// src/generated-definitions/GameSessionSetting.ts
import { z } from "zod";
var GameSessionSetting = z.object({
  allow_join_in_progress: z.boolean(),
  current_internal_player: z.number().int(),
  current_player: z.number().int(),
  map_name: z.string(),
  max_internal_player: z.number().int(),
  max_player: z.number().int(),
  mode: z.string(),
  num_bot: z.number().int(),
  password: z.string(),
  settings: z.record(z.any()).nullish()
});

// src/generated-definitions/StatusHistory.ts
import { z as z2 } from "zod";
var StatusHistory = z2.object({ status: z2.string(), time_stamp: z2.string() });

// src/generated-definitions/Server.ts
import { z as z3 } from "zod";
var Server = z3.object({
  allocation_id: z3.string(),
  alternate_ips: z3.array(z3.string()).nullish(),
  cpu_limit: z3.number().int(),
  cpu_request: z3.string(),
  deployment: z3.string(),
  game_version: z3.string(),
  image_version: z3.string(),
  ip: z3.string(),
  is_override_game_version: z3.boolean(),
  last_update: z3.string(),
  mem_limit: z3.number().int(),
  mem_request: z3.string(),
  namespace: z3.string(),
  params: z3.string(),
  pod_name: z3.string(),
  port: z3.number().int(),
  ports: z3.record(z3.number().int()).nullish(),
  provider: z3.string(),
  region: z3.string(),
  session_id: z3.string(),
  status: z3.string(),
  status_history: z3.array(StatusHistory).nullish()
});

// src/generated-definitions/CustomGameResponse.ts
import { z as z4 } from "zod";
var CustomGameResponse = z4.object({
  all_players: z4.array(z4.string()).nullish(),
  created_at: z4.string(),
  game_session_setting: GameSessionSetting.nullish(),
  joinable: z4.boolean(),
  namespace: z4.string(),
  players: z4.array(z4.string()).nullish(),
  server: Server.nullish(),
  session_id: z4.string(),
  session_type: z4.string(),
  spectators: z4.array(z4.string()).nullish()
});

// src/generated-definitions/PagingCursor.ts
import { z as z5 } from "zod";
var PagingCursor = z5.object({ next: z5.string(), previous: z5.string() });

// src/generated-definitions/ActiveCustomGameResponse.ts
import { z as z6 } from "zod";
var ActiveCustomGameResponse = z6.object({ pagination: PagingCursor, sessions: z6.array(CustomGameResponse) });

// src/generated-definitions/MatchAttributes.ts
import { z as z7 } from "zod";
var MatchAttributes = z7.object({ first_ticket_created_at: z7.number().int() });

// src/generated-definitions/PartyMember.ts
import { z as z8 } from "zod";
var PartyMember = z8.object({ extra_attributes: z8.record(z8.any()).nullish(), user_id: z8.string() });

// src/generated-definitions/MatchingParty.ts
import { z as z9 } from "zod";
var MatchingParty = z9.object({
  match_attributes: MatchAttributes.nullish(),
  party_attributes: z9.record(z9.any()).nullish(),
  party_id: z9.string(),
  party_members: z9.array(PartyMember).nullish()
});

// src/generated-definitions/MatchingAlly.ts
import { z as z10 } from "zod";
var MatchingAlly = z10.object({ matching_parties: z10.array(MatchingParty).nullish() });

// src/generated-definitions/MatchMaking.ts
import { z as z11 } from "zod";
var MatchMaking = z11.object({
  channel: z11.string(),
  client_version: z11.string(),
  created_at: z11.string(),
  deployment: z11.string(),
  event: z11.string(),
  game_mode: z11.string(),
  joinable: z11.boolean().nullish(),
  match_id: z11.string(),
  matching_allies: z11.array(MatchingAlly).nullish(),
  namespace: z11.string(),
  party_attributes: z11.record(z11.any()),
  party_id: z11.string().nullish(),
  queued_at: z11.number().int(),
  region: z11.string(),
  server_name: z11.string(),
  status: z11.string(),
  sub_game_mode: z11.array(z11.string()).nullish()
});

// src/generated-definitions/GameSession.ts
import { z as z12 } from "zod";
var GameSession = z12.object({
  all_players: z12.array(z12.string()).nullish(),
  created_at: z12.string(),
  game_session_setting: GameSessionSetting.nullish(),
  game_version: z12.string(),
  joinable: z12.boolean(),
  match: MatchMaking.nullish(),
  namespace: z12.string(),
  players: z12.array(z12.string()).nullish(),
  server: Server,
  session_id: z12.string(),
  session_type: z12.string(),
  spectators: z12.array(z12.string()).nullish(),
  user_id: z12.string(),
  username: z12.string()
});

// src/generated-definitions/ActiveMatchmakingGameResponse.ts
import { z as z13 } from "zod";
var ActiveMatchmakingGameResponse = z13.object({ pagination: PagingCursor, sessions: z13.array(GameSession).nullish() });

// src/generated-definitions/AdminSessionResponse.ts
import { z as z14 } from "zod";
var AdminSessionResponse = z14.object({
  all_players: z14.array(z14.string()),
  created_at: z14.string(),
  game_session_setting: GameSessionSetting.nullish(),
  game_version: z14.string(),
  joinable: z14.boolean(),
  match: MatchMaking.nullish(),
  namespace: z14.string(),
  players: z14.array(z14.string()),
  server: Server,
  session_id: z14.string(),
  session_type: z14.string(),
  spectators: z14.array(z14.string()),
  user_id: z14.string(),
  username: z14.string()
});

// src/generated-definitions/CountActiveSessionResponse.ts
import { z as z15 } from "zod";
var CountActiveSessionResponse = z15.object({
  custom_game: z15.number().int(),
  matchmaking_game: z15.number().int(),
  total: z15.number().int()
});

// src/generated-definitions/SessionPlayerHistory.ts
import { z as z16 } from "zod";
var SessionPlayerHistory = z16.object({ Action: z16.string(), Date: z16.string(), UserID: z16.string() });

// src/generated-definitions/SessionPlayerJoining.ts
import { z as z17 } from "zod";
var SessionPlayerJoining = z17.object({ Date: z17.string(), State: z17.string(), UserID: z17.string() });

// src/generated-definitions/GetSessionHistoryDetailedResponseItem.ts
import { z as z18 } from "zod";
var GetSessionHistoryDetailedResponseItem = z18.object({
  _id: z18.string(),
  channel: z18.string(),
  client_version: z18.string(),
  created_at: z18.string(),
  event_description: z18.string(),
  event_name: z18.string(),
  game_mode: z18.string(),
  joinable: z18.boolean(),
  joining: z18.array(SessionPlayerJoining).nullish(),
  match_id: z18.string(),
  matching_allies: z18.array(MatchingAlly).nullish(),
  namespace: z18.string(),
  party_id: z18.string().nullish(),
  players: z18.array(SessionPlayerHistory).nullish(),
  region: z18.string(),
  removed_reason: z18.string(),
  server_name: z18.string(),
  session_type: z18.string(),
  status: z18.string(),
  user_id: z18.string()
});

// src/generated-definitions/GetSessionHistoryDetailedResponseItemArray.ts
import { z as z19 } from "zod";
var GetSessionHistoryDetailedResponseItemArray = z19.array(GetSessionHistoryDetailedResponseItem);

// src/generated-definitions/GetSessionHistorySearchResponseItemV2.ts
import { z as z20 } from "zod";
var GetSessionHistorySearchResponseItemV2 = z20.object({
  _id: z20.string(),
  created_at: z20.string(),
  game_mode: z20.string(),
  joinable: z20.boolean(),
  joining: z20.array(SessionPlayerJoining).nullish(),
  match_id: z20.string(),
  namespace: z20.string(),
  players: z20.array(SessionPlayerHistory).nullish(),
  removed_reason: z20.string(),
  session_type: z20.string(),
  status: z20.string(),
  sub_game_mode: z20.array(z20.string()).nullish(),
  user_id: z20.string()
});

// src/generated-definitions/Pagination.ts
import { z as z21 } from "zod";
var Pagination = z21.object({ first: z21.string(), last: z21.string(), next: z21.string(), previous: z21.string() });

// src/generated-definitions/GetSessionHistorySearchResponseV2.ts
import { z as z22 } from "zod";
var GetSessionHistorySearchResponseV2 = z22.object({ data: z22.array(GetSessionHistorySearchResponseItemV2), pagination: Pagination });

// src/generated-definitions/SessionQueryResponse.ts
import { z as z23 } from "zod";
var SessionQueryResponse = z23.object({ pagination: PagingCursor, sessions: z23.array(GameSession) });

// src/generated-admin/endpoints/SessionAdmin$.ts
import { Validate } from "@accelbyte/sdk";
var SessionAdmin$ = class {
  // @ts-ignore
  // prettier-ignore
  constructor(axiosInstance, namespace, useSchemaValidation = true) {
    this.axiosInstance = axiosInstance;
    this.namespace = namespace;
    this.useSchemaValidation = useSchemaValidation;
  }
  /**
   * Query to available game session
   */
  getGamesession(queryParams) {
    const params = { limit: 25, ...queryParams };
    const url = "/sessionbrowser/admin/namespaces/{namespace}/gamesession".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.get(url, { params });
    return Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, SessionQueryResponse, "SessionQueryResponse");
  }
  /**
   * Admin delete the session by session ID
   */
  deleteGamesession_BySessionId(sessionID) {
    const params = {};
    const url = "/sessionbrowser/admin/namespaces/{namespace}/gamesession/{sessionID}".replace("{namespace}", this.namespace).replace("{sessionID}", sessionID);
    const resultPromise = this.axiosInstance.delete(url, { params });
    return Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, AdminSessionResponse, "AdminSessionResponse");
  }
  /**
   * Get the session by session ID for admin user
   */
  getGamesession_BySessionId(sessionID) {
    const params = {};
    const url = "/sessionbrowser/admin/namespaces/{namespace}/gamesession/{sessionID}".replace("{namespace}", this.namespace).replace("{sessionID}", sessionID);
    const resultPromise = this.axiosInstance.get(url, { params });
    return Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, AdminSessionResponse, "AdminSessionResponse");
  }
  /**
   * Search sessions. Optimize the query by differentiating query with filter namespace only and filter with namespace &amp; other filter (partyID, userID, matchID). Query with filter namespace only will not group whole session data while query with filter namespace &amp; other filter will include session data.
   */
  getSessionsHistorySearch(queryParams) {
    const params = { ...queryParams };
    const url = "/sessionbrowser/admin/namespaces/{namespace}/sessions/history/search".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.get(url, { params });
    return Validate.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      GetSessionHistorySearchResponseV2,
      "GetSessionHistorySearchResponseV2"
    );
  }
  /**
   * Get all active session
   */
  getGamesessionActiveCount(queryParams) {
    const params = { ...queryParams };
    const url = "/sessionbrowser/admin/namespaces/{namespace}/gamesession/active/count".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.get(url, { params });
    return Validate.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      CountActiveSessionResponse,
      "CountActiveSessionResponse"
    );
  }
  /**
   * Get all active session for custom game, this return only dedicated session type
   */
  getGamesessionActiveCustomGame(queryParams) {
    const params = { limit: 25, ...queryParams };
    const url = "/sessionbrowser/admin/namespaces/{namespace}/gamesession/active/custom-game".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.get(url, { params });
    return Validate.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      ActiveCustomGameResponse,
      "ActiveCustomGameResponse"
    );
  }
  /**
   * Get all active session for matchmaking game, this return only dedicated session type
   */
  getGamesessionActiveMatchmakingGame(queryParams) {
    const params = { limit: 25, ...queryParams };
    const url = "/sessionbrowser/admin/namespaces/{namespace}/gamesession/active/matchmaking-game".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.get(url, { params });
    return Validate.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      ActiveMatchmakingGameResponse,
      "ActiveMatchmakingGameResponse"
    );
  }
  /**
   * Get session history detailed. if party_id value empty/null, field will not show in response body.
   */
  getHistoryDetailed_ByMatchId(matchID) {
    const params = {};
    const url = "/sessionbrowser/admin/namespaces/{namespace}/sessions/{matchID}/history/detailed".replace("{namespace}", this.namespace).replace("{matchID}", matchID);
    const resultPromise = this.axiosInstance.get(url, { params });
    return Validate.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      GetSessionHistoryDetailedResponseItemArray,
      "GetSessionHistoryDetailedResponseItemArray"
    );
  }
};

// src/generated-admin/SessionAdminApi.ts
import { ApiUtils, Network } from "@accelbyte/sdk";
function SessionAdminApi(sdk, args) {
  const sdkAssembly = sdk.assembly();
  const namespace = args?.coreConfig?.namespace ?? sdkAssembly.coreConfig.namespace;
  const useSchemaValidation = args?.coreConfig?.useSchemaValidation ?? sdkAssembly.coreConfig.useSchemaValidation;
  let axiosInstance = sdkAssembly.axiosInstance;
  const requestConfigOverrides = args?.axiosConfig?.request;
  const baseURLOverride = args?.coreConfig?.baseURL;
  const interceptorsOverride = args?.axiosConfig?.interceptors ?? [];
  if (requestConfigOverrides || baseURLOverride || interceptorsOverride.length > 0) {
    const requestConfig = ApiUtils.mergeAxiosConfigs(sdkAssembly.axiosInstance.defaults, {
      ...baseURLOverride ? { baseURL: baseURLOverride } : {},
      ...requestConfigOverrides
    });
    axiosInstance = Network.create(requestConfig);
    for (const interceptor of interceptorsOverride) {
      if (interceptor.type === "request") {
        axiosInstance.interceptors.request.use(interceptor.onRequest, interceptor.onError);
      }
      if (interceptor.type === "response") {
        axiosInstance.interceptors.response.use(interceptor.onSuccess, interceptor.onError);
      }
    }
  }
  async function getGamesession(queryParams) {
    const $ = new SessionAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getGamesession(queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function deleteGamesession_BySessionId(sessionID) {
    const $ = new SessionAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.deleteGamesession_BySessionId(sessionID);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getGamesession_BySessionId(sessionID) {
    const $ = new SessionAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getGamesession_BySessionId(sessionID);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getSessionsHistorySearch(queryParams) {
    const $ = new SessionAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getSessionsHistorySearch(queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getGamesessionActiveCount(queryParams) {
    const $ = new SessionAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getGamesessionActiveCount(queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getGamesessionActiveCustomGame(queryParams) {
    const $ = new SessionAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getGamesessionActiveCustomGame(queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getGamesessionActiveMatchmakingGame(queryParams) {
    const $ = new SessionAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getGamesessionActiveMatchmakingGame(queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getHistoryDetailed_ByMatchId(matchID) {
    const $ = new SessionAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getHistoryDetailed_ByMatchId(matchID);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  return {
    /**
     * Query to available game session
     */
    getGamesession,
    /**
     * Admin delete the session by session ID
     */
    deleteGamesession_BySessionId,
    /**
     * Get the session by session ID for admin user
     */
    getGamesession_BySessionId,
    /**
     * Search sessions. Optimize the query by differentiating query with filter namespace only and filter with namespace &amp; other filter (partyID, userID, matchID). Query with filter namespace only will not group whole session data while query with filter namespace &amp; other filter will include session data.
     */
    getSessionsHistorySearch,
    /**
     * Get all active session
     */
    getGamesessionActiveCount,
    /**
     * Get all active session for custom game, this return only dedicated session type
     */
    getGamesessionActiveCustomGame,
    /**
     * Get all active session for matchmaking game, this return only dedicated session type
     */
    getGamesessionActiveMatchmakingGame,
    /**
     * Get session history detailed. if party_id value empty/null, field will not show in response body.
     */
    getHistoryDetailed_ByMatchId
  };
}

// src/generated-definitions/AddPlayerResponse.ts
import { z as z24 } from "zod";
var AddPlayerResponse = z24.object({ status: z24.boolean() });

// src/generated-definitions/RecentPlayerHistory.ts
import { z as z25 } from "zod";
var RecentPlayerHistory = z25.object({
  created_at: z25.string(),
  namespace: z25.string(),
  other_display_name: z25.string(),
  other_id: z25.string(),
  updated_at: z25.string(),
  user_id: z25.string()
});

// src/generated-definitions/RecentPlayerQueryResponse.ts
import { z as z26 } from "zod";
var RecentPlayerQueryResponse = z26.object({ data: z26.array(RecentPlayerHistory) });

// src/generated-definitions/SessionByUserIDsResponse.ts
import { z as z27 } from "zod";
var SessionByUserIDsResponse = z27.object({ data: z27.array(GameSession) });

// src/generated-definitions/SessionResponse.ts
import { z as z28 } from "zod";
var SessionResponse = z28.object({
  all_players: z28.array(z28.string()),
  created_at: z28.string(),
  game_session_setting: GameSessionSetting,
  game_version: z28.string(),
  joinable: z28.boolean(),
  match: MatchMaking,
  namespace: z28.string(),
  players: z28.array(z28.string()),
  server: Server,
  session_id: z28.string(),
  session_type: z28.string(),
  spectators: z28.array(z28.string()),
  user_id: z28.string(),
  username: z28.string()
});

// src/generated-public/endpoints/Session$.ts
import { Validate as Validate2 } from "@accelbyte/sdk";
var Session$ = class {
  // @ts-ignore
  // prettier-ignore
  constructor(axiosInstance, namespace, useSchemaValidation = true) {
    this.axiosInstance = axiosInstance;
    this.namespace = namespace;
    this.useSchemaValidation = useSchemaValidation;
  }
  /**
   * Query available game session
   */
  getGamesession(queryParams) {
    const params = { limit: 25, ...queryParams };
    const url = "/sessionbrowser/namespaces/{namespace}/gamesession".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.get(url, { params });
    return Validate2.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, SessionQueryResponse, "SessionQueryResponse");
  }
  /**
   * This end point intended to be called directly by P2P game client host or by DSMC
   */
  createGamesession(data) {
    const params = {};
    const url = "/sessionbrowser/namespaces/{namespace}/gamesession".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.post(url, data, { params });
    return Validate2.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, SessionResponse, "SessionResponse");
  }
  /**
   * Query game sessions by comma separated user ids
   */
  getGamesessionBulk(queryParams) {
    const params = { ...queryParams };
    const url = "/sessionbrowser/namespaces/{namespace}/gamesession/bulk".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.get(url, { params });
    return Validate2.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      SessionByUserIDsResponse,
      "SessionByUserIDsResponse"
    );
  }
  /**
   * Query recent player by user ID
   */
  getRecentplayer_ByUserId(userID) {
    const params = {};
    const url = "/sessionbrowser/namespaces/{namespace}/recentplayer/{userID}".replace("{namespace}", this.namespace).replace("{userID}", userID);
    const resultPromise = this.axiosInstance.get(url, { params });
    return Validate2.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      RecentPlayerQueryResponse,
      "RecentPlayerQueryResponse"
    );
  }
  /**
   * Delete the session (p2p) by session ID
   */
  deleteGamesession_BySessionId(sessionID) {
    const params = {};
    const url = "/sessionbrowser/namespaces/{namespace}/gamesession/{sessionID}".replace("{namespace}", this.namespace).replace("{sessionID}", sessionID);
    const resultPromise = this.axiosInstance.delete(url, { params });
    return Validate2.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, SessionResponse, "SessionResponse");
  }
  /**
   * Get the session by session ID
   */
  getGamesession_BySessionId(sessionID) {
    const params = {};
    const url = "/sessionbrowser/namespaces/{namespace}/gamesession/{sessionID}".replace("{namespace}", this.namespace).replace("{sessionID}", sessionID);
    const resultPromise = this.axiosInstance.get(url, { params });
    return Validate2.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, SessionResponse, "SessionResponse");
  }
  /**
   * Update game session, used to update the current player
   */
  updateGamesession_BySessionId(sessionID, data) {
    const params = {};
    const url = "/sessionbrowser/namespaces/{namespace}/gamesession/{sessionID}".replace("{namespace}", this.namespace).replace("{sessionID}", sessionID);
    const resultPromise = this.axiosInstance.put(url, data, { params });
    return Validate2.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, SessionResponse, "SessionResponse");
  }
  /**
   * Join the specified session by session ID. Possible the game required a password to join
   */
  fetchJoin_BySessionId(sessionID, data) {
    const params = {};
    const url = "/sessionbrowser/namespaces/{namespace}/gamesession/{sessionID}/join".replace("{namespace}", this.namespace).replace("{sessionID}", sessionID);
    const resultPromise = this.axiosInstance.post(url, data, { params });
    return Validate2.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, SessionResponse, "SessionResponse");
  }
  /**
   * Add player to game session
   */
  updatePlayer_BySessionId(sessionID, data) {
    const params = {};
    const url = "/sessionbrowser/namespaces/{namespace}/gamesession/{sessionID}/player".replace("{namespace}", this.namespace).replace("{sessionID}", sessionID);
    const resultPromise = this.axiosInstance.post(url, data, { params });
    return Validate2.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, AddPlayerResponse, "AddPlayerResponse");
  }
  /**
   * Only use for local DS entry, will error when calling non local DS entry
   */
  deleteLocald_BySessionId(sessionID) {
    const params = {};
    const url = "/sessionbrowser/namespaces/{namespace}/gamesession/{sessionID}/localds".replace("{namespace}", this.namespace).replace("{sessionID}", sessionID);
    const resultPromise = this.axiosInstance.delete(url, { params });
    return Validate2.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, SessionResponse, "SessionResponse");
  }
  /**
   * Update game session, used to update OtherSettings
   */
  updateSetting_BySessionId(sessionID, data) {
    const params = {};
    const url = "/sessionbrowser/namespaces/{namespace}/gamesession/{sessionID}/settings".replace("{namespace}", this.namespace).replace("{sessionID}", sessionID);
    const resultPromise = this.axiosInstance.put(url, data, { params });
    return Validate2.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, SessionResponse, "SessionResponse");
  }
  /**
   * Remove player from game session
   */
  deletePlayer_BySessionId_ByUserId(sessionID, userID) {
    const params = {};
    const url = "/sessionbrowser/namespaces/{namespace}/gamesession/{sessionID}/player/{userID}".replace("{namespace}", this.namespace).replace("{sessionID}", sessionID).replace("{userID}", userID);
    const resultPromise = this.axiosInstance.delete(url, { params });
    return Validate2.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, AddPlayerResponse, "AddPlayerResponse");
  }
};

// src/generated-public/SessionApi.ts
import { ApiUtils as ApiUtils2, Network as Network2 } from "@accelbyte/sdk";
function SessionApi(sdk, args) {
  const sdkAssembly = sdk.assembly();
  const namespace = args?.coreConfig?.namespace ?? sdkAssembly.coreConfig.namespace;
  const useSchemaValidation = args?.coreConfig?.useSchemaValidation ?? sdkAssembly.coreConfig.useSchemaValidation;
  let axiosInstance = sdkAssembly.axiosInstance;
  const requestConfigOverrides = args?.axiosConfig?.request;
  const baseURLOverride = args?.coreConfig?.baseURL;
  const interceptorsOverride = args?.axiosConfig?.interceptors ?? [];
  if (requestConfigOverrides || baseURLOverride || interceptorsOverride.length > 0) {
    const requestConfig = ApiUtils2.mergeAxiosConfigs(sdkAssembly.axiosInstance.defaults, {
      ...baseURLOverride ? { baseURL: baseURLOverride } : {},
      ...requestConfigOverrides
    });
    axiosInstance = Network2.create(requestConfig);
    for (const interceptor of interceptorsOverride) {
      if (interceptor.type === "request") {
        axiosInstance.interceptors.request.use(interceptor.onRequest, interceptor.onError);
      }
      if (interceptor.type === "response") {
        axiosInstance.interceptors.response.use(interceptor.onSuccess, interceptor.onError);
      }
    }
  }
  async function getGamesession(queryParams) {
    const $ = new Session$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getGamesession(queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function createGamesession(data) {
    const $ = new Session$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.createGamesession(data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getGamesessionBulk(queryParams) {
    const $ = new Session$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getGamesessionBulk(queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getRecentplayer_ByUserId(userID) {
    const $ = new Session$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getRecentplayer_ByUserId(userID);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function deleteGamesession_BySessionId(sessionID) {
    const $ = new Session$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.deleteGamesession_BySessionId(sessionID);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getGamesession_BySessionId(sessionID) {
    const $ = new Session$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getGamesession_BySessionId(sessionID);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function updateGamesession_BySessionId(sessionID, data) {
    const $ = new Session$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.updateGamesession_BySessionId(sessionID, data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function fetchJoin_BySessionId(sessionID, data) {
    const $ = new Session$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.fetchJoin_BySessionId(sessionID, data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function updatePlayer_BySessionId(sessionID, data) {
    const $ = new Session$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.updatePlayer_BySessionId(sessionID, data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function deleteLocald_BySessionId(sessionID) {
    const $ = new Session$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.deleteLocald_BySessionId(sessionID);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function updateSetting_BySessionId(sessionID, data) {
    const $ = new Session$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.updateSetting_BySessionId(sessionID, data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function deletePlayer_BySessionId_ByUserId(sessionID, userID) {
    const $ = new Session$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.deletePlayer_BySessionId_ByUserId(sessionID, userID);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  return {
    /**
     * Query available game session
     */
    getGamesession,
    /**
     * This end point intended to be called directly by P2P game client host or by DSMC
     */
    createGamesession,
    /**
     * Query game sessions by comma separated user ids
     */
    getGamesessionBulk,
    /**
     * Query recent player by user ID
     */
    getRecentplayer_ByUserId,
    /**
     * Delete the session (p2p) by session ID
     */
    deleteGamesession_BySessionId,
    /**
     * Get the session by session ID
     */
    getGamesession_BySessionId,
    /**
     * Update game session, used to update the current player
     */
    updateGamesession_BySessionId,
    /**
     * Join the specified session by session ID. Possible the game required a password to join
     */
    fetchJoin_BySessionId,
    /**
     * Add player to game session
     */
    updatePlayer_BySessionId,
    /**
     * Only use for local DS entry, will error when calling non local DS entry
     */
    deleteLocald_BySessionId,
    /**
     * Update game session, used to update OtherSettings
     */
    updateSetting_BySessionId,
    /**
     * Remove player from game session
     */
    deletePlayer_BySessionId_ByUserId
  };
}

export {
  GameSessionSetting,
  StatusHistory,
  Server,
  CustomGameResponse,
  PagingCursor,
  ActiveCustomGameResponse,
  MatchAttributes,
  PartyMember,
  MatchingParty,
  MatchingAlly,
  MatchMaking,
  GameSession,
  ActiveMatchmakingGameResponse,
  AdminSessionResponse,
  CountActiveSessionResponse,
  SessionPlayerHistory,
  SessionPlayerJoining,
  GetSessionHistoryDetailedResponseItem,
  GetSessionHistoryDetailedResponseItemArray,
  GetSessionHistorySearchResponseItemV2,
  Pagination,
  GetSessionHistorySearchResponseV2,
  SessionQueryResponse,
  SessionAdmin$,
  SessionAdminApi,
  AddPlayerResponse,
  RecentPlayerHistory,
  RecentPlayerQueryResponse,
  SessionByUserIDsResponse,
  SessionResponse,
  Session$,
  SessionApi
};

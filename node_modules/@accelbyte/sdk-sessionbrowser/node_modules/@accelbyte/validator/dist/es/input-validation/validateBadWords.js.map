{"version":3,"sources":["../../../src/input-validation/validateBadWords.ts"],"names":["value","isBadWord"],"mappings":"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","file":"validateBadWords.js","sourcesContent":["/*\n * Copyright (c) 2020-2023 AccelByte Inc. All Rights Reserved\n * This is licensed software from AccelByte Inc, for limitations\n * and restrictions contact your company contract manager.\n */\n\nimport * as naughtyWords from 'naughty-words'\nimport isEmpty from 'validator/lib/isEmpty.js'\nimport { z } from 'zod'\nimport enExtra from './constant/badWords/en.json'\nimport { CommonValidationErrorType } from './constant/errorType'\n\nexport const ValidateBadWordsErrorType = z.enum([CommonValidationErrorType.enum.empty, CommonValidationErrorType.enum.containsBadWords])\nexport type ValidateBadWordsErrorType = z.infer<typeof ValidateBadWordsErrorType>\n\ninterface ValidateBadWordsOptions {\n  isRequired?: boolean\n  matchingMode?: 'exact' | 'contain'\n  languageCode?: Array<keyof typeof localizedBadWords> | keyof typeof localizedBadWords | '*'\n}\n\nconst localizedBadWords = {\n  ar: naughtyWords.ar,\n  cs: naughtyWords.cs,\n  da: naughtyWords.da,\n  de: naughtyWords.de,\n  en: naughtyWords.en.concat(enExtra),\n  eo: naughtyWords.eo,\n  es: naughtyWords.es,\n  fa: naughtyWords.fa,\n  fi: naughtyWords.fi,\n  fil: naughtyWords.fil,\n  fr: naughtyWords.fr,\n  hi: naughtyWords.hi,\n  hu: naughtyWords.hu,\n  it: naughtyWords.it,\n  ja: naughtyWords.ja,\n  kab: naughtyWords.kab,\n  ko: naughtyWords.ko,\n  nl: naughtyWords.nl,\n  no: naughtyWords.no,\n  pl: naughtyWords.pl,\n  pt: naughtyWords.pt,\n  ru: naughtyWords.ru,\n  sv: naughtyWords.sv,\n  th: naughtyWords.th,\n  tlh: naughtyWords.tlh,\n  tr: naughtyWords.tr,\n  zh: naughtyWords.zh\n}\n\n/**\n *\n * @param value\n * @param isRequired\n * @param languageCode (string \"*\") or ValidateBadWordsLanguageCode.keys or ValidateBadWordsLanguageCode.keys[]\n * @param matchingMode (string \"exact\" | \"contain\")\n * @default languageCode en\n * @default matchingMode contain\n */\nconst validateBadWords = (\n  value: string,\n  { isRequired = true, languageCode = 'en', matchingMode = 'contain' }: ValidateBadWordsOptions = {}\n) => {\n  if (isEmpty(value) && isRequired) {\n    return ValidateBadWordsErrorType.enum.empty\n  }\n\n  if (languageCode === '*') {\n    const filteredBadWord = Object.values(localizedBadWords).find(badWords => isBadWord(badWords, value, matchingMode))\n    if (!!filteredBadWord && !!filteredBadWord.length) {\n      return ValidateBadWordsErrorType.enum.containsBadWords\n    }\n  } else if (Array.isArray(languageCode)) {\n    const filteredBadWord = languageCode.find(code => isBadWord(localizedBadWords[code] || [], value, matchingMode))\n    if (filteredBadWord) {\n      return ValidateBadWordsErrorType.enum.containsBadWords\n    }\n  } else {\n    if (isBadWord(localizedBadWords[languageCode] || [], value, matchingMode)) {\n      return ValidateBadWordsErrorType.enum.containsBadWords\n    }\n  }\n  return null\n}\n\n/**\n * Tokenize and then validate bad word. The tokenizer will separate the value by\n * treating non alphanumeric character as separator.\n *\n * @param value the input value to be validate\n */\nexport function tokenizeAndValidateBadWords(value: string) {\n  const matchSpecialCharacters = /[-!$%^&*()_+|~=`{}[\\]:/;<>?,.@#]/g\n  const sanitezedValue = value.replace(matchSpecialCharacters, ' ')\n  const tokenizedValue = sanitezedValue.split(' ').filter(value => !!value)\n\n  for (let i = 0; i < tokenizedValue.length; i++) {\n    const isBadWord = validateBadWords(tokenizedValue[i], { isRequired: false, languageCode: '*', matchingMode: 'exact' })\n    if (isBadWord) return ValidateBadWordsErrorType.enum.containsBadWords\n  }\n\n  return null\n}\n\nfunction isBadWord(badWords: string[], word: string, matchingMode: string) {\n  const noRepeatedChar = word.replace(/[^\\w\\s]|(.)(?=\\1)/gi, '').toLowerCase()\n  const noSpecialChar = word.replace(/[^a-zA-Z0-9 :]/gi, '').toLowerCase()\n  const lowerCase = word.toLowerCase()\n  const words = [lowerCase, noRepeatedChar, noSpecialChar]\n  return words.some(value => doesBadWordsContainWord(badWords, value, matchingMode))\n}\n\nfunction doesBadWordsContainWord(badWords: string[], word: string, matchingMode: string) {\n  switch (matchingMode) {\n    case 'exact':\n      return badWords.includes(word)\n    default:\n      return badWords.includes(word) || badWords.some((badWord: string) => word.includes(badWord))\n  }\n}\n"]}
import { AxiosRequestConfig, InternalAxiosRequestConfig, AxiosResponse, AxiosInstance, AxiosError } from 'axios';
import { ZodTypeAny, z, ZodError } from 'zod';

type MakeOptional<Type, UnionKeys extends keyof Type> = Omit<Type, UnionKeys> & Partial<Pick<Type, UnionKeys>>;
type MakeRequired<T, K extends keyof T> = T & {
    [P in K]-?: T[P];
};
declare function isType<T extends ZodTypeAny>(schema: T, data: unknown): data is z.infer<T>;

interface CoreConfig {
    /**
     * The client ID for the SDK. This value is retrieved from Admin Portal, OAuth Clients.
     */
    clientId: string;
    /**
     * The redirect URI after logging in. This is used to generate the valid login URL to IAM.
     * This value is retrieved from Admin Portal, OAuth Clients.
     */
    redirectURI: string;
    /**
     * The base URL of your AGS deployment.
     */
    baseURL: string;
    /**
     * The namespace of your AGS deployment.
     */
    namespace: string;
    /**
     * When "false" is provided, the SDK bypasses Zod Schema Validation.
     * Default is "true".
     */
    useSchemaValidation: boolean;
}
interface AxiosConfig {
    interceptors?: Interceptor[];
    request?: AxiosRequestConfig;
}
interface WebSocketConfig {
    /**
     * Allow reconnect when upstream is abruptly disconnected.
     * @default true
     */
    allowReconnect?: boolean;
    /**
     * Maximum number of reconnect attempts. Positive value integer.
     * Set 0 for unlimited attempts.
     * @default 0
     */
    maxReconnectAttempts?: number;
}
type Interceptor = {
    type: 'request';
    name: string;
    onRequest?: (config: InternalAxiosRequestConfig) => InternalAxiosRequestConfig | Promise<InternalAxiosRequestConfig>;
    onError?: (error: unknown) => unknown;
} | {
    type: 'response';
    name: string;
    onSuccess?: (response: AxiosResponse<unknown>) => AxiosResponse<unknown>;
    onError?: (error: unknown) => unknown;
};
interface SdkConstructorParam {
    coreConfig: MakeOptional<CoreConfig, 'useSchemaValidation'>;
    axiosConfig?: AxiosConfig;
    webSocketConfig?: WebSocketConfig;
}
interface SdkSetConfigParam {
    coreConfig?: Partial<CoreConfig>;
    axiosConfig?: AxiosConfig;
    webSocketConfig?: WebSocketConfig;
}
type ApiError = {
    errorCode: number | string;
    errorMessage: string;
};
type TokenConfig = {
    accessToken?: string;
    refreshToken?: string | null;
};

declare const AccelByte: {
    SDK: (param: SdkConstructorParam) => AccelByteSDK;
};
declare class AccelByteSDK {
    private coreConfig;
    private axiosConfig;
    private axiosInstance;
    private webSocketConfig;
    private token;
    constructor({ coreConfig, axiosConfig, webSocketConfig }: SdkConstructorParam);
    private createAxiosInstance;
    /**
     * Assembles and returns the current Axios instance along with core and Axios configurations.
     */
    assembly(): {
        axiosInstance: AxiosInstance;
        coreConfig: CoreConfig;
        axiosConfig: MakeRequired<AxiosConfig, "request">;
        webSocketConfig: WebSocketConfig;
    };
    /**
     * Creates a new instance of AccelByteSDK with a shallow copy of the current configurations.
     * Optionally allows excluding interceptors.
     * @param {boolean} [opts.interceptors] - Whether to include interceptors in the clone. Default is true.
     * @returns {AccelByteSDK} A new instance of AccelByteSDK with the cloned configuration.
     */
    clone(opts?: {
        interceptors?: boolean;
    }): AccelByteSDK;
    /**
     * Adds interceptors to the current Axios configuration.
     */
    addInterceptors(interceptors: Interceptor[]): AccelByteSDK;
    /**
     * Removes interceptors from the Axios configuration. Can remove all interceptors or filter specific ones.
     * @param {function} [filterCallback] - Optional filter function to remove specific interceptors.
     */
    removeInterceptors(): AccelByteSDK;
    removeInterceptors(filterCallback: (interceptor: Interceptor) => boolean): AccelByteSDK;
    /**
     * Updates the SDK's core and Axios configurations.
     * Merges the provided configurations with the current ones.
     */
    setConfig({ coreConfig, axiosConfig, webSocketConfig }: SdkSetConfigParam): this;
    /**
     * Set accessToken and refreshToken and updates the Axios request headers to use Bearer authentication.
     */
    setToken(token: TokenConfig): void;
    /**
     * Removes the currently set token.
     */
    removeToken(): void;
    /**
     * Retrieves the current token configuration.
     */
    getToken(): TokenConfig;
}

declare enum IamErrorCode {
    InternalServerError = 20000,
    UnauthorizedAccess = 20001,
    ValidationError = 20002,
    ForbiddenAccess = 20003,
    TooManyRequests = 20007,
    UserNotFound = 20008,
    TokenIsExpired = 20011,
    InsufficientPermissions = 20013,
    InvalidAudience = 20014,
    InsufficientScope = 20015,
    UnableToParseRequestBody = 20019,
    InvalidPaginationParameters = 20021,
    TokenIsNotUserToken = 20022,
    InvalidRefererHeader = 20023,
    SubdomainMismatch = 20030
}

declare const ERROR_LINK_ANOTHER_3RD_PARTY_ACCOUNT = 10200;
declare const ERROR_CODE_LINK_DELETION_ACCOUNT = 10135;
declare const ERROR_CODE_TOKEN_EXPIRED = 10196;
declare const ERROR_USER_BANNED = 10134;

declare const TokenWithDeviceCookieResponseV3: z.ZodObject<{
    access_token: z.ZodString;
    auth_trust_id: z.ZodOptional<z.ZodNullable<z.ZodString>>;
    bans: z.ZodOptional<z.ZodNullable<z.ZodArray<z.ZodObject<{
        ban: z.ZodString;
        disabledDate: z.ZodOptional<z.ZodNullable<z.ZodString>>;
        enabled: z.ZodBoolean;
        endDate: z.ZodString;
        targetedNamespace: z.ZodString;
    }, "strip", z.ZodTypeAny, {
        ban: string;
        enabled: boolean;
        endDate: string;
        targetedNamespace: string;
        disabledDate?: string | null | undefined;
    }, {
        ban: string;
        enabled: boolean;
        endDate: string;
        targetedNamespace: string;
        disabledDate?: string | null | undefined;
    }>, "many">>>;
    display_name: z.ZodOptional<z.ZodNullable<z.ZodString>>;
    expires_in: z.ZodNumber;
    is_comply: z.ZodOptional<z.ZodNullable<z.ZodBoolean>>;
    jflgs: z.ZodOptional<z.ZodNullable<z.ZodNumber>>;
    namespace: z.ZodString;
    namespace_roles: z.ZodOptional<z.ZodNullable<z.ZodArray<z.ZodObject<{
        namespace: z.ZodString;
        roleId: z.ZodString;
    }, "strip", z.ZodTypeAny, {
        namespace: string;
        roleId: string;
    }, {
        namespace: string;
        roleId: string;
    }>, "many">>>;
    permissions: z.ZodArray<z.ZodObject<{
        action: z.ZodNumber;
        resource: z.ZodString;
        schedAction: z.ZodOptional<z.ZodNullable<z.ZodNumber>>;
        schedCron: z.ZodOptional<z.ZodNullable<z.ZodString>>;
        schedRange: z.ZodOptional<z.ZodNullable<z.ZodArray<z.ZodString, "many">>>;
    }, "strip", z.ZodTypeAny, {
        action: number;
        resource: string;
        schedAction?: number | null | undefined;
        schedCron?: string | null | undefined;
        schedRange?: string[] | null | undefined;
    }, {
        action: number;
        resource: string;
        schedAction?: number | null | undefined;
        schedCron?: string | null | undefined;
        schedRange?: string[] | null | undefined;
    }>, "many">;
    platform_id: z.ZodOptional<z.ZodNullable<z.ZodString>>;
    platform_user_id: z.ZodOptional<z.ZodNullable<z.ZodString>>;
    refresh_expires_in: z.ZodOptional<z.ZodNullable<z.ZodNumber>>;
    refresh_token: z.ZodOptional<z.ZodNullable<z.ZodString>>;
    roles: z.ZodOptional<z.ZodNullable<z.ZodArray<z.ZodString, "many">>>;
    scope: z.ZodString;
    simultaneous_platform_id: z.ZodOptional<z.ZodNullable<z.ZodString>>;
    simultaneous_platform_user_id: z.ZodOptional<z.ZodNullable<z.ZodString>>;
    token_type: z.ZodString;
    unique_display_name: z.ZodOptional<z.ZodNullable<z.ZodString>>;
    user_id: z.ZodOptional<z.ZodNullable<z.ZodString>>;
    xuid: z.ZodOptional<z.ZodNullable<z.ZodString>>;
}, "strip", z.ZodTypeAny, {
    namespace: string;
    access_token: string;
    expires_in: number;
    permissions: {
        action: number;
        resource: string;
        schedAction?: number | null | undefined;
        schedCron?: string | null | undefined;
        schedRange?: string[] | null | undefined;
    }[];
    scope: string;
    token_type: string;
    auth_trust_id?: string | null | undefined;
    bans?: {
        ban: string;
        enabled: boolean;
        endDate: string;
        targetedNamespace: string;
        disabledDate?: string | null | undefined;
    }[] | null | undefined;
    display_name?: string | null | undefined;
    is_comply?: boolean | null | undefined;
    jflgs?: number | null | undefined;
    namespace_roles?: {
        namespace: string;
        roleId: string;
    }[] | null | undefined;
    platform_id?: string | null | undefined;
    platform_user_id?: string | null | undefined;
    refresh_expires_in?: number | null | undefined;
    refresh_token?: string | null | undefined;
    roles?: string[] | null | undefined;
    simultaneous_platform_id?: string | null | undefined;
    simultaneous_platform_user_id?: string | null | undefined;
    unique_display_name?: string | null | undefined;
    user_id?: string | null | undefined;
    xuid?: string | null | undefined;
}, {
    namespace: string;
    access_token: string;
    expires_in: number;
    permissions: {
        action: number;
        resource: string;
        schedAction?: number | null | undefined;
        schedCron?: string | null | undefined;
        schedRange?: string[] | null | undefined;
    }[];
    scope: string;
    token_type: string;
    auth_trust_id?: string | null | undefined;
    bans?: {
        ban: string;
        enabled: boolean;
        endDate: string;
        targetedNamespace: string;
        disabledDate?: string | null | undefined;
    }[] | null | undefined;
    display_name?: string | null | undefined;
    is_comply?: boolean | null | undefined;
    jflgs?: number | null | undefined;
    namespace_roles?: {
        namespace: string;
        roleId: string;
    }[] | null | undefined;
    platform_id?: string | null | undefined;
    platform_user_id?: string | null | undefined;
    refresh_expires_in?: number | null | undefined;
    refresh_token?: string | null | undefined;
    roles?: string[] | null | undefined;
    simultaneous_platform_id?: string | null | undefined;
    simultaneous_platform_user_id?: string | null | undefined;
    unique_display_name?: string | null | undefined;
    user_id?: string | null | undefined;
    xuid?: string | null | undefined;
}>;
interface TokenWithDeviceCookieResponseV3 extends z.TypeOf<typeof TokenWithDeviceCookieResponseV3> {
}

type ResponseError = Error | AxiosError;
type Response<T> = {
    response: AxiosResponse<T>;
    error: null;
} | {
    response: null;
    error: ResponseError;
};
declare class Validate {
    static validateOrReturnResponse<D>(useSchemaValidation: boolean, networkCall: () => Promise<AxiosResponse<D>>, Codec: z.ZodType<D>, modelName: string): Promise<Response<D>>;
    static responseType<D>(networkCall: () => Promise<AxiosResponse<D>>, Codec: z.ZodType<D>, modelName: string): Promise<Response<D>>;
    static unsafeResponse<D>(networkCall: () => Promise<AxiosResponse<D>>): Promise<Response<D>>;
    static safeParse<D>(data: unknown, Codec: z.ZodType<D>): D | null;
}
declare class DecodeError extends Error {
    constructor({ error, response, modelName }: {
        error: ZodError;
        response: AxiosResponse;
        modelName: string;
    });
}

declare enum GrantTokenUrls {
    GRANT_TOKEN = "/iam/v3/oauth/token",
    GRANT_TOKEN_V4 = "/iam/v4/oauth/token"
}
type GrantTokenUrlString = `${GrantTokenUrls}`;
type RefreshArgs = {
    axiosConfig: AxiosRequestConfig;
    refreshToken?: string;
    clientId: string;
    tokenUrl?: GrantTokenUrlString;
};
declare class RefreshToken {
    private config;
    private interceptors;
    constructor({ config, interceptors }: {
        config: RefreshArgs;
        interceptors?: Interceptor[];
    });
    runWithLock: () => Promise<Partial<TokenWithDeviceCookieResponseV3> | false>;
    run: () => Promise<false | TokenWithDeviceCookieResponseV3>;
    refreshToken: () => Promise<Response<TokenWithDeviceCookieResponseV3>>;
}
type SessionExpiredInterceptorOptions = {
    /**
     * The client ID used by the SDK, obtained from the Admin Portal under OAuth Clients.
     */
    clientId: string;
    /**
     * An optional array of URLs that should be ignored when handling session expiration.
     * Default to `['/iam/v3/oauth/token', '/iam/v4/oauth/token', '/iam/v3/oauth/revoke']`
     */
    expectedErrorUrls?: string[];
    /**
     * A callback function that retrieves the current refresh token.
     */
    getRefreshToken?: () => string | undefined;
    /**
     * The URL endpoint for obtaining a new token. Defaults to `'/iam/v3/oauth/token'`.
     */
    tokenUrl?: GrantTokenUrlString;
    /**
     * A callback function triggered when the session has expired.
     */
    onSessionExpired: () => void;
    /**
     * A callback function triggered when successfully get new session.
     */
    onGetUserSession?: (accessToken: string, refreshToken: string) => void;
};
declare const createAuthInterceptor: ({ clientId, onSessionExpired, onGetUserSession, expectedErrorUrls, getRefreshToken, tokenUrl }: SessionExpiredInterceptorOptions) => Interceptor;
type RefreshSessioNInterceptorOptions = {
    /**
     * The URL endpoint for obtaining a new token. Defaults to `'/iam/v3/oauth/token'`.
     */
    tokenUrl?: GrantTokenUrlString;
};
declare const createRefreshSessionInterceptor: (options?: RefreshSessioNInterceptorOptions) => Interceptor;
type GetSessionInterceptorOptions = {
    /**
     * The URL endpoint for obtaining a new token. Defaults to `'/iam/v3/oauth/token'`.
     */
    tokenUrl?: GrantTokenUrlString;
    /**
     * A callback function triggered when successfully get new session.
     */
    onGetUserSession: (accessToken: string, refreshToken: string) => void;
};
declare const createGetSessionInterceptor: ({ tokenUrl, onGetUserSession }: GetSessionInterceptorOptions) => Interceptor;

declare const BASE_PATHS: readonly ["/achievement", "/basic", "/buildinfo", "/chat", "/cloudsave", "/content-management", "/differ", "/dsmcontroller", "/event", "/game-telemetry", "/gdpr", "/group", "/iam", "/leaderboard", "/agreement", "/lobby", "/match2", "/matchmaking", "/odin-config", "/platform", "/qosm", "/reporting", "/seasonpass", "/session", "/sessionbrowser", "/social", "/ugc", "/config"];
type BasePath = (typeof BASE_PATHS)[number] | (string & {});

type CreateCustomPathInterceptorOptions = {
    /**
     * A list of objects specifying which service base paths should be replaced.
     * For example, providing `{'/iam': '/iam-test'}` will redirect all `'/iam'` requests to `'/iam-test'`.
     */
    basePath: Partial<Record<BasePath, string>>;
    /**
     * Indicates whether to use the internal AccelByte network. This should only be used in a server environment.
     * When set to true, requests will be made to `http://{service-name}/{path}` instead of the `baseURL`.
     */
    isInternalNetwork?: boolean;
};
declare const createCustomPathInterceptor: ({ basePath, isInternalNetwork }: CreateCustomPathInterceptorOptions) => Interceptor;

declare const ErrorInterceptors: Array<Interceptor>;

declare class ApiUtils {
    static mergeAxiosConfigs: (config: AxiosRequestConfig, overrides?: AxiosRequestConfig) => AxiosRequestConfig;
    static is4xxError: (error: unknown) => boolean;
}

declare class BrowserHelper {
    static isOnBrowser: () => false | Document;
}

declare class CodeGenUtil {
    /**
     * Returns a hash code from a string
     * @param  {String} str The string to hash.
     * @return {Number} A 32bit integer
     * @see http://werxltd.com/wp/2010/05/13/javascript-implementation-of-javas-string-hashcode-method/
     */
    static hashCode(str: string): number;
    static getFormUrlEncodedData: (data: Record<string, any>) => URLSearchParams;
}

declare class DesktopChecker {
    private static desktopApp;
    static isDesktopApp(): boolean;
    private static isInIframe;
    private static isElectron;
}

declare class Network {
    static create(...configs: AxiosRequestConfig[]): AxiosInstance;
    static withBearerToken(accessToken: string, config?: AxiosRequestConfig): AxiosInstance;
    static setDeviceTokenCookie: () => void;
    static removeDeviceTokenCookie: () => void;
    static getFormUrlEncodedData: (data: any) => URLSearchParams;
}

declare class RefreshSession {
    static KEY: string;
    static isLocked: () => boolean;
    static lock: (expiry: number) => void;
    static unlock: () => void;
    static sleepAsync: (timeInMs: number) => Promise<unknown>;
    static isBearerAuth: (config?: AxiosRequestConfig) => boolean;
}

declare class SdkDevice {
    static ID_KEY: string;
    static TYPE: {
        MOBILE: string;
        DESKTOP: string;
    };
    static getType: () => string;
    static generateUUID: () => string;
    static getDeviceId: () => string;
}

declare class UrlHelper {
    static isCompleteURLString: (urlString: string) => boolean;
    static trimSlashFromStringEnd(pathString: string): string;
    static trimSlashFromStringStart(pathString: string): string;
    static trimSlashFromStringEdges(pathString: string): string;
    static combinePaths(...paths: string[]): string;
    static combineURLPaths(urlString: string, ...paths: string[]): string;
    static removeQueryParam(fullUrlString: string, param: string): string;
}

export { AccelByte, AccelByteSDK, type ApiError, ApiUtils, type AxiosConfig, BrowserHelper, CodeGenUtil, type CoreConfig, DecodeError, DesktopChecker, ERROR_CODE_LINK_DELETION_ACCOUNT, ERROR_CODE_TOKEN_EXPIRED, ERROR_LINK_ANOTHER_3RD_PARTY_ACCOUNT, ERROR_USER_BANNED, ErrorInterceptors, IamErrorCode, type Interceptor, type MakeOptional, type MakeRequired, Network, RefreshSession, RefreshToken, type Response, type ResponseError, type SdkConstructorParam, SdkDevice, type SdkSetConfigParam, type TokenConfig, UrlHelper, Validate, type WebSocketConfig, createAuthInterceptor, createCustomPathInterceptor, createGetSessionInterceptor, createRefreshSessionInterceptor, isType };

// src/polyfills/browser.ts
import { Buffer as Buffer2 } from "buffer";
window.Buffer = Buffer2;

// src/utils/ApiUtils.ts
import axios from "axios";
var ApiUtils = class {
};
ApiUtils.mergeAxiosConfigs = (config, overrides) => {
  return {
    ...config,
    ...overrides,
    headers: {
      ...config?.headers,
      ...overrides?.headers
    }
  };
};
ApiUtils.is4xxError = (error) => {
  if (axios.isAxiosError(error) && error.response) {
    return error.response.status >= 400 && error.response.status <= 499;
  }
  return false;
};

// src/utils/Network.ts
import axios2 from "axios";
import qs from "query-string";

// src/utils/SdkDevice.ts
import * as uuid from "uuid";
var _SdkDevice = class _SdkDevice {
};
_SdkDevice.ID_KEY = "deviceId";
_SdkDevice.TYPE = {
  MOBILE: "mobile",
  DESKTOP: "desktop"
};
_SdkDevice.getType = () => {
  return isMobile() ? _SdkDevice.TYPE.MOBILE : _SdkDevice.TYPE.DESKTOP;
};
_SdkDevice.generateUUID = () => {
  const deviceIdInUUID = uuid.v4().split("-").join("");
  localStorage.setItem(_SdkDevice.ID_KEY, deviceIdInUUID);
  return deviceIdInUUID;
};
_SdkDevice.getDeviceId = () => {
  return localStorage.getItem(_SdkDevice.ID_KEY) || _SdkDevice.generateUUID();
};
var SdkDevice = _SdkDevice;
var mobileRE = /(android|bb\d+|meego).+mobile|armv7l|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series[46]0|symbian|treo|up\.(browser|link)|vodafone|wap|windows (ce|phone)|xda|xiino/i;
var tabletRE = /android|ipad|playbook|silk/i;
var isMobile = (opts) => {
  if (!opts) opts = {};
  let ua = opts.ua;
  if (!ua && typeof navigator !== "undefined") ua = navigator.userAgent;
  if (ua && ua.headers && typeof ua.headers["user-agent"] === "string") {
    ua = ua.headers["user-agent"];
  }
  if (typeof ua !== "string") return false;
  let result = mobileRE.test(ua) || !!opts.tablet && tabletRE.test(ua);
  if (!result && opts.tablet && opts.featureDetect && navigator && navigator.maxTouchPoints > 1 && ua.indexOf("Macintosh") !== -1 && ua.indexOf("Safari") !== -1) {
    result = true;
  }
  return result;
};

// src/utils/Network.ts
var _Network = class _Network {
  static create(...configs) {
    const axiosInstance = axios2.create(
      Object.assign(
        {
          paramsSerializer: qs.stringify
        },
        ...configs
      )
    );
    return axiosInstance;
  }
  static withBearerToken(accessToken, config) {
    return _Network.create(config || {}, {
      headers: { Authorization: `Bearer ${accessToken}` }
    });
  }
};
_Network.setDeviceTokenCookie = () => {
  const deviceId = SdkDevice.getDeviceId();
  document.cookie = `device_token=${deviceId}; path=/;`;
};
_Network.removeDeviceTokenCookie = () => {
  document.cookie = `device_token=; expires=${(/* @__PURE__ */ new Date(0)).toUTCString()}`;
};
_Network.getFormUrlEncodedData = (data) => {
  const formPayload = new URLSearchParams();
  const formKeys = Object.keys(data);
  formKeys.forEach((key) => {
    if (data[key]) formPayload.append(key, data[key]);
  });
  return formPayload;
};
var Network = _Network;

// src/AccelByteSDK.ts
var AccelByte = {
  SDK: (param) => {
    return new AccelByteSDK(param);
  }
};
var AccelByteSDK = class _AccelByteSDK {
  constructor({ coreConfig, axiosConfig, webSocketConfig }) {
    this.coreConfig = {
      ...coreConfig,
      useSchemaValidation: coreConfig.useSchemaValidation ?? true
    };
    this.axiosConfig = {
      /**
       * when user create a variable to store intercepters and passed into sdk
       * the sdk will use the variable as reference value,
       * so when new interceptor added, reference value will also has the new interceptor,
       * to avoid this we create shallow copy for the interceptors
       */
      interceptors: axiosConfig?.interceptors ? [...axiosConfig.interceptors] : void 0,
      request: {
        timeout: 6e4,
        withCredentials: true,
        ...axiosConfig?.request,
        headers: {
          "Content-Type": "application/json",
          ...axiosConfig?.request?.headers
        }
      }
    };
    this.axiosInstance = this.createAxiosInstance();
    this.webSocketConfig = {
      allowReconnect: webSocketConfig?.allowReconnect ?? true,
      maxReconnectAttempts: webSocketConfig?.maxReconnectAttempts ?? 0
    };
    this.token = {};
  }
  createAxiosInstance() {
    const axiosInstance = Network.create({ baseURL: this.coreConfig.baseURL, ...this.axiosConfig.request });
    const interceptors = this.axiosConfig.interceptors;
    if (interceptors) {
      for (const interceptor of interceptors) {
        if (interceptor.type === "request") {
          axiosInstance.interceptors.request.use(interceptor?.onRequest, interceptor.onError);
        }
        if (interceptor.type === "response") {
          axiosInstance.interceptors.response.use(interceptor?.onSuccess, interceptor.onError);
        }
      }
    }
    return axiosInstance;
  }
  /**
   * Assembles and returns the current Axios instance along with core and Axios configurations.
   */
  assembly() {
    return {
      axiosInstance: this.axiosInstance,
      coreConfig: this.coreConfig,
      axiosConfig: this.axiosConfig,
      webSocketConfig: this.webSocketConfig
    };
  }
  /**
   * Creates a new instance of AccelByteSDK with a shallow copy of the current configurations.
   * Optionally allows excluding interceptors.
   * @param {boolean} [opts.interceptors] - Whether to include interceptors in the clone. Default is true.
   * @returns {AccelByteSDK} A new instance of AccelByteSDK with the cloned configuration.
   */
  clone(opts) {
    const newConfigs = {
      coreConfig: { ...this.coreConfig },
      axiosConfig: { ...this.axiosConfig }
    };
    if (opts?.interceptors === false) {
      delete newConfigs.axiosConfig.interceptors;
    }
    const newSdkInstance = new _AccelByteSDK(newConfigs);
    newSdkInstance.setToken(this.token);
    return newSdkInstance;
  }
  /**
   * Adds interceptors to the current Axios configuration.
   */
  addInterceptors(interceptors) {
    if (!this.axiosConfig.interceptors) {
      this.axiosConfig.interceptors = [];
    }
    this.axiosConfig.interceptors.push(...interceptors);
    return this;
  }
  removeInterceptors(filterCallback) {
    if (!this.axiosConfig?.interceptors) return this;
    if (!filterCallback) {
      this.axiosConfig.interceptors = void 0;
      this.axiosInstance.interceptors.request.clear();
      this.axiosInstance.interceptors.response.clear();
      return this;
    }
    this.axiosConfig.interceptors = this.axiosConfig.interceptors.filter(filterCallback);
    this.axiosInstance = this.createAxiosInstance();
    return this;
  }
  /**
   * Updates the SDK's core and Axios configurations.
   * Merges the provided configurations with the current ones.
   */
  setConfig({ coreConfig, axiosConfig, webSocketConfig }) {
    this.coreConfig = {
      ...this.coreConfig,
      ...coreConfig
    };
    this.axiosConfig = {
      ...this.axiosConfig,
      ...axiosConfig?.interceptors,
      request: ApiUtils.mergeAxiosConfigs(this.axiosConfig.request, axiosConfig?.request)
    };
    this.webSocketConfig = {
      ...this.webSocketConfig,
      ...webSocketConfig
    };
    this.axiosInstance = this.createAxiosInstance();
    return this;
  }
  /**
   * Set accessToken and refreshToken and updates the Axios request headers to use Bearer authentication.
   */
  setToken(token) {
    this.token = {
      ...this.token,
      ...token
    };
    const configOverride = { headers: { Authorization: this.token.accessToken ? `Bearer ${this.token.accessToken}` : "" } };
    this.axiosConfig = {
      ...this.axiosConfig,
      request: ApiUtils.mergeAxiosConfigs(this.axiosInstance.defaults, configOverride)
    };
    this.axiosInstance = this.createAxiosInstance();
  }
  /**
   * Removes the currently set token.
   */
  removeToken() {
    this.token = {};
    const configOverride = { headers: { Authorization: void 0 } };
    this.axiosConfig = {
      ...this.axiosConfig,
      request: ApiUtils.mergeAxiosConfigs(this.axiosInstance.defaults, configOverride)
    };
    this.axiosInstance = this.createAxiosInstance();
  }
  /**
   * Retrieves the current token configuration.
   */
  getToken() {
    return this.token;
  }
};

// src/constants/IamErrorCode.ts
var IamErrorCode = /* @__PURE__ */ ((IamErrorCode2) => {
  IamErrorCode2[IamErrorCode2["InternalServerError"] = 2e4] = "InternalServerError";
  IamErrorCode2[IamErrorCode2["UnauthorizedAccess"] = 20001] = "UnauthorizedAccess";
  IamErrorCode2[IamErrorCode2["ValidationError"] = 20002] = "ValidationError";
  IamErrorCode2[IamErrorCode2["ForbiddenAccess"] = 20003] = "ForbiddenAccess";
  IamErrorCode2[IamErrorCode2["TooManyRequests"] = 20007] = "TooManyRequests";
  IamErrorCode2[IamErrorCode2["UserNotFound"] = 20008] = "UserNotFound";
  IamErrorCode2[IamErrorCode2["TokenIsExpired"] = 20011] = "TokenIsExpired";
  IamErrorCode2[IamErrorCode2["InsufficientPermissions"] = 20013] = "InsufficientPermissions";
  IamErrorCode2[IamErrorCode2["InvalidAudience"] = 20014] = "InvalidAudience";
  IamErrorCode2[IamErrorCode2["InsufficientScope"] = 20015] = "InsufficientScope";
  IamErrorCode2[IamErrorCode2["UnableToParseRequestBody"] = 20019] = "UnableToParseRequestBody";
  IamErrorCode2[IamErrorCode2["InvalidPaginationParameters"] = 20021] = "InvalidPaginationParameters";
  IamErrorCode2[IamErrorCode2["TokenIsNotUserToken"] = 20022] = "TokenIsNotUserToken";
  IamErrorCode2[IamErrorCode2["InvalidRefererHeader"] = 20023] = "InvalidRefererHeader";
  IamErrorCode2[IamErrorCode2["SubdomainMismatch"] = 20030] = "SubdomainMismatch";
  return IamErrorCode2;
})(IamErrorCode || {});

// src/constants/LinkAccount.ts
var ERROR_LINK_ANOTHER_3RD_PARTY_ACCOUNT = 10200;
var ERROR_CODE_LINK_DELETION_ACCOUNT = 10135;
var ERROR_CODE_TOKEN_EXPIRED = 10196;
var ERROR_USER_BANNED = 10134;

// src/interceptors/AuthInterceptors.ts
import axios3 from "axios";

// src/utils/DesktopChecker.ts
var _DesktopChecker = class _DesktopChecker {
  static isDesktopApp() {
    return _DesktopChecker.desktopApp && !_DesktopChecker.isInIframe();
  }
  static isInIframe() {
    try {
      return window.self !== window.top;
    } catch (error) {
      return true;
    }
  }
  // borrowed from https://github.com/cheton/is-electron
  static isElectron() {
    if (typeof window !== "undefined" && typeof window.process === "object" && window.process.type === "renderer") {
      return true;
    }
    if (typeof process !== "undefined" && typeof process.versions === "object" && !!process.versions.electron) {
      return true;
    }
    if (typeof navigator === "object" && typeof navigator.userAgent === "string" && navigator.userAgent.indexOf("Electron") >= 0) {
      return true;
    }
    return false;
  }
};
_DesktopChecker.desktopApp = _DesktopChecker.isElectron();
var DesktopChecker = _DesktopChecker;

// src/utils/BrowserHelper.ts
var BrowserHelper = class {
};
BrowserHelper.isOnBrowser = () => {
  return typeof window !== "undefined" && window.document;
};

// src/utils/RefreshSession.ts
var _RefreshSession = class _RefreshSession {
};
// --
_RefreshSession.KEY = "RefreshSession.lock";
_RefreshSession.isLocked = () => {
  if (!BrowserHelper.isOnBrowser()) return false;
  const lockStatus = localStorage.getItem(_RefreshSession.KEY);
  if (!lockStatus) {
    return false;
  }
  const lockExpiry = Number(lockStatus);
  if (isNaN(lockExpiry)) {
    return false;
  }
  return lockExpiry > (/* @__PURE__ */ new Date()).getTime();
};
_RefreshSession.lock = (expiry) => {
  if (!BrowserHelper.isOnBrowser()) return;
  localStorage.setItem(_RefreshSession.KEY, `${(/* @__PURE__ */ new Date()).getTime() + expiry}`);
};
_RefreshSession.unlock = () => {
  if (!BrowserHelper.isOnBrowser()) return;
  localStorage.removeItem(_RefreshSession.KEY);
};
_RefreshSession.sleepAsync = (timeInMs) => new Promise((resolve) => setTimeout(resolve, timeInMs));
_RefreshSession.isBearerAuth = (config) => {
  if (config?.headers?.Authorization?.toLowerCase().indexOf("bearer") > -1) {
    return true;
  }
  return false;
};
var RefreshSession = _RefreshSession;

// ../sdk-iam/src/generated-definitions/TokenWithDeviceCookieResponseV3.ts
import { z as z4 } from "zod";

// ../sdk-iam/src/generated-definitions/JwtBanV3.ts
import { z } from "zod";
var JwtBanV3 = z.object({
  ban: z.string(),
  disabledDate: z.string().nullish(),
  enabled: z.boolean(),
  endDate: z.string(),
  targetedNamespace: z.string()
});

// ../sdk-iam/src/generated-definitions/NamespaceRole.ts
import { z as z2 } from "zod";
var NamespaceRole = z2.object({ namespace: z2.string(), roleId: z2.string() });

// ../sdk-iam/src/generated-definitions/PermissionV3.ts
import { z as z3 } from "zod";
var PermissionV3 = z3.object({
  action: z3.number().int(),
  resource: z3.string(),
  schedAction: z3.number().int().nullish(),
  schedCron: z3.string().nullish(),
  schedRange: z3.array(z3.string()).nullish()
});

// ../sdk-iam/src/generated-definitions/TokenWithDeviceCookieResponseV3.ts
var TokenWithDeviceCookieResponseV3 = z4.object({
  access_token: z4.string(),
  auth_trust_id: z4.string().nullish(),
  bans: z4.array(JwtBanV3).nullish(),
  display_name: z4.string().nullish(),
  expires_in: z4.number().int(),
  is_comply: z4.boolean().nullish(),
  jflgs: z4.number().int().nullish(),
  namespace: z4.string(),
  namespace_roles: z4.array(NamespaceRole).nullish(),
  permissions: z4.array(PermissionV3),
  platform_id: z4.string().nullish(),
  platform_user_id: z4.string().nullish(),
  refresh_expires_in: z4.number().int().nullish(),
  refresh_token: z4.string().nullish(),
  roles: z4.array(z4.string()).nullish(),
  scope: z4.string(),
  simultaneous_platform_id: z4.string().nullish(),
  simultaneous_platform_user_id: z4.string().nullish(),
  token_type: z4.string(),
  unique_display_name: z4.string().nullish(),
  user_id: z4.string().nullish(),
  xuid: z4.string().nullish()
});

// src/utils/CodeGenUtil.ts
var CodeGenUtil = class {
  /**
   * Returns a hash code from a string
   * @param  {String} str The string to hash.
   * @return {Number} A 32bit integer
   * @see http://werxltd.com/wp/2010/05/13/javascript-implementation-of-javas-string-hashcode-method/
   */
  static hashCode(str) {
    let hash = 0;
    for (let i = 0, len = str.length; i < len; i++) {
      const chr = str.charCodeAt(i);
      hash = (hash << 5) - hash + chr;
      hash |= 0;
    }
    return hash;
  }
};
CodeGenUtil.getFormUrlEncodedData = (data) => {
  const formPayload = new URLSearchParams();
  const formKeys = Object.keys(data);
  formKeys.forEach((key) => {
    if (typeof data[key] !== "undefined") formPayload.append(key, data[key]);
  });
  return formPayload;
};

// src/utils/Validate.ts
var Validate = class _Validate {
  static validateOrReturnResponse(useSchemaValidation, networkCall, Codec, modelName) {
    return useSchemaValidation ? _Validate.responseType(() => networkCall(), Codec, modelName) : _Validate.unsafeResponse(() => networkCall());
  }
  static responseType(networkCall, Codec, modelName) {
    return wrapNetworkCallSafely(async () => {
      const response = await networkCall();
      const decodeResult = Codec.safeParse(response.data);
      if (!decodeResult.success && response.status !== 204) {
        throw new DecodeError({ error: decodeResult.error, response, modelName });
      }
      return response;
    });
  }
  static unsafeResponse(networkCall) {
    return wrapNetworkCallSafely(() => networkCall());
  }
  static safeParse(data, Codec) {
    const result = Codec.safeParse(data);
    if (result.success) {
      return result.data;
    }
    return null;
  }
};
async function wrapNetworkCallSafely(networkCallFunction) {
  try {
    const response = await networkCallFunction();
    return { response, error: null };
  } catch (error) {
    return { response: null, error };
  }
}
var DecodeError = class extends Error {
  constructor({ error, response, modelName }) {
    const msg = `response from url "${response.config.url}" doesn't match model "${modelName}"`;
    super(msg);
    console.error(msg, error);
  }
};

// src/interceptors/AuthInterceptorDeps.ts
var OAuth20$ = class {
  // @ts-ignore
  constructor(axiosInstance) {
    this.axiosInstance = axiosInstance;
  }
  postOauthToken(data) {
    const params = {};
    const url = "/iam/v3/oauth/token";
    const resultPromise = this.axiosInstance.post(url, CodeGenUtil.getFormUrlEncodedData(data), {
      ...params,
      headers: { ...params.headers, "content-type": "application/x-www-form-urlencoded" }
    });
    return Validate.responseType(() => resultPromise, TokenWithDeviceCookieResponseV3, "TokenWithDeviceCookieResponseV3");
  }
};
var OAuth20V4$ = class {
  // @ts-ignore
  // prettier-ignore
  constructor(axiosInstance) {
    this.axiosInstance = axiosInstance;
  }
  /**
   * This endpoint supports grant type: 1. Grant Type == &lt;code&gt;authorization_code&lt;/code&gt;: It generates the user token by given the authorization code which generated in &#34;/iam/v3/authenticate&#34; API response. It should also pass in the redirect_uri, which should be the same as generating the authorization code request. 2. Grant Type == &lt;code&gt;password&lt;/code&gt;: The grant type to use for authenticating a user, whether it&#39;s by email / username and password combination or through platform. 3. Grant Type == &lt;code&gt;refresh_token&lt;/code&gt;: Used to get a new access token for a valid refresh token. 4. Grant Type == &lt;code&gt;client_credentials&lt;/code&gt;: It generates a token by checking the client credentials provided through Authorization header. 5. Grant Type == &lt;code&gt;urn:ietf:params:oauth:grant-type:extend_client_credentials&lt;/code&gt;: It generates a token by checking the client credentials provided through Authorization header. It only allows publisher/studio namespace client. In generated token: 1. There wil be no roles, namespace_roles &amp; permission. 2. The scope will be fixed as &#39;extend&#39;. 3. There will have a new field &#39;extend_namespace&#39;, the value is from token request body. 6. Grant Type == &lt;code&gt;urn:ietf:params:oauth:grant-type:login_queue_ticket&lt;/code&gt;: It generates a token by validating the login queue ticket against login queue service. ## Access Token Content Following is the access token’s content: - **namespace**. It is the namespace the token was generated from. - **display_name**. The display name of the sub. It is empty if the token is generated from the client credential - **roles**. The sub’s roles. It is empty if the token is generated from the client credential - **namespace_roles**. The sub’s roles scoped to namespace. Improvement from roles, which make the role scoped to specific namespace instead of global to publisher namespace - **permissions**. The sub or aud’ permissions - **bans**. The sub’s list of bans. It is used by the IAM client for validating the token. - **jflgs**. It stands for Justice Flags. It is a special flag used for storing additional status information regarding the sub. It is implemented as a bit mask. Following explains what each bit represents: - 1: Email Address Verified - 2: Phone Number Verified - 4: Anonymous - 8: Suspicious Login - **aud**. The aud is the targeted resource server. - **iat**. The time the token issues at. It is in Epoch time format - **exp**. The time the token expires. It is in Epoch time format - **client_id**. The UserID. The sub is omitted if the token is generated from client credential - **scope**. The scope of the access request, expressed as a list of space-delimited, case-sensitive strings ## Bans The JWT contains user&#39;s active bans with its expiry date. List of ban types can be obtained from /bans. ## Device Cookie Validation _**For grant type &#34;password&#34; only**_ Device Cookie is used to protect the user account from brute force login attack, &lt;a target=&#34;_blank&#34; href=&#34;https://owasp.org/www-community/Slow_Down_Online_Guessing_Attacks_with_Device_Cookies&#34;&gt;more detail from OWASP&lt;a&gt;. This endpoint will read device cookie from request header **Auth-Trust-Id**. If device cookie not found, it will generate a new one and set it into response body **auth_trust_id** when successfully login. ## Track Login History This endpoint will track login history to detect suspicious login activity, please provide **Device-Id** (alphanumeric) in request header parameter otherwise it will set to &#34;unknown&#34;. Align with General Data Protection Regulation in Europe, user login history will be kept within 28 days by default&#34; ## 2FA remember device To remember device for 2FA, should provide cookie: device_token or header: Device-Token ## Response note If it is a user token request and user hasn&#39;t accepted required legal policy, the field &lt;code&gt;is_comply&lt;/code&gt; will be false in response and responsed token will have no permission. action code: 10703
   */
  postOauthToken_v4(data, queryParams) {
    const params = { code_challenge_method: "plain", ...queryParams };
    const url = "/iam/v4/oauth/token";
    const resultPromise = this.axiosInstance.post(url, CodeGenUtil.getFormUrlEncodedData(data), {
      ...params,
      headers: { ...params.headers, "content-type": "application/x-www-form-urlencoded" }
    });
    return Validate.responseType(() => resultPromise, TokenWithDeviceCookieResponseV3, "TokenWithDeviceCookieResponseV3");
  }
};

// src/interceptors/AuthInterceptors.ts
var REFRESH_EXPIRY = 1e3;
var REFRESH_EXPIRY_UPDATE_RATE = 500;
var REFRESH_EXPIRY_CHECK_RATE = 1e3;
var GrantTokenUrls = /* @__PURE__ */ ((GrantTokenUrls2) => {
  GrantTokenUrls2["GRANT_TOKEN"] = "/iam/v3/oauth/token";
  GrantTokenUrls2["GRANT_TOKEN_V4"] = "/iam/v4/oauth/token";
  return GrantTokenUrls2;
})(GrantTokenUrls || {});
var LoginUrls = /* @__PURE__ */ ((LoginUrls2) => {
  LoginUrls2["REVOKE"] = "/iam/v3/oauth/revoke";
  return LoginUrls2;
})(LoginUrls || {});
var noOp = () => {
};
var RefreshToken = class {
  constructor({ config, interceptors }) {
    // Return Promise<true> if refresh in any tab is successful;
    this.runWithLock = () => {
      if (RefreshSession.isLocked()) {
        return Promise.resolve().then(async () => {
          while (RefreshSession.isLocked()) {
            await RefreshSession.sleepAsync(REFRESH_EXPIRY_CHECK_RATE);
          }
          return {};
        });
      }
      RefreshSession.lock(REFRESH_EXPIRY);
      let isLocallyRefreshingToken = true;
      (async () => {
        while (isLocallyRefreshingToken) {
          RefreshSession.lock(REFRESH_EXPIRY);
          await RefreshSession.sleepAsync(REFRESH_EXPIRY_UPDATE_RATE);
        }
      })();
      return Promise.resolve().then(() => this.run()).finally(() => {
        isLocallyRefreshingToken = false;
        RefreshSession.unlock();
      });
    };
    this.run = async () => {
      const { axiosConfig, refreshToken } = this.config;
      if (DesktopChecker.isDesktopApp() && !axiosConfig.withCredentials && !refreshToken) {
        return false;
      }
      const result = await this.refreshToken();
      if (result.error) {
        return false;
      }
      return result.response.data;
    };
    this.refreshToken = () => {
      const { axiosConfig, refreshToken, clientId, tokenUrl } = this.config;
      const config = {
        ...axiosConfig,
        /**
         * Ideally `withCredentials` should be `true` to make sure that
         * cookies always included when refreshing token
         * especially on cross-origin requests.
         * But if `refreshToken` is provided (e.g. from Launcher),
         * we can set it to false and send refresh_token via payload.
         */
        withCredentials: !refreshToken,
        headers: {
          "Content-Type": "application/x-www-form-urlencoded",
          Authorization: `Basic ${Buffer.from(`${clientId}:`).toString("base64")}`
        }
      };
      const axios4 = Network.create(config);
      for (const interceptor of this.interceptors) {
        if (interceptor.type === "request") {
          axios4.interceptors.request.use(interceptor?.onRequest, interceptor.onError);
        }
        if (interceptor.type === "response") {
          axios4.interceptors.response.use(interceptor?.onSuccess, interceptor.onError);
        }
      }
      const payload = {
        refresh_token: refreshToken || void 0,
        client_id: clientId,
        grant_type: "refresh_token"
      };
      if (tokenUrl === "/iam/v4/oauth/token" /* GRANT_TOKEN_V4 */) {
        return new OAuth20V4$(axios4).postOauthToken_v4(payload);
      }
      const oauth20 = new OAuth20$(axios4);
      return oauth20.postOauthToken(payload);
    };
    this.config = config;
    this.interceptors = interceptors || [];
  }
};
var refreshComplete = (error, tokenResponse, onSessionExpired, axiosConfig, errorConfig) => {
  if (tokenResponse) {
    const { access_token } = tokenResponse;
    if (!axiosConfig.withCredentials && access_token) {
      return axios3({
        ...errorConfig,
        headers: {
          ...errorConfig.headers,
          Authorization: `Bearer ${access_token}`
        }
      });
    } else {
      return axios3(errorConfig);
    }
  }
  if (onSessionExpired) {
    onSessionExpired();
  }
  throw error;
};
var createAuthInterceptor = ({
  clientId,
  onSessionExpired,
  onGetUserSession,
  expectedErrorUrls = Object.values({ ...LoginUrls, ...GrantTokenUrls }),
  getRefreshToken,
  tokenUrl = "/iam/v3/oauth/token" /* GRANT_TOKEN */
}) => {
  return {
    type: "response",
    name: "session-expired",
    onError: (e) => {
      const error = e;
      const { config, response } = error;
      if (axios3.isCancel(error)) {
        return Promise.reject(error);
      }
      if (!response) {
        console.warn(`sdk:ERR_INTERNET_DISCONNECTED ${config?.baseURL}${config?.url}. ${error.message}
`);
      }
      if (response?.status === 401) {
        const { url } = config || {};
        const axiosConfig = config;
        const refreshToken = getRefreshToken?.();
        if (!url || url && expectedErrorUrls.includes(url)) {
          return Promise.reject(error);
        }
        const refresh = new RefreshToken({
          config: { axiosConfig, clientId, refreshToken, tokenUrl },
          interceptors: [
            createRefreshSessionInterceptor({ tokenUrl }),
            createGetSessionInterceptor({ onGetUserSession: onGetUserSession || noOp, tokenUrl })
          ]
        });
        return refresh.runWithLock().then((tokenResponse) => {
          return refreshComplete(error, tokenResponse, onSessionExpired, axiosConfig, config || {});
        });
      }
      return Promise.reject(error);
    }
  };
};
var createRefreshSessionInterceptor = (options) => {
  const { tokenUrl = "/iam/v3/oauth/token" /* GRANT_TOKEN */ } = options || {};
  return {
    type: "request",
    name: "refresh-session",
    onError: (error) => Promise.reject(error),
    onRequest: async (config) => {
      const isRefreshTokenUrl = config.url === tokenUrl;
      while (RefreshSession.isLocked() && !isRefreshTokenUrl) {
        await RefreshSession.sleepAsync(200);
      }
      return config;
    }
  };
};
var createGetSessionInterceptor = ({
  tokenUrl = "/iam/v3/oauth/token" /* GRANT_TOKEN */,
  onGetUserSession
}) => ({
  type: "response",
  name: "get-session",
  onError: (error) => Promise.reject(error),
  onSuccess: (response) => {
    const { config, status } = response;
    if (config.url === tokenUrl && status === 200) {
      const { access_token, refresh_token } = response.data;
      if (access_token) {
        onGetUserSession(access_token, refresh_token ?? "");
      }
    }
    return response;
  }
});

// src/constants/paths.ts
var INTERNAL_SERVICES = {
  "/achievement": "justice-achievement-service",
  "/basic": "justice-basic-service",
  "/buildinfo": "justice-buildinfo-service",
  "/chat": "justice-chat-service",
  "/cloudsave": "justice-cloudsave-service",
  "/content-management": "justice-odin-content-management-service",
  "/differ": "justice-differ",
  "/dsmcontroller": "justice-dsm-controller-service",
  "/event": "justice-event-log-service",
  "/game-telemetry": "analytics-game-telemetry-api",
  "/gdpr": "justice-gdpr-service",
  "/group": "justice-group-service",
  "/iam": "justice-iam-service",
  "/leaderboard": "justice-leaderboard-service",
  "/agreement": "justice-legal-service",
  // sdk-legal
  "/lobby": "justice-lobby-server",
  "/match2": "justice-matchmaking-v2",
  // sdk-matchmaking
  "/matchmaking": "justice-matchmaking",
  // sdk-matchmaking-v1
  "/odin-config": "justice-odin-config-service",
  "/platform": "justice-platform-service",
  "/qosm": "justice-qos-manager-service",
  "/reporting": "justice-reporting-service",
  "/seasonpass": "justice-seasonpass-service",
  "/session": "justice-session-service",
  "/sessionbrowser": "justice-session-browser-service",
  "/social": "justice-social-service",
  "/ugc": "justice-ugc-service",
  "/config": "justice-config-service"
};

// src/interceptors/CustomPathInterceptor.ts
var createCustomPathInterceptor = ({ basePath, isInternalNetwork }) => {
  return {
    type: "request",
    name: "custom-base-path",
    onRequest: async (config) => {
      const { url } = config;
      if (url) {
        const firstPath = url.split("/")[1];
        const servicePath = `/${firstPath}`;
        const newBasePath = basePath?.[servicePath];
        const internalPath = INTERNAL_SERVICES?.[servicePath];
        if (isInternalNetwork && internalPath) {
          config.baseURL = `http://${internalPath}`;
        }
        if (newBasePath) {
          config.url = config.url?.replace(servicePath, newBasePath);
        }
      }
      return config;
    },
    onError: (error) => Promise.reject(error)
  };
};

// src/interceptors/ErrorInterceptor.ts
var ERROR_ELIGIBILITY_CODE = 13130;
var ErrorInterceptors = [
  {
    type: "response",
    name: "user-eligibilitiy-change",
    onError: (e) => {
      const error = e;
      if (error.response) {
        const { response } = error;
        if (response?.status === 403 && (response?.config).url.includes(process.env.BASE_URL) && response?.config.withCredentials) {
          if (response.data.errorCode === ERROR_ELIGIBILITY_CODE) {
          }
        }
      }
      return Promise.reject(error);
    }
  },
  {
    type: "response",
    name: "too-many-request",
    onError: (e) => {
      const error = e;
      if (error.response) {
        const { response } = error;
        if (response?.status === 429) {
        }
      }
      return Promise.reject(error);
    }
  }
];

// src/utils/Type.ts
function isType(schema, data) {
  return schema.safeParse(data).success;
}

// src/utils/UrlHelper.ts
var _UrlHelper = class _UrlHelper {
  static trimSlashFromStringEnd(pathString) {
    let newString = pathString;
    while (newString[newString.length - 1] === "/") {
      newString = newString.slice(0, -1);
    }
    return newString;
  }
  static trimSlashFromStringStart(pathString) {
    let newString = pathString;
    while (newString[0] === "/") {
      newString = newString.slice(1);
    }
    return newString;
  }
  static trimSlashFromStringEdges(pathString) {
    return _UrlHelper.trimSlashFromStringStart(this.trimSlashFromStringEnd(pathString));
  }
  static combinePaths(...paths) {
    const completePath = paths.join("/");
    return completePath.replace(/\/{2,}/g, "/");
  }
  static combineURLPaths(urlString, ...paths) {
    const url = new URL(urlString);
    const { origin } = url;
    const pathname = _UrlHelper.trimSlashFromStringEdges(_UrlHelper.combinePaths(url.pathname, ...paths));
    return new URL(pathname, origin).toString();
  }
  static removeQueryParam(fullUrlString, param) {
    const url = new URL(fullUrlString);
    const params = url.searchParams;
    const pathname = this.trimSlashFromStringEnd(url.pathname);
    params.delete(param);
    let newUrlString;
    if (params.toString() === "") newUrlString = `${url.origin}${pathname}${url.hash}`;
    else newUrlString = `${url.origin}${pathname}?${params.toString()}${url.hash}`;
    return newUrlString;
  }
};
_UrlHelper.isCompleteURLString = (urlString) => {
  try {
    const url = new URL(urlString);
    return url.hostname !== "";
  } catch (error) {
  }
  return false;
};
var UrlHelper = _UrlHelper;
export {
  AccelByte,
  AccelByteSDK,
  ApiUtils,
  BrowserHelper,
  CodeGenUtil,
  DecodeError,
  DesktopChecker,
  ERROR_CODE_LINK_DELETION_ACCOUNT,
  ERROR_CODE_TOKEN_EXPIRED,
  ERROR_LINK_ANOTHER_3RD_PARTY_ACCOUNT,
  ERROR_USER_BANNED,
  ErrorInterceptors,
  IamErrorCode,
  Network,
  RefreshSession,
  RefreshToken,
  SdkDevice,
  UrlHelper,
  Validate,
  createAuthInterceptor,
  createCustomPathInterceptor,
  createGetSessionInterceptor,
  createRefreshSessionInterceptor,
  isType
};
//# sourceMappingURL=index.browser.js.map
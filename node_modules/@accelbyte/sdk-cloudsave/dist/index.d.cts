import { AccelByteSDK, SdkSetConfigParam, Response } from '@accelbyte/sdk';
import { AxiosResponse, AxiosInstance } from 'axios';
import { A as AdminConcurrentRecordRequest, a as AdminGameConcurrentRecordRequest, P as PlayerRecordConcurrentUpdateResponse, b as AdminPlayerConcurrentRecordRequest, L as ListGameBinaryRecordsAdminResponse, G as GameBinaryRecordCreate, U as UploadBinaryRecordResponse, c as GameBinaryRecordAdminResponse, B as BinaryRecordRequest, d as GameBinaryRecordMetadataRequest, e as UploadBinaryRecordRequest, f as ListGameRecordKeysResponse, g as GameRecordAdminResponse, h as GameRecordRequest, i as ListPlayerBinaryRecordsResponse, j as PlayerBinaryRecordCreate, k as PlayerBinaryRecordResponse, l as PlayerBinaryRecordMetadataRequest, m as ListPlayerRecordKeysResponse, n as BulkUserKeyRequest, o as BulkGetPlayerRecordSizeResponse, p as BulkUserIDsRequest, q as BulkGetPlayerRecordResponse, r as BulkUpdatePlayerRecordsByKeyRequest, s as BulkUpdatePlayerRecordByKeyResponseArray, t as BulkGetPlayerRecordsRequest, u as BulkGetAdminPlayerRecordResponse, v as BulkUpdatePlayerRecordsRequest, w as BulkUpdatePlayerRecordResponseArray, x as PlayerRecordResponse, y as PlayerRecordRequest, z as PlayerRecordSizeResponse, C as PluginResponse, D as PluginRequest, E as ListAdminGameRecordKeysResponse, F as BulkGetAdminGameRecordRequest, H as BulkGetAdminGameRecordResponse, I as AdminGameRecordResponse, J as AdminGameRecordRequest, K as ListAdminPlayerRecordKeysResponse, M as BulkGetAdminPlayerRecordRequest, N as AdminPlayerRecordResponse, O as AdminPlayerRecordRequest, Q as ListTagsResponse, T as TagRequest, R as ConcurrentRecordRequest, S as ListGameBinaryRecordsResponse, V as PublicGameBinaryRecordCreate, W as BulkGetGameRecordRequest, X as BulkGetGameBinaryRecordResponse, Y as GameBinaryRecordResponse, Z as BulkGetGameRecordResponse, _ as GameRecordResponse, $ as BulkGetPlayerBinaryRecordResponse, a0 as PublicPlayerBinaryRecordCreate, a1 as PlayerBinaryRecordMetadataPublicRequest } from './PublicPlayerBinaryRecordCreate-BVfdaP5p.cjs';
import { z } from 'zod';

/**
 * AUTO GENERATED
 */

declare function ConcurrentRecordAdminApi(sdk: AccelByteSDK, args?: SdkSetConfigParam): {
    /**
     * ## Description This endpoints will create new game record or replace the existing game record. **Replace behaviour:** The existing value will be replaced completely with the new value. Example - Existing JSON: `{ &#34;data1&#34;: &#34;value&#34; }` - New JSON: `{ &#34;data2&#34;: &#34;new value&#34; }` - Result: `{ &#34;data2&#34;: &#34;new value&#34; }` ## Restriction This is the restriction of Key Naming for the record: 1. Cannot use **&#34;.&#34;** as the key name - `{ &#34;data.2&#34;: &#34;value&#34; }` 2. Cannot use **&#34;$&#34;** as the prefix in key names - `{ &#34;$data&#34;: &#34;value&#34; }` 3. Cannot use empty string in key names - `{ &#34;&#34;: &#34;value&#34; }` ## Reserved Word Reserved Word List: **__META** The reserved word cannot be used as a field in record value, If still defining the field when creating or updating the record, it will be ignored. ## Parameters Notes 1. set_by (default: CLIENT, type: string) Indicate which party that could modify the game record. SERVER: record can be modified by server only. CLIENT: record can be modified by client and server. 2. updatedAt (required: true) Time format style: RFC3339 3. value Json 4. tags (default: *empty array*, type: array of string) Indicate the tagging for the game record. **Request Body Example:** ``` { &#34;set_by&#34;: &#34;SERVER&#34;, &#34;value&#34;: {}, &#34;updatedAt&#34;: &#34;2022-03-17T10:42:15.444Z&#34;, &#34;tags&#34;: [&#34;tag1&#34;, &#34;tag2&#34;] } ``` ## Optimistic Concurrency Control This endpoint implement optimistic concurrency control to avoid race condition. If the record has been updated since the client fetch it, the server will return HTTP status code 412 (precondition failed) and client need to redo the operation (fetch data and do update). Otherwise, the server will process the request.
     */
    updateConcurrentRecord_ByKey: (key: string, data: AdminConcurrentRecordRequest) => Promise<AxiosResponse<unknown>>;
    /**
     * ## Description This endpoints will create new game record or replace the existing game record. **Replace behaviour:** The existing value will be replaced completely with the new value. Example - Existing JSON: `{ &#34;data1&#34;: &#34;value&#34; }` - New JSON: `{ &#34;data2&#34;: &#34;new value&#34; }` - Result: `{ &#34;data2&#34;: &#34;new value&#34; }` ## Restriction This is the restriction of Key Naming for the record: 1. Cannot use **&#34;.&#34;** as the key name - `{ &#34;data.2&#34;: &#34;value&#34; }` 2. Cannot use **&#34;$&#34;** as the prefix in key names - `{ &#34;$data&#34;: &#34;value&#34; }` 3. Cannot use empty string in key names - `{ &#34;&#34;: &#34;value&#34; }` ## Reserved Word Reserved Word List: **__META** The reserved word cannot be used as a field in record value, If still defining the field when creating or updating the record, it will be ignored. ## Parameters Notes 1. updatedAt (required: true) Time format style: RFC3339 2. value Json 3. tags (default: *empty array*, type: array of string) Indicate the tagging for the admin record. **Request Body Example:** ``` { &#34;value&#34;: {}, &#34;updatedAt&#34;: &#34;2022-03-17T10:42:15.444Z&#34;, &#34;tags&#34;: [&#34;tag1&#34;, &#34;tag2&#34;] } ``` ## Optimistic Concurrency Control This endpoint implement optimistic concurrency control to avoid race condition. If the record has been updated since the client fetch it, the server will return HTTP status code 412 (precondition failed) and client need to redo the operation (fetch data and do update). Otherwise, the server will process the request.
     */
    updateConcurrentAdminrecord_ByKey: (key: string, data: AdminGameConcurrentRecordRequest) => Promise<AxiosResponse<unknown>>;
    /**
     * ## Description This endpoints will create new player record or replace the existing player record. **Replace behaviour:** The existing value will be replaced completely with the new value. Example - Existing JSON: `{ &#34;data1&#34;: &#34;value&#34; }` - New JSON: `{ &#34;data2&#34;: &#34;new value&#34; }` - Result: `{ &#34;data2&#34;: &#34;new value&#34; }` ## Restriction This is the restriction of Key Naming for the record: 1. Cannot use **&#34;.&#34;** as the key name - `{ &#34;data.2&#34;: &#34;value&#34; }` 2. Cannot use **&#34;$&#34;** as the prefix in key names - `{ &#34;$data&#34;: &#34;value&#34; }` 3. Cannot use empty string in key names - `{ &#34;&#34;: &#34;value&#34; }` ## Reserved Word Reserved Word List: **__META** The reserved word cannot be used as a field in record value, If still defining the field when creating or updating the record, it will be ignored. ## Parameters Notes 1. set_by (default: CLIENT, type: string) Indicate which party that could modify the game record. SERVER: record can be modified by server only. CLIENT: record can be modified by client and server. 2. updatedAt (required: true) Time format style: RFC3339 3. value Json 4. tags (default: *empty array*, type: array of string) Indicate the tagging for the game record. **Request Body Example:** ``` { &#34;set_by&#34;: &#34;SERVER&#34;, &#34;value&#34;: {}, &#34;updatedAt&#34;: &#34;2022-03-17T10:42:15.444Z&#34;, &#34;tags&#34;: [&#34;tag1&#34;, &#34;tag2&#34;] } ``` ## Optimistic Concurrency Control This endpoint implement optimistic concurrency control to avoid race condition. If the record has been updated since the client fetch it, the server will return HTTP status code 412 (precondition failed) and client need to redo the operation (fetch data and do update). Otherwise, the server will process the request.
     */
    updateConcurrentRecord_ByUserId_ByKey: (userId: string, key: string, data: AdminConcurrentRecordRequest, queryParams?: {
        responseBody?: boolean | null;
    }) => Promise<AxiosResponse<PlayerRecordConcurrentUpdateResponse>>;
    /**
     * ## Description This endpoints will create new admin player record or replace the existing admin player record. **Replace behaviour:** The existing value will be replaced completely with the new value. Example - Existing JSON: `{ &#34;data1&#34;: &#34;value&#34; }` - New JSON: `{ &#34;data2&#34;: &#34;new value&#34; }` - Result: `{ &#34;data2&#34;: &#34;new value&#34; }` ## Restriction This is the restriction of Key Naming for the record: 1. Cannot use **&#34;.&#34;** as the key name - `{ &#34;data.2&#34;: &#34;value&#34; }` 2. Cannot use **&#34;$&#34;** as the prefix in key names - `{ &#34;$data&#34;: &#34;value&#34; }` 3. Cannot use empty string in key names - `{ &#34;&#34;: &#34;value&#34; }` ## Reserved Word Reserved Word List: **__META** The reserved word cannot be used as a field in record value, If still defining the field when creating or updating the record, it will be ignored. ## Parameters Notes 1. updatedAt (required: true) Time format style: RFC3339 2. value Json 3. tags (default: *empty array*, type: array of string) Indicate the tagging for the admin record. **Request Body Example:** ``` { &#34;value&#34;: {}, &#34;updatedAt&#34;: &#34;2022-03-17T10:42:15.444Z&#34;, &#34;tags&#34;: [&#34;tag1&#34;, &#34;tag2&#34;] } ``` ## Optimistic Concurrency Control This endpoint implement optimistic concurrency control to avoid race condition. If the record has been updated since the client fetch it, the server will return HTTP status code 412 (precondition failed) and client need to redo the operation (fetch data and do update). Otherwise, the server will process the request.
     */
    updateConcurrentAdminrecord_ByUserId_ByKey: (userId: string, key: string, data: AdminPlayerConcurrentRecordRequest, queryParams?: {
        responseBody?: boolean | null;
    }) => Promise<AxiosResponse<PlayerRecordConcurrentUpdateResponse>>;
    /**
     * ## Description This endpoints will create new player public record or replace the existing player public record. **Replace behaviour:** The existing value will be replaced completely with the new value. Example - Existing JSON: `{ &#34;data1&#34;: &#34;value&#34; }` - New JSON: `{ &#34;data2&#34;: &#34;new value&#34; }` - Result: `{ &#34;data2&#34;: &#34;new value&#34; }` ## Restriction This is the restriction of Key Naming for the record: 1. Cannot use **&#34;.&#34;** as the key name - `{ &#34;data.2&#34;: &#34;value&#34; }` 2. Cannot use **&#34;$&#34;** as the prefix in key names - `{ &#34;$data&#34;: &#34;value&#34; }` 3. Cannot use empty string in key names - `{ &#34;&#34;: &#34;value&#34; }` ## Reserved Word Reserved Word List: **__META** The reserved word cannot be used as a field in record value, If still defining the field when creating or updating the record, it will be ignored. ## Parameters Notes 1. set_by (default: CLIENT, type: string) Indicate which party that could modify the game record. SERVER: record can be modified by server only. CLIENT: record can be modified by client and server. 2. updatedAt (required: true) Time format style: RFC3339 3. value Json 4. tags (default: *empty array*, type: array of string) Indicate the tagging for the game record. **Request Body Example:** ``` { &#34;set_by&#34;: &#34;SERVER&#34;, &#34;value&#34;: {}, &#34;updatedAt&#34;: &#34;2022-03-17T10:42:15.444Z&#34;, &#34;tags&#34;: [&#34;tag1&#34;, &#34;tag2&#34;] } ``` ## Optimistic Concurrency Control This endpoint implement optimistic concurrency control to avoid race condition. If the record has been updated since the client fetch it, the server will return HTTP status code 412 (precondition failed) and client need to redo the operation (fetch data and do update). Otherwise, the server will process the request.
     */
    updatePublicConcurrent_ByUserId_ByKey: (userId: string, key: string, data: AdminConcurrentRecordRequest, queryParams?: {
        responseBody?: boolean | null;
    }) => Promise<AxiosResponse<PlayerRecordConcurrentUpdateResponse>>;
};

/**
 * AUTO GENERATED
 */

declare function GameBinaryRecordAdminApi(sdk: AccelByteSDK, args?: SdkSetConfigParam): {
    /**
     * Retrieve list of binary records by namespace.
     */
    getBinaries: (queryParams?: {
        limit?: number;
        offset?: number;
        query?: string | null;
        tags?: string[];
    }) => Promise<AxiosResponse<ListGameBinaryRecordsAdminResponse>>;
    /**
     * Create a game binary record. Other detail info: `key` should follow these rules: 1. support uppercase and lowercase letters, numbers, and separators **&#34;-&#34;**, **&#34;_&#34;**, **&#34;.&#34;** are allowed 2. begin and end with letters or numbers 3. spaces are not allowed 4. separators must not appears twice in a row Supported file types: jpeg, jpg, png, bmp, gif, mp3, webp, and bin.
     */
    createBinary: (data: GameBinaryRecordCreate) => Promise<AxiosResponse<UploadBinaryRecordResponse>>;
    /**
     * Delete a game binary record.
     */
    deleteBinary_ByKey: (key: string) => Promise<AxiosResponse<unknown>>;
    /**
     * Get a game binary record by its key.
     */
    getBinary_ByKey: (key: string) => Promise<AxiosResponse<GameBinaryRecordAdminResponse>>;
    /**
     * Update a game binary record file by its key
     */
    updateBinary_ByKey: (key: string, data: BinaryRecordRequest) => Promise<AxiosResponse<GameBinaryRecordAdminResponse>>;
    /**
     * Update a game binary record metadata by its key
     */
    updateMetadata_ByKey: (key: string, data: GameBinaryRecordMetadataRequest) => Promise<AxiosResponse<GameBinaryRecordAdminResponse>>;
    /**
     * Request presigned URL to upload the binary record to s3. Other detail info: Supported file types: jpeg, jpg, png, bmp, gif, mp3, webp, and bin.
     */
    createPresigned_ByKey: (key: string, data: UploadBinaryRecordRequest) => Promise<AxiosResponse<UploadBinaryRecordResponse>>;
};

/**
 * AUTO GENERATED
 */

declare function GameRecordAdminApi(sdk: AccelByteSDK, args?: SdkSetConfigParam): {
    /**
     * Retrieve list of records key by namespace
     */
    getRecords: (queryParams: {
        limit: number;
        offset: number;
        query?: string | null;
        tags?: string[];
    }) => Promise<AxiosResponse<ListGameRecordKeysResponse>>;
    /**
     * This endpoints delete game record in namespace-level
     */
    deleteRecord_ByKey: (key: string) => Promise<AxiosResponse<unknown>>;
    /**
     * Get a record by its key in namespace-level.
     */
    getRecord_ByKey: (key: string) => Promise<AxiosResponse<GameRecordAdminResponse>>;
    /**
     * ## Description This endpoints will create new game record or append the existing game record. **Append example:** Example 1 - Existing JSON: `{ &#34;data1&#34;: &#34;value&#34; }` - New JSON: `{ &#34;data2&#34;: &#34;new value&#34; }` - Result: `{ &#34;data1&#34;: &#34;value&#34;, &#34;data2&#34;: &#34;new value&#34; }` Example 2 - Existing JSON: `{ &#34;data1&#34;: { &#34;data2&#34;: &#34;value&#34; }` - New JSON: `{ &#34;data1&#34;: { &#34;data3&#34;: &#34;new value&#34; }` - Result: `{ &#34;data1&#34;: { &#34;data2&#34;: &#34;value&#34;, &#34;data3&#34;: &#34;new value&#34; }` ## Restriction This is the restriction of Key Naming for the record: 1. Cannot use **&#34;.&#34;** as the key name - `{ &#34;data.2&#34;: &#34;value&#34; }` 2. Cannot use **&#34;$&#34;** as the prefix in key names - `{ &#34;$data&#34;: &#34;value&#34; }` 3. Cannot use empty string in key names - `{ &#34;&#34;: &#34;value&#34; }` ## Record Metadata Metadata allows user to define the behaviour of the record. Metadata can be defined in request body with field name **__META**. When creating record, if **__META** field is not defined, the metadata value will use the default value. When updating record, if **__META** field is not defined, the existing metadata value will stay as is. **Metadata List:** 1. set_by (default: CLIENT, type: string) Indicate which party that could modify the game record. SERVER: record can be modified by server only. CLIENT: record can be modified by client and server. 2. ttl_config (default: *empty*, type: object) Indicate the TTL configuration for the game record. action: - DELETE: record will be deleted after TTL is reached 3. tags (default: *empty array*, type: array of string) Indicate the tagging for the game record. **Request Body Example:** ``` { &#34;__META&#34;: { &#34;set_by&#34;: &#34;SERVER&#34;, &#34;ttl_config&#34;: { &#34;expires_at&#34;: &#34;2026-01-02T15:04:05Z&#34;, // should be in RFC3339 format &#34;action&#34;: &#34;DELETE&#34; }, &#34;tags&#34;: [&#34;tag1&#34;, &#34;tag2&#34;] } ... } ```
     */
    createRecord_ByKey: (key: string, data: GameRecordRequest) => Promise<AxiosResponse<GameRecordAdminResponse>>;
    /**
     * ## Description This endpoints will create new game record or replace the existing game record. **Replace behaviour:** The existing value will be replaced completely with the new value. Example - Existing JSON: `{ &#34;data1&#34;: &#34;value&#34; }` - New JSON: `{ &#34;data2&#34;: &#34;new value&#34; }` - Result: `{ &#34;data2&#34;: &#34;new value&#34; }` ## Restriction This is the restriction of Key Naming for the record: 1. Cannot use **&#34;.&#34;** as the key name - `{ &#34;data.2&#34;: &#34;value&#34; }` 2. Cannot use **&#34;$&#34;** as the prefix in key names - `{ &#34;$data&#34;: &#34;value&#34; }` 3. Cannot use empty string in key names - `{ &#34;&#34;: &#34;value&#34; }` ## Record Metadata Metadata allows user to define the behaviour of the record. Metadata can be defined in request body with field name **__META**. When creating record, if **__META** field is not defined, the metadata value will use the default value. When updating record, if **__META** field is not defined, the existing metadata value will stay as is. **Metadata List:** 1. set_by (default: CLIENT, type: string) Indicate which party that could modify the game record. SERVER: record can be modified by server only. CLIENT: record can be modified by client and server. 2. ttl_config (default: *empty*, type: object) Indicate the TTL configuration for the game record. action: - DELETE: record will be deleted after TTL is reached 3. tags (default: *empty array*, type: array of string) Indicate the tagging for the game record. **Request Body Example:** ``` { &#34;__META&#34;: { &#34;set_by&#34;: &#34;SERVER&#34;, &#34;ttl_config&#34;: { &#34;expires_at&#34;: &#34;2026-01-02T15:04:05Z&#34;, // should be in RFC3339 format &#34;action&#34;: &#34;DELETE&#34; }, &#34;tags&#34;: [&#34;tag1&#34;, &#34;tag2&#34;] } ... } ```
     */
    updateRecord_ByKey: (key: string, data: GameRecordRequest) => Promise<AxiosResponse<GameRecordAdminResponse>>;
};

/**
 * AUTO GENERATED
 */

declare function PlayerBinaryRecordAdminApi(sdk: AccelByteSDK, args?: SdkSetConfigParam): {
    /**
     * Retrieve list of player binary records by namespace.
     */
    getBinaries_ByUserId: (userId: string, queryParams?: {
        limit?: number;
        offset?: number;
        query?: string | null;
        tags?: string[];
    }) => Promise<AxiosResponse<ListPlayerBinaryRecordsResponse>>;
    /**
     * Create a player binary record. Other detail info: `key` should follow these rules: 1. support uppercase and lowercase letters, numbers, and separators **&#34;-&#34;**, **&#34;_&#34;**, **&#34;.&#34;** are allowed 2. begin and end with letters or numbers 3. spaces are not allowed 4. separators must not appears twice in a row Supported file types: jpeg, jpg, png, bmp, gif, mp3, webp, and bin.
     */
    createBinary_ByUserId: (userId: string, data: PlayerBinaryRecordCreate) => Promise<AxiosResponse<UploadBinaryRecordResponse>>;
    /**
     * Delete a player binary record.
     */
    deleteBinary_ByUserId_ByKey: (userId: string, key: string) => Promise<AxiosResponse<unknown>>;
    /**
     * Get a player binary record by its key.
     */
    getBinary_ByUserId_ByKey: (userId: string, key: string) => Promise<AxiosResponse<PlayerBinaryRecordResponse>>;
    /**
     * Update a player binary record file by its key
     */
    updateBinary_ByUserId_ByKey: (userId: string, key: string, data: BinaryRecordRequest) => Promise<AxiosResponse<PlayerBinaryRecordResponse>>;
    /**
     * Update a player binary record metadata by its key
     */
    updateMetadata_ByUserId_ByKey: (userId: string, key: string, data: PlayerBinaryRecordMetadataRequest) => Promise<AxiosResponse<PlayerBinaryRecordResponse>>;
    /**
     * Request presigned URL to upload the binary record to s3. Other detail info: Supported file types: jpeg, jpg, png, bmp, gif, mp3, webp, and bin.
     */
    createPresigned_ByUserId_ByKey: (userId: string, key: string, data: UploadBinaryRecordRequest) => Promise<AxiosResponse<UploadBinaryRecordResponse>>;
};

/**
 * AUTO GENERATED
 */

declare function PlayerRecordAdminApi(sdk: AccelByteSDK, args?: SdkSetConfigParam): {
    /**
     * @deprecated
     * Retrieve list of player records key and userID under given namespace.
     */
    getUsersRecords: (queryParams?: {
        limit?: number;
        offset?: number;
        query?: string | null;
    }) => Promise<AxiosResponse<ListPlayerRecordKeysResponse>>;
    /**
     * Retrieve list of player records key and userID under given namespace.
     */
    getRecords_ByUserId: (userId: string, queryParams?: {
        limit?: number;
        offset?: number;
        query?: string | null;
        tags?: string[];
    }) => Promise<AxiosResponse<ListPlayerRecordKeysResponse>>;
    /**
     * Bulk get player&#39;s record size, max allowed 20 at a time, that can be retrieved using this endpoint.
     */
    fetchUserBulkRecordSize: (data: BulkUserKeyRequest) => Promise<AxiosResponse<BulkGetPlayerRecordSizeResponse>>;
    /**
     * Retrieve player record key and payload in bulk under given namespace. Maximum number of user ids per request is 20.
     */
    fetchBulkUser_ByKey: (key: string, data: BulkUserIDsRequest) => Promise<AxiosResponse<BulkGetPlayerRecordResponse>>;
    /**
     * This endpoints will create new player record or replace the existing player record in bulk. Maximum number of user ids per request is 10. Maximum total size of the request payload is 5 MB.
     */
    updateBulkUser_ByKey: (key: string, data: BulkUpdatePlayerRecordsByKeyRequest) => Promise<AxiosResponse<BulkUpdatePlayerRecordByKeyResponseArray>>;
    /**
     * Retrieve player record key and payload in bulk under given namespace. Maximum bulk key limit per request 20.
     */
    fetchRecordBulk_ByUserId: (userId: string, data: BulkGetPlayerRecordsRequest) => Promise<AxiosResponse<BulkGetAdminPlayerRecordResponse>>;
    /**
     * This endpoints will create new player record or replace the existing player record in bulk. Maximum bulk key limit per request 10.
     */
    updateRecordBulk_ByUserId: (userId: string, data: BulkUpdatePlayerRecordsRequest) => Promise<AxiosResponse<BulkUpdatePlayerRecordResponseArray>>;
    /**
     * Delete a record (arbitrary JSON data) in user-level with given key.
     */
    deleteRecord_ByUserId_ByKey: (userId: string, key: string) => Promise<AxiosResponse<unknown>>;
    /**
     * Get a record in user-level (arbitrary JSON data) by its key.
     */
    getRecord_ByUserId_ByKey: (userId: string, key: string) => Promise<AxiosResponse<PlayerRecordResponse>>;
    /**
     * ## Description This endpoints will create new player record or append the existing player record. **Append example:** Example 1 - Existing JSON: `{ &#34;data1&#34;: &#34;value&#34; }` - New JSON: `{ &#34;data2&#34;: &#34;new value&#34; }` - Result: `{ &#34;data1&#34;: &#34;value&#34;, &#34;data2&#34;: &#34;new value&#34; }` Example 2 - Existing JSON: `{ &#34;data1&#34;: { &#34;data2&#34;: &#34;value&#34; }` - New JSON: `{ &#34;data1&#34;: { &#34;data3&#34;: &#34;new value&#34; }` - Result: `{ &#34;data1&#34;: { &#34;data2&#34;: &#34;value&#34;, &#34;data3&#34;: &#34;new value&#34; }` ## Restriction This is the restriction of Key Naming for the record: 1. Cannot use **&#34;.&#34;** as the key name - `{ &#34;data.2&#34;: &#34;value&#34; }` 2. Cannot use **&#34;$&#34;** as the prefix in key names - `{ &#34;$data&#34;: &#34;value&#34; }` 3. Cannot use empty string in key names - `{ &#34;&#34;: &#34;value&#34; }` ## Record Metadata Metadata allows user to define the behaviour of the record. Metadata can be defined in request body with field name **__META**. When creating record, if **__META** field is not defined, the metadata value will use the default value. When updating record, if **__META** field is not defined, the existing metadata value will stay as is. **Metadata List:** 1. set_by (default: CLIENT, type: string) Indicate which party that could modify the game record. SERVER: record can be modified by server only. CLIENT: record can be modified by client and server. 2. is_public (default: false, type: bool) Indicate whether the player record is a public record or not. 3. tags (default: *empty array*, type: array of string) Indicate the tagging for the game record. **Request Body Example:** ``` { &#34;__META&#34;: { &#34;set_by&#34;: &#34;SERVER&#34;, &#34;is_public&#34;: true, &#34;tags&#34;: [&#34;tag1&#34;, &#34;tag2&#34;] } ... } ```
     */
    createRecord_ByUserId_ByKey: (userId: string, key: string, data: PlayerRecordRequest) => Promise<AxiosResponse<PlayerRecordResponse>>;
    /**
     * ## Description This endpoints will create new player record or replace the existing player record. **Replace behaviour:** The existing value will be replaced completely with the new value. Example - Existing JSON: `{ &#34;data1&#34;: &#34;value&#34; }` - New JSON: `{ &#34;data2&#34;: &#34;new value&#34; }` - Result: `{ &#34;data2&#34;: &#34;new value&#34; }` ## Restriction This is the restriction of Key Naming for the record: 1. Cannot use **&#34;.&#34;** as the key name - `{ &#34;data.2&#34;: &#34;value&#34; }` 2. Cannot use **&#34;$&#34;** as the prefix in key names - `{ &#34;$data&#34;: &#34;value&#34; }` 3. Cannot use empty string in key names - `{ &#34;&#34;: &#34;value&#34; }` ## Record Metadata Metadata allows user to define the behaviour of the record. Metadata can be defined in request body with field name **__META**. When creating record, if **__META** field is not defined, the metadata value will use the default value. When updating record, if **__META** field is not defined, the existing metadata value will stay as is. **Metadata List:** 1. set_by (default: CLIENT, type: string) Indicate which party that could modify the game record. SERVER: record can be modified by server only. CLIENT: record can be modified by client and server. 2. is_public (default: false, type: bool) Indicate whether the player record is a public record or not. 3. tags (default: *empty array*, type: array of string) Indicate the tagging for the game record. **Request Body Example:** ``` { &#34;__META&#34;: { &#34;set_by&#34;: &#34;SERVER&#34;, &#34;is_public&#34;: true, &#34;tags&#34;: [&#34;tag1&#34;, &#34;tag2&#34;] } ... } ```
     */
    updateRecord_ByUserId_ByKey: (userId: string, key: string, data: PlayerRecordRequest) => Promise<AxiosResponse<PlayerRecordResponse>>;
    /**
     * Get a size of the player record
     */
    getSize_ByUserId_ByKey: (userId: string, key: string) => Promise<AxiosResponse<PlayerRecordSizeResponse>>;
    /**
     * Delete player public record. ## Warning: This endpoint is going to deprecate This endpoint is going to deprecate in the future please don&#39;t use it. For alternative, please use these endpoints: - **POST /cloudsave/v1/admin/namespaces/{namespace}/users/{userId}/records/{key}** and utilizing **__META** functionality - **PUT /cloudsave/v1/admin/namespaces/{namespace}/users/{userId}/records/{key}** and utilizing **__META** functionality - **DELETE /cloudsave/v1/admin/namespaces/{namespace}/users/{userId}/records/{key}**
     */
    deletePublic_ByUserId_ByKey: (userId: string, key: string) => Promise<AxiosResponse<unknown>>;
    /**
     * Get a record in user-level (arbitrary JSON data) by its key.
     */
    getPublic_ByUserId_ByKey: (userId: string, key: string) => Promise<AxiosResponse<PlayerRecordResponse>>;
    /**
     * ## Description This endpoints will create new player public record or append the existing player public record. **Append example:** Example 1 - Existing JSON: `{ &#34;data1&#34;: &#34;value&#34; }` - New JSON: `{ &#34;data2&#34;: &#34;new value&#34; }` - Result: `{ &#34;data1&#34;: &#34;value&#34;, &#34;data2&#34;: &#34;new value&#34; }` Example 2 - Existing JSON: `{ &#34;data1&#34;: { &#34;data2&#34;: &#34;value&#34; }` - New JSON: `{ &#34;data1&#34;: { &#34;data3&#34;: &#34;new value&#34; }` - Result: `{ &#34;data1&#34;: { &#34;data2&#34;: &#34;value&#34;, &#34;data3&#34;: &#34;new value&#34; }` ## Restriction This is the restriction of Key Naming for the record: 1. Cannot use **&#34;.&#34;** as the key name - `{ &#34;data.2&#34;: &#34;value&#34; }` 2. Cannot use **&#34;$&#34;** as the prefix in key names - `{ &#34;$data&#34;: &#34;value&#34; }` 3. Cannot use empty string in key names - `{ &#34;&#34;: &#34;value&#34; }` ## Warning: This endpoint is going to deprecate This endpoint is going to deprecate in the future please don&#39;t use it. For alternative, please use these endpoints: - **POST /cloudsave/v1/admin/namespaces/{namespace}/users/{userId}/records/{key}** and utilizing **__META** functionality - **PUT /cloudsave/v1/admin/namespaces/{namespace}/users/{userId}/records/{key}** and utilizing **__META** functionality - **DELETE /cloudsave/v1/admin/namespaces/{namespace}/users/{userId}/records/{key}**
     */
    createPublic_ByUserId_ByKey: (userId: string, key: string, data: PlayerRecordRequest) => Promise<AxiosResponse<PlayerRecordResponse>>;
    /**
     * ## Description This endpoints will create new player public record or replace the existing player public record. **Replace behaviour:** The existing value will be replaced completely with the new value. Example - Existing JSON: `{ &#34;data1&#34;: &#34;value&#34; }` - New JSON: `{ &#34;data2&#34;: &#34;new value&#34; }` - Result: `{ &#34;data2&#34;: &#34;new value&#34; }` ## Restriction This is the restriction of Key Naming for the record: 1. Cannot use **&#34;.&#34;** as the key name - `{ &#34;data.2&#34;: &#34;value&#34; }` 2. Cannot use **&#34;$&#34;** as the prefix in key names - `{ &#34;$data&#34;: &#34;value&#34; }` 3. Cannot use empty string in key names - `{ &#34;&#34;: &#34;value&#34; }` ## Warning: This endpoint is going to deprecate This endpoint is going to deprecate in the future please don&#39;t use it. For alternative, please use these endpoints: - **POST /cloudsave/v1/admin/namespaces/{namespace}/users/{userId}/records/{key}** and utilizing **__META** functionality - **PUT /cloudsave/v1/admin/namespaces/{namespace}/users/{userId}/records/{key}** and utilizing **__META** functionality - **DELETE /cloudsave/v1/admin/namespaces/{namespace}/users/{userId}/records/{key}**
     */
    updatePublic_ByUserId_ByKey: (userId: string, key: string, data: PlayerRecordRequest) => Promise<AxiosResponse<PlayerRecordResponse>>;
};

/**
 * AUTO GENERATED
 */

declare function PluginConfigAdminApi(sdk: AccelByteSDK, args?: SdkSetConfigParam): {
    /**
     * ## Description This endpoints will delete grpc plugins configuration
     */
    deletePlugin: () => Promise<AxiosResponse<unknown>>;
    /**
     * ## Description This endpoints will get grpc plugins configuration
     */
    getPlugins: () => Promise<AxiosResponse<PluginResponse>>;
    /**
     * ## Description This endpoints will update grpc plugins configuration
     */
    patchPlugin: (data: PluginRequest) => Promise<AxiosResponse<PluginResponse>>;
    /**
     * ## Description This endpoints will create new grpc plugins configuration per namespace
     */
    createPlugin: (data: PluginRequest) => Promise<AxiosResponse<PluginResponse>>;
};

/**
 * AUTO GENERATED
 */

declare function RecordAdminApi(sdk: AccelByteSDK, args?: SdkSetConfigParam): {
    /**
     * Retrieve list of records key by namespace
     */
    getAdminrecords: (queryParams?: {
        limit?: number;
        offset?: number;
        query?: string | null;
        tags?: string[];
    }) => Promise<AxiosResponse<ListAdminGameRecordKeysResponse>>;
    /**
     * Bulk get admin game records. Maximum key per request 20.
     */
    fetchAdminrecordBulk: (data: BulkGetAdminGameRecordRequest) => Promise<AxiosResponse<BulkGetAdminGameRecordResponse>>;
    /**
     * This endpoints delete game record in namespace-level
     */
    deleteAdminrecord_ByKey: (key: string) => Promise<AxiosResponse<unknown>>;
    /**
     * Get a record by its key in namespace-level.
     */
    getAdminrecord_ByKey: (key: string) => Promise<AxiosResponse<AdminGameRecordResponse>>;
    /**
     * ## Description This endpoints will create new admin game record or append the existing admin game record. **Append example:** Example 1 - Existing JSON: `{ &#34;data1&#34;: &#34;value&#34; }` - New JSON: `{ &#34;data2&#34;: &#34;new value&#34; }` - Result: `{ &#34;data1&#34;: &#34;value&#34;, &#34;data2&#34;: &#34;new value&#34; }` Example 2 - Existing JSON: `{ &#34;data1&#34;: { &#34;data2&#34;: &#34;value&#34; }` - New JSON: `{ &#34;data1&#34;: { &#34;data3&#34;: &#34;new value&#34; }` - Result: `{ &#34;data1&#34;: { &#34;data2&#34;: &#34;value&#34;, &#34;data3&#34;: &#34;new value&#34; }` ## Restriction This is the restriction of Key Naming for the record: 1. Cannot use **&#34;.&#34;** as the key name - `{ &#34;data.2&#34;: &#34;value&#34; }` 2. Cannot use **&#34;$&#34;** as the prefix in key names - `{ &#34;$data&#34;: &#34;value&#34; }` 3. Cannot use empty string in key names - `{ &#34;&#34;: &#34;value&#34; }` ## Record Metadata Metadata allows user to define the behaviour of the record. Metadata can be defined in request body with field name **__META**. When creating record, if **__META** field is not defined, the metadata value will use the default value. When updating record, if **__META** field is not defined, the existing metadata value will stay as is. **Metadata List:** 1. tags (default: *empty array*, type: array of string) Indicate the tagging for the admin record. **Request Body Example:** ``` { &#34;__META&#34;: { &#34;tags&#34;: [&#34;tag1&#34;, &#34;tag2&#34;] } ... } ```
     */
    createAdminrecord_ByKey: (key: string, data: AdminGameRecordRequest) => Promise<AxiosResponse<AdminGameRecordResponse>>;
    /**
     * ## Description This endpoints will create new admin game record or replace the existing admin game record. **Append example:** Example - Existing JSON: `{ &#34;data1&#34;: &#34;value&#34; }` - New JSON: `{ &#34;data2&#34;: &#34;new value&#34; }` - Result: `{ &#34;data2&#34;: &#34;new value&#34; }` ## Restriction This is the restriction of Key Naming for the record: 1. Cannot use **&#34;.&#34;** as the key name - `{ &#34;data.2&#34;: &#34;value&#34; }` 2. Cannot use **&#34;$&#34;** as the prefix in key names - `{ &#34;$data&#34;: &#34;value&#34; }` 3. Cannot use empty string in key names - `{ &#34;&#34;: &#34;value&#34; }` ## Record Metadata Metadata allows user to define the behaviour of the record. Metadata can be defined in request body with field name **__META**. When creating record, if **__META** field is not defined, the metadata value will use the default value. When updating record, if **__META** field is not defined, the existing metadata value will stay as is. **Metadata List:** 1. tags (default: *empty array*, type: array of string) Indicate the tagging for the admin record. **Request Body Example:** ``` { &#34;__META&#34;: { &#34;tags&#34;: [&#34;tag1&#34;, &#34;tag2&#34;] } ... } ```
     */
    updateAdminrecord_ByKey: (key: string, data: AdminGameRecordRequest) => Promise<AxiosResponse<AdminGameRecordResponse>>;
    /**
     * Retrieve list of admin player records key and userID under given namespace.
     */
    getAdminrecords_ByUserId: (userId: string, queryParams?: {
        limit?: number;
        offset?: number;
        query?: string | null;
        tags?: string[];
    }) => Promise<AxiosResponse<ListAdminPlayerRecordKeysResponse>>;
    /**
     * Bulk get admin player record by userIds, max allowed 20 at a time.
     */
    fetchBulkUser_ByKey: (key: string, data: BulkUserIDsRequest) => Promise<AxiosResponse<BulkGetAdminPlayerRecordResponse>>;
    /**
     * Bulk get admin player records. Maximum key per request 20.
     */
    fetchAdminrecordBulk_ByUserId: (userId: string, data: BulkGetAdminPlayerRecordRequest) => Promise<AxiosResponse<BulkGetAdminPlayerRecordResponse>>;
    /**
     * Delete a record (arbitrary JSON data) in user-level with given key.
     */
    deleteAdminrecord_ByUserId_ByKey: (userId: string, key: string) => Promise<AxiosResponse<unknown>>;
    /**
     * Get a admin record in user-level (arbitrary JSON data) by its key.
     */
    getAdminrecord_ByUserId_ByKey: (userId: string, key: string) => Promise<AxiosResponse<AdminPlayerRecordResponse>>;
    /**
     * ## Description This endpoints will create new admin player record or append the existing admin game record. **Append example:** Example 1 - Existing JSON: `{ &#34;data1&#34;: &#34;value&#34; }` - New JSON: `{ &#34;data2&#34;: &#34;new value&#34; }` - Result: `{ &#34;data1&#34;: &#34;value&#34;, &#34;data2&#34;: &#34;new value&#34; }` Example 2 - Existing JSON: `{ &#34;data1&#34;: { &#34;data2&#34;: &#34;value&#34; }` - New JSON: `{ &#34;data1&#34;: { &#34;data3&#34;: &#34;new value&#34; }` - Result: `{ &#34;data1&#34;: { &#34;data2&#34;: &#34;value&#34;, &#34;data3&#34;: &#34;new value&#34; }` ## Restriction This is the restriction of Key Naming for the record: 1. Cannot use **&#34;.&#34;** as the key name - `{ &#34;data.2&#34;: &#34;value&#34; }` 2. Cannot use **&#34;$&#34;** as the prefix in key names - `{ &#34;$data&#34;: &#34;value&#34; }` 3. Cannot use empty string in key names - `{ &#34;&#34;: &#34;value&#34; }` ## Record Metadata Metadata allows user to define the behaviour of the record. Metadata can be defined in request body with field name **__META**. When creating record, if **__META** field is not defined, the metadata value will use the default value. When updating record, if **__META** field is not defined, the existing metadata value will stay as is. **Metadata List:** 1. tags (default: *empty array*, type: array of string) Indicate the tagging for the admin record. **Request Body Example:** ``` { &#34;__META&#34;: { &#34;tags&#34;: [&#34;tag1&#34;, &#34;tag2&#34;] } ... } ```
     */
    createAdminrecord_ByUserId_ByKey: (userId: string, key: string, data: AdminPlayerRecordRequest) => Promise<AxiosResponse<AdminPlayerRecordResponse>>;
    /**
     * ## Description This endpoints will create new admin player record or replace the existing admin player record. **Replace behaviour:** The existing value will be replaced completely with the new value. Example - Existing JSON: `{ &#34;data1&#34;: &#34;value&#34; }` - New JSON: `{ &#34;data2&#34;: &#34;new value&#34; }` - Result: `{ &#34;data2&#34;: &#34;new value&#34; }` ## Restriction This is the restriction of Key Naming for the record: 1. Cannot use **&#34;.&#34;** as the key name - `{ &#34;data.2&#34;: &#34;value&#34; }` 2. Cannot use **&#34;$&#34;** as the prefix in key names - `{ &#34;$data&#34;: &#34;value&#34; }` 3. Cannot use empty string in key names - `{ &#34;&#34;: &#34;value&#34; }` ## Record Metadata Metadata allows user to define the behaviour of the record. Metadata can be defined in request body with field name **__META**. When creating record, if **__META** field is not defined, the metadata value will use the default value. When updating record, if **__META** field is not defined, the existing metadata value will stay as is. **Metadata List:** 1. tags (default: *empty array*, type: array of string) Indicate the tagging for the admin record. **Request Body Example:** ``` { &#34;__META&#34;: { &#34;tags&#34;: [&#34;tag1&#34;, &#34;tag2&#34;] } ... } ```
     */
    updateAdminrecord_ByUserId_ByKey: (userId: string, key: string, data: AdminPlayerRecordRequest) => Promise<AxiosResponse<AdminPlayerRecordResponse>>;
};

/**
 * AUTO GENERATED
 */

declare function TagsAdminApi(sdk: AccelByteSDK, args?: SdkSetConfigParam): {
    /**
     * ## Description Retrieve list of available tags by namespace
     */
    getTags: (queryParams?: {
        limit?: number;
        offset?: number;
    }) => Promise<AxiosResponse<ListTagsResponse>>;
    /**
     * ## Description This endpoint will create new tags
     */
    createTag: (data: TagRequest) => Promise<AxiosResponse<unknown>>;
    /**
     * ## Description This endpoint will delete tag by name
     */
    deleteTag_ByTag: (tag: string) => Promise<AxiosResponse<unknown>>;
};

/**
 * AUTO GENERATED
 */

declare function TtlConfigAdminApi(sdk: AccelByteSDK, args?: SdkSetConfigParam): {
    /**
     * ## Description This endpoints will delete the ttl config of the game record
     */
    deleteTtl_ByKey: (key: string) => Promise<AxiosResponse<unknown>>;
    /**
     * ## Description This endpoints will delete the ttl config of the game binary record
     */
    deleteTtl_ByKey_ByNS: (key: string) => Promise<AxiosResponse<unknown>>;
};

/**
 * AUTO GENERATED
 */

declare function ConcurrentRecordApi(sdk: AccelByteSDK, args?: SdkSetConfigParam): {
    /**
     * ## Description This endpoints will create new game record or replace the existing game record. **Replace behaviour:** The existing value will be replaced completely with the new value. Example - Existing JSON: `{ &#34;data1&#34;: &#34;value&#34; }` - New JSON: `{ &#34;data2&#34;: &#34;new value&#34; }` - Result: `{ &#34;data2&#34;: &#34;new value&#34; }` ## Restriction This is the restriction of Key Naming for the record: 1. Cannot use **&#34;.&#34;** as the key name - `{ &#34;data.2&#34;: &#34;value&#34; }` 2. Cannot use **&#34;$&#34;** as the prefix in key names - `{ &#34;$data&#34;: &#34;value&#34; }` 3. Cannot use empty string in key names - `{ &#34;&#34;: &#34;value&#34; }` ## Reserved Word Reserved Word List: **__META** The reserved word cannot be used as a field in record value, If still defining the field when creating or updating the record, it will be ignored. ## Optimistic Concurrency Control This endpoint implement optimistic concurrency control to avoid race condition. If the record has been updated since the client fetch it, the server will return HTTP status code 412 (precondition failed) and client need to redo the operation (fetch data and do update). Otherwise, the server will process the request.
     */
    updateConcurrentRecord_ByKey: (key: string, data: ConcurrentRecordRequest) => Promise<AxiosResponse<unknown>>;
    /**
     * ## Description This endpoints will create new player record or replace the existing player record. **Replace behaviour:** The existing value will be replaced completely with the new value. Example - Existing JSON: `{ &#34;data1&#34;: &#34;value&#34; }` - New JSON: `{ &#34;data2&#34;: &#34;new value&#34; }` - Result: `{ &#34;data2&#34;: &#34;new value&#34; }` ## Restriction This is the restriction of Key Naming for the record: 1. Cannot use **&#34;.&#34;** as the key name - `{ &#34;data.2&#34;: &#34;value&#34; }` 2. Cannot use **&#34;$&#34;** as the prefix in key names - `{ &#34;$data&#34;: &#34;value&#34; }` 3. Cannot use empty string in key names - `{ &#34;&#34;: &#34;value&#34; }` ## Reserved Word Reserved Word List: **__META** The reserved word cannot be used as a field in record value, If still defining the field when creating or updating the record, it will be ignored. ## Optimistic Concurrency Control This endpoint implement optimistic concurrency control to avoid race condition. If the record has been updated since the client fetch it, the server will return HTTP status code 412 (precondition failed) and client need to redo the operation (fetch data and do update). Otherwise, the server will process the request.
     */
    updateConcurrentRecord_ByUserId_ByKey: (userId: string, key: string, data: ConcurrentRecordRequest, queryParams?: {
        responseBody?: boolean | null;
    }) => Promise<AxiosResponse<PlayerRecordConcurrentUpdateResponse>>;
    /**
     * ## Description This endpoints will create new player public record or replace the existing player public record. **Replace behaviour:** The existing value will be replaced completely with the new value. Example - Existing JSON: `{ &#34;data1&#34;: &#34;value&#34; }` - New JSON: `{ &#34;data2&#34;: &#34;new value&#34; }` - Result: `{ &#34;data2&#34;: &#34;new value&#34; }` ## Restriction This is the restriction of Key Naming for the record: 1. Cannot use **&#34;.&#34;** as the key name - `{ &#34;data.2&#34;: &#34;value&#34; }` 2. Cannot use **&#34;$&#34;** as the prefix in key names - `{ &#34;$data&#34;: &#34;value&#34; }` 3. Cannot use empty string in key names - `{ &#34;&#34;: &#34;value&#34; }` ## Reserved Word Reserved Word List: **__META** The reserved word cannot be used as a field in record value, If still defining the field when creating or updating the record, it will be ignored. ## Optimistic Concurrency Control This endpoint implement optimistic concurrency control to avoid race condition. If the record has been updated since the client fetch it, the server will return HTTP status code 412 (precondition failed) and client need to redo the operation (fetch data and do update). Otherwise, the server will process the request.
     */
    updatePublicConcurrent_ByUserId_ByKey: (userId: string, key: string, data: ConcurrentRecordRequest, queryParams?: {
        responseBody?: boolean | null;
    }) => Promise<AxiosResponse<PlayerRecordConcurrentUpdateResponse>>;
};

/**
 * AUTO GENERATED
 */

declare function PublicGameBinaryRecordApi(sdk: AccelByteSDK, args?: SdkSetConfigParam): {
    /**
     * Retrieve list of binary records by namespace.
     */
    getBinaries: (queryParams?: {
        limit?: number;
        offset?: number;
        query?: string | null;
        tags?: string[];
    }) => Promise<AxiosResponse<ListGameBinaryRecordsResponse>>;
    /**
     * Create a game binary record. Other detail info: `key` should follow these rules: 1. support uppercase and lowercase letters, numbers, and separators **&#34;-&#34;**, **&#34;_&#34;**, **&#34;.&#34;** are allowed 2. begin and end with letters or numbers 3. spaces are not allowed 4. separators must not appears twice in a row Supported file types: jpeg, jpg, png, bmp, gif, mp3, webp, and bin.
     */
    createBinary: (data: PublicGameBinaryRecordCreate) => Promise<AxiosResponse<UploadBinaryRecordResponse>>;
    /**
     * Bulk get game binary records. Maximum key per request 20.
     */
    createBinaryBulk: (data: BulkGetGameRecordRequest) => Promise<AxiosResponse<BulkGetGameBinaryRecordResponse>>;
    /**
     * Delete a game binary record.
     */
    deleteBinary_ByKey: (key: string) => Promise<AxiosResponse<unknown>>;
    /**
     * Get a game binary record by its key.
     */
    getBinary_ByKey: (key: string) => Promise<AxiosResponse<GameBinaryRecordResponse>>;
    /**
     * Update a game binary record file by its key
     */
    updateBinary_ByKey: (key: string, data: BinaryRecordRequest) => Promise<AxiosResponse<GameBinaryRecordResponse>>;
    /**
     * Request presigned URL to upload the binary record to s3. Other detail info: Supported file types: jpeg, jpg, png, bmp, gif, mp3, webp, and bin.
     */
    createPresigned_ByKey: (key: string, data: UploadBinaryRecordRequest) => Promise<AxiosResponse<UploadBinaryRecordResponse>>;
};

/**
 * AUTO GENERATED
 */

declare function PublicGameRecordApi(sdk: AccelByteSDK, args?: SdkSetConfigParam): {
    /**
     * Bulk get game records. Maximum key per request 20.
     */
    fetchRecordBulk: (data: BulkGetGameRecordRequest) => Promise<AxiosResponse<BulkGetGameRecordResponse>>;
    /**
     * Delete records by its key
     */
    deleteRecord_ByKey: (key: string) => Promise<AxiosResponse<unknown>>;
    /**
     * Get game record by its key.
     */
    getRecord_ByKey: (key: string) => Promise<AxiosResponse<GameRecordResponse>>;
    /**
     * ## Description This endpoints will create new game record or append the existing game record. **Append example:** Example 1 - Existing JSON: `{ &#34;data1&#34;: &#34;value&#34; }` - New JSON: `{ &#34;data2&#34;: &#34;new value&#34; }` - Result: `{ &#34;data1&#34;: &#34;value&#34;, &#34;data2&#34;: &#34;new value&#34; }` Example 2 - Existing JSON: `{ &#34;data1&#34;: { &#34;data2&#34;: &#34;value&#34; }` - New JSON: `{ &#34;data1&#34;: { &#34;data3&#34;: &#34;new value&#34; }` - Result: `{ &#34;data1&#34;: { &#34;data2&#34;: &#34;value&#34;, &#34;data3&#34;: &#34;new value&#34; }` ## Restriction This is the restriction of Key Naming for the record: 1. Cannot use **&#34;.&#34;** as the key name - `{ &#34;data.2&#34;: &#34;value&#34; }` 2. Cannot use **&#34;$&#34;** as the prefix in key names - `{ &#34;$data&#34;: &#34;value&#34; }` 3. Cannot use empty string in key names - `{ &#34;&#34;: &#34;value&#34; }` ## Reserved Word Reserved Word List: **__META** The reserved word cannot be used as a field in record value, If still defining the field when creating or updating the record, it will be ignored.
     */
    createRecord_ByKey: (key: string, data: GameRecordRequest) => Promise<AxiosResponse<GameRecordResponse>>;
    /**
     * ## Description This endpoints will create new game record or replace the existing game record. **Replace behaviour:** The existing value will be replaced completely with the new value. Example - Existing JSON: `{ &#34;data1&#34;: &#34;value&#34; }` - New JSON: `{ &#34;data2&#34;: &#34;new value&#34; }` - Result: `{ &#34;data2&#34;: &#34;new value&#34; }` ## Restriction This is the restriction of Key Naming for the record: 1. Cannot use **&#34;.&#34;** as the key name - `{ &#34;data.2&#34;: &#34;value&#34; }` 2. Cannot use **&#34;$&#34;** as the prefix in key names - `{ &#34;$data&#34;: &#34;value&#34; }` 3. Cannot use empty string in key names - `{ &#34;&#34;: &#34;value&#34; }` ## Reserved Word Reserved Word List: **__META** The reserved word cannot be used as a field in record value, If still defining the field when creating or updating the record, it will be ignored.
     */
    updateRecord_ByKey: (key: string, data: GameRecordRequest) => Promise<AxiosResponse<GameRecordResponse>>;
};

/**
 * AUTO GENERATED
 */

declare function PublicPlayerBinaryRecordApi(sdk: AccelByteSDK, args?: SdkSetConfigParam): {
    /**
     * Retrieve list of my binary records by namespace.
     */
    getUsersMeBinaries: (queryParams?: {
        limit?: number;
        offset?: number;
        query?: string | null;
        tags?: string[];
    }) => Promise<AxiosResponse<ListPlayerBinaryRecordsResponse>>;
    /**
     * Retrieve player record key and payload in bulk under given namespace. Maximum bulk key limit per request 20
     */
    createUserMeBinaryBulk: (data: BulkGetPlayerRecordsRequest) => Promise<AxiosResponse<BulkGetPlayerBinaryRecordResponse>>;
    /**
     * Create a player binary record. Other detail info: `key` should follow these rules: 1. support uppercase and lowercase letters, numbers, and separators **&#34;-&#34;**, **&#34;_&#34;**, **&#34;.&#34;** are allowed 2. begin and end with letters or numbers 3. spaces are not allowed 4. separators must not appears twice in a row Supported file types: jpeg, jpg, png, bmp, gif, mp3, webp, and bin.
     */
    createBinary_ByUserId: (userId: string, data: PublicPlayerBinaryRecordCreate) => Promise<AxiosResponse<UploadBinaryRecordResponse>>;
    /**
     * Delete a player binary record. Only player who own the record can delete it
     */
    deleteBinary_ByUserId_ByKey: (userId: string, key: string) => Promise<AxiosResponse<unknown>>;
    /**
     * Get a player binary record by its key. **Private Record**: Only user who own the record could retrieve it.
     */
    getBinary_ByUserId_ByKey: (userId: string, key: string) => Promise<AxiosResponse<PlayerBinaryRecordResponse>>;
    /**
     * Update a player binary record file by its key
     */
    updateBinary_ByUserId_ByKey: (userId: string, key: string, data: BinaryRecordRequest) => Promise<AxiosResponse<PlayerBinaryRecordResponse>>;
    /**
     * Retrieve list of other player public binary records under given namespace.
     */
    getBinariesPublic_ByUserId: (userId: string, queryParams?: {
        limit?: number;
        offset?: number;
        tags?: string[];
    }) => Promise<AxiosResponse<ListPlayerBinaryRecordsResponse>>;
    /**
     * Bulk get other player&#39;s public binary record by userIds, max allowed 20 at a time. Only record with `isPublic=true` can be retrieved using this endpoint.
     */
    fetchPublicBulkUser_ByKey: (key: string, data: BulkUserIDsRequest) => Promise<AxiosResponse<BulkGetPlayerBinaryRecordResponse>>;
    /**
     * Retrieve other player public binary record in bulk under given namespace. Maximum bulk key limit per request 20
     */
    fetchBinaryBulk_ByUserId: (userId: string, data: BulkGetPlayerRecordsRequest) => Promise<AxiosResponse<BulkGetPlayerBinaryRecordResponse>>;
    /**
     * Get other player&#39;s public binary record. Only record with `isPublic=true` can be retrieved using this endpoint.
     */
    getPublic_ByUserId_ByKey: (userId: string, key: string) => Promise<AxiosResponse<PlayerBinaryRecordResponse>>;
    /**
     * Update a player binary record metadata by its key
     */
    updateMetadata_ByUserId_ByKey: (userId: string, key: string, data: PlayerBinaryRecordMetadataPublicRequest) => Promise<AxiosResponse<PlayerBinaryRecordResponse>>;
    /**
     * Request presigned URL to upload the binary record to s3. Other detail info: Supported file types: jpeg, jpg, png, bmp, gif, mp3, webp, and bin.
     */
    createPresigned_ByUserId_ByKey: (userId: string, key: string, data: UploadBinaryRecordRequest) => Promise<AxiosResponse<UploadBinaryRecordResponse>>;
};

/**
 * AUTO GENERATED
 */

declare function PublicPlayerRecordApi(sdk: AccelByteSDK, args?: SdkSetConfigParam): {
    /**
     * Retrieve list of player records key under given namespace.
     */
    getUsersMeRecords: (queryParams?: {
        limit?: number;
        offset?: number;
        tags?: string[];
    }) => Promise<AxiosResponse<ListPlayerRecordKeysResponse>>;
    /**
     * Retrieve player record key and payload in bulk under given namespace. Maximum bulk key limit per request 20
     */
    createUserMeRecordBulk: (data: BulkGetPlayerRecordsRequest) => Promise<AxiosResponse<BulkGetPlayerRecordResponse>>;
    /**
     * Delete player record by its key. Only user that own the player record could delete it.
     */
    deleteRecord_ByUserId_ByKey: (userId: string, key: string) => Promise<AxiosResponse<unknown>>;
    /**
     * Get player record by its key. **Private Record**: Only user that own the player record could retrieve it.
     */
    getRecord_ByUserId_ByKey: (userId: string, key: string) => Promise<AxiosResponse<PlayerRecordResponse>>;
    /**
     * ## Description This endpoints will create new player record or append the existing player record. Only user that own the existing player record could modify. **Append example:** Example 1 - Existing JSON: `{ &#34;data1&#34;: &#34;value&#34; }` - New JSON: `{ &#34;data2&#34;: &#34;new value&#34; }` - Result: `{ &#34;data1&#34;: &#34;value&#34;, &#34;data2&#34;: &#34;new value&#34; }` Example 2 - Existing JSON: `{ &#34;data1&#34;: { &#34;data2&#34;: &#34;value&#34; }` - New JSON: `{ &#34;data1&#34;: { &#34;data3&#34;: &#34;new value&#34; }` - Result: `{ &#34;data1&#34;: { &#34;data2&#34;: &#34;value&#34;, &#34;data3&#34;: &#34;new value&#34; }` ## Restriction This is the restriction of Key Naming for the record: 1. Cannot use **&#34;.&#34;** as the key name - `{ &#34;data.2&#34;: &#34;value&#34; }` 2. Cannot use **&#34;$&#34;** as the prefix in key names - `{ &#34;$data&#34;: &#34;value&#34; }` 3. Cannot use empty string in key names - `{ &#34;&#34;: &#34;value&#34; }` ## Record Metadata Metadata allows user to define the behaviour of the record. Metadata can be defined in request body with field name **__META**. When creating record, if **__META** field is not defined, the metadata value will use the default value. When updating record, if **__META** field is not defined, the existing metadata value will stay as is. **Metadata List:** 1. is_public (default: false, type: bool) Indicate whether the player record is a public record or not. **Request Body Example:** ``` { &#34;__META&#34;: { &#34;is_public&#34;: true } ... } ```
     */
    createRecord_ByUserId_ByKey: (userId: string, key: string, data: PlayerRecordRequest) => Promise<AxiosResponse<PlayerRecordResponse>>;
    /**
     * ## Description This endpoints will create new player record or replace the existing player record. Only user that own the existing player record could modify it. **Replace behaviour:** The existing value will be replaced completely with the new value. Example - Existing JSON: `{ &#34;data1&#34;: &#34;value&#34; }` - New JSON: `{ &#34;data2&#34;: &#34;new value&#34; }` - Result: `{ &#34;data2&#34;: &#34;new value&#34; }` ## Restriction This is the restriction of Key Naming for the record: 1. Cannot use **&#34;.&#34;** as the key name - `{ &#34;data.2&#34;: &#34;value&#34; }` 2. Cannot use **&#34;$&#34;** as the prefix in key names - `{ &#34;$data&#34;: &#34;value&#34; }` 3. Cannot use empty string in key names - `{ &#34;&#34;: &#34;value&#34; }` ## Record Metadata Metadata allows user to define the behaviour of the record. Metadata can be defined in request body with field name **__META**. When creating record, if **__META** field is not defined, the metadata value will use the default value. When updating record, if **__META** field is not defined, the existing metadata value will stay as is. **Metadata List:** 1. is_public (default: false, type: bool) Indicate whether the player record is a public record or not. **Request Body Example:** ``` { &#34;__META&#34;: { &#34;is_public&#34;: true } ... } ```
     */
    updateRecord_ByUserId_ByKey: (userId: string, key: string, data: PlayerRecordRequest) => Promise<AxiosResponse<PlayerRecordResponse>>;
    /**
     * Retrieve list of other public player records key under given namespace.
     */
    getRecordsPublic_ByUserId: (userId: string, queryParams?: {
        limit?: number;
        offset?: number;
        tags?: string[];
    }) => Promise<AxiosResponse<ListPlayerRecordKeysResponse>>;
    /**
     * Delete player public record. ## Warning: This endpoint is going to deprecate This endpoint is going to deprecate in the future please don&#39;t use it. For alternative, please use these endpoints: - **POST /cloudsave/v1/namespaces/{namespace}/users/{userId}/records/{key}** and utilizing **__META** functionality - **PUT /cloudsave/v1/namespaces/{namespace}/users/{userId}/records/{key}** and utilizing **__META** functionality - **DELETE /cloudsave/v1/namespaces/{namespace}/users/{userId}/records/{key}**
     */
    deletePublicMeUser_ByKey: (key: string) => Promise<AxiosResponse<unknown>>;
    /**
     * Bulk get other player&#39;s record that is public by userIds, max allowed 20 at a time. Only record with `isPublic=true` that can be retrieved using this endpoint.
     */
    fetchPublicBulkUser_ByKey: (key: string, data: BulkUserIDsRequest) => Promise<AxiosResponse<BulkGetPlayerRecordResponse>>;
    /**
     * Retrieve other player public record key and payload in bulk under given namespace. Maximum bulk key limit per request 20
     */
    fetchRecordBulk_ByUserId: (userId: string, data: BulkGetPlayerRecordsRequest) => Promise<AxiosResponse<BulkGetPlayerRecordResponse>>;
    /**
     * Get other player&#39;s record that is public. Only record with `isPublic=true` that can be retrieved using this endpoint.
     */
    getPublic_ByUserId_ByKey: (userId: string, key: string) => Promise<AxiosResponse<PlayerRecordResponse>>;
    /**
     * ## Description This endpoints will create new player public record or append the existing player public record. **Append example:** Example 1 - Existing JSON: `{ &#34;data1&#34;: &#34;value&#34; }` - New JSON: `{ &#34;data2&#34;: &#34;new value&#34; }` - Result: `{ &#34;data1&#34;: &#34;value&#34;, &#34;data2&#34;: &#34;new value&#34; }` Example 2 - Existing JSON: `{ &#34;data1&#34;: { &#34;data2&#34;: &#34;value&#34; }` - New JSON: `{ &#34;data1&#34;: { &#34;data3&#34;: &#34;new value&#34; }` - Result: `{ &#34;data1&#34;: { &#34;data2&#34;: &#34;value&#34;, &#34;data3&#34;: &#34;new value&#34; }` ## Restriction This is the restriction of Key Naming for the record: 1. Cannot use **&#34;.&#34;** as the key name - `{ &#34;data.2&#34;: &#34;value&#34; }` 2. Cannot use **&#34;$&#34;** as the prefix in key names - `{ &#34;$data&#34;: &#34;value&#34; }` 3. Cannot use empty string in key names - `{ &#34;&#34;: &#34;value&#34; }` ## Reserved Word Reserved Word List: **__META** The reserved word cannot be used as a field in record value, If still defining the field when creating or updating the record, it will be ignored. ## Warning: This endpoint is going to deprecate This endpoint is going to deprecate in the future please don&#39;t use it. For alternative, please use these endpoints: - **POST /cloudsave/v1/namespaces/{namespace}/users/{userId}/records/{key}** and utilizing **__META** functionality - **PUT /cloudsave/v1/namespaces/{namespace}/users/{userId}/records/{key}** and utilizing **__META** functionality - **DELETE /cloudsave/v1/namespaces/{namespace}/users/{userId}/records/{key}**
     */
    createPublic_ByUserId_ByKey: (userId: string, key: string, data: PlayerRecordRequest) => Promise<AxiosResponse<PlayerRecordResponse>>;
    /**
     * ## Description This endpoints will create new player public record or replace the existing player public record. **Replace behaviour:** The existing value will be replaced completely with the new value. Example - Existing JSON: `{ &#34;data1&#34;: &#34;value&#34; }` - New JSON: `{ &#34;data2&#34;: &#34;new value&#34; }` - Result: `{ &#34;data2&#34;: &#34;new value&#34; }` ## Restriction This is the restriction of Key Naming for the record: 1. Cannot use **&#34;.&#34;** as the key name - `{ &#34;data.2&#34;: &#34;value&#34; }` 2. Cannot use **&#34;$&#34;** as the prefix in key names - `{ &#34;$data&#34;: &#34;value&#34; }` 3. Cannot use empty string in key names - `{ &#34;&#34;: &#34;value&#34; }` ## Reserved Word Reserved Word List: **__META** The reserved word cannot be used as a field in record value, If still defining the field when creating or updating the record, it will be ignored. ## Warning: This endpoint is going to deprecate This endpoint is going to deprecate in the future please don&#39;t use it. For alternative, please use these endpoints: - **POST /cloudsave/v1/namespaces/{namespace}/users/{userId}/records/{key}** and utilizing **__META** functionality - **PUT /cloudsave/v1/namespaces/{namespace}/users/{userId}/records/{key}** and utilizing **__META** functionality - **DELETE /cloudsave/v1/namespaces/{namespace}/users/{userId}/records/{key}**
     */
    updatePublic_ByUserId_ByKey: (userId: string, key: string, data: PlayerRecordRequest) => Promise<AxiosResponse<PlayerRecordResponse>>;
};

/**
 * AUTO GENERATED
 */

declare function PublicTagsApi(sdk: AccelByteSDK, args?: SdkSetConfigParam): {
    /**
     * ## Description Retrieve list of available tags by namespace
     */
    getTags: (queryParams?: {
        limit?: number;
        offset?: number;
    }) => Promise<AxiosResponse<ListTagsResponse>>;
};

/**
 * AUTO GENERATED
 */

declare const Cloudsave: {
    TagsAdminApi: typeof TagsAdminApi;
    PluginConfigAdminApi: typeof PluginConfigAdminApi;
    GameRecordAdminApi: typeof GameRecordAdminApi;
    GameBinaryRecordAdminApi: typeof GameBinaryRecordAdminApi;
    RecordAdminApi: typeof RecordAdminApi;
    PlayerRecordAdminApi: typeof PlayerRecordAdminApi;
    TtlConfigAdminApi: typeof TtlConfigAdminApi;
    PlayerBinaryRecordAdminApi: typeof PlayerBinaryRecordAdminApi;
    ConcurrentRecordAdminApi: typeof ConcurrentRecordAdminApi;
    PublicTagsApi: typeof PublicTagsApi;
    PublicGameBinaryRecordApi: typeof PublicGameBinaryRecordApi;
    PublicGameRecordApi: typeof PublicGameRecordApi;
    PublicPlayerRecordApi: typeof PublicPlayerRecordApi;
    PublicPlayerBinaryRecordApi: typeof PublicPlayerBinaryRecordApi;
    ConcurrentRecordApi: typeof ConcurrentRecordApi;
    version: () => void;
};

/**
 * AUTO GENERATED
 */

declare class ConcurrentRecordAdmin$ {
    private axiosInstance;
    private namespace;
    private useSchemaValidation;
    constructor(axiosInstance: AxiosInstance, namespace: string, useSchemaValidation?: boolean);
    /**
     * ## Description This endpoints will create new game record or replace the existing game record. **Replace behaviour:** The existing value will be replaced completely with the new value. Example - Existing JSON: `{ &#34;data1&#34;: &#34;value&#34; }` - New JSON: `{ &#34;data2&#34;: &#34;new value&#34; }` - Result: `{ &#34;data2&#34;: &#34;new value&#34; }` ## Restriction This is the restriction of Key Naming for the record: 1. Cannot use **&#34;.&#34;** as the key name - `{ &#34;data.2&#34;: &#34;value&#34; }` 2. Cannot use **&#34;$&#34;** as the prefix in key names - `{ &#34;$data&#34;: &#34;value&#34; }` 3. Cannot use empty string in key names - `{ &#34;&#34;: &#34;value&#34; }` ## Reserved Word Reserved Word List: **__META** The reserved word cannot be used as a field in record value, If still defining the field when creating or updating the record, it will be ignored. ## Parameters Notes 1. set_by (default: CLIENT, type: string) Indicate which party that could modify the game record. SERVER: record can be modified by server only. CLIENT: record can be modified by client and server. 2. updatedAt (required: true) Time format style: RFC3339 3. value Json 4. tags (default: *empty array*, type: array of string) Indicate the tagging for the game record. **Request Body Example:** ``` { &#34;set_by&#34;: &#34;SERVER&#34;, &#34;value&#34;: {}, &#34;updatedAt&#34;: &#34;2022-03-17T10:42:15.444Z&#34;, &#34;tags&#34;: [&#34;tag1&#34;, &#34;tag2&#34;] } ``` ## Optimistic Concurrency Control This endpoint implement optimistic concurrency control to avoid race condition. If the record has been updated since the client fetch it, the server will return HTTP status code 412 (precondition failed) and client need to redo the operation (fetch data and do update). Otherwise, the server will process the request.
     */
    updateConcurrentRecord_ByKey(key: string, data: AdminConcurrentRecordRequest): Promise<Response<unknown>>;
    /**
     * ## Description This endpoints will create new game record or replace the existing game record. **Replace behaviour:** The existing value will be replaced completely with the new value. Example - Existing JSON: `{ &#34;data1&#34;: &#34;value&#34; }` - New JSON: `{ &#34;data2&#34;: &#34;new value&#34; }` - Result: `{ &#34;data2&#34;: &#34;new value&#34; }` ## Restriction This is the restriction of Key Naming for the record: 1. Cannot use **&#34;.&#34;** as the key name - `{ &#34;data.2&#34;: &#34;value&#34; }` 2. Cannot use **&#34;$&#34;** as the prefix in key names - `{ &#34;$data&#34;: &#34;value&#34; }` 3. Cannot use empty string in key names - `{ &#34;&#34;: &#34;value&#34; }` ## Reserved Word Reserved Word List: **__META** The reserved word cannot be used as a field in record value, If still defining the field when creating or updating the record, it will be ignored. ## Parameters Notes 1. updatedAt (required: true) Time format style: RFC3339 2. value Json 3. tags (default: *empty array*, type: array of string) Indicate the tagging for the admin record. **Request Body Example:** ``` { &#34;value&#34;: {}, &#34;updatedAt&#34;: &#34;2022-03-17T10:42:15.444Z&#34;, &#34;tags&#34;: [&#34;tag1&#34;, &#34;tag2&#34;] } ``` ## Optimistic Concurrency Control This endpoint implement optimistic concurrency control to avoid race condition. If the record has been updated since the client fetch it, the server will return HTTP status code 412 (precondition failed) and client need to redo the operation (fetch data and do update). Otherwise, the server will process the request.
     */
    updateConcurrentAdminrecord_ByKey(key: string, data: AdminGameConcurrentRecordRequest): Promise<Response<unknown>>;
    /**
     * ## Description This endpoints will create new player record or replace the existing player record. **Replace behaviour:** The existing value will be replaced completely with the new value. Example - Existing JSON: `{ &#34;data1&#34;: &#34;value&#34; }` - New JSON: `{ &#34;data2&#34;: &#34;new value&#34; }` - Result: `{ &#34;data2&#34;: &#34;new value&#34; }` ## Restriction This is the restriction of Key Naming for the record: 1. Cannot use **&#34;.&#34;** as the key name - `{ &#34;data.2&#34;: &#34;value&#34; }` 2. Cannot use **&#34;$&#34;** as the prefix in key names - `{ &#34;$data&#34;: &#34;value&#34; }` 3. Cannot use empty string in key names - `{ &#34;&#34;: &#34;value&#34; }` ## Reserved Word Reserved Word List: **__META** The reserved word cannot be used as a field in record value, If still defining the field when creating or updating the record, it will be ignored. ## Parameters Notes 1. set_by (default: CLIENT, type: string) Indicate which party that could modify the game record. SERVER: record can be modified by server only. CLIENT: record can be modified by client and server. 2. updatedAt (required: true) Time format style: RFC3339 3. value Json 4. tags (default: *empty array*, type: array of string) Indicate the tagging for the game record. **Request Body Example:** ``` { &#34;set_by&#34;: &#34;SERVER&#34;, &#34;value&#34;: {}, &#34;updatedAt&#34;: &#34;2022-03-17T10:42:15.444Z&#34;, &#34;tags&#34;: [&#34;tag1&#34;, &#34;tag2&#34;] } ``` ## Optimistic Concurrency Control This endpoint implement optimistic concurrency control to avoid race condition. If the record has been updated since the client fetch it, the server will return HTTP status code 412 (precondition failed) and client need to redo the operation (fetch data and do update). Otherwise, the server will process the request.
     */
    updateConcurrentRecord_ByUserId_ByKey(userId: string, key: string, data: AdminConcurrentRecordRequest, queryParams?: {
        responseBody?: boolean | null;
    }): Promise<Response<PlayerRecordConcurrentUpdateResponse>>;
    /**
     * ## Description This endpoints will create new admin player record or replace the existing admin player record. **Replace behaviour:** The existing value will be replaced completely with the new value. Example - Existing JSON: `{ &#34;data1&#34;: &#34;value&#34; }` - New JSON: `{ &#34;data2&#34;: &#34;new value&#34; }` - Result: `{ &#34;data2&#34;: &#34;new value&#34; }` ## Restriction This is the restriction of Key Naming for the record: 1. Cannot use **&#34;.&#34;** as the key name - `{ &#34;data.2&#34;: &#34;value&#34; }` 2. Cannot use **&#34;$&#34;** as the prefix in key names - `{ &#34;$data&#34;: &#34;value&#34; }` 3. Cannot use empty string in key names - `{ &#34;&#34;: &#34;value&#34; }` ## Reserved Word Reserved Word List: **__META** The reserved word cannot be used as a field in record value, If still defining the field when creating or updating the record, it will be ignored. ## Parameters Notes 1. updatedAt (required: true) Time format style: RFC3339 2. value Json 3. tags (default: *empty array*, type: array of string) Indicate the tagging for the admin record. **Request Body Example:** ``` { &#34;value&#34;: {}, &#34;updatedAt&#34;: &#34;2022-03-17T10:42:15.444Z&#34;, &#34;tags&#34;: [&#34;tag1&#34;, &#34;tag2&#34;] } ``` ## Optimistic Concurrency Control This endpoint implement optimistic concurrency control to avoid race condition. If the record has been updated since the client fetch it, the server will return HTTP status code 412 (precondition failed) and client need to redo the operation (fetch data and do update). Otherwise, the server will process the request.
     */
    updateConcurrentAdminrecord_ByUserId_ByKey(userId: string, key: string, data: AdminPlayerConcurrentRecordRequest, queryParams?: {
        responseBody?: boolean | null;
    }): Promise<Response<PlayerRecordConcurrentUpdateResponse>>;
    /**
     * ## Description This endpoints will create new player public record or replace the existing player public record. **Replace behaviour:** The existing value will be replaced completely with the new value. Example - Existing JSON: `{ &#34;data1&#34;: &#34;value&#34; }` - New JSON: `{ &#34;data2&#34;: &#34;new value&#34; }` - Result: `{ &#34;data2&#34;: &#34;new value&#34; }` ## Restriction This is the restriction of Key Naming for the record: 1. Cannot use **&#34;.&#34;** as the key name - `{ &#34;data.2&#34;: &#34;value&#34; }` 2. Cannot use **&#34;$&#34;** as the prefix in key names - `{ &#34;$data&#34;: &#34;value&#34; }` 3. Cannot use empty string in key names - `{ &#34;&#34;: &#34;value&#34; }` ## Reserved Word Reserved Word List: **__META** The reserved word cannot be used as a field in record value, If still defining the field when creating or updating the record, it will be ignored. ## Parameters Notes 1. set_by (default: CLIENT, type: string) Indicate which party that could modify the game record. SERVER: record can be modified by server only. CLIENT: record can be modified by client and server. 2. updatedAt (required: true) Time format style: RFC3339 3. value Json 4. tags (default: *empty array*, type: array of string) Indicate the tagging for the game record. **Request Body Example:** ``` { &#34;set_by&#34;: &#34;SERVER&#34;, &#34;value&#34;: {}, &#34;updatedAt&#34;: &#34;2022-03-17T10:42:15.444Z&#34;, &#34;tags&#34;: [&#34;tag1&#34;, &#34;tag2&#34;] } ``` ## Optimistic Concurrency Control This endpoint implement optimistic concurrency control to avoid race condition. If the record has been updated since the client fetch it, the server will return HTTP status code 412 (precondition failed) and client need to redo the operation (fetch data and do update). Otherwise, the server will process the request.
     */
    updatePublicConcurrent_ByUserId_ByKey(userId: string, key: string, data: AdminConcurrentRecordRequest, queryParams?: {
        responseBody?: boolean | null;
    }): Promise<Response<PlayerRecordConcurrentUpdateResponse>>;
}

/**
 * AUTO GENERATED
 */

declare class GameBinaryRecordAdmin$ {
    private axiosInstance;
    private namespace;
    private useSchemaValidation;
    constructor(axiosInstance: AxiosInstance, namespace: string, useSchemaValidation?: boolean);
    /**
     * Retrieve list of binary records by namespace.
     */
    getBinaries(queryParams?: {
        limit?: number;
        offset?: number;
        query?: string | null;
        tags?: string[];
    }): Promise<Response<ListGameBinaryRecordsAdminResponse>>;
    /**
     * Create a game binary record. Other detail info: `key` should follow these rules: 1. support uppercase and lowercase letters, numbers, and separators **&#34;-&#34;**, **&#34;_&#34;**, **&#34;.&#34;** are allowed 2. begin and end with letters or numbers 3. spaces are not allowed 4. separators must not appears twice in a row Supported file types: jpeg, jpg, png, bmp, gif, mp3, webp, and bin.
     */
    createBinary(data: GameBinaryRecordCreate): Promise<Response<UploadBinaryRecordResponse>>;
    /**
     * Delete a game binary record.
     */
    deleteBinary_ByKey(key: string): Promise<Response<unknown>>;
    /**
     * Get a game binary record by its key.
     */
    getBinary_ByKey(key: string): Promise<Response<GameBinaryRecordAdminResponse>>;
    /**
     * Update a game binary record file by its key
     */
    updateBinary_ByKey(key: string, data: BinaryRecordRequest): Promise<Response<GameBinaryRecordAdminResponse>>;
    /**
     * Update a game binary record metadata by its key
     */
    updateMetadata_ByKey(key: string, data: GameBinaryRecordMetadataRequest): Promise<Response<GameBinaryRecordAdminResponse>>;
    /**
     * Request presigned URL to upload the binary record to s3. Other detail info: Supported file types: jpeg, jpg, png, bmp, gif, mp3, webp, and bin.
     */
    createPresigned_ByKey(key: string, data: UploadBinaryRecordRequest): Promise<Response<UploadBinaryRecordResponse>>;
}

/**
 * AUTO GENERATED
 */

declare class GameRecordAdmin$ {
    private axiosInstance;
    private namespace;
    private useSchemaValidation;
    constructor(axiosInstance: AxiosInstance, namespace: string, useSchemaValidation?: boolean);
    /**
     * Retrieve list of records key by namespace
     */
    getRecords(queryParams: {
        limit: number;
        offset: number;
        query?: string | null;
        tags?: string[];
    }): Promise<Response<ListGameRecordKeysResponse>>;
    /**
     * This endpoints delete game record in namespace-level
     */
    deleteRecord_ByKey(key: string): Promise<Response<unknown>>;
    /**
     * Get a record by its key in namespace-level.
     */
    getRecord_ByKey(key: string): Promise<Response<GameRecordAdminResponse>>;
    /**
     * ## Description This endpoints will create new game record or append the existing game record. **Append example:** Example 1 - Existing JSON: `{ &#34;data1&#34;: &#34;value&#34; }` - New JSON: `{ &#34;data2&#34;: &#34;new value&#34; }` - Result: `{ &#34;data1&#34;: &#34;value&#34;, &#34;data2&#34;: &#34;new value&#34; }` Example 2 - Existing JSON: `{ &#34;data1&#34;: { &#34;data2&#34;: &#34;value&#34; }` - New JSON: `{ &#34;data1&#34;: { &#34;data3&#34;: &#34;new value&#34; }` - Result: `{ &#34;data1&#34;: { &#34;data2&#34;: &#34;value&#34;, &#34;data3&#34;: &#34;new value&#34; }` ## Restriction This is the restriction of Key Naming for the record: 1. Cannot use **&#34;.&#34;** as the key name - `{ &#34;data.2&#34;: &#34;value&#34; }` 2. Cannot use **&#34;$&#34;** as the prefix in key names - `{ &#34;$data&#34;: &#34;value&#34; }` 3. Cannot use empty string in key names - `{ &#34;&#34;: &#34;value&#34; }` ## Record Metadata Metadata allows user to define the behaviour of the record. Metadata can be defined in request body with field name **__META**. When creating record, if **__META** field is not defined, the metadata value will use the default value. When updating record, if **__META** field is not defined, the existing metadata value will stay as is. **Metadata List:** 1. set_by (default: CLIENT, type: string) Indicate which party that could modify the game record. SERVER: record can be modified by server only. CLIENT: record can be modified by client and server. 2. ttl_config (default: *empty*, type: object) Indicate the TTL configuration for the game record. action: - DELETE: record will be deleted after TTL is reached 3. tags (default: *empty array*, type: array of string) Indicate the tagging for the game record. **Request Body Example:** ``` { &#34;__META&#34;: { &#34;set_by&#34;: &#34;SERVER&#34;, &#34;ttl_config&#34;: { &#34;expires_at&#34;: &#34;2026-01-02T15:04:05Z&#34;, // should be in RFC3339 format &#34;action&#34;: &#34;DELETE&#34; }, &#34;tags&#34;: [&#34;tag1&#34;, &#34;tag2&#34;] } ... } ```
     */
    createRecord_ByKey(key: string, data: GameRecordRequest): Promise<Response<GameRecordAdminResponse>>;
    /**
     * ## Description This endpoints will create new game record or replace the existing game record. **Replace behaviour:** The existing value will be replaced completely with the new value. Example - Existing JSON: `{ &#34;data1&#34;: &#34;value&#34; }` - New JSON: `{ &#34;data2&#34;: &#34;new value&#34; }` - Result: `{ &#34;data2&#34;: &#34;new value&#34; }` ## Restriction This is the restriction of Key Naming for the record: 1. Cannot use **&#34;.&#34;** as the key name - `{ &#34;data.2&#34;: &#34;value&#34; }` 2. Cannot use **&#34;$&#34;** as the prefix in key names - `{ &#34;$data&#34;: &#34;value&#34; }` 3. Cannot use empty string in key names - `{ &#34;&#34;: &#34;value&#34; }` ## Record Metadata Metadata allows user to define the behaviour of the record. Metadata can be defined in request body with field name **__META**. When creating record, if **__META** field is not defined, the metadata value will use the default value. When updating record, if **__META** field is not defined, the existing metadata value will stay as is. **Metadata List:** 1. set_by (default: CLIENT, type: string) Indicate which party that could modify the game record. SERVER: record can be modified by server only. CLIENT: record can be modified by client and server. 2. ttl_config (default: *empty*, type: object) Indicate the TTL configuration for the game record. action: - DELETE: record will be deleted after TTL is reached 3. tags (default: *empty array*, type: array of string) Indicate the tagging for the game record. **Request Body Example:** ``` { &#34;__META&#34;: { &#34;set_by&#34;: &#34;SERVER&#34;, &#34;ttl_config&#34;: { &#34;expires_at&#34;: &#34;2026-01-02T15:04:05Z&#34;, // should be in RFC3339 format &#34;action&#34;: &#34;DELETE&#34; }, &#34;tags&#34;: [&#34;tag1&#34;, &#34;tag2&#34;] } ... } ```
     */
    updateRecord_ByKey(key: string, data: GameRecordRequest): Promise<Response<GameRecordAdminResponse>>;
}

/**
 * AUTO GENERATED
 */

declare class PlayerBinaryRecordAdmin$ {
    private axiosInstance;
    private namespace;
    private useSchemaValidation;
    constructor(axiosInstance: AxiosInstance, namespace: string, useSchemaValidation?: boolean);
    /**
     * Retrieve list of player binary records by namespace.
     */
    getBinaries_ByUserId(userId: string, queryParams?: {
        limit?: number;
        offset?: number;
        query?: string | null;
        tags?: string[];
    }): Promise<Response<ListPlayerBinaryRecordsResponse>>;
    /**
     * Create a player binary record. Other detail info: `key` should follow these rules: 1. support uppercase and lowercase letters, numbers, and separators **&#34;-&#34;**, **&#34;_&#34;**, **&#34;.&#34;** are allowed 2. begin and end with letters or numbers 3. spaces are not allowed 4. separators must not appears twice in a row Supported file types: jpeg, jpg, png, bmp, gif, mp3, webp, and bin.
     */
    createBinary_ByUserId(userId: string, data: PlayerBinaryRecordCreate): Promise<Response<UploadBinaryRecordResponse>>;
    /**
     * Delete a player binary record.
     */
    deleteBinary_ByUserId_ByKey(userId: string, key: string): Promise<Response<unknown>>;
    /**
     * Get a player binary record by its key.
     */
    getBinary_ByUserId_ByKey(userId: string, key: string): Promise<Response<PlayerBinaryRecordResponse>>;
    /**
     * Update a player binary record file by its key
     */
    updateBinary_ByUserId_ByKey(userId: string, key: string, data: BinaryRecordRequest): Promise<Response<PlayerBinaryRecordResponse>>;
    /**
     * Update a player binary record metadata by its key
     */
    updateMetadata_ByUserId_ByKey(userId: string, key: string, data: PlayerBinaryRecordMetadataRequest): Promise<Response<PlayerBinaryRecordResponse>>;
    /**
     * Request presigned URL to upload the binary record to s3. Other detail info: Supported file types: jpeg, jpg, png, bmp, gif, mp3, webp, and bin.
     */
    createPresigned_ByUserId_ByKey(userId: string, key: string, data: UploadBinaryRecordRequest): Promise<Response<UploadBinaryRecordResponse>>;
}

/**
 * AUTO GENERATED
 */

declare class PlayerRecordAdmin$ {
    private axiosInstance;
    private namespace;
    private useSchemaValidation;
    constructor(axiosInstance: AxiosInstance, namespace: string, useSchemaValidation?: boolean);
    /**
     * @deprecated
     * Retrieve list of player records key and userID under given namespace.
     */
    getUsersRecords(queryParams?: {
        limit?: number;
        offset?: number;
        query?: string | null;
    }): Promise<Response<ListPlayerRecordKeysResponse>>;
    /**
     * Retrieve list of player records key and userID under given namespace.
     */
    getRecords_ByUserId(userId: string, queryParams?: {
        limit?: number;
        offset?: number;
        query?: string | null;
        tags?: string[];
    }): Promise<Response<ListPlayerRecordKeysResponse>>;
    /**
     * Bulk get player&#39;s record size, max allowed 20 at a time, that can be retrieved using this endpoint.
     */
    fetchUserBulkRecordSize(data: BulkUserKeyRequest): Promise<Response<BulkGetPlayerRecordSizeResponse>>;
    /**
     * Retrieve player record key and payload in bulk under given namespace. Maximum number of user ids per request is 20.
     */
    fetchBulkUser_ByKey(key: string, data: BulkUserIDsRequest): Promise<Response<BulkGetPlayerRecordResponse>>;
    /**
     * This endpoints will create new player record or replace the existing player record in bulk. Maximum number of user ids per request is 10. Maximum total size of the request payload is 5 MB.
     */
    updateBulkUser_ByKey(key: string, data: BulkUpdatePlayerRecordsByKeyRequest): Promise<Response<BulkUpdatePlayerRecordByKeyResponseArray>>;
    /**
     * Retrieve player record key and payload in bulk under given namespace. Maximum bulk key limit per request 20.
     */
    fetchRecordBulk_ByUserId(userId: string, data: BulkGetPlayerRecordsRequest): Promise<Response<BulkGetAdminPlayerRecordResponse>>;
    /**
     * This endpoints will create new player record or replace the existing player record in bulk. Maximum bulk key limit per request 10.
     */
    updateRecordBulk_ByUserId(userId: string, data: BulkUpdatePlayerRecordsRequest): Promise<Response<BulkUpdatePlayerRecordResponseArray>>;
    /**
     * Delete a record (arbitrary JSON data) in user-level with given key.
     */
    deleteRecord_ByUserId_ByKey(userId: string, key: string): Promise<Response<unknown>>;
    /**
     * Get a record in user-level (arbitrary JSON data) by its key.
     */
    getRecord_ByUserId_ByKey(userId: string, key: string): Promise<Response<PlayerRecordResponse>>;
    /**
     * ## Description This endpoints will create new player record or append the existing player record. **Append example:** Example 1 - Existing JSON: `{ &#34;data1&#34;: &#34;value&#34; }` - New JSON: `{ &#34;data2&#34;: &#34;new value&#34; }` - Result: `{ &#34;data1&#34;: &#34;value&#34;, &#34;data2&#34;: &#34;new value&#34; }` Example 2 - Existing JSON: `{ &#34;data1&#34;: { &#34;data2&#34;: &#34;value&#34; }` - New JSON: `{ &#34;data1&#34;: { &#34;data3&#34;: &#34;new value&#34; }` - Result: `{ &#34;data1&#34;: { &#34;data2&#34;: &#34;value&#34;, &#34;data3&#34;: &#34;new value&#34; }` ## Restriction This is the restriction of Key Naming for the record: 1. Cannot use **&#34;.&#34;** as the key name - `{ &#34;data.2&#34;: &#34;value&#34; }` 2. Cannot use **&#34;$&#34;** as the prefix in key names - `{ &#34;$data&#34;: &#34;value&#34; }` 3. Cannot use empty string in key names - `{ &#34;&#34;: &#34;value&#34; }` ## Record Metadata Metadata allows user to define the behaviour of the record. Metadata can be defined in request body with field name **__META**. When creating record, if **__META** field is not defined, the metadata value will use the default value. When updating record, if **__META** field is not defined, the existing metadata value will stay as is. **Metadata List:** 1. set_by (default: CLIENT, type: string) Indicate which party that could modify the game record. SERVER: record can be modified by server only. CLIENT: record can be modified by client and server. 2. is_public (default: false, type: bool) Indicate whether the player record is a public record or not. 3. tags (default: *empty array*, type: array of string) Indicate the tagging for the game record. **Request Body Example:** ``` { &#34;__META&#34;: { &#34;set_by&#34;: &#34;SERVER&#34;, &#34;is_public&#34;: true, &#34;tags&#34;: [&#34;tag1&#34;, &#34;tag2&#34;] } ... } ```
     */
    createRecord_ByUserId_ByKey(userId: string, key: string, data: PlayerRecordRequest): Promise<Response<PlayerRecordResponse>>;
    /**
     * ## Description This endpoints will create new player record or replace the existing player record. **Replace behaviour:** The existing value will be replaced completely with the new value. Example - Existing JSON: `{ &#34;data1&#34;: &#34;value&#34; }` - New JSON: `{ &#34;data2&#34;: &#34;new value&#34; }` - Result: `{ &#34;data2&#34;: &#34;new value&#34; }` ## Restriction This is the restriction of Key Naming for the record: 1. Cannot use **&#34;.&#34;** as the key name - `{ &#34;data.2&#34;: &#34;value&#34; }` 2. Cannot use **&#34;$&#34;** as the prefix in key names - `{ &#34;$data&#34;: &#34;value&#34; }` 3. Cannot use empty string in key names - `{ &#34;&#34;: &#34;value&#34; }` ## Record Metadata Metadata allows user to define the behaviour of the record. Metadata can be defined in request body with field name **__META**. When creating record, if **__META** field is not defined, the metadata value will use the default value. When updating record, if **__META** field is not defined, the existing metadata value will stay as is. **Metadata List:** 1. set_by (default: CLIENT, type: string) Indicate which party that could modify the game record. SERVER: record can be modified by server only. CLIENT: record can be modified by client and server. 2. is_public (default: false, type: bool) Indicate whether the player record is a public record or not. 3. tags (default: *empty array*, type: array of string) Indicate the tagging for the game record. **Request Body Example:** ``` { &#34;__META&#34;: { &#34;set_by&#34;: &#34;SERVER&#34;, &#34;is_public&#34;: true, &#34;tags&#34;: [&#34;tag1&#34;, &#34;tag2&#34;] } ... } ```
     */
    updateRecord_ByUserId_ByKey(userId: string, key: string, data: PlayerRecordRequest): Promise<Response<PlayerRecordResponse>>;
    /**
     * Get a size of the player record
     */
    getSize_ByUserId_ByKey(userId: string, key: string): Promise<Response<PlayerRecordSizeResponse>>;
    /**
     * Delete player public record. ## Warning: This endpoint is going to deprecate This endpoint is going to deprecate in the future please don&#39;t use it. For alternative, please use these endpoints: - **POST /cloudsave/v1/admin/namespaces/{namespace}/users/{userId}/records/{key}** and utilizing **__META** functionality - **PUT /cloudsave/v1/admin/namespaces/{namespace}/users/{userId}/records/{key}** and utilizing **__META** functionality - **DELETE /cloudsave/v1/admin/namespaces/{namespace}/users/{userId}/records/{key}**
     */
    deletePublic_ByUserId_ByKey(userId: string, key: string): Promise<Response<unknown>>;
    /**
     * Get a record in user-level (arbitrary JSON data) by its key.
     */
    getPublic_ByUserId_ByKey(userId: string, key: string): Promise<Response<PlayerRecordResponse>>;
    /**
     * ## Description This endpoints will create new player public record or append the existing player public record. **Append example:** Example 1 - Existing JSON: `{ &#34;data1&#34;: &#34;value&#34; }` - New JSON: `{ &#34;data2&#34;: &#34;new value&#34; }` - Result: `{ &#34;data1&#34;: &#34;value&#34;, &#34;data2&#34;: &#34;new value&#34; }` Example 2 - Existing JSON: `{ &#34;data1&#34;: { &#34;data2&#34;: &#34;value&#34; }` - New JSON: `{ &#34;data1&#34;: { &#34;data3&#34;: &#34;new value&#34; }` - Result: `{ &#34;data1&#34;: { &#34;data2&#34;: &#34;value&#34;, &#34;data3&#34;: &#34;new value&#34; }` ## Restriction This is the restriction of Key Naming for the record: 1. Cannot use **&#34;.&#34;** as the key name - `{ &#34;data.2&#34;: &#34;value&#34; }` 2. Cannot use **&#34;$&#34;** as the prefix in key names - `{ &#34;$data&#34;: &#34;value&#34; }` 3. Cannot use empty string in key names - `{ &#34;&#34;: &#34;value&#34; }` ## Warning: This endpoint is going to deprecate This endpoint is going to deprecate in the future please don&#39;t use it. For alternative, please use these endpoints: - **POST /cloudsave/v1/admin/namespaces/{namespace}/users/{userId}/records/{key}** and utilizing **__META** functionality - **PUT /cloudsave/v1/admin/namespaces/{namespace}/users/{userId}/records/{key}** and utilizing **__META** functionality - **DELETE /cloudsave/v1/admin/namespaces/{namespace}/users/{userId}/records/{key}**
     */
    createPublic_ByUserId_ByKey(userId: string, key: string, data: PlayerRecordRequest): Promise<Response<PlayerRecordResponse>>;
    /**
     * ## Description This endpoints will create new player public record or replace the existing player public record. **Replace behaviour:** The existing value will be replaced completely with the new value. Example - Existing JSON: `{ &#34;data1&#34;: &#34;value&#34; }` - New JSON: `{ &#34;data2&#34;: &#34;new value&#34; }` - Result: `{ &#34;data2&#34;: &#34;new value&#34; }` ## Restriction This is the restriction of Key Naming for the record: 1. Cannot use **&#34;.&#34;** as the key name - `{ &#34;data.2&#34;: &#34;value&#34; }` 2. Cannot use **&#34;$&#34;** as the prefix in key names - `{ &#34;$data&#34;: &#34;value&#34; }` 3. Cannot use empty string in key names - `{ &#34;&#34;: &#34;value&#34; }` ## Warning: This endpoint is going to deprecate This endpoint is going to deprecate in the future please don&#39;t use it. For alternative, please use these endpoints: - **POST /cloudsave/v1/admin/namespaces/{namespace}/users/{userId}/records/{key}** and utilizing **__META** functionality - **PUT /cloudsave/v1/admin/namespaces/{namespace}/users/{userId}/records/{key}** and utilizing **__META** functionality - **DELETE /cloudsave/v1/admin/namespaces/{namespace}/users/{userId}/records/{key}**
     */
    updatePublic_ByUserId_ByKey(userId: string, key: string, data: PlayerRecordRequest): Promise<Response<PlayerRecordResponse>>;
}

/**
 * AUTO GENERATED
 */

declare class PluginConfigAdmin$ {
    private axiosInstance;
    private namespace;
    private useSchemaValidation;
    constructor(axiosInstance: AxiosInstance, namespace: string, useSchemaValidation?: boolean);
    /**
     * ## Description This endpoints will delete grpc plugins configuration
     */
    deletePlugin(): Promise<Response<unknown>>;
    /**
     * ## Description This endpoints will get grpc plugins configuration
     */
    getPlugins(): Promise<Response<PluginResponse>>;
    /**
     * ## Description This endpoints will update grpc plugins configuration
     */
    patchPlugin(data: PluginRequest): Promise<Response<PluginResponse>>;
    /**
     * ## Description This endpoints will create new grpc plugins configuration per namespace
     */
    createPlugin(data: PluginRequest): Promise<Response<PluginResponse>>;
}

/**
 * AUTO GENERATED
 */

declare class RecordAdmin$ {
    private axiosInstance;
    private namespace;
    private useSchemaValidation;
    constructor(axiosInstance: AxiosInstance, namespace: string, useSchemaValidation?: boolean);
    /**
     * Retrieve list of records key by namespace
     */
    getAdminrecords(queryParams?: {
        limit?: number;
        offset?: number;
        query?: string | null;
        tags?: string[];
    }): Promise<Response<ListAdminGameRecordKeysResponse>>;
    /**
     * Bulk get admin game records. Maximum key per request 20.
     */
    fetchAdminrecordBulk(data: BulkGetAdminGameRecordRequest): Promise<Response<BulkGetAdminGameRecordResponse>>;
    /**
     * This endpoints delete game record in namespace-level
     */
    deleteAdminrecord_ByKey(key: string): Promise<Response<unknown>>;
    /**
     * Get a record by its key in namespace-level.
     */
    getAdminrecord_ByKey(key: string): Promise<Response<AdminGameRecordResponse>>;
    /**
     * ## Description This endpoints will create new admin game record or append the existing admin game record. **Append example:** Example 1 - Existing JSON: `{ &#34;data1&#34;: &#34;value&#34; }` - New JSON: `{ &#34;data2&#34;: &#34;new value&#34; }` - Result: `{ &#34;data1&#34;: &#34;value&#34;, &#34;data2&#34;: &#34;new value&#34; }` Example 2 - Existing JSON: `{ &#34;data1&#34;: { &#34;data2&#34;: &#34;value&#34; }` - New JSON: `{ &#34;data1&#34;: { &#34;data3&#34;: &#34;new value&#34; }` - Result: `{ &#34;data1&#34;: { &#34;data2&#34;: &#34;value&#34;, &#34;data3&#34;: &#34;new value&#34; }` ## Restriction This is the restriction of Key Naming for the record: 1. Cannot use **&#34;.&#34;** as the key name - `{ &#34;data.2&#34;: &#34;value&#34; }` 2. Cannot use **&#34;$&#34;** as the prefix in key names - `{ &#34;$data&#34;: &#34;value&#34; }` 3. Cannot use empty string in key names - `{ &#34;&#34;: &#34;value&#34; }` ## Record Metadata Metadata allows user to define the behaviour of the record. Metadata can be defined in request body with field name **__META**. When creating record, if **__META** field is not defined, the metadata value will use the default value. When updating record, if **__META** field is not defined, the existing metadata value will stay as is. **Metadata List:** 1. tags (default: *empty array*, type: array of string) Indicate the tagging for the admin record. **Request Body Example:** ``` { &#34;__META&#34;: { &#34;tags&#34;: [&#34;tag1&#34;, &#34;tag2&#34;] } ... } ```
     */
    createAdminrecord_ByKey(key: string, data: AdminGameRecordRequest): Promise<Response<AdminGameRecordResponse>>;
    /**
     * ## Description This endpoints will create new admin game record or replace the existing admin game record. **Append example:** Example - Existing JSON: `{ &#34;data1&#34;: &#34;value&#34; }` - New JSON: `{ &#34;data2&#34;: &#34;new value&#34; }` - Result: `{ &#34;data2&#34;: &#34;new value&#34; }` ## Restriction This is the restriction of Key Naming for the record: 1. Cannot use **&#34;.&#34;** as the key name - `{ &#34;data.2&#34;: &#34;value&#34; }` 2. Cannot use **&#34;$&#34;** as the prefix in key names - `{ &#34;$data&#34;: &#34;value&#34; }` 3. Cannot use empty string in key names - `{ &#34;&#34;: &#34;value&#34; }` ## Record Metadata Metadata allows user to define the behaviour of the record. Metadata can be defined in request body with field name **__META**. When creating record, if **__META** field is not defined, the metadata value will use the default value. When updating record, if **__META** field is not defined, the existing metadata value will stay as is. **Metadata List:** 1. tags (default: *empty array*, type: array of string) Indicate the tagging for the admin record. **Request Body Example:** ``` { &#34;__META&#34;: { &#34;tags&#34;: [&#34;tag1&#34;, &#34;tag2&#34;] } ... } ```
     */
    updateAdminrecord_ByKey(key: string, data: AdminGameRecordRequest): Promise<Response<AdminGameRecordResponse>>;
    /**
     * Retrieve list of admin player records key and userID under given namespace.
     */
    getAdminrecords_ByUserId(userId: string, queryParams?: {
        limit?: number;
        offset?: number;
        query?: string | null;
        tags?: string[];
    }): Promise<Response<ListAdminPlayerRecordKeysResponse>>;
    /**
     * Bulk get admin player record by userIds, max allowed 20 at a time.
     */
    fetchBulkUser_ByKey(key: string, data: BulkUserIDsRequest): Promise<Response<BulkGetAdminPlayerRecordResponse>>;
    /**
     * Bulk get admin player records. Maximum key per request 20.
     */
    fetchAdminrecordBulk_ByUserId(userId: string, data: BulkGetAdminPlayerRecordRequest): Promise<Response<BulkGetAdminPlayerRecordResponse>>;
    /**
     * Delete a record (arbitrary JSON data) in user-level with given key.
     */
    deleteAdminrecord_ByUserId_ByKey(userId: string, key: string): Promise<Response<unknown>>;
    /**
     * Get a admin record in user-level (arbitrary JSON data) by its key.
     */
    getAdminrecord_ByUserId_ByKey(userId: string, key: string): Promise<Response<AdminPlayerRecordResponse>>;
    /**
     * ## Description This endpoints will create new admin player record or append the existing admin game record. **Append example:** Example 1 - Existing JSON: `{ &#34;data1&#34;: &#34;value&#34; }` - New JSON: `{ &#34;data2&#34;: &#34;new value&#34; }` - Result: `{ &#34;data1&#34;: &#34;value&#34;, &#34;data2&#34;: &#34;new value&#34; }` Example 2 - Existing JSON: `{ &#34;data1&#34;: { &#34;data2&#34;: &#34;value&#34; }` - New JSON: `{ &#34;data1&#34;: { &#34;data3&#34;: &#34;new value&#34; }` - Result: `{ &#34;data1&#34;: { &#34;data2&#34;: &#34;value&#34;, &#34;data3&#34;: &#34;new value&#34; }` ## Restriction This is the restriction of Key Naming for the record: 1. Cannot use **&#34;.&#34;** as the key name - `{ &#34;data.2&#34;: &#34;value&#34; }` 2. Cannot use **&#34;$&#34;** as the prefix in key names - `{ &#34;$data&#34;: &#34;value&#34; }` 3. Cannot use empty string in key names - `{ &#34;&#34;: &#34;value&#34; }` ## Record Metadata Metadata allows user to define the behaviour of the record. Metadata can be defined in request body with field name **__META**. When creating record, if **__META** field is not defined, the metadata value will use the default value. When updating record, if **__META** field is not defined, the existing metadata value will stay as is. **Metadata List:** 1. tags (default: *empty array*, type: array of string) Indicate the tagging for the admin record. **Request Body Example:** ``` { &#34;__META&#34;: { &#34;tags&#34;: [&#34;tag1&#34;, &#34;tag2&#34;] } ... } ```
     */
    createAdminrecord_ByUserId_ByKey(userId: string, key: string, data: AdminPlayerRecordRequest): Promise<Response<AdminPlayerRecordResponse>>;
    /**
     * ## Description This endpoints will create new admin player record or replace the existing admin player record. **Replace behaviour:** The existing value will be replaced completely with the new value. Example - Existing JSON: `{ &#34;data1&#34;: &#34;value&#34; }` - New JSON: `{ &#34;data2&#34;: &#34;new value&#34; }` - Result: `{ &#34;data2&#34;: &#34;new value&#34; }` ## Restriction This is the restriction of Key Naming for the record: 1. Cannot use **&#34;.&#34;** as the key name - `{ &#34;data.2&#34;: &#34;value&#34; }` 2. Cannot use **&#34;$&#34;** as the prefix in key names - `{ &#34;$data&#34;: &#34;value&#34; }` 3. Cannot use empty string in key names - `{ &#34;&#34;: &#34;value&#34; }` ## Record Metadata Metadata allows user to define the behaviour of the record. Metadata can be defined in request body with field name **__META**. When creating record, if **__META** field is not defined, the metadata value will use the default value. When updating record, if **__META** field is not defined, the existing metadata value will stay as is. **Metadata List:** 1. tags (default: *empty array*, type: array of string) Indicate the tagging for the admin record. **Request Body Example:** ``` { &#34;__META&#34;: { &#34;tags&#34;: [&#34;tag1&#34;, &#34;tag2&#34;] } ... } ```
     */
    updateAdminrecord_ByUserId_ByKey(userId: string, key: string, data: AdminPlayerRecordRequest): Promise<Response<AdminPlayerRecordResponse>>;
}

/**
 * AUTO GENERATED
 */

declare class TagsAdmin$ {
    private axiosInstance;
    private namespace;
    private useSchemaValidation;
    constructor(axiosInstance: AxiosInstance, namespace: string, useSchemaValidation?: boolean);
    /**
     * ## Description Retrieve list of available tags by namespace
     */
    getTags(queryParams?: {
        limit?: number;
        offset?: number;
    }): Promise<Response<ListTagsResponse>>;
    /**
     * ## Description This endpoint will create new tags
     */
    createTag(data: TagRequest): Promise<Response<unknown>>;
    /**
     * ## Description This endpoint will delete tag by name
     */
    deleteTag_ByTag(tag: string): Promise<Response<unknown>>;
}

/**
 * AUTO GENERATED
 */

declare class TtlConfigAdmin$ {
    private axiosInstance;
    private namespace;
    private useSchemaValidation;
    constructor(axiosInstance: AxiosInstance, namespace: string, useSchemaValidation?: boolean);
    /**
     * ## Description This endpoints will delete the ttl config of the game record
     */
    deleteTtl_ByKey(key: string): Promise<Response<unknown>>;
    /**
     * ## Description This endpoints will delete the ttl config of the game binary record
     */
    deleteTtl_ByKey_ByNS(key: string): Promise<Response<unknown>>;
}

declare const AdminPlayerRecordKeyInfo: z.ZodObject<{
    key: z.ZodString;
    user_id: z.ZodString;
}, "strip", z.ZodTypeAny, {
    user_id: string;
    key: string;
}, {
    user_id: string;
    key: string;
}>;
interface AdminPlayerRecordKeyInfo extends z.TypeOf<typeof AdminPlayerRecordKeyInfo> {
}

declare const AppConfig: z.ZodObject<{
    appName: z.ZodString;
}, "strip", z.ZodTypeAny, {
    appName: string;
}, {
    appName: string;
}>;
interface AppConfig extends z.TypeOf<typeof AppConfig> {
}

declare const BinaryInfoResponse: z.ZodObject<{
    content_type: z.ZodString;
    created_at: z.ZodString;
    file_location: z.ZodString;
    updated_at: z.ZodString;
    url: z.ZodOptional<z.ZodNullable<z.ZodString>>;
    version: z.ZodNumber;
}, "strip", z.ZodTypeAny, {
    updated_at: string;
    content_type: string;
    file_location: string;
    created_at: string;
    version: number;
    url?: string | null | undefined;
}, {
    updated_at: string;
    content_type: string;
    file_location: string;
    created_at: string;
    version: number;
    url?: string | null | undefined;
}>;
interface BinaryInfoResponse extends z.TypeOf<typeof BinaryInfoResponse> {
}

declare const BulkUpdatePlayerRecordByKeyRequestDetail: z.ZodObject<{
    user_id: z.ZodString;
    value: z.ZodRecord<z.ZodString, z.ZodAny>;
}, "strip", z.ZodTypeAny, {
    value: Record<string, any>;
    user_id: string;
}, {
    value: Record<string, any>;
    user_id: string;
}>;
interface BulkUpdatePlayerRecordByKeyRequestDetail extends z.TypeOf<typeof BulkUpdatePlayerRecordByKeyRequestDetail> {
}

declare const BulkUpdatePlayerRecordByKeyResponse: z.ZodObject<{
    detail: z.ZodRecord<z.ZodString, z.ZodAny>;
    success: z.ZodBoolean;
    user_id: z.ZodString;
}, "strip", z.ZodTypeAny, {
    user_id: string;
    detail: Record<string, any>;
    success: boolean;
}, {
    user_id: string;
    detail: Record<string, any>;
    success: boolean;
}>;
interface BulkUpdatePlayerRecordByKeyResponse extends z.TypeOf<typeof BulkUpdatePlayerRecordByKeyResponse> {
}

declare const BulkUpdatePlayerRecordRequestDetail: z.ZodObject<{
    key: z.ZodString;
    value: z.ZodRecord<z.ZodString, z.ZodAny>;
}, "strip", z.ZodTypeAny, {
    value: Record<string, any>;
    key: string;
}, {
    value: Record<string, any>;
    key: string;
}>;
interface BulkUpdatePlayerRecordRequestDetail extends z.TypeOf<typeof BulkUpdatePlayerRecordRequestDetail> {
}

declare const BulkUpdatePlayerRecordResponse: z.ZodObject<{
    detail: z.ZodRecord<z.ZodString, z.ZodAny>;
    key: z.ZodString;
    success: z.ZodBoolean;
}, "strip", z.ZodTypeAny, {
    key: string;
    detail: Record<string, any>;
    success: boolean;
}, {
    key: string;
    detail: Record<string, any>;
    success: boolean;
}>;
interface BulkUpdatePlayerRecordResponse extends z.TypeOf<typeof BulkUpdatePlayerRecordResponse> {
}

declare const CustomConfig: z.ZodObject<{
    GRPCAddress: z.ZodString;
}, "strip", z.ZodTypeAny, {
    GRPCAddress: string;
}, {
    GRPCAddress: string;
}>;
interface CustomConfig extends z.TypeOf<typeof CustomConfig> {
}

declare const CustomFunction: z.ZodObject<{
    afterBulkReadGameBinaryRecord: z.ZodBoolean;
    afterBulkReadGameRecord: z.ZodBoolean;
    afterBulkReadPlayerBinaryRecord: z.ZodBoolean;
    afterBulkReadPlayerRecord: z.ZodBoolean;
    afterReadGameBinaryRecord: z.ZodBoolean;
    afterReadGameRecord: z.ZodBoolean;
    afterReadPlayerBinaryRecord: z.ZodBoolean;
    afterReadPlayerRecord: z.ZodBoolean;
    beforeWriteAdminGameRecord: z.ZodBoolean;
    beforeWriteAdminPlayerRecord: z.ZodBoolean;
    beforeWriteGameBinaryRecord: z.ZodBoolean;
    beforeWriteGameRecord: z.ZodBoolean;
    beforeWritePlayerBinaryRecord: z.ZodBoolean;
    beforeWritePlayerRecord: z.ZodBoolean;
}, "strip", z.ZodTypeAny, {
    afterBulkReadGameBinaryRecord: boolean;
    afterBulkReadGameRecord: boolean;
    afterBulkReadPlayerBinaryRecord: boolean;
    afterBulkReadPlayerRecord: boolean;
    afterReadGameBinaryRecord: boolean;
    afterReadGameRecord: boolean;
    afterReadPlayerBinaryRecord: boolean;
    afterReadPlayerRecord: boolean;
    beforeWriteAdminGameRecord: boolean;
    beforeWriteAdminPlayerRecord: boolean;
    beforeWriteGameBinaryRecord: boolean;
    beforeWriteGameRecord: boolean;
    beforeWritePlayerBinaryRecord: boolean;
    beforeWritePlayerRecord: boolean;
}, {
    afterBulkReadGameBinaryRecord: boolean;
    afterBulkReadGameRecord: boolean;
    afterBulkReadPlayerBinaryRecord: boolean;
    afterBulkReadPlayerRecord: boolean;
    afterReadGameBinaryRecord: boolean;
    afterReadGameRecord: boolean;
    afterReadPlayerBinaryRecord: boolean;
    afterReadPlayerRecord: boolean;
    beforeWriteAdminGameRecord: boolean;
    beforeWriteAdminPlayerRecord: boolean;
    beforeWriteGameBinaryRecord: boolean;
    beforeWriteGameRecord: boolean;
    beforeWritePlayerBinaryRecord: boolean;
    beforeWritePlayerRecord: boolean;
}>;
interface CustomFunction extends z.TypeOf<typeof CustomFunction> {
}

declare const Pagination: z.ZodObject<{
    first: z.ZodString;
    last: z.ZodString;
    next: z.ZodString;
    previous: z.ZodString;
}, "strip", z.ZodTypeAny, {
    first: string;
    last: string;
    next: string;
    previous: string;
}, {
    first: string;
    last: string;
    next: string;
    previous: string;
}>;
interface Pagination extends z.TypeOf<typeof Pagination> {
}

declare const PlayerRecordKeyInfo: z.ZodObject<{
    key: z.ZodString;
    user_id: z.ZodString;
}, "strip", z.ZodTypeAny, {
    user_id: string;
    key: string;
}, {
    user_id: string;
    key: string;
}>;
interface PlayerRecordKeyInfo extends z.TypeOf<typeof PlayerRecordKeyInfo> {
}

declare const ResponseError: z.ZodObject<{
    errorCode: z.ZodNumber;
    errorMessage: z.ZodString;
}, "strip", z.ZodTypeAny, {
    errorCode: number;
    errorMessage: string;
}, {
    errorCode: number;
    errorMessage: string;
}>;
interface ResponseError extends z.TypeOf<typeof ResponseError> {
}

declare const TagInfo: z.ZodObject<{
    created_at: z.ZodString;
    tag: z.ZodString;
}, "strip", z.ZodTypeAny, {
    created_at: string;
    tag: string;
}, {
    created_at: string;
    tag: string;
}>;
interface TagInfo extends z.TypeOf<typeof TagInfo> {
}

declare const TtlConfigDto: z.ZodObject<{
    action: z.ZodEnum<["DELETE"]>;
    expires_at: z.ZodString;
}, "strip", z.ZodTypeAny, {
    action: "DELETE";
    expires_at: string;
}, {
    action: "DELETE";
    expires_at: string;
}>;
interface TtlConfigDto extends z.TypeOf<typeof TtlConfigDto> {
}

declare const UserKeyRequest: z.ZodObject<{
    keys: z.ZodArray<z.ZodString, "many">;
    user_id: z.ZodString;
}, "strip", z.ZodTypeAny, {
    keys: string[];
    user_id: string;
}, {
    keys: string[];
    user_id: string;
}>;
interface UserKeyRequest extends z.TypeOf<typeof UserKeyRequest> {
}

/**
 * AUTO GENERATED
 */

declare class ConcurrentRecord$ {
    private axiosInstance;
    private namespace;
    private useSchemaValidation;
    constructor(axiosInstance: AxiosInstance, namespace: string, useSchemaValidation?: boolean);
    /**
     * ## Description This endpoints will create new game record or replace the existing game record. **Replace behaviour:** The existing value will be replaced completely with the new value. Example - Existing JSON: `{ &#34;data1&#34;: &#34;value&#34; }` - New JSON: `{ &#34;data2&#34;: &#34;new value&#34; }` - Result: `{ &#34;data2&#34;: &#34;new value&#34; }` ## Restriction This is the restriction of Key Naming for the record: 1. Cannot use **&#34;.&#34;** as the key name - `{ &#34;data.2&#34;: &#34;value&#34; }` 2. Cannot use **&#34;$&#34;** as the prefix in key names - `{ &#34;$data&#34;: &#34;value&#34; }` 3. Cannot use empty string in key names - `{ &#34;&#34;: &#34;value&#34; }` ## Reserved Word Reserved Word List: **__META** The reserved word cannot be used as a field in record value, If still defining the field when creating or updating the record, it will be ignored. ## Optimistic Concurrency Control This endpoint implement optimistic concurrency control to avoid race condition. If the record has been updated since the client fetch it, the server will return HTTP status code 412 (precondition failed) and client need to redo the operation (fetch data and do update). Otherwise, the server will process the request.
     */
    updateConcurrentRecord_ByKey(key: string, data: ConcurrentRecordRequest): Promise<Response<unknown>>;
    /**
     * ## Description This endpoints will create new player record or replace the existing player record. **Replace behaviour:** The existing value will be replaced completely with the new value. Example - Existing JSON: `{ &#34;data1&#34;: &#34;value&#34; }` - New JSON: `{ &#34;data2&#34;: &#34;new value&#34; }` - Result: `{ &#34;data2&#34;: &#34;new value&#34; }` ## Restriction This is the restriction of Key Naming for the record: 1. Cannot use **&#34;.&#34;** as the key name - `{ &#34;data.2&#34;: &#34;value&#34; }` 2. Cannot use **&#34;$&#34;** as the prefix in key names - `{ &#34;$data&#34;: &#34;value&#34; }` 3. Cannot use empty string in key names - `{ &#34;&#34;: &#34;value&#34; }` ## Reserved Word Reserved Word List: **__META** The reserved word cannot be used as a field in record value, If still defining the field when creating or updating the record, it will be ignored. ## Optimistic Concurrency Control This endpoint implement optimistic concurrency control to avoid race condition. If the record has been updated since the client fetch it, the server will return HTTP status code 412 (precondition failed) and client need to redo the operation (fetch data and do update). Otherwise, the server will process the request.
     */
    updateConcurrentRecord_ByUserId_ByKey(userId: string, key: string, data: ConcurrentRecordRequest, queryParams?: {
        responseBody?: boolean | null;
    }): Promise<Response<PlayerRecordConcurrentUpdateResponse>>;
    /**
     * ## Description This endpoints will create new player public record or replace the existing player public record. **Replace behaviour:** The existing value will be replaced completely with the new value. Example - Existing JSON: `{ &#34;data1&#34;: &#34;value&#34; }` - New JSON: `{ &#34;data2&#34;: &#34;new value&#34; }` - Result: `{ &#34;data2&#34;: &#34;new value&#34; }` ## Restriction This is the restriction of Key Naming for the record: 1. Cannot use **&#34;.&#34;** as the key name - `{ &#34;data.2&#34;: &#34;value&#34; }` 2. Cannot use **&#34;$&#34;** as the prefix in key names - `{ &#34;$data&#34;: &#34;value&#34; }` 3. Cannot use empty string in key names - `{ &#34;&#34;: &#34;value&#34; }` ## Reserved Word Reserved Word List: **__META** The reserved word cannot be used as a field in record value, If still defining the field when creating or updating the record, it will be ignored. ## Optimistic Concurrency Control This endpoint implement optimistic concurrency control to avoid race condition. If the record has been updated since the client fetch it, the server will return HTTP status code 412 (precondition failed) and client need to redo the operation (fetch data and do update). Otherwise, the server will process the request.
     */
    updatePublicConcurrent_ByUserId_ByKey(userId: string, key: string, data: ConcurrentRecordRequest, queryParams?: {
        responseBody?: boolean | null;
    }): Promise<Response<PlayerRecordConcurrentUpdateResponse>>;
}

/**
 * AUTO GENERATED
 */

declare class PublicGameBinaryRecord$ {
    private axiosInstance;
    private namespace;
    private useSchemaValidation;
    constructor(axiosInstance: AxiosInstance, namespace: string, useSchemaValidation?: boolean);
    /**
     * Retrieve list of binary records by namespace.
     */
    getBinaries(queryParams?: {
        limit?: number;
        offset?: number;
        query?: string | null;
        tags?: string[];
    }): Promise<Response<ListGameBinaryRecordsResponse>>;
    /**
     * Create a game binary record. Other detail info: `key` should follow these rules: 1. support uppercase and lowercase letters, numbers, and separators **&#34;-&#34;**, **&#34;_&#34;**, **&#34;.&#34;** are allowed 2. begin and end with letters or numbers 3. spaces are not allowed 4. separators must not appears twice in a row Supported file types: jpeg, jpg, png, bmp, gif, mp3, webp, and bin.
     */
    createBinary(data: PublicGameBinaryRecordCreate): Promise<Response<UploadBinaryRecordResponse>>;
    /**
     * Bulk get game binary records. Maximum key per request 20.
     */
    createBinaryBulk(data: BulkGetGameRecordRequest): Promise<Response<BulkGetGameBinaryRecordResponse>>;
    /**
     * Delete a game binary record.
     */
    deleteBinary_ByKey(key: string): Promise<Response<unknown>>;
    /**
     * Get a game binary record by its key.
     */
    getBinary_ByKey(key: string): Promise<Response<GameBinaryRecordResponse>>;
    /**
     * Update a game binary record file by its key
     */
    updateBinary_ByKey(key: string, data: BinaryRecordRequest): Promise<Response<GameBinaryRecordResponse>>;
    /**
     * Request presigned URL to upload the binary record to s3. Other detail info: Supported file types: jpeg, jpg, png, bmp, gif, mp3, webp, and bin.
     */
    createPresigned_ByKey(key: string, data: UploadBinaryRecordRequest): Promise<Response<UploadBinaryRecordResponse>>;
}

/**
 * AUTO GENERATED
 */

declare class PublicGameRecord$ {
    private axiosInstance;
    private namespace;
    private useSchemaValidation;
    constructor(axiosInstance: AxiosInstance, namespace: string, useSchemaValidation?: boolean);
    /**
     * Bulk get game records. Maximum key per request 20.
     */
    fetchRecordBulk(data: BulkGetGameRecordRequest): Promise<Response<BulkGetGameRecordResponse>>;
    /**
     * Delete records by its key
     */
    deleteRecord_ByKey(key: string): Promise<Response<unknown>>;
    /**
     * Get game record by its key.
     */
    getRecord_ByKey(key: string): Promise<Response<GameRecordResponse>>;
    /**
     * ## Description This endpoints will create new game record or append the existing game record. **Append example:** Example 1 - Existing JSON: `{ &#34;data1&#34;: &#34;value&#34; }` - New JSON: `{ &#34;data2&#34;: &#34;new value&#34; }` - Result: `{ &#34;data1&#34;: &#34;value&#34;, &#34;data2&#34;: &#34;new value&#34; }` Example 2 - Existing JSON: `{ &#34;data1&#34;: { &#34;data2&#34;: &#34;value&#34; }` - New JSON: `{ &#34;data1&#34;: { &#34;data3&#34;: &#34;new value&#34; }` - Result: `{ &#34;data1&#34;: { &#34;data2&#34;: &#34;value&#34;, &#34;data3&#34;: &#34;new value&#34; }` ## Restriction This is the restriction of Key Naming for the record: 1. Cannot use **&#34;.&#34;** as the key name - `{ &#34;data.2&#34;: &#34;value&#34; }` 2. Cannot use **&#34;$&#34;** as the prefix in key names - `{ &#34;$data&#34;: &#34;value&#34; }` 3. Cannot use empty string in key names - `{ &#34;&#34;: &#34;value&#34; }` ## Reserved Word Reserved Word List: **__META** The reserved word cannot be used as a field in record value, If still defining the field when creating or updating the record, it will be ignored.
     */
    createRecord_ByKey(key: string, data: GameRecordRequest): Promise<Response<GameRecordResponse>>;
    /**
     * ## Description This endpoints will create new game record or replace the existing game record. **Replace behaviour:** The existing value will be replaced completely with the new value. Example - Existing JSON: `{ &#34;data1&#34;: &#34;value&#34; }` - New JSON: `{ &#34;data2&#34;: &#34;new value&#34; }` - Result: `{ &#34;data2&#34;: &#34;new value&#34; }` ## Restriction This is the restriction of Key Naming for the record: 1. Cannot use **&#34;.&#34;** as the key name - `{ &#34;data.2&#34;: &#34;value&#34; }` 2. Cannot use **&#34;$&#34;** as the prefix in key names - `{ &#34;$data&#34;: &#34;value&#34; }` 3. Cannot use empty string in key names - `{ &#34;&#34;: &#34;value&#34; }` ## Reserved Word Reserved Word List: **__META** The reserved word cannot be used as a field in record value, If still defining the field when creating or updating the record, it will be ignored.
     */
    updateRecord_ByKey(key: string, data: GameRecordRequest): Promise<Response<GameRecordResponse>>;
}

/**
 * AUTO GENERATED
 */

declare class PublicPlayerBinaryRecord$ {
    private axiosInstance;
    private namespace;
    private useSchemaValidation;
    constructor(axiosInstance: AxiosInstance, namespace: string, useSchemaValidation?: boolean);
    /**
     * Retrieve list of my binary records by namespace.
     */
    getUsersMeBinaries(queryParams?: {
        limit?: number;
        offset?: number;
        query?: string | null;
        tags?: string[];
    }): Promise<Response<ListPlayerBinaryRecordsResponse>>;
    /**
     * Retrieve player record key and payload in bulk under given namespace. Maximum bulk key limit per request 20
     */
    createUserMeBinaryBulk(data: BulkGetPlayerRecordsRequest): Promise<Response<BulkGetPlayerBinaryRecordResponse>>;
    /**
     * Create a player binary record. Other detail info: `key` should follow these rules: 1. support uppercase and lowercase letters, numbers, and separators **&#34;-&#34;**, **&#34;_&#34;**, **&#34;.&#34;** are allowed 2. begin and end with letters or numbers 3. spaces are not allowed 4. separators must not appears twice in a row Supported file types: jpeg, jpg, png, bmp, gif, mp3, webp, and bin.
     */
    createBinary_ByUserId(userId: string, data: PublicPlayerBinaryRecordCreate): Promise<Response<UploadBinaryRecordResponse>>;
    /**
     * Delete a player binary record. Only player who own the record can delete it
     */
    deleteBinary_ByUserId_ByKey(userId: string, key: string): Promise<Response<unknown>>;
    /**
     * Get a player binary record by its key. **Private Record**: Only user who own the record could retrieve it.
     */
    getBinary_ByUserId_ByKey(userId: string, key: string): Promise<Response<PlayerBinaryRecordResponse>>;
    /**
     * Update a player binary record file by its key
     */
    updateBinary_ByUserId_ByKey(userId: string, key: string, data: BinaryRecordRequest): Promise<Response<PlayerBinaryRecordResponse>>;
    /**
     * Retrieve list of other player public binary records under given namespace.
     */
    getBinariesPublic_ByUserId(userId: string, queryParams?: {
        limit?: number;
        offset?: number;
        tags?: string[];
    }): Promise<Response<ListPlayerBinaryRecordsResponse>>;
    /**
     * Bulk get other player&#39;s public binary record by userIds, max allowed 20 at a time. Only record with `isPublic=true` can be retrieved using this endpoint.
     */
    fetchPublicBulkUser_ByKey(key: string, data: BulkUserIDsRequest): Promise<Response<BulkGetPlayerBinaryRecordResponse>>;
    /**
     * Retrieve other player public binary record in bulk under given namespace. Maximum bulk key limit per request 20
     */
    fetchBinaryBulk_ByUserId(userId: string, data: BulkGetPlayerRecordsRequest): Promise<Response<BulkGetPlayerBinaryRecordResponse>>;
    /**
     * Get other player&#39;s public binary record. Only record with `isPublic=true` can be retrieved using this endpoint.
     */
    getPublic_ByUserId_ByKey(userId: string, key: string): Promise<Response<PlayerBinaryRecordResponse>>;
    /**
     * Update a player binary record metadata by its key
     */
    updateMetadata_ByUserId_ByKey(userId: string, key: string, data: PlayerBinaryRecordMetadataPublicRequest): Promise<Response<PlayerBinaryRecordResponse>>;
    /**
     * Request presigned URL to upload the binary record to s3. Other detail info: Supported file types: jpeg, jpg, png, bmp, gif, mp3, webp, and bin.
     */
    createPresigned_ByUserId_ByKey(userId: string, key: string, data: UploadBinaryRecordRequest): Promise<Response<UploadBinaryRecordResponse>>;
}

/**
 * AUTO GENERATED
 */

declare class PublicPlayerRecord$ {
    private axiosInstance;
    private namespace;
    private useSchemaValidation;
    constructor(axiosInstance: AxiosInstance, namespace: string, useSchemaValidation?: boolean);
    /**
     * Retrieve list of player records key under given namespace.
     */
    getUsersMeRecords(queryParams?: {
        limit?: number;
        offset?: number;
        tags?: string[];
    }): Promise<Response<ListPlayerRecordKeysResponse>>;
    /**
     * Retrieve player record key and payload in bulk under given namespace. Maximum bulk key limit per request 20
     */
    createUserMeRecordBulk(data: BulkGetPlayerRecordsRequest): Promise<Response<BulkGetPlayerRecordResponse>>;
    /**
     * Delete player record by its key. Only user that own the player record could delete it.
     */
    deleteRecord_ByUserId_ByKey(userId: string, key: string): Promise<Response<unknown>>;
    /**
     * Get player record by its key. **Private Record**: Only user that own the player record could retrieve it.
     */
    getRecord_ByUserId_ByKey(userId: string, key: string): Promise<Response<PlayerRecordResponse>>;
    /**
     * ## Description This endpoints will create new player record or append the existing player record. Only user that own the existing player record could modify. **Append example:** Example 1 - Existing JSON: `{ &#34;data1&#34;: &#34;value&#34; }` - New JSON: `{ &#34;data2&#34;: &#34;new value&#34; }` - Result: `{ &#34;data1&#34;: &#34;value&#34;, &#34;data2&#34;: &#34;new value&#34; }` Example 2 - Existing JSON: `{ &#34;data1&#34;: { &#34;data2&#34;: &#34;value&#34; }` - New JSON: `{ &#34;data1&#34;: { &#34;data3&#34;: &#34;new value&#34; }` - Result: `{ &#34;data1&#34;: { &#34;data2&#34;: &#34;value&#34;, &#34;data3&#34;: &#34;new value&#34; }` ## Restriction This is the restriction of Key Naming for the record: 1. Cannot use **&#34;.&#34;** as the key name - `{ &#34;data.2&#34;: &#34;value&#34; }` 2. Cannot use **&#34;$&#34;** as the prefix in key names - `{ &#34;$data&#34;: &#34;value&#34; }` 3. Cannot use empty string in key names - `{ &#34;&#34;: &#34;value&#34; }` ## Record Metadata Metadata allows user to define the behaviour of the record. Metadata can be defined in request body with field name **__META**. When creating record, if **__META** field is not defined, the metadata value will use the default value. When updating record, if **__META** field is not defined, the existing metadata value will stay as is. **Metadata List:** 1. is_public (default: false, type: bool) Indicate whether the player record is a public record or not. **Request Body Example:** ``` { &#34;__META&#34;: { &#34;is_public&#34;: true } ... } ```
     */
    createRecord_ByUserId_ByKey(userId: string, key: string, data: PlayerRecordRequest): Promise<Response<PlayerRecordResponse>>;
    /**
     * ## Description This endpoints will create new player record or replace the existing player record. Only user that own the existing player record could modify it. **Replace behaviour:** The existing value will be replaced completely with the new value. Example - Existing JSON: `{ &#34;data1&#34;: &#34;value&#34; }` - New JSON: `{ &#34;data2&#34;: &#34;new value&#34; }` - Result: `{ &#34;data2&#34;: &#34;new value&#34; }` ## Restriction This is the restriction of Key Naming for the record: 1. Cannot use **&#34;.&#34;** as the key name - `{ &#34;data.2&#34;: &#34;value&#34; }` 2. Cannot use **&#34;$&#34;** as the prefix in key names - `{ &#34;$data&#34;: &#34;value&#34; }` 3. Cannot use empty string in key names - `{ &#34;&#34;: &#34;value&#34; }` ## Record Metadata Metadata allows user to define the behaviour of the record. Metadata can be defined in request body with field name **__META**. When creating record, if **__META** field is not defined, the metadata value will use the default value. When updating record, if **__META** field is not defined, the existing metadata value will stay as is. **Metadata List:** 1. is_public (default: false, type: bool) Indicate whether the player record is a public record or not. **Request Body Example:** ``` { &#34;__META&#34;: { &#34;is_public&#34;: true } ... } ```
     */
    updateRecord_ByUserId_ByKey(userId: string, key: string, data: PlayerRecordRequest): Promise<Response<PlayerRecordResponse>>;
    /**
     * Retrieve list of other public player records key under given namespace.
     */
    getRecordsPublic_ByUserId(userId: string, queryParams?: {
        limit?: number;
        offset?: number;
        tags?: string[];
    }): Promise<Response<ListPlayerRecordKeysResponse>>;
    /**
     * Delete player public record. ## Warning: This endpoint is going to deprecate This endpoint is going to deprecate in the future please don&#39;t use it. For alternative, please use these endpoints: - **POST /cloudsave/v1/namespaces/{namespace}/users/{userId}/records/{key}** and utilizing **__META** functionality - **PUT /cloudsave/v1/namespaces/{namespace}/users/{userId}/records/{key}** and utilizing **__META** functionality - **DELETE /cloudsave/v1/namespaces/{namespace}/users/{userId}/records/{key}**
     */
    deletePublicMeUser_ByKey(key: string): Promise<Response<unknown>>;
    /**
     * Bulk get other player&#39;s record that is public by userIds, max allowed 20 at a time. Only record with `isPublic=true` that can be retrieved using this endpoint.
     */
    fetchPublicBulkUser_ByKey(key: string, data: BulkUserIDsRequest): Promise<Response<BulkGetPlayerRecordResponse>>;
    /**
     * Retrieve other player public record key and payload in bulk under given namespace. Maximum bulk key limit per request 20
     */
    fetchRecordBulk_ByUserId(userId: string, data: BulkGetPlayerRecordsRequest): Promise<Response<BulkGetPlayerRecordResponse>>;
    /**
     * Get other player&#39;s record that is public. Only record with `isPublic=true` that can be retrieved using this endpoint.
     */
    getPublic_ByUserId_ByKey(userId: string, key: string): Promise<Response<PlayerRecordResponse>>;
    /**
     * ## Description This endpoints will create new player public record or append the existing player public record. **Append example:** Example 1 - Existing JSON: `{ &#34;data1&#34;: &#34;value&#34; }` - New JSON: `{ &#34;data2&#34;: &#34;new value&#34; }` - Result: `{ &#34;data1&#34;: &#34;value&#34;, &#34;data2&#34;: &#34;new value&#34; }` Example 2 - Existing JSON: `{ &#34;data1&#34;: { &#34;data2&#34;: &#34;value&#34; }` - New JSON: `{ &#34;data1&#34;: { &#34;data3&#34;: &#34;new value&#34; }` - Result: `{ &#34;data1&#34;: { &#34;data2&#34;: &#34;value&#34;, &#34;data3&#34;: &#34;new value&#34; }` ## Restriction This is the restriction of Key Naming for the record: 1. Cannot use **&#34;.&#34;** as the key name - `{ &#34;data.2&#34;: &#34;value&#34; }` 2. Cannot use **&#34;$&#34;** as the prefix in key names - `{ &#34;$data&#34;: &#34;value&#34; }` 3. Cannot use empty string in key names - `{ &#34;&#34;: &#34;value&#34; }` ## Reserved Word Reserved Word List: **__META** The reserved word cannot be used as a field in record value, If still defining the field when creating or updating the record, it will be ignored. ## Warning: This endpoint is going to deprecate This endpoint is going to deprecate in the future please don&#39;t use it. For alternative, please use these endpoints: - **POST /cloudsave/v1/namespaces/{namespace}/users/{userId}/records/{key}** and utilizing **__META** functionality - **PUT /cloudsave/v1/namespaces/{namespace}/users/{userId}/records/{key}** and utilizing **__META** functionality - **DELETE /cloudsave/v1/namespaces/{namespace}/users/{userId}/records/{key}**
     */
    createPublic_ByUserId_ByKey(userId: string, key: string, data: PlayerRecordRequest): Promise<Response<PlayerRecordResponse>>;
    /**
     * ## Description This endpoints will create new player public record or replace the existing player public record. **Replace behaviour:** The existing value will be replaced completely with the new value. Example - Existing JSON: `{ &#34;data1&#34;: &#34;value&#34; }` - New JSON: `{ &#34;data2&#34;: &#34;new value&#34; }` - Result: `{ &#34;data2&#34;: &#34;new value&#34; }` ## Restriction This is the restriction of Key Naming for the record: 1. Cannot use **&#34;.&#34;** as the key name - `{ &#34;data.2&#34;: &#34;value&#34; }` 2. Cannot use **&#34;$&#34;** as the prefix in key names - `{ &#34;$data&#34;: &#34;value&#34; }` 3. Cannot use empty string in key names - `{ &#34;&#34;: &#34;value&#34; }` ## Reserved Word Reserved Word List: **__META** The reserved word cannot be used as a field in record value, If still defining the field when creating or updating the record, it will be ignored. ## Warning: This endpoint is going to deprecate This endpoint is going to deprecate in the future please don&#39;t use it. For alternative, please use these endpoints: - **POST /cloudsave/v1/namespaces/{namespace}/users/{userId}/records/{key}** and utilizing **__META** functionality - **PUT /cloudsave/v1/namespaces/{namespace}/users/{userId}/records/{key}** and utilizing **__META** functionality - **DELETE /cloudsave/v1/namespaces/{namespace}/users/{userId}/records/{key}**
     */
    updatePublic_ByUserId_ByKey(userId: string, key: string, data: PlayerRecordRequest): Promise<Response<PlayerRecordResponse>>;
}

/**
 * AUTO GENERATED
 */

declare class PublicTags$ {
    private axiosInstance;
    private namespace;
    private useSchemaValidation;
    constructor(axiosInstance: AxiosInstance, namespace: string, useSchemaValidation?: boolean);
    /**
     * ## Description Retrieve list of available tags by namespace
     */
    getTags(queryParams?: {
        limit?: number;
        offset?: number;
    }): Promise<Response<ListTagsResponse>>;
}

export { AdminConcurrentRecordRequest, AdminGameConcurrentRecordRequest, AdminGameRecordRequest, AdminGameRecordResponse, AdminPlayerConcurrentRecordRequest, AdminPlayerRecordKeyInfo, AdminPlayerRecordRequest, AdminPlayerRecordResponse, AppConfig, BinaryInfoResponse, BinaryRecordRequest, BulkGetAdminGameRecordRequest, BulkGetAdminGameRecordResponse, BulkGetAdminPlayerRecordRequest, BulkGetAdminPlayerRecordResponse, BulkGetGameBinaryRecordResponse, BulkGetGameRecordRequest, BulkGetGameRecordResponse, BulkGetPlayerBinaryRecordResponse, BulkGetPlayerRecordResponse, BulkGetPlayerRecordSizeResponse, BulkGetPlayerRecordsRequest, BulkUpdatePlayerRecordByKeyRequestDetail, BulkUpdatePlayerRecordByKeyResponse, BulkUpdatePlayerRecordByKeyResponseArray, BulkUpdatePlayerRecordRequestDetail, BulkUpdatePlayerRecordResponse, BulkUpdatePlayerRecordResponseArray, BulkUpdatePlayerRecordsByKeyRequest, BulkUpdatePlayerRecordsRequest, BulkUserIDsRequest, BulkUserKeyRequest, Cloudsave, ConcurrentRecord$, ConcurrentRecordAdmin$, ConcurrentRecordAdminApi, ConcurrentRecordApi, ConcurrentRecordRequest, CustomConfig, CustomFunction, GameBinaryRecordAdmin$, GameBinaryRecordAdminApi, GameBinaryRecordAdminResponse, GameBinaryRecordCreate, GameBinaryRecordMetadataRequest, GameBinaryRecordResponse, GameRecordAdmin$, GameRecordAdminApi, GameRecordAdminResponse, GameRecordRequest, GameRecordResponse, ListAdminGameRecordKeysResponse, ListAdminPlayerRecordKeysResponse, ListGameBinaryRecordsAdminResponse, ListGameBinaryRecordsResponse, ListGameRecordKeysResponse, ListPlayerBinaryRecordsResponse, ListPlayerRecordKeysResponse, ListTagsResponse, Pagination, PlayerBinaryRecordAdmin$, PlayerBinaryRecordAdminApi, PlayerBinaryRecordCreate, PlayerBinaryRecordMetadataPublicRequest, PlayerBinaryRecordMetadataRequest, PlayerBinaryRecordResponse, PlayerRecordAdmin$, PlayerRecordAdminApi, PlayerRecordConcurrentUpdateResponse, PlayerRecordKeyInfo, PlayerRecordRequest, PlayerRecordResponse, PlayerRecordSizeResponse, PluginConfigAdmin$, PluginConfigAdminApi, PluginRequest, PluginResponse, PublicGameBinaryRecord$, PublicGameBinaryRecordApi, PublicGameBinaryRecordCreate, PublicGameRecord$, PublicGameRecordApi, PublicPlayerBinaryRecord$, PublicPlayerBinaryRecordApi, PublicPlayerBinaryRecordCreate, PublicPlayerRecord$, PublicPlayerRecordApi, PublicTags$, PublicTagsApi, RecordAdmin$, RecordAdminApi, ResponseError, TagInfo, TagRequest, TagsAdmin$, TagsAdminApi, TtlConfigAdmin$, TtlConfigAdminApi, TtlConfigDto, UploadBinaryRecordRequest, UploadBinaryRecordResponse, UserKeyRequest };

// src/generated-definitions/PlayerRecordConcurrentUpdateResponse.ts
import { z } from "zod";
var PlayerRecordConcurrentUpdateResponse = z.object({ updated_at: z.string() });

// src/generated-admin/endpoints/ConcurrentRecordAdmin$.ts
import { Validate } from "@accelbyte/sdk";
import { z as z2 } from "zod";
var ConcurrentRecordAdmin$ = class {
  // @ts-ignore
  // prettier-ignore
  constructor(axiosInstance, namespace, useSchemaValidation = true) {
    this.axiosInstance = axiosInstance;
    this.namespace = namespace;
    this.useSchemaValidation = useSchemaValidation;
  }
  /**
   * ## Description This endpoints will create new game record or replace the existing game record. **Replace behaviour:** The existing value will be replaced completely with the new value. Example - Existing JSON: `{ &#34;data1&#34;: &#34;value&#34; }` - New JSON: `{ &#34;data2&#34;: &#34;new value&#34; }` - Result: `{ &#34;data2&#34;: &#34;new value&#34; }` ## Restriction This is the restriction of Key Naming for the record: 1. Cannot use **&#34;.&#34;** as the key name - `{ &#34;data.2&#34;: &#34;value&#34; }` 2. Cannot use **&#34;$&#34;** as the prefix in key names - `{ &#34;$data&#34;: &#34;value&#34; }` 3. Cannot use empty string in key names - `{ &#34;&#34;: &#34;value&#34; }` ## Reserved Word Reserved Word List: **__META** The reserved word cannot be used as a field in record value, If still defining the field when creating or updating the record, it will be ignored. ## Parameters Notes 1. set_by (default: CLIENT, type: string) Indicate which party that could modify the game record. SERVER: record can be modified by server only. CLIENT: record can be modified by client and server. 2. updatedAt (required: true) Time format style: RFC3339 3. value Json 4. tags (default: *empty array*, type: array of string) Indicate the tagging for the game record. **Request Body Example:** ``` { &#34;set_by&#34;: &#34;SERVER&#34;, &#34;value&#34;: {}, &#34;updatedAt&#34;: &#34;2022-03-17T10:42:15.444Z&#34;, &#34;tags&#34;: [&#34;tag1&#34;, &#34;tag2&#34;] } ``` ## Optimistic Concurrency Control This endpoint implement optimistic concurrency control to avoid race condition. If the record has been updated since the client fetch it, the server will return HTTP status code 412 (precondition failed) and client need to redo the operation (fetch data and do update). Otherwise, the server will process the request.
   */
  updateConcurrentRecord_ByKey(key, data) {
    const params = {};
    const url = "/cloudsave/v1/admin/namespaces/{namespace}/concurrent/records/{key}".replace("{namespace}", this.namespace).replace("{key}", key);
    const resultPromise = this.axiosInstance.put(url, data, { params });
    return Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, z2.unknown(), "z.unknown()");
  }
  /**
   * ## Description This endpoints will create new game record or replace the existing game record. **Replace behaviour:** The existing value will be replaced completely with the new value. Example - Existing JSON: `{ &#34;data1&#34;: &#34;value&#34; }` - New JSON: `{ &#34;data2&#34;: &#34;new value&#34; }` - Result: `{ &#34;data2&#34;: &#34;new value&#34; }` ## Restriction This is the restriction of Key Naming for the record: 1. Cannot use **&#34;.&#34;** as the key name - `{ &#34;data.2&#34;: &#34;value&#34; }` 2. Cannot use **&#34;$&#34;** as the prefix in key names - `{ &#34;$data&#34;: &#34;value&#34; }` 3. Cannot use empty string in key names - `{ &#34;&#34;: &#34;value&#34; }` ## Reserved Word Reserved Word List: **__META** The reserved word cannot be used as a field in record value, If still defining the field when creating or updating the record, it will be ignored. ## Parameters Notes 1. updatedAt (required: true) Time format style: RFC3339 2. value Json 3. tags (default: *empty array*, type: array of string) Indicate the tagging for the admin record. **Request Body Example:** ``` { &#34;value&#34;: {}, &#34;updatedAt&#34;: &#34;2022-03-17T10:42:15.444Z&#34;, &#34;tags&#34;: [&#34;tag1&#34;, &#34;tag2&#34;] } ``` ## Optimistic Concurrency Control This endpoint implement optimistic concurrency control to avoid race condition. If the record has been updated since the client fetch it, the server will return HTTP status code 412 (precondition failed) and client need to redo the operation (fetch data and do update). Otherwise, the server will process the request.
   */
  updateConcurrentAdminrecord_ByKey(key, data) {
    const params = {};
    const url = "/cloudsave/v1/admin/namespaces/{namespace}/concurrent/adminrecords/{key}".replace("{namespace}", this.namespace).replace("{key}", key);
    const resultPromise = this.axiosInstance.put(url, data, { params });
    return Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, z2.unknown(), "z.unknown()");
  }
  /**
   * ## Description This endpoints will create new player record or replace the existing player record. **Replace behaviour:** The existing value will be replaced completely with the new value. Example - Existing JSON: `{ &#34;data1&#34;: &#34;value&#34; }` - New JSON: `{ &#34;data2&#34;: &#34;new value&#34; }` - Result: `{ &#34;data2&#34;: &#34;new value&#34; }` ## Restriction This is the restriction of Key Naming for the record: 1. Cannot use **&#34;.&#34;** as the key name - `{ &#34;data.2&#34;: &#34;value&#34; }` 2. Cannot use **&#34;$&#34;** as the prefix in key names - `{ &#34;$data&#34;: &#34;value&#34; }` 3. Cannot use empty string in key names - `{ &#34;&#34;: &#34;value&#34; }` ## Reserved Word Reserved Word List: **__META** The reserved word cannot be used as a field in record value, If still defining the field when creating or updating the record, it will be ignored. ## Parameters Notes 1. set_by (default: CLIENT, type: string) Indicate which party that could modify the game record. SERVER: record can be modified by server only. CLIENT: record can be modified by client and server. 2. updatedAt (required: true) Time format style: RFC3339 3. value Json 4. tags (default: *empty array*, type: array of string) Indicate the tagging for the game record. **Request Body Example:** ``` { &#34;set_by&#34;: &#34;SERVER&#34;, &#34;value&#34;: {}, &#34;updatedAt&#34;: &#34;2022-03-17T10:42:15.444Z&#34;, &#34;tags&#34;: [&#34;tag1&#34;, &#34;tag2&#34;] } ``` ## Optimistic Concurrency Control This endpoint implement optimistic concurrency control to avoid race condition. If the record has been updated since the client fetch it, the server will return HTTP status code 412 (precondition failed) and client need to redo the operation (fetch data and do update). Otherwise, the server will process the request.
   */
  updateConcurrentRecord_ByUserId_ByKey(userId, key, data, queryParams) {
    const params = { ...queryParams };
    const url = "/cloudsave/v1/admin/namespaces/{namespace}/users/{userId}/concurrent/records/{key}".replace("{namespace}", this.namespace).replace("{userId}", userId).replace("{key}", key);
    const resultPromise = this.axiosInstance.put(url, data, { params });
    return Validate.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      PlayerRecordConcurrentUpdateResponse,
      "PlayerRecordConcurrentUpdateResponse"
    );
  }
  /**
   * ## Description This endpoints will create new admin player record or replace the existing admin player record. **Replace behaviour:** The existing value will be replaced completely with the new value. Example - Existing JSON: `{ &#34;data1&#34;: &#34;value&#34; }` - New JSON: `{ &#34;data2&#34;: &#34;new value&#34; }` - Result: `{ &#34;data2&#34;: &#34;new value&#34; }` ## Restriction This is the restriction of Key Naming for the record: 1. Cannot use **&#34;.&#34;** as the key name - `{ &#34;data.2&#34;: &#34;value&#34; }` 2. Cannot use **&#34;$&#34;** as the prefix in key names - `{ &#34;$data&#34;: &#34;value&#34; }` 3. Cannot use empty string in key names - `{ &#34;&#34;: &#34;value&#34; }` ## Reserved Word Reserved Word List: **__META** The reserved word cannot be used as a field in record value, If still defining the field when creating or updating the record, it will be ignored. ## Parameters Notes 1. updatedAt (required: true) Time format style: RFC3339 2. value Json 3. tags (default: *empty array*, type: array of string) Indicate the tagging for the admin record. **Request Body Example:** ``` { &#34;value&#34;: {}, &#34;updatedAt&#34;: &#34;2022-03-17T10:42:15.444Z&#34;, &#34;tags&#34;: [&#34;tag1&#34;, &#34;tag2&#34;] } ``` ## Optimistic Concurrency Control This endpoint implement optimistic concurrency control to avoid race condition. If the record has been updated since the client fetch it, the server will return HTTP status code 412 (precondition failed) and client need to redo the operation (fetch data and do update). Otherwise, the server will process the request.
   */
  updateConcurrentAdminrecord_ByUserId_ByKey(userId, key, data, queryParams) {
    const params = { ...queryParams };
    const url = "/cloudsave/v1/admin/namespaces/{namespace}/users/{userId}/concurrent/adminrecords/{key}".replace("{namespace}", this.namespace).replace("{userId}", userId).replace("{key}", key);
    const resultPromise = this.axiosInstance.put(url, data, { params });
    return Validate.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      PlayerRecordConcurrentUpdateResponse,
      "PlayerRecordConcurrentUpdateResponse"
    );
  }
  /**
   * ## Description This endpoints will create new player public record or replace the existing player public record. **Replace behaviour:** The existing value will be replaced completely with the new value. Example - Existing JSON: `{ &#34;data1&#34;: &#34;value&#34; }` - New JSON: `{ &#34;data2&#34;: &#34;new value&#34; }` - Result: `{ &#34;data2&#34;: &#34;new value&#34; }` ## Restriction This is the restriction of Key Naming for the record: 1. Cannot use **&#34;.&#34;** as the key name - `{ &#34;data.2&#34;: &#34;value&#34; }` 2. Cannot use **&#34;$&#34;** as the prefix in key names - `{ &#34;$data&#34;: &#34;value&#34; }` 3. Cannot use empty string in key names - `{ &#34;&#34;: &#34;value&#34; }` ## Reserved Word Reserved Word List: **__META** The reserved word cannot be used as a field in record value, If still defining the field when creating or updating the record, it will be ignored. ## Parameters Notes 1. set_by (default: CLIENT, type: string) Indicate which party that could modify the game record. SERVER: record can be modified by server only. CLIENT: record can be modified by client and server. 2. updatedAt (required: true) Time format style: RFC3339 3. value Json 4. tags (default: *empty array*, type: array of string) Indicate the tagging for the game record. **Request Body Example:** ``` { &#34;set_by&#34;: &#34;SERVER&#34;, &#34;value&#34;: {}, &#34;updatedAt&#34;: &#34;2022-03-17T10:42:15.444Z&#34;, &#34;tags&#34;: [&#34;tag1&#34;, &#34;tag2&#34;] } ``` ## Optimistic Concurrency Control This endpoint implement optimistic concurrency control to avoid race condition. If the record has been updated since the client fetch it, the server will return HTTP status code 412 (precondition failed) and client need to redo the operation (fetch data and do update). Otherwise, the server will process the request.
   */
  updatePublicConcurrent_ByUserId_ByKey(userId, key, data, queryParams) {
    const params = { ...queryParams };
    const url = "/cloudsave/v1/admin/namespaces/{namespace}/users/{userId}/concurrent/records/{key}/public".replace("{namespace}", this.namespace).replace("{userId}", userId).replace("{key}", key);
    const resultPromise = this.axiosInstance.put(url, data, { params });
    return Validate.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      PlayerRecordConcurrentUpdateResponse,
      "PlayerRecordConcurrentUpdateResponse"
    );
  }
};

// src/generated-admin/ConcurrentRecordAdminApi.ts
import { ApiUtils, Network } from "@accelbyte/sdk";
function ConcurrentRecordAdminApi(sdk, args) {
  const sdkAssembly = sdk.assembly();
  const namespace = args?.coreConfig?.namespace ?? sdkAssembly.coreConfig.namespace;
  const useSchemaValidation = args?.coreConfig?.useSchemaValidation ?? sdkAssembly.coreConfig.useSchemaValidation;
  let axiosInstance = sdkAssembly.axiosInstance;
  const requestConfigOverrides = args?.axiosConfig?.request;
  const baseURLOverride = args?.coreConfig?.baseURL;
  const interceptorsOverride = args?.axiosConfig?.interceptors ?? [];
  if (requestConfigOverrides || baseURLOverride || interceptorsOverride.length > 0) {
    const requestConfig = ApiUtils.mergeAxiosConfigs(sdkAssembly.axiosInstance.defaults, {
      ...baseURLOverride ? { baseURL: baseURLOverride } : {},
      ...requestConfigOverrides
    });
    axiosInstance = Network.create(requestConfig);
    for (const interceptor of interceptorsOverride) {
      if (interceptor.type === "request") {
        axiosInstance.interceptors.request.use(interceptor.onRequest, interceptor.onError);
      }
      if (interceptor.type === "response") {
        axiosInstance.interceptors.response.use(interceptor.onSuccess, interceptor.onError);
      }
    }
  }
  async function updateConcurrentRecord_ByKey(key, data) {
    const $ = new ConcurrentRecordAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.updateConcurrentRecord_ByKey(key, data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function updateConcurrentAdminrecord_ByKey(key, data) {
    const $ = new ConcurrentRecordAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.updateConcurrentAdminrecord_ByKey(key, data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function updateConcurrentRecord_ByUserId_ByKey(userId, key, data, queryParams) {
    const $ = new ConcurrentRecordAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.updateConcurrentRecord_ByUserId_ByKey(userId, key, data, queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function updateConcurrentAdminrecord_ByUserId_ByKey(userId, key, data, queryParams) {
    const $ = new ConcurrentRecordAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.updateConcurrentAdminrecord_ByUserId_ByKey(userId, key, data, queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function updatePublicConcurrent_ByUserId_ByKey(userId, key, data, queryParams) {
    const $ = new ConcurrentRecordAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.updatePublicConcurrent_ByUserId_ByKey(userId, key, data, queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  return {
    /**
     * ## Description This endpoints will create new game record or replace the existing game record. **Replace behaviour:** The existing value will be replaced completely with the new value. Example - Existing JSON: `{ &#34;data1&#34;: &#34;value&#34; }` - New JSON: `{ &#34;data2&#34;: &#34;new value&#34; }` - Result: `{ &#34;data2&#34;: &#34;new value&#34; }` ## Restriction This is the restriction of Key Naming for the record: 1. Cannot use **&#34;.&#34;** as the key name - `{ &#34;data.2&#34;: &#34;value&#34; }` 2. Cannot use **&#34;$&#34;** as the prefix in key names - `{ &#34;$data&#34;: &#34;value&#34; }` 3. Cannot use empty string in key names - `{ &#34;&#34;: &#34;value&#34; }` ## Reserved Word Reserved Word List: **__META** The reserved word cannot be used as a field in record value, If still defining the field when creating or updating the record, it will be ignored. ## Parameters Notes 1. set_by (default: CLIENT, type: string) Indicate which party that could modify the game record. SERVER: record can be modified by server only. CLIENT: record can be modified by client and server. 2. updatedAt (required: true) Time format style: RFC3339 3. value Json 4. tags (default: *empty array*, type: array of string) Indicate the tagging for the game record. **Request Body Example:** ``` { &#34;set_by&#34;: &#34;SERVER&#34;, &#34;value&#34;: {}, &#34;updatedAt&#34;: &#34;2022-03-17T10:42:15.444Z&#34;, &#34;tags&#34;: [&#34;tag1&#34;, &#34;tag2&#34;] } ``` ## Optimistic Concurrency Control This endpoint implement optimistic concurrency control to avoid race condition. If the record has been updated since the client fetch it, the server will return HTTP status code 412 (precondition failed) and client need to redo the operation (fetch data and do update). Otherwise, the server will process the request.
     */
    updateConcurrentRecord_ByKey,
    /**
     * ## Description This endpoints will create new game record or replace the existing game record. **Replace behaviour:** The existing value will be replaced completely with the new value. Example - Existing JSON: `{ &#34;data1&#34;: &#34;value&#34; }` - New JSON: `{ &#34;data2&#34;: &#34;new value&#34; }` - Result: `{ &#34;data2&#34;: &#34;new value&#34; }` ## Restriction This is the restriction of Key Naming for the record: 1. Cannot use **&#34;.&#34;** as the key name - `{ &#34;data.2&#34;: &#34;value&#34; }` 2. Cannot use **&#34;$&#34;** as the prefix in key names - `{ &#34;$data&#34;: &#34;value&#34; }` 3. Cannot use empty string in key names - `{ &#34;&#34;: &#34;value&#34; }` ## Reserved Word Reserved Word List: **__META** The reserved word cannot be used as a field in record value, If still defining the field when creating or updating the record, it will be ignored. ## Parameters Notes 1. updatedAt (required: true) Time format style: RFC3339 2. value Json 3. tags (default: *empty array*, type: array of string) Indicate the tagging for the admin record. **Request Body Example:** ``` { &#34;value&#34;: {}, &#34;updatedAt&#34;: &#34;2022-03-17T10:42:15.444Z&#34;, &#34;tags&#34;: [&#34;tag1&#34;, &#34;tag2&#34;] } ``` ## Optimistic Concurrency Control This endpoint implement optimistic concurrency control to avoid race condition. If the record has been updated since the client fetch it, the server will return HTTP status code 412 (precondition failed) and client need to redo the operation (fetch data and do update). Otherwise, the server will process the request.
     */
    updateConcurrentAdminrecord_ByKey,
    /**
     * ## Description This endpoints will create new player record or replace the existing player record. **Replace behaviour:** The existing value will be replaced completely with the new value. Example - Existing JSON: `{ &#34;data1&#34;: &#34;value&#34; }` - New JSON: `{ &#34;data2&#34;: &#34;new value&#34; }` - Result: `{ &#34;data2&#34;: &#34;new value&#34; }` ## Restriction This is the restriction of Key Naming for the record: 1. Cannot use **&#34;.&#34;** as the key name - `{ &#34;data.2&#34;: &#34;value&#34; }` 2. Cannot use **&#34;$&#34;** as the prefix in key names - `{ &#34;$data&#34;: &#34;value&#34; }` 3. Cannot use empty string in key names - `{ &#34;&#34;: &#34;value&#34; }` ## Reserved Word Reserved Word List: **__META** The reserved word cannot be used as a field in record value, If still defining the field when creating or updating the record, it will be ignored. ## Parameters Notes 1. set_by (default: CLIENT, type: string) Indicate which party that could modify the game record. SERVER: record can be modified by server only. CLIENT: record can be modified by client and server. 2. updatedAt (required: true) Time format style: RFC3339 3. value Json 4. tags (default: *empty array*, type: array of string) Indicate the tagging for the game record. **Request Body Example:** ``` { &#34;set_by&#34;: &#34;SERVER&#34;, &#34;value&#34;: {}, &#34;updatedAt&#34;: &#34;2022-03-17T10:42:15.444Z&#34;, &#34;tags&#34;: [&#34;tag1&#34;, &#34;tag2&#34;] } ``` ## Optimistic Concurrency Control This endpoint implement optimistic concurrency control to avoid race condition. If the record has been updated since the client fetch it, the server will return HTTP status code 412 (precondition failed) and client need to redo the operation (fetch data and do update). Otherwise, the server will process the request.
     */
    updateConcurrentRecord_ByUserId_ByKey,
    /**
     * ## Description This endpoints will create new admin player record or replace the existing admin player record. **Replace behaviour:** The existing value will be replaced completely with the new value. Example - Existing JSON: `{ &#34;data1&#34;: &#34;value&#34; }` - New JSON: `{ &#34;data2&#34;: &#34;new value&#34; }` - Result: `{ &#34;data2&#34;: &#34;new value&#34; }` ## Restriction This is the restriction of Key Naming for the record: 1. Cannot use **&#34;.&#34;** as the key name - `{ &#34;data.2&#34;: &#34;value&#34; }` 2. Cannot use **&#34;$&#34;** as the prefix in key names - `{ &#34;$data&#34;: &#34;value&#34; }` 3. Cannot use empty string in key names - `{ &#34;&#34;: &#34;value&#34; }` ## Reserved Word Reserved Word List: **__META** The reserved word cannot be used as a field in record value, If still defining the field when creating or updating the record, it will be ignored. ## Parameters Notes 1. updatedAt (required: true) Time format style: RFC3339 2. value Json 3. tags (default: *empty array*, type: array of string) Indicate the tagging for the admin record. **Request Body Example:** ``` { &#34;value&#34;: {}, &#34;updatedAt&#34;: &#34;2022-03-17T10:42:15.444Z&#34;, &#34;tags&#34;: [&#34;tag1&#34;, &#34;tag2&#34;] } ``` ## Optimistic Concurrency Control This endpoint implement optimistic concurrency control to avoid race condition. If the record has been updated since the client fetch it, the server will return HTTP status code 412 (precondition failed) and client need to redo the operation (fetch data and do update). Otherwise, the server will process the request.
     */
    updateConcurrentAdminrecord_ByUserId_ByKey,
    /**
     * ## Description This endpoints will create new player public record or replace the existing player public record. **Replace behaviour:** The existing value will be replaced completely with the new value. Example - Existing JSON: `{ &#34;data1&#34;: &#34;value&#34; }` - New JSON: `{ &#34;data2&#34;: &#34;new value&#34; }` - Result: `{ &#34;data2&#34;: &#34;new value&#34; }` ## Restriction This is the restriction of Key Naming for the record: 1. Cannot use **&#34;.&#34;** as the key name - `{ &#34;data.2&#34;: &#34;value&#34; }` 2. Cannot use **&#34;$&#34;** as the prefix in key names - `{ &#34;$data&#34;: &#34;value&#34; }` 3. Cannot use empty string in key names - `{ &#34;&#34;: &#34;value&#34; }` ## Reserved Word Reserved Word List: **__META** The reserved word cannot be used as a field in record value, If still defining the field when creating or updating the record, it will be ignored. ## Parameters Notes 1. set_by (default: CLIENT, type: string) Indicate which party that could modify the game record. SERVER: record can be modified by server only. CLIENT: record can be modified by client and server. 2. updatedAt (required: true) Time format style: RFC3339 3. value Json 4. tags (default: *empty array*, type: array of string) Indicate the tagging for the game record. **Request Body Example:** ``` { &#34;set_by&#34;: &#34;SERVER&#34;, &#34;value&#34;: {}, &#34;updatedAt&#34;: &#34;2022-03-17T10:42:15.444Z&#34;, &#34;tags&#34;: [&#34;tag1&#34;, &#34;tag2&#34;] } ``` ## Optimistic Concurrency Control This endpoint implement optimistic concurrency control to avoid race condition. If the record has been updated since the client fetch it, the server will return HTTP status code 412 (precondition failed) and client need to redo the operation (fetch data and do update). Otherwise, the server will process the request.
     */
    updatePublicConcurrent_ByUserId_ByKey
  };
}

// src/generated-definitions/BinaryInfoResponse.ts
import { z as z3 } from "zod";
var BinaryInfoResponse = z3.object({
  content_type: z3.string(),
  created_at: z3.string(),
  file_location: z3.string(),
  updated_at: z3.string(),
  url: z3.string().nullish(),
  version: z3.number().int()
});

// src/generated-definitions/TtlConfigDto.ts
import { z as z4 } from "zod";
var TtlConfigDto = z4.object({ action: z4.enum(["DELETE"]), expires_at: z4.string() });

// src/generated-definitions/GameBinaryRecordAdminResponse.ts
import { z as z5 } from "zod";
var GameBinaryRecordAdminResponse = z5.object({
  binary_info: BinaryInfoResponse.nullish(),
  created_at: z5.string(),
  key: z5.string(),
  namespace: z5.string(),
  set_by: z5.enum(["CLIENT", "SERVER"]).nullish(),
  tags: z5.array(z5.string()).nullish(),
  ttl_config: TtlConfigDto.nullish(),
  updated_at: z5.string()
});

// src/generated-definitions/Pagination.ts
import { z as z6 } from "zod";
var Pagination = z6.object({ first: z6.string(), last: z6.string(), next: z6.string(), previous: z6.string() });

// src/generated-definitions/ListGameBinaryRecordsAdminResponse.ts
import { z as z7 } from "zod";
var ListGameBinaryRecordsAdminResponse = z7.object({ data: z7.array(GameBinaryRecordAdminResponse), paging: Pagination });

// src/generated-definitions/UploadBinaryRecordResponse.ts
import { z as z8 } from "zod";
var UploadBinaryRecordResponse = z8.object({
  content_type: z8.string(),
  file_location: z8.string(),
  url: z8.string(),
  version: z8.number().int()
});

// src/generated-admin/endpoints/GameBinaryRecordAdmin$.ts
import { Validate as Validate2 } from "@accelbyte/sdk";
import { z as z9 } from "zod";
var GameBinaryRecordAdmin$ = class {
  // @ts-ignore
  // prettier-ignore
  constructor(axiosInstance, namespace, useSchemaValidation = true) {
    this.axiosInstance = axiosInstance;
    this.namespace = namespace;
    this.useSchemaValidation = useSchemaValidation;
  }
  /**
   * Retrieve list of binary records by namespace.
   */
  getBinaries(queryParams) {
    const params = { limit: 25, ...queryParams };
    const url = "/cloudsave/v1/admin/namespaces/{namespace}/binaries".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.get(url, { params });
    return Validate2.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      ListGameBinaryRecordsAdminResponse,
      "ListGameBinaryRecordsAdminResponse"
    );
  }
  /**
   * Create a game binary record. Other detail info: `key` should follow these rules: 1. support uppercase and lowercase letters, numbers, and separators **&#34;-&#34;**, **&#34;_&#34;**, **&#34;.&#34;** are allowed 2. begin and end with letters or numbers 3. spaces are not allowed 4. separators must not appears twice in a row Supported file types: jpeg, jpg, png, bmp, gif, mp3, webp, and bin.
   */
  createBinary(data) {
    const params = {};
    const url = "/cloudsave/v1/admin/namespaces/{namespace}/binaries".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.post(url, data, { params });
    return Validate2.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      UploadBinaryRecordResponse,
      "UploadBinaryRecordResponse"
    );
  }
  /**
   * Delete a game binary record.
   */
  deleteBinary_ByKey(key) {
    const params = {};
    const url = "/cloudsave/v1/admin/namespaces/{namespace}/binaries/{key}".replace("{namespace}", this.namespace).replace("{key}", key);
    const resultPromise = this.axiosInstance.delete(url, { params });
    return Validate2.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, z9.unknown(), "z.unknown()");
  }
  /**
   * Get a game binary record by its key.
   */
  getBinary_ByKey(key) {
    const params = {};
    const url = "/cloudsave/v1/admin/namespaces/{namespace}/binaries/{key}".replace("{namespace}", this.namespace).replace("{key}", key);
    const resultPromise = this.axiosInstance.get(url, { params });
    return Validate2.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      GameBinaryRecordAdminResponse,
      "GameBinaryRecordAdminResponse"
    );
  }
  /**
   * Update a game binary record file by its key
   */
  updateBinary_ByKey(key, data) {
    const params = {};
    const url = "/cloudsave/v1/admin/namespaces/{namespace}/binaries/{key}".replace("{namespace}", this.namespace).replace("{key}", key);
    const resultPromise = this.axiosInstance.put(url, data, { params });
    return Validate2.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      GameBinaryRecordAdminResponse,
      "GameBinaryRecordAdminResponse"
    );
  }
  /**
   * Update a game binary record metadata by its key
   */
  updateMetadata_ByKey(key, data) {
    const params = {};
    const url = "/cloudsave/v1/admin/namespaces/{namespace}/binaries/{key}/metadata".replace("{namespace}", this.namespace).replace("{key}", key);
    const resultPromise = this.axiosInstance.put(url, data, { params });
    return Validate2.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      GameBinaryRecordAdminResponse,
      "GameBinaryRecordAdminResponse"
    );
  }
  /**
   * Request presigned URL to upload the binary record to s3. Other detail info: Supported file types: jpeg, jpg, png, bmp, gif, mp3, webp, and bin.
   */
  createPresigned_ByKey(key, data) {
    const params = {};
    const url = "/cloudsave/v1/admin/namespaces/{namespace}/binaries/{key}/presigned".replace("{namespace}", this.namespace).replace("{key}", key);
    const resultPromise = this.axiosInstance.post(url, data, { params });
    return Validate2.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      UploadBinaryRecordResponse,
      "UploadBinaryRecordResponse"
    );
  }
};

// src/generated-admin/GameBinaryRecordAdminApi.ts
import { ApiUtils as ApiUtils2, Network as Network2 } from "@accelbyte/sdk";
function GameBinaryRecordAdminApi(sdk, args) {
  const sdkAssembly = sdk.assembly();
  const namespace = args?.coreConfig?.namespace ?? sdkAssembly.coreConfig.namespace;
  const useSchemaValidation = args?.coreConfig?.useSchemaValidation ?? sdkAssembly.coreConfig.useSchemaValidation;
  let axiosInstance = sdkAssembly.axiosInstance;
  const requestConfigOverrides = args?.axiosConfig?.request;
  const baseURLOverride = args?.coreConfig?.baseURL;
  const interceptorsOverride = args?.axiosConfig?.interceptors ?? [];
  if (requestConfigOverrides || baseURLOverride || interceptorsOverride.length > 0) {
    const requestConfig = ApiUtils2.mergeAxiosConfigs(sdkAssembly.axiosInstance.defaults, {
      ...baseURLOverride ? { baseURL: baseURLOverride } : {},
      ...requestConfigOverrides
    });
    axiosInstance = Network2.create(requestConfig);
    for (const interceptor of interceptorsOverride) {
      if (interceptor.type === "request") {
        axiosInstance.interceptors.request.use(interceptor.onRequest, interceptor.onError);
      }
      if (interceptor.type === "response") {
        axiosInstance.interceptors.response.use(interceptor.onSuccess, interceptor.onError);
      }
    }
  }
  async function getBinaries(queryParams) {
    const $ = new GameBinaryRecordAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getBinaries(queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function createBinary(data) {
    const $ = new GameBinaryRecordAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.createBinary(data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function deleteBinary_ByKey(key) {
    const $ = new GameBinaryRecordAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.deleteBinary_ByKey(key);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getBinary_ByKey(key) {
    const $ = new GameBinaryRecordAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getBinary_ByKey(key);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function updateBinary_ByKey(key, data) {
    const $ = new GameBinaryRecordAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.updateBinary_ByKey(key, data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function updateMetadata_ByKey(key, data) {
    const $ = new GameBinaryRecordAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.updateMetadata_ByKey(key, data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function createPresigned_ByKey(key, data) {
    const $ = new GameBinaryRecordAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.createPresigned_ByKey(key, data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  return {
    /**
     * Retrieve list of binary records by namespace.
     */
    getBinaries,
    /**
     * Create a game binary record. Other detail info: `key` should follow these rules: 1. support uppercase and lowercase letters, numbers, and separators **&#34;-&#34;**, **&#34;_&#34;**, **&#34;.&#34;** are allowed 2. begin and end with letters or numbers 3. spaces are not allowed 4. separators must not appears twice in a row Supported file types: jpeg, jpg, png, bmp, gif, mp3, webp, and bin.
     */
    createBinary,
    /**
     * Delete a game binary record.
     */
    deleteBinary_ByKey,
    /**
     * Get a game binary record by its key.
     */
    getBinary_ByKey,
    /**
     * Update a game binary record file by its key
     */
    updateBinary_ByKey,
    /**
     * Update a game binary record metadata by its key
     */
    updateMetadata_ByKey,
    /**
     * Request presigned URL to upload the binary record to s3. Other detail info: Supported file types: jpeg, jpg, png, bmp, gif, mp3, webp, and bin.
     */
    createPresigned_ByKey
  };
}

// src/generated-definitions/GameRecordAdminResponse.ts
import { z as z10 } from "zod";
var GameRecordAdminResponse = z10.object({
  created_at: z10.string(),
  key: z10.string(),
  namespace: z10.string(),
  set_by: z10.enum(["CLIENT", "SERVER"]).nullish(),
  tags: z10.array(z10.string()).nullish(),
  ttl_config: TtlConfigDto.nullish(),
  updated_at: z10.string(),
  value: z10.record(z10.any())
});

// src/generated-definitions/ListGameRecordKeysResponse.ts
import { z as z11 } from "zod";
var ListGameRecordKeysResponse = z11.object({ data: z11.array(z11.string()), paging: Pagination });

// src/generated-admin/endpoints/GameRecordAdmin$.ts
import { Validate as Validate3 } from "@accelbyte/sdk";
import { z as z12 } from "zod";
var GameRecordAdmin$ = class {
  // @ts-ignore
  // prettier-ignore
  constructor(axiosInstance, namespace, useSchemaValidation = true) {
    this.axiosInstance = axiosInstance;
    this.namespace = namespace;
    this.useSchemaValidation = useSchemaValidation;
  }
  /**
   * Retrieve list of records key by namespace
   */
  getRecords(queryParams) {
    const params = { ...queryParams };
    const url = "/cloudsave/v1/admin/namespaces/{namespace}/records".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.get(url, { params });
    return Validate3.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      ListGameRecordKeysResponse,
      "ListGameRecordKeysResponse"
    );
  }
  /**
   * This endpoints delete game record in namespace-level
   */
  deleteRecord_ByKey(key) {
    const params = {};
    const url = "/cloudsave/v1/admin/namespaces/{namespace}/records/{key}".replace("{namespace}", this.namespace).replace("{key}", key);
    const resultPromise = this.axiosInstance.delete(url, { params });
    return Validate3.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, z12.unknown(), "z.unknown()");
  }
  /**
   * Get a record by its key in namespace-level.
   */
  getRecord_ByKey(key) {
    const params = {};
    const url = "/cloudsave/v1/admin/namespaces/{namespace}/records/{key}".replace("{namespace}", this.namespace).replace("{key}", key);
    const resultPromise = this.axiosInstance.get(url, { params });
    return Validate3.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      GameRecordAdminResponse,
      "GameRecordAdminResponse"
    );
  }
  /**
   * ## Description This endpoints will create new game record or append the existing game record. **Append example:** Example 1 - Existing JSON: `{ &#34;data1&#34;: &#34;value&#34; }` - New JSON: `{ &#34;data2&#34;: &#34;new value&#34; }` - Result: `{ &#34;data1&#34;: &#34;value&#34;, &#34;data2&#34;: &#34;new value&#34; }` Example 2 - Existing JSON: `{ &#34;data1&#34;: { &#34;data2&#34;: &#34;value&#34; }` - New JSON: `{ &#34;data1&#34;: { &#34;data3&#34;: &#34;new value&#34; }` - Result: `{ &#34;data1&#34;: { &#34;data2&#34;: &#34;value&#34;, &#34;data3&#34;: &#34;new value&#34; }` ## Restriction This is the restriction of Key Naming for the record: 1. Cannot use **&#34;.&#34;** as the key name - `{ &#34;data.2&#34;: &#34;value&#34; }` 2. Cannot use **&#34;$&#34;** as the prefix in key names - `{ &#34;$data&#34;: &#34;value&#34; }` 3. Cannot use empty string in key names - `{ &#34;&#34;: &#34;value&#34; }` ## Record Metadata Metadata allows user to define the behaviour of the record. Metadata can be defined in request body with field name **__META**. When creating record, if **__META** field is not defined, the metadata value will use the default value. When updating record, if **__META** field is not defined, the existing metadata value will stay as is. **Metadata List:** 1. set_by (default: CLIENT, type: string) Indicate which party that could modify the game record. SERVER: record can be modified by server only. CLIENT: record can be modified by client and server. 2. ttl_config (default: *empty*, type: object) Indicate the TTL configuration for the game record. action: - DELETE: record will be deleted after TTL is reached 3. tags (default: *empty array*, type: array of string) Indicate the tagging for the game record. **Request Body Example:** ``` { &#34;__META&#34;: { &#34;set_by&#34;: &#34;SERVER&#34;, &#34;ttl_config&#34;: { &#34;expires_at&#34;: &#34;2026-01-02T15:04:05Z&#34;, // should be in RFC3339 format &#34;action&#34;: &#34;DELETE&#34; }, &#34;tags&#34;: [&#34;tag1&#34;, &#34;tag2&#34;] } ... } ```
   */
  createRecord_ByKey(key, data) {
    const params = {};
    const url = "/cloudsave/v1/admin/namespaces/{namespace}/records/{key}".replace("{namespace}", this.namespace).replace("{key}", key);
    const resultPromise = this.axiosInstance.post(url, data, { params });
    return Validate3.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      GameRecordAdminResponse,
      "GameRecordAdminResponse"
    );
  }
  /**
   * ## Description This endpoints will create new game record or replace the existing game record. **Replace behaviour:** The existing value will be replaced completely with the new value. Example - Existing JSON: `{ &#34;data1&#34;: &#34;value&#34; }` - New JSON: `{ &#34;data2&#34;: &#34;new value&#34; }` - Result: `{ &#34;data2&#34;: &#34;new value&#34; }` ## Restriction This is the restriction of Key Naming for the record: 1. Cannot use **&#34;.&#34;** as the key name - `{ &#34;data.2&#34;: &#34;value&#34; }` 2. Cannot use **&#34;$&#34;** as the prefix in key names - `{ &#34;$data&#34;: &#34;value&#34; }` 3. Cannot use empty string in key names - `{ &#34;&#34;: &#34;value&#34; }` ## Record Metadata Metadata allows user to define the behaviour of the record. Metadata can be defined in request body with field name **__META**. When creating record, if **__META** field is not defined, the metadata value will use the default value. When updating record, if **__META** field is not defined, the existing metadata value will stay as is. **Metadata List:** 1. set_by (default: CLIENT, type: string) Indicate which party that could modify the game record. SERVER: record can be modified by server only. CLIENT: record can be modified by client and server. 2. ttl_config (default: *empty*, type: object) Indicate the TTL configuration for the game record. action: - DELETE: record will be deleted after TTL is reached 3. tags (default: *empty array*, type: array of string) Indicate the tagging for the game record. **Request Body Example:** ``` { &#34;__META&#34;: { &#34;set_by&#34;: &#34;SERVER&#34;, &#34;ttl_config&#34;: { &#34;expires_at&#34;: &#34;2026-01-02T15:04:05Z&#34;, // should be in RFC3339 format &#34;action&#34;: &#34;DELETE&#34; }, &#34;tags&#34;: [&#34;tag1&#34;, &#34;tag2&#34;] } ... } ```
   */
  updateRecord_ByKey(key, data) {
    const params = {};
    const url = "/cloudsave/v1/admin/namespaces/{namespace}/records/{key}".replace("{namespace}", this.namespace).replace("{key}", key);
    const resultPromise = this.axiosInstance.put(url, data, { params });
    return Validate3.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      GameRecordAdminResponse,
      "GameRecordAdminResponse"
    );
  }
};

// src/generated-admin/GameRecordAdminApi.ts
import { ApiUtils as ApiUtils3, Network as Network3 } from "@accelbyte/sdk";
function GameRecordAdminApi(sdk, args) {
  const sdkAssembly = sdk.assembly();
  const namespace = args?.coreConfig?.namespace ?? sdkAssembly.coreConfig.namespace;
  const useSchemaValidation = args?.coreConfig?.useSchemaValidation ?? sdkAssembly.coreConfig.useSchemaValidation;
  let axiosInstance = sdkAssembly.axiosInstance;
  const requestConfigOverrides = args?.axiosConfig?.request;
  const baseURLOverride = args?.coreConfig?.baseURL;
  const interceptorsOverride = args?.axiosConfig?.interceptors ?? [];
  if (requestConfigOverrides || baseURLOverride || interceptorsOverride.length > 0) {
    const requestConfig = ApiUtils3.mergeAxiosConfigs(sdkAssembly.axiosInstance.defaults, {
      ...baseURLOverride ? { baseURL: baseURLOverride } : {},
      ...requestConfigOverrides
    });
    axiosInstance = Network3.create(requestConfig);
    for (const interceptor of interceptorsOverride) {
      if (interceptor.type === "request") {
        axiosInstance.interceptors.request.use(interceptor.onRequest, interceptor.onError);
      }
      if (interceptor.type === "response") {
        axiosInstance.interceptors.response.use(interceptor.onSuccess, interceptor.onError);
      }
    }
  }
  async function getRecords(queryParams) {
    const $ = new GameRecordAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getRecords(queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function deleteRecord_ByKey(key) {
    const $ = new GameRecordAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.deleteRecord_ByKey(key);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getRecord_ByKey(key) {
    const $ = new GameRecordAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getRecord_ByKey(key);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function createRecord_ByKey(key, data) {
    const $ = new GameRecordAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.createRecord_ByKey(key, data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function updateRecord_ByKey(key, data) {
    const $ = new GameRecordAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.updateRecord_ByKey(key, data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  return {
    /**
     * Retrieve list of records key by namespace
     */
    getRecords,
    /**
     * This endpoints delete game record in namespace-level
     */
    deleteRecord_ByKey,
    /**
     * Get a record by its key in namespace-level.
     */
    getRecord_ByKey,
    /**
     * ## Description This endpoints will create new game record or append the existing game record. **Append example:** Example 1 - Existing JSON: `{ &#34;data1&#34;: &#34;value&#34; }` - New JSON: `{ &#34;data2&#34;: &#34;new value&#34; }` - Result: `{ &#34;data1&#34;: &#34;value&#34;, &#34;data2&#34;: &#34;new value&#34; }` Example 2 - Existing JSON: `{ &#34;data1&#34;: { &#34;data2&#34;: &#34;value&#34; }` - New JSON: `{ &#34;data1&#34;: { &#34;data3&#34;: &#34;new value&#34; }` - Result: `{ &#34;data1&#34;: { &#34;data2&#34;: &#34;value&#34;, &#34;data3&#34;: &#34;new value&#34; }` ## Restriction This is the restriction of Key Naming for the record: 1. Cannot use **&#34;.&#34;** as the key name - `{ &#34;data.2&#34;: &#34;value&#34; }` 2. Cannot use **&#34;$&#34;** as the prefix in key names - `{ &#34;$data&#34;: &#34;value&#34; }` 3. Cannot use empty string in key names - `{ &#34;&#34;: &#34;value&#34; }` ## Record Metadata Metadata allows user to define the behaviour of the record. Metadata can be defined in request body with field name **__META**. When creating record, if **__META** field is not defined, the metadata value will use the default value. When updating record, if **__META** field is not defined, the existing metadata value will stay as is. **Metadata List:** 1. set_by (default: CLIENT, type: string) Indicate which party that could modify the game record. SERVER: record can be modified by server only. CLIENT: record can be modified by client and server. 2. ttl_config (default: *empty*, type: object) Indicate the TTL configuration for the game record. action: - DELETE: record will be deleted after TTL is reached 3. tags (default: *empty array*, type: array of string) Indicate the tagging for the game record. **Request Body Example:** ``` { &#34;__META&#34;: { &#34;set_by&#34;: &#34;SERVER&#34;, &#34;ttl_config&#34;: { &#34;expires_at&#34;: &#34;2026-01-02T15:04:05Z&#34;, // should be in RFC3339 format &#34;action&#34;: &#34;DELETE&#34; }, &#34;tags&#34;: [&#34;tag1&#34;, &#34;tag2&#34;] } ... } ```
     */
    createRecord_ByKey,
    /**
     * ## Description This endpoints will create new game record or replace the existing game record. **Replace behaviour:** The existing value will be replaced completely with the new value. Example - Existing JSON: `{ &#34;data1&#34;: &#34;value&#34; }` - New JSON: `{ &#34;data2&#34;: &#34;new value&#34; }` - Result: `{ &#34;data2&#34;: &#34;new value&#34; }` ## Restriction This is the restriction of Key Naming for the record: 1. Cannot use **&#34;.&#34;** as the key name - `{ &#34;data.2&#34;: &#34;value&#34; }` 2. Cannot use **&#34;$&#34;** as the prefix in key names - `{ &#34;$data&#34;: &#34;value&#34; }` 3. Cannot use empty string in key names - `{ &#34;&#34;: &#34;value&#34; }` ## Record Metadata Metadata allows user to define the behaviour of the record. Metadata can be defined in request body with field name **__META**. When creating record, if **__META** field is not defined, the metadata value will use the default value. When updating record, if **__META** field is not defined, the existing metadata value will stay as is. **Metadata List:** 1. set_by (default: CLIENT, type: string) Indicate which party that could modify the game record. SERVER: record can be modified by server only. CLIENT: record can be modified by client and server. 2. ttl_config (default: *empty*, type: object) Indicate the TTL configuration for the game record. action: - DELETE: record will be deleted after TTL is reached 3. tags (default: *empty array*, type: array of string) Indicate the tagging for the game record. **Request Body Example:** ``` { &#34;__META&#34;: { &#34;set_by&#34;: &#34;SERVER&#34;, &#34;ttl_config&#34;: { &#34;expires_at&#34;: &#34;2026-01-02T15:04:05Z&#34;, // should be in RFC3339 format &#34;action&#34;: &#34;DELETE&#34; }, &#34;tags&#34;: [&#34;tag1&#34;, &#34;tag2&#34;] } ... } ```
     */
    updateRecord_ByKey
  };
}

// src/generated-definitions/PlayerBinaryRecordResponse.ts
import { z as z13 } from "zod";
var PlayerBinaryRecordResponse = z13.object({
  binary_info: BinaryInfoResponse.nullish(),
  created_at: z13.string(),
  is_public: z13.boolean(),
  key: z13.string(),
  namespace: z13.string(),
  set_by: z13.enum(["CLIENT", "SERVER"]).nullish(),
  tags: z13.array(z13.string()).nullish(),
  updated_at: z13.string(),
  user_id: z13.string()
});

// src/generated-definitions/ListPlayerBinaryRecordsResponse.ts
import { z as z14 } from "zod";
var ListPlayerBinaryRecordsResponse = z14.object({ data: z14.array(PlayerBinaryRecordResponse), paging: Pagination });

// src/generated-admin/endpoints/PlayerBinaryRecordAdmin$.ts
import { Validate as Validate4 } from "@accelbyte/sdk";
import { z as z15 } from "zod";
var PlayerBinaryRecordAdmin$ = class {
  // @ts-ignore
  // prettier-ignore
  constructor(axiosInstance, namespace, useSchemaValidation = true) {
    this.axiosInstance = axiosInstance;
    this.namespace = namespace;
    this.useSchemaValidation = useSchemaValidation;
  }
  /**
   * Retrieve list of player binary records by namespace.
   */
  getBinaries_ByUserId(userId, queryParams) {
    const params = { limit: 25, ...queryParams };
    const url = "/cloudsave/v1/admin/namespaces/{namespace}/users/{userId}/binaries".replace("{namespace}", this.namespace).replace("{userId}", userId);
    const resultPromise = this.axiosInstance.get(url, { params });
    return Validate4.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      ListPlayerBinaryRecordsResponse,
      "ListPlayerBinaryRecordsResponse"
    );
  }
  /**
   * Create a player binary record. Other detail info: `key` should follow these rules: 1. support uppercase and lowercase letters, numbers, and separators **&#34;-&#34;**, **&#34;_&#34;**, **&#34;.&#34;** are allowed 2. begin and end with letters or numbers 3. spaces are not allowed 4. separators must not appears twice in a row Supported file types: jpeg, jpg, png, bmp, gif, mp3, webp, and bin.
   */
  createBinary_ByUserId(userId, data) {
    const params = {};
    const url = "/cloudsave/v1/admin/namespaces/{namespace}/users/{userId}/binaries".replace("{namespace}", this.namespace).replace("{userId}", userId);
    const resultPromise = this.axiosInstance.post(url, data, { params });
    return Validate4.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      UploadBinaryRecordResponse,
      "UploadBinaryRecordResponse"
    );
  }
  /**
   * Delete a player binary record.
   */
  deleteBinary_ByUserId_ByKey(userId, key) {
    const params = {};
    const url = "/cloudsave/v1/admin/namespaces/{namespace}/users/{userId}/binaries/{key}".replace("{namespace}", this.namespace).replace("{userId}", userId).replace("{key}", key);
    const resultPromise = this.axiosInstance.delete(url, { params });
    return Validate4.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, z15.unknown(), "z.unknown()");
  }
  /**
   * Get a player binary record by its key.
   */
  getBinary_ByUserId_ByKey(userId, key) {
    const params = {};
    const url = "/cloudsave/v1/admin/namespaces/{namespace}/users/{userId}/binaries/{key}".replace("{namespace}", this.namespace).replace("{userId}", userId).replace("{key}", key);
    const resultPromise = this.axiosInstance.get(url, { params });
    return Validate4.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      PlayerBinaryRecordResponse,
      "PlayerBinaryRecordResponse"
    );
  }
  /**
   * Update a player binary record file by its key
   */
  updateBinary_ByUserId_ByKey(userId, key, data) {
    const params = {};
    const url = "/cloudsave/v1/admin/namespaces/{namespace}/users/{userId}/binaries/{key}".replace("{namespace}", this.namespace).replace("{userId}", userId).replace("{key}", key);
    const resultPromise = this.axiosInstance.put(url, data, { params });
    return Validate4.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      PlayerBinaryRecordResponse,
      "PlayerBinaryRecordResponse"
    );
  }
  /**
   * Update a player binary record metadata by its key
   */
  updateMetadata_ByUserId_ByKey(userId, key, data) {
    const params = {};
    const url = "/cloudsave/v1/admin/namespaces/{namespace}/users/{userId}/binaries/{key}/metadata".replace("{namespace}", this.namespace).replace("{userId}", userId).replace("{key}", key);
    const resultPromise = this.axiosInstance.put(url, data, { params });
    return Validate4.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      PlayerBinaryRecordResponse,
      "PlayerBinaryRecordResponse"
    );
  }
  /**
   * Request presigned URL to upload the binary record to s3. Other detail info: Supported file types: jpeg, jpg, png, bmp, gif, mp3, webp, and bin.
   */
  createPresigned_ByUserId_ByKey(userId, key, data) {
    const params = {};
    const url = "/cloudsave/v1/admin/namespaces/{namespace}/users/{userId}/binaries/{key}/presigned".replace("{namespace}", this.namespace).replace("{userId}", userId).replace("{key}", key);
    const resultPromise = this.axiosInstance.post(url, data, { params });
    return Validate4.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      UploadBinaryRecordResponse,
      "UploadBinaryRecordResponse"
    );
  }
};

// src/generated-admin/PlayerBinaryRecordAdminApi.ts
import { ApiUtils as ApiUtils4, Network as Network4 } from "@accelbyte/sdk";
function PlayerBinaryRecordAdminApi(sdk, args) {
  const sdkAssembly = sdk.assembly();
  const namespace = args?.coreConfig?.namespace ?? sdkAssembly.coreConfig.namespace;
  const useSchemaValidation = args?.coreConfig?.useSchemaValidation ?? sdkAssembly.coreConfig.useSchemaValidation;
  let axiosInstance = sdkAssembly.axiosInstance;
  const requestConfigOverrides = args?.axiosConfig?.request;
  const baseURLOverride = args?.coreConfig?.baseURL;
  const interceptorsOverride = args?.axiosConfig?.interceptors ?? [];
  if (requestConfigOverrides || baseURLOverride || interceptorsOverride.length > 0) {
    const requestConfig = ApiUtils4.mergeAxiosConfigs(sdkAssembly.axiosInstance.defaults, {
      ...baseURLOverride ? { baseURL: baseURLOverride } : {},
      ...requestConfigOverrides
    });
    axiosInstance = Network4.create(requestConfig);
    for (const interceptor of interceptorsOverride) {
      if (interceptor.type === "request") {
        axiosInstance.interceptors.request.use(interceptor.onRequest, interceptor.onError);
      }
      if (interceptor.type === "response") {
        axiosInstance.interceptors.response.use(interceptor.onSuccess, interceptor.onError);
      }
    }
  }
  async function getBinaries_ByUserId(userId, queryParams) {
    const $ = new PlayerBinaryRecordAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getBinaries_ByUserId(userId, queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function createBinary_ByUserId(userId, data) {
    const $ = new PlayerBinaryRecordAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.createBinary_ByUserId(userId, data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function deleteBinary_ByUserId_ByKey(userId, key) {
    const $ = new PlayerBinaryRecordAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.deleteBinary_ByUserId_ByKey(userId, key);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getBinary_ByUserId_ByKey(userId, key) {
    const $ = new PlayerBinaryRecordAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getBinary_ByUserId_ByKey(userId, key);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function updateBinary_ByUserId_ByKey(userId, key, data) {
    const $ = new PlayerBinaryRecordAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.updateBinary_ByUserId_ByKey(userId, key, data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function updateMetadata_ByUserId_ByKey(userId, key, data) {
    const $ = new PlayerBinaryRecordAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.updateMetadata_ByUserId_ByKey(userId, key, data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function createPresigned_ByUserId_ByKey(userId, key, data) {
    const $ = new PlayerBinaryRecordAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.createPresigned_ByUserId_ByKey(userId, key, data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  return {
    /**
     * Retrieve list of player binary records by namespace.
     */
    getBinaries_ByUserId,
    /**
     * Create a player binary record. Other detail info: `key` should follow these rules: 1. support uppercase and lowercase letters, numbers, and separators **&#34;-&#34;**, **&#34;_&#34;**, **&#34;.&#34;** are allowed 2. begin and end with letters or numbers 3. spaces are not allowed 4. separators must not appears twice in a row Supported file types: jpeg, jpg, png, bmp, gif, mp3, webp, and bin.
     */
    createBinary_ByUserId,
    /**
     * Delete a player binary record.
     */
    deleteBinary_ByUserId_ByKey,
    /**
     * Get a player binary record by its key.
     */
    getBinary_ByUserId_ByKey,
    /**
     * Update a player binary record file by its key
     */
    updateBinary_ByUserId_ByKey,
    /**
     * Update a player binary record metadata by its key
     */
    updateMetadata_ByUserId_ByKey,
    /**
     * Request presigned URL to upload the binary record to s3. Other detail info: Supported file types: jpeg, jpg, png, bmp, gif, mp3, webp, and bin.
     */
    createPresigned_ByUserId_ByKey
  };
}

// src/generated-definitions/AdminPlayerRecordResponse.ts
import { z as z16 } from "zod";
var AdminPlayerRecordResponse = z16.object({
  created_at: z16.string(),
  key: z16.string(),
  namespace: z16.string(),
  tags: z16.array(z16.string()).nullish(),
  updated_at: z16.string(),
  user_id: z16.string(),
  value: z16.record(z16.any())
});

// src/generated-definitions/BulkGetAdminPlayerRecordResponse.ts
import { z as z17 } from "zod";
var BulkGetAdminPlayerRecordResponse = z17.object({ data: z17.array(AdminPlayerRecordResponse) });

// src/generated-definitions/PlayerRecordResponse.ts
import { z as z18 } from "zod";
var PlayerRecordResponse = z18.object({
  created_at: z18.string(),
  is_public: z18.boolean(),
  key: z18.string(),
  namespace: z18.string(),
  set_by: z18.enum(["CLIENT", "SERVER"]).nullish(),
  tags: z18.array(z18.string()).nullish(),
  updated_at: z18.string(),
  user_id: z18.string(),
  value: z18.record(z18.any())
});

// src/generated-definitions/BulkGetPlayerRecordResponse.ts
import { z as z19 } from "zod";
var BulkGetPlayerRecordResponse = z19.object({ data: z19.array(PlayerRecordResponse) });

// src/generated-definitions/PlayerRecordSizeResponse.ts
import { z as z20 } from "zod";
var PlayerRecordSizeResponse = z20.object({
  current_size: z20.number().int(),
  key: z20.string(),
  namespace: z20.string(),
  remaining_size: z20.number().int(),
  user_id: z20.string()
});

// src/generated-definitions/BulkGetPlayerRecordSizeResponse.ts
import { z as z21 } from "zod";
var BulkGetPlayerRecordSizeResponse = z21.object({ data: z21.array(PlayerRecordSizeResponse) });

// src/generated-definitions/BulkUpdatePlayerRecordByKeyResponse.ts
import { z as z22 } from "zod";
var BulkUpdatePlayerRecordByKeyResponse = z22.object({ detail: z22.record(z22.any()), success: z22.boolean(), user_id: z22.string() });

// src/generated-definitions/BulkUpdatePlayerRecordByKeyResponseArray.ts
import { z as z23 } from "zod";
var BulkUpdatePlayerRecordByKeyResponseArray = z23.array(BulkUpdatePlayerRecordByKeyResponse);

// src/generated-definitions/BulkUpdatePlayerRecordResponse.ts
import { z as z24 } from "zod";
var BulkUpdatePlayerRecordResponse = z24.object({ detail: z24.record(z24.any()), key: z24.string(), success: z24.boolean() });

// src/generated-definitions/BulkUpdatePlayerRecordResponseArray.ts
import { z as z25 } from "zod";
var BulkUpdatePlayerRecordResponseArray = z25.array(BulkUpdatePlayerRecordResponse);

// src/generated-definitions/PlayerRecordKeyInfo.ts
import { z as z26 } from "zod";
var PlayerRecordKeyInfo = z26.object({ key: z26.string(), user_id: z26.string() });

// src/generated-definitions/ListPlayerRecordKeysResponse.ts
import { z as z27 } from "zod";
var ListPlayerRecordKeysResponse = z27.object({ data: z27.array(PlayerRecordKeyInfo), paging: Pagination });

// src/generated-admin/endpoints/PlayerRecordAdmin$.ts
import { Validate as Validate5 } from "@accelbyte/sdk";
import { z as z28 } from "zod";
var PlayerRecordAdmin$ = class {
  // @ts-ignore
  // prettier-ignore
  constructor(axiosInstance, namespace, useSchemaValidation = true) {
    this.axiosInstance = axiosInstance;
    this.namespace = namespace;
    this.useSchemaValidation = useSchemaValidation;
  }
  /**
   * @deprecated
   * Retrieve list of player records key and userID under given namespace.
   */
  getUsersRecords(queryParams) {
    const params = { limit: 25, ...queryParams };
    const url = "/cloudsave/v1/admin/namespaces/{namespace}/users/records".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.get(url, { params });
    return Validate5.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      ListPlayerRecordKeysResponse,
      "ListPlayerRecordKeysResponse"
    );
  }
  /**
   * Retrieve list of player records key and userID under given namespace.
   */
  getRecords_ByUserId(userId, queryParams) {
    const params = { limit: 25, ...queryParams };
    const url = "/cloudsave/v1/admin/namespaces/{namespace}/users/{userId}/records".replace("{namespace}", this.namespace).replace("{userId}", userId);
    const resultPromise = this.axiosInstance.get(url, { params });
    return Validate5.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      ListPlayerRecordKeysResponse,
      "ListPlayerRecordKeysResponse"
    );
  }
  /**
   * Bulk get player&#39;s record size, max allowed 20 at a time, that can be retrieved using this endpoint.
   */
  fetchUserBulkRecordSize(data) {
    const params = {};
    const url = "/cloudsave/v1/admin/namespaces/{namespace}/users/bulk/records/size".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.post(url, data, { params });
    return Validate5.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      BulkGetPlayerRecordSizeResponse,
      "BulkGetPlayerRecordSizeResponse"
    );
  }
  /**
   * Retrieve player record key and payload in bulk under given namespace. Maximum number of user ids per request is 20.
   */
  fetchBulkUser_ByKey(key, data) {
    const params = {};
    const url = "/cloudsave/v1/admin/namespaces/{namespace}/users/records/{key}/bulk".replace("{namespace}", this.namespace).replace("{key}", key);
    const resultPromise = this.axiosInstance.post(url, data, { params });
    return Validate5.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      BulkGetPlayerRecordResponse,
      "BulkGetPlayerRecordResponse"
    );
  }
  /**
   * This endpoints will create new player record or replace the existing player record in bulk. Maximum number of user ids per request is 10. Maximum total size of the request payload is 5 MB.
   */
  updateBulkUser_ByKey(key, data) {
    const params = {};
    const url = "/cloudsave/v1/admin/namespaces/{namespace}/users/records/{key}/bulk".replace("{namespace}", this.namespace).replace("{key}", key);
    const resultPromise = this.axiosInstance.put(url, data, { params });
    return Validate5.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      BulkUpdatePlayerRecordByKeyResponseArray,
      "BulkUpdatePlayerRecordByKeyResponseArray"
    );
  }
  /**
   * Retrieve player record key and payload in bulk under given namespace. Maximum bulk key limit per request 20.
   */
  fetchRecordBulk_ByUserId(userId, data) {
    const params = {};
    const url = "/cloudsave/v1/admin/namespaces/{namespace}/users/{userId}/records/bulk".replace("{namespace}", this.namespace).replace("{userId}", userId);
    const resultPromise = this.axiosInstance.post(url, data, { params });
    return Validate5.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      BulkGetAdminPlayerRecordResponse,
      "BulkGetAdminPlayerRecordResponse"
    );
  }
  /**
   * This endpoints will create new player record or replace the existing player record in bulk. Maximum bulk key limit per request 10.
   */
  updateRecordBulk_ByUserId(userId, data) {
    const params = {};
    const url = "/cloudsave/v1/admin/namespaces/{namespace}/users/{userId}/records/bulk".replace("{namespace}", this.namespace).replace("{userId}", userId);
    const resultPromise = this.axiosInstance.put(url, data, { params });
    return Validate5.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      BulkUpdatePlayerRecordResponseArray,
      "BulkUpdatePlayerRecordResponseArray"
    );
  }
  /**
   * Delete a record (arbitrary JSON data) in user-level with given key.
   */
  deleteRecord_ByUserId_ByKey(userId, key) {
    const params = {};
    const url = "/cloudsave/v1/admin/namespaces/{namespace}/users/{userId}/records/{key}".replace("{namespace}", this.namespace).replace("{userId}", userId).replace("{key}", key);
    const resultPromise = this.axiosInstance.delete(url, { params });
    return Validate5.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, z28.unknown(), "z.unknown()");
  }
  /**
   * Get a record in user-level (arbitrary JSON data) by its key.
   */
  getRecord_ByUserId_ByKey(userId, key) {
    const params = {};
    const url = "/cloudsave/v1/admin/namespaces/{namespace}/users/{userId}/records/{key}".replace("{namespace}", this.namespace).replace("{userId}", userId).replace("{key}", key);
    const resultPromise = this.axiosInstance.get(url, { params });
    return Validate5.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, PlayerRecordResponse, "PlayerRecordResponse");
  }
  /**
   * ## Description This endpoints will create new player record or append the existing player record. **Append example:** Example 1 - Existing JSON: `{ &#34;data1&#34;: &#34;value&#34; }` - New JSON: `{ &#34;data2&#34;: &#34;new value&#34; }` - Result: `{ &#34;data1&#34;: &#34;value&#34;, &#34;data2&#34;: &#34;new value&#34; }` Example 2 - Existing JSON: `{ &#34;data1&#34;: { &#34;data2&#34;: &#34;value&#34; }` - New JSON: `{ &#34;data1&#34;: { &#34;data3&#34;: &#34;new value&#34; }` - Result: `{ &#34;data1&#34;: { &#34;data2&#34;: &#34;value&#34;, &#34;data3&#34;: &#34;new value&#34; }` ## Restriction This is the restriction of Key Naming for the record: 1. Cannot use **&#34;.&#34;** as the key name - `{ &#34;data.2&#34;: &#34;value&#34; }` 2. Cannot use **&#34;$&#34;** as the prefix in key names - `{ &#34;$data&#34;: &#34;value&#34; }` 3. Cannot use empty string in key names - `{ &#34;&#34;: &#34;value&#34; }` ## Record Metadata Metadata allows user to define the behaviour of the record. Metadata can be defined in request body with field name **__META**. When creating record, if **__META** field is not defined, the metadata value will use the default value. When updating record, if **__META** field is not defined, the existing metadata value will stay as is. **Metadata List:** 1. set_by (default: CLIENT, type: string) Indicate which party that could modify the game record. SERVER: record can be modified by server only. CLIENT: record can be modified by client and server. 2. is_public (default: false, type: bool) Indicate whether the player record is a public record or not. 3. tags (default: *empty array*, type: array of string) Indicate the tagging for the game record. **Request Body Example:** ``` { &#34;__META&#34;: { &#34;set_by&#34;: &#34;SERVER&#34;, &#34;is_public&#34;: true, &#34;tags&#34;: [&#34;tag1&#34;, &#34;tag2&#34;] } ... } ```
   */
  createRecord_ByUserId_ByKey(userId, key, data) {
    const params = {};
    const url = "/cloudsave/v1/admin/namespaces/{namespace}/users/{userId}/records/{key}".replace("{namespace}", this.namespace).replace("{userId}", userId).replace("{key}", key);
    const resultPromise = this.axiosInstance.post(url, data, { params });
    return Validate5.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, PlayerRecordResponse, "PlayerRecordResponse");
  }
  /**
   * ## Description This endpoints will create new player record or replace the existing player record. **Replace behaviour:** The existing value will be replaced completely with the new value. Example - Existing JSON: `{ &#34;data1&#34;: &#34;value&#34; }` - New JSON: `{ &#34;data2&#34;: &#34;new value&#34; }` - Result: `{ &#34;data2&#34;: &#34;new value&#34; }` ## Restriction This is the restriction of Key Naming for the record: 1. Cannot use **&#34;.&#34;** as the key name - `{ &#34;data.2&#34;: &#34;value&#34; }` 2. Cannot use **&#34;$&#34;** as the prefix in key names - `{ &#34;$data&#34;: &#34;value&#34; }` 3. Cannot use empty string in key names - `{ &#34;&#34;: &#34;value&#34; }` ## Record Metadata Metadata allows user to define the behaviour of the record. Metadata can be defined in request body with field name **__META**. When creating record, if **__META** field is not defined, the metadata value will use the default value. When updating record, if **__META** field is not defined, the existing metadata value will stay as is. **Metadata List:** 1. set_by (default: CLIENT, type: string) Indicate which party that could modify the game record. SERVER: record can be modified by server only. CLIENT: record can be modified by client and server. 2. is_public (default: false, type: bool) Indicate whether the player record is a public record or not. 3. tags (default: *empty array*, type: array of string) Indicate the tagging for the game record. **Request Body Example:** ``` { &#34;__META&#34;: { &#34;set_by&#34;: &#34;SERVER&#34;, &#34;is_public&#34;: true, &#34;tags&#34;: [&#34;tag1&#34;, &#34;tag2&#34;] } ... } ```
   */
  updateRecord_ByUserId_ByKey(userId, key, data) {
    const params = {};
    const url = "/cloudsave/v1/admin/namespaces/{namespace}/users/{userId}/records/{key}".replace("{namespace}", this.namespace).replace("{userId}", userId).replace("{key}", key);
    const resultPromise = this.axiosInstance.put(url, data, { params });
    return Validate5.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, PlayerRecordResponse, "PlayerRecordResponse");
  }
  /**
   * Get a size of the player record
   */
  getSize_ByUserId_ByKey(userId, key) {
    const params = {};
    const url = "/cloudsave/v1/admin/namespaces/{namespace}/users/{userId}/records/{key}/size".replace("{namespace}", this.namespace).replace("{userId}", userId).replace("{key}", key);
    const resultPromise = this.axiosInstance.get(url, { params });
    return Validate5.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      PlayerRecordSizeResponse,
      "PlayerRecordSizeResponse"
    );
  }
  /**
   * Delete player public record. ## Warning: This endpoint is going to deprecate This endpoint is going to deprecate in the future please don&#39;t use it. For alternative, please use these endpoints: - **POST /cloudsave/v1/admin/namespaces/{namespace}/users/{userId}/records/{key}** and utilizing **__META** functionality - **PUT /cloudsave/v1/admin/namespaces/{namespace}/users/{userId}/records/{key}** and utilizing **__META** functionality - **DELETE /cloudsave/v1/admin/namespaces/{namespace}/users/{userId}/records/{key}**
   */
  deletePublic_ByUserId_ByKey(userId, key) {
    const params = {};
    const url = "/cloudsave/v1/admin/namespaces/{namespace}/users/{userId}/records/{key}/public".replace("{namespace}", this.namespace).replace("{userId}", userId).replace("{key}", key);
    const resultPromise = this.axiosInstance.delete(url, { params });
    return Validate5.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, z28.unknown(), "z.unknown()");
  }
  /**
   * Get a record in user-level (arbitrary JSON data) by its key.
   */
  getPublic_ByUserId_ByKey(userId, key) {
    const params = {};
    const url = "/cloudsave/v1/admin/namespaces/{namespace}/users/{userId}/records/{key}/public".replace("{namespace}", this.namespace).replace("{userId}", userId).replace("{key}", key);
    const resultPromise = this.axiosInstance.get(url, { params });
    return Validate5.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, PlayerRecordResponse, "PlayerRecordResponse");
  }
  /**
   * ## Description This endpoints will create new player public record or append the existing player public record. **Append example:** Example 1 - Existing JSON: `{ &#34;data1&#34;: &#34;value&#34; }` - New JSON: `{ &#34;data2&#34;: &#34;new value&#34; }` - Result: `{ &#34;data1&#34;: &#34;value&#34;, &#34;data2&#34;: &#34;new value&#34; }` Example 2 - Existing JSON: `{ &#34;data1&#34;: { &#34;data2&#34;: &#34;value&#34; }` - New JSON: `{ &#34;data1&#34;: { &#34;data3&#34;: &#34;new value&#34; }` - Result: `{ &#34;data1&#34;: { &#34;data2&#34;: &#34;value&#34;, &#34;data3&#34;: &#34;new value&#34; }` ## Restriction This is the restriction of Key Naming for the record: 1. Cannot use **&#34;.&#34;** as the key name - `{ &#34;data.2&#34;: &#34;value&#34; }` 2. Cannot use **&#34;$&#34;** as the prefix in key names - `{ &#34;$data&#34;: &#34;value&#34; }` 3. Cannot use empty string in key names - `{ &#34;&#34;: &#34;value&#34; }` ## Warning: This endpoint is going to deprecate This endpoint is going to deprecate in the future please don&#39;t use it. For alternative, please use these endpoints: - **POST /cloudsave/v1/admin/namespaces/{namespace}/users/{userId}/records/{key}** and utilizing **__META** functionality - **PUT /cloudsave/v1/admin/namespaces/{namespace}/users/{userId}/records/{key}** and utilizing **__META** functionality - **DELETE /cloudsave/v1/admin/namespaces/{namespace}/users/{userId}/records/{key}**
   */
  createPublic_ByUserId_ByKey(userId, key, data) {
    const params = {};
    const url = "/cloudsave/v1/admin/namespaces/{namespace}/users/{userId}/records/{key}/public".replace("{namespace}", this.namespace).replace("{userId}", userId).replace("{key}", key);
    const resultPromise = this.axiosInstance.post(url, data, { params });
    return Validate5.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, PlayerRecordResponse, "PlayerRecordResponse");
  }
  /**
   * ## Description This endpoints will create new player public record or replace the existing player public record. **Replace behaviour:** The existing value will be replaced completely with the new value. Example - Existing JSON: `{ &#34;data1&#34;: &#34;value&#34; }` - New JSON: `{ &#34;data2&#34;: &#34;new value&#34; }` - Result: `{ &#34;data2&#34;: &#34;new value&#34; }` ## Restriction This is the restriction of Key Naming for the record: 1. Cannot use **&#34;.&#34;** as the key name - `{ &#34;data.2&#34;: &#34;value&#34; }` 2. Cannot use **&#34;$&#34;** as the prefix in key names - `{ &#34;$data&#34;: &#34;value&#34; }` 3. Cannot use empty string in key names - `{ &#34;&#34;: &#34;value&#34; }` ## Warning: This endpoint is going to deprecate This endpoint is going to deprecate in the future please don&#39;t use it. For alternative, please use these endpoints: - **POST /cloudsave/v1/admin/namespaces/{namespace}/users/{userId}/records/{key}** and utilizing **__META** functionality - **PUT /cloudsave/v1/admin/namespaces/{namespace}/users/{userId}/records/{key}** and utilizing **__META** functionality - **DELETE /cloudsave/v1/admin/namespaces/{namespace}/users/{userId}/records/{key}**
   */
  updatePublic_ByUserId_ByKey(userId, key, data) {
    const params = {};
    const url = "/cloudsave/v1/admin/namespaces/{namespace}/users/{userId}/records/{key}/public".replace("{namespace}", this.namespace).replace("{userId}", userId).replace("{key}", key);
    const resultPromise = this.axiosInstance.put(url, data, { params });
    return Validate5.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, PlayerRecordResponse, "PlayerRecordResponse");
  }
};

// src/generated-admin/PlayerRecordAdminApi.ts
import { ApiUtils as ApiUtils5, Network as Network5 } from "@accelbyte/sdk";
function PlayerRecordAdminApi(sdk, args) {
  const sdkAssembly = sdk.assembly();
  const namespace = args?.coreConfig?.namespace ?? sdkAssembly.coreConfig.namespace;
  const useSchemaValidation = args?.coreConfig?.useSchemaValidation ?? sdkAssembly.coreConfig.useSchemaValidation;
  let axiosInstance = sdkAssembly.axiosInstance;
  const requestConfigOverrides = args?.axiosConfig?.request;
  const baseURLOverride = args?.coreConfig?.baseURL;
  const interceptorsOverride = args?.axiosConfig?.interceptors ?? [];
  if (requestConfigOverrides || baseURLOverride || interceptorsOverride.length > 0) {
    const requestConfig = ApiUtils5.mergeAxiosConfigs(sdkAssembly.axiosInstance.defaults, {
      ...baseURLOverride ? { baseURL: baseURLOverride } : {},
      ...requestConfigOverrides
    });
    axiosInstance = Network5.create(requestConfig);
    for (const interceptor of interceptorsOverride) {
      if (interceptor.type === "request") {
        axiosInstance.interceptors.request.use(interceptor.onRequest, interceptor.onError);
      }
      if (interceptor.type === "response") {
        axiosInstance.interceptors.response.use(interceptor.onSuccess, interceptor.onError);
      }
    }
  }
  async function getUsersRecords(queryParams) {
    const $ = new PlayerRecordAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getUsersRecords(queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getRecords_ByUserId(userId, queryParams) {
    const $ = new PlayerRecordAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getRecords_ByUserId(userId, queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function fetchUserBulkRecordSize(data) {
    const $ = new PlayerRecordAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.fetchUserBulkRecordSize(data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function fetchBulkUser_ByKey(key, data) {
    const $ = new PlayerRecordAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.fetchBulkUser_ByKey(key, data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function updateBulkUser_ByKey(key, data) {
    const $ = new PlayerRecordAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.updateBulkUser_ByKey(key, data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function fetchRecordBulk_ByUserId(userId, data) {
    const $ = new PlayerRecordAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.fetchRecordBulk_ByUserId(userId, data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function updateRecordBulk_ByUserId(userId, data) {
    const $ = new PlayerRecordAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.updateRecordBulk_ByUserId(userId, data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function deleteRecord_ByUserId_ByKey(userId, key) {
    const $ = new PlayerRecordAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.deleteRecord_ByUserId_ByKey(userId, key);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getRecord_ByUserId_ByKey(userId, key) {
    const $ = new PlayerRecordAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getRecord_ByUserId_ByKey(userId, key);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function createRecord_ByUserId_ByKey(userId, key, data) {
    const $ = new PlayerRecordAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.createRecord_ByUserId_ByKey(userId, key, data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function updateRecord_ByUserId_ByKey(userId, key, data) {
    const $ = new PlayerRecordAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.updateRecord_ByUserId_ByKey(userId, key, data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getSize_ByUserId_ByKey(userId, key) {
    const $ = new PlayerRecordAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getSize_ByUserId_ByKey(userId, key);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function deletePublic_ByUserId_ByKey(userId, key) {
    const $ = new PlayerRecordAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.deletePublic_ByUserId_ByKey(userId, key);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getPublic_ByUserId_ByKey(userId, key) {
    const $ = new PlayerRecordAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getPublic_ByUserId_ByKey(userId, key);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function createPublic_ByUserId_ByKey(userId, key, data) {
    const $ = new PlayerRecordAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.createPublic_ByUserId_ByKey(userId, key, data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function updatePublic_ByUserId_ByKey(userId, key, data) {
    const $ = new PlayerRecordAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.updatePublic_ByUserId_ByKey(userId, key, data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  return {
    /**
     * @deprecated
     * Retrieve list of player records key and userID under given namespace.
     */
    getUsersRecords,
    /**
     * Retrieve list of player records key and userID under given namespace.
     */
    getRecords_ByUserId,
    /**
     * Bulk get player&#39;s record size, max allowed 20 at a time, that can be retrieved using this endpoint.
     */
    fetchUserBulkRecordSize,
    /**
     * Retrieve player record key and payload in bulk under given namespace. Maximum number of user ids per request is 20.
     */
    fetchBulkUser_ByKey,
    /**
     * This endpoints will create new player record or replace the existing player record in bulk. Maximum number of user ids per request is 10. Maximum total size of the request payload is 5 MB.
     */
    updateBulkUser_ByKey,
    /**
     * Retrieve player record key and payload in bulk under given namespace. Maximum bulk key limit per request 20.
     */
    fetchRecordBulk_ByUserId,
    /**
     * This endpoints will create new player record or replace the existing player record in bulk. Maximum bulk key limit per request 10.
     */
    updateRecordBulk_ByUserId,
    /**
     * Delete a record (arbitrary JSON data) in user-level with given key.
     */
    deleteRecord_ByUserId_ByKey,
    /**
     * Get a record in user-level (arbitrary JSON data) by its key.
     */
    getRecord_ByUserId_ByKey,
    /**
     * ## Description This endpoints will create new player record or append the existing player record. **Append example:** Example 1 - Existing JSON: `{ &#34;data1&#34;: &#34;value&#34; }` - New JSON: `{ &#34;data2&#34;: &#34;new value&#34; }` - Result: `{ &#34;data1&#34;: &#34;value&#34;, &#34;data2&#34;: &#34;new value&#34; }` Example 2 - Existing JSON: `{ &#34;data1&#34;: { &#34;data2&#34;: &#34;value&#34; }` - New JSON: `{ &#34;data1&#34;: { &#34;data3&#34;: &#34;new value&#34; }` - Result: `{ &#34;data1&#34;: { &#34;data2&#34;: &#34;value&#34;, &#34;data3&#34;: &#34;new value&#34; }` ## Restriction This is the restriction of Key Naming for the record: 1. Cannot use **&#34;.&#34;** as the key name - `{ &#34;data.2&#34;: &#34;value&#34; }` 2. Cannot use **&#34;$&#34;** as the prefix in key names - `{ &#34;$data&#34;: &#34;value&#34; }` 3. Cannot use empty string in key names - `{ &#34;&#34;: &#34;value&#34; }` ## Record Metadata Metadata allows user to define the behaviour of the record. Metadata can be defined in request body with field name **__META**. When creating record, if **__META** field is not defined, the metadata value will use the default value. When updating record, if **__META** field is not defined, the existing metadata value will stay as is. **Metadata List:** 1. set_by (default: CLIENT, type: string) Indicate which party that could modify the game record. SERVER: record can be modified by server only. CLIENT: record can be modified by client and server. 2. is_public (default: false, type: bool) Indicate whether the player record is a public record or not. 3. tags (default: *empty array*, type: array of string) Indicate the tagging for the game record. **Request Body Example:** ``` { &#34;__META&#34;: { &#34;set_by&#34;: &#34;SERVER&#34;, &#34;is_public&#34;: true, &#34;tags&#34;: [&#34;tag1&#34;, &#34;tag2&#34;] } ... } ```
     */
    createRecord_ByUserId_ByKey,
    /**
     * ## Description This endpoints will create new player record or replace the existing player record. **Replace behaviour:** The existing value will be replaced completely with the new value. Example - Existing JSON: `{ &#34;data1&#34;: &#34;value&#34; }` - New JSON: `{ &#34;data2&#34;: &#34;new value&#34; }` - Result: `{ &#34;data2&#34;: &#34;new value&#34; }` ## Restriction This is the restriction of Key Naming for the record: 1. Cannot use **&#34;.&#34;** as the key name - `{ &#34;data.2&#34;: &#34;value&#34; }` 2. Cannot use **&#34;$&#34;** as the prefix in key names - `{ &#34;$data&#34;: &#34;value&#34; }` 3. Cannot use empty string in key names - `{ &#34;&#34;: &#34;value&#34; }` ## Record Metadata Metadata allows user to define the behaviour of the record. Metadata can be defined in request body with field name **__META**. When creating record, if **__META** field is not defined, the metadata value will use the default value. When updating record, if **__META** field is not defined, the existing metadata value will stay as is. **Metadata List:** 1. set_by (default: CLIENT, type: string) Indicate which party that could modify the game record. SERVER: record can be modified by server only. CLIENT: record can be modified by client and server. 2. is_public (default: false, type: bool) Indicate whether the player record is a public record or not. 3. tags (default: *empty array*, type: array of string) Indicate the tagging for the game record. **Request Body Example:** ``` { &#34;__META&#34;: { &#34;set_by&#34;: &#34;SERVER&#34;, &#34;is_public&#34;: true, &#34;tags&#34;: [&#34;tag1&#34;, &#34;tag2&#34;] } ... } ```
     */
    updateRecord_ByUserId_ByKey,
    /**
     * Get a size of the player record
     */
    getSize_ByUserId_ByKey,
    /**
     * Delete player public record. ## Warning: This endpoint is going to deprecate This endpoint is going to deprecate in the future please don&#39;t use it. For alternative, please use these endpoints: - **POST /cloudsave/v1/admin/namespaces/{namespace}/users/{userId}/records/{key}** and utilizing **__META** functionality - **PUT /cloudsave/v1/admin/namespaces/{namespace}/users/{userId}/records/{key}** and utilizing **__META** functionality - **DELETE /cloudsave/v1/admin/namespaces/{namespace}/users/{userId}/records/{key}**
     */
    deletePublic_ByUserId_ByKey,
    /**
     * Get a record in user-level (arbitrary JSON data) by its key.
     */
    getPublic_ByUserId_ByKey,
    /**
     * ## Description This endpoints will create new player public record or append the existing player public record. **Append example:** Example 1 - Existing JSON: `{ &#34;data1&#34;: &#34;value&#34; }` - New JSON: `{ &#34;data2&#34;: &#34;new value&#34; }` - Result: `{ &#34;data1&#34;: &#34;value&#34;, &#34;data2&#34;: &#34;new value&#34; }` Example 2 - Existing JSON: `{ &#34;data1&#34;: { &#34;data2&#34;: &#34;value&#34; }` - New JSON: `{ &#34;data1&#34;: { &#34;data3&#34;: &#34;new value&#34; }` - Result: `{ &#34;data1&#34;: { &#34;data2&#34;: &#34;value&#34;, &#34;data3&#34;: &#34;new value&#34; }` ## Restriction This is the restriction of Key Naming for the record: 1. Cannot use **&#34;.&#34;** as the key name - `{ &#34;data.2&#34;: &#34;value&#34; }` 2. Cannot use **&#34;$&#34;** as the prefix in key names - `{ &#34;$data&#34;: &#34;value&#34; }` 3. Cannot use empty string in key names - `{ &#34;&#34;: &#34;value&#34; }` ## Warning: This endpoint is going to deprecate This endpoint is going to deprecate in the future please don&#39;t use it. For alternative, please use these endpoints: - **POST /cloudsave/v1/admin/namespaces/{namespace}/users/{userId}/records/{key}** and utilizing **__META** functionality - **PUT /cloudsave/v1/admin/namespaces/{namespace}/users/{userId}/records/{key}** and utilizing **__META** functionality - **DELETE /cloudsave/v1/admin/namespaces/{namespace}/users/{userId}/records/{key}**
     */
    createPublic_ByUserId_ByKey,
    /**
     * ## Description This endpoints will create new player public record or replace the existing player public record. **Replace behaviour:** The existing value will be replaced completely with the new value. Example - Existing JSON: `{ &#34;data1&#34;: &#34;value&#34; }` - New JSON: `{ &#34;data2&#34;: &#34;new value&#34; }` - Result: `{ &#34;data2&#34;: &#34;new value&#34; }` ## Restriction This is the restriction of Key Naming for the record: 1. Cannot use **&#34;.&#34;** as the key name - `{ &#34;data.2&#34;: &#34;value&#34; }` 2. Cannot use **&#34;$&#34;** as the prefix in key names - `{ &#34;$data&#34;: &#34;value&#34; }` 3. Cannot use empty string in key names - `{ &#34;&#34;: &#34;value&#34; }` ## Warning: This endpoint is going to deprecate This endpoint is going to deprecate in the future please don&#39;t use it. For alternative, please use these endpoints: - **POST /cloudsave/v1/admin/namespaces/{namespace}/users/{userId}/records/{key}** and utilizing **__META** functionality - **PUT /cloudsave/v1/admin/namespaces/{namespace}/users/{userId}/records/{key}** and utilizing **__META** functionality - **DELETE /cloudsave/v1/admin/namespaces/{namespace}/users/{userId}/records/{key}**
     */
    updatePublic_ByUserId_ByKey
  };
}

// src/generated-definitions/AppConfig.ts
import { z as z29 } from "zod";
var AppConfig = z29.object({ appName: z29.string() });

// src/generated-definitions/CustomConfig.ts
import { z as z30 } from "zod";
var CustomConfig = z30.object({ GRPCAddress: z30.string() });

// src/generated-definitions/CustomFunction.ts
import { z as z31 } from "zod";
var CustomFunction = z31.object({
  afterBulkReadGameBinaryRecord: z31.boolean(),
  afterBulkReadGameRecord: z31.boolean(),
  afterBulkReadPlayerBinaryRecord: z31.boolean(),
  afterBulkReadPlayerRecord: z31.boolean(),
  afterReadGameBinaryRecord: z31.boolean(),
  afterReadGameRecord: z31.boolean(),
  afterReadPlayerBinaryRecord: z31.boolean(),
  afterReadPlayerRecord: z31.boolean(),
  beforeWriteAdminGameRecord: z31.boolean(),
  beforeWriteAdminPlayerRecord: z31.boolean(),
  beforeWriteGameBinaryRecord: z31.boolean(),
  beforeWriteGameRecord: z31.boolean(),
  beforeWritePlayerBinaryRecord: z31.boolean(),
  beforeWritePlayerRecord: z31.boolean()
});

// src/generated-definitions/PluginResponse.ts
import { z as z32 } from "zod";
var PluginResponse = z32.object({
  appConfig: AppConfig.nullish(),
  customConfig: CustomConfig.nullish(),
  customFunction: CustomFunction,
  extendType: z32.enum(["APP", "CUSTOM"]),
  namespace: z32.string()
});

// src/generated-admin/endpoints/PluginConfigAdmin$.ts
import { Validate as Validate6 } from "@accelbyte/sdk";
import { z as z33 } from "zod";
var PluginConfigAdmin$ = class {
  // @ts-ignore
  // prettier-ignore
  constructor(axiosInstance, namespace, useSchemaValidation = true) {
    this.axiosInstance = axiosInstance;
    this.namespace = namespace;
    this.useSchemaValidation = useSchemaValidation;
  }
  /**
   * ## Description This endpoints will delete grpc plugins configuration
   */
  deletePlugin() {
    const params = {};
    const url = "/cloudsave/v1/admin/namespaces/{namespace}/plugins".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.delete(url, { params });
    return Validate6.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, z33.unknown(), "z.unknown()");
  }
  /**
   * ## Description This endpoints will get grpc plugins configuration
   */
  getPlugins() {
    const params = {};
    const url = "/cloudsave/v1/admin/namespaces/{namespace}/plugins".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.get(url, { params });
    return Validate6.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, PluginResponse, "PluginResponse");
  }
  /**
   * ## Description This endpoints will update grpc plugins configuration
   */
  patchPlugin(data) {
    const params = {};
    const url = "/cloudsave/v1/admin/namespaces/{namespace}/plugins".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.patch(url, data, { params });
    return Validate6.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, PluginResponse, "PluginResponse");
  }
  /**
   * ## Description This endpoints will create new grpc plugins configuration per namespace
   */
  createPlugin(data) {
    const params = {};
    const url = "/cloudsave/v1/admin/namespaces/{namespace}/plugins".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.post(url, data, { params });
    return Validate6.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, PluginResponse, "PluginResponse");
  }
};

// src/generated-admin/PluginConfigAdminApi.ts
import { ApiUtils as ApiUtils6, Network as Network6 } from "@accelbyte/sdk";
function PluginConfigAdminApi(sdk, args) {
  const sdkAssembly = sdk.assembly();
  const namespace = args?.coreConfig?.namespace ?? sdkAssembly.coreConfig.namespace;
  const useSchemaValidation = args?.coreConfig?.useSchemaValidation ?? sdkAssembly.coreConfig.useSchemaValidation;
  let axiosInstance = sdkAssembly.axiosInstance;
  const requestConfigOverrides = args?.axiosConfig?.request;
  const baseURLOverride = args?.coreConfig?.baseURL;
  const interceptorsOverride = args?.axiosConfig?.interceptors ?? [];
  if (requestConfigOverrides || baseURLOverride || interceptorsOverride.length > 0) {
    const requestConfig = ApiUtils6.mergeAxiosConfigs(sdkAssembly.axiosInstance.defaults, {
      ...baseURLOverride ? { baseURL: baseURLOverride } : {},
      ...requestConfigOverrides
    });
    axiosInstance = Network6.create(requestConfig);
    for (const interceptor of interceptorsOverride) {
      if (interceptor.type === "request") {
        axiosInstance.interceptors.request.use(interceptor.onRequest, interceptor.onError);
      }
      if (interceptor.type === "response") {
        axiosInstance.interceptors.response.use(interceptor.onSuccess, interceptor.onError);
      }
    }
  }
  async function deletePlugin() {
    const $ = new PluginConfigAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.deletePlugin();
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getPlugins() {
    const $ = new PluginConfigAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getPlugins();
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function patchPlugin(data) {
    const $ = new PluginConfigAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.patchPlugin(data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function createPlugin(data) {
    const $ = new PluginConfigAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.createPlugin(data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  return {
    /**
     * ## Description This endpoints will delete grpc plugins configuration
     */
    deletePlugin,
    /**
     * ## Description This endpoints will get grpc plugins configuration
     */
    getPlugins,
    /**
     * ## Description This endpoints will update grpc plugins configuration
     */
    patchPlugin,
    /**
     * ## Description This endpoints will create new grpc plugins configuration per namespace
     */
    createPlugin
  };
}

// src/generated-definitions/AdminGameRecordResponse.ts
import { z as z34 } from "zod";
var AdminGameRecordResponse = z34.object({
  created_at: z34.string(),
  key: z34.string(),
  namespace: z34.string(),
  tags: z34.array(z34.string()).nullish(),
  updated_at: z34.string(),
  value: z34.record(z34.any())
});

// src/generated-definitions/BulkGetAdminGameRecordResponse.ts
import { z as z35 } from "zod";
var BulkGetAdminGameRecordResponse = z35.object({ data: z35.array(AdminGameRecordResponse) });

// src/generated-definitions/ListAdminGameRecordKeysResponse.ts
import { z as z36 } from "zod";
var ListAdminGameRecordKeysResponse = z36.object({ data: z36.array(z36.string()), paging: Pagination });

// src/generated-definitions/AdminPlayerRecordKeyInfo.ts
import { z as z37 } from "zod";
var AdminPlayerRecordKeyInfo = z37.object({ key: z37.string(), user_id: z37.string() });

// src/generated-definitions/ListAdminPlayerRecordKeysResponse.ts
import { z as z38 } from "zod";
var ListAdminPlayerRecordKeysResponse = z38.object({ data: z38.array(AdminPlayerRecordKeyInfo), paging: Pagination });

// src/generated-admin/endpoints/RecordAdmin$.ts
import { Validate as Validate7 } from "@accelbyte/sdk";
import { z as z39 } from "zod";
var RecordAdmin$ = class {
  // @ts-ignore
  // prettier-ignore
  constructor(axiosInstance, namespace, useSchemaValidation = true) {
    this.axiosInstance = axiosInstance;
    this.namespace = namespace;
    this.useSchemaValidation = useSchemaValidation;
  }
  /**
   * Retrieve list of records key by namespace
   */
  getAdminrecords(queryParams) {
    const params = { limit: 25, ...queryParams };
    const url = "/cloudsave/v1/admin/namespaces/{namespace}/adminrecords".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.get(url, { params });
    return Validate7.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      ListAdminGameRecordKeysResponse,
      "ListAdminGameRecordKeysResponse"
    );
  }
  /**
   * Bulk get admin game records. Maximum key per request 20.
   */
  fetchAdminrecordBulk(data) {
    const params = {};
    const url = "/cloudsave/v1/admin/namespaces/{namespace}/adminrecords/bulk".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.post(url, data, { params });
    return Validate7.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      BulkGetAdminGameRecordResponse,
      "BulkGetAdminGameRecordResponse"
    );
  }
  /**
   * This endpoints delete game record in namespace-level
   */
  deleteAdminrecord_ByKey(key) {
    const params = {};
    const url = "/cloudsave/v1/admin/namespaces/{namespace}/adminrecords/{key}".replace("{namespace}", this.namespace).replace("{key}", key);
    const resultPromise = this.axiosInstance.delete(url, { params });
    return Validate7.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, z39.unknown(), "z.unknown()");
  }
  /**
   * Get a record by its key in namespace-level.
   */
  getAdminrecord_ByKey(key) {
    const params = {};
    const url = "/cloudsave/v1/admin/namespaces/{namespace}/adminrecords/{key}".replace("{namespace}", this.namespace).replace("{key}", key);
    const resultPromise = this.axiosInstance.get(url, { params });
    return Validate7.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      AdminGameRecordResponse,
      "AdminGameRecordResponse"
    );
  }
  /**
   * ## Description This endpoints will create new admin game record or append the existing admin game record. **Append example:** Example 1 - Existing JSON: `{ &#34;data1&#34;: &#34;value&#34; }` - New JSON: `{ &#34;data2&#34;: &#34;new value&#34; }` - Result: `{ &#34;data1&#34;: &#34;value&#34;, &#34;data2&#34;: &#34;new value&#34; }` Example 2 - Existing JSON: `{ &#34;data1&#34;: { &#34;data2&#34;: &#34;value&#34; }` - New JSON: `{ &#34;data1&#34;: { &#34;data3&#34;: &#34;new value&#34; }` - Result: `{ &#34;data1&#34;: { &#34;data2&#34;: &#34;value&#34;, &#34;data3&#34;: &#34;new value&#34; }` ## Restriction This is the restriction of Key Naming for the record: 1. Cannot use **&#34;.&#34;** as the key name - `{ &#34;data.2&#34;: &#34;value&#34; }` 2. Cannot use **&#34;$&#34;** as the prefix in key names - `{ &#34;$data&#34;: &#34;value&#34; }` 3. Cannot use empty string in key names - `{ &#34;&#34;: &#34;value&#34; }` ## Record Metadata Metadata allows user to define the behaviour of the record. Metadata can be defined in request body with field name **__META**. When creating record, if **__META** field is not defined, the metadata value will use the default value. When updating record, if **__META** field is not defined, the existing metadata value will stay as is. **Metadata List:** 1. tags (default: *empty array*, type: array of string) Indicate the tagging for the admin record. **Request Body Example:** ``` { &#34;__META&#34;: { &#34;tags&#34;: [&#34;tag1&#34;, &#34;tag2&#34;] } ... } ```
   */
  createAdminrecord_ByKey(key, data) {
    const params = {};
    const url = "/cloudsave/v1/admin/namespaces/{namespace}/adminrecords/{key}".replace("{namespace}", this.namespace).replace("{key}", key);
    const resultPromise = this.axiosInstance.post(url, data, { params });
    return Validate7.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      AdminGameRecordResponse,
      "AdminGameRecordResponse"
    );
  }
  /**
   * ## Description This endpoints will create new admin game record or replace the existing admin game record. **Append example:** Example - Existing JSON: `{ &#34;data1&#34;: &#34;value&#34; }` - New JSON: `{ &#34;data2&#34;: &#34;new value&#34; }` - Result: `{ &#34;data2&#34;: &#34;new value&#34; }` ## Restriction This is the restriction of Key Naming for the record: 1. Cannot use **&#34;.&#34;** as the key name - `{ &#34;data.2&#34;: &#34;value&#34; }` 2. Cannot use **&#34;$&#34;** as the prefix in key names - `{ &#34;$data&#34;: &#34;value&#34; }` 3. Cannot use empty string in key names - `{ &#34;&#34;: &#34;value&#34; }` ## Record Metadata Metadata allows user to define the behaviour of the record. Metadata can be defined in request body with field name **__META**. When creating record, if **__META** field is not defined, the metadata value will use the default value. When updating record, if **__META** field is not defined, the existing metadata value will stay as is. **Metadata List:** 1. tags (default: *empty array*, type: array of string) Indicate the tagging for the admin record. **Request Body Example:** ``` { &#34;__META&#34;: { &#34;tags&#34;: [&#34;tag1&#34;, &#34;tag2&#34;] } ... } ```
   */
  updateAdminrecord_ByKey(key, data) {
    const params = {};
    const url = "/cloudsave/v1/admin/namespaces/{namespace}/adminrecords/{key}".replace("{namespace}", this.namespace).replace("{key}", key);
    const resultPromise = this.axiosInstance.put(url, data, { params });
    return Validate7.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      AdminGameRecordResponse,
      "AdminGameRecordResponse"
    );
  }
  /**
   * Retrieve list of admin player records key and userID under given namespace.
   */
  getAdminrecords_ByUserId(userId, queryParams) {
    const params = { limit: 25, ...queryParams };
    const url = "/cloudsave/v1/admin/namespaces/{namespace}/users/{userId}/adminrecords".replace("{namespace}", this.namespace).replace("{userId}", userId);
    const resultPromise = this.axiosInstance.get(url, { params });
    return Validate7.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      ListAdminPlayerRecordKeysResponse,
      "ListAdminPlayerRecordKeysResponse"
    );
  }
  /**
   * Bulk get admin player record by userIds, max allowed 20 at a time.
   */
  fetchBulkUser_ByKey(key, data) {
    const params = {};
    const url = "/cloudsave/v1/admin/namespaces/{namespace}/users/adminrecords/{key}/bulk".replace("{namespace}", this.namespace).replace("{key}", key);
    const resultPromise = this.axiosInstance.post(url, data, { params });
    return Validate7.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      BulkGetAdminPlayerRecordResponse,
      "BulkGetAdminPlayerRecordResponse"
    );
  }
  /**
   * Bulk get admin player records. Maximum key per request 20.
   */
  fetchAdminrecordBulk_ByUserId(userId, data) {
    const params = {};
    const url = "/cloudsave/v1/admin/namespaces/{namespace}/users/{userId}/adminrecords/bulk".replace("{namespace}", this.namespace).replace("{userId}", userId);
    const resultPromise = this.axiosInstance.post(url, data, { params });
    return Validate7.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      BulkGetAdminPlayerRecordResponse,
      "BulkGetAdminPlayerRecordResponse"
    );
  }
  /**
   * Delete a record (arbitrary JSON data) in user-level with given key.
   */
  deleteAdminrecord_ByUserId_ByKey(userId, key) {
    const params = {};
    const url = "/cloudsave/v1/admin/namespaces/{namespace}/users/{userId}/adminrecords/{key}".replace("{namespace}", this.namespace).replace("{userId}", userId).replace("{key}", key);
    const resultPromise = this.axiosInstance.delete(url, { params });
    return Validate7.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, z39.unknown(), "z.unknown()");
  }
  /**
   * Get a admin record in user-level (arbitrary JSON data) by its key.
   */
  getAdminrecord_ByUserId_ByKey(userId, key) {
    const params = {};
    const url = "/cloudsave/v1/admin/namespaces/{namespace}/users/{userId}/adminrecords/{key}".replace("{namespace}", this.namespace).replace("{userId}", userId).replace("{key}", key);
    const resultPromise = this.axiosInstance.get(url, { params });
    return Validate7.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      AdminPlayerRecordResponse,
      "AdminPlayerRecordResponse"
    );
  }
  /**
   * ## Description This endpoints will create new admin player record or append the existing admin game record. **Append example:** Example 1 - Existing JSON: `{ &#34;data1&#34;: &#34;value&#34; }` - New JSON: `{ &#34;data2&#34;: &#34;new value&#34; }` - Result: `{ &#34;data1&#34;: &#34;value&#34;, &#34;data2&#34;: &#34;new value&#34; }` Example 2 - Existing JSON: `{ &#34;data1&#34;: { &#34;data2&#34;: &#34;value&#34; }` - New JSON: `{ &#34;data1&#34;: { &#34;data3&#34;: &#34;new value&#34; }` - Result: `{ &#34;data1&#34;: { &#34;data2&#34;: &#34;value&#34;, &#34;data3&#34;: &#34;new value&#34; }` ## Restriction This is the restriction of Key Naming for the record: 1. Cannot use **&#34;.&#34;** as the key name - `{ &#34;data.2&#34;: &#34;value&#34; }` 2. Cannot use **&#34;$&#34;** as the prefix in key names - `{ &#34;$data&#34;: &#34;value&#34; }` 3. Cannot use empty string in key names - `{ &#34;&#34;: &#34;value&#34; }` ## Record Metadata Metadata allows user to define the behaviour of the record. Metadata can be defined in request body with field name **__META**. When creating record, if **__META** field is not defined, the metadata value will use the default value. When updating record, if **__META** field is not defined, the existing metadata value will stay as is. **Metadata List:** 1. tags (default: *empty array*, type: array of string) Indicate the tagging for the admin record. **Request Body Example:** ``` { &#34;__META&#34;: { &#34;tags&#34;: [&#34;tag1&#34;, &#34;tag2&#34;] } ... } ```
   */
  createAdminrecord_ByUserId_ByKey(userId, key, data) {
    const params = {};
    const url = "/cloudsave/v1/admin/namespaces/{namespace}/users/{userId}/adminrecords/{key}".replace("{namespace}", this.namespace).replace("{userId}", userId).replace("{key}", key);
    const resultPromise = this.axiosInstance.post(url, data, { params });
    return Validate7.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      AdminPlayerRecordResponse,
      "AdminPlayerRecordResponse"
    );
  }
  /**
   * ## Description This endpoints will create new admin player record or replace the existing admin player record. **Replace behaviour:** The existing value will be replaced completely with the new value. Example - Existing JSON: `{ &#34;data1&#34;: &#34;value&#34; }` - New JSON: `{ &#34;data2&#34;: &#34;new value&#34; }` - Result: `{ &#34;data2&#34;: &#34;new value&#34; }` ## Restriction This is the restriction of Key Naming for the record: 1. Cannot use **&#34;.&#34;** as the key name - `{ &#34;data.2&#34;: &#34;value&#34; }` 2. Cannot use **&#34;$&#34;** as the prefix in key names - `{ &#34;$data&#34;: &#34;value&#34; }` 3. Cannot use empty string in key names - `{ &#34;&#34;: &#34;value&#34; }` ## Record Metadata Metadata allows user to define the behaviour of the record. Metadata can be defined in request body with field name **__META**. When creating record, if **__META** field is not defined, the metadata value will use the default value. When updating record, if **__META** field is not defined, the existing metadata value will stay as is. **Metadata List:** 1. tags (default: *empty array*, type: array of string) Indicate the tagging for the admin record. **Request Body Example:** ``` { &#34;__META&#34;: { &#34;tags&#34;: [&#34;tag1&#34;, &#34;tag2&#34;] } ... } ```
   */
  updateAdminrecord_ByUserId_ByKey(userId, key, data) {
    const params = {};
    const url = "/cloudsave/v1/admin/namespaces/{namespace}/users/{userId}/adminrecords/{key}".replace("{namespace}", this.namespace).replace("{userId}", userId).replace("{key}", key);
    const resultPromise = this.axiosInstance.put(url, data, { params });
    return Validate7.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      AdminPlayerRecordResponse,
      "AdminPlayerRecordResponse"
    );
  }
};

// src/generated-admin/RecordAdminApi.ts
import { ApiUtils as ApiUtils7, Network as Network7 } from "@accelbyte/sdk";
function RecordAdminApi(sdk, args) {
  const sdkAssembly = sdk.assembly();
  const namespace = args?.coreConfig?.namespace ?? sdkAssembly.coreConfig.namespace;
  const useSchemaValidation = args?.coreConfig?.useSchemaValidation ?? sdkAssembly.coreConfig.useSchemaValidation;
  let axiosInstance = sdkAssembly.axiosInstance;
  const requestConfigOverrides = args?.axiosConfig?.request;
  const baseURLOverride = args?.coreConfig?.baseURL;
  const interceptorsOverride = args?.axiosConfig?.interceptors ?? [];
  if (requestConfigOverrides || baseURLOverride || interceptorsOverride.length > 0) {
    const requestConfig = ApiUtils7.mergeAxiosConfigs(sdkAssembly.axiosInstance.defaults, {
      ...baseURLOverride ? { baseURL: baseURLOverride } : {},
      ...requestConfigOverrides
    });
    axiosInstance = Network7.create(requestConfig);
    for (const interceptor of interceptorsOverride) {
      if (interceptor.type === "request") {
        axiosInstance.interceptors.request.use(interceptor.onRequest, interceptor.onError);
      }
      if (interceptor.type === "response") {
        axiosInstance.interceptors.response.use(interceptor.onSuccess, interceptor.onError);
      }
    }
  }
  async function getAdminrecords(queryParams) {
    const $ = new RecordAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getAdminrecords(queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function fetchAdminrecordBulk(data) {
    const $ = new RecordAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.fetchAdminrecordBulk(data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function deleteAdminrecord_ByKey(key) {
    const $ = new RecordAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.deleteAdminrecord_ByKey(key);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getAdminrecord_ByKey(key) {
    const $ = new RecordAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getAdminrecord_ByKey(key);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function createAdminrecord_ByKey(key, data) {
    const $ = new RecordAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.createAdminrecord_ByKey(key, data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function updateAdminrecord_ByKey(key, data) {
    const $ = new RecordAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.updateAdminrecord_ByKey(key, data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getAdminrecords_ByUserId(userId, queryParams) {
    const $ = new RecordAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getAdminrecords_ByUserId(userId, queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function fetchBulkUser_ByKey(key, data) {
    const $ = new RecordAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.fetchBulkUser_ByKey(key, data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function fetchAdminrecordBulk_ByUserId(userId, data) {
    const $ = new RecordAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.fetchAdminrecordBulk_ByUserId(userId, data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function deleteAdminrecord_ByUserId_ByKey(userId, key) {
    const $ = new RecordAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.deleteAdminrecord_ByUserId_ByKey(userId, key);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getAdminrecord_ByUserId_ByKey(userId, key) {
    const $ = new RecordAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getAdminrecord_ByUserId_ByKey(userId, key);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function createAdminrecord_ByUserId_ByKey(userId, key, data) {
    const $ = new RecordAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.createAdminrecord_ByUserId_ByKey(userId, key, data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function updateAdminrecord_ByUserId_ByKey(userId, key, data) {
    const $ = new RecordAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.updateAdminrecord_ByUserId_ByKey(userId, key, data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  return {
    /**
     * Retrieve list of records key by namespace
     */
    getAdminrecords,
    /**
     * Bulk get admin game records. Maximum key per request 20.
     */
    fetchAdminrecordBulk,
    /**
     * This endpoints delete game record in namespace-level
     */
    deleteAdminrecord_ByKey,
    /**
     * Get a record by its key in namespace-level.
     */
    getAdminrecord_ByKey,
    /**
     * ## Description This endpoints will create new admin game record or append the existing admin game record. **Append example:** Example 1 - Existing JSON: `{ &#34;data1&#34;: &#34;value&#34; }` - New JSON: `{ &#34;data2&#34;: &#34;new value&#34; }` - Result: `{ &#34;data1&#34;: &#34;value&#34;, &#34;data2&#34;: &#34;new value&#34; }` Example 2 - Existing JSON: `{ &#34;data1&#34;: { &#34;data2&#34;: &#34;value&#34; }` - New JSON: `{ &#34;data1&#34;: { &#34;data3&#34;: &#34;new value&#34; }` - Result: `{ &#34;data1&#34;: { &#34;data2&#34;: &#34;value&#34;, &#34;data3&#34;: &#34;new value&#34; }` ## Restriction This is the restriction of Key Naming for the record: 1. Cannot use **&#34;.&#34;** as the key name - `{ &#34;data.2&#34;: &#34;value&#34; }` 2. Cannot use **&#34;$&#34;** as the prefix in key names - `{ &#34;$data&#34;: &#34;value&#34; }` 3. Cannot use empty string in key names - `{ &#34;&#34;: &#34;value&#34; }` ## Record Metadata Metadata allows user to define the behaviour of the record. Metadata can be defined in request body with field name **__META**. When creating record, if **__META** field is not defined, the metadata value will use the default value. When updating record, if **__META** field is not defined, the existing metadata value will stay as is. **Metadata List:** 1. tags (default: *empty array*, type: array of string) Indicate the tagging for the admin record. **Request Body Example:** ``` { &#34;__META&#34;: { &#34;tags&#34;: [&#34;tag1&#34;, &#34;tag2&#34;] } ... } ```
     */
    createAdminrecord_ByKey,
    /**
     * ## Description This endpoints will create new admin game record or replace the existing admin game record. **Append example:** Example - Existing JSON: `{ &#34;data1&#34;: &#34;value&#34; }` - New JSON: `{ &#34;data2&#34;: &#34;new value&#34; }` - Result: `{ &#34;data2&#34;: &#34;new value&#34; }` ## Restriction This is the restriction of Key Naming for the record: 1. Cannot use **&#34;.&#34;** as the key name - `{ &#34;data.2&#34;: &#34;value&#34; }` 2. Cannot use **&#34;$&#34;** as the prefix in key names - `{ &#34;$data&#34;: &#34;value&#34; }` 3. Cannot use empty string in key names - `{ &#34;&#34;: &#34;value&#34; }` ## Record Metadata Metadata allows user to define the behaviour of the record. Metadata can be defined in request body with field name **__META**. When creating record, if **__META** field is not defined, the metadata value will use the default value. When updating record, if **__META** field is not defined, the existing metadata value will stay as is. **Metadata List:** 1. tags (default: *empty array*, type: array of string) Indicate the tagging for the admin record. **Request Body Example:** ``` { &#34;__META&#34;: { &#34;tags&#34;: [&#34;tag1&#34;, &#34;tag2&#34;] } ... } ```
     */
    updateAdminrecord_ByKey,
    /**
     * Retrieve list of admin player records key and userID under given namespace.
     */
    getAdminrecords_ByUserId,
    /**
     * Bulk get admin player record by userIds, max allowed 20 at a time.
     */
    fetchBulkUser_ByKey,
    /**
     * Bulk get admin player records. Maximum key per request 20.
     */
    fetchAdminrecordBulk_ByUserId,
    /**
     * Delete a record (arbitrary JSON data) in user-level with given key.
     */
    deleteAdminrecord_ByUserId_ByKey,
    /**
     * Get a admin record in user-level (arbitrary JSON data) by its key.
     */
    getAdminrecord_ByUserId_ByKey,
    /**
     * ## Description This endpoints will create new admin player record or append the existing admin game record. **Append example:** Example 1 - Existing JSON: `{ &#34;data1&#34;: &#34;value&#34; }` - New JSON: `{ &#34;data2&#34;: &#34;new value&#34; }` - Result: `{ &#34;data1&#34;: &#34;value&#34;, &#34;data2&#34;: &#34;new value&#34; }` Example 2 - Existing JSON: `{ &#34;data1&#34;: { &#34;data2&#34;: &#34;value&#34; }` - New JSON: `{ &#34;data1&#34;: { &#34;data3&#34;: &#34;new value&#34; }` - Result: `{ &#34;data1&#34;: { &#34;data2&#34;: &#34;value&#34;, &#34;data3&#34;: &#34;new value&#34; }` ## Restriction This is the restriction of Key Naming for the record: 1. Cannot use **&#34;.&#34;** as the key name - `{ &#34;data.2&#34;: &#34;value&#34; }` 2. Cannot use **&#34;$&#34;** as the prefix in key names - `{ &#34;$data&#34;: &#34;value&#34; }` 3. Cannot use empty string in key names - `{ &#34;&#34;: &#34;value&#34; }` ## Record Metadata Metadata allows user to define the behaviour of the record. Metadata can be defined in request body with field name **__META**. When creating record, if **__META** field is not defined, the metadata value will use the default value. When updating record, if **__META** field is not defined, the existing metadata value will stay as is. **Metadata List:** 1. tags (default: *empty array*, type: array of string) Indicate the tagging for the admin record. **Request Body Example:** ``` { &#34;__META&#34;: { &#34;tags&#34;: [&#34;tag1&#34;, &#34;tag2&#34;] } ... } ```
     */
    createAdminrecord_ByUserId_ByKey,
    /**
     * ## Description This endpoints will create new admin player record or replace the existing admin player record. **Replace behaviour:** The existing value will be replaced completely with the new value. Example - Existing JSON: `{ &#34;data1&#34;: &#34;value&#34; }` - New JSON: `{ &#34;data2&#34;: &#34;new value&#34; }` - Result: `{ &#34;data2&#34;: &#34;new value&#34; }` ## Restriction This is the restriction of Key Naming for the record: 1. Cannot use **&#34;.&#34;** as the key name - `{ &#34;data.2&#34;: &#34;value&#34; }` 2. Cannot use **&#34;$&#34;** as the prefix in key names - `{ &#34;$data&#34;: &#34;value&#34; }` 3. Cannot use empty string in key names - `{ &#34;&#34;: &#34;value&#34; }` ## Record Metadata Metadata allows user to define the behaviour of the record. Metadata can be defined in request body with field name **__META**. When creating record, if **__META** field is not defined, the metadata value will use the default value. When updating record, if **__META** field is not defined, the existing metadata value will stay as is. **Metadata List:** 1. tags (default: *empty array*, type: array of string) Indicate the tagging for the admin record. **Request Body Example:** ``` { &#34;__META&#34;: { &#34;tags&#34;: [&#34;tag1&#34;, &#34;tag2&#34;] } ... } ```
     */
    updateAdminrecord_ByUserId_ByKey
  };
}

// src/generated-definitions/TagInfo.ts
import { z as z40 } from "zod";
var TagInfo = z40.object({ created_at: z40.string(), tag: z40.string() });

// src/generated-definitions/ListTagsResponse.ts
import { z as z41 } from "zod";
var ListTagsResponse = z41.object({ data: z41.array(TagInfo), paging: Pagination });

// src/generated-admin/endpoints/TagsAdmin$.ts
import { Validate as Validate8 } from "@accelbyte/sdk";
import { z as z42 } from "zod";
var TagsAdmin$ = class {
  // @ts-ignore
  // prettier-ignore
  constructor(axiosInstance, namespace, useSchemaValidation = true) {
    this.axiosInstance = axiosInstance;
    this.namespace = namespace;
    this.useSchemaValidation = useSchemaValidation;
  }
  /**
   * ## Description Retrieve list of available tags by namespace
   */
  getTags(queryParams) {
    const params = { limit: 25, ...queryParams };
    const url = "/cloudsave/v1/admin/namespaces/{namespace}/tags".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.get(url, { params });
    return Validate8.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, ListTagsResponse, "ListTagsResponse");
  }
  /**
   * ## Description This endpoint will create new tags
   */
  createTag(data) {
    const params = {};
    const url = "/cloudsave/v1/admin/namespaces/{namespace}/tags".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.post(url, data, { params });
    return Validate8.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, z42.unknown(), "z.unknown()");
  }
  /**
   * ## Description This endpoint will delete tag by name
   */
  deleteTag_ByTag(tag) {
    const params = {};
    const url = "/cloudsave/v1/admin/namespaces/{namespace}/tags/{tag}".replace("{namespace}", this.namespace).replace("{tag}", tag);
    const resultPromise = this.axiosInstance.delete(url, { params });
    return Validate8.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, z42.unknown(), "z.unknown()");
  }
};

// src/generated-admin/TagsAdminApi.ts
import { ApiUtils as ApiUtils8, Network as Network8 } from "@accelbyte/sdk";
function TagsAdminApi(sdk, args) {
  const sdkAssembly = sdk.assembly();
  const namespace = args?.coreConfig?.namespace ?? sdkAssembly.coreConfig.namespace;
  const useSchemaValidation = args?.coreConfig?.useSchemaValidation ?? sdkAssembly.coreConfig.useSchemaValidation;
  let axiosInstance = sdkAssembly.axiosInstance;
  const requestConfigOverrides = args?.axiosConfig?.request;
  const baseURLOverride = args?.coreConfig?.baseURL;
  const interceptorsOverride = args?.axiosConfig?.interceptors ?? [];
  if (requestConfigOverrides || baseURLOverride || interceptorsOverride.length > 0) {
    const requestConfig = ApiUtils8.mergeAxiosConfigs(sdkAssembly.axiosInstance.defaults, {
      ...baseURLOverride ? { baseURL: baseURLOverride } : {},
      ...requestConfigOverrides
    });
    axiosInstance = Network8.create(requestConfig);
    for (const interceptor of interceptorsOverride) {
      if (interceptor.type === "request") {
        axiosInstance.interceptors.request.use(interceptor.onRequest, interceptor.onError);
      }
      if (interceptor.type === "response") {
        axiosInstance.interceptors.response.use(interceptor.onSuccess, interceptor.onError);
      }
    }
  }
  async function getTags(queryParams) {
    const $ = new TagsAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getTags(queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function createTag(data) {
    const $ = new TagsAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.createTag(data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function deleteTag_ByTag(tag) {
    const $ = new TagsAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.deleteTag_ByTag(tag);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  return {
    /**
     * ## Description Retrieve list of available tags by namespace
     */
    getTags,
    /**
     * ## Description This endpoint will create new tags
     */
    createTag,
    /**
     * ## Description This endpoint will delete tag by name
     */
    deleteTag_ByTag
  };
}

// src/generated-admin/endpoints/TtlConfigAdmin$.ts
import { Validate as Validate9 } from "@accelbyte/sdk";
import { z as z43 } from "zod";
var TtlConfigAdmin$ = class {
  // @ts-ignore
  // prettier-ignore
  constructor(axiosInstance, namespace, useSchemaValidation = true) {
    this.axiosInstance = axiosInstance;
    this.namespace = namespace;
    this.useSchemaValidation = useSchemaValidation;
  }
  /**
   * ## Description This endpoints will delete the ttl config of the game record
   */
  deleteTtl_ByKey(key) {
    const params = {};
    const url = "/cloudsave/v1/admin/namespaces/{namespace}/records/{key}/ttl".replace("{namespace}", this.namespace).replace("{key}", key);
    const resultPromise = this.axiosInstance.delete(url, { params });
    return Validate9.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, z43.unknown(), "z.unknown()");
  }
  /**
   * ## Description This endpoints will delete the ttl config of the game binary record
   */
  deleteTtl_ByKey_ByNS(key) {
    const params = {};
    const url = "/cloudsave/v1/admin/namespaces/{namespace}/binaries/{key}/ttl".replace("{namespace}", this.namespace).replace("{key}", key);
    const resultPromise = this.axiosInstance.delete(url, { params });
    return Validate9.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, z43.unknown(), "z.unknown()");
  }
};

// src/generated-admin/TtlConfigAdminApi.ts
import { ApiUtils as ApiUtils9, Network as Network9 } from "@accelbyte/sdk";
function TtlConfigAdminApi(sdk, args) {
  const sdkAssembly = sdk.assembly();
  const namespace = args?.coreConfig?.namespace ?? sdkAssembly.coreConfig.namespace;
  const useSchemaValidation = args?.coreConfig?.useSchemaValidation ?? sdkAssembly.coreConfig.useSchemaValidation;
  let axiosInstance = sdkAssembly.axiosInstance;
  const requestConfigOverrides = args?.axiosConfig?.request;
  const baseURLOverride = args?.coreConfig?.baseURL;
  const interceptorsOverride = args?.axiosConfig?.interceptors ?? [];
  if (requestConfigOverrides || baseURLOverride || interceptorsOverride.length > 0) {
    const requestConfig = ApiUtils9.mergeAxiosConfigs(sdkAssembly.axiosInstance.defaults, {
      ...baseURLOverride ? { baseURL: baseURLOverride } : {},
      ...requestConfigOverrides
    });
    axiosInstance = Network9.create(requestConfig);
    for (const interceptor of interceptorsOverride) {
      if (interceptor.type === "request") {
        axiosInstance.interceptors.request.use(interceptor.onRequest, interceptor.onError);
      }
      if (interceptor.type === "response") {
        axiosInstance.interceptors.response.use(interceptor.onSuccess, interceptor.onError);
      }
    }
  }
  async function deleteTtl_ByKey(key) {
    const $ = new TtlConfigAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.deleteTtl_ByKey(key);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function deleteTtl_ByKey_ByNS(key) {
    const $ = new TtlConfigAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.deleteTtl_ByKey_ByNS(key);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  return {
    /**
     * ## Description This endpoints will delete the ttl config of the game record
     */
    deleteTtl_ByKey,
    /**
     * ## Description This endpoints will delete the ttl config of the game binary record
     */
    deleteTtl_ByKey_ByNS
  };
}

// src/generated-public/endpoints/ConcurrentRecord$.ts
import { Validate as Validate10 } from "@accelbyte/sdk";
import { z as z44 } from "zod";
var ConcurrentRecord$ = class {
  // @ts-ignore
  // prettier-ignore
  constructor(axiosInstance, namespace, useSchemaValidation = true) {
    this.axiosInstance = axiosInstance;
    this.namespace = namespace;
    this.useSchemaValidation = useSchemaValidation;
  }
  /**
   * ## Description This endpoints will create new game record or replace the existing game record. **Replace behaviour:** The existing value will be replaced completely with the new value. Example - Existing JSON: `{ &#34;data1&#34;: &#34;value&#34; }` - New JSON: `{ &#34;data2&#34;: &#34;new value&#34; }` - Result: `{ &#34;data2&#34;: &#34;new value&#34; }` ## Restriction This is the restriction of Key Naming for the record: 1. Cannot use **&#34;.&#34;** as the key name - `{ &#34;data.2&#34;: &#34;value&#34; }` 2. Cannot use **&#34;$&#34;** as the prefix in key names - `{ &#34;$data&#34;: &#34;value&#34; }` 3. Cannot use empty string in key names - `{ &#34;&#34;: &#34;value&#34; }` ## Reserved Word Reserved Word List: **__META** The reserved word cannot be used as a field in record value, If still defining the field when creating or updating the record, it will be ignored. ## Optimistic Concurrency Control This endpoint implement optimistic concurrency control to avoid race condition. If the record has been updated since the client fetch it, the server will return HTTP status code 412 (precondition failed) and client need to redo the operation (fetch data and do update). Otherwise, the server will process the request.
   */
  updateConcurrentRecord_ByKey(key, data) {
    const params = {};
    const url = "/cloudsave/v1/namespaces/{namespace}/concurrent/records/{key}".replace("{namespace}", this.namespace).replace("{key}", key);
    const resultPromise = this.axiosInstance.put(url, data, { params });
    return Validate10.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, z44.unknown(), "z.unknown()");
  }
  /**
   * ## Description This endpoints will create new player record or replace the existing player record. **Replace behaviour:** The existing value will be replaced completely with the new value. Example - Existing JSON: `{ &#34;data1&#34;: &#34;value&#34; }` - New JSON: `{ &#34;data2&#34;: &#34;new value&#34; }` - Result: `{ &#34;data2&#34;: &#34;new value&#34; }` ## Restriction This is the restriction of Key Naming for the record: 1. Cannot use **&#34;.&#34;** as the key name - `{ &#34;data.2&#34;: &#34;value&#34; }` 2. Cannot use **&#34;$&#34;** as the prefix in key names - `{ &#34;$data&#34;: &#34;value&#34; }` 3. Cannot use empty string in key names - `{ &#34;&#34;: &#34;value&#34; }` ## Reserved Word Reserved Word List: **__META** The reserved word cannot be used as a field in record value, If still defining the field when creating or updating the record, it will be ignored. ## Optimistic Concurrency Control This endpoint implement optimistic concurrency control to avoid race condition. If the record has been updated since the client fetch it, the server will return HTTP status code 412 (precondition failed) and client need to redo the operation (fetch data and do update). Otherwise, the server will process the request.
   */
  updateConcurrentRecord_ByUserId_ByKey(userId, key, data, queryParams) {
    const params = { ...queryParams };
    const url = "/cloudsave/v1/namespaces/{namespace}/users/{userId}/concurrent/records/{key}".replace("{namespace}", this.namespace).replace("{userId}", userId).replace("{key}", key);
    const resultPromise = this.axiosInstance.put(url, data, { params });
    return Validate10.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      PlayerRecordConcurrentUpdateResponse,
      "PlayerRecordConcurrentUpdateResponse"
    );
  }
  /**
   * ## Description This endpoints will create new player public record or replace the existing player public record. **Replace behaviour:** The existing value will be replaced completely with the new value. Example - Existing JSON: `{ &#34;data1&#34;: &#34;value&#34; }` - New JSON: `{ &#34;data2&#34;: &#34;new value&#34; }` - Result: `{ &#34;data2&#34;: &#34;new value&#34; }` ## Restriction This is the restriction of Key Naming for the record: 1. Cannot use **&#34;.&#34;** as the key name - `{ &#34;data.2&#34;: &#34;value&#34; }` 2. Cannot use **&#34;$&#34;** as the prefix in key names - `{ &#34;$data&#34;: &#34;value&#34; }` 3. Cannot use empty string in key names - `{ &#34;&#34;: &#34;value&#34; }` ## Reserved Word Reserved Word List: **__META** The reserved word cannot be used as a field in record value, If still defining the field when creating or updating the record, it will be ignored. ## Optimistic Concurrency Control This endpoint implement optimistic concurrency control to avoid race condition. If the record has been updated since the client fetch it, the server will return HTTP status code 412 (precondition failed) and client need to redo the operation (fetch data and do update). Otherwise, the server will process the request.
   */
  updatePublicConcurrent_ByUserId_ByKey(userId, key, data, queryParams) {
    const params = { ...queryParams };
    const url = "/cloudsave/v1/namespaces/{namespace}/users/{userId}/concurrent/records/{key}/public".replace("{namespace}", this.namespace).replace("{userId}", userId).replace("{key}", key);
    const resultPromise = this.axiosInstance.put(url, data, { params });
    return Validate10.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      PlayerRecordConcurrentUpdateResponse,
      "PlayerRecordConcurrentUpdateResponse"
    );
  }
};

// src/generated-public/ConcurrentRecordApi.ts
import { ApiUtils as ApiUtils10, Network as Network10 } from "@accelbyte/sdk";
function ConcurrentRecordApi(sdk, args) {
  const sdkAssembly = sdk.assembly();
  const namespace = args?.coreConfig?.namespace ?? sdkAssembly.coreConfig.namespace;
  const useSchemaValidation = args?.coreConfig?.useSchemaValidation ?? sdkAssembly.coreConfig.useSchemaValidation;
  let axiosInstance = sdkAssembly.axiosInstance;
  const requestConfigOverrides = args?.axiosConfig?.request;
  const baseURLOverride = args?.coreConfig?.baseURL;
  const interceptorsOverride = args?.axiosConfig?.interceptors ?? [];
  if (requestConfigOverrides || baseURLOverride || interceptorsOverride.length > 0) {
    const requestConfig = ApiUtils10.mergeAxiosConfigs(sdkAssembly.axiosInstance.defaults, {
      ...baseURLOverride ? { baseURL: baseURLOverride } : {},
      ...requestConfigOverrides
    });
    axiosInstance = Network10.create(requestConfig);
    for (const interceptor of interceptorsOverride) {
      if (interceptor.type === "request") {
        axiosInstance.interceptors.request.use(interceptor.onRequest, interceptor.onError);
      }
      if (interceptor.type === "response") {
        axiosInstance.interceptors.response.use(interceptor.onSuccess, interceptor.onError);
      }
    }
  }
  async function updateConcurrentRecord_ByKey(key, data) {
    const $ = new ConcurrentRecord$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.updateConcurrentRecord_ByKey(key, data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function updateConcurrentRecord_ByUserId_ByKey(userId, key, data, queryParams) {
    const $ = new ConcurrentRecord$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.updateConcurrentRecord_ByUserId_ByKey(userId, key, data, queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function updatePublicConcurrent_ByUserId_ByKey(userId, key, data, queryParams) {
    const $ = new ConcurrentRecord$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.updatePublicConcurrent_ByUserId_ByKey(userId, key, data, queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  return {
    /**
     * ## Description This endpoints will create new game record or replace the existing game record. **Replace behaviour:** The existing value will be replaced completely with the new value. Example - Existing JSON: `{ &#34;data1&#34;: &#34;value&#34; }` - New JSON: `{ &#34;data2&#34;: &#34;new value&#34; }` - Result: `{ &#34;data2&#34;: &#34;new value&#34; }` ## Restriction This is the restriction of Key Naming for the record: 1. Cannot use **&#34;.&#34;** as the key name - `{ &#34;data.2&#34;: &#34;value&#34; }` 2. Cannot use **&#34;$&#34;** as the prefix in key names - `{ &#34;$data&#34;: &#34;value&#34; }` 3. Cannot use empty string in key names - `{ &#34;&#34;: &#34;value&#34; }` ## Reserved Word Reserved Word List: **__META** The reserved word cannot be used as a field in record value, If still defining the field when creating or updating the record, it will be ignored. ## Optimistic Concurrency Control This endpoint implement optimistic concurrency control to avoid race condition. If the record has been updated since the client fetch it, the server will return HTTP status code 412 (precondition failed) and client need to redo the operation (fetch data and do update). Otherwise, the server will process the request.
     */
    updateConcurrentRecord_ByKey,
    /**
     * ## Description This endpoints will create new player record or replace the existing player record. **Replace behaviour:** The existing value will be replaced completely with the new value. Example - Existing JSON: `{ &#34;data1&#34;: &#34;value&#34; }` - New JSON: `{ &#34;data2&#34;: &#34;new value&#34; }` - Result: `{ &#34;data2&#34;: &#34;new value&#34; }` ## Restriction This is the restriction of Key Naming for the record: 1. Cannot use **&#34;.&#34;** as the key name - `{ &#34;data.2&#34;: &#34;value&#34; }` 2. Cannot use **&#34;$&#34;** as the prefix in key names - `{ &#34;$data&#34;: &#34;value&#34; }` 3. Cannot use empty string in key names - `{ &#34;&#34;: &#34;value&#34; }` ## Reserved Word Reserved Word List: **__META** The reserved word cannot be used as a field in record value, If still defining the field when creating or updating the record, it will be ignored. ## Optimistic Concurrency Control This endpoint implement optimistic concurrency control to avoid race condition. If the record has been updated since the client fetch it, the server will return HTTP status code 412 (precondition failed) and client need to redo the operation (fetch data and do update). Otherwise, the server will process the request.
     */
    updateConcurrentRecord_ByUserId_ByKey,
    /**
     * ## Description This endpoints will create new player public record or replace the existing player public record. **Replace behaviour:** The existing value will be replaced completely with the new value. Example - Existing JSON: `{ &#34;data1&#34;: &#34;value&#34; }` - New JSON: `{ &#34;data2&#34;: &#34;new value&#34; }` - Result: `{ &#34;data2&#34;: &#34;new value&#34; }` ## Restriction This is the restriction of Key Naming for the record: 1. Cannot use **&#34;.&#34;** as the key name - `{ &#34;data.2&#34;: &#34;value&#34; }` 2. Cannot use **&#34;$&#34;** as the prefix in key names - `{ &#34;$data&#34;: &#34;value&#34; }` 3. Cannot use empty string in key names - `{ &#34;&#34;: &#34;value&#34; }` ## Reserved Word Reserved Word List: **__META** The reserved word cannot be used as a field in record value, If still defining the field when creating or updating the record, it will be ignored. ## Optimistic Concurrency Control This endpoint implement optimistic concurrency control to avoid race condition. If the record has been updated since the client fetch it, the server will return HTTP status code 412 (precondition failed) and client need to redo the operation (fetch data and do update). Otherwise, the server will process the request.
     */
    updatePublicConcurrent_ByUserId_ByKey
  };
}

// src/generated-definitions/GameBinaryRecordResponse.ts
import { z as z45 } from "zod";
var GameBinaryRecordResponse = z45.object({
  binary_info: BinaryInfoResponse.nullish(),
  created_at: z45.string(),
  key: z45.string(),
  namespace: z45.string(),
  set_by: z45.enum(["CLIENT", "SERVER"]).nullish(),
  tags: z45.array(z45.string()).nullish(),
  updated_at: z45.string()
});

// src/generated-definitions/BulkGetGameBinaryRecordResponse.ts
import { z as z46 } from "zod";
var BulkGetGameBinaryRecordResponse = z46.object({ data: z46.array(GameBinaryRecordResponse) });

// src/generated-definitions/ListGameBinaryRecordsResponse.ts
import { z as z47 } from "zod";
var ListGameBinaryRecordsResponse = z47.object({ data: z47.array(GameBinaryRecordResponse), paging: Pagination });

// src/generated-public/endpoints/PublicGameBinaryRecord$.ts
import { Validate as Validate11 } from "@accelbyte/sdk";
import { z as z48 } from "zod";
var PublicGameBinaryRecord$ = class {
  // @ts-ignore
  // prettier-ignore
  constructor(axiosInstance, namespace, useSchemaValidation = true) {
    this.axiosInstance = axiosInstance;
    this.namespace = namespace;
    this.useSchemaValidation = useSchemaValidation;
  }
  /**
   * Retrieve list of binary records by namespace.
   */
  getBinaries(queryParams) {
    const params = { limit: 25, ...queryParams };
    const url = "/cloudsave/v1/namespaces/{namespace}/binaries".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.get(url, { params });
    return Validate11.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      ListGameBinaryRecordsResponse,
      "ListGameBinaryRecordsResponse"
    );
  }
  /**
   * Create a game binary record. Other detail info: `key` should follow these rules: 1. support uppercase and lowercase letters, numbers, and separators **&#34;-&#34;**, **&#34;_&#34;**, **&#34;.&#34;** are allowed 2. begin and end with letters or numbers 3. spaces are not allowed 4. separators must not appears twice in a row Supported file types: jpeg, jpg, png, bmp, gif, mp3, webp, and bin.
   */
  createBinary(data) {
    const params = {};
    const url = "/cloudsave/v1/namespaces/{namespace}/binaries".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.post(url, data, { params });
    return Validate11.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      UploadBinaryRecordResponse,
      "UploadBinaryRecordResponse"
    );
  }
  /**
   * Bulk get game binary records. Maximum key per request 20.
   */
  createBinaryBulk(data) {
    const params = {};
    const url = "/cloudsave/v1/namespaces/{namespace}/binaries/bulk".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.post(url, data, { params });
    return Validate11.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      BulkGetGameBinaryRecordResponse,
      "BulkGetGameBinaryRecordResponse"
    );
  }
  /**
   * Delete a game binary record.
   */
  deleteBinary_ByKey(key) {
    const params = {};
    const url = "/cloudsave/v1/namespaces/{namespace}/binaries/{key}".replace("{namespace}", this.namespace).replace("{key}", key);
    const resultPromise = this.axiosInstance.delete(url, { params });
    return Validate11.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, z48.unknown(), "z.unknown()");
  }
  /**
   * Get a game binary record by its key.
   */
  getBinary_ByKey(key) {
    const params = {};
    const url = "/cloudsave/v1/namespaces/{namespace}/binaries/{key}".replace("{namespace}", this.namespace).replace("{key}", key);
    const resultPromise = this.axiosInstance.get(url, { params });
    return Validate11.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      GameBinaryRecordResponse,
      "GameBinaryRecordResponse"
    );
  }
  /**
   * Update a game binary record file by its key
   */
  updateBinary_ByKey(key, data) {
    const params = {};
    const url = "/cloudsave/v1/namespaces/{namespace}/binaries/{key}".replace("{namespace}", this.namespace).replace("{key}", key);
    const resultPromise = this.axiosInstance.put(url, data, { params });
    return Validate11.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      GameBinaryRecordResponse,
      "GameBinaryRecordResponse"
    );
  }
  /**
   * Request presigned URL to upload the binary record to s3. Other detail info: Supported file types: jpeg, jpg, png, bmp, gif, mp3, webp, and bin.
   */
  createPresigned_ByKey(key, data) {
    const params = {};
    const url = "/cloudsave/v1/namespaces/{namespace}/binaries/{key}/presigned".replace("{namespace}", this.namespace).replace("{key}", key);
    const resultPromise = this.axiosInstance.post(url, data, { params });
    return Validate11.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      UploadBinaryRecordResponse,
      "UploadBinaryRecordResponse"
    );
  }
};

// src/generated-public/PublicGameBinaryRecordApi.ts
import { ApiUtils as ApiUtils11, Network as Network11 } from "@accelbyte/sdk";
function PublicGameBinaryRecordApi(sdk, args) {
  const sdkAssembly = sdk.assembly();
  const namespace = args?.coreConfig?.namespace ?? sdkAssembly.coreConfig.namespace;
  const useSchemaValidation = args?.coreConfig?.useSchemaValidation ?? sdkAssembly.coreConfig.useSchemaValidation;
  let axiosInstance = sdkAssembly.axiosInstance;
  const requestConfigOverrides = args?.axiosConfig?.request;
  const baseURLOverride = args?.coreConfig?.baseURL;
  const interceptorsOverride = args?.axiosConfig?.interceptors ?? [];
  if (requestConfigOverrides || baseURLOverride || interceptorsOverride.length > 0) {
    const requestConfig = ApiUtils11.mergeAxiosConfigs(sdkAssembly.axiosInstance.defaults, {
      ...baseURLOverride ? { baseURL: baseURLOverride } : {},
      ...requestConfigOverrides
    });
    axiosInstance = Network11.create(requestConfig);
    for (const interceptor of interceptorsOverride) {
      if (interceptor.type === "request") {
        axiosInstance.interceptors.request.use(interceptor.onRequest, interceptor.onError);
      }
      if (interceptor.type === "response") {
        axiosInstance.interceptors.response.use(interceptor.onSuccess, interceptor.onError);
      }
    }
  }
  async function getBinaries(queryParams) {
    const $ = new PublicGameBinaryRecord$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getBinaries(queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function createBinary(data) {
    const $ = new PublicGameBinaryRecord$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.createBinary(data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function createBinaryBulk(data) {
    const $ = new PublicGameBinaryRecord$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.createBinaryBulk(data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function deleteBinary_ByKey(key) {
    const $ = new PublicGameBinaryRecord$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.deleteBinary_ByKey(key);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getBinary_ByKey(key) {
    const $ = new PublicGameBinaryRecord$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getBinary_ByKey(key);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function updateBinary_ByKey(key, data) {
    const $ = new PublicGameBinaryRecord$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.updateBinary_ByKey(key, data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function createPresigned_ByKey(key, data) {
    const $ = new PublicGameBinaryRecord$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.createPresigned_ByKey(key, data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  return {
    /**
     * Retrieve list of binary records by namespace.
     */
    getBinaries,
    /**
     * Create a game binary record. Other detail info: `key` should follow these rules: 1. support uppercase and lowercase letters, numbers, and separators **&#34;-&#34;**, **&#34;_&#34;**, **&#34;.&#34;** are allowed 2. begin and end with letters or numbers 3. spaces are not allowed 4. separators must not appears twice in a row Supported file types: jpeg, jpg, png, bmp, gif, mp3, webp, and bin.
     */
    createBinary,
    /**
     * Bulk get game binary records. Maximum key per request 20.
     */
    createBinaryBulk,
    /**
     * Delete a game binary record.
     */
    deleteBinary_ByKey,
    /**
     * Get a game binary record by its key.
     */
    getBinary_ByKey,
    /**
     * Update a game binary record file by its key
     */
    updateBinary_ByKey,
    /**
     * Request presigned URL to upload the binary record to s3. Other detail info: Supported file types: jpeg, jpg, png, bmp, gif, mp3, webp, and bin.
     */
    createPresigned_ByKey
  };
}

// src/generated-definitions/GameRecordResponse.ts
import { z as z49 } from "zod";
var GameRecordResponse = z49.object({
  created_at: z49.string(),
  key: z49.string(),
  namespace: z49.string(),
  set_by: z49.enum(["CLIENT", "SERVER"]).nullish(),
  tags: z49.array(z49.string()).nullish(),
  updated_at: z49.string(),
  value: z49.record(z49.any())
});

// src/generated-definitions/BulkGetGameRecordResponse.ts
import { z as z50 } from "zod";
var BulkGetGameRecordResponse = z50.object({ data: z50.array(GameRecordResponse) });

// src/generated-public/endpoints/PublicGameRecord$.ts
import { Validate as Validate12 } from "@accelbyte/sdk";
import { z as z51 } from "zod";
var PublicGameRecord$ = class {
  // @ts-ignore
  // prettier-ignore
  constructor(axiosInstance, namespace, useSchemaValidation = true) {
    this.axiosInstance = axiosInstance;
    this.namespace = namespace;
    this.useSchemaValidation = useSchemaValidation;
  }
  /**
   * Bulk get game records. Maximum key per request 20.
   */
  fetchRecordBulk(data) {
    const params = {};
    const url = "/cloudsave/v1/namespaces/{namespace}/records/bulk".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.post(url, data, { params });
    return Validate12.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      BulkGetGameRecordResponse,
      "BulkGetGameRecordResponse"
    );
  }
  /**
   * Delete records by its key
   */
  deleteRecord_ByKey(key) {
    const params = {};
    const url = "/cloudsave/v1/namespaces/{namespace}/records/{key}".replace("{namespace}", this.namespace).replace("{key}", key);
    const resultPromise = this.axiosInstance.delete(url, { params });
    return Validate12.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, z51.unknown(), "z.unknown()");
  }
  /**
   * Get game record by its key.
   */
  getRecord_ByKey(key) {
    const params = {};
    const url = "/cloudsave/v1/namespaces/{namespace}/records/{key}".replace("{namespace}", this.namespace).replace("{key}", key);
    const resultPromise = this.axiosInstance.get(url, { params });
    return Validate12.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, GameRecordResponse, "GameRecordResponse");
  }
  /**
   * ## Description This endpoints will create new game record or append the existing game record. **Append example:** Example 1 - Existing JSON: `{ &#34;data1&#34;: &#34;value&#34; }` - New JSON: `{ &#34;data2&#34;: &#34;new value&#34; }` - Result: `{ &#34;data1&#34;: &#34;value&#34;, &#34;data2&#34;: &#34;new value&#34; }` Example 2 - Existing JSON: `{ &#34;data1&#34;: { &#34;data2&#34;: &#34;value&#34; }` - New JSON: `{ &#34;data1&#34;: { &#34;data3&#34;: &#34;new value&#34; }` - Result: `{ &#34;data1&#34;: { &#34;data2&#34;: &#34;value&#34;, &#34;data3&#34;: &#34;new value&#34; }` ## Restriction This is the restriction of Key Naming for the record: 1. Cannot use **&#34;.&#34;** as the key name - `{ &#34;data.2&#34;: &#34;value&#34; }` 2. Cannot use **&#34;$&#34;** as the prefix in key names - `{ &#34;$data&#34;: &#34;value&#34; }` 3. Cannot use empty string in key names - `{ &#34;&#34;: &#34;value&#34; }` ## Reserved Word Reserved Word List: **__META** The reserved word cannot be used as a field in record value, If still defining the field when creating or updating the record, it will be ignored.
   */
  createRecord_ByKey(key, data) {
    const params = {};
    const url = "/cloudsave/v1/namespaces/{namespace}/records/{key}".replace("{namespace}", this.namespace).replace("{key}", key);
    const resultPromise = this.axiosInstance.post(url, data, { params });
    return Validate12.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, GameRecordResponse, "GameRecordResponse");
  }
  /**
   * ## Description This endpoints will create new game record or replace the existing game record. **Replace behaviour:** The existing value will be replaced completely with the new value. Example - Existing JSON: `{ &#34;data1&#34;: &#34;value&#34; }` - New JSON: `{ &#34;data2&#34;: &#34;new value&#34; }` - Result: `{ &#34;data2&#34;: &#34;new value&#34; }` ## Restriction This is the restriction of Key Naming for the record: 1. Cannot use **&#34;.&#34;** as the key name - `{ &#34;data.2&#34;: &#34;value&#34; }` 2. Cannot use **&#34;$&#34;** as the prefix in key names - `{ &#34;$data&#34;: &#34;value&#34; }` 3. Cannot use empty string in key names - `{ &#34;&#34;: &#34;value&#34; }` ## Reserved Word Reserved Word List: **__META** The reserved word cannot be used as a field in record value, If still defining the field when creating or updating the record, it will be ignored.
   */
  updateRecord_ByKey(key, data) {
    const params = {};
    const url = "/cloudsave/v1/namespaces/{namespace}/records/{key}".replace("{namespace}", this.namespace).replace("{key}", key);
    const resultPromise = this.axiosInstance.put(url, data, { params });
    return Validate12.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, GameRecordResponse, "GameRecordResponse");
  }
};

// src/generated-public/PublicGameRecordApi.ts
import { ApiUtils as ApiUtils12, Network as Network12 } from "@accelbyte/sdk";
function PublicGameRecordApi(sdk, args) {
  const sdkAssembly = sdk.assembly();
  const namespace = args?.coreConfig?.namespace ?? sdkAssembly.coreConfig.namespace;
  const useSchemaValidation = args?.coreConfig?.useSchemaValidation ?? sdkAssembly.coreConfig.useSchemaValidation;
  let axiosInstance = sdkAssembly.axiosInstance;
  const requestConfigOverrides = args?.axiosConfig?.request;
  const baseURLOverride = args?.coreConfig?.baseURL;
  const interceptorsOverride = args?.axiosConfig?.interceptors ?? [];
  if (requestConfigOverrides || baseURLOverride || interceptorsOverride.length > 0) {
    const requestConfig = ApiUtils12.mergeAxiosConfigs(sdkAssembly.axiosInstance.defaults, {
      ...baseURLOverride ? { baseURL: baseURLOverride } : {},
      ...requestConfigOverrides
    });
    axiosInstance = Network12.create(requestConfig);
    for (const interceptor of interceptorsOverride) {
      if (interceptor.type === "request") {
        axiosInstance.interceptors.request.use(interceptor.onRequest, interceptor.onError);
      }
      if (interceptor.type === "response") {
        axiosInstance.interceptors.response.use(interceptor.onSuccess, interceptor.onError);
      }
    }
  }
  async function fetchRecordBulk(data) {
    const $ = new PublicGameRecord$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.fetchRecordBulk(data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function deleteRecord_ByKey(key) {
    const $ = new PublicGameRecord$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.deleteRecord_ByKey(key);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getRecord_ByKey(key) {
    const $ = new PublicGameRecord$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getRecord_ByKey(key);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function createRecord_ByKey(key, data) {
    const $ = new PublicGameRecord$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.createRecord_ByKey(key, data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function updateRecord_ByKey(key, data) {
    const $ = new PublicGameRecord$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.updateRecord_ByKey(key, data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  return {
    /**
     * Bulk get game records. Maximum key per request 20.
     */
    fetchRecordBulk,
    /**
     * Delete records by its key
     */
    deleteRecord_ByKey,
    /**
     * Get game record by its key.
     */
    getRecord_ByKey,
    /**
     * ## Description This endpoints will create new game record or append the existing game record. **Append example:** Example 1 - Existing JSON: `{ &#34;data1&#34;: &#34;value&#34; }` - New JSON: `{ &#34;data2&#34;: &#34;new value&#34; }` - Result: `{ &#34;data1&#34;: &#34;value&#34;, &#34;data2&#34;: &#34;new value&#34; }` Example 2 - Existing JSON: `{ &#34;data1&#34;: { &#34;data2&#34;: &#34;value&#34; }` - New JSON: `{ &#34;data1&#34;: { &#34;data3&#34;: &#34;new value&#34; }` - Result: `{ &#34;data1&#34;: { &#34;data2&#34;: &#34;value&#34;, &#34;data3&#34;: &#34;new value&#34; }` ## Restriction This is the restriction of Key Naming for the record: 1. Cannot use **&#34;.&#34;** as the key name - `{ &#34;data.2&#34;: &#34;value&#34; }` 2. Cannot use **&#34;$&#34;** as the prefix in key names - `{ &#34;$data&#34;: &#34;value&#34; }` 3. Cannot use empty string in key names - `{ &#34;&#34;: &#34;value&#34; }` ## Reserved Word Reserved Word List: **__META** The reserved word cannot be used as a field in record value, If still defining the field when creating or updating the record, it will be ignored.
     */
    createRecord_ByKey,
    /**
     * ## Description This endpoints will create new game record or replace the existing game record. **Replace behaviour:** The existing value will be replaced completely with the new value. Example - Existing JSON: `{ &#34;data1&#34;: &#34;value&#34; }` - New JSON: `{ &#34;data2&#34;: &#34;new value&#34; }` - Result: `{ &#34;data2&#34;: &#34;new value&#34; }` ## Restriction This is the restriction of Key Naming for the record: 1. Cannot use **&#34;.&#34;** as the key name - `{ &#34;data.2&#34;: &#34;value&#34; }` 2. Cannot use **&#34;$&#34;** as the prefix in key names - `{ &#34;$data&#34;: &#34;value&#34; }` 3. Cannot use empty string in key names - `{ &#34;&#34;: &#34;value&#34; }` ## Reserved Word Reserved Word List: **__META** The reserved word cannot be used as a field in record value, If still defining the field when creating or updating the record, it will be ignored.
     */
    updateRecord_ByKey
  };
}

// src/generated-definitions/BulkGetPlayerBinaryRecordResponse.ts
import { z as z52 } from "zod";
var BulkGetPlayerBinaryRecordResponse = z52.object({ data: z52.array(PlayerBinaryRecordResponse) });

// src/generated-public/endpoints/PublicPlayerBinaryRecord$.ts
import { Validate as Validate13 } from "@accelbyte/sdk";
import { z as z53 } from "zod";
var PublicPlayerBinaryRecord$ = class {
  // @ts-ignore
  // prettier-ignore
  constructor(axiosInstance, namespace, useSchemaValidation = true) {
    this.axiosInstance = axiosInstance;
    this.namespace = namespace;
    this.useSchemaValidation = useSchemaValidation;
  }
  /**
   * Retrieve list of my binary records by namespace.
   */
  getUsersMeBinaries(queryParams) {
    const params = { limit: 25, ...queryParams };
    const url = "/cloudsave/v1/namespaces/{namespace}/users/me/binaries".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.get(url, { params });
    return Validate13.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      ListPlayerBinaryRecordsResponse,
      "ListPlayerBinaryRecordsResponse"
    );
  }
  /**
   * Retrieve player record key and payload in bulk under given namespace. Maximum bulk key limit per request 20
   */
  createUserMeBinaryBulk(data) {
    const params = {};
    const url = "/cloudsave/v1/namespaces/{namespace}/users/me/binaries/bulk".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.post(url, data, { params });
    return Validate13.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      BulkGetPlayerBinaryRecordResponse,
      "BulkGetPlayerBinaryRecordResponse"
    );
  }
  /**
   * Create a player binary record. Other detail info: `key` should follow these rules: 1. support uppercase and lowercase letters, numbers, and separators **&#34;-&#34;**, **&#34;_&#34;**, **&#34;.&#34;** are allowed 2. begin and end with letters or numbers 3. spaces are not allowed 4. separators must not appears twice in a row Supported file types: jpeg, jpg, png, bmp, gif, mp3, webp, and bin.
   */
  createBinary_ByUserId(userId, data) {
    const params = {};
    const url = "/cloudsave/v1/namespaces/{namespace}/users/{userId}/binaries".replace("{namespace}", this.namespace).replace("{userId}", userId);
    const resultPromise = this.axiosInstance.post(url, data, { params });
    return Validate13.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      UploadBinaryRecordResponse,
      "UploadBinaryRecordResponse"
    );
  }
  /**
   * Delete a player binary record. Only player who own the record can delete it
   */
  deleteBinary_ByUserId_ByKey(userId, key) {
    const params = {};
    const url = "/cloudsave/v1/namespaces/{namespace}/users/{userId}/binaries/{key}".replace("{namespace}", this.namespace).replace("{userId}", userId).replace("{key}", key);
    const resultPromise = this.axiosInstance.delete(url, { params });
    return Validate13.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, z53.unknown(), "z.unknown()");
  }
  /**
   * Get a player binary record by its key. **Private Record**: Only user who own the record could retrieve it.
   */
  getBinary_ByUserId_ByKey(userId, key) {
    const params = {};
    const url = "/cloudsave/v1/namespaces/{namespace}/users/{userId}/binaries/{key}".replace("{namespace}", this.namespace).replace("{userId}", userId).replace("{key}", key);
    const resultPromise = this.axiosInstance.get(url, { params });
    return Validate13.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      PlayerBinaryRecordResponse,
      "PlayerBinaryRecordResponse"
    );
  }
  /**
   * Update a player binary record file by its key
   */
  updateBinary_ByUserId_ByKey(userId, key, data) {
    const params = {};
    const url = "/cloudsave/v1/namespaces/{namespace}/users/{userId}/binaries/{key}".replace("{namespace}", this.namespace).replace("{userId}", userId).replace("{key}", key);
    const resultPromise = this.axiosInstance.put(url, data, { params });
    return Validate13.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      PlayerBinaryRecordResponse,
      "PlayerBinaryRecordResponse"
    );
  }
  /**
   * Retrieve list of other player public binary records under given namespace.
   */
  getBinariesPublic_ByUserId(userId, queryParams) {
    const params = { limit: 25, ...queryParams };
    const url = "/cloudsave/v1/namespaces/{namespace}/users/{userId}/binaries/public".replace("{namespace}", this.namespace).replace("{userId}", userId);
    const resultPromise = this.axiosInstance.get(url, { params });
    return Validate13.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      ListPlayerBinaryRecordsResponse,
      "ListPlayerBinaryRecordsResponse"
    );
  }
  /**
   * Bulk get other player&#39;s public binary record by userIds, max allowed 20 at a time. Only record with `isPublic=true` can be retrieved using this endpoint.
   */
  fetchPublicBulkUser_ByKey(key, data) {
    const params = {};
    const url = "/cloudsave/v1/namespaces/{namespace}/users/bulk/binaries/{key}/public".replace("{namespace}", this.namespace).replace("{key}", key);
    const resultPromise = this.axiosInstance.post(url, data, { params });
    return Validate13.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      BulkGetPlayerBinaryRecordResponse,
      "BulkGetPlayerBinaryRecordResponse"
    );
  }
  /**
   * Retrieve other player public binary record in bulk under given namespace. Maximum bulk key limit per request 20
   */
  fetchBinaryBulk_ByUserId(userId, data) {
    const params = {};
    const url = "/cloudsave/v1/namespaces/{namespace}/users/{userId}/binaries/public/bulk".replace("{namespace}", this.namespace).replace("{userId}", userId);
    const resultPromise = this.axiosInstance.post(url, data, { params });
    return Validate13.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      BulkGetPlayerBinaryRecordResponse,
      "BulkGetPlayerBinaryRecordResponse"
    );
  }
  /**
   * Get other player&#39;s public binary record. Only record with `isPublic=true` can be retrieved using this endpoint.
   */
  getPublic_ByUserId_ByKey(userId, key) {
    const params = {};
    const url = "/cloudsave/v1/namespaces/{namespace}/users/{userId}/binaries/{key}/public".replace("{namespace}", this.namespace).replace("{userId}", userId).replace("{key}", key);
    const resultPromise = this.axiosInstance.get(url, { params });
    return Validate13.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      PlayerBinaryRecordResponse,
      "PlayerBinaryRecordResponse"
    );
  }
  /**
   * Update a player binary record metadata by its key
   */
  updateMetadata_ByUserId_ByKey(userId, key, data) {
    const params = {};
    const url = "/cloudsave/v1/namespaces/{namespace}/users/{userId}/binaries/{key}/metadata".replace("{namespace}", this.namespace).replace("{userId}", userId).replace("{key}", key);
    const resultPromise = this.axiosInstance.put(url, data, { params });
    return Validate13.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      PlayerBinaryRecordResponse,
      "PlayerBinaryRecordResponse"
    );
  }
  /**
   * Request presigned URL to upload the binary record to s3. Other detail info: Supported file types: jpeg, jpg, png, bmp, gif, mp3, webp, and bin.
   */
  createPresigned_ByUserId_ByKey(userId, key, data) {
    const params = {};
    const url = "/cloudsave/v1/namespaces/{namespace}/users/{userId}/binaries/{key}/presigned".replace("{namespace}", this.namespace).replace("{userId}", userId).replace("{key}", key);
    const resultPromise = this.axiosInstance.post(url, data, { params });
    return Validate13.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      UploadBinaryRecordResponse,
      "UploadBinaryRecordResponse"
    );
  }
};

// src/generated-public/PublicPlayerBinaryRecordApi.ts
import { ApiUtils as ApiUtils13, Network as Network13 } from "@accelbyte/sdk";
function PublicPlayerBinaryRecordApi(sdk, args) {
  const sdkAssembly = sdk.assembly();
  const namespace = args?.coreConfig?.namespace ?? sdkAssembly.coreConfig.namespace;
  const useSchemaValidation = args?.coreConfig?.useSchemaValidation ?? sdkAssembly.coreConfig.useSchemaValidation;
  let axiosInstance = sdkAssembly.axiosInstance;
  const requestConfigOverrides = args?.axiosConfig?.request;
  const baseURLOverride = args?.coreConfig?.baseURL;
  const interceptorsOverride = args?.axiosConfig?.interceptors ?? [];
  if (requestConfigOverrides || baseURLOverride || interceptorsOverride.length > 0) {
    const requestConfig = ApiUtils13.mergeAxiosConfigs(sdkAssembly.axiosInstance.defaults, {
      ...baseURLOverride ? { baseURL: baseURLOverride } : {},
      ...requestConfigOverrides
    });
    axiosInstance = Network13.create(requestConfig);
    for (const interceptor of interceptorsOverride) {
      if (interceptor.type === "request") {
        axiosInstance.interceptors.request.use(interceptor.onRequest, interceptor.onError);
      }
      if (interceptor.type === "response") {
        axiosInstance.interceptors.response.use(interceptor.onSuccess, interceptor.onError);
      }
    }
  }
  async function getUsersMeBinaries(queryParams) {
    const $ = new PublicPlayerBinaryRecord$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getUsersMeBinaries(queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function createUserMeBinaryBulk(data) {
    const $ = new PublicPlayerBinaryRecord$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.createUserMeBinaryBulk(data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function createBinary_ByUserId(userId, data) {
    const $ = new PublicPlayerBinaryRecord$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.createBinary_ByUserId(userId, data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function deleteBinary_ByUserId_ByKey(userId, key) {
    const $ = new PublicPlayerBinaryRecord$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.deleteBinary_ByUserId_ByKey(userId, key);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getBinary_ByUserId_ByKey(userId, key) {
    const $ = new PublicPlayerBinaryRecord$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getBinary_ByUserId_ByKey(userId, key);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function updateBinary_ByUserId_ByKey(userId, key, data) {
    const $ = new PublicPlayerBinaryRecord$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.updateBinary_ByUserId_ByKey(userId, key, data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getBinariesPublic_ByUserId(userId, queryParams) {
    const $ = new PublicPlayerBinaryRecord$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getBinariesPublic_ByUserId(userId, queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function fetchPublicBulkUser_ByKey(key, data) {
    const $ = new PublicPlayerBinaryRecord$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.fetchPublicBulkUser_ByKey(key, data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function fetchBinaryBulk_ByUserId(userId, data) {
    const $ = new PublicPlayerBinaryRecord$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.fetchBinaryBulk_ByUserId(userId, data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getPublic_ByUserId_ByKey(userId, key) {
    const $ = new PublicPlayerBinaryRecord$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getPublic_ByUserId_ByKey(userId, key);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function updateMetadata_ByUserId_ByKey(userId, key, data) {
    const $ = new PublicPlayerBinaryRecord$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.updateMetadata_ByUserId_ByKey(userId, key, data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function createPresigned_ByUserId_ByKey(userId, key, data) {
    const $ = new PublicPlayerBinaryRecord$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.createPresigned_ByUserId_ByKey(userId, key, data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  return {
    /**
     * Retrieve list of my binary records by namespace.
     */
    getUsersMeBinaries,
    /**
     * Retrieve player record key and payload in bulk under given namespace. Maximum bulk key limit per request 20
     */
    createUserMeBinaryBulk,
    /**
     * Create a player binary record. Other detail info: `key` should follow these rules: 1. support uppercase and lowercase letters, numbers, and separators **&#34;-&#34;**, **&#34;_&#34;**, **&#34;.&#34;** are allowed 2. begin and end with letters or numbers 3. spaces are not allowed 4. separators must not appears twice in a row Supported file types: jpeg, jpg, png, bmp, gif, mp3, webp, and bin.
     */
    createBinary_ByUserId,
    /**
     * Delete a player binary record. Only player who own the record can delete it
     */
    deleteBinary_ByUserId_ByKey,
    /**
     * Get a player binary record by its key. **Private Record**: Only user who own the record could retrieve it.
     */
    getBinary_ByUserId_ByKey,
    /**
     * Update a player binary record file by its key
     */
    updateBinary_ByUserId_ByKey,
    /**
     * Retrieve list of other player public binary records under given namespace.
     */
    getBinariesPublic_ByUserId,
    /**
     * Bulk get other player&#39;s public binary record by userIds, max allowed 20 at a time. Only record with `isPublic=true` can be retrieved using this endpoint.
     */
    fetchPublicBulkUser_ByKey,
    /**
     * Retrieve other player public binary record in bulk under given namespace. Maximum bulk key limit per request 20
     */
    fetchBinaryBulk_ByUserId,
    /**
     * Get other player&#39;s public binary record. Only record with `isPublic=true` can be retrieved using this endpoint.
     */
    getPublic_ByUserId_ByKey,
    /**
     * Update a player binary record metadata by its key
     */
    updateMetadata_ByUserId_ByKey,
    /**
     * Request presigned URL to upload the binary record to s3. Other detail info: Supported file types: jpeg, jpg, png, bmp, gif, mp3, webp, and bin.
     */
    createPresigned_ByUserId_ByKey
  };
}

// src/generated-public/endpoints/PublicPlayerRecord$.ts
import { Validate as Validate14 } from "@accelbyte/sdk";
import { z as z54 } from "zod";
var PublicPlayerRecord$ = class {
  // @ts-ignore
  // prettier-ignore
  constructor(axiosInstance, namespace, useSchemaValidation = true) {
    this.axiosInstance = axiosInstance;
    this.namespace = namespace;
    this.useSchemaValidation = useSchemaValidation;
  }
  /**
   * Retrieve list of player records key under given namespace.
   */
  getUsersMeRecords(queryParams) {
    const params = { limit: 25, ...queryParams };
    const url = "/cloudsave/v1/namespaces/{namespace}/users/me/records".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.get(url, { params });
    return Validate14.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      ListPlayerRecordKeysResponse,
      "ListPlayerRecordKeysResponse"
    );
  }
  /**
   * Retrieve player record key and payload in bulk under given namespace. Maximum bulk key limit per request 20
   */
  createUserMeRecordBulk(data) {
    const params = {};
    const url = "/cloudsave/v1/namespaces/{namespace}/users/me/records/bulk".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.post(url, data, { params });
    return Validate14.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      BulkGetPlayerRecordResponse,
      "BulkGetPlayerRecordResponse"
    );
  }
  /**
   * Delete player record by its key. Only user that own the player record could delete it.
   */
  deleteRecord_ByUserId_ByKey(userId, key) {
    const params = {};
    const url = "/cloudsave/v1/namespaces/{namespace}/users/{userId}/records/{key}".replace("{namespace}", this.namespace).replace("{userId}", userId).replace("{key}", key);
    const resultPromise = this.axiosInstance.delete(url, { params });
    return Validate14.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, z54.unknown(), "z.unknown()");
  }
  /**
   * Get player record by its key. **Private Record**: Only user that own the player record could retrieve it.
   */
  getRecord_ByUserId_ByKey(userId, key) {
    const params = {};
    const url = "/cloudsave/v1/namespaces/{namespace}/users/{userId}/records/{key}".replace("{namespace}", this.namespace).replace("{userId}", userId).replace("{key}", key);
    const resultPromise = this.axiosInstance.get(url, { params });
    return Validate14.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, PlayerRecordResponse, "PlayerRecordResponse");
  }
  /**
   * ## Description This endpoints will create new player record or append the existing player record. Only user that own the existing player record could modify. **Append example:** Example 1 - Existing JSON: `{ &#34;data1&#34;: &#34;value&#34; }` - New JSON: `{ &#34;data2&#34;: &#34;new value&#34; }` - Result: `{ &#34;data1&#34;: &#34;value&#34;, &#34;data2&#34;: &#34;new value&#34; }` Example 2 - Existing JSON: `{ &#34;data1&#34;: { &#34;data2&#34;: &#34;value&#34; }` - New JSON: `{ &#34;data1&#34;: { &#34;data3&#34;: &#34;new value&#34; }` - Result: `{ &#34;data1&#34;: { &#34;data2&#34;: &#34;value&#34;, &#34;data3&#34;: &#34;new value&#34; }` ## Restriction This is the restriction of Key Naming for the record: 1. Cannot use **&#34;.&#34;** as the key name - `{ &#34;data.2&#34;: &#34;value&#34; }` 2. Cannot use **&#34;$&#34;** as the prefix in key names - `{ &#34;$data&#34;: &#34;value&#34; }` 3. Cannot use empty string in key names - `{ &#34;&#34;: &#34;value&#34; }` ## Record Metadata Metadata allows user to define the behaviour of the record. Metadata can be defined in request body with field name **__META**. When creating record, if **__META** field is not defined, the metadata value will use the default value. When updating record, if **__META** field is not defined, the existing metadata value will stay as is. **Metadata List:** 1. is_public (default: false, type: bool) Indicate whether the player record is a public record or not. **Request Body Example:** ``` { &#34;__META&#34;: { &#34;is_public&#34;: true } ... } ```
   */
  createRecord_ByUserId_ByKey(userId, key, data) {
    const params = {};
    const url = "/cloudsave/v1/namespaces/{namespace}/users/{userId}/records/{key}".replace("{namespace}", this.namespace).replace("{userId}", userId).replace("{key}", key);
    const resultPromise = this.axiosInstance.post(url, data, { params });
    return Validate14.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, PlayerRecordResponse, "PlayerRecordResponse");
  }
  /**
   * ## Description This endpoints will create new player record or replace the existing player record. Only user that own the existing player record could modify it. **Replace behaviour:** The existing value will be replaced completely with the new value. Example - Existing JSON: `{ &#34;data1&#34;: &#34;value&#34; }` - New JSON: `{ &#34;data2&#34;: &#34;new value&#34; }` - Result: `{ &#34;data2&#34;: &#34;new value&#34; }` ## Restriction This is the restriction of Key Naming for the record: 1. Cannot use **&#34;.&#34;** as the key name - `{ &#34;data.2&#34;: &#34;value&#34; }` 2. Cannot use **&#34;$&#34;** as the prefix in key names - `{ &#34;$data&#34;: &#34;value&#34; }` 3. Cannot use empty string in key names - `{ &#34;&#34;: &#34;value&#34; }` ## Record Metadata Metadata allows user to define the behaviour of the record. Metadata can be defined in request body with field name **__META**. When creating record, if **__META** field is not defined, the metadata value will use the default value. When updating record, if **__META** field is not defined, the existing metadata value will stay as is. **Metadata List:** 1. is_public (default: false, type: bool) Indicate whether the player record is a public record or not. **Request Body Example:** ``` { &#34;__META&#34;: { &#34;is_public&#34;: true } ... } ```
   */
  updateRecord_ByUserId_ByKey(userId, key, data) {
    const params = {};
    const url = "/cloudsave/v1/namespaces/{namespace}/users/{userId}/records/{key}".replace("{namespace}", this.namespace).replace("{userId}", userId).replace("{key}", key);
    const resultPromise = this.axiosInstance.put(url, data, { params });
    return Validate14.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, PlayerRecordResponse, "PlayerRecordResponse");
  }
  /**
   * Retrieve list of other public player records key under given namespace.
   */
  getRecordsPublic_ByUserId(userId, queryParams) {
    const params = { limit: 25, ...queryParams };
    const url = "/cloudsave/v1/namespaces/{namespace}/users/{userId}/records/public".replace("{namespace}", this.namespace).replace("{userId}", userId);
    const resultPromise = this.axiosInstance.get(url, { params });
    return Validate14.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      ListPlayerRecordKeysResponse,
      "ListPlayerRecordKeysResponse"
    );
  }
  /**
   * Delete player public record. ## Warning: This endpoint is going to deprecate This endpoint is going to deprecate in the future please don&#39;t use it. For alternative, please use these endpoints: - **POST /cloudsave/v1/namespaces/{namespace}/users/{userId}/records/{key}** and utilizing **__META** functionality - **PUT /cloudsave/v1/namespaces/{namespace}/users/{userId}/records/{key}** and utilizing **__META** functionality - **DELETE /cloudsave/v1/namespaces/{namespace}/users/{userId}/records/{key}**
   */
  deletePublicMeUser_ByKey(key) {
    const params = {};
    const url = "/cloudsave/v1/namespaces/{namespace}/users/me/records/{key}/public".replace("{namespace}", this.namespace).replace("{key}", key);
    const resultPromise = this.axiosInstance.delete(url, { params });
    return Validate14.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, z54.unknown(), "z.unknown()");
  }
  /**
   * Bulk get other player&#39;s record that is public by userIds, max allowed 20 at a time. Only record with `isPublic=true` that can be retrieved using this endpoint.
   */
  fetchPublicBulkUser_ByKey(key, data) {
    const params = {};
    const url = "/cloudsave/v1/namespaces/{namespace}/users/bulk/records/{key}/public".replace("{namespace}", this.namespace).replace("{key}", key);
    const resultPromise = this.axiosInstance.post(url, data, { params });
    return Validate14.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      BulkGetPlayerRecordResponse,
      "BulkGetPlayerRecordResponse"
    );
  }
  /**
   * Retrieve other player public record key and payload in bulk under given namespace. Maximum bulk key limit per request 20
   */
  fetchRecordBulk_ByUserId(userId, data) {
    const params = {};
    const url = "/cloudsave/v1/namespaces/{namespace}/users/{userId}/records/public/bulk".replace("{namespace}", this.namespace).replace("{userId}", userId);
    const resultPromise = this.axiosInstance.post(url, data, { params });
    return Validate14.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      BulkGetPlayerRecordResponse,
      "BulkGetPlayerRecordResponse"
    );
  }
  /**
   * Get other player&#39;s record that is public. Only record with `isPublic=true` that can be retrieved using this endpoint.
   */
  getPublic_ByUserId_ByKey(userId, key) {
    const params = {};
    const url = "/cloudsave/v1/namespaces/{namespace}/users/{userId}/records/{key}/public".replace("{namespace}", this.namespace).replace("{userId}", userId).replace("{key}", key);
    const resultPromise = this.axiosInstance.get(url, { params });
    return Validate14.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, PlayerRecordResponse, "PlayerRecordResponse");
  }
  /**
   * ## Description This endpoints will create new player public record or append the existing player public record. **Append example:** Example 1 - Existing JSON: `{ &#34;data1&#34;: &#34;value&#34; }` - New JSON: `{ &#34;data2&#34;: &#34;new value&#34; }` - Result: `{ &#34;data1&#34;: &#34;value&#34;, &#34;data2&#34;: &#34;new value&#34; }` Example 2 - Existing JSON: `{ &#34;data1&#34;: { &#34;data2&#34;: &#34;value&#34; }` - New JSON: `{ &#34;data1&#34;: { &#34;data3&#34;: &#34;new value&#34; }` - Result: `{ &#34;data1&#34;: { &#34;data2&#34;: &#34;value&#34;, &#34;data3&#34;: &#34;new value&#34; }` ## Restriction This is the restriction of Key Naming for the record: 1. Cannot use **&#34;.&#34;** as the key name - `{ &#34;data.2&#34;: &#34;value&#34; }` 2. Cannot use **&#34;$&#34;** as the prefix in key names - `{ &#34;$data&#34;: &#34;value&#34; }` 3. Cannot use empty string in key names - `{ &#34;&#34;: &#34;value&#34; }` ## Reserved Word Reserved Word List: **__META** The reserved word cannot be used as a field in record value, If still defining the field when creating or updating the record, it will be ignored. ## Warning: This endpoint is going to deprecate This endpoint is going to deprecate in the future please don&#39;t use it. For alternative, please use these endpoints: - **POST /cloudsave/v1/namespaces/{namespace}/users/{userId}/records/{key}** and utilizing **__META** functionality - **PUT /cloudsave/v1/namespaces/{namespace}/users/{userId}/records/{key}** and utilizing **__META** functionality - **DELETE /cloudsave/v1/namespaces/{namespace}/users/{userId}/records/{key}**
   */
  createPublic_ByUserId_ByKey(userId, key, data) {
    const params = {};
    const url = "/cloudsave/v1/namespaces/{namespace}/users/{userId}/records/{key}/public".replace("{namespace}", this.namespace).replace("{userId}", userId).replace("{key}", key);
    const resultPromise = this.axiosInstance.post(url, data, { params });
    return Validate14.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, PlayerRecordResponse, "PlayerRecordResponse");
  }
  /**
   * ## Description This endpoints will create new player public record or replace the existing player public record. **Replace behaviour:** The existing value will be replaced completely with the new value. Example - Existing JSON: `{ &#34;data1&#34;: &#34;value&#34; }` - New JSON: `{ &#34;data2&#34;: &#34;new value&#34; }` - Result: `{ &#34;data2&#34;: &#34;new value&#34; }` ## Restriction This is the restriction of Key Naming for the record: 1. Cannot use **&#34;.&#34;** as the key name - `{ &#34;data.2&#34;: &#34;value&#34; }` 2. Cannot use **&#34;$&#34;** as the prefix in key names - `{ &#34;$data&#34;: &#34;value&#34; }` 3. Cannot use empty string in key names - `{ &#34;&#34;: &#34;value&#34; }` ## Reserved Word Reserved Word List: **__META** The reserved word cannot be used as a field in record value, If still defining the field when creating or updating the record, it will be ignored. ## Warning: This endpoint is going to deprecate This endpoint is going to deprecate in the future please don&#39;t use it. For alternative, please use these endpoints: - **POST /cloudsave/v1/namespaces/{namespace}/users/{userId}/records/{key}** and utilizing **__META** functionality - **PUT /cloudsave/v1/namespaces/{namespace}/users/{userId}/records/{key}** and utilizing **__META** functionality - **DELETE /cloudsave/v1/namespaces/{namespace}/users/{userId}/records/{key}**
   */
  updatePublic_ByUserId_ByKey(userId, key, data) {
    const params = {};
    const url = "/cloudsave/v1/namespaces/{namespace}/users/{userId}/records/{key}/public".replace("{namespace}", this.namespace).replace("{userId}", userId).replace("{key}", key);
    const resultPromise = this.axiosInstance.put(url, data, { params });
    return Validate14.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, PlayerRecordResponse, "PlayerRecordResponse");
  }
};

// src/generated-public/PublicPlayerRecordApi.ts
import { ApiUtils as ApiUtils14, Network as Network14 } from "@accelbyte/sdk";
function PublicPlayerRecordApi(sdk, args) {
  const sdkAssembly = sdk.assembly();
  const namespace = args?.coreConfig?.namespace ?? sdkAssembly.coreConfig.namespace;
  const useSchemaValidation = args?.coreConfig?.useSchemaValidation ?? sdkAssembly.coreConfig.useSchemaValidation;
  let axiosInstance = sdkAssembly.axiosInstance;
  const requestConfigOverrides = args?.axiosConfig?.request;
  const baseURLOverride = args?.coreConfig?.baseURL;
  const interceptorsOverride = args?.axiosConfig?.interceptors ?? [];
  if (requestConfigOverrides || baseURLOverride || interceptorsOverride.length > 0) {
    const requestConfig = ApiUtils14.mergeAxiosConfigs(sdkAssembly.axiosInstance.defaults, {
      ...baseURLOverride ? { baseURL: baseURLOverride } : {},
      ...requestConfigOverrides
    });
    axiosInstance = Network14.create(requestConfig);
    for (const interceptor of interceptorsOverride) {
      if (interceptor.type === "request") {
        axiosInstance.interceptors.request.use(interceptor.onRequest, interceptor.onError);
      }
      if (interceptor.type === "response") {
        axiosInstance.interceptors.response.use(interceptor.onSuccess, interceptor.onError);
      }
    }
  }
  async function getUsersMeRecords(queryParams) {
    const $ = new PublicPlayerRecord$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getUsersMeRecords(queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function createUserMeRecordBulk(data) {
    const $ = new PublicPlayerRecord$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.createUserMeRecordBulk(data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function deleteRecord_ByUserId_ByKey(userId, key) {
    const $ = new PublicPlayerRecord$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.deleteRecord_ByUserId_ByKey(userId, key);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getRecord_ByUserId_ByKey(userId, key) {
    const $ = new PublicPlayerRecord$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getRecord_ByUserId_ByKey(userId, key);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function createRecord_ByUserId_ByKey(userId, key, data) {
    const $ = new PublicPlayerRecord$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.createRecord_ByUserId_ByKey(userId, key, data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function updateRecord_ByUserId_ByKey(userId, key, data) {
    const $ = new PublicPlayerRecord$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.updateRecord_ByUserId_ByKey(userId, key, data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getRecordsPublic_ByUserId(userId, queryParams) {
    const $ = new PublicPlayerRecord$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getRecordsPublic_ByUserId(userId, queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function deletePublicMeUser_ByKey(key) {
    const $ = new PublicPlayerRecord$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.deletePublicMeUser_ByKey(key);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function fetchPublicBulkUser_ByKey(key, data) {
    const $ = new PublicPlayerRecord$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.fetchPublicBulkUser_ByKey(key, data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function fetchRecordBulk_ByUserId(userId, data) {
    const $ = new PublicPlayerRecord$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.fetchRecordBulk_ByUserId(userId, data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getPublic_ByUserId_ByKey(userId, key) {
    const $ = new PublicPlayerRecord$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getPublic_ByUserId_ByKey(userId, key);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function createPublic_ByUserId_ByKey(userId, key, data) {
    const $ = new PublicPlayerRecord$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.createPublic_ByUserId_ByKey(userId, key, data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function updatePublic_ByUserId_ByKey(userId, key, data) {
    const $ = new PublicPlayerRecord$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.updatePublic_ByUserId_ByKey(userId, key, data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  return {
    /**
     * Retrieve list of player records key under given namespace.
     */
    getUsersMeRecords,
    /**
     * Retrieve player record key and payload in bulk under given namespace. Maximum bulk key limit per request 20
     */
    createUserMeRecordBulk,
    /**
     * Delete player record by its key. Only user that own the player record could delete it.
     */
    deleteRecord_ByUserId_ByKey,
    /**
     * Get player record by its key. **Private Record**: Only user that own the player record could retrieve it.
     */
    getRecord_ByUserId_ByKey,
    /**
     * ## Description This endpoints will create new player record or append the existing player record. Only user that own the existing player record could modify. **Append example:** Example 1 - Existing JSON: `{ &#34;data1&#34;: &#34;value&#34; }` - New JSON: `{ &#34;data2&#34;: &#34;new value&#34; }` - Result: `{ &#34;data1&#34;: &#34;value&#34;, &#34;data2&#34;: &#34;new value&#34; }` Example 2 - Existing JSON: `{ &#34;data1&#34;: { &#34;data2&#34;: &#34;value&#34; }` - New JSON: `{ &#34;data1&#34;: { &#34;data3&#34;: &#34;new value&#34; }` - Result: `{ &#34;data1&#34;: { &#34;data2&#34;: &#34;value&#34;, &#34;data3&#34;: &#34;new value&#34; }` ## Restriction This is the restriction of Key Naming for the record: 1. Cannot use **&#34;.&#34;** as the key name - `{ &#34;data.2&#34;: &#34;value&#34; }` 2. Cannot use **&#34;$&#34;** as the prefix in key names - `{ &#34;$data&#34;: &#34;value&#34; }` 3. Cannot use empty string in key names - `{ &#34;&#34;: &#34;value&#34; }` ## Record Metadata Metadata allows user to define the behaviour of the record. Metadata can be defined in request body with field name **__META**. When creating record, if **__META** field is not defined, the metadata value will use the default value. When updating record, if **__META** field is not defined, the existing metadata value will stay as is. **Metadata List:** 1. is_public (default: false, type: bool) Indicate whether the player record is a public record or not. **Request Body Example:** ``` { &#34;__META&#34;: { &#34;is_public&#34;: true } ... } ```
     */
    createRecord_ByUserId_ByKey,
    /**
     * ## Description This endpoints will create new player record or replace the existing player record. Only user that own the existing player record could modify it. **Replace behaviour:** The existing value will be replaced completely with the new value. Example - Existing JSON: `{ &#34;data1&#34;: &#34;value&#34; }` - New JSON: `{ &#34;data2&#34;: &#34;new value&#34; }` - Result: `{ &#34;data2&#34;: &#34;new value&#34; }` ## Restriction This is the restriction of Key Naming for the record: 1. Cannot use **&#34;.&#34;** as the key name - `{ &#34;data.2&#34;: &#34;value&#34; }` 2. Cannot use **&#34;$&#34;** as the prefix in key names - `{ &#34;$data&#34;: &#34;value&#34; }` 3. Cannot use empty string in key names - `{ &#34;&#34;: &#34;value&#34; }` ## Record Metadata Metadata allows user to define the behaviour of the record. Metadata can be defined in request body with field name **__META**. When creating record, if **__META** field is not defined, the metadata value will use the default value. When updating record, if **__META** field is not defined, the existing metadata value will stay as is. **Metadata List:** 1. is_public (default: false, type: bool) Indicate whether the player record is a public record or not. **Request Body Example:** ``` { &#34;__META&#34;: { &#34;is_public&#34;: true } ... } ```
     */
    updateRecord_ByUserId_ByKey,
    /**
     * Retrieve list of other public player records key under given namespace.
     */
    getRecordsPublic_ByUserId,
    /**
     * Delete player public record. ## Warning: This endpoint is going to deprecate This endpoint is going to deprecate in the future please don&#39;t use it. For alternative, please use these endpoints: - **POST /cloudsave/v1/namespaces/{namespace}/users/{userId}/records/{key}** and utilizing **__META** functionality - **PUT /cloudsave/v1/namespaces/{namespace}/users/{userId}/records/{key}** and utilizing **__META** functionality - **DELETE /cloudsave/v1/namespaces/{namespace}/users/{userId}/records/{key}**
     */
    deletePublicMeUser_ByKey,
    /**
     * Bulk get other player&#39;s record that is public by userIds, max allowed 20 at a time. Only record with `isPublic=true` that can be retrieved using this endpoint.
     */
    fetchPublicBulkUser_ByKey,
    /**
     * Retrieve other player public record key and payload in bulk under given namespace. Maximum bulk key limit per request 20
     */
    fetchRecordBulk_ByUserId,
    /**
     * Get other player&#39;s record that is public. Only record with `isPublic=true` that can be retrieved using this endpoint.
     */
    getPublic_ByUserId_ByKey,
    /**
     * ## Description This endpoints will create new player public record or append the existing player public record. **Append example:** Example 1 - Existing JSON: `{ &#34;data1&#34;: &#34;value&#34; }` - New JSON: `{ &#34;data2&#34;: &#34;new value&#34; }` - Result: `{ &#34;data1&#34;: &#34;value&#34;, &#34;data2&#34;: &#34;new value&#34; }` Example 2 - Existing JSON: `{ &#34;data1&#34;: { &#34;data2&#34;: &#34;value&#34; }` - New JSON: `{ &#34;data1&#34;: { &#34;data3&#34;: &#34;new value&#34; }` - Result: `{ &#34;data1&#34;: { &#34;data2&#34;: &#34;value&#34;, &#34;data3&#34;: &#34;new value&#34; }` ## Restriction This is the restriction of Key Naming for the record: 1. Cannot use **&#34;.&#34;** as the key name - `{ &#34;data.2&#34;: &#34;value&#34; }` 2. Cannot use **&#34;$&#34;** as the prefix in key names - `{ &#34;$data&#34;: &#34;value&#34; }` 3. Cannot use empty string in key names - `{ &#34;&#34;: &#34;value&#34; }` ## Reserved Word Reserved Word List: **__META** The reserved word cannot be used as a field in record value, If still defining the field when creating or updating the record, it will be ignored. ## Warning: This endpoint is going to deprecate This endpoint is going to deprecate in the future please don&#39;t use it. For alternative, please use these endpoints: - **POST /cloudsave/v1/namespaces/{namespace}/users/{userId}/records/{key}** and utilizing **__META** functionality - **PUT /cloudsave/v1/namespaces/{namespace}/users/{userId}/records/{key}** and utilizing **__META** functionality - **DELETE /cloudsave/v1/namespaces/{namespace}/users/{userId}/records/{key}**
     */
    createPublic_ByUserId_ByKey,
    /**
     * ## Description This endpoints will create new player public record or replace the existing player public record. **Replace behaviour:** The existing value will be replaced completely with the new value. Example - Existing JSON: `{ &#34;data1&#34;: &#34;value&#34; }` - New JSON: `{ &#34;data2&#34;: &#34;new value&#34; }` - Result: `{ &#34;data2&#34;: &#34;new value&#34; }` ## Restriction This is the restriction of Key Naming for the record: 1. Cannot use **&#34;.&#34;** as the key name - `{ &#34;data.2&#34;: &#34;value&#34; }` 2. Cannot use **&#34;$&#34;** as the prefix in key names - `{ &#34;$data&#34;: &#34;value&#34; }` 3. Cannot use empty string in key names - `{ &#34;&#34;: &#34;value&#34; }` ## Reserved Word Reserved Word List: **__META** The reserved word cannot be used as a field in record value, If still defining the field when creating or updating the record, it will be ignored. ## Warning: This endpoint is going to deprecate This endpoint is going to deprecate in the future please don&#39;t use it. For alternative, please use these endpoints: - **POST /cloudsave/v1/namespaces/{namespace}/users/{userId}/records/{key}** and utilizing **__META** functionality - **PUT /cloudsave/v1/namespaces/{namespace}/users/{userId}/records/{key}** and utilizing **__META** functionality - **DELETE /cloudsave/v1/namespaces/{namespace}/users/{userId}/records/{key}**
     */
    updatePublic_ByUserId_ByKey
  };
}

// src/generated-public/endpoints/PublicTags$.ts
import { Validate as Validate15 } from "@accelbyte/sdk";
var PublicTags$ = class {
  // @ts-ignore
  // prettier-ignore
  constructor(axiosInstance, namespace, useSchemaValidation = true) {
    this.axiosInstance = axiosInstance;
    this.namespace = namespace;
    this.useSchemaValidation = useSchemaValidation;
  }
  /**
   * ## Description Retrieve list of available tags by namespace
   */
  getTags(queryParams) {
    const params = { limit: 25, ...queryParams };
    const url = "/cloudsave/v1/namespaces/{namespace}/tags".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.get(url, { params });
    return Validate15.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, ListTagsResponse, "ListTagsResponse");
  }
};

// src/generated-public/PublicTagsApi.ts
import { ApiUtils as ApiUtils15, Network as Network15 } from "@accelbyte/sdk";
function PublicTagsApi(sdk, args) {
  const sdkAssembly = sdk.assembly();
  const namespace = args?.coreConfig?.namespace ?? sdkAssembly.coreConfig.namespace;
  const useSchemaValidation = args?.coreConfig?.useSchemaValidation ?? sdkAssembly.coreConfig.useSchemaValidation;
  let axiosInstance = sdkAssembly.axiosInstance;
  const requestConfigOverrides = args?.axiosConfig?.request;
  const baseURLOverride = args?.coreConfig?.baseURL;
  const interceptorsOverride = args?.axiosConfig?.interceptors ?? [];
  if (requestConfigOverrides || baseURLOverride || interceptorsOverride.length > 0) {
    const requestConfig = ApiUtils15.mergeAxiosConfigs(sdkAssembly.axiosInstance.defaults, {
      ...baseURLOverride ? { baseURL: baseURLOverride } : {},
      ...requestConfigOverrides
    });
    axiosInstance = Network15.create(requestConfig);
    for (const interceptor of interceptorsOverride) {
      if (interceptor.type === "request") {
        axiosInstance.interceptors.request.use(interceptor.onRequest, interceptor.onError);
      }
      if (interceptor.type === "response") {
        axiosInstance.interceptors.response.use(interceptor.onSuccess, interceptor.onError);
      }
    }
  }
  async function getTags(queryParams) {
    const $ = new PublicTags$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getTags(queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  return {
    /**
     * ## Description Retrieve list of available tags by namespace
     */
    getTags
  };
}

export {
  PlayerRecordConcurrentUpdateResponse,
  ConcurrentRecordAdmin$,
  ConcurrentRecordAdminApi,
  BinaryInfoResponse,
  TtlConfigDto,
  GameBinaryRecordAdminResponse,
  Pagination,
  ListGameBinaryRecordsAdminResponse,
  UploadBinaryRecordResponse,
  GameBinaryRecordAdmin$,
  GameBinaryRecordAdminApi,
  GameRecordAdminResponse,
  ListGameRecordKeysResponse,
  GameRecordAdmin$,
  GameRecordAdminApi,
  PlayerBinaryRecordResponse,
  ListPlayerBinaryRecordsResponse,
  PlayerBinaryRecordAdmin$,
  PlayerBinaryRecordAdminApi,
  AdminPlayerRecordResponse,
  BulkGetAdminPlayerRecordResponse,
  PlayerRecordResponse,
  BulkGetPlayerRecordResponse,
  PlayerRecordSizeResponse,
  BulkGetPlayerRecordSizeResponse,
  BulkUpdatePlayerRecordByKeyResponse,
  BulkUpdatePlayerRecordByKeyResponseArray,
  BulkUpdatePlayerRecordResponse,
  BulkUpdatePlayerRecordResponseArray,
  PlayerRecordKeyInfo,
  ListPlayerRecordKeysResponse,
  PlayerRecordAdmin$,
  PlayerRecordAdminApi,
  AppConfig,
  CustomConfig,
  CustomFunction,
  PluginResponse,
  PluginConfigAdmin$,
  PluginConfigAdminApi,
  AdminGameRecordResponse,
  BulkGetAdminGameRecordResponse,
  ListAdminGameRecordKeysResponse,
  AdminPlayerRecordKeyInfo,
  ListAdminPlayerRecordKeysResponse,
  RecordAdmin$,
  RecordAdminApi,
  TagInfo,
  ListTagsResponse,
  TagsAdmin$,
  TagsAdminApi,
  TtlConfigAdmin$,
  TtlConfigAdminApi,
  ConcurrentRecord$,
  ConcurrentRecordApi,
  GameBinaryRecordResponse,
  BulkGetGameBinaryRecordResponse,
  ListGameBinaryRecordsResponse,
  PublicGameBinaryRecord$,
  PublicGameBinaryRecordApi,
  GameRecordResponse,
  BulkGetGameRecordResponse,
  PublicGameRecord$,
  PublicGameRecordApi,
  BulkGetPlayerBinaryRecordResponse,
  PublicPlayerBinaryRecord$,
  PublicPlayerBinaryRecordApi,
  PublicPlayerRecord$,
  PublicPlayerRecordApi,
  PublicTags$,
  PublicTagsApi
};

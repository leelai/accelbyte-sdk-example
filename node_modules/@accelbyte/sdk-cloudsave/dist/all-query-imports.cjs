"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/all-query-imports.ts
var all_query_imports_exports = {};
__export(all_query_imports_exports, {
  Key_ConcurrentRecord: () => Key_ConcurrentRecord,
  Key_ConcurrentRecordAdmin: () => Key_ConcurrentRecordAdmin,
  Key_GameBinaryRecordAdmin: () => Key_GameBinaryRecordAdmin,
  Key_GameRecordAdmin: () => Key_GameRecordAdmin,
  Key_PlayerBinaryRecordAdmin: () => Key_PlayerBinaryRecordAdmin,
  Key_PlayerRecordAdmin: () => Key_PlayerRecordAdmin,
  Key_PluginConfigAdmin: () => Key_PluginConfigAdmin,
  Key_PublicGameBinaryRecord: () => Key_PublicGameBinaryRecord,
  Key_PublicGameRecord: () => Key_PublicGameRecord,
  Key_PublicPlayerBinaryRecord: () => Key_PublicPlayerBinaryRecord,
  Key_PublicPlayerRecord: () => Key_PublicPlayerRecord,
  Key_PublicTags: () => Key_PublicTags,
  Key_RecordAdmin: () => Key_RecordAdmin,
  Key_TagsAdmin: () => Key_TagsAdmin,
  Key_TtlConfigAdmin: () => Key_TtlConfigAdmin,
  useConcurrentRecordAdminApi_UpdateConcurrentAdminrecord_ByKeyMutation: () => useConcurrentRecordAdminApi_UpdateConcurrentAdminrecord_ByKeyMutation,
  useConcurrentRecordAdminApi_UpdateConcurrentAdminrecord_ByUserId_ByKeyMutation: () => useConcurrentRecordAdminApi_UpdateConcurrentAdminrecord_ByUserId_ByKeyMutation,
  useConcurrentRecordAdminApi_UpdateConcurrentRecord_ByKeyMutation: () => useConcurrentRecordAdminApi_UpdateConcurrentRecord_ByKeyMutation,
  useConcurrentRecordAdminApi_UpdateConcurrentRecord_ByUserId_ByKeyMutation: () => useConcurrentRecordAdminApi_UpdateConcurrentRecord_ByUserId_ByKeyMutation,
  useConcurrentRecordAdminApi_UpdatePublicConcurrent_ByUserId_ByKeyMutation: () => useConcurrentRecordAdminApi_UpdatePublicConcurrent_ByUserId_ByKeyMutation,
  useConcurrentRecordApi_UpdateConcurrentRecord_ByKeyMutation: () => useConcurrentRecordApi_UpdateConcurrentRecord_ByKeyMutation,
  useConcurrentRecordApi_UpdateConcurrentRecord_ByUserId_ByKeyMutation: () => useConcurrentRecordApi_UpdateConcurrentRecord_ByUserId_ByKeyMutation,
  useConcurrentRecordApi_UpdatePublicConcurrent_ByUserId_ByKeyMutation: () => useConcurrentRecordApi_UpdatePublicConcurrent_ByUserId_ByKeyMutation,
  useGameBinaryRecordAdminApi_CreateBinaryMutation: () => useGameBinaryRecordAdminApi_CreateBinaryMutation,
  useGameBinaryRecordAdminApi_CreatePresigned_ByKeyMutation: () => useGameBinaryRecordAdminApi_CreatePresigned_ByKeyMutation,
  useGameBinaryRecordAdminApi_DeleteBinary_ByKeyMutation: () => useGameBinaryRecordAdminApi_DeleteBinary_ByKeyMutation,
  useGameBinaryRecordAdminApi_GetBinaries: () => useGameBinaryRecordAdminApi_GetBinaries,
  useGameBinaryRecordAdminApi_GetBinary_ByKey: () => useGameBinaryRecordAdminApi_GetBinary_ByKey,
  useGameBinaryRecordAdminApi_UpdateBinary_ByKeyMutation: () => useGameBinaryRecordAdminApi_UpdateBinary_ByKeyMutation,
  useGameBinaryRecordAdminApi_UpdateMetadata_ByKeyMutation: () => useGameBinaryRecordAdminApi_UpdateMetadata_ByKeyMutation,
  useGameRecordAdminApi_CreateRecord_ByKeyMutation: () => useGameRecordAdminApi_CreateRecord_ByKeyMutation,
  useGameRecordAdminApi_DeleteRecord_ByKeyMutation: () => useGameRecordAdminApi_DeleteRecord_ByKeyMutation,
  useGameRecordAdminApi_GetRecord_ByKey: () => useGameRecordAdminApi_GetRecord_ByKey,
  useGameRecordAdminApi_GetRecords: () => useGameRecordAdminApi_GetRecords,
  useGameRecordAdminApi_UpdateRecord_ByKeyMutation: () => useGameRecordAdminApi_UpdateRecord_ByKeyMutation,
  usePlayerBinaryRecordAdminApi_CreateBinary_ByUserIdMutation: () => usePlayerBinaryRecordAdminApi_CreateBinary_ByUserIdMutation,
  usePlayerBinaryRecordAdminApi_CreatePresigned_ByUserId_ByKeyMutation: () => usePlayerBinaryRecordAdminApi_CreatePresigned_ByUserId_ByKeyMutation,
  usePlayerBinaryRecordAdminApi_DeleteBinary_ByUserId_ByKeyMutation: () => usePlayerBinaryRecordAdminApi_DeleteBinary_ByUserId_ByKeyMutation,
  usePlayerBinaryRecordAdminApi_GetBinaries_ByUserId: () => usePlayerBinaryRecordAdminApi_GetBinaries_ByUserId,
  usePlayerBinaryRecordAdminApi_GetBinary_ByUserId_ByKey: () => usePlayerBinaryRecordAdminApi_GetBinary_ByUserId_ByKey,
  usePlayerBinaryRecordAdminApi_UpdateBinary_ByUserId_ByKeyMutation: () => usePlayerBinaryRecordAdminApi_UpdateBinary_ByUserId_ByKeyMutation,
  usePlayerBinaryRecordAdminApi_UpdateMetadata_ByUserId_ByKeyMutation: () => usePlayerBinaryRecordAdminApi_UpdateMetadata_ByUserId_ByKeyMutation,
  usePlayerRecordAdminApi_CreatePublic_ByUserId_ByKeyMutation: () => usePlayerRecordAdminApi_CreatePublic_ByUserId_ByKeyMutation,
  usePlayerRecordAdminApi_CreateRecord_ByUserId_ByKeyMutation: () => usePlayerRecordAdminApi_CreateRecord_ByUserId_ByKeyMutation,
  usePlayerRecordAdminApi_DeletePublic_ByUserId_ByKeyMutation: () => usePlayerRecordAdminApi_DeletePublic_ByUserId_ByKeyMutation,
  usePlayerRecordAdminApi_DeleteRecord_ByUserId_ByKeyMutation: () => usePlayerRecordAdminApi_DeleteRecord_ByUserId_ByKeyMutation,
  usePlayerRecordAdminApi_FetchBulkUser_ByKey: () => usePlayerRecordAdminApi_FetchBulkUser_ByKey,
  usePlayerRecordAdminApi_FetchRecordBulk_ByUserId: () => usePlayerRecordAdminApi_FetchRecordBulk_ByUserId,
  usePlayerRecordAdminApi_FetchUserBulkRecordSize: () => usePlayerRecordAdminApi_FetchUserBulkRecordSize,
  usePlayerRecordAdminApi_GetPublic_ByUserId_ByKey: () => usePlayerRecordAdminApi_GetPublic_ByUserId_ByKey,
  usePlayerRecordAdminApi_GetRecord_ByUserId_ByKey: () => usePlayerRecordAdminApi_GetRecord_ByUserId_ByKey,
  usePlayerRecordAdminApi_GetRecords_ByUserId: () => usePlayerRecordAdminApi_GetRecords_ByUserId,
  usePlayerRecordAdminApi_GetSize_ByUserId_ByKey: () => usePlayerRecordAdminApi_GetSize_ByUserId_ByKey,
  usePlayerRecordAdminApi_GetUsersRecords: () => usePlayerRecordAdminApi_GetUsersRecords,
  usePlayerRecordAdminApi_UpdateBulkUser_ByKeyMutation: () => usePlayerRecordAdminApi_UpdateBulkUser_ByKeyMutation,
  usePlayerRecordAdminApi_UpdatePublic_ByUserId_ByKeyMutation: () => usePlayerRecordAdminApi_UpdatePublic_ByUserId_ByKeyMutation,
  usePlayerRecordAdminApi_UpdateRecordBulk_ByUserIdMutation: () => usePlayerRecordAdminApi_UpdateRecordBulk_ByUserIdMutation,
  usePlayerRecordAdminApi_UpdateRecord_ByUserId_ByKeyMutation: () => usePlayerRecordAdminApi_UpdateRecord_ByUserId_ByKeyMutation,
  usePluginConfigAdminApi_CreatePluginMutation: () => usePluginConfigAdminApi_CreatePluginMutation,
  usePluginConfigAdminApi_DeletePluginMutation: () => usePluginConfigAdminApi_DeletePluginMutation,
  usePluginConfigAdminApi_GetPlugins: () => usePluginConfigAdminApi_GetPlugins,
  usePluginConfigAdminApi_PatchPluginMutation: () => usePluginConfigAdminApi_PatchPluginMutation,
  usePublicGameBinaryRecordApi_CreateBinaryBulkMutation: () => usePublicGameBinaryRecordApi_CreateBinaryBulkMutation,
  usePublicGameBinaryRecordApi_CreateBinaryMutation: () => usePublicGameBinaryRecordApi_CreateBinaryMutation,
  usePublicGameBinaryRecordApi_CreatePresigned_ByKeyMutation: () => usePublicGameBinaryRecordApi_CreatePresigned_ByKeyMutation,
  usePublicGameBinaryRecordApi_DeleteBinary_ByKeyMutation: () => usePublicGameBinaryRecordApi_DeleteBinary_ByKeyMutation,
  usePublicGameBinaryRecordApi_GetBinaries: () => usePublicGameBinaryRecordApi_GetBinaries,
  usePublicGameBinaryRecordApi_GetBinary_ByKey: () => usePublicGameBinaryRecordApi_GetBinary_ByKey,
  usePublicGameBinaryRecordApi_UpdateBinary_ByKeyMutation: () => usePublicGameBinaryRecordApi_UpdateBinary_ByKeyMutation,
  usePublicGameRecordApi_CreateRecord_ByKeyMutation: () => usePublicGameRecordApi_CreateRecord_ByKeyMutation,
  usePublicGameRecordApi_DeleteRecord_ByKeyMutation: () => usePublicGameRecordApi_DeleteRecord_ByKeyMutation,
  usePublicGameRecordApi_FetchRecordBulk: () => usePublicGameRecordApi_FetchRecordBulk,
  usePublicGameRecordApi_GetRecord_ByKey: () => usePublicGameRecordApi_GetRecord_ByKey,
  usePublicGameRecordApi_UpdateRecord_ByKeyMutation: () => usePublicGameRecordApi_UpdateRecord_ByKeyMutation,
  usePublicPlayerBinaryRecordApi_CreateBinary_ByUserIdMutation: () => usePublicPlayerBinaryRecordApi_CreateBinary_ByUserIdMutation,
  usePublicPlayerBinaryRecordApi_CreatePresigned_ByUserId_ByKeyMutation: () => usePublicPlayerBinaryRecordApi_CreatePresigned_ByUserId_ByKeyMutation,
  usePublicPlayerBinaryRecordApi_CreateUserMeBinaryBulkMutation: () => usePublicPlayerBinaryRecordApi_CreateUserMeBinaryBulkMutation,
  usePublicPlayerBinaryRecordApi_DeleteBinary_ByUserId_ByKeyMutation: () => usePublicPlayerBinaryRecordApi_DeleteBinary_ByUserId_ByKeyMutation,
  usePublicPlayerBinaryRecordApi_FetchBinaryBulk_ByUserId: () => usePublicPlayerBinaryRecordApi_FetchBinaryBulk_ByUserId,
  usePublicPlayerBinaryRecordApi_FetchPublicBulkUser_ByKey: () => usePublicPlayerBinaryRecordApi_FetchPublicBulkUser_ByKey,
  usePublicPlayerBinaryRecordApi_GetBinariesPublic_ByUserId: () => usePublicPlayerBinaryRecordApi_GetBinariesPublic_ByUserId,
  usePublicPlayerBinaryRecordApi_GetBinary_ByUserId_ByKey: () => usePublicPlayerBinaryRecordApi_GetBinary_ByUserId_ByKey,
  usePublicPlayerBinaryRecordApi_GetPublic_ByUserId_ByKey: () => usePublicPlayerBinaryRecordApi_GetPublic_ByUserId_ByKey,
  usePublicPlayerBinaryRecordApi_GetUsersMeBinaries: () => usePublicPlayerBinaryRecordApi_GetUsersMeBinaries,
  usePublicPlayerBinaryRecordApi_UpdateBinary_ByUserId_ByKeyMutation: () => usePublicPlayerBinaryRecordApi_UpdateBinary_ByUserId_ByKeyMutation,
  usePublicPlayerBinaryRecordApi_UpdateMetadata_ByUserId_ByKeyMutation: () => usePublicPlayerBinaryRecordApi_UpdateMetadata_ByUserId_ByKeyMutation,
  usePublicPlayerRecordApi_CreatePublic_ByUserId_ByKeyMutation: () => usePublicPlayerRecordApi_CreatePublic_ByUserId_ByKeyMutation,
  usePublicPlayerRecordApi_CreateRecord_ByUserId_ByKeyMutation: () => usePublicPlayerRecordApi_CreateRecord_ByUserId_ByKeyMutation,
  usePublicPlayerRecordApi_CreateUserMeRecordBulkMutation: () => usePublicPlayerRecordApi_CreateUserMeRecordBulkMutation,
  usePublicPlayerRecordApi_DeletePublicMeUser_ByKeyMutation: () => usePublicPlayerRecordApi_DeletePublicMeUser_ByKeyMutation,
  usePublicPlayerRecordApi_DeleteRecord_ByUserId_ByKeyMutation: () => usePublicPlayerRecordApi_DeleteRecord_ByUserId_ByKeyMutation,
  usePublicPlayerRecordApi_FetchPublicBulkUser_ByKey: () => usePublicPlayerRecordApi_FetchPublicBulkUser_ByKey,
  usePublicPlayerRecordApi_FetchRecordBulk_ByUserId: () => usePublicPlayerRecordApi_FetchRecordBulk_ByUserId,
  usePublicPlayerRecordApi_GetPublic_ByUserId_ByKey: () => usePublicPlayerRecordApi_GetPublic_ByUserId_ByKey,
  usePublicPlayerRecordApi_GetRecord_ByUserId_ByKey: () => usePublicPlayerRecordApi_GetRecord_ByUserId_ByKey,
  usePublicPlayerRecordApi_GetRecordsPublic_ByUserId: () => usePublicPlayerRecordApi_GetRecordsPublic_ByUserId,
  usePublicPlayerRecordApi_GetUsersMeRecords: () => usePublicPlayerRecordApi_GetUsersMeRecords,
  usePublicPlayerRecordApi_UpdatePublic_ByUserId_ByKeyMutation: () => usePublicPlayerRecordApi_UpdatePublic_ByUserId_ByKeyMutation,
  usePublicPlayerRecordApi_UpdateRecord_ByUserId_ByKeyMutation: () => usePublicPlayerRecordApi_UpdateRecord_ByUserId_ByKeyMutation,
  usePublicTagsApi_GetTags: () => usePublicTagsApi_GetTags,
  useRecordAdminApi_CreateAdminrecord_ByKeyMutation: () => useRecordAdminApi_CreateAdminrecord_ByKeyMutation,
  useRecordAdminApi_CreateAdminrecord_ByUserId_ByKeyMutation: () => useRecordAdminApi_CreateAdminrecord_ByUserId_ByKeyMutation,
  useRecordAdminApi_DeleteAdminrecord_ByKeyMutation: () => useRecordAdminApi_DeleteAdminrecord_ByKeyMutation,
  useRecordAdminApi_DeleteAdminrecord_ByUserId_ByKeyMutation: () => useRecordAdminApi_DeleteAdminrecord_ByUserId_ByKeyMutation,
  useRecordAdminApi_FetchAdminrecordBulk: () => useRecordAdminApi_FetchAdminrecordBulk,
  useRecordAdminApi_FetchAdminrecordBulk_ByUserId: () => useRecordAdminApi_FetchAdminrecordBulk_ByUserId,
  useRecordAdminApi_FetchBulkUser_ByKey: () => useRecordAdminApi_FetchBulkUser_ByKey,
  useRecordAdminApi_GetAdminrecord_ByKey: () => useRecordAdminApi_GetAdminrecord_ByKey,
  useRecordAdminApi_GetAdminrecord_ByUserId_ByKey: () => useRecordAdminApi_GetAdminrecord_ByUserId_ByKey,
  useRecordAdminApi_GetAdminrecords: () => useRecordAdminApi_GetAdminrecords,
  useRecordAdminApi_GetAdminrecords_ByUserId: () => useRecordAdminApi_GetAdminrecords_ByUserId,
  useRecordAdminApi_UpdateAdminrecord_ByKeyMutation: () => useRecordAdminApi_UpdateAdminrecord_ByKeyMutation,
  useRecordAdminApi_UpdateAdminrecord_ByUserId_ByKeyMutation: () => useRecordAdminApi_UpdateAdminrecord_ByUserId_ByKeyMutation,
  useTagsAdminApi_CreateTagMutation: () => useTagsAdminApi_CreateTagMutation,
  useTagsAdminApi_DeleteTag_ByTagMutation: () => useTagsAdminApi_DeleteTag_ByTagMutation,
  useTagsAdminApi_GetTags: () => useTagsAdminApi_GetTags,
  useTtlConfigAdminApi_DeleteTtl_ByKeyMutation: () => useTtlConfigAdminApi_DeleteTtl_ByKeyMutation,
  useTtlConfigAdminApi_DeleteTtl_ByKey_ByNSMutation: () => useTtlConfigAdminApi_DeleteTtl_ByKey_ByNSMutation
});
module.exports = __toCommonJS(all_query_imports_exports);

// src/generated-admin/queries/ConcurrentRecordAdmin.query.ts
var import_react_query = require("@tanstack/react-query");

// src/generated-admin/ConcurrentRecordAdminApi.ts
var import_sdk2 = require("@accelbyte/sdk");

// src/generated-admin/endpoints/ConcurrentRecordAdmin$.ts
var import_sdk = require("@accelbyte/sdk");
var import_zod2 = require("zod");

// src/generated-definitions/PlayerRecordConcurrentUpdateResponse.ts
var import_zod = require("zod");
var PlayerRecordConcurrentUpdateResponse = import_zod.z.object({ updated_at: import_zod.z.string() });

// src/generated-admin/endpoints/ConcurrentRecordAdmin$.ts
var ConcurrentRecordAdmin$ = class {
  // @ts-ignore
  // prettier-ignore
  constructor(axiosInstance, namespace, useSchemaValidation = true) {
    this.axiosInstance = axiosInstance;
    this.namespace = namespace;
    this.useSchemaValidation = useSchemaValidation;
  }
  /**
   * ## Description This endpoints will create new game record or replace the existing game record. **Replace behaviour:** The existing value will be replaced completely with the new value. Example - Existing JSON: `{ &#34;data1&#34;: &#34;value&#34; }` - New JSON: `{ &#34;data2&#34;: &#34;new value&#34; }` - Result: `{ &#34;data2&#34;: &#34;new value&#34; }` ## Restriction This is the restriction of Key Naming for the record: 1. Cannot use **&#34;.&#34;** as the key name - `{ &#34;data.2&#34;: &#34;value&#34; }` 2. Cannot use **&#34;$&#34;** as the prefix in key names - `{ &#34;$data&#34;: &#34;value&#34; }` 3. Cannot use empty string in key names - `{ &#34;&#34;: &#34;value&#34; }` ## Reserved Word Reserved Word List: **__META** The reserved word cannot be used as a field in record value, If still defining the field when creating or updating the record, it will be ignored. ## Parameters Notes 1. set_by (default: CLIENT, type: string) Indicate which party that could modify the game record. SERVER: record can be modified by server only. CLIENT: record can be modified by client and server. 2. updatedAt (required: true) Time format style: RFC3339 3. value Json 4. tags (default: *empty array*, type: array of string) Indicate the tagging for the game record. **Request Body Example:** ``` { &#34;set_by&#34;: &#34;SERVER&#34;, &#34;value&#34;: {}, &#34;updatedAt&#34;: &#34;2022-03-17T10:42:15.444Z&#34;, &#34;tags&#34;: [&#34;tag1&#34;, &#34;tag2&#34;] } ``` ## Optimistic Concurrency Control This endpoint implement optimistic concurrency control to avoid race condition. If the record has been updated since the client fetch it, the server will return HTTP status code 412 (precondition failed) and client need to redo the operation (fetch data and do update). Otherwise, the server will process the request.
   */
  updateConcurrentRecord_ByKey(key, data) {
    const params = {};
    const url = "/cloudsave/v1/admin/namespaces/{namespace}/concurrent/records/{key}".replace("{namespace}", this.namespace).replace("{key}", key);
    const resultPromise = this.axiosInstance.put(url, data, { params });
    return import_sdk.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, import_zod2.z.unknown(), "z.unknown()");
  }
  /**
   * ## Description This endpoints will create new game record or replace the existing game record. **Replace behaviour:** The existing value will be replaced completely with the new value. Example - Existing JSON: `{ &#34;data1&#34;: &#34;value&#34; }` - New JSON: `{ &#34;data2&#34;: &#34;new value&#34; }` - Result: `{ &#34;data2&#34;: &#34;new value&#34; }` ## Restriction This is the restriction of Key Naming for the record: 1. Cannot use **&#34;.&#34;** as the key name - `{ &#34;data.2&#34;: &#34;value&#34; }` 2. Cannot use **&#34;$&#34;** as the prefix in key names - `{ &#34;$data&#34;: &#34;value&#34; }` 3. Cannot use empty string in key names - `{ &#34;&#34;: &#34;value&#34; }` ## Reserved Word Reserved Word List: **__META** The reserved word cannot be used as a field in record value, If still defining the field when creating or updating the record, it will be ignored. ## Parameters Notes 1. updatedAt (required: true) Time format style: RFC3339 2. value Json 3. tags (default: *empty array*, type: array of string) Indicate the tagging for the admin record. **Request Body Example:** ``` { &#34;value&#34;: {}, &#34;updatedAt&#34;: &#34;2022-03-17T10:42:15.444Z&#34;, &#34;tags&#34;: [&#34;tag1&#34;, &#34;tag2&#34;] } ``` ## Optimistic Concurrency Control This endpoint implement optimistic concurrency control to avoid race condition. If the record has been updated since the client fetch it, the server will return HTTP status code 412 (precondition failed) and client need to redo the operation (fetch data and do update). Otherwise, the server will process the request.
   */
  updateConcurrentAdminrecord_ByKey(key, data) {
    const params = {};
    const url = "/cloudsave/v1/admin/namespaces/{namespace}/concurrent/adminrecords/{key}".replace("{namespace}", this.namespace).replace("{key}", key);
    const resultPromise = this.axiosInstance.put(url, data, { params });
    return import_sdk.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, import_zod2.z.unknown(), "z.unknown()");
  }
  /**
   * ## Description This endpoints will create new player record or replace the existing player record. **Replace behaviour:** The existing value will be replaced completely with the new value. Example - Existing JSON: `{ &#34;data1&#34;: &#34;value&#34; }` - New JSON: `{ &#34;data2&#34;: &#34;new value&#34; }` - Result: `{ &#34;data2&#34;: &#34;new value&#34; }` ## Restriction This is the restriction of Key Naming for the record: 1. Cannot use **&#34;.&#34;** as the key name - `{ &#34;data.2&#34;: &#34;value&#34; }` 2. Cannot use **&#34;$&#34;** as the prefix in key names - `{ &#34;$data&#34;: &#34;value&#34; }` 3. Cannot use empty string in key names - `{ &#34;&#34;: &#34;value&#34; }` ## Reserved Word Reserved Word List: **__META** The reserved word cannot be used as a field in record value, If still defining the field when creating or updating the record, it will be ignored. ## Parameters Notes 1. set_by (default: CLIENT, type: string) Indicate which party that could modify the game record. SERVER: record can be modified by server only. CLIENT: record can be modified by client and server. 2. updatedAt (required: true) Time format style: RFC3339 3. value Json 4. tags (default: *empty array*, type: array of string) Indicate the tagging for the game record. **Request Body Example:** ``` { &#34;set_by&#34;: &#34;SERVER&#34;, &#34;value&#34;: {}, &#34;updatedAt&#34;: &#34;2022-03-17T10:42:15.444Z&#34;, &#34;tags&#34;: [&#34;tag1&#34;, &#34;tag2&#34;] } ``` ## Optimistic Concurrency Control This endpoint implement optimistic concurrency control to avoid race condition. If the record has been updated since the client fetch it, the server will return HTTP status code 412 (precondition failed) and client need to redo the operation (fetch data and do update). Otherwise, the server will process the request.
   */
  updateConcurrentRecord_ByUserId_ByKey(userId, key, data, queryParams) {
    const params = { ...queryParams };
    const url = "/cloudsave/v1/admin/namespaces/{namespace}/users/{userId}/concurrent/records/{key}".replace("{namespace}", this.namespace).replace("{userId}", userId).replace("{key}", key);
    const resultPromise = this.axiosInstance.put(url, data, { params });
    return import_sdk.Validate.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      PlayerRecordConcurrentUpdateResponse,
      "PlayerRecordConcurrentUpdateResponse"
    );
  }
  /**
   * ## Description This endpoints will create new admin player record or replace the existing admin player record. **Replace behaviour:** The existing value will be replaced completely with the new value. Example - Existing JSON: `{ &#34;data1&#34;: &#34;value&#34; }` - New JSON: `{ &#34;data2&#34;: &#34;new value&#34; }` - Result: `{ &#34;data2&#34;: &#34;new value&#34; }` ## Restriction This is the restriction of Key Naming for the record: 1. Cannot use **&#34;.&#34;** as the key name - `{ &#34;data.2&#34;: &#34;value&#34; }` 2. Cannot use **&#34;$&#34;** as the prefix in key names - `{ &#34;$data&#34;: &#34;value&#34; }` 3. Cannot use empty string in key names - `{ &#34;&#34;: &#34;value&#34; }` ## Reserved Word Reserved Word List: **__META** The reserved word cannot be used as a field in record value, If still defining the field when creating or updating the record, it will be ignored. ## Parameters Notes 1. updatedAt (required: true) Time format style: RFC3339 2. value Json 3. tags (default: *empty array*, type: array of string) Indicate the tagging for the admin record. **Request Body Example:** ``` { &#34;value&#34;: {}, &#34;updatedAt&#34;: &#34;2022-03-17T10:42:15.444Z&#34;, &#34;tags&#34;: [&#34;tag1&#34;, &#34;tag2&#34;] } ``` ## Optimistic Concurrency Control This endpoint implement optimistic concurrency control to avoid race condition. If the record has been updated since the client fetch it, the server will return HTTP status code 412 (precondition failed) and client need to redo the operation (fetch data and do update). Otherwise, the server will process the request.
   */
  updateConcurrentAdminrecord_ByUserId_ByKey(userId, key, data, queryParams) {
    const params = { ...queryParams };
    const url = "/cloudsave/v1/admin/namespaces/{namespace}/users/{userId}/concurrent/adminrecords/{key}".replace("{namespace}", this.namespace).replace("{userId}", userId).replace("{key}", key);
    const resultPromise = this.axiosInstance.put(url, data, { params });
    return import_sdk.Validate.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      PlayerRecordConcurrentUpdateResponse,
      "PlayerRecordConcurrentUpdateResponse"
    );
  }
  /**
   * ## Description This endpoints will create new player public record or replace the existing player public record. **Replace behaviour:** The existing value will be replaced completely with the new value. Example - Existing JSON: `{ &#34;data1&#34;: &#34;value&#34; }` - New JSON: `{ &#34;data2&#34;: &#34;new value&#34; }` - Result: `{ &#34;data2&#34;: &#34;new value&#34; }` ## Restriction This is the restriction of Key Naming for the record: 1. Cannot use **&#34;.&#34;** as the key name - `{ &#34;data.2&#34;: &#34;value&#34; }` 2. Cannot use **&#34;$&#34;** as the prefix in key names - `{ &#34;$data&#34;: &#34;value&#34; }` 3. Cannot use empty string in key names - `{ &#34;&#34;: &#34;value&#34; }` ## Reserved Word Reserved Word List: **__META** The reserved word cannot be used as a field in record value, If still defining the field when creating or updating the record, it will be ignored. ## Parameters Notes 1. set_by (default: CLIENT, type: string) Indicate which party that could modify the game record. SERVER: record can be modified by server only. CLIENT: record can be modified by client and server. 2. updatedAt (required: true) Time format style: RFC3339 3. value Json 4. tags (default: *empty array*, type: array of string) Indicate the tagging for the game record. **Request Body Example:** ``` { &#34;set_by&#34;: &#34;SERVER&#34;, &#34;value&#34;: {}, &#34;updatedAt&#34;: &#34;2022-03-17T10:42:15.444Z&#34;, &#34;tags&#34;: [&#34;tag1&#34;, &#34;tag2&#34;] } ``` ## Optimistic Concurrency Control This endpoint implement optimistic concurrency control to avoid race condition. If the record has been updated since the client fetch it, the server will return HTTP status code 412 (precondition failed) and client need to redo the operation (fetch data and do update). Otherwise, the server will process the request.
   */
  updatePublicConcurrent_ByUserId_ByKey(userId, key, data, queryParams) {
    const params = { ...queryParams };
    const url = "/cloudsave/v1/admin/namespaces/{namespace}/users/{userId}/concurrent/records/{key}/public".replace("{namespace}", this.namespace).replace("{userId}", userId).replace("{key}", key);
    const resultPromise = this.axiosInstance.put(url, data, { params });
    return import_sdk.Validate.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      PlayerRecordConcurrentUpdateResponse,
      "PlayerRecordConcurrentUpdateResponse"
    );
  }
};

// src/generated-admin/ConcurrentRecordAdminApi.ts
function ConcurrentRecordAdminApi(sdk, args) {
  const sdkAssembly = sdk.assembly();
  const namespace = args?.coreConfig?.namespace ?? sdkAssembly.coreConfig.namespace;
  const useSchemaValidation = args?.coreConfig?.useSchemaValidation ?? sdkAssembly.coreConfig.useSchemaValidation;
  let axiosInstance = sdkAssembly.axiosInstance;
  const requestConfigOverrides = args?.axiosConfig?.request;
  const baseURLOverride = args?.coreConfig?.baseURL;
  const interceptorsOverride = args?.axiosConfig?.interceptors ?? [];
  if (requestConfigOverrides || baseURLOverride || interceptorsOverride.length > 0) {
    const requestConfig = import_sdk2.ApiUtils.mergeAxiosConfigs(sdkAssembly.axiosInstance.defaults, {
      ...baseURLOverride ? { baseURL: baseURLOverride } : {},
      ...requestConfigOverrides
    });
    axiosInstance = import_sdk2.Network.create(requestConfig);
    for (const interceptor of interceptorsOverride) {
      if (interceptor.type === "request") {
        axiosInstance.interceptors.request.use(interceptor.onRequest, interceptor.onError);
      }
      if (interceptor.type === "response") {
        axiosInstance.interceptors.response.use(interceptor.onSuccess, interceptor.onError);
      }
    }
  }
  async function updateConcurrentRecord_ByKey(key, data) {
    const $ = new ConcurrentRecordAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.updateConcurrentRecord_ByKey(key, data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function updateConcurrentAdminrecord_ByKey(key, data) {
    const $ = new ConcurrentRecordAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.updateConcurrentAdminrecord_ByKey(key, data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function updateConcurrentRecord_ByUserId_ByKey(userId, key, data, queryParams) {
    const $ = new ConcurrentRecordAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.updateConcurrentRecord_ByUserId_ByKey(userId, key, data, queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function updateConcurrentAdminrecord_ByUserId_ByKey(userId, key, data, queryParams) {
    const $ = new ConcurrentRecordAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.updateConcurrentAdminrecord_ByUserId_ByKey(userId, key, data, queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function updatePublicConcurrent_ByUserId_ByKey(userId, key, data, queryParams) {
    const $ = new ConcurrentRecordAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.updatePublicConcurrent_ByUserId_ByKey(userId, key, data, queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  return {
    /**
     * ## Description This endpoints will create new game record or replace the existing game record. **Replace behaviour:** The existing value will be replaced completely with the new value. Example - Existing JSON: `{ &#34;data1&#34;: &#34;value&#34; }` - New JSON: `{ &#34;data2&#34;: &#34;new value&#34; }` - Result: `{ &#34;data2&#34;: &#34;new value&#34; }` ## Restriction This is the restriction of Key Naming for the record: 1. Cannot use **&#34;.&#34;** as the key name - `{ &#34;data.2&#34;: &#34;value&#34; }` 2. Cannot use **&#34;$&#34;** as the prefix in key names - `{ &#34;$data&#34;: &#34;value&#34; }` 3. Cannot use empty string in key names - `{ &#34;&#34;: &#34;value&#34; }` ## Reserved Word Reserved Word List: **__META** The reserved word cannot be used as a field in record value, If still defining the field when creating or updating the record, it will be ignored. ## Parameters Notes 1. set_by (default: CLIENT, type: string) Indicate which party that could modify the game record. SERVER: record can be modified by server only. CLIENT: record can be modified by client and server. 2. updatedAt (required: true) Time format style: RFC3339 3. value Json 4. tags (default: *empty array*, type: array of string) Indicate the tagging for the game record. **Request Body Example:** ``` { &#34;set_by&#34;: &#34;SERVER&#34;, &#34;value&#34;: {}, &#34;updatedAt&#34;: &#34;2022-03-17T10:42:15.444Z&#34;, &#34;tags&#34;: [&#34;tag1&#34;, &#34;tag2&#34;] } ``` ## Optimistic Concurrency Control This endpoint implement optimistic concurrency control to avoid race condition. If the record has been updated since the client fetch it, the server will return HTTP status code 412 (precondition failed) and client need to redo the operation (fetch data and do update). Otherwise, the server will process the request.
     */
    updateConcurrentRecord_ByKey,
    /**
     * ## Description This endpoints will create new game record or replace the existing game record. **Replace behaviour:** The existing value will be replaced completely with the new value. Example - Existing JSON: `{ &#34;data1&#34;: &#34;value&#34; }` - New JSON: `{ &#34;data2&#34;: &#34;new value&#34; }` - Result: `{ &#34;data2&#34;: &#34;new value&#34; }` ## Restriction This is the restriction of Key Naming for the record: 1. Cannot use **&#34;.&#34;** as the key name - `{ &#34;data.2&#34;: &#34;value&#34; }` 2. Cannot use **&#34;$&#34;** as the prefix in key names - `{ &#34;$data&#34;: &#34;value&#34; }` 3. Cannot use empty string in key names - `{ &#34;&#34;: &#34;value&#34; }` ## Reserved Word Reserved Word List: **__META** The reserved word cannot be used as a field in record value, If still defining the field when creating or updating the record, it will be ignored. ## Parameters Notes 1. updatedAt (required: true) Time format style: RFC3339 2. value Json 3. tags (default: *empty array*, type: array of string) Indicate the tagging for the admin record. **Request Body Example:** ``` { &#34;value&#34;: {}, &#34;updatedAt&#34;: &#34;2022-03-17T10:42:15.444Z&#34;, &#34;tags&#34;: [&#34;tag1&#34;, &#34;tag2&#34;] } ``` ## Optimistic Concurrency Control This endpoint implement optimistic concurrency control to avoid race condition. If the record has been updated since the client fetch it, the server will return HTTP status code 412 (precondition failed) and client need to redo the operation (fetch data and do update). Otherwise, the server will process the request.
     */
    updateConcurrentAdminrecord_ByKey,
    /**
     * ## Description This endpoints will create new player record or replace the existing player record. **Replace behaviour:** The existing value will be replaced completely with the new value. Example - Existing JSON: `{ &#34;data1&#34;: &#34;value&#34; }` - New JSON: `{ &#34;data2&#34;: &#34;new value&#34; }` - Result: `{ &#34;data2&#34;: &#34;new value&#34; }` ## Restriction This is the restriction of Key Naming for the record: 1. Cannot use **&#34;.&#34;** as the key name - `{ &#34;data.2&#34;: &#34;value&#34; }` 2. Cannot use **&#34;$&#34;** as the prefix in key names - `{ &#34;$data&#34;: &#34;value&#34; }` 3. Cannot use empty string in key names - `{ &#34;&#34;: &#34;value&#34; }` ## Reserved Word Reserved Word List: **__META** The reserved word cannot be used as a field in record value, If still defining the field when creating or updating the record, it will be ignored. ## Parameters Notes 1. set_by (default: CLIENT, type: string) Indicate which party that could modify the game record. SERVER: record can be modified by server only. CLIENT: record can be modified by client and server. 2. updatedAt (required: true) Time format style: RFC3339 3. value Json 4. tags (default: *empty array*, type: array of string) Indicate the tagging for the game record. **Request Body Example:** ``` { &#34;set_by&#34;: &#34;SERVER&#34;, &#34;value&#34;: {}, &#34;updatedAt&#34;: &#34;2022-03-17T10:42:15.444Z&#34;, &#34;tags&#34;: [&#34;tag1&#34;, &#34;tag2&#34;] } ``` ## Optimistic Concurrency Control This endpoint implement optimistic concurrency control to avoid race condition. If the record has been updated since the client fetch it, the server will return HTTP status code 412 (precondition failed) and client need to redo the operation (fetch data and do update). Otherwise, the server will process the request.
     */
    updateConcurrentRecord_ByUserId_ByKey,
    /**
     * ## Description This endpoints will create new admin player record or replace the existing admin player record. **Replace behaviour:** The existing value will be replaced completely with the new value. Example - Existing JSON: `{ &#34;data1&#34;: &#34;value&#34; }` - New JSON: `{ &#34;data2&#34;: &#34;new value&#34; }` - Result: `{ &#34;data2&#34;: &#34;new value&#34; }` ## Restriction This is the restriction of Key Naming for the record: 1. Cannot use **&#34;.&#34;** as the key name - `{ &#34;data.2&#34;: &#34;value&#34; }` 2. Cannot use **&#34;$&#34;** as the prefix in key names - `{ &#34;$data&#34;: &#34;value&#34; }` 3. Cannot use empty string in key names - `{ &#34;&#34;: &#34;value&#34; }` ## Reserved Word Reserved Word List: **__META** The reserved word cannot be used as a field in record value, If still defining the field when creating or updating the record, it will be ignored. ## Parameters Notes 1. updatedAt (required: true) Time format style: RFC3339 2. value Json 3. tags (default: *empty array*, type: array of string) Indicate the tagging for the admin record. **Request Body Example:** ``` { &#34;value&#34;: {}, &#34;updatedAt&#34;: &#34;2022-03-17T10:42:15.444Z&#34;, &#34;tags&#34;: [&#34;tag1&#34;, &#34;tag2&#34;] } ``` ## Optimistic Concurrency Control This endpoint implement optimistic concurrency control to avoid race condition. If the record has been updated since the client fetch it, the server will return HTTP status code 412 (precondition failed) and client need to redo the operation (fetch data and do update). Otherwise, the server will process the request.
     */
    updateConcurrentAdminrecord_ByUserId_ByKey,
    /**
     * ## Description This endpoints will create new player public record or replace the existing player public record. **Replace behaviour:** The existing value will be replaced completely with the new value. Example - Existing JSON: `{ &#34;data1&#34;: &#34;value&#34; }` - New JSON: `{ &#34;data2&#34;: &#34;new value&#34; }` - Result: `{ &#34;data2&#34;: &#34;new value&#34; }` ## Restriction This is the restriction of Key Naming for the record: 1. Cannot use **&#34;.&#34;** as the key name - `{ &#34;data.2&#34;: &#34;value&#34; }` 2. Cannot use **&#34;$&#34;** as the prefix in key names - `{ &#34;$data&#34;: &#34;value&#34; }` 3. Cannot use empty string in key names - `{ &#34;&#34;: &#34;value&#34; }` ## Reserved Word Reserved Word List: **__META** The reserved word cannot be used as a field in record value, If still defining the field when creating or updating the record, it will be ignored. ## Parameters Notes 1. set_by (default: CLIENT, type: string) Indicate which party that could modify the game record. SERVER: record can be modified by server only. CLIENT: record can be modified by client and server. 2. updatedAt (required: true) Time format style: RFC3339 3. value Json 4. tags (default: *empty array*, type: array of string) Indicate the tagging for the game record. **Request Body Example:** ``` { &#34;set_by&#34;: &#34;SERVER&#34;, &#34;value&#34;: {}, &#34;updatedAt&#34;: &#34;2022-03-17T10:42:15.444Z&#34;, &#34;tags&#34;: [&#34;tag1&#34;, &#34;tag2&#34;] } ``` ## Optimistic Concurrency Control This endpoint implement optimistic concurrency control to avoid race condition. If the record has been updated since the client fetch it, the server will return HTTP status code 412 (precondition failed) and client need to redo the operation (fetch data and do update). Otherwise, the server will process the request.
     */
    updatePublicConcurrent_ByUserId_ByKey
  };
}

// src/generated-admin/queries/ConcurrentRecordAdmin.query.ts
var Key_ConcurrentRecordAdmin = /* @__PURE__ */ ((Key_ConcurrentRecordAdmin2) => {
  Key_ConcurrentRecordAdmin2["ConcurrentRecord_ByKey"] = "Cloudsave.ConcurrentRecordAdmin.ConcurrentRecord_ByKey";
  Key_ConcurrentRecordAdmin2["ConcurrentAdminrecord_ByKey"] = "Cloudsave.ConcurrentRecordAdmin.ConcurrentAdminrecord_ByKey";
  Key_ConcurrentRecordAdmin2["ConcurrentRecord_ByUserId_ByKey"] = "Cloudsave.ConcurrentRecordAdmin.ConcurrentRecord_ByUserId_ByKey";
  Key_ConcurrentRecordAdmin2["ConcurrentAdminrecord_ByUserId_ByKey"] = "Cloudsave.ConcurrentRecordAdmin.ConcurrentAdminrecord_ByUserId_ByKey";
  Key_ConcurrentRecordAdmin2["PublicConcurrent_ByUserId_ByKey"] = "Cloudsave.ConcurrentRecordAdmin.PublicConcurrent_ByUserId_ByKey";
  return Key_ConcurrentRecordAdmin2;
})(Key_ConcurrentRecordAdmin || {});
var useConcurrentRecordAdminApi_UpdateConcurrentRecord_ByKeyMutation = (sdk, options, callback) => {
  const mutationFn = async (input) => {
    const response = await ConcurrentRecordAdminApi(sdk, {
      coreConfig: input.coreConfig,
      axiosConfig: input.axiosConfig
    }).updateConcurrentRecord_ByKey(input.key, input.data);
    callback && callback(response.data);
    return response.data;
  };
  return (0, import_react_query.useMutation)({
    mutationKey: ["Cloudsave.ConcurrentRecordAdmin.ConcurrentRecord_ByKey" /* ConcurrentRecord_ByKey */],
    mutationFn,
    ...options
  });
};
var useConcurrentRecordAdminApi_UpdateConcurrentAdminrecord_ByKeyMutation = (sdk, options, callback) => {
  const mutationFn = async (input) => {
    const response = await ConcurrentRecordAdminApi(sdk, {
      coreConfig: input.coreConfig,
      axiosConfig: input.axiosConfig
    }).updateConcurrentAdminrecord_ByKey(input.key, input.data);
    callback && callback(response.data);
    return response.data;
  };
  return (0, import_react_query.useMutation)({
    mutationKey: ["Cloudsave.ConcurrentRecordAdmin.ConcurrentAdminrecord_ByKey" /* ConcurrentAdminrecord_ByKey */],
    mutationFn,
    ...options
  });
};
var useConcurrentRecordAdminApi_UpdateConcurrentRecord_ByUserId_ByKeyMutation = (sdk, options, callback) => {
  const mutationFn = async (input) => {
    const response = await ConcurrentRecordAdminApi(sdk, {
      coreConfig: input.coreConfig,
      axiosConfig: input.axiosConfig
    }).updateConcurrentRecord_ByUserId_ByKey(input.userId, input.key, input.data, input.queryParams);
    callback && callback(response.data);
    return response.data;
  };
  return (0, import_react_query.useMutation)({
    mutationKey: ["Cloudsave.ConcurrentRecordAdmin.ConcurrentRecord_ByUserId_ByKey" /* ConcurrentRecord_ByUserId_ByKey */],
    mutationFn,
    ...options
  });
};
var useConcurrentRecordAdminApi_UpdateConcurrentAdminrecord_ByUserId_ByKeyMutation = (sdk, options, callback) => {
  const mutationFn = async (input) => {
    const response = await ConcurrentRecordAdminApi(sdk, {
      coreConfig: input.coreConfig,
      axiosConfig: input.axiosConfig
    }).updateConcurrentAdminrecord_ByUserId_ByKey(input.userId, input.key, input.data, input.queryParams);
    callback && callback(response.data);
    return response.data;
  };
  return (0, import_react_query.useMutation)({
    mutationKey: ["Cloudsave.ConcurrentRecordAdmin.ConcurrentAdminrecord_ByUserId_ByKey" /* ConcurrentAdminrecord_ByUserId_ByKey */],
    mutationFn,
    ...options
  });
};
var useConcurrentRecordAdminApi_UpdatePublicConcurrent_ByUserId_ByKeyMutation = (sdk, options, callback) => {
  const mutationFn = async (input) => {
    const response = await ConcurrentRecordAdminApi(sdk, {
      coreConfig: input.coreConfig,
      axiosConfig: input.axiosConfig
    }).updatePublicConcurrent_ByUserId_ByKey(input.userId, input.key, input.data, input.queryParams);
    callback && callback(response.data);
    return response.data;
  };
  return (0, import_react_query.useMutation)({
    mutationKey: ["Cloudsave.ConcurrentRecordAdmin.PublicConcurrent_ByUserId_ByKey" /* PublicConcurrent_ByUserId_ByKey */],
    mutationFn,
    ...options
  });
};

// src/generated-admin/queries/GameBinaryRecordAdmin.query.ts
var import_react_query2 = require("@tanstack/react-query");

// src/generated-admin/GameBinaryRecordAdminApi.ts
var import_sdk4 = require("@accelbyte/sdk");

// src/generated-admin/endpoints/GameBinaryRecordAdmin$.ts
var import_sdk3 = require("@accelbyte/sdk");
var import_zod9 = require("zod");

// src/generated-definitions/GameBinaryRecordAdminResponse.ts
var import_zod5 = require("zod");

// src/generated-definitions/BinaryInfoResponse.ts
var import_zod3 = require("zod");
var BinaryInfoResponse = import_zod3.z.object({
  content_type: import_zod3.z.string(),
  created_at: import_zod3.z.string(),
  file_location: import_zod3.z.string(),
  updated_at: import_zod3.z.string(),
  url: import_zod3.z.string().nullish(),
  version: import_zod3.z.number().int()
});

// src/generated-definitions/TtlConfigDto.ts
var import_zod4 = require("zod");
var TtlConfigDto = import_zod4.z.object({ action: import_zod4.z.enum(["DELETE"]), expires_at: import_zod4.z.string() });

// src/generated-definitions/GameBinaryRecordAdminResponse.ts
var GameBinaryRecordAdminResponse = import_zod5.z.object({
  binary_info: BinaryInfoResponse.nullish(),
  created_at: import_zod5.z.string(),
  key: import_zod5.z.string(),
  namespace: import_zod5.z.string(),
  set_by: import_zod5.z.enum(["CLIENT", "SERVER"]).nullish(),
  tags: import_zod5.z.array(import_zod5.z.string()).nullish(),
  ttl_config: TtlConfigDto.nullish(),
  updated_at: import_zod5.z.string()
});

// src/generated-definitions/ListGameBinaryRecordsAdminResponse.ts
var import_zod7 = require("zod");

// src/generated-definitions/Pagination.ts
var import_zod6 = require("zod");
var Pagination = import_zod6.z.object({ first: import_zod6.z.string(), last: import_zod6.z.string(), next: import_zod6.z.string(), previous: import_zod6.z.string() });

// src/generated-definitions/ListGameBinaryRecordsAdminResponse.ts
var ListGameBinaryRecordsAdminResponse = import_zod7.z.object({ data: import_zod7.z.array(GameBinaryRecordAdminResponse), paging: Pagination });

// src/generated-definitions/UploadBinaryRecordResponse.ts
var import_zod8 = require("zod");
var UploadBinaryRecordResponse = import_zod8.z.object({
  content_type: import_zod8.z.string(),
  file_location: import_zod8.z.string(),
  url: import_zod8.z.string(),
  version: import_zod8.z.number().int()
});

// src/generated-admin/endpoints/GameBinaryRecordAdmin$.ts
var GameBinaryRecordAdmin$ = class {
  // @ts-ignore
  // prettier-ignore
  constructor(axiosInstance, namespace, useSchemaValidation = true) {
    this.axiosInstance = axiosInstance;
    this.namespace = namespace;
    this.useSchemaValidation = useSchemaValidation;
  }
  /**
   * Retrieve list of binary records by namespace.
   */
  getBinaries(queryParams) {
    const params = { limit: 25, ...queryParams };
    const url = "/cloudsave/v1/admin/namespaces/{namespace}/binaries".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.get(url, { params });
    return import_sdk3.Validate.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      ListGameBinaryRecordsAdminResponse,
      "ListGameBinaryRecordsAdminResponse"
    );
  }
  /**
   * Create a game binary record. Other detail info: `key` should follow these rules: 1. support uppercase and lowercase letters, numbers, and separators **&#34;-&#34;**, **&#34;_&#34;**, **&#34;.&#34;** are allowed 2. begin and end with letters or numbers 3. spaces are not allowed 4. separators must not appears twice in a row Supported file types: jpeg, jpg, png, bmp, gif, mp3, webp, and bin.
   */
  createBinary(data) {
    const params = {};
    const url = "/cloudsave/v1/admin/namespaces/{namespace}/binaries".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.post(url, data, { params });
    return import_sdk3.Validate.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      UploadBinaryRecordResponse,
      "UploadBinaryRecordResponse"
    );
  }
  /**
   * Delete a game binary record.
   */
  deleteBinary_ByKey(key) {
    const params = {};
    const url = "/cloudsave/v1/admin/namespaces/{namespace}/binaries/{key}".replace("{namespace}", this.namespace).replace("{key}", key);
    const resultPromise = this.axiosInstance.delete(url, { params });
    return import_sdk3.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, import_zod9.z.unknown(), "z.unknown()");
  }
  /**
   * Get a game binary record by its key.
   */
  getBinary_ByKey(key) {
    const params = {};
    const url = "/cloudsave/v1/admin/namespaces/{namespace}/binaries/{key}".replace("{namespace}", this.namespace).replace("{key}", key);
    const resultPromise = this.axiosInstance.get(url, { params });
    return import_sdk3.Validate.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      GameBinaryRecordAdminResponse,
      "GameBinaryRecordAdminResponse"
    );
  }
  /**
   * Update a game binary record file by its key
   */
  updateBinary_ByKey(key, data) {
    const params = {};
    const url = "/cloudsave/v1/admin/namespaces/{namespace}/binaries/{key}".replace("{namespace}", this.namespace).replace("{key}", key);
    const resultPromise = this.axiosInstance.put(url, data, { params });
    return import_sdk3.Validate.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      GameBinaryRecordAdminResponse,
      "GameBinaryRecordAdminResponse"
    );
  }
  /**
   * Update a game binary record metadata by its key
   */
  updateMetadata_ByKey(key, data) {
    const params = {};
    const url = "/cloudsave/v1/admin/namespaces/{namespace}/binaries/{key}/metadata".replace("{namespace}", this.namespace).replace("{key}", key);
    const resultPromise = this.axiosInstance.put(url, data, { params });
    return import_sdk3.Validate.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      GameBinaryRecordAdminResponse,
      "GameBinaryRecordAdminResponse"
    );
  }
  /**
   * Request presigned URL to upload the binary record to s3. Other detail info: Supported file types: jpeg, jpg, png, bmp, gif, mp3, webp, and bin.
   */
  createPresigned_ByKey(key, data) {
    const params = {};
    const url = "/cloudsave/v1/admin/namespaces/{namespace}/binaries/{key}/presigned".replace("{namespace}", this.namespace).replace("{key}", key);
    const resultPromise = this.axiosInstance.post(url, data, { params });
    return import_sdk3.Validate.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      UploadBinaryRecordResponse,
      "UploadBinaryRecordResponse"
    );
  }
};

// src/generated-admin/GameBinaryRecordAdminApi.ts
function GameBinaryRecordAdminApi(sdk, args) {
  const sdkAssembly = sdk.assembly();
  const namespace = args?.coreConfig?.namespace ?? sdkAssembly.coreConfig.namespace;
  const useSchemaValidation = args?.coreConfig?.useSchemaValidation ?? sdkAssembly.coreConfig.useSchemaValidation;
  let axiosInstance = sdkAssembly.axiosInstance;
  const requestConfigOverrides = args?.axiosConfig?.request;
  const baseURLOverride = args?.coreConfig?.baseURL;
  const interceptorsOverride = args?.axiosConfig?.interceptors ?? [];
  if (requestConfigOverrides || baseURLOverride || interceptorsOverride.length > 0) {
    const requestConfig = import_sdk4.ApiUtils.mergeAxiosConfigs(sdkAssembly.axiosInstance.defaults, {
      ...baseURLOverride ? { baseURL: baseURLOverride } : {},
      ...requestConfigOverrides
    });
    axiosInstance = import_sdk4.Network.create(requestConfig);
    for (const interceptor of interceptorsOverride) {
      if (interceptor.type === "request") {
        axiosInstance.interceptors.request.use(interceptor.onRequest, interceptor.onError);
      }
      if (interceptor.type === "response") {
        axiosInstance.interceptors.response.use(interceptor.onSuccess, interceptor.onError);
      }
    }
  }
  async function getBinaries(queryParams) {
    const $ = new GameBinaryRecordAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getBinaries(queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function createBinary(data) {
    const $ = new GameBinaryRecordAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.createBinary(data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function deleteBinary_ByKey(key) {
    const $ = new GameBinaryRecordAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.deleteBinary_ByKey(key);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getBinary_ByKey(key) {
    const $ = new GameBinaryRecordAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getBinary_ByKey(key);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function updateBinary_ByKey(key, data) {
    const $ = new GameBinaryRecordAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.updateBinary_ByKey(key, data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function updateMetadata_ByKey(key, data) {
    const $ = new GameBinaryRecordAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.updateMetadata_ByKey(key, data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function createPresigned_ByKey(key, data) {
    const $ = new GameBinaryRecordAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.createPresigned_ByKey(key, data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  return {
    /**
     * Retrieve list of binary records by namespace.
     */
    getBinaries,
    /**
     * Create a game binary record. Other detail info: `key` should follow these rules: 1. support uppercase and lowercase letters, numbers, and separators **&#34;-&#34;**, **&#34;_&#34;**, **&#34;.&#34;** are allowed 2. begin and end with letters or numbers 3. spaces are not allowed 4. separators must not appears twice in a row Supported file types: jpeg, jpg, png, bmp, gif, mp3, webp, and bin.
     */
    createBinary,
    /**
     * Delete a game binary record.
     */
    deleteBinary_ByKey,
    /**
     * Get a game binary record by its key.
     */
    getBinary_ByKey,
    /**
     * Update a game binary record file by its key
     */
    updateBinary_ByKey,
    /**
     * Update a game binary record metadata by its key
     */
    updateMetadata_ByKey,
    /**
     * Request presigned URL to upload the binary record to s3. Other detail info: Supported file types: jpeg, jpg, png, bmp, gif, mp3, webp, and bin.
     */
    createPresigned_ByKey
  };
}

// src/generated-admin/queries/GameBinaryRecordAdmin.query.ts
var Key_GameBinaryRecordAdmin = /* @__PURE__ */ ((Key_GameBinaryRecordAdmin2) => {
  Key_GameBinaryRecordAdmin2["Binaries"] = "Cloudsave.GameBinaryRecordAdmin.Binaries";
  Key_GameBinaryRecordAdmin2["Binary"] = "Cloudsave.GameBinaryRecordAdmin.Binary";
  Key_GameBinaryRecordAdmin2["Binary_ByKey"] = "Cloudsave.GameBinaryRecordAdmin.Binary_ByKey";
  Key_GameBinaryRecordAdmin2["Metadata_ByKey"] = "Cloudsave.GameBinaryRecordAdmin.Metadata_ByKey";
  Key_GameBinaryRecordAdmin2["Presigned_ByKey"] = "Cloudsave.GameBinaryRecordAdmin.Presigned_ByKey";
  return Key_GameBinaryRecordAdmin2;
})(Key_GameBinaryRecordAdmin || {});
var useGameBinaryRecordAdminApi_GetBinaries = (sdk, input, options, callback) => {
  const queryFn = (sdk2, input2) => async () => {
    const response = await GameBinaryRecordAdminApi(sdk2, { coreConfig: input2.coreConfig, axiosConfig: input2.axiosConfig }).getBinaries(
      input2.queryParams
    );
    callback && callback(response);
    return response.data;
  };
  return (0, import_react_query2.useQuery)({
    queryKey: ["Cloudsave.GameBinaryRecordAdmin.Binaries" /* Binaries */, input],
    queryFn: queryFn(sdk, input),
    ...options
  });
};
var useGameBinaryRecordAdminApi_CreateBinaryMutation = (sdk, options, callback) => {
  const mutationFn = async (input) => {
    const response = await GameBinaryRecordAdminApi(sdk, { coreConfig: input.coreConfig, axiosConfig: input.axiosConfig }).createBinary(
      input.data
    );
    callback && callback(response.data);
    return response.data;
  };
  return (0, import_react_query2.useMutation)({
    mutationKey: ["Cloudsave.GameBinaryRecordAdmin.Binary" /* Binary */],
    mutationFn,
    ...options
  });
};
var useGameBinaryRecordAdminApi_DeleteBinary_ByKeyMutation = (sdk, options, callback) => {
  const mutationFn = async (input) => {
    const response = await GameBinaryRecordAdminApi(sdk, {
      coreConfig: input.coreConfig,
      axiosConfig: input.axiosConfig
    }).deleteBinary_ByKey(input.key);
    callback && callback(response.data);
    return response.data;
  };
  return (0, import_react_query2.useMutation)({
    mutationKey: ["Cloudsave.GameBinaryRecordAdmin.Binary_ByKey" /* Binary_ByKey */],
    mutationFn,
    ...options
  });
};
var useGameBinaryRecordAdminApi_GetBinary_ByKey = (sdk, input, options, callback) => {
  const queryFn = (sdk2, input2) => async () => {
    const response = await GameBinaryRecordAdminApi(sdk2, { coreConfig: input2.coreConfig, axiosConfig: input2.axiosConfig }).getBinary_ByKey(
      input2.key
    );
    callback && callback(response);
    return response.data;
  };
  return (0, import_react_query2.useQuery)({
    queryKey: ["Cloudsave.GameBinaryRecordAdmin.Binary_ByKey" /* Binary_ByKey */, input],
    queryFn: queryFn(sdk, input),
    ...options
  });
};
var useGameBinaryRecordAdminApi_UpdateBinary_ByKeyMutation = (sdk, options, callback) => {
  const mutationFn = async (input) => {
    const response = await GameBinaryRecordAdminApi(sdk, {
      coreConfig: input.coreConfig,
      axiosConfig: input.axiosConfig
    }).updateBinary_ByKey(input.key, input.data);
    callback && callback(response.data);
    return response.data;
  };
  return (0, import_react_query2.useMutation)({
    mutationKey: ["Cloudsave.GameBinaryRecordAdmin.Binary_ByKey" /* Binary_ByKey */],
    mutationFn,
    ...options
  });
};
var useGameBinaryRecordAdminApi_UpdateMetadata_ByKeyMutation = (sdk, options, callback) => {
  const mutationFn = async (input) => {
    const response = await GameBinaryRecordAdminApi(sdk, {
      coreConfig: input.coreConfig,
      axiosConfig: input.axiosConfig
    }).updateMetadata_ByKey(input.key, input.data);
    callback && callback(response.data);
    return response.data;
  };
  return (0, import_react_query2.useMutation)({
    mutationKey: ["Cloudsave.GameBinaryRecordAdmin.Metadata_ByKey" /* Metadata_ByKey */],
    mutationFn,
    ...options
  });
};
var useGameBinaryRecordAdminApi_CreatePresigned_ByKeyMutation = (sdk, options, callback) => {
  const mutationFn = async (input) => {
    const response = await GameBinaryRecordAdminApi(sdk, {
      coreConfig: input.coreConfig,
      axiosConfig: input.axiosConfig
    }).createPresigned_ByKey(input.key, input.data);
    callback && callback(response.data);
    return response.data;
  };
  return (0, import_react_query2.useMutation)({
    mutationKey: ["Cloudsave.GameBinaryRecordAdmin.Presigned_ByKey" /* Presigned_ByKey */],
    mutationFn,
    ...options
  });
};

// src/generated-admin/queries/GameRecordAdmin.query.ts
var import_react_query3 = require("@tanstack/react-query");

// src/generated-admin/GameRecordAdminApi.ts
var import_sdk6 = require("@accelbyte/sdk");

// src/generated-admin/endpoints/GameRecordAdmin$.ts
var import_sdk5 = require("@accelbyte/sdk");
var import_zod12 = require("zod");

// src/generated-definitions/GameRecordAdminResponse.ts
var import_zod10 = require("zod");
var GameRecordAdminResponse = import_zod10.z.object({
  created_at: import_zod10.z.string(),
  key: import_zod10.z.string(),
  namespace: import_zod10.z.string(),
  set_by: import_zod10.z.enum(["CLIENT", "SERVER"]).nullish(),
  tags: import_zod10.z.array(import_zod10.z.string()).nullish(),
  ttl_config: TtlConfigDto.nullish(),
  updated_at: import_zod10.z.string(),
  value: import_zod10.z.record(import_zod10.z.any())
});

// src/generated-definitions/ListGameRecordKeysResponse.ts
var import_zod11 = require("zod");
var ListGameRecordKeysResponse = import_zod11.z.object({ data: import_zod11.z.array(import_zod11.z.string()), paging: Pagination });

// src/generated-admin/endpoints/GameRecordAdmin$.ts
var GameRecordAdmin$ = class {
  // @ts-ignore
  // prettier-ignore
  constructor(axiosInstance, namespace, useSchemaValidation = true) {
    this.axiosInstance = axiosInstance;
    this.namespace = namespace;
    this.useSchemaValidation = useSchemaValidation;
  }
  /**
   * Retrieve list of records key by namespace
   */
  getRecords(queryParams) {
    const params = { ...queryParams };
    const url = "/cloudsave/v1/admin/namespaces/{namespace}/records".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.get(url, { params });
    return import_sdk5.Validate.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      ListGameRecordKeysResponse,
      "ListGameRecordKeysResponse"
    );
  }
  /**
   * This endpoints delete game record in namespace-level
   */
  deleteRecord_ByKey(key) {
    const params = {};
    const url = "/cloudsave/v1/admin/namespaces/{namespace}/records/{key}".replace("{namespace}", this.namespace).replace("{key}", key);
    const resultPromise = this.axiosInstance.delete(url, { params });
    return import_sdk5.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, import_zod12.z.unknown(), "z.unknown()");
  }
  /**
   * Get a record by its key in namespace-level.
   */
  getRecord_ByKey(key) {
    const params = {};
    const url = "/cloudsave/v1/admin/namespaces/{namespace}/records/{key}".replace("{namespace}", this.namespace).replace("{key}", key);
    const resultPromise = this.axiosInstance.get(url, { params });
    return import_sdk5.Validate.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      GameRecordAdminResponse,
      "GameRecordAdminResponse"
    );
  }
  /**
   * ## Description This endpoints will create new game record or append the existing game record. **Append example:** Example 1 - Existing JSON: `{ &#34;data1&#34;: &#34;value&#34; }` - New JSON: `{ &#34;data2&#34;: &#34;new value&#34; }` - Result: `{ &#34;data1&#34;: &#34;value&#34;, &#34;data2&#34;: &#34;new value&#34; }` Example 2 - Existing JSON: `{ &#34;data1&#34;: { &#34;data2&#34;: &#34;value&#34; }` - New JSON: `{ &#34;data1&#34;: { &#34;data3&#34;: &#34;new value&#34; }` - Result: `{ &#34;data1&#34;: { &#34;data2&#34;: &#34;value&#34;, &#34;data3&#34;: &#34;new value&#34; }` ## Restriction This is the restriction of Key Naming for the record: 1. Cannot use **&#34;.&#34;** as the key name - `{ &#34;data.2&#34;: &#34;value&#34; }` 2. Cannot use **&#34;$&#34;** as the prefix in key names - `{ &#34;$data&#34;: &#34;value&#34; }` 3. Cannot use empty string in key names - `{ &#34;&#34;: &#34;value&#34; }` ## Record Metadata Metadata allows user to define the behaviour of the record. Metadata can be defined in request body with field name **__META**. When creating record, if **__META** field is not defined, the metadata value will use the default value. When updating record, if **__META** field is not defined, the existing metadata value will stay as is. **Metadata List:** 1. set_by (default: CLIENT, type: string) Indicate which party that could modify the game record. SERVER: record can be modified by server only. CLIENT: record can be modified by client and server. 2. ttl_config (default: *empty*, type: object) Indicate the TTL configuration for the game record. action: - DELETE: record will be deleted after TTL is reached 3. tags (default: *empty array*, type: array of string) Indicate the tagging for the game record. **Request Body Example:** ``` { &#34;__META&#34;: { &#34;set_by&#34;: &#34;SERVER&#34;, &#34;ttl_config&#34;: { &#34;expires_at&#34;: &#34;2026-01-02T15:04:05Z&#34;, // should be in RFC3339 format &#34;action&#34;: &#34;DELETE&#34; }, &#34;tags&#34;: [&#34;tag1&#34;, &#34;tag2&#34;] } ... } ```
   */
  createRecord_ByKey(key, data) {
    const params = {};
    const url = "/cloudsave/v1/admin/namespaces/{namespace}/records/{key}".replace("{namespace}", this.namespace).replace("{key}", key);
    const resultPromise = this.axiosInstance.post(url, data, { params });
    return import_sdk5.Validate.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      GameRecordAdminResponse,
      "GameRecordAdminResponse"
    );
  }
  /**
   * ## Description This endpoints will create new game record or replace the existing game record. **Replace behaviour:** The existing value will be replaced completely with the new value. Example - Existing JSON: `{ &#34;data1&#34;: &#34;value&#34; }` - New JSON: `{ &#34;data2&#34;: &#34;new value&#34; }` - Result: `{ &#34;data2&#34;: &#34;new value&#34; }` ## Restriction This is the restriction of Key Naming for the record: 1. Cannot use **&#34;.&#34;** as the key name - `{ &#34;data.2&#34;: &#34;value&#34; }` 2. Cannot use **&#34;$&#34;** as the prefix in key names - `{ &#34;$data&#34;: &#34;value&#34; }` 3. Cannot use empty string in key names - `{ &#34;&#34;: &#34;value&#34; }` ## Record Metadata Metadata allows user to define the behaviour of the record. Metadata can be defined in request body with field name **__META**. When creating record, if **__META** field is not defined, the metadata value will use the default value. When updating record, if **__META** field is not defined, the existing metadata value will stay as is. **Metadata List:** 1. set_by (default: CLIENT, type: string) Indicate which party that could modify the game record. SERVER: record can be modified by server only. CLIENT: record can be modified by client and server. 2. ttl_config (default: *empty*, type: object) Indicate the TTL configuration for the game record. action: - DELETE: record will be deleted after TTL is reached 3. tags (default: *empty array*, type: array of string) Indicate the tagging for the game record. **Request Body Example:** ``` { &#34;__META&#34;: { &#34;set_by&#34;: &#34;SERVER&#34;, &#34;ttl_config&#34;: { &#34;expires_at&#34;: &#34;2026-01-02T15:04:05Z&#34;, // should be in RFC3339 format &#34;action&#34;: &#34;DELETE&#34; }, &#34;tags&#34;: [&#34;tag1&#34;, &#34;tag2&#34;] } ... } ```
   */
  updateRecord_ByKey(key, data) {
    const params = {};
    const url = "/cloudsave/v1/admin/namespaces/{namespace}/records/{key}".replace("{namespace}", this.namespace).replace("{key}", key);
    const resultPromise = this.axiosInstance.put(url, data, { params });
    return import_sdk5.Validate.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      GameRecordAdminResponse,
      "GameRecordAdminResponse"
    );
  }
};

// src/generated-admin/GameRecordAdminApi.ts
function GameRecordAdminApi(sdk, args) {
  const sdkAssembly = sdk.assembly();
  const namespace = args?.coreConfig?.namespace ?? sdkAssembly.coreConfig.namespace;
  const useSchemaValidation = args?.coreConfig?.useSchemaValidation ?? sdkAssembly.coreConfig.useSchemaValidation;
  let axiosInstance = sdkAssembly.axiosInstance;
  const requestConfigOverrides = args?.axiosConfig?.request;
  const baseURLOverride = args?.coreConfig?.baseURL;
  const interceptorsOverride = args?.axiosConfig?.interceptors ?? [];
  if (requestConfigOverrides || baseURLOverride || interceptorsOverride.length > 0) {
    const requestConfig = import_sdk6.ApiUtils.mergeAxiosConfigs(sdkAssembly.axiosInstance.defaults, {
      ...baseURLOverride ? { baseURL: baseURLOverride } : {},
      ...requestConfigOverrides
    });
    axiosInstance = import_sdk6.Network.create(requestConfig);
    for (const interceptor of interceptorsOverride) {
      if (interceptor.type === "request") {
        axiosInstance.interceptors.request.use(interceptor.onRequest, interceptor.onError);
      }
      if (interceptor.type === "response") {
        axiosInstance.interceptors.response.use(interceptor.onSuccess, interceptor.onError);
      }
    }
  }
  async function getRecords(queryParams) {
    const $ = new GameRecordAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getRecords(queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function deleteRecord_ByKey(key) {
    const $ = new GameRecordAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.deleteRecord_ByKey(key);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getRecord_ByKey(key) {
    const $ = new GameRecordAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getRecord_ByKey(key);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function createRecord_ByKey(key, data) {
    const $ = new GameRecordAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.createRecord_ByKey(key, data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function updateRecord_ByKey(key, data) {
    const $ = new GameRecordAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.updateRecord_ByKey(key, data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  return {
    /**
     * Retrieve list of records key by namespace
     */
    getRecords,
    /**
     * This endpoints delete game record in namespace-level
     */
    deleteRecord_ByKey,
    /**
     * Get a record by its key in namespace-level.
     */
    getRecord_ByKey,
    /**
     * ## Description This endpoints will create new game record or append the existing game record. **Append example:** Example 1 - Existing JSON: `{ &#34;data1&#34;: &#34;value&#34; }` - New JSON: `{ &#34;data2&#34;: &#34;new value&#34; }` - Result: `{ &#34;data1&#34;: &#34;value&#34;, &#34;data2&#34;: &#34;new value&#34; }` Example 2 - Existing JSON: `{ &#34;data1&#34;: { &#34;data2&#34;: &#34;value&#34; }` - New JSON: `{ &#34;data1&#34;: { &#34;data3&#34;: &#34;new value&#34; }` - Result: `{ &#34;data1&#34;: { &#34;data2&#34;: &#34;value&#34;, &#34;data3&#34;: &#34;new value&#34; }` ## Restriction This is the restriction of Key Naming for the record: 1. Cannot use **&#34;.&#34;** as the key name - `{ &#34;data.2&#34;: &#34;value&#34; }` 2. Cannot use **&#34;$&#34;** as the prefix in key names - `{ &#34;$data&#34;: &#34;value&#34; }` 3. Cannot use empty string in key names - `{ &#34;&#34;: &#34;value&#34; }` ## Record Metadata Metadata allows user to define the behaviour of the record. Metadata can be defined in request body with field name **__META**. When creating record, if **__META** field is not defined, the metadata value will use the default value. When updating record, if **__META** field is not defined, the existing metadata value will stay as is. **Metadata List:** 1. set_by (default: CLIENT, type: string) Indicate which party that could modify the game record. SERVER: record can be modified by server only. CLIENT: record can be modified by client and server. 2. ttl_config (default: *empty*, type: object) Indicate the TTL configuration for the game record. action: - DELETE: record will be deleted after TTL is reached 3. tags (default: *empty array*, type: array of string) Indicate the tagging for the game record. **Request Body Example:** ``` { &#34;__META&#34;: { &#34;set_by&#34;: &#34;SERVER&#34;, &#34;ttl_config&#34;: { &#34;expires_at&#34;: &#34;2026-01-02T15:04:05Z&#34;, // should be in RFC3339 format &#34;action&#34;: &#34;DELETE&#34; }, &#34;tags&#34;: [&#34;tag1&#34;, &#34;tag2&#34;] } ... } ```
     */
    createRecord_ByKey,
    /**
     * ## Description This endpoints will create new game record or replace the existing game record. **Replace behaviour:** The existing value will be replaced completely with the new value. Example - Existing JSON: `{ &#34;data1&#34;: &#34;value&#34; }` - New JSON: `{ &#34;data2&#34;: &#34;new value&#34; }` - Result: `{ &#34;data2&#34;: &#34;new value&#34; }` ## Restriction This is the restriction of Key Naming for the record: 1. Cannot use **&#34;.&#34;** as the key name - `{ &#34;data.2&#34;: &#34;value&#34; }` 2. Cannot use **&#34;$&#34;** as the prefix in key names - `{ &#34;$data&#34;: &#34;value&#34; }` 3. Cannot use empty string in key names - `{ &#34;&#34;: &#34;value&#34; }` ## Record Metadata Metadata allows user to define the behaviour of the record. Metadata can be defined in request body with field name **__META**. When creating record, if **__META** field is not defined, the metadata value will use the default value. When updating record, if **__META** field is not defined, the existing metadata value will stay as is. **Metadata List:** 1. set_by (default: CLIENT, type: string) Indicate which party that could modify the game record. SERVER: record can be modified by server only. CLIENT: record can be modified by client and server. 2. ttl_config (default: *empty*, type: object) Indicate the TTL configuration for the game record. action: - DELETE: record will be deleted after TTL is reached 3. tags (default: *empty array*, type: array of string) Indicate the tagging for the game record. **Request Body Example:** ``` { &#34;__META&#34;: { &#34;set_by&#34;: &#34;SERVER&#34;, &#34;ttl_config&#34;: { &#34;expires_at&#34;: &#34;2026-01-02T15:04:05Z&#34;, // should be in RFC3339 format &#34;action&#34;: &#34;DELETE&#34; }, &#34;tags&#34;: [&#34;tag1&#34;, &#34;tag2&#34;] } ... } ```
     */
    updateRecord_ByKey
  };
}

// src/generated-admin/queries/GameRecordAdmin.query.ts
var Key_GameRecordAdmin = /* @__PURE__ */ ((Key_GameRecordAdmin2) => {
  Key_GameRecordAdmin2["Records"] = "Cloudsave.GameRecordAdmin.Records";
  Key_GameRecordAdmin2["Record_ByKey"] = "Cloudsave.GameRecordAdmin.Record_ByKey";
  return Key_GameRecordAdmin2;
})(Key_GameRecordAdmin || {});
var useGameRecordAdminApi_GetRecords = (sdk, input, options, callback) => {
  const queryFn = (sdk2, input2) => async () => {
    const response = await GameRecordAdminApi(sdk2, { coreConfig: input2.coreConfig, axiosConfig: input2.axiosConfig }).getRecords(
      input2.queryParams
    );
    callback && callback(response);
    return response.data;
  };
  return (0, import_react_query3.useQuery)({
    queryKey: ["Cloudsave.GameRecordAdmin.Records" /* Records */, input],
    queryFn: queryFn(sdk, input),
    ...options
  });
};
var useGameRecordAdminApi_DeleteRecord_ByKeyMutation = (sdk, options, callback) => {
  const mutationFn = async (input) => {
    const response = await GameRecordAdminApi(sdk, { coreConfig: input.coreConfig, axiosConfig: input.axiosConfig }).deleteRecord_ByKey(
      input.key
    );
    callback && callback(response.data);
    return response.data;
  };
  return (0, import_react_query3.useMutation)({
    mutationKey: ["Cloudsave.GameRecordAdmin.Record_ByKey" /* Record_ByKey */],
    mutationFn,
    ...options
  });
};
var useGameRecordAdminApi_GetRecord_ByKey = (sdk, input, options, callback) => {
  const queryFn = (sdk2, input2) => async () => {
    const response = await GameRecordAdminApi(sdk2, { coreConfig: input2.coreConfig, axiosConfig: input2.axiosConfig }).getRecord_ByKey(
      input2.key
    );
    callback && callback(response);
    return response.data;
  };
  return (0, import_react_query3.useQuery)({
    queryKey: ["Cloudsave.GameRecordAdmin.Record_ByKey" /* Record_ByKey */, input],
    queryFn: queryFn(sdk, input),
    ...options
  });
};
var useGameRecordAdminApi_CreateRecord_ByKeyMutation = (sdk, options, callback) => {
  const mutationFn = async (input) => {
    const response = await GameRecordAdminApi(sdk, { coreConfig: input.coreConfig, axiosConfig: input.axiosConfig }).createRecord_ByKey(
      input.key,
      input.data
    );
    callback && callback(response.data);
    return response.data;
  };
  return (0, import_react_query3.useMutation)({
    mutationKey: ["Cloudsave.GameRecordAdmin.Record_ByKey" /* Record_ByKey */],
    mutationFn,
    ...options
  });
};
var useGameRecordAdminApi_UpdateRecord_ByKeyMutation = (sdk, options, callback) => {
  const mutationFn = async (input) => {
    const response = await GameRecordAdminApi(sdk, { coreConfig: input.coreConfig, axiosConfig: input.axiosConfig }).updateRecord_ByKey(
      input.key,
      input.data
    );
    callback && callback(response.data);
    return response.data;
  };
  return (0, import_react_query3.useMutation)({
    mutationKey: ["Cloudsave.GameRecordAdmin.Record_ByKey" /* Record_ByKey */],
    mutationFn,
    ...options
  });
};

// src/generated-admin/queries/PlayerBinaryRecordAdmin.query.ts
var import_react_query4 = require("@tanstack/react-query");

// src/generated-admin/PlayerBinaryRecordAdminApi.ts
var import_sdk8 = require("@accelbyte/sdk");

// src/generated-admin/endpoints/PlayerBinaryRecordAdmin$.ts
var import_sdk7 = require("@accelbyte/sdk");
var import_zod15 = require("zod");

// src/generated-definitions/ListPlayerBinaryRecordsResponse.ts
var import_zod14 = require("zod");

// src/generated-definitions/PlayerBinaryRecordResponse.ts
var import_zod13 = require("zod");
var PlayerBinaryRecordResponse = import_zod13.z.object({
  binary_info: BinaryInfoResponse.nullish(),
  created_at: import_zod13.z.string(),
  is_public: import_zod13.z.boolean(),
  key: import_zod13.z.string(),
  namespace: import_zod13.z.string(),
  set_by: import_zod13.z.enum(["CLIENT", "SERVER"]).nullish(),
  tags: import_zod13.z.array(import_zod13.z.string()).nullish(),
  updated_at: import_zod13.z.string(),
  user_id: import_zod13.z.string()
});

// src/generated-definitions/ListPlayerBinaryRecordsResponse.ts
var ListPlayerBinaryRecordsResponse = import_zod14.z.object({ data: import_zod14.z.array(PlayerBinaryRecordResponse), paging: Pagination });

// src/generated-admin/endpoints/PlayerBinaryRecordAdmin$.ts
var PlayerBinaryRecordAdmin$ = class {
  // @ts-ignore
  // prettier-ignore
  constructor(axiosInstance, namespace, useSchemaValidation = true) {
    this.axiosInstance = axiosInstance;
    this.namespace = namespace;
    this.useSchemaValidation = useSchemaValidation;
  }
  /**
   * Retrieve list of player binary records by namespace.
   */
  getBinaries_ByUserId(userId, queryParams) {
    const params = { limit: 25, ...queryParams };
    const url = "/cloudsave/v1/admin/namespaces/{namespace}/users/{userId}/binaries".replace("{namespace}", this.namespace).replace("{userId}", userId);
    const resultPromise = this.axiosInstance.get(url, { params });
    return import_sdk7.Validate.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      ListPlayerBinaryRecordsResponse,
      "ListPlayerBinaryRecordsResponse"
    );
  }
  /**
   * Create a player binary record. Other detail info: `key` should follow these rules: 1. support uppercase and lowercase letters, numbers, and separators **&#34;-&#34;**, **&#34;_&#34;**, **&#34;.&#34;** are allowed 2. begin and end with letters or numbers 3. spaces are not allowed 4. separators must not appears twice in a row Supported file types: jpeg, jpg, png, bmp, gif, mp3, webp, and bin.
   */
  createBinary_ByUserId(userId, data) {
    const params = {};
    const url = "/cloudsave/v1/admin/namespaces/{namespace}/users/{userId}/binaries".replace("{namespace}", this.namespace).replace("{userId}", userId);
    const resultPromise = this.axiosInstance.post(url, data, { params });
    return import_sdk7.Validate.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      UploadBinaryRecordResponse,
      "UploadBinaryRecordResponse"
    );
  }
  /**
   * Delete a player binary record.
   */
  deleteBinary_ByUserId_ByKey(userId, key) {
    const params = {};
    const url = "/cloudsave/v1/admin/namespaces/{namespace}/users/{userId}/binaries/{key}".replace("{namespace}", this.namespace).replace("{userId}", userId).replace("{key}", key);
    const resultPromise = this.axiosInstance.delete(url, { params });
    return import_sdk7.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, import_zod15.z.unknown(), "z.unknown()");
  }
  /**
   * Get a player binary record by its key.
   */
  getBinary_ByUserId_ByKey(userId, key) {
    const params = {};
    const url = "/cloudsave/v1/admin/namespaces/{namespace}/users/{userId}/binaries/{key}".replace("{namespace}", this.namespace).replace("{userId}", userId).replace("{key}", key);
    const resultPromise = this.axiosInstance.get(url, { params });
    return import_sdk7.Validate.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      PlayerBinaryRecordResponse,
      "PlayerBinaryRecordResponse"
    );
  }
  /**
   * Update a player binary record file by its key
   */
  updateBinary_ByUserId_ByKey(userId, key, data) {
    const params = {};
    const url = "/cloudsave/v1/admin/namespaces/{namespace}/users/{userId}/binaries/{key}".replace("{namespace}", this.namespace).replace("{userId}", userId).replace("{key}", key);
    const resultPromise = this.axiosInstance.put(url, data, { params });
    return import_sdk7.Validate.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      PlayerBinaryRecordResponse,
      "PlayerBinaryRecordResponse"
    );
  }
  /**
   * Update a player binary record metadata by its key
   */
  updateMetadata_ByUserId_ByKey(userId, key, data) {
    const params = {};
    const url = "/cloudsave/v1/admin/namespaces/{namespace}/users/{userId}/binaries/{key}/metadata".replace("{namespace}", this.namespace).replace("{userId}", userId).replace("{key}", key);
    const resultPromise = this.axiosInstance.put(url, data, { params });
    return import_sdk7.Validate.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      PlayerBinaryRecordResponse,
      "PlayerBinaryRecordResponse"
    );
  }
  /**
   * Request presigned URL to upload the binary record to s3. Other detail info: Supported file types: jpeg, jpg, png, bmp, gif, mp3, webp, and bin.
   */
  createPresigned_ByUserId_ByKey(userId, key, data) {
    const params = {};
    const url = "/cloudsave/v1/admin/namespaces/{namespace}/users/{userId}/binaries/{key}/presigned".replace("{namespace}", this.namespace).replace("{userId}", userId).replace("{key}", key);
    const resultPromise = this.axiosInstance.post(url, data, { params });
    return import_sdk7.Validate.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      UploadBinaryRecordResponse,
      "UploadBinaryRecordResponse"
    );
  }
};

// src/generated-admin/PlayerBinaryRecordAdminApi.ts
function PlayerBinaryRecordAdminApi(sdk, args) {
  const sdkAssembly = sdk.assembly();
  const namespace = args?.coreConfig?.namespace ?? sdkAssembly.coreConfig.namespace;
  const useSchemaValidation = args?.coreConfig?.useSchemaValidation ?? sdkAssembly.coreConfig.useSchemaValidation;
  let axiosInstance = sdkAssembly.axiosInstance;
  const requestConfigOverrides = args?.axiosConfig?.request;
  const baseURLOverride = args?.coreConfig?.baseURL;
  const interceptorsOverride = args?.axiosConfig?.interceptors ?? [];
  if (requestConfigOverrides || baseURLOverride || interceptorsOverride.length > 0) {
    const requestConfig = import_sdk8.ApiUtils.mergeAxiosConfigs(sdkAssembly.axiosInstance.defaults, {
      ...baseURLOverride ? { baseURL: baseURLOverride } : {},
      ...requestConfigOverrides
    });
    axiosInstance = import_sdk8.Network.create(requestConfig);
    for (const interceptor of interceptorsOverride) {
      if (interceptor.type === "request") {
        axiosInstance.interceptors.request.use(interceptor.onRequest, interceptor.onError);
      }
      if (interceptor.type === "response") {
        axiosInstance.interceptors.response.use(interceptor.onSuccess, interceptor.onError);
      }
    }
  }
  async function getBinaries_ByUserId(userId, queryParams) {
    const $ = new PlayerBinaryRecordAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getBinaries_ByUserId(userId, queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function createBinary_ByUserId(userId, data) {
    const $ = new PlayerBinaryRecordAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.createBinary_ByUserId(userId, data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function deleteBinary_ByUserId_ByKey(userId, key) {
    const $ = new PlayerBinaryRecordAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.deleteBinary_ByUserId_ByKey(userId, key);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getBinary_ByUserId_ByKey(userId, key) {
    const $ = new PlayerBinaryRecordAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getBinary_ByUserId_ByKey(userId, key);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function updateBinary_ByUserId_ByKey(userId, key, data) {
    const $ = new PlayerBinaryRecordAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.updateBinary_ByUserId_ByKey(userId, key, data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function updateMetadata_ByUserId_ByKey(userId, key, data) {
    const $ = new PlayerBinaryRecordAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.updateMetadata_ByUserId_ByKey(userId, key, data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function createPresigned_ByUserId_ByKey(userId, key, data) {
    const $ = new PlayerBinaryRecordAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.createPresigned_ByUserId_ByKey(userId, key, data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  return {
    /**
     * Retrieve list of player binary records by namespace.
     */
    getBinaries_ByUserId,
    /**
     * Create a player binary record. Other detail info: `key` should follow these rules: 1. support uppercase and lowercase letters, numbers, and separators **&#34;-&#34;**, **&#34;_&#34;**, **&#34;.&#34;** are allowed 2. begin and end with letters or numbers 3. spaces are not allowed 4. separators must not appears twice in a row Supported file types: jpeg, jpg, png, bmp, gif, mp3, webp, and bin.
     */
    createBinary_ByUserId,
    /**
     * Delete a player binary record.
     */
    deleteBinary_ByUserId_ByKey,
    /**
     * Get a player binary record by its key.
     */
    getBinary_ByUserId_ByKey,
    /**
     * Update a player binary record file by its key
     */
    updateBinary_ByUserId_ByKey,
    /**
     * Update a player binary record metadata by its key
     */
    updateMetadata_ByUserId_ByKey,
    /**
     * Request presigned URL to upload the binary record to s3. Other detail info: Supported file types: jpeg, jpg, png, bmp, gif, mp3, webp, and bin.
     */
    createPresigned_ByUserId_ByKey
  };
}

// src/generated-admin/queries/PlayerBinaryRecordAdmin.query.ts
var Key_PlayerBinaryRecordAdmin = /* @__PURE__ */ ((Key_PlayerBinaryRecordAdmin2) => {
  Key_PlayerBinaryRecordAdmin2["Binaries_ByUserId"] = "Cloudsave.PlayerBinaryRecordAdmin.Binaries_ByUserId";
  Key_PlayerBinaryRecordAdmin2["Binary_ByUserId"] = "Cloudsave.PlayerBinaryRecordAdmin.Binary_ByUserId";
  Key_PlayerBinaryRecordAdmin2["Binary_ByUserId_ByKey"] = "Cloudsave.PlayerBinaryRecordAdmin.Binary_ByUserId_ByKey";
  Key_PlayerBinaryRecordAdmin2["Metadata_ByUserId_ByKey"] = "Cloudsave.PlayerBinaryRecordAdmin.Metadata_ByUserId_ByKey";
  Key_PlayerBinaryRecordAdmin2["Presigned_ByUserId_ByKey"] = "Cloudsave.PlayerBinaryRecordAdmin.Presigned_ByUserId_ByKey";
  return Key_PlayerBinaryRecordAdmin2;
})(Key_PlayerBinaryRecordAdmin || {});
var usePlayerBinaryRecordAdminApi_GetBinaries_ByUserId = (sdk, input, options, callback) => {
  const queryFn = (sdk2, input2) => async () => {
    const response = await PlayerBinaryRecordAdminApi(sdk2, {
      coreConfig: input2.coreConfig,
      axiosConfig: input2.axiosConfig
    }).getBinaries_ByUserId(input2.userId, input2.queryParams);
    callback && callback(response);
    return response.data;
  };
  return (0, import_react_query4.useQuery)({
    queryKey: ["Cloudsave.PlayerBinaryRecordAdmin.Binaries_ByUserId" /* Binaries_ByUserId */, input],
    queryFn: queryFn(sdk, input),
    ...options
  });
};
var usePlayerBinaryRecordAdminApi_CreateBinary_ByUserIdMutation = (sdk, options, callback) => {
  const mutationFn = async (input) => {
    const response = await PlayerBinaryRecordAdminApi(sdk, {
      coreConfig: input.coreConfig,
      axiosConfig: input.axiosConfig
    }).createBinary_ByUserId(input.userId, input.data);
    callback && callback(response.data);
    return response.data;
  };
  return (0, import_react_query4.useMutation)({
    mutationKey: ["Cloudsave.PlayerBinaryRecordAdmin.Binary_ByUserId" /* Binary_ByUserId */],
    mutationFn,
    ...options
  });
};
var usePlayerBinaryRecordAdminApi_DeleteBinary_ByUserId_ByKeyMutation = (sdk, options, callback) => {
  const mutationFn = async (input) => {
    const response = await PlayerBinaryRecordAdminApi(sdk, {
      coreConfig: input.coreConfig,
      axiosConfig: input.axiosConfig
    }).deleteBinary_ByUserId_ByKey(input.userId, input.key);
    callback && callback(response.data);
    return response.data;
  };
  return (0, import_react_query4.useMutation)({
    mutationKey: ["Cloudsave.PlayerBinaryRecordAdmin.Binary_ByUserId_ByKey" /* Binary_ByUserId_ByKey */],
    mutationFn,
    ...options
  });
};
var usePlayerBinaryRecordAdminApi_GetBinary_ByUserId_ByKey = (sdk, input, options, callback) => {
  const queryFn = (sdk2, input2) => async () => {
    const response = await PlayerBinaryRecordAdminApi(sdk2, {
      coreConfig: input2.coreConfig,
      axiosConfig: input2.axiosConfig
    }).getBinary_ByUserId_ByKey(input2.userId, input2.key);
    callback && callback(response);
    return response.data;
  };
  return (0, import_react_query4.useQuery)({
    queryKey: ["Cloudsave.PlayerBinaryRecordAdmin.Binary_ByUserId_ByKey" /* Binary_ByUserId_ByKey */, input],
    queryFn: queryFn(sdk, input),
    ...options
  });
};
var usePlayerBinaryRecordAdminApi_UpdateBinary_ByUserId_ByKeyMutation = (sdk, options, callback) => {
  const mutationFn = async (input) => {
    const response = await PlayerBinaryRecordAdminApi(sdk, {
      coreConfig: input.coreConfig,
      axiosConfig: input.axiosConfig
    }).updateBinary_ByUserId_ByKey(input.userId, input.key, input.data);
    callback && callback(response.data);
    return response.data;
  };
  return (0, import_react_query4.useMutation)({
    mutationKey: ["Cloudsave.PlayerBinaryRecordAdmin.Binary_ByUserId_ByKey" /* Binary_ByUserId_ByKey */],
    mutationFn,
    ...options
  });
};
var usePlayerBinaryRecordAdminApi_UpdateMetadata_ByUserId_ByKeyMutation = (sdk, options, callback) => {
  const mutationFn = async (input) => {
    const response = await PlayerBinaryRecordAdminApi(sdk, {
      coreConfig: input.coreConfig,
      axiosConfig: input.axiosConfig
    }).updateMetadata_ByUserId_ByKey(input.userId, input.key, input.data);
    callback && callback(response.data);
    return response.data;
  };
  return (0, import_react_query4.useMutation)({
    mutationKey: ["Cloudsave.PlayerBinaryRecordAdmin.Metadata_ByUserId_ByKey" /* Metadata_ByUserId_ByKey */],
    mutationFn,
    ...options
  });
};
var usePlayerBinaryRecordAdminApi_CreatePresigned_ByUserId_ByKeyMutation = (sdk, options, callback) => {
  const mutationFn = async (input) => {
    const response = await PlayerBinaryRecordAdminApi(sdk, {
      coreConfig: input.coreConfig,
      axiosConfig: input.axiosConfig
    }).createPresigned_ByUserId_ByKey(input.userId, input.key, input.data);
    callback && callback(response.data);
    return response.data;
  };
  return (0, import_react_query4.useMutation)({
    mutationKey: ["Cloudsave.PlayerBinaryRecordAdmin.Presigned_ByUserId_ByKey" /* Presigned_ByUserId_ByKey */],
    mutationFn,
    ...options
  });
};

// src/generated-admin/queries/PlayerRecordAdmin.query.ts
var import_react_query5 = require("@tanstack/react-query");

// src/generated-admin/PlayerRecordAdminApi.ts
var import_sdk10 = require("@accelbyte/sdk");

// src/generated-admin/endpoints/PlayerRecordAdmin$.ts
var import_sdk9 = require("@accelbyte/sdk");
var import_zod28 = require("zod");

// src/generated-definitions/BulkGetAdminPlayerRecordResponse.ts
var import_zod17 = require("zod");

// src/generated-definitions/AdminPlayerRecordResponse.ts
var import_zod16 = require("zod");
var AdminPlayerRecordResponse = import_zod16.z.object({
  created_at: import_zod16.z.string(),
  key: import_zod16.z.string(),
  namespace: import_zod16.z.string(),
  tags: import_zod16.z.array(import_zod16.z.string()).nullish(),
  updated_at: import_zod16.z.string(),
  user_id: import_zod16.z.string(),
  value: import_zod16.z.record(import_zod16.z.any())
});

// src/generated-definitions/BulkGetAdminPlayerRecordResponse.ts
var BulkGetAdminPlayerRecordResponse = import_zod17.z.object({ data: import_zod17.z.array(AdminPlayerRecordResponse) });

// src/generated-definitions/BulkGetPlayerRecordResponse.ts
var import_zod19 = require("zod");

// src/generated-definitions/PlayerRecordResponse.ts
var import_zod18 = require("zod");
var PlayerRecordResponse = import_zod18.z.object({
  created_at: import_zod18.z.string(),
  is_public: import_zod18.z.boolean(),
  key: import_zod18.z.string(),
  namespace: import_zod18.z.string(),
  set_by: import_zod18.z.enum(["CLIENT", "SERVER"]).nullish(),
  tags: import_zod18.z.array(import_zod18.z.string()).nullish(),
  updated_at: import_zod18.z.string(),
  user_id: import_zod18.z.string(),
  value: import_zod18.z.record(import_zod18.z.any())
});

// src/generated-definitions/BulkGetPlayerRecordResponse.ts
var BulkGetPlayerRecordResponse = import_zod19.z.object({ data: import_zod19.z.array(PlayerRecordResponse) });

// src/generated-definitions/BulkGetPlayerRecordSizeResponse.ts
var import_zod21 = require("zod");

// src/generated-definitions/PlayerRecordSizeResponse.ts
var import_zod20 = require("zod");
var PlayerRecordSizeResponse = import_zod20.z.object({
  current_size: import_zod20.z.number().int(),
  key: import_zod20.z.string(),
  namespace: import_zod20.z.string(),
  remaining_size: import_zod20.z.number().int(),
  user_id: import_zod20.z.string()
});

// src/generated-definitions/BulkGetPlayerRecordSizeResponse.ts
var BulkGetPlayerRecordSizeResponse = import_zod21.z.object({ data: import_zod21.z.array(PlayerRecordSizeResponse) });

// src/generated-definitions/BulkUpdatePlayerRecordByKeyResponseArray.ts
var import_zod23 = require("zod");

// src/generated-definitions/BulkUpdatePlayerRecordByKeyResponse.ts
var import_zod22 = require("zod");
var BulkUpdatePlayerRecordByKeyResponse = import_zod22.z.object({ detail: import_zod22.z.record(import_zod22.z.any()), success: import_zod22.z.boolean(), user_id: import_zod22.z.string() });

// src/generated-definitions/BulkUpdatePlayerRecordByKeyResponseArray.ts
var BulkUpdatePlayerRecordByKeyResponseArray = import_zod23.z.array(BulkUpdatePlayerRecordByKeyResponse);

// src/generated-definitions/BulkUpdatePlayerRecordResponseArray.ts
var import_zod25 = require("zod");

// src/generated-definitions/BulkUpdatePlayerRecordResponse.ts
var import_zod24 = require("zod");
var BulkUpdatePlayerRecordResponse = import_zod24.z.object({ detail: import_zod24.z.record(import_zod24.z.any()), key: import_zod24.z.string(), success: import_zod24.z.boolean() });

// src/generated-definitions/BulkUpdatePlayerRecordResponseArray.ts
var BulkUpdatePlayerRecordResponseArray = import_zod25.z.array(BulkUpdatePlayerRecordResponse);

// src/generated-definitions/ListPlayerRecordKeysResponse.ts
var import_zod27 = require("zod");

// src/generated-definitions/PlayerRecordKeyInfo.ts
var import_zod26 = require("zod");
var PlayerRecordKeyInfo = import_zod26.z.object({ key: import_zod26.z.string(), user_id: import_zod26.z.string() });

// src/generated-definitions/ListPlayerRecordKeysResponse.ts
var ListPlayerRecordKeysResponse = import_zod27.z.object({ data: import_zod27.z.array(PlayerRecordKeyInfo), paging: Pagination });

// src/generated-admin/endpoints/PlayerRecordAdmin$.ts
var PlayerRecordAdmin$ = class {
  // @ts-ignore
  // prettier-ignore
  constructor(axiosInstance, namespace, useSchemaValidation = true) {
    this.axiosInstance = axiosInstance;
    this.namespace = namespace;
    this.useSchemaValidation = useSchemaValidation;
  }
  /**
   * @deprecated
   * Retrieve list of player records key and userID under given namespace.
   */
  getUsersRecords(queryParams) {
    const params = { limit: 25, ...queryParams };
    const url = "/cloudsave/v1/admin/namespaces/{namespace}/users/records".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.get(url, { params });
    return import_sdk9.Validate.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      ListPlayerRecordKeysResponse,
      "ListPlayerRecordKeysResponse"
    );
  }
  /**
   * Retrieve list of player records key and userID under given namespace.
   */
  getRecords_ByUserId(userId, queryParams) {
    const params = { limit: 25, ...queryParams };
    const url = "/cloudsave/v1/admin/namespaces/{namespace}/users/{userId}/records".replace("{namespace}", this.namespace).replace("{userId}", userId);
    const resultPromise = this.axiosInstance.get(url, { params });
    return import_sdk9.Validate.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      ListPlayerRecordKeysResponse,
      "ListPlayerRecordKeysResponse"
    );
  }
  /**
   * Bulk get player&#39;s record size, max allowed 20 at a time, that can be retrieved using this endpoint.
   */
  fetchUserBulkRecordSize(data) {
    const params = {};
    const url = "/cloudsave/v1/admin/namespaces/{namespace}/users/bulk/records/size".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.post(url, data, { params });
    return import_sdk9.Validate.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      BulkGetPlayerRecordSizeResponse,
      "BulkGetPlayerRecordSizeResponse"
    );
  }
  /**
   * Retrieve player record key and payload in bulk under given namespace. Maximum number of user ids per request is 20.
   */
  fetchBulkUser_ByKey(key, data) {
    const params = {};
    const url = "/cloudsave/v1/admin/namespaces/{namespace}/users/records/{key}/bulk".replace("{namespace}", this.namespace).replace("{key}", key);
    const resultPromise = this.axiosInstance.post(url, data, { params });
    return import_sdk9.Validate.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      BulkGetPlayerRecordResponse,
      "BulkGetPlayerRecordResponse"
    );
  }
  /**
   * This endpoints will create new player record or replace the existing player record in bulk. Maximum number of user ids per request is 10. Maximum total size of the request payload is 5 MB.
   */
  updateBulkUser_ByKey(key, data) {
    const params = {};
    const url = "/cloudsave/v1/admin/namespaces/{namespace}/users/records/{key}/bulk".replace("{namespace}", this.namespace).replace("{key}", key);
    const resultPromise = this.axiosInstance.put(url, data, { params });
    return import_sdk9.Validate.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      BulkUpdatePlayerRecordByKeyResponseArray,
      "BulkUpdatePlayerRecordByKeyResponseArray"
    );
  }
  /**
   * Retrieve player record key and payload in bulk under given namespace. Maximum bulk key limit per request 20.
   */
  fetchRecordBulk_ByUserId(userId, data) {
    const params = {};
    const url = "/cloudsave/v1/admin/namespaces/{namespace}/users/{userId}/records/bulk".replace("{namespace}", this.namespace).replace("{userId}", userId);
    const resultPromise = this.axiosInstance.post(url, data, { params });
    return import_sdk9.Validate.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      BulkGetAdminPlayerRecordResponse,
      "BulkGetAdminPlayerRecordResponse"
    );
  }
  /**
   * This endpoints will create new player record or replace the existing player record in bulk. Maximum bulk key limit per request 10.
   */
  updateRecordBulk_ByUserId(userId, data) {
    const params = {};
    const url = "/cloudsave/v1/admin/namespaces/{namespace}/users/{userId}/records/bulk".replace("{namespace}", this.namespace).replace("{userId}", userId);
    const resultPromise = this.axiosInstance.put(url, data, { params });
    return import_sdk9.Validate.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      BulkUpdatePlayerRecordResponseArray,
      "BulkUpdatePlayerRecordResponseArray"
    );
  }
  /**
   * Delete a record (arbitrary JSON data) in user-level with given key.
   */
  deleteRecord_ByUserId_ByKey(userId, key) {
    const params = {};
    const url = "/cloudsave/v1/admin/namespaces/{namespace}/users/{userId}/records/{key}".replace("{namespace}", this.namespace).replace("{userId}", userId).replace("{key}", key);
    const resultPromise = this.axiosInstance.delete(url, { params });
    return import_sdk9.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, import_zod28.z.unknown(), "z.unknown()");
  }
  /**
   * Get a record in user-level (arbitrary JSON data) by its key.
   */
  getRecord_ByUserId_ByKey(userId, key) {
    const params = {};
    const url = "/cloudsave/v1/admin/namespaces/{namespace}/users/{userId}/records/{key}".replace("{namespace}", this.namespace).replace("{userId}", userId).replace("{key}", key);
    const resultPromise = this.axiosInstance.get(url, { params });
    return import_sdk9.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, PlayerRecordResponse, "PlayerRecordResponse");
  }
  /**
   * ## Description This endpoints will create new player record or append the existing player record. **Append example:** Example 1 - Existing JSON: `{ &#34;data1&#34;: &#34;value&#34; }` - New JSON: `{ &#34;data2&#34;: &#34;new value&#34; }` - Result: `{ &#34;data1&#34;: &#34;value&#34;, &#34;data2&#34;: &#34;new value&#34; }` Example 2 - Existing JSON: `{ &#34;data1&#34;: { &#34;data2&#34;: &#34;value&#34; }` - New JSON: `{ &#34;data1&#34;: { &#34;data3&#34;: &#34;new value&#34; }` - Result: `{ &#34;data1&#34;: { &#34;data2&#34;: &#34;value&#34;, &#34;data3&#34;: &#34;new value&#34; }` ## Restriction This is the restriction of Key Naming for the record: 1. Cannot use **&#34;.&#34;** as the key name - `{ &#34;data.2&#34;: &#34;value&#34; }` 2. Cannot use **&#34;$&#34;** as the prefix in key names - `{ &#34;$data&#34;: &#34;value&#34; }` 3. Cannot use empty string in key names - `{ &#34;&#34;: &#34;value&#34; }` ## Record Metadata Metadata allows user to define the behaviour of the record. Metadata can be defined in request body with field name **__META**. When creating record, if **__META** field is not defined, the metadata value will use the default value. When updating record, if **__META** field is not defined, the existing metadata value will stay as is. **Metadata List:** 1. set_by (default: CLIENT, type: string) Indicate which party that could modify the game record. SERVER: record can be modified by server only. CLIENT: record can be modified by client and server. 2. is_public (default: false, type: bool) Indicate whether the player record is a public record or not. 3. tags (default: *empty array*, type: array of string) Indicate the tagging for the game record. **Request Body Example:** ``` { &#34;__META&#34;: { &#34;set_by&#34;: &#34;SERVER&#34;, &#34;is_public&#34;: true, &#34;tags&#34;: [&#34;tag1&#34;, &#34;tag2&#34;] } ... } ```
   */
  createRecord_ByUserId_ByKey(userId, key, data) {
    const params = {};
    const url = "/cloudsave/v1/admin/namespaces/{namespace}/users/{userId}/records/{key}".replace("{namespace}", this.namespace).replace("{userId}", userId).replace("{key}", key);
    const resultPromise = this.axiosInstance.post(url, data, { params });
    return import_sdk9.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, PlayerRecordResponse, "PlayerRecordResponse");
  }
  /**
   * ## Description This endpoints will create new player record or replace the existing player record. **Replace behaviour:** The existing value will be replaced completely with the new value. Example - Existing JSON: `{ &#34;data1&#34;: &#34;value&#34; }` - New JSON: `{ &#34;data2&#34;: &#34;new value&#34; }` - Result: `{ &#34;data2&#34;: &#34;new value&#34; }` ## Restriction This is the restriction of Key Naming for the record: 1. Cannot use **&#34;.&#34;** as the key name - `{ &#34;data.2&#34;: &#34;value&#34; }` 2. Cannot use **&#34;$&#34;** as the prefix in key names - `{ &#34;$data&#34;: &#34;value&#34; }` 3. Cannot use empty string in key names - `{ &#34;&#34;: &#34;value&#34; }` ## Record Metadata Metadata allows user to define the behaviour of the record. Metadata can be defined in request body with field name **__META**. When creating record, if **__META** field is not defined, the metadata value will use the default value. When updating record, if **__META** field is not defined, the existing metadata value will stay as is. **Metadata List:** 1. set_by (default: CLIENT, type: string) Indicate which party that could modify the game record. SERVER: record can be modified by server only. CLIENT: record can be modified by client and server. 2. is_public (default: false, type: bool) Indicate whether the player record is a public record or not. 3. tags (default: *empty array*, type: array of string) Indicate the tagging for the game record. **Request Body Example:** ``` { &#34;__META&#34;: { &#34;set_by&#34;: &#34;SERVER&#34;, &#34;is_public&#34;: true, &#34;tags&#34;: [&#34;tag1&#34;, &#34;tag2&#34;] } ... } ```
   */
  updateRecord_ByUserId_ByKey(userId, key, data) {
    const params = {};
    const url = "/cloudsave/v1/admin/namespaces/{namespace}/users/{userId}/records/{key}".replace("{namespace}", this.namespace).replace("{userId}", userId).replace("{key}", key);
    const resultPromise = this.axiosInstance.put(url, data, { params });
    return import_sdk9.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, PlayerRecordResponse, "PlayerRecordResponse");
  }
  /**
   * Get a size of the player record
   */
  getSize_ByUserId_ByKey(userId, key) {
    const params = {};
    const url = "/cloudsave/v1/admin/namespaces/{namespace}/users/{userId}/records/{key}/size".replace("{namespace}", this.namespace).replace("{userId}", userId).replace("{key}", key);
    const resultPromise = this.axiosInstance.get(url, { params });
    return import_sdk9.Validate.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      PlayerRecordSizeResponse,
      "PlayerRecordSizeResponse"
    );
  }
  /**
   * Delete player public record. ## Warning: This endpoint is going to deprecate This endpoint is going to deprecate in the future please don&#39;t use it. For alternative, please use these endpoints: - **POST /cloudsave/v1/admin/namespaces/{namespace}/users/{userId}/records/{key}** and utilizing **__META** functionality - **PUT /cloudsave/v1/admin/namespaces/{namespace}/users/{userId}/records/{key}** and utilizing **__META** functionality - **DELETE /cloudsave/v1/admin/namespaces/{namespace}/users/{userId}/records/{key}**
   */
  deletePublic_ByUserId_ByKey(userId, key) {
    const params = {};
    const url = "/cloudsave/v1/admin/namespaces/{namespace}/users/{userId}/records/{key}/public".replace("{namespace}", this.namespace).replace("{userId}", userId).replace("{key}", key);
    const resultPromise = this.axiosInstance.delete(url, { params });
    return import_sdk9.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, import_zod28.z.unknown(), "z.unknown()");
  }
  /**
   * Get a record in user-level (arbitrary JSON data) by its key.
   */
  getPublic_ByUserId_ByKey(userId, key) {
    const params = {};
    const url = "/cloudsave/v1/admin/namespaces/{namespace}/users/{userId}/records/{key}/public".replace("{namespace}", this.namespace).replace("{userId}", userId).replace("{key}", key);
    const resultPromise = this.axiosInstance.get(url, { params });
    return import_sdk9.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, PlayerRecordResponse, "PlayerRecordResponse");
  }
  /**
   * ## Description This endpoints will create new player public record or append the existing player public record. **Append example:** Example 1 - Existing JSON: `{ &#34;data1&#34;: &#34;value&#34; }` - New JSON: `{ &#34;data2&#34;: &#34;new value&#34; }` - Result: `{ &#34;data1&#34;: &#34;value&#34;, &#34;data2&#34;: &#34;new value&#34; }` Example 2 - Existing JSON: `{ &#34;data1&#34;: { &#34;data2&#34;: &#34;value&#34; }` - New JSON: `{ &#34;data1&#34;: { &#34;data3&#34;: &#34;new value&#34; }` - Result: `{ &#34;data1&#34;: { &#34;data2&#34;: &#34;value&#34;, &#34;data3&#34;: &#34;new value&#34; }` ## Restriction This is the restriction of Key Naming for the record: 1. Cannot use **&#34;.&#34;** as the key name - `{ &#34;data.2&#34;: &#34;value&#34; }` 2. Cannot use **&#34;$&#34;** as the prefix in key names - `{ &#34;$data&#34;: &#34;value&#34; }` 3. Cannot use empty string in key names - `{ &#34;&#34;: &#34;value&#34; }` ## Warning: This endpoint is going to deprecate This endpoint is going to deprecate in the future please don&#39;t use it. For alternative, please use these endpoints: - **POST /cloudsave/v1/admin/namespaces/{namespace}/users/{userId}/records/{key}** and utilizing **__META** functionality - **PUT /cloudsave/v1/admin/namespaces/{namespace}/users/{userId}/records/{key}** and utilizing **__META** functionality - **DELETE /cloudsave/v1/admin/namespaces/{namespace}/users/{userId}/records/{key}**
   */
  createPublic_ByUserId_ByKey(userId, key, data) {
    const params = {};
    const url = "/cloudsave/v1/admin/namespaces/{namespace}/users/{userId}/records/{key}/public".replace("{namespace}", this.namespace).replace("{userId}", userId).replace("{key}", key);
    const resultPromise = this.axiosInstance.post(url, data, { params });
    return import_sdk9.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, PlayerRecordResponse, "PlayerRecordResponse");
  }
  /**
   * ## Description This endpoints will create new player public record or replace the existing player public record. **Replace behaviour:** The existing value will be replaced completely with the new value. Example - Existing JSON: `{ &#34;data1&#34;: &#34;value&#34; }` - New JSON: `{ &#34;data2&#34;: &#34;new value&#34; }` - Result: `{ &#34;data2&#34;: &#34;new value&#34; }` ## Restriction This is the restriction of Key Naming for the record: 1. Cannot use **&#34;.&#34;** as the key name - `{ &#34;data.2&#34;: &#34;value&#34; }` 2. Cannot use **&#34;$&#34;** as the prefix in key names - `{ &#34;$data&#34;: &#34;value&#34; }` 3. Cannot use empty string in key names - `{ &#34;&#34;: &#34;value&#34; }` ## Warning: This endpoint is going to deprecate This endpoint is going to deprecate in the future please don&#39;t use it. For alternative, please use these endpoints: - **POST /cloudsave/v1/admin/namespaces/{namespace}/users/{userId}/records/{key}** and utilizing **__META** functionality - **PUT /cloudsave/v1/admin/namespaces/{namespace}/users/{userId}/records/{key}** and utilizing **__META** functionality - **DELETE /cloudsave/v1/admin/namespaces/{namespace}/users/{userId}/records/{key}**
   */
  updatePublic_ByUserId_ByKey(userId, key, data) {
    const params = {};
    const url = "/cloudsave/v1/admin/namespaces/{namespace}/users/{userId}/records/{key}/public".replace("{namespace}", this.namespace).replace("{userId}", userId).replace("{key}", key);
    const resultPromise = this.axiosInstance.put(url, data, { params });
    return import_sdk9.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, PlayerRecordResponse, "PlayerRecordResponse");
  }
};

// src/generated-admin/PlayerRecordAdminApi.ts
function PlayerRecordAdminApi(sdk, args) {
  const sdkAssembly = sdk.assembly();
  const namespace = args?.coreConfig?.namespace ?? sdkAssembly.coreConfig.namespace;
  const useSchemaValidation = args?.coreConfig?.useSchemaValidation ?? sdkAssembly.coreConfig.useSchemaValidation;
  let axiosInstance = sdkAssembly.axiosInstance;
  const requestConfigOverrides = args?.axiosConfig?.request;
  const baseURLOverride = args?.coreConfig?.baseURL;
  const interceptorsOverride = args?.axiosConfig?.interceptors ?? [];
  if (requestConfigOverrides || baseURLOverride || interceptorsOverride.length > 0) {
    const requestConfig = import_sdk10.ApiUtils.mergeAxiosConfigs(sdkAssembly.axiosInstance.defaults, {
      ...baseURLOverride ? { baseURL: baseURLOverride } : {},
      ...requestConfigOverrides
    });
    axiosInstance = import_sdk10.Network.create(requestConfig);
    for (const interceptor of interceptorsOverride) {
      if (interceptor.type === "request") {
        axiosInstance.interceptors.request.use(interceptor.onRequest, interceptor.onError);
      }
      if (interceptor.type === "response") {
        axiosInstance.interceptors.response.use(interceptor.onSuccess, interceptor.onError);
      }
    }
  }
  async function getUsersRecords(queryParams) {
    const $ = new PlayerRecordAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getUsersRecords(queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getRecords_ByUserId(userId, queryParams) {
    const $ = new PlayerRecordAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getRecords_ByUserId(userId, queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function fetchUserBulkRecordSize(data) {
    const $ = new PlayerRecordAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.fetchUserBulkRecordSize(data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function fetchBulkUser_ByKey(key, data) {
    const $ = new PlayerRecordAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.fetchBulkUser_ByKey(key, data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function updateBulkUser_ByKey(key, data) {
    const $ = new PlayerRecordAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.updateBulkUser_ByKey(key, data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function fetchRecordBulk_ByUserId(userId, data) {
    const $ = new PlayerRecordAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.fetchRecordBulk_ByUserId(userId, data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function updateRecordBulk_ByUserId(userId, data) {
    const $ = new PlayerRecordAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.updateRecordBulk_ByUserId(userId, data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function deleteRecord_ByUserId_ByKey(userId, key) {
    const $ = new PlayerRecordAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.deleteRecord_ByUserId_ByKey(userId, key);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getRecord_ByUserId_ByKey(userId, key) {
    const $ = new PlayerRecordAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getRecord_ByUserId_ByKey(userId, key);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function createRecord_ByUserId_ByKey(userId, key, data) {
    const $ = new PlayerRecordAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.createRecord_ByUserId_ByKey(userId, key, data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function updateRecord_ByUserId_ByKey(userId, key, data) {
    const $ = new PlayerRecordAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.updateRecord_ByUserId_ByKey(userId, key, data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getSize_ByUserId_ByKey(userId, key) {
    const $ = new PlayerRecordAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getSize_ByUserId_ByKey(userId, key);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function deletePublic_ByUserId_ByKey(userId, key) {
    const $ = new PlayerRecordAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.deletePublic_ByUserId_ByKey(userId, key);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getPublic_ByUserId_ByKey(userId, key) {
    const $ = new PlayerRecordAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getPublic_ByUserId_ByKey(userId, key);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function createPublic_ByUserId_ByKey(userId, key, data) {
    const $ = new PlayerRecordAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.createPublic_ByUserId_ByKey(userId, key, data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function updatePublic_ByUserId_ByKey(userId, key, data) {
    const $ = new PlayerRecordAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.updatePublic_ByUserId_ByKey(userId, key, data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  return {
    /**
     * @deprecated
     * Retrieve list of player records key and userID under given namespace.
     */
    getUsersRecords,
    /**
     * Retrieve list of player records key and userID under given namespace.
     */
    getRecords_ByUserId,
    /**
     * Bulk get player&#39;s record size, max allowed 20 at a time, that can be retrieved using this endpoint.
     */
    fetchUserBulkRecordSize,
    /**
     * Retrieve player record key and payload in bulk under given namespace. Maximum number of user ids per request is 20.
     */
    fetchBulkUser_ByKey,
    /**
     * This endpoints will create new player record or replace the existing player record in bulk. Maximum number of user ids per request is 10. Maximum total size of the request payload is 5 MB.
     */
    updateBulkUser_ByKey,
    /**
     * Retrieve player record key and payload in bulk under given namespace. Maximum bulk key limit per request 20.
     */
    fetchRecordBulk_ByUserId,
    /**
     * This endpoints will create new player record or replace the existing player record in bulk. Maximum bulk key limit per request 10.
     */
    updateRecordBulk_ByUserId,
    /**
     * Delete a record (arbitrary JSON data) in user-level with given key.
     */
    deleteRecord_ByUserId_ByKey,
    /**
     * Get a record in user-level (arbitrary JSON data) by its key.
     */
    getRecord_ByUserId_ByKey,
    /**
     * ## Description This endpoints will create new player record or append the existing player record. **Append example:** Example 1 - Existing JSON: `{ &#34;data1&#34;: &#34;value&#34; }` - New JSON: `{ &#34;data2&#34;: &#34;new value&#34; }` - Result: `{ &#34;data1&#34;: &#34;value&#34;, &#34;data2&#34;: &#34;new value&#34; }` Example 2 - Existing JSON: `{ &#34;data1&#34;: { &#34;data2&#34;: &#34;value&#34; }` - New JSON: `{ &#34;data1&#34;: { &#34;data3&#34;: &#34;new value&#34; }` - Result: `{ &#34;data1&#34;: { &#34;data2&#34;: &#34;value&#34;, &#34;data3&#34;: &#34;new value&#34; }` ## Restriction This is the restriction of Key Naming for the record: 1. Cannot use **&#34;.&#34;** as the key name - `{ &#34;data.2&#34;: &#34;value&#34; }` 2. Cannot use **&#34;$&#34;** as the prefix in key names - `{ &#34;$data&#34;: &#34;value&#34; }` 3. Cannot use empty string in key names - `{ &#34;&#34;: &#34;value&#34; }` ## Record Metadata Metadata allows user to define the behaviour of the record. Metadata can be defined in request body with field name **__META**. When creating record, if **__META** field is not defined, the metadata value will use the default value. When updating record, if **__META** field is not defined, the existing metadata value will stay as is. **Metadata List:** 1. set_by (default: CLIENT, type: string) Indicate which party that could modify the game record. SERVER: record can be modified by server only. CLIENT: record can be modified by client and server. 2. is_public (default: false, type: bool) Indicate whether the player record is a public record or not. 3. tags (default: *empty array*, type: array of string) Indicate the tagging for the game record. **Request Body Example:** ``` { &#34;__META&#34;: { &#34;set_by&#34;: &#34;SERVER&#34;, &#34;is_public&#34;: true, &#34;tags&#34;: [&#34;tag1&#34;, &#34;tag2&#34;] } ... } ```
     */
    createRecord_ByUserId_ByKey,
    /**
     * ## Description This endpoints will create new player record or replace the existing player record. **Replace behaviour:** The existing value will be replaced completely with the new value. Example - Existing JSON: `{ &#34;data1&#34;: &#34;value&#34; }` - New JSON: `{ &#34;data2&#34;: &#34;new value&#34; }` - Result: `{ &#34;data2&#34;: &#34;new value&#34; }` ## Restriction This is the restriction of Key Naming for the record: 1. Cannot use **&#34;.&#34;** as the key name - `{ &#34;data.2&#34;: &#34;value&#34; }` 2. Cannot use **&#34;$&#34;** as the prefix in key names - `{ &#34;$data&#34;: &#34;value&#34; }` 3. Cannot use empty string in key names - `{ &#34;&#34;: &#34;value&#34; }` ## Record Metadata Metadata allows user to define the behaviour of the record. Metadata can be defined in request body with field name **__META**. When creating record, if **__META** field is not defined, the metadata value will use the default value. When updating record, if **__META** field is not defined, the existing metadata value will stay as is. **Metadata List:** 1. set_by (default: CLIENT, type: string) Indicate which party that could modify the game record. SERVER: record can be modified by server only. CLIENT: record can be modified by client and server. 2. is_public (default: false, type: bool) Indicate whether the player record is a public record or not. 3. tags (default: *empty array*, type: array of string) Indicate the tagging for the game record. **Request Body Example:** ``` { &#34;__META&#34;: { &#34;set_by&#34;: &#34;SERVER&#34;, &#34;is_public&#34;: true, &#34;tags&#34;: [&#34;tag1&#34;, &#34;tag2&#34;] } ... } ```
     */
    updateRecord_ByUserId_ByKey,
    /**
     * Get a size of the player record
     */
    getSize_ByUserId_ByKey,
    /**
     * Delete player public record. ## Warning: This endpoint is going to deprecate This endpoint is going to deprecate in the future please don&#39;t use it. For alternative, please use these endpoints: - **POST /cloudsave/v1/admin/namespaces/{namespace}/users/{userId}/records/{key}** and utilizing **__META** functionality - **PUT /cloudsave/v1/admin/namespaces/{namespace}/users/{userId}/records/{key}** and utilizing **__META** functionality - **DELETE /cloudsave/v1/admin/namespaces/{namespace}/users/{userId}/records/{key}**
     */
    deletePublic_ByUserId_ByKey,
    /**
     * Get a record in user-level (arbitrary JSON data) by its key.
     */
    getPublic_ByUserId_ByKey,
    /**
     * ## Description This endpoints will create new player public record or append the existing player public record. **Append example:** Example 1 - Existing JSON: `{ &#34;data1&#34;: &#34;value&#34; }` - New JSON: `{ &#34;data2&#34;: &#34;new value&#34; }` - Result: `{ &#34;data1&#34;: &#34;value&#34;, &#34;data2&#34;: &#34;new value&#34; }` Example 2 - Existing JSON: `{ &#34;data1&#34;: { &#34;data2&#34;: &#34;value&#34; }` - New JSON: `{ &#34;data1&#34;: { &#34;data3&#34;: &#34;new value&#34; }` - Result: `{ &#34;data1&#34;: { &#34;data2&#34;: &#34;value&#34;, &#34;data3&#34;: &#34;new value&#34; }` ## Restriction This is the restriction of Key Naming for the record: 1. Cannot use **&#34;.&#34;** as the key name - `{ &#34;data.2&#34;: &#34;value&#34; }` 2. Cannot use **&#34;$&#34;** as the prefix in key names - `{ &#34;$data&#34;: &#34;value&#34; }` 3. Cannot use empty string in key names - `{ &#34;&#34;: &#34;value&#34; }` ## Warning: This endpoint is going to deprecate This endpoint is going to deprecate in the future please don&#39;t use it. For alternative, please use these endpoints: - **POST /cloudsave/v1/admin/namespaces/{namespace}/users/{userId}/records/{key}** and utilizing **__META** functionality - **PUT /cloudsave/v1/admin/namespaces/{namespace}/users/{userId}/records/{key}** and utilizing **__META** functionality - **DELETE /cloudsave/v1/admin/namespaces/{namespace}/users/{userId}/records/{key}**
     */
    createPublic_ByUserId_ByKey,
    /**
     * ## Description This endpoints will create new player public record or replace the existing player public record. **Replace behaviour:** The existing value will be replaced completely with the new value. Example - Existing JSON: `{ &#34;data1&#34;: &#34;value&#34; }` - New JSON: `{ &#34;data2&#34;: &#34;new value&#34; }` - Result: `{ &#34;data2&#34;: &#34;new value&#34; }` ## Restriction This is the restriction of Key Naming for the record: 1. Cannot use **&#34;.&#34;** as the key name - `{ &#34;data.2&#34;: &#34;value&#34; }` 2. Cannot use **&#34;$&#34;** as the prefix in key names - `{ &#34;$data&#34;: &#34;value&#34; }` 3. Cannot use empty string in key names - `{ &#34;&#34;: &#34;value&#34; }` ## Warning: This endpoint is going to deprecate This endpoint is going to deprecate in the future please don&#39;t use it. For alternative, please use these endpoints: - **POST /cloudsave/v1/admin/namespaces/{namespace}/users/{userId}/records/{key}** and utilizing **__META** functionality - **PUT /cloudsave/v1/admin/namespaces/{namespace}/users/{userId}/records/{key}** and utilizing **__META** functionality - **DELETE /cloudsave/v1/admin/namespaces/{namespace}/users/{userId}/records/{key}**
     */
    updatePublic_ByUserId_ByKey
  };
}

// src/generated-admin/queries/PlayerRecordAdmin.query.ts
var Key_PlayerRecordAdmin = /* @__PURE__ */ ((Key_PlayerRecordAdmin2) => {
  Key_PlayerRecordAdmin2["UsersRecords"] = "Cloudsave.PlayerRecordAdmin.UsersRecords";
  Key_PlayerRecordAdmin2["Records_ByUserId"] = "Cloudsave.PlayerRecordAdmin.Records_ByUserId";
  Key_PlayerRecordAdmin2["UserBulkRecordSize"] = "Cloudsave.PlayerRecordAdmin.UserBulkRecordSize";
  Key_PlayerRecordAdmin2["BulkUser_ByKey"] = "Cloudsave.PlayerRecordAdmin.BulkUser_ByKey";
  Key_PlayerRecordAdmin2["RecordBulk_ByUserId"] = "Cloudsave.PlayerRecordAdmin.RecordBulk_ByUserId";
  Key_PlayerRecordAdmin2["Record_ByUserId_ByKey"] = "Cloudsave.PlayerRecordAdmin.Record_ByUserId_ByKey";
  Key_PlayerRecordAdmin2["Size_ByUserId_ByKey"] = "Cloudsave.PlayerRecordAdmin.Size_ByUserId_ByKey";
  Key_PlayerRecordAdmin2["Public_ByUserId_ByKey"] = "Cloudsave.PlayerRecordAdmin.Public_ByUserId_ByKey";
  return Key_PlayerRecordAdmin2;
})(Key_PlayerRecordAdmin || {});
var usePlayerRecordAdminApi_GetUsersRecords = (sdk, input, options, callback) => {
  const queryFn = (sdk2, input2) => async () => {
    const response = await PlayerRecordAdminApi(sdk2, { coreConfig: input2.coreConfig, axiosConfig: input2.axiosConfig }).getUsersRecords(
      input2.queryParams
    );
    callback && callback(response);
    return response.data;
  };
  return (0, import_react_query5.useQuery)({
    queryKey: ["Cloudsave.PlayerRecordAdmin.UsersRecords" /* UsersRecords */, input],
    queryFn: queryFn(sdk, input),
    ...options
  });
};
var usePlayerRecordAdminApi_GetRecords_ByUserId = (sdk, input, options, callback) => {
  const queryFn = (sdk2, input2) => async () => {
    const response = await PlayerRecordAdminApi(sdk2, { coreConfig: input2.coreConfig, axiosConfig: input2.axiosConfig }).getRecords_ByUserId(
      input2.userId,
      input2.queryParams
    );
    callback && callback(response);
    return response.data;
  };
  return (0, import_react_query5.useQuery)({
    queryKey: ["Cloudsave.PlayerRecordAdmin.Records_ByUserId" /* Records_ByUserId */, input],
    queryFn: queryFn(sdk, input),
    ...options
  });
};
var usePlayerRecordAdminApi_FetchUserBulkRecordSize = (sdk, input, options, callback) => {
  const queryFn = (sdk2, input2) => async () => {
    const response = await PlayerRecordAdminApi(sdk2, {
      coreConfig: input2.coreConfig,
      axiosConfig: input2.axiosConfig
    }).fetchUserBulkRecordSize(input2.data);
    callback && callback(response);
    return response.data;
  };
  return (0, import_react_query5.useQuery)({
    queryKey: ["Cloudsave.PlayerRecordAdmin.UserBulkRecordSize" /* UserBulkRecordSize */, input],
    queryFn: queryFn(sdk, input),
    ...options
  });
};
var usePlayerRecordAdminApi_FetchBulkUser_ByKey = (sdk, input, options, callback) => {
  const queryFn = (sdk2, input2) => async () => {
    const response = await PlayerRecordAdminApi(sdk2, { coreConfig: input2.coreConfig, axiosConfig: input2.axiosConfig }).fetchBulkUser_ByKey(
      input2.key,
      input2.data
    );
    callback && callback(response);
    return response.data;
  };
  return (0, import_react_query5.useQuery)({
    queryKey: ["Cloudsave.PlayerRecordAdmin.BulkUser_ByKey" /* BulkUser_ByKey */, input],
    queryFn: queryFn(sdk, input),
    ...options
  });
};
var usePlayerRecordAdminApi_UpdateBulkUser_ByKeyMutation = (sdk, options, callback) => {
  const mutationFn = async (input) => {
    const response = await PlayerRecordAdminApi(sdk, { coreConfig: input.coreConfig, axiosConfig: input.axiosConfig }).updateBulkUser_ByKey(
      input.key,
      input.data
    );
    callback && callback(response.data);
    return response.data;
  };
  return (0, import_react_query5.useMutation)({
    mutationKey: ["Cloudsave.PlayerRecordAdmin.BulkUser_ByKey" /* BulkUser_ByKey */],
    mutationFn,
    ...options
  });
};
var usePlayerRecordAdminApi_FetchRecordBulk_ByUserId = (sdk, input, options, callback) => {
  const queryFn = (sdk2, input2) => async () => {
    const response = await PlayerRecordAdminApi(sdk2, {
      coreConfig: input2.coreConfig,
      axiosConfig: input2.axiosConfig
    }).fetchRecordBulk_ByUserId(input2.userId, input2.data);
    callback && callback(response);
    return response.data;
  };
  return (0, import_react_query5.useQuery)({
    queryKey: ["Cloudsave.PlayerRecordAdmin.RecordBulk_ByUserId" /* RecordBulk_ByUserId */, input],
    queryFn: queryFn(sdk, input),
    ...options
  });
};
var usePlayerRecordAdminApi_UpdateRecordBulk_ByUserIdMutation = (sdk, options, callback) => {
  const mutationFn = async (input) => {
    const response = await PlayerRecordAdminApi(sdk, {
      coreConfig: input.coreConfig,
      axiosConfig: input.axiosConfig
    }).updateRecordBulk_ByUserId(input.userId, input.data);
    callback && callback(response.data);
    return response.data;
  };
  return (0, import_react_query5.useMutation)({
    mutationKey: ["Cloudsave.PlayerRecordAdmin.RecordBulk_ByUserId" /* RecordBulk_ByUserId */],
    mutationFn,
    ...options
  });
};
var usePlayerRecordAdminApi_DeleteRecord_ByUserId_ByKeyMutation = (sdk, options, callback) => {
  const mutationFn = async (input) => {
    const response = await PlayerRecordAdminApi(sdk, {
      coreConfig: input.coreConfig,
      axiosConfig: input.axiosConfig
    }).deleteRecord_ByUserId_ByKey(input.userId, input.key);
    callback && callback(response.data);
    return response.data;
  };
  return (0, import_react_query5.useMutation)({
    mutationKey: ["Cloudsave.PlayerRecordAdmin.Record_ByUserId_ByKey" /* Record_ByUserId_ByKey */],
    mutationFn,
    ...options
  });
};
var usePlayerRecordAdminApi_GetRecord_ByUserId_ByKey = (sdk, input, options, callback) => {
  const queryFn = (sdk2, input2) => async () => {
    const response = await PlayerRecordAdminApi(sdk2, {
      coreConfig: input2.coreConfig,
      axiosConfig: input2.axiosConfig
    }).getRecord_ByUserId_ByKey(input2.userId, input2.key);
    callback && callback(response);
    return response.data;
  };
  return (0, import_react_query5.useQuery)({
    queryKey: ["Cloudsave.PlayerRecordAdmin.Record_ByUserId_ByKey" /* Record_ByUserId_ByKey */, input],
    queryFn: queryFn(sdk, input),
    ...options
  });
};
var usePlayerRecordAdminApi_CreateRecord_ByUserId_ByKeyMutation = (sdk, options, callback) => {
  const mutationFn = async (input) => {
    const response = await PlayerRecordAdminApi(sdk, {
      coreConfig: input.coreConfig,
      axiosConfig: input.axiosConfig
    }).createRecord_ByUserId_ByKey(input.userId, input.key, input.data);
    callback && callback(response.data);
    return response.data;
  };
  return (0, import_react_query5.useMutation)({
    mutationKey: ["Cloudsave.PlayerRecordAdmin.Record_ByUserId_ByKey" /* Record_ByUserId_ByKey */],
    mutationFn,
    ...options
  });
};
var usePlayerRecordAdminApi_UpdateRecord_ByUserId_ByKeyMutation = (sdk, options, callback) => {
  const mutationFn = async (input) => {
    const response = await PlayerRecordAdminApi(sdk, {
      coreConfig: input.coreConfig,
      axiosConfig: input.axiosConfig
    }).updateRecord_ByUserId_ByKey(input.userId, input.key, input.data);
    callback && callback(response.data);
    return response.data;
  };
  return (0, import_react_query5.useMutation)({
    mutationKey: ["Cloudsave.PlayerRecordAdmin.Record_ByUserId_ByKey" /* Record_ByUserId_ByKey */],
    mutationFn,
    ...options
  });
};
var usePlayerRecordAdminApi_GetSize_ByUserId_ByKey = (sdk, input, options, callback) => {
  const queryFn = (sdk2, input2) => async () => {
    const response = await PlayerRecordAdminApi(sdk2, {
      coreConfig: input2.coreConfig,
      axiosConfig: input2.axiosConfig
    }).getSize_ByUserId_ByKey(input2.userId, input2.key);
    callback && callback(response);
    return response.data;
  };
  return (0, import_react_query5.useQuery)({
    queryKey: ["Cloudsave.PlayerRecordAdmin.Size_ByUserId_ByKey" /* Size_ByUserId_ByKey */, input],
    queryFn: queryFn(sdk, input),
    ...options
  });
};
var usePlayerRecordAdminApi_DeletePublic_ByUserId_ByKeyMutation = (sdk, options, callback) => {
  const mutationFn = async (input) => {
    const response = await PlayerRecordAdminApi(sdk, {
      coreConfig: input.coreConfig,
      axiosConfig: input.axiosConfig
    }).deletePublic_ByUserId_ByKey(input.userId, input.key);
    callback && callback(response.data);
    return response.data;
  };
  return (0, import_react_query5.useMutation)({
    mutationKey: ["Cloudsave.PlayerRecordAdmin.Public_ByUserId_ByKey" /* Public_ByUserId_ByKey */],
    mutationFn,
    ...options
  });
};
var usePlayerRecordAdminApi_GetPublic_ByUserId_ByKey = (sdk, input, options, callback) => {
  const queryFn = (sdk2, input2) => async () => {
    const response = await PlayerRecordAdminApi(sdk2, {
      coreConfig: input2.coreConfig,
      axiosConfig: input2.axiosConfig
    }).getPublic_ByUserId_ByKey(input2.userId, input2.key);
    callback && callback(response);
    return response.data;
  };
  return (0, import_react_query5.useQuery)({
    queryKey: ["Cloudsave.PlayerRecordAdmin.Public_ByUserId_ByKey" /* Public_ByUserId_ByKey */, input],
    queryFn: queryFn(sdk, input),
    ...options
  });
};
var usePlayerRecordAdminApi_CreatePublic_ByUserId_ByKeyMutation = (sdk, options, callback) => {
  const mutationFn = async (input) => {
    const response = await PlayerRecordAdminApi(sdk, {
      coreConfig: input.coreConfig,
      axiosConfig: input.axiosConfig
    }).createPublic_ByUserId_ByKey(input.userId, input.key, input.data);
    callback && callback(response.data);
    return response.data;
  };
  return (0, import_react_query5.useMutation)({
    mutationKey: ["Cloudsave.PlayerRecordAdmin.Public_ByUserId_ByKey" /* Public_ByUserId_ByKey */],
    mutationFn,
    ...options
  });
};
var usePlayerRecordAdminApi_UpdatePublic_ByUserId_ByKeyMutation = (sdk, options, callback) => {
  const mutationFn = async (input) => {
    const response = await PlayerRecordAdminApi(sdk, {
      coreConfig: input.coreConfig,
      axiosConfig: input.axiosConfig
    }).updatePublic_ByUserId_ByKey(input.userId, input.key, input.data);
    callback && callback(response.data);
    return response.data;
  };
  return (0, import_react_query5.useMutation)({
    mutationKey: ["Cloudsave.PlayerRecordAdmin.Public_ByUserId_ByKey" /* Public_ByUserId_ByKey */],
    mutationFn,
    ...options
  });
};

// src/generated-admin/queries/PluginConfigAdmin.query.ts
var import_react_query6 = require("@tanstack/react-query");

// src/generated-admin/PluginConfigAdminApi.ts
var import_sdk12 = require("@accelbyte/sdk");

// src/generated-admin/endpoints/PluginConfigAdmin$.ts
var import_sdk11 = require("@accelbyte/sdk");
var import_zod33 = require("zod");

// src/generated-definitions/PluginResponse.ts
var import_zod32 = require("zod");

// src/generated-definitions/AppConfig.ts
var import_zod29 = require("zod");
var AppConfig = import_zod29.z.object({ appName: import_zod29.z.string() });

// src/generated-definitions/CustomConfig.ts
var import_zod30 = require("zod");
var CustomConfig = import_zod30.z.object({ GRPCAddress: import_zod30.z.string() });

// src/generated-definitions/CustomFunction.ts
var import_zod31 = require("zod");
var CustomFunction = import_zod31.z.object({
  afterBulkReadGameBinaryRecord: import_zod31.z.boolean(),
  afterBulkReadGameRecord: import_zod31.z.boolean(),
  afterBulkReadPlayerBinaryRecord: import_zod31.z.boolean(),
  afterBulkReadPlayerRecord: import_zod31.z.boolean(),
  afterReadGameBinaryRecord: import_zod31.z.boolean(),
  afterReadGameRecord: import_zod31.z.boolean(),
  afterReadPlayerBinaryRecord: import_zod31.z.boolean(),
  afterReadPlayerRecord: import_zod31.z.boolean(),
  beforeWriteAdminGameRecord: import_zod31.z.boolean(),
  beforeWriteAdminPlayerRecord: import_zod31.z.boolean(),
  beforeWriteGameBinaryRecord: import_zod31.z.boolean(),
  beforeWriteGameRecord: import_zod31.z.boolean(),
  beforeWritePlayerBinaryRecord: import_zod31.z.boolean(),
  beforeWritePlayerRecord: import_zod31.z.boolean()
});

// src/generated-definitions/PluginResponse.ts
var PluginResponse = import_zod32.z.object({
  appConfig: AppConfig.nullish(),
  customConfig: CustomConfig.nullish(),
  customFunction: CustomFunction,
  extendType: import_zod32.z.enum(["APP", "CUSTOM"]),
  namespace: import_zod32.z.string()
});

// src/generated-admin/endpoints/PluginConfigAdmin$.ts
var PluginConfigAdmin$ = class {
  // @ts-ignore
  // prettier-ignore
  constructor(axiosInstance, namespace, useSchemaValidation = true) {
    this.axiosInstance = axiosInstance;
    this.namespace = namespace;
    this.useSchemaValidation = useSchemaValidation;
  }
  /**
   * ## Description This endpoints will delete grpc plugins configuration
   */
  deletePlugin() {
    const params = {};
    const url = "/cloudsave/v1/admin/namespaces/{namespace}/plugins".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.delete(url, { params });
    return import_sdk11.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, import_zod33.z.unknown(), "z.unknown()");
  }
  /**
   * ## Description This endpoints will get grpc plugins configuration
   */
  getPlugins() {
    const params = {};
    const url = "/cloudsave/v1/admin/namespaces/{namespace}/plugins".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.get(url, { params });
    return import_sdk11.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, PluginResponse, "PluginResponse");
  }
  /**
   * ## Description This endpoints will update grpc plugins configuration
   */
  patchPlugin(data) {
    const params = {};
    const url = "/cloudsave/v1/admin/namespaces/{namespace}/plugins".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.patch(url, data, { params });
    return import_sdk11.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, PluginResponse, "PluginResponse");
  }
  /**
   * ## Description This endpoints will create new grpc plugins configuration per namespace
   */
  createPlugin(data) {
    const params = {};
    const url = "/cloudsave/v1/admin/namespaces/{namespace}/plugins".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.post(url, data, { params });
    return import_sdk11.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, PluginResponse, "PluginResponse");
  }
};

// src/generated-admin/PluginConfigAdminApi.ts
function PluginConfigAdminApi(sdk, args) {
  const sdkAssembly = sdk.assembly();
  const namespace = args?.coreConfig?.namespace ?? sdkAssembly.coreConfig.namespace;
  const useSchemaValidation = args?.coreConfig?.useSchemaValidation ?? sdkAssembly.coreConfig.useSchemaValidation;
  let axiosInstance = sdkAssembly.axiosInstance;
  const requestConfigOverrides = args?.axiosConfig?.request;
  const baseURLOverride = args?.coreConfig?.baseURL;
  const interceptorsOverride = args?.axiosConfig?.interceptors ?? [];
  if (requestConfigOverrides || baseURLOverride || interceptorsOverride.length > 0) {
    const requestConfig = import_sdk12.ApiUtils.mergeAxiosConfigs(sdkAssembly.axiosInstance.defaults, {
      ...baseURLOverride ? { baseURL: baseURLOverride } : {},
      ...requestConfigOverrides
    });
    axiosInstance = import_sdk12.Network.create(requestConfig);
    for (const interceptor of interceptorsOverride) {
      if (interceptor.type === "request") {
        axiosInstance.interceptors.request.use(interceptor.onRequest, interceptor.onError);
      }
      if (interceptor.type === "response") {
        axiosInstance.interceptors.response.use(interceptor.onSuccess, interceptor.onError);
      }
    }
  }
  async function deletePlugin() {
    const $ = new PluginConfigAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.deletePlugin();
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getPlugins() {
    const $ = new PluginConfigAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getPlugins();
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function patchPlugin(data) {
    const $ = new PluginConfigAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.patchPlugin(data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function createPlugin(data) {
    const $ = new PluginConfigAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.createPlugin(data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  return {
    /**
     * ## Description This endpoints will delete grpc plugins configuration
     */
    deletePlugin,
    /**
     * ## Description This endpoints will get grpc plugins configuration
     */
    getPlugins,
    /**
     * ## Description This endpoints will update grpc plugins configuration
     */
    patchPlugin,
    /**
     * ## Description This endpoints will create new grpc plugins configuration per namespace
     */
    createPlugin
  };
}

// src/generated-admin/queries/PluginConfigAdmin.query.ts
var Key_PluginConfigAdmin = /* @__PURE__ */ ((Key_PluginConfigAdmin2) => {
  Key_PluginConfigAdmin2["Plugin"] = "Cloudsave.PluginConfigAdmin.Plugin";
  Key_PluginConfigAdmin2["Plugins"] = "Cloudsave.PluginConfigAdmin.Plugins";
  return Key_PluginConfigAdmin2;
})(Key_PluginConfigAdmin || {});
var usePluginConfigAdminApi_DeletePluginMutation = (sdk, options, callback) => {
  const mutationFn = async (input) => {
    const response = await PluginConfigAdminApi(sdk, { coreConfig: input.coreConfig, axiosConfig: input.axiosConfig }).deletePlugin();
    callback && callback(response.data);
    return response.data;
  };
  return (0, import_react_query6.useMutation)({
    mutationKey: ["Cloudsave.PluginConfigAdmin.Plugin" /* Plugin */],
    mutationFn,
    ...options
  });
};
var usePluginConfigAdminApi_GetPlugins = (sdk, input, options, callback) => {
  const queryFn = (sdk2, input2) => async () => {
    const response = await PluginConfigAdminApi(sdk2, { coreConfig: input2.coreConfig, axiosConfig: input2.axiosConfig }).getPlugins();
    callback && callback(response);
    return response.data;
  };
  return (0, import_react_query6.useQuery)({
    queryKey: ["Cloudsave.PluginConfigAdmin.Plugins" /* Plugins */, input],
    queryFn: queryFn(sdk, input),
    ...options
  });
};
var usePluginConfigAdminApi_PatchPluginMutation = (sdk, options, callback) => {
  const mutationFn = async (input) => {
    const response = await PluginConfigAdminApi(sdk, { coreConfig: input.coreConfig, axiosConfig: input.axiosConfig }).patchPlugin(
      input.data
    );
    callback && callback(response.data);
    return response.data;
  };
  return (0, import_react_query6.useMutation)({
    mutationKey: ["Cloudsave.PluginConfigAdmin.Plugin" /* Plugin */],
    mutationFn,
    ...options
  });
};
var usePluginConfigAdminApi_CreatePluginMutation = (sdk, options, callback) => {
  const mutationFn = async (input) => {
    const response = await PluginConfigAdminApi(sdk, { coreConfig: input.coreConfig, axiosConfig: input.axiosConfig }).createPlugin(
      input.data
    );
    callback && callback(response.data);
    return response.data;
  };
  return (0, import_react_query6.useMutation)({
    mutationKey: ["Cloudsave.PluginConfigAdmin.Plugin" /* Plugin */],
    mutationFn,
    ...options
  });
};

// src/generated-admin/queries/RecordAdmin.query.ts
var import_react_query7 = require("@tanstack/react-query");

// src/generated-admin/RecordAdminApi.ts
var import_sdk14 = require("@accelbyte/sdk");

// src/generated-admin/endpoints/RecordAdmin$.ts
var import_sdk13 = require("@accelbyte/sdk");
var import_zod39 = require("zod");

// src/generated-definitions/AdminGameRecordResponse.ts
var import_zod34 = require("zod");
var AdminGameRecordResponse = import_zod34.z.object({
  created_at: import_zod34.z.string(),
  key: import_zod34.z.string(),
  namespace: import_zod34.z.string(),
  tags: import_zod34.z.array(import_zod34.z.string()).nullish(),
  updated_at: import_zod34.z.string(),
  value: import_zod34.z.record(import_zod34.z.any())
});

// src/generated-definitions/BulkGetAdminGameRecordResponse.ts
var import_zod35 = require("zod");
var BulkGetAdminGameRecordResponse = import_zod35.z.object({ data: import_zod35.z.array(AdminGameRecordResponse) });

// src/generated-definitions/ListAdminGameRecordKeysResponse.ts
var import_zod36 = require("zod");
var ListAdminGameRecordKeysResponse = import_zod36.z.object({ data: import_zod36.z.array(import_zod36.z.string()), paging: Pagination });

// src/generated-definitions/ListAdminPlayerRecordKeysResponse.ts
var import_zod38 = require("zod");

// src/generated-definitions/AdminPlayerRecordKeyInfo.ts
var import_zod37 = require("zod");
var AdminPlayerRecordKeyInfo = import_zod37.z.object({ key: import_zod37.z.string(), user_id: import_zod37.z.string() });

// src/generated-definitions/ListAdminPlayerRecordKeysResponse.ts
var ListAdminPlayerRecordKeysResponse = import_zod38.z.object({ data: import_zod38.z.array(AdminPlayerRecordKeyInfo), paging: Pagination });

// src/generated-admin/endpoints/RecordAdmin$.ts
var RecordAdmin$ = class {
  // @ts-ignore
  // prettier-ignore
  constructor(axiosInstance, namespace, useSchemaValidation = true) {
    this.axiosInstance = axiosInstance;
    this.namespace = namespace;
    this.useSchemaValidation = useSchemaValidation;
  }
  /**
   * Retrieve list of records key by namespace
   */
  getAdminrecords(queryParams) {
    const params = { limit: 25, ...queryParams };
    const url = "/cloudsave/v1/admin/namespaces/{namespace}/adminrecords".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.get(url, { params });
    return import_sdk13.Validate.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      ListAdminGameRecordKeysResponse,
      "ListAdminGameRecordKeysResponse"
    );
  }
  /**
   * Bulk get admin game records. Maximum key per request 20.
   */
  fetchAdminrecordBulk(data) {
    const params = {};
    const url = "/cloudsave/v1/admin/namespaces/{namespace}/adminrecords/bulk".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.post(url, data, { params });
    return import_sdk13.Validate.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      BulkGetAdminGameRecordResponse,
      "BulkGetAdminGameRecordResponse"
    );
  }
  /**
   * This endpoints delete game record in namespace-level
   */
  deleteAdminrecord_ByKey(key) {
    const params = {};
    const url = "/cloudsave/v1/admin/namespaces/{namespace}/adminrecords/{key}".replace("{namespace}", this.namespace).replace("{key}", key);
    const resultPromise = this.axiosInstance.delete(url, { params });
    return import_sdk13.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, import_zod39.z.unknown(), "z.unknown()");
  }
  /**
   * Get a record by its key in namespace-level.
   */
  getAdminrecord_ByKey(key) {
    const params = {};
    const url = "/cloudsave/v1/admin/namespaces/{namespace}/adminrecords/{key}".replace("{namespace}", this.namespace).replace("{key}", key);
    const resultPromise = this.axiosInstance.get(url, { params });
    return import_sdk13.Validate.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      AdminGameRecordResponse,
      "AdminGameRecordResponse"
    );
  }
  /**
   * ## Description This endpoints will create new admin game record or append the existing admin game record. **Append example:** Example 1 - Existing JSON: `{ &#34;data1&#34;: &#34;value&#34; }` - New JSON: `{ &#34;data2&#34;: &#34;new value&#34; }` - Result: `{ &#34;data1&#34;: &#34;value&#34;, &#34;data2&#34;: &#34;new value&#34; }` Example 2 - Existing JSON: `{ &#34;data1&#34;: { &#34;data2&#34;: &#34;value&#34; }` - New JSON: `{ &#34;data1&#34;: { &#34;data3&#34;: &#34;new value&#34; }` - Result: `{ &#34;data1&#34;: { &#34;data2&#34;: &#34;value&#34;, &#34;data3&#34;: &#34;new value&#34; }` ## Restriction This is the restriction of Key Naming for the record: 1. Cannot use **&#34;.&#34;** as the key name - `{ &#34;data.2&#34;: &#34;value&#34; }` 2. Cannot use **&#34;$&#34;** as the prefix in key names - `{ &#34;$data&#34;: &#34;value&#34; }` 3. Cannot use empty string in key names - `{ &#34;&#34;: &#34;value&#34; }` ## Record Metadata Metadata allows user to define the behaviour of the record. Metadata can be defined in request body with field name **__META**. When creating record, if **__META** field is not defined, the metadata value will use the default value. When updating record, if **__META** field is not defined, the existing metadata value will stay as is. **Metadata List:** 1. tags (default: *empty array*, type: array of string) Indicate the tagging for the admin record. **Request Body Example:** ``` { &#34;__META&#34;: { &#34;tags&#34;: [&#34;tag1&#34;, &#34;tag2&#34;] } ... } ```
   */
  createAdminrecord_ByKey(key, data) {
    const params = {};
    const url = "/cloudsave/v1/admin/namespaces/{namespace}/adminrecords/{key}".replace("{namespace}", this.namespace).replace("{key}", key);
    const resultPromise = this.axiosInstance.post(url, data, { params });
    return import_sdk13.Validate.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      AdminGameRecordResponse,
      "AdminGameRecordResponse"
    );
  }
  /**
   * ## Description This endpoints will create new admin game record or replace the existing admin game record. **Append example:** Example - Existing JSON: `{ &#34;data1&#34;: &#34;value&#34; }` - New JSON: `{ &#34;data2&#34;: &#34;new value&#34; }` - Result: `{ &#34;data2&#34;: &#34;new value&#34; }` ## Restriction This is the restriction of Key Naming for the record: 1. Cannot use **&#34;.&#34;** as the key name - `{ &#34;data.2&#34;: &#34;value&#34; }` 2. Cannot use **&#34;$&#34;** as the prefix in key names - `{ &#34;$data&#34;: &#34;value&#34; }` 3. Cannot use empty string in key names - `{ &#34;&#34;: &#34;value&#34; }` ## Record Metadata Metadata allows user to define the behaviour of the record. Metadata can be defined in request body with field name **__META**. When creating record, if **__META** field is not defined, the metadata value will use the default value. When updating record, if **__META** field is not defined, the existing metadata value will stay as is. **Metadata List:** 1. tags (default: *empty array*, type: array of string) Indicate the tagging for the admin record. **Request Body Example:** ``` { &#34;__META&#34;: { &#34;tags&#34;: [&#34;tag1&#34;, &#34;tag2&#34;] } ... } ```
   */
  updateAdminrecord_ByKey(key, data) {
    const params = {};
    const url = "/cloudsave/v1/admin/namespaces/{namespace}/adminrecords/{key}".replace("{namespace}", this.namespace).replace("{key}", key);
    const resultPromise = this.axiosInstance.put(url, data, { params });
    return import_sdk13.Validate.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      AdminGameRecordResponse,
      "AdminGameRecordResponse"
    );
  }
  /**
   * Retrieve list of admin player records key and userID under given namespace.
   */
  getAdminrecords_ByUserId(userId, queryParams) {
    const params = { limit: 25, ...queryParams };
    const url = "/cloudsave/v1/admin/namespaces/{namespace}/users/{userId}/adminrecords".replace("{namespace}", this.namespace).replace("{userId}", userId);
    const resultPromise = this.axiosInstance.get(url, { params });
    return import_sdk13.Validate.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      ListAdminPlayerRecordKeysResponse,
      "ListAdminPlayerRecordKeysResponse"
    );
  }
  /**
   * Bulk get admin player record by userIds, max allowed 20 at a time.
   */
  fetchBulkUser_ByKey(key, data) {
    const params = {};
    const url = "/cloudsave/v1/admin/namespaces/{namespace}/users/adminrecords/{key}/bulk".replace("{namespace}", this.namespace).replace("{key}", key);
    const resultPromise = this.axiosInstance.post(url, data, { params });
    return import_sdk13.Validate.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      BulkGetAdminPlayerRecordResponse,
      "BulkGetAdminPlayerRecordResponse"
    );
  }
  /**
   * Bulk get admin player records. Maximum key per request 20.
   */
  fetchAdminrecordBulk_ByUserId(userId, data) {
    const params = {};
    const url = "/cloudsave/v1/admin/namespaces/{namespace}/users/{userId}/adminrecords/bulk".replace("{namespace}", this.namespace).replace("{userId}", userId);
    const resultPromise = this.axiosInstance.post(url, data, { params });
    return import_sdk13.Validate.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      BulkGetAdminPlayerRecordResponse,
      "BulkGetAdminPlayerRecordResponse"
    );
  }
  /**
   * Delete a record (arbitrary JSON data) in user-level with given key.
   */
  deleteAdminrecord_ByUserId_ByKey(userId, key) {
    const params = {};
    const url = "/cloudsave/v1/admin/namespaces/{namespace}/users/{userId}/adminrecords/{key}".replace("{namespace}", this.namespace).replace("{userId}", userId).replace("{key}", key);
    const resultPromise = this.axiosInstance.delete(url, { params });
    return import_sdk13.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, import_zod39.z.unknown(), "z.unknown()");
  }
  /**
   * Get a admin record in user-level (arbitrary JSON data) by its key.
   */
  getAdminrecord_ByUserId_ByKey(userId, key) {
    const params = {};
    const url = "/cloudsave/v1/admin/namespaces/{namespace}/users/{userId}/adminrecords/{key}".replace("{namespace}", this.namespace).replace("{userId}", userId).replace("{key}", key);
    const resultPromise = this.axiosInstance.get(url, { params });
    return import_sdk13.Validate.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      AdminPlayerRecordResponse,
      "AdminPlayerRecordResponse"
    );
  }
  /**
   * ## Description This endpoints will create new admin player record or append the existing admin game record. **Append example:** Example 1 - Existing JSON: `{ &#34;data1&#34;: &#34;value&#34; }` - New JSON: `{ &#34;data2&#34;: &#34;new value&#34; }` - Result: `{ &#34;data1&#34;: &#34;value&#34;, &#34;data2&#34;: &#34;new value&#34; }` Example 2 - Existing JSON: `{ &#34;data1&#34;: { &#34;data2&#34;: &#34;value&#34; }` - New JSON: `{ &#34;data1&#34;: { &#34;data3&#34;: &#34;new value&#34; }` - Result: `{ &#34;data1&#34;: { &#34;data2&#34;: &#34;value&#34;, &#34;data3&#34;: &#34;new value&#34; }` ## Restriction This is the restriction of Key Naming for the record: 1. Cannot use **&#34;.&#34;** as the key name - `{ &#34;data.2&#34;: &#34;value&#34; }` 2. Cannot use **&#34;$&#34;** as the prefix in key names - `{ &#34;$data&#34;: &#34;value&#34; }` 3. Cannot use empty string in key names - `{ &#34;&#34;: &#34;value&#34; }` ## Record Metadata Metadata allows user to define the behaviour of the record. Metadata can be defined in request body with field name **__META**. When creating record, if **__META** field is not defined, the metadata value will use the default value. When updating record, if **__META** field is not defined, the existing metadata value will stay as is. **Metadata List:** 1. tags (default: *empty array*, type: array of string) Indicate the tagging for the admin record. **Request Body Example:** ``` { &#34;__META&#34;: { &#34;tags&#34;: [&#34;tag1&#34;, &#34;tag2&#34;] } ... } ```
   */
  createAdminrecord_ByUserId_ByKey(userId, key, data) {
    const params = {};
    const url = "/cloudsave/v1/admin/namespaces/{namespace}/users/{userId}/adminrecords/{key}".replace("{namespace}", this.namespace).replace("{userId}", userId).replace("{key}", key);
    const resultPromise = this.axiosInstance.post(url, data, { params });
    return import_sdk13.Validate.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      AdminPlayerRecordResponse,
      "AdminPlayerRecordResponse"
    );
  }
  /**
   * ## Description This endpoints will create new admin player record or replace the existing admin player record. **Replace behaviour:** The existing value will be replaced completely with the new value. Example - Existing JSON: `{ &#34;data1&#34;: &#34;value&#34; }` - New JSON: `{ &#34;data2&#34;: &#34;new value&#34; }` - Result: `{ &#34;data2&#34;: &#34;new value&#34; }` ## Restriction This is the restriction of Key Naming for the record: 1. Cannot use **&#34;.&#34;** as the key name - `{ &#34;data.2&#34;: &#34;value&#34; }` 2. Cannot use **&#34;$&#34;** as the prefix in key names - `{ &#34;$data&#34;: &#34;value&#34; }` 3. Cannot use empty string in key names - `{ &#34;&#34;: &#34;value&#34; }` ## Record Metadata Metadata allows user to define the behaviour of the record. Metadata can be defined in request body with field name **__META**. When creating record, if **__META** field is not defined, the metadata value will use the default value. When updating record, if **__META** field is not defined, the existing metadata value will stay as is. **Metadata List:** 1. tags (default: *empty array*, type: array of string) Indicate the tagging for the admin record. **Request Body Example:** ``` { &#34;__META&#34;: { &#34;tags&#34;: [&#34;tag1&#34;, &#34;tag2&#34;] } ... } ```
   */
  updateAdminrecord_ByUserId_ByKey(userId, key, data) {
    const params = {};
    const url = "/cloudsave/v1/admin/namespaces/{namespace}/users/{userId}/adminrecords/{key}".replace("{namespace}", this.namespace).replace("{userId}", userId).replace("{key}", key);
    const resultPromise = this.axiosInstance.put(url, data, { params });
    return import_sdk13.Validate.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      AdminPlayerRecordResponse,
      "AdminPlayerRecordResponse"
    );
  }
};

// src/generated-admin/RecordAdminApi.ts
function RecordAdminApi(sdk, args) {
  const sdkAssembly = sdk.assembly();
  const namespace = args?.coreConfig?.namespace ?? sdkAssembly.coreConfig.namespace;
  const useSchemaValidation = args?.coreConfig?.useSchemaValidation ?? sdkAssembly.coreConfig.useSchemaValidation;
  let axiosInstance = sdkAssembly.axiosInstance;
  const requestConfigOverrides = args?.axiosConfig?.request;
  const baseURLOverride = args?.coreConfig?.baseURL;
  const interceptorsOverride = args?.axiosConfig?.interceptors ?? [];
  if (requestConfigOverrides || baseURLOverride || interceptorsOverride.length > 0) {
    const requestConfig = import_sdk14.ApiUtils.mergeAxiosConfigs(sdkAssembly.axiosInstance.defaults, {
      ...baseURLOverride ? { baseURL: baseURLOverride } : {},
      ...requestConfigOverrides
    });
    axiosInstance = import_sdk14.Network.create(requestConfig);
    for (const interceptor of interceptorsOverride) {
      if (interceptor.type === "request") {
        axiosInstance.interceptors.request.use(interceptor.onRequest, interceptor.onError);
      }
      if (interceptor.type === "response") {
        axiosInstance.interceptors.response.use(interceptor.onSuccess, interceptor.onError);
      }
    }
  }
  async function getAdminrecords(queryParams) {
    const $ = new RecordAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getAdminrecords(queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function fetchAdminrecordBulk(data) {
    const $ = new RecordAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.fetchAdminrecordBulk(data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function deleteAdminrecord_ByKey(key) {
    const $ = new RecordAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.deleteAdminrecord_ByKey(key);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getAdminrecord_ByKey(key) {
    const $ = new RecordAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getAdminrecord_ByKey(key);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function createAdminrecord_ByKey(key, data) {
    const $ = new RecordAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.createAdminrecord_ByKey(key, data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function updateAdminrecord_ByKey(key, data) {
    const $ = new RecordAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.updateAdminrecord_ByKey(key, data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getAdminrecords_ByUserId(userId, queryParams) {
    const $ = new RecordAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getAdminrecords_ByUserId(userId, queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function fetchBulkUser_ByKey(key, data) {
    const $ = new RecordAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.fetchBulkUser_ByKey(key, data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function fetchAdminrecordBulk_ByUserId(userId, data) {
    const $ = new RecordAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.fetchAdminrecordBulk_ByUserId(userId, data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function deleteAdminrecord_ByUserId_ByKey(userId, key) {
    const $ = new RecordAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.deleteAdminrecord_ByUserId_ByKey(userId, key);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getAdminrecord_ByUserId_ByKey(userId, key) {
    const $ = new RecordAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getAdminrecord_ByUserId_ByKey(userId, key);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function createAdminrecord_ByUserId_ByKey(userId, key, data) {
    const $ = new RecordAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.createAdminrecord_ByUserId_ByKey(userId, key, data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function updateAdminrecord_ByUserId_ByKey(userId, key, data) {
    const $ = new RecordAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.updateAdminrecord_ByUserId_ByKey(userId, key, data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  return {
    /**
     * Retrieve list of records key by namespace
     */
    getAdminrecords,
    /**
     * Bulk get admin game records. Maximum key per request 20.
     */
    fetchAdminrecordBulk,
    /**
     * This endpoints delete game record in namespace-level
     */
    deleteAdminrecord_ByKey,
    /**
     * Get a record by its key in namespace-level.
     */
    getAdminrecord_ByKey,
    /**
     * ## Description This endpoints will create new admin game record or append the existing admin game record. **Append example:** Example 1 - Existing JSON: `{ &#34;data1&#34;: &#34;value&#34; }` - New JSON: `{ &#34;data2&#34;: &#34;new value&#34; }` - Result: `{ &#34;data1&#34;: &#34;value&#34;, &#34;data2&#34;: &#34;new value&#34; }` Example 2 - Existing JSON: `{ &#34;data1&#34;: { &#34;data2&#34;: &#34;value&#34; }` - New JSON: `{ &#34;data1&#34;: { &#34;data3&#34;: &#34;new value&#34; }` - Result: `{ &#34;data1&#34;: { &#34;data2&#34;: &#34;value&#34;, &#34;data3&#34;: &#34;new value&#34; }` ## Restriction This is the restriction of Key Naming for the record: 1. Cannot use **&#34;.&#34;** as the key name - `{ &#34;data.2&#34;: &#34;value&#34; }` 2. Cannot use **&#34;$&#34;** as the prefix in key names - `{ &#34;$data&#34;: &#34;value&#34; }` 3. Cannot use empty string in key names - `{ &#34;&#34;: &#34;value&#34; }` ## Record Metadata Metadata allows user to define the behaviour of the record. Metadata can be defined in request body with field name **__META**. When creating record, if **__META** field is not defined, the metadata value will use the default value. When updating record, if **__META** field is not defined, the existing metadata value will stay as is. **Metadata List:** 1. tags (default: *empty array*, type: array of string) Indicate the tagging for the admin record. **Request Body Example:** ``` { &#34;__META&#34;: { &#34;tags&#34;: [&#34;tag1&#34;, &#34;tag2&#34;] } ... } ```
     */
    createAdminrecord_ByKey,
    /**
     * ## Description This endpoints will create new admin game record or replace the existing admin game record. **Append example:** Example - Existing JSON: `{ &#34;data1&#34;: &#34;value&#34; }` - New JSON: `{ &#34;data2&#34;: &#34;new value&#34; }` - Result: `{ &#34;data2&#34;: &#34;new value&#34; }` ## Restriction This is the restriction of Key Naming for the record: 1. Cannot use **&#34;.&#34;** as the key name - `{ &#34;data.2&#34;: &#34;value&#34; }` 2. Cannot use **&#34;$&#34;** as the prefix in key names - `{ &#34;$data&#34;: &#34;value&#34; }` 3. Cannot use empty string in key names - `{ &#34;&#34;: &#34;value&#34; }` ## Record Metadata Metadata allows user to define the behaviour of the record. Metadata can be defined in request body with field name **__META**. When creating record, if **__META** field is not defined, the metadata value will use the default value. When updating record, if **__META** field is not defined, the existing metadata value will stay as is. **Metadata List:** 1. tags (default: *empty array*, type: array of string) Indicate the tagging for the admin record. **Request Body Example:** ``` { &#34;__META&#34;: { &#34;tags&#34;: [&#34;tag1&#34;, &#34;tag2&#34;] } ... } ```
     */
    updateAdminrecord_ByKey,
    /**
     * Retrieve list of admin player records key and userID under given namespace.
     */
    getAdminrecords_ByUserId,
    /**
     * Bulk get admin player record by userIds, max allowed 20 at a time.
     */
    fetchBulkUser_ByKey,
    /**
     * Bulk get admin player records. Maximum key per request 20.
     */
    fetchAdminrecordBulk_ByUserId,
    /**
     * Delete a record (arbitrary JSON data) in user-level with given key.
     */
    deleteAdminrecord_ByUserId_ByKey,
    /**
     * Get a admin record in user-level (arbitrary JSON data) by its key.
     */
    getAdminrecord_ByUserId_ByKey,
    /**
     * ## Description This endpoints will create new admin player record or append the existing admin game record. **Append example:** Example 1 - Existing JSON: `{ &#34;data1&#34;: &#34;value&#34; }` - New JSON: `{ &#34;data2&#34;: &#34;new value&#34; }` - Result: `{ &#34;data1&#34;: &#34;value&#34;, &#34;data2&#34;: &#34;new value&#34; }` Example 2 - Existing JSON: `{ &#34;data1&#34;: { &#34;data2&#34;: &#34;value&#34; }` - New JSON: `{ &#34;data1&#34;: { &#34;data3&#34;: &#34;new value&#34; }` - Result: `{ &#34;data1&#34;: { &#34;data2&#34;: &#34;value&#34;, &#34;data3&#34;: &#34;new value&#34; }` ## Restriction This is the restriction of Key Naming for the record: 1. Cannot use **&#34;.&#34;** as the key name - `{ &#34;data.2&#34;: &#34;value&#34; }` 2. Cannot use **&#34;$&#34;** as the prefix in key names - `{ &#34;$data&#34;: &#34;value&#34; }` 3. Cannot use empty string in key names - `{ &#34;&#34;: &#34;value&#34; }` ## Record Metadata Metadata allows user to define the behaviour of the record. Metadata can be defined in request body with field name **__META**. When creating record, if **__META** field is not defined, the metadata value will use the default value. When updating record, if **__META** field is not defined, the existing metadata value will stay as is. **Metadata List:** 1. tags (default: *empty array*, type: array of string) Indicate the tagging for the admin record. **Request Body Example:** ``` { &#34;__META&#34;: { &#34;tags&#34;: [&#34;tag1&#34;, &#34;tag2&#34;] } ... } ```
     */
    createAdminrecord_ByUserId_ByKey,
    /**
     * ## Description This endpoints will create new admin player record or replace the existing admin player record. **Replace behaviour:** The existing value will be replaced completely with the new value. Example - Existing JSON: `{ &#34;data1&#34;: &#34;value&#34; }` - New JSON: `{ &#34;data2&#34;: &#34;new value&#34; }` - Result: `{ &#34;data2&#34;: &#34;new value&#34; }` ## Restriction This is the restriction of Key Naming for the record: 1. Cannot use **&#34;.&#34;** as the key name - `{ &#34;data.2&#34;: &#34;value&#34; }` 2. Cannot use **&#34;$&#34;** as the prefix in key names - `{ &#34;$data&#34;: &#34;value&#34; }` 3. Cannot use empty string in key names - `{ &#34;&#34;: &#34;value&#34; }` ## Record Metadata Metadata allows user to define the behaviour of the record. Metadata can be defined in request body with field name **__META**. When creating record, if **__META** field is not defined, the metadata value will use the default value. When updating record, if **__META** field is not defined, the existing metadata value will stay as is. **Metadata List:** 1. tags (default: *empty array*, type: array of string) Indicate the tagging for the admin record. **Request Body Example:** ``` { &#34;__META&#34;: { &#34;tags&#34;: [&#34;tag1&#34;, &#34;tag2&#34;] } ... } ```
     */
    updateAdminrecord_ByUserId_ByKey
  };
}

// src/generated-admin/queries/RecordAdmin.query.ts
var Key_RecordAdmin = /* @__PURE__ */ ((Key_RecordAdmin2) => {
  Key_RecordAdmin2["Adminrecords"] = "Cloudsave.RecordAdmin.Adminrecords";
  Key_RecordAdmin2["AdminrecordBulk"] = "Cloudsave.RecordAdmin.AdminrecordBulk";
  Key_RecordAdmin2["Adminrecord_ByKey"] = "Cloudsave.RecordAdmin.Adminrecord_ByKey";
  Key_RecordAdmin2["Adminrecords_ByUserId"] = "Cloudsave.RecordAdmin.Adminrecords_ByUserId";
  Key_RecordAdmin2["BulkUser_ByKey"] = "Cloudsave.RecordAdmin.BulkUser_ByKey";
  Key_RecordAdmin2["AdminrecordBulk_ByUserId"] = "Cloudsave.RecordAdmin.AdminrecordBulk_ByUserId";
  Key_RecordAdmin2["Adminrecord_ByUserId_ByKey"] = "Cloudsave.RecordAdmin.Adminrecord_ByUserId_ByKey";
  return Key_RecordAdmin2;
})(Key_RecordAdmin || {});
var useRecordAdminApi_GetAdminrecords = (sdk, input, options, callback) => {
  const queryFn = (sdk2, input2) => async () => {
    const response = await RecordAdminApi(sdk2, { coreConfig: input2.coreConfig, axiosConfig: input2.axiosConfig }).getAdminrecords(
      input2.queryParams
    );
    callback && callback(response);
    return response.data;
  };
  return (0, import_react_query7.useQuery)({
    queryKey: ["Cloudsave.RecordAdmin.Adminrecords" /* Adminrecords */, input],
    queryFn: queryFn(sdk, input),
    ...options
  });
};
var useRecordAdminApi_FetchAdminrecordBulk = (sdk, input, options, callback) => {
  const queryFn = (sdk2, input2) => async () => {
    const response = await RecordAdminApi(sdk2, { coreConfig: input2.coreConfig, axiosConfig: input2.axiosConfig }).fetchAdminrecordBulk(
      input2.data
    );
    callback && callback(response);
    return response.data;
  };
  return (0, import_react_query7.useQuery)({
    queryKey: ["Cloudsave.RecordAdmin.AdminrecordBulk" /* AdminrecordBulk */, input],
    queryFn: queryFn(sdk, input),
    ...options
  });
};
var useRecordAdminApi_DeleteAdminrecord_ByKeyMutation = (sdk, options, callback) => {
  const mutationFn = async (input) => {
    const response = await RecordAdminApi(sdk, { coreConfig: input.coreConfig, axiosConfig: input.axiosConfig }).deleteAdminrecord_ByKey(
      input.key
    );
    callback && callback(response.data);
    return response.data;
  };
  return (0, import_react_query7.useMutation)({
    mutationKey: ["Cloudsave.RecordAdmin.Adminrecord_ByKey" /* Adminrecord_ByKey */],
    mutationFn,
    ...options
  });
};
var useRecordAdminApi_GetAdminrecord_ByKey = (sdk, input, options, callback) => {
  const queryFn = (sdk2, input2) => async () => {
    const response = await RecordAdminApi(sdk2, { coreConfig: input2.coreConfig, axiosConfig: input2.axiosConfig }).getAdminrecord_ByKey(
      input2.key
    );
    callback && callback(response);
    return response.data;
  };
  return (0, import_react_query7.useQuery)({
    queryKey: ["Cloudsave.RecordAdmin.Adminrecord_ByKey" /* Adminrecord_ByKey */, input],
    queryFn: queryFn(sdk, input),
    ...options
  });
};
var useRecordAdminApi_CreateAdminrecord_ByKeyMutation = (sdk, options, callback) => {
  const mutationFn = async (input) => {
    const response = await RecordAdminApi(sdk, { coreConfig: input.coreConfig, axiosConfig: input.axiosConfig }).createAdminrecord_ByKey(
      input.key,
      input.data
    );
    callback && callback(response.data);
    return response.data;
  };
  return (0, import_react_query7.useMutation)({
    mutationKey: ["Cloudsave.RecordAdmin.Adminrecord_ByKey" /* Adminrecord_ByKey */],
    mutationFn,
    ...options
  });
};
var useRecordAdminApi_UpdateAdminrecord_ByKeyMutation = (sdk, options, callback) => {
  const mutationFn = async (input) => {
    const response = await RecordAdminApi(sdk, { coreConfig: input.coreConfig, axiosConfig: input.axiosConfig }).updateAdminrecord_ByKey(
      input.key,
      input.data
    );
    callback && callback(response.data);
    return response.data;
  };
  return (0, import_react_query7.useMutation)({
    mutationKey: ["Cloudsave.RecordAdmin.Adminrecord_ByKey" /* Adminrecord_ByKey */],
    mutationFn,
    ...options
  });
};
var useRecordAdminApi_GetAdminrecords_ByUserId = (sdk, input, options, callback) => {
  const queryFn = (sdk2, input2) => async () => {
    const response = await RecordAdminApi(sdk2, { coreConfig: input2.coreConfig, axiosConfig: input2.axiosConfig }).getAdminrecords_ByUserId(
      input2.userId,
      input2.queryParams
    );
    callback && callback(response);
    return response.data;
  };
  return (0, import_react_query7.useQuery)({
    queryKey: ["Cloudsave.RecordAdmin.Adminrecords_ByUserId" /* Adminrecords_ByUserId */, input],
    queryFn: queryFn(sdk, input),
    ...options
  });
};
var useRecordAdminApi_FetchBulkUser_ByKey = (sdk, input, options, callback) => {
  const queryFn = (sdk2, input2) => async () => {
    const response = await RecordAdminApi(sdk2, { coreConfig: input2.coreConfig, axiosConfig: input2.axiosConfig }).fetchBulkUser_ByKey(
      input2.key,
      input2.data
    );
    callback && callback(response);
    return response.data;
  };
  return (0, import_react_query7.useQuery)({
    queryKey: ["Cloudsave.RecordAdmin.BulkUser_ByKey" /* BulkUser_ByKey */, input],
    queryFn: queryFn(sdk, input),
    ...options
  });
};
var useRecordAdminApi_FetchAdminrecordBulk_ByUserId = (sdk, input, options, callback) => {
  const queryFn = (sdk2, input2) => async () => {
    const response = await RecordAdminApi(sdk2, {
      coreConfig: input2.coreConfig,
      axiosConfig: input2.axiosConfig
    }).fetchAdminrecordBulk_ByUserId(input2.userId, input2.data);
    callback && callback(response);
    return response.data;
  };
  return (0, import_react_query7.useQuery)({
    queryKey: ["Cloudsave.RecordAdmin.AdminrecordBulk_ByUserId" /* AdminrecordBulk_ByUserId */, input],
    queryFn: queryFn(sdk, input),
    ...options
  });
};
var useRecordAdminApi_DeleteAdminrecord_ByUserId_ByKeyMutation = (sdk, options, callback) => {
  const mutationFn = async (input) => {
    const response = await RecordAdminApi(sdk, {
      coreConfig: input.coreConfig,
      axiosConfig: input.axiosConfig
    }).deleteAdminrecord_ByUserId_ByKey(input.userId, input.key);
    callback && callback(response.data);
    return response.data;
  };
  return (0, import_react_query7.useMutation)({
    mutationKey: ["Cloudsave.RecordAdmin.Adminrecord_ByUserId_ByKey" /* Adminrecord_ByUserId_ByKey */],
    mutationFn,
    ...options
  });
};
var useRecordAdminApi_GetAdminrecord_ByUserId_ByKey = (sdk, input, options, callback) => {
  const queryFn = (sdk2, input2) => async () => {
    const response = await RecordAdminApi(sdk2, {
      coreConfig: input2.coreConfig,
      axiosConfig: input2.axiosConfig
    }).getAdminrecord_ByUserId_ByKey(input2.userId, input2.key);
    callback && callback(response);
    return response.data;
  };
  return (0, import_react_query7.useQuery)({
    queryKey: ["Cloudsave.RecordAdmin.Adminrecord_ByUserId_ByKey" /* Adminrecord_ByUserId_ByKey */, input],
    queryFn: queryFn(sdk, input),
    ...options
  });
};
var useRecordAdminApi_CreateAdminrecord_ByUserId_ByKeyMutation = (sdk, options, callback) => {
  const mutationFn = async (input) => {
    const response = await RecordAdminApi(sdk, {
      coreConfig: input.coreConfig,
      axiosConfig: input.axiosConfig
    }).createAdminrecord_ByUserId_ByKey(input.userId, input.key, input.data);
    callback && callback(response.data);
    return response.data;
  };
  return (0, import_react_query7.useMutation)({
    mutationKey: ["Cloudsave.RecordAdmin.Adminrecord_ByUserId_ByKey" /* Adminrecord_ByUserId_ByKey */],
    mutationFn,
    ...options
  });
};
var useRecordAdminApi_UpdateAdminrecord_ByUserId_ByKeyMutation = (sdk, options, callback) => {
  const mutationFn = async (input) => {
    const response = await RecordAdminApi(sdk, {
      coreConfig: input.coreConfig,
      axiosConfig: input.axiosConfig
    }).updateAdminrecord_ByUserId_ByKey(input.userId, input.key, input.data);
    callback && callback(response.data);
    return response.data;
  };
  return (0, import_react_query7.useMutation)({
    mutationKey: ["Cloudsave.RecordAdmin.Adminrecord_ByUserId_ByKey" /* Adminrecord_ByUserId_ByKey */],
    mutationFn,
    ...options
  });
};

// src/generated-admin/queries/TagsAdmin.query.ts
var import_react_query8 = require("@tanstack/react-query");

// src/generated-admin/TagsAdminApi.ts
var import_sdk16 = require("@accelbyte/sdk");

// src/generated-admin/endpoints/TagsAdmin$.ts
var import_sdk15 = require("@accelbyte/sdk");
var import_zod42 = require("zod");

// src/generated-definitions/ListTagsResponse.ts
var import_zod41 = require("zod");

// src/generated-definitions/TagInfo.ts
var import_zod40 = require("zod");
var TagInfo = import_zod40.z.object({ created_at: import_zod40.z.string(), tag: import_zod40.z.string() });

// src/generated-definitions/ListTagsResponse.ts
var ListTagsResponse = import_zod41.z.object({ data: import_zod41.z.array(TagInfo), paging: Pagination });

// src/generated-admin/endpoints/TagsAdmin$.ts
var TagsAdmin$ = class {
  // @ts-ignore
  // prettier-ignore
  constructor(axiosInstance, namespace, useSchemaValidation = true) {
    this.axiosInstance = axiosInstance;
    this.namespace = namespace;
    this.useSchemaValidation = useSchemaValidation;
  }
  /**
   * ## Description Retrieve list of available tags by namespace
   */
  getTags(queryParams) {
    const params = { limit: 25, ...queryParams };
    const url = "/cloudsave/v1/admin/namespaces/{namespace}/tags".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.get(url, { params });
    return import_sdk15.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, ListTagsResponse, "ListTagsResponse");
  }
  /**
   * ## Description This endpoint will create new tags
   */
  createTag(data) {
    const params = {};
    const url = "/cloudsave/v1/admin/namespaces/{namespace}/tags".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.post(url, data, { params });
    return import_sdk15.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, import_zod42.z.unknown(), "z.unknown()");
  }
  /**
   * ## Description This endpoint will delete tag by name
   */
  deleteTag_ByTag(tag) {
    const params = {};
    const url = "/cloudsave/v1/admin/namespaces/{namespace}/tags/{tag}".replace("{namespace}", this.namespace).replace("{tag}", tag);
    const resultPromise = this.axiosInstance.delete(url, { params });
    return import_sdk15.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, import_zod42.z.unknown(), "z.unknown()");
  }
};

// src/generated-admin/TagsAdminApi.ts
function TagsAdminApi(sdk, args) {
  const sdkAssembly = sdk.assembly();
  const namespace = args?.coreConfig?.namespace ?? sdkAssembly.coreConfig.namespace;
  const useSchemaValidation = args?.coreConfig?.useSchemaValidation ?? sdkAssembly.coreConfig.useSchemaValidation;
  let axiosInstance = sdkAssembly.axiosInstance;
  const requestConfigOverrides = args?.axiosConfig?.request;
  const baseURLOverride = args?.coreConfig?.baseURL;
  const interceptorsOverride = args?.axiosConfig?.interceptors ?? [];
  if (requestConfigOverrides || baseURLOverride || interceptorsOverride.length > 0) {
    const requestConfig = import_sdk16.ApiUtils.mergeAxiosConfigs(sdkAssembly.axiosInstance.defaults, {
      ...baseURLOverride ? { baseURL: baseURLOverride } : {},
      ...requestConfigOverrides
    });
    axiosInstance = import_sdk16.Network.create(requestConfig);
    for (const interceptor of interceptorsOverride) {
      if (interceptor.type === "request") {
        axiosInstance.interceptors.request.use(interceptor.onRequest, interceptor.onError);
      }
      if (interceptor.type === "response") {
        axiosInstance.interceptors.response.use(interceptor.onSuccess, interceptor.onError);
      }
    }
  }
  async function getTags(queryParams) {
    const $ = new TagsAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getTags(queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function createTag(data) {
    const $ = new TagsAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.createTag(data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function deleteTag_ByTag(tag) {
    const $ = new TagsAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.deleteTag_ByTag(tag);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  return {
    /**
     * ## Description Retrieve list of available tags by namespace
     */
    getTags,
    /**
     * ## Description This endpoint will create new tags
     */
    createTag,
    /**
     * ## Description This endpoint will delete tag by name
     */
    deleteTag_ByTag
  };
}

// src/generated-admin/queries/TagsAdmin.query.ts
var Key_TagsAdmin = /* @__PURE__ */ ((Key_TagsAdmin2) => {
  Key_TagsAdmin2["Tags"] = "Cloudsave.TagsAdmin.Tags";
  Key_TagsAdmin2["Tag"] = "Cloudsave.TagsAdmin.Tag";
  Key_TagsAdmin2["Tag_ByTag"] = "Cloudsave.TagsAdmin.Tag_ByTag";
  return Key_TagsAdmin2;
})(Key_TagsAdmin || {});
var useTagsAdminApi_GetTags = (sdk, input, options, callback) => {
  const queryFn = (sdk2, input2) => async () => {
    const response = await TagsAdminApi(sdk2, { coreConfig: input2.coreConfig, axiosConfig: input2.axiosConfig }).getTags(input2.queryParams);
    callback && callback(response);
    return response.data;
  };
  return (0, import_react_query8.useQuery)({
    queryKey: ["Cloudsave.TagsAdmin.Tags" /* Tags */, input],
    queryFn: queryFn(sdk, input),
    ...options
  });
};
var useTagsAdminApi_CreateTagMutation = (sdk, options, callback) => {
  const mutationFn = async (input) => {
    const response = await TagsAdminApi(sdk, { coreConfig: input.coreConfig, axiosConfig: input.axiosConfig }).createTag(input.data);
    callback && callback(response.data);
    return response.data;
  };
  return (0, import_react_query8.useMutation)({
    mutationKey: ["Cloudsave.TagsAdmin.Tag" /* Tag */],
    mutationFn,
    ...options
  });
};
var useTagsAdminApi_DeleteTag_ByTagMutation = (sdk, options, callback) => {
  const mutationFn = async (input) => {
    const response = await TagsAdminApi(sdk, { coreConfig: input.coreConfig, axiosConfig: input.axiosConfig }).deleteTag_ByTag(input.tag);
    callback && callback(response.data);
    return response.data;
  };
  return (0, import_react_query8.useMutation)({
    mutationKey: ["Cloudsave.TagsAdmin.Tag_ByTag" /* Tag_ByTag */],
    mutationFn,
    ...options
  });
};

// src/generated-admin/queries/TtlConfigAdmin.query.ts
var import_react_query9 = require("@tanstack/react-query");

// src/generated-admin/TtlConfigAdminApi.ts
var import_sdk18 = require("@accelbyte/sdk");

// src/generated-admin/endpoints/TtlConfigAdmin$.ts
var import_sdk17 = require("@accelbyte/sdk");
var import_zod43 = require("zod");
var TtlConfigAdmin$ = class {
  // @ts-ignore
  // prettier-ignore
  constructor(axiosInstance, namespace, useSchemaValidation = true) {
    this.axiosInstance = axiosInstance;
    this.namespace = namespace;
    this.useSchemaValidation = useSchemaValidation;
  }
  /**
   * ## Description This endpoints will delete the ttl config of the game record
   */
  deleteTtl_ByKey(key) {
    const params = {};
    const url = "/cloudsave/v1/admin/namespaces/{namespace}/records/{key}/ttl".replace("{namespace}", this.namespace).replace("{key}", key);
    const resultPromise = this.axiosInstance.delete(url, { params });
    return import_sdk17.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, import_zod43.z.unknown(), "z.unknown()");
  }
  /**
   * ## Description This endpoints will delete the ttl config of the game binary record
   */
  deleteTtl_ByKey_ByNS(key) {
    const params = {};
    const url = "/cloudsave/v1/admin/namespaces/{namespace}/binaries/{key}/ttl".replace("{namespace}", this.namespace).replace("{key}", key);
    const resultPromise = this.axiosInstance.delete(url, { params });
    return import_sdk17.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, import_zod43.z.unknown(), "z.unknown()");
  }
};

// src/generated-admin/TtlConfigAdminApi.ts
function TtlConfigAdminApi(sdk, args) {
  const sdkAssembly = sdk.assembly();
  const namespace = args?.coreConfig?.namespace ?? sdkAssembly.coreConfig.namespace;
  const useSchemaValidation = args?.coreConfig?.useSchemaValidation ?? sdkAssembly.coreConfig.useSchemaValidation;
  let axiosInstance = sdkAssembly.axiosInstance;
  const requestConfigOverrides = args?.axiosConfig?.request;
  const baseURLOverride = args?.coreConfig?.baseURL;
  const interceptorsOverride = args?.axiosConfig?.interceptors ?? [];
  if (requestConfigOverrides || baseURLOverride || interceptorsOverride.length > 0) {
    const requestConfig = import_sdk18.ApiUtils.mergeAxiosConfigs(sdkAssembly.axiosInstance.defaults, {
      ...baseURLOverride ? { baseURL: baseURLOverride } : {},
      ...requestConfigOverrides
    });
    axiosInstance = import_sdk18.Network.create(requestConfig);
    for (const interceptor of interceptorsOverride) {
      if (interceptor.type === "request") {
        axiosInstance.interceptors.request.use(interceptor.onRequest, interceptor.onError);
      }
      if (interceptor.type === "response") {
        axiosInstance.interceptors.response.use(interceptor.onSuccess, interceptor.onError);
      }
    }
  }
  async function deleteTtl_ByKey(key) {
    const $ = new TtlConfigAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.deleteTtl_ByKey(key);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function deleteTtl_ByKey_ByNS(key) {
    const $ = new TtlConfigAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.deleteTtl_ByKey_ByNS(key);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  return {
    /**
     * ## Description This endpoints will delete the ttl config of the game record
     */
    deleteTtl_ByKey,
    /**
     * ## Description This endpoints will delete the ttl config of the game binary record
     */
    deleteTtl_ByKey_ByNS
  };
}

// src/generated-admin/queries/TtlConfigAdmin.query.ts
var Key_TtlConfigAdmin = /* @__PURE__ */ ((Key_TtlConfigAdmin2) => {
  Key_TtlConfigAdmin2["Ttl_ByKey"] = "Cloudsave.TtlConfigAdmin.Ttl_ByKey";
  Key_TtlConfigAdmin2["Ttl_ByKey_ByNS"] = "Cloudsave.TtlConfigAdmin.Ttl_ByKey_ByNS";
  return Key_TtlConfigAdmin2;
})(Key_TtlConfigAdmin || {});
var useTtlConfigAdminApi_DeleteTtl_ByKeyMutation = (sdk, options, callback) => {
  const mutationFn = async (input) => {
    const response = await TtlConfigAdminApi(sdk, { coreConfig: input.coreConfig, axiosConfig: input.axiosConfig }).deleteTtl_ByKey(
      input.key
    );
    callback && callback(response.data);
    return response.data;
  };
  return (0, import_react_query9.useMutation)({
    mutationKey: ["Cloudsave.TtlConfigAdmin.Ttl_ByKey" /* Ttl_ByKey */],
    mutationFn,
    ...options
  });
};
var useTtlConfigAdminApi_DeleteTtl_ByKey_ByNSMutation = (sdk, options, callback) => {
  const mutationFn = async (input) => {
    const response = await TtlConfigAdminApi(sdk, { coreConfig: input.coreConfig, axiosConfig: input.axiosConfig }).deleteTtl_ByKey_ByNS(
      input.key
    );
    callback && callback(response.data);
    return response.data;
  };
  return (0, import_react_query9.useMutation)({
    mutationKey: ["Cloudsave.TtlConfigAdmin.Ttl_ByKey_ByNS" /* Ttl_ByKey_ByNS */],
    mutationFn,
    ...options
  });
};

// src/generated-public/queries/ConcurrentRecord.query.ts
var import_react_query10 = require("@tanstack/react-query");

// src/generated-public/ConcurrentRecordApi.ts
var import_sdk20 = require("@accelbyte/sdk");

// src/generated-public/endpoints/ConcurrentRecord$.ts
var import_sdk19 = require("@accelbyte/sdk");
var import_zod44 = require("zod");
var ConcurrentRecord$ = class {
  // @ts-ignore
  // prettier-ignore
  constructor(axiosInstance, namespace, useSchemaValidation = true) {
    this.axiosInstance = axiosInstance;
    this.namespace = namespace;
    this.useSchemaValidation = useSchemaValidation;
  }
  /**
   * ## Description This endpoints will create new game record or replace the existing game record. **Replace behaviour:** The existing value will be replaced completely with the new value. Example - Existing JSON: `{ &#34;data1&#34;: &#34;value&#34; }` - New JSON: `{ &#34;data2&#34;: &#34;new value&#34; }` - Result: `{ &#34;data2&#34;: &#34;new value&#34; }` ## Restriction This is the restriction of Key Naming for the record: 1. Cannot use **&#34;.&#34;** as the key name - `{ &#34;data.2&#34;: &#34;value&#34; }` 2. Cannot use **&#34;$&#34;** as the prefix in key names - `{ &#34;$data&#34;: &#34;value&#34; }` 3. Cannot use empty string in key names - `{ &#34;&#34;: &#34;value&#34; }` ## Reserved Word Reserved Word List: **__META** The reserved word cannot be used as a field in record value, If still defining the field when creating or updating the record, it will be ignored. ## Optimistic Concurrency Control This endpoint implement optimistic concurrency control to avoid race condition. If the record has been updated since the client fetch it, the server will return HTTP status code 412 (precondition failed) and client need to redo the operation (fetch data and do update). Otherwise, the server will process the request.
   */
  updateConcurrentRecord_ByKey(key, data) {
    const params = {};
    const url = "/cloudsave/v1/namespaces/{namespace}/concurrent/records/{key}".replace("{namespace}", this.namespace).replace("{key}", key);
    const resultPromise = this.axiosInstance.put(url, data, { params });
    return import_sdk19.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, import_zod44.z.unknown(), "z.unknown()");
  }
  /**
   * ## Description This endpoints will create new player record or replace the existing player record. **Replace behaviour:** The existing value will be replaced completely with the new value. Example - Existing JSON: `{ &#34;data1&#34;: &#34;value&#34; }` - New JSON: `{ &#34;data2&#34;: &#34;new value&#34; }` - Result: `{ &#34;data2&#34;: &#34;new value&#34; }` ## Restriction This is the restriction of Key Naming for the record: 1. Cannot use **&#34;.&#34;** as the key name - `{ &#34;data.2&#34;: &#34;value&#34; }` 2. Cannot use **&#34;$&#34;** as the prefix in key names - `{ &#34;$data&#34;: &#34;value&#34; }` 3. Cannot use empty string in key names - `{ &#34;&#34;: &#34;value&#34; }` ## Reserved Word Reserved Word List: **__META** The reserved word cannot be used as a field in record value, If still defining the field when creating or updating the record, it will be ignored. ## Optimistic Concurrency Control This endpoint implement optimistic concurrency control to avoid race condition. If the record has been updated since the client fetch it, the server will return HTTP status code 412 (precondition failed) and client need to redo the operation (fetch data and do update). Otherwise, the server will process the request.
   */
  updateConcurrentRecord_ByUserId_ByKey(userId, key, data, queryParams) {
    const params = { ...queryParams };
    const url = "/cloudsave/v1/namespaces/{namespace}/users/{userId}/concurrent/records/{key}".replace("{namespace}", this.namespace).replace("{userId}", userId).replace("{key}", key);
    const resultPromise = this.axiosInstance.put(url, data, { params });
    return import_sdk19.Validate.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      PlayerRecordConcurrentUpdateResponse,
      "PlayerRecordConcurrentUpdateResponse"
    );
  }
  /**
   * ## Description This endpoints will create new player public record or replace the existing player public record. **Replace behaviour:** The existing value will be replaced completely with the new value. Example - Existing JSON: `{ &#34;data1&#34;: &#34;value&#34; }` - New JSON: `{ &#34;data2&#34;: &#34;new value&#34; }` - Result: `{ &#34;data2&#34;: &#34;new value&#34; }` ## Restriction This is the restriction of Key Naming for the record: 1. Cannot use **&#34;.&#34;** as the key name - `{ &#34;data.2&#34;: &#34;value&#34; }` 2. Cannot use **&#34;$&#34;** as the prefix in key names - `{ &#34;$data&#34;: &#34;value&#34; }` 3. Cannot use empty string in key names - `{ &#34;&#34;: &#34;value&#34; }` ## Reserved Word Reserved Word List: **__META** The reserved word cannot be used as a field in record value, If still defining the field when creating or updating the record, it will be ignored. ## Optimistic Concurrency Control This endpoint implement optimistic concurrency control to avoid race condition. If the record has been updated since the client fetch it, the server will return HTTP status code 412 (precondition failed) and client need to redo the operation (fetch data and do update). Otherwise, the server will process the request.
   */
  updatePublicConcurrent_ByUserId_ByKey(userId, key, data, queryParams) {
    const params = { ...queryParams };
    const url = "/cloudsave/v1/namespaces/{namespace}/users/{userId}/concurrent/records/{key}/public".replace("{namespace}", this.namespace).replace("{userId}", userId).replace("{key}", key);
    const resultPromise = this.axiosInstance.put(url, data, { params });
    return import_sdk19.Validate.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      PlayerRecordConcurrentUpdateResponse,
      "PlayerRecordConcurrentUpdateResponse"
    );
  }
};

// src/generated-public/ConcurrentRecordApi.ts
function ConcurrentRecordApi(sdk, args) {
  const sdkAssembly = sdk.assembly();
  const namespace = args?.coreConfig?.namespace ?? sdkAssembly.coreConfig.namespace;
  const useSchemaValidation = args?.coreConfig?.useSchemaValidation ?? sdkAssembly.coreConfig.useSchemaValidation;
  let axiosInstance = sdkAssembly.axiosInstance;
  const requestConfigOverrides = args?.axiosConfig?.request;
  const baseURLOverride = args?.coreConfig?.baseURL;
  const interceptorsOverride = args?.axiosConfig?.interceptors ?? [];
  if (requestConfigOverrides || baseURLOverride || interceptorsOverride.length > 0) {
    const requestConfig = import_sdk20.ApiUtils.mergeAxiosConfigs(sdkAssembly.axiosInstance.defaults, {
      ...baseURLOverride ? { baseURL: baseURLOverride } : {},
      ...requestConfigOverrides
    });
    axiosInstance = import_sdk20.Network.create(requestConfig);
    for (const interceptor of interceptorsOverride) {
      if (interceptor.type === "request") {
        axiosInstance.interceptors.request.use(interceptor.onRequest, interceptor.onError);
      }
      if (interceptor.type === "response") {
        axiosInstance.interceptors.response.use(interceptor.onSuccess, interceptor.onError);
      }
    }
  }
  async function updateConcurrentRecord_ByKey(key, data) {
    const $ = new ConcurrentRecord$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.updateConcurrentRecord_ByKey(key, data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function updateConcurrentRecord_ByUserId_ByKey(userId, key, data, queryParams) {
    const $ = new ConcurrentRecord$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.updateConcurrentRecord_ByUserId_ByKey(userId, key, data, queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function updatePublicConcurrent_ByUserId_ByKey(userId, key, data, queryParams) {
    const $ = new ConcurrentRecord$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.updatePublicConcurrent_ByUserId_ByKey(userId, key, data, queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  return {
    /**
     * ## Description This endpoints will create new game record or replace the existing game record. **Replace behaviour:** The existing value will be replaced completely with the new value. Example - Existing JSON: `{ &#34;data1&#34;: &#34;value&#34; }` - New JSON: `{ &#34;data2&#34;: &#34;new value&#34; }` - Result: `{ &#34;data2&#34;: &#34;new value&#34; }` ## Restriction This is the restriction of Key Naming for the record: 1. Cannot use **&#34;.&#34;** as the key name - `{ &#34;data.2&#34;: &#34;value&#34; }` 2. Cannot use **&#34;$&#34;** as the prefix in key names - `{ &#34;$data&#34;: &#34;value&#34; }` 3. Cannot use empty string in key names - `{ &#34;&#34;: &#34;value&#34; }` ## Reserved Word Reserved Word List: **__META** The reserved word cannot be used as a field in record value, If still defining the field when creating or updating the record, it will be ignored. ## Optimistic Concurrency Control This endpoint implement optimistic concurrency control to avoid race condition. If the record has been updated since the client fetch it, the server will return HTTP status code 412 (precondition failed) and client need to redo the operation (fetch data and do update). Otherwise, the server will process the request.
     */
    updateConcurrentRecord_ByKey,
    /**
     * ## Description This endpoints will create new player record or replace the existing player record. **Replace behaviour:** The existing value will be replaced completely with the new value. Example - Existing JSON: `{ &#34;data1&#34;: &#34;value&#34; }` - New JSON: `{ &#34;data2&#34;: &#34;new value&#34; }` - Result: `{ &#34;data2&#34;: &#34;new value&#34; }` ## Restriction This is the restriction of Key Naming for the record: 1. Cannot use **&#34;.&#34;** as the key name - `{ &#34;data.2&#34;: &#34;value&#34; }` 2. Cannot use **&#34;$&#34;** as the prefix in key names - `{ &#34;$data&#34;: &#34;value&#34; }` 3. Cannot use empty string in key names - `{ &#34;&#34;: &#34;value&#34; }` ## Reserved Word Reserved Word List: **__META** The reserved word cannot be used as a field in record value, If still defining the field when creating or updating the record, it will be ignored. ## Optimistic Concurrency Control This endpoint implement optimistic concurrency control to avoid race condition. If the record has been updated since the client fetch it, the server will return HTTP status code 412 (precondition failed) and client need to redo the operation (fetch data and do update). Otherwise, the server will process the request.
     */
    updateConcurrentRecord_ByUserId_ByKey,
    /**
     * ## Description This endpoints will create new player public record or replace the existing player public record. **Replace behaviour:** The existing value will be replaced completely with the new value. Example - Existing JSON: `{ &#34;data1&#34;: &#34;value&#34; }` - New JSON: `{ &#34;data2&#34;: &#34;new value&#34; }` - Result: `{ &#34;data2&#34;: &#34;new value&#34; }` ## Restriction This is the restriction of Key Naming for the record: 1. Cannot use **&#34;.&#34;** as the key name - `{ &#34;data.2&#34;: &#34;value&#34; }` 2. Cannot use **&#34;$&#34;** as the prefix in key names - `{ &#34;$data&#34;: &#34;value&#34; }` 3. Cannot use empty string in key names - `{ &#34;&#34;: &#34;value&#34; }` ## Reserved Word Reserved Word List: **__META** The reserved word cannot be used as a field in record value, If still defining the field when creating or updating the record, it will be ignored. ## Optimistic Concurrency Control This endpoint implement optimistic concurrency control to avoid race condition. If the record has been updated since the client fetch it, the server will return HTTP status code 412 (precondition failed) and client need to redo the operation (fetch data and do update). Otherwise, the server will process the request.
     */
    updatePublicConcurrent_ByUserId_ByKey
  };
}

// src/generated-public/queries/ConcurrentRecord.query.ts
var Key_ConcurrentRecord = /* @__PURE__ */ ((Key_ConcurrentRecord2) => {
  Key_ConcurrentRecord2["ConcurrentRecord_ByKey"] = "Cloudsave.ConcurrentRecord.ConcurrentRecord_ByKey";
  Key_ConcurrentRecord2["ConcurrentRecord_ByUserId_ByKey"] = "Cloudsave.ConcurrentRecord.ConcurrentRecord_ByUserId_ByKey";
  Key_ConcurrentRecord2["PublicConcurrent_ByUserId_ByKey"] = "Cloudsave.ConcurrentRecord.PublicConcurrent_ByUserId_ByKey";
  return Key_ConcurrentRecord2;
})(Key_ConcurrentRecord || {});
var useConcurrentRecordApi_UpdateConcurrentRecord_ByKeyMutation = (sdk, options, callback) => {
  const mutationFn = async (input) => {
    const response = await ConcurrentRecordApi(sdk, {
      coreConfig: input.coreConfig,
      axiosConfig: input.axiosConfig
    }).updateConcurrentRecord_ByKey(input.key, input.data);
    callback && callback(response.data);
    return response.data;
  };
  return (0, import_react_query10.useMutation)({
    mutationKey: ["Cloudsave.ConcurrentRecord.ConcurrentRecord_ByKey" /* ConcurrentRecord_ByKey */],
    mutationFn,
    ...options
  });
};
var useConcurrentRecordApi_UpdateConcurrentRecord_ByUserId_ByKeyMutation = (sdk, options, callback) => {
  const mutationFn = async (input) => {
    const response = await ConcurrentRecordApi(sdk, {
      coreConfig: input.coreConfig,
      axiosConfig: input.axiosConfig
    }).updateConcurrentRecord_ByUserId_ByKey(input.userId, input.key, input.data, input.queryParams);
    callback && callback(response.data);
    return response.data;
  };
  return (0, import_react_query10.useMutation)({
    mutationKey: ["Cloudsave.ConcurrentRecord.ConcurrentRecord_ByUserId_ByKey" /* ConcurrentRecord_ByUserId_ByKey */],
    mutationFn,
    ...options
  });
};
var useConcurrentRecordApi_UpdatePublicConcurrent_ByUserId_ByKeyMutation = (sdk, options, callback) => {
  const mutationFn = async (input) => {
    const response = await ConcurrentRecordApi(sdk, {
      coreConfig: input.coreConfig,
      axiosConfig: input.axiosConfig
    }).updatePublicConcurrent_ByUserId_ByKey(input.userId, input.key, input.data, input.queryParams);
    callback && callback(response.data);
    return response.data;
  };
  return (0, import_react_query10.useMutation)({
    mutationKey: ["Cloudsave.ConcurrentRecord.PublicConcurrent_ByUserId_ByKey" /* PublicConcurrent_ByUserId_ByKey */],
    mutationFn,
    ...options
  });
};

// src/generated-public/queries/PublicGameBinaryRecord.query.ts
var import_react_query11 = require("@tanstack/react-query");

// src/generated-public/PublicGameBinaryRecordApi.ts
var import_sdk22 = require("@accelbyte/sdk");

// src/generated-public/endpoints/PublicGameBinaryRecord$.ts
var import_sdk21 = require("@accelbyte/sdk");
var import_zod48 = require("zod");

// src/generated-definitions/BulkGetGameBinaryRecordResponse.ts
var import_zod46 = require("zod");

// src/generated-definitions/GameBinaryRecordResponse.ts
var import_zod45 = require("zod");
var GameBinaryRecordResponse = import_zod45.z.object({
  binary_info: BinaryInfoResponse.nullish(),
  created_at: import_zod45.z.string(),
  key: import_zod45.z.string(),
  namespace: import_zod45.z.string(),
  set_by: import_zod45.z.enum(["CLIENT", "SERVER"]).nullish(),
  tags: import_zod45.z.array(import_zod45.z.string()).nullish(),
  updated_at: import_zod45.z.string()
});

// src/generated-definitions/BulkGetGameBinaryRecordResponse.ts
var BulkGetGameBinaryRecordResponse = import_zod46.z.object({ data: import_zod46.z.array(GameBinaryRecordResponse) });

// src/generated-definitions/ListGameBinaryRecordsResponse.ts
var import_zod47 = require("zod");
var ListGameBinaryRecordsResponse = import_zod47.z.object({ data: import_zod47.z.array(GameBinaryRecordResponse), paging: Pagination });

// src/generated-public/endpoints/PublicGameBinaryRecord$.ts
var PublicGameBinaryRecord$ = class {
  // @ts-ignore
  // prettier-ignore
  constructor(axiosInstance, namespace, useSchemaValidation = true) {
    this.axiosInstance = axiosInstance;
    this.namespace = namespace;
    this.useSchemaValidation = useSchemaValidation;
  }
  /**
   * Retrieve list of binary records by namespace.
   */
  getBinaries(queryParams) {
    const params = { limit: 25, ...queryParams };
    const url = "/cloudsave/v1/namespaces/{namespace}/binaries".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.get(url, { params });
    return import_sdk21.Validate.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      ListGameBinaryRecordsResponse,
      "ListGameBinaryRecordsResponse"
    );
  }
  /**
   * Create a game binary record. Other detail info: `key` should follow these rules: 1. support uppercase and lowercase letters, numbers, and separators **&#34;-&#34;**, **&#34;_&#34;**, **&#34;.&#34;** are allowed 2. begin and end with letters or numbers 3. spaces are not allowed 4. separators must not appears twice in a row Supported file types: jpeg, jpg, png, bmp, gif, mp3, webp, and bin.
   */
  createBinary(data) {
    const params = {};
    const url = "/cloudsave/v1/namespaces/{namespace}/binaries".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.post(url, data, { params });
    return import_sdk21.Validate.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      UploadBinaryRecordResponse,
      "UploadBinaryRecordResponse"
    );
  }
  /**
   * Bulk get game binary records. Maximum key per request 20.
   */
  createBinaryBulk(data) {
    const params = {};
    const url = "/cloudsave/v1/namespaces/{namespace}/binaries/bulk".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.post(url, data, { params });
    return import_sdk21.Validate.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      BulkGetGameBinaryRecordResponse,
      "BulkGetGameBinaryRecordResponse"
    );
  }
  /**
   * Delete a game binary record.
   */
  deleteBinary_ByKey(key) {
    const params = {};
    const url = "/cloudsave/v1/namespaces/{namespace}/binaries/{key}".replace("{namespace}", this.namespace).replace("{key}", key);
    const resultPromise = this.axiosInstance.delete(url, { params });
    return import_sdk21.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, import_zod48.z.unknown(), "z.unknown()");
  }
  /**
   * Get a game binary record by its key.
   */
  getBinary_ByKey(key) {
    const params = {};
    const url = "/cloudsave/v1/namespaces/{namespace}/binaries/{key}".replace("{namespace}", this.namespace).replace("{key}", key);
    const resultPromise = this.axiosInstance.get(url, { params });
    return import_sdk21.Validate.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      GameBinaryRecordResponse,
      "GameBinaryRecordResponse"
    );
  }
  /**
   * Update a game binary record file by its key
   */
  updateBinary_ByKey(key, data) {
    const params = {};
    const url = "/cloudsave/v1/namespaces/{namespace}/binaries/{key}".replace("{namespace}", this.namespace).replace("{key}", key);
    const resultPromise = this.axiosInstance.put(url, data, { params });
    return import_sdk21.Validate.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      GameBinaryRecordResponse,
      "GameBinaryRecordResponse"
    );
  }
  /**
   * Request presigned URL to upload the binary record to s3. Other detail info: Supported file types: jpeg, jpg, png, bmp, gif, mp3, webp, and bin.
   */
  createPresigned_ByKey(key, data) {
    const params = {};
    const url = "/cloudsave/v1/namespaces/{namespace}/binaries/{key}/presigned".replace("{namespace}", this.namespace).replace("{key}", key);
    const resultPromise = this.axiosInstance.post(url, data, { params });
    return import_sdk21.Validate.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      UploadBinaryRecordResponse,
      "UploadBinaryRecordResponse"
    );
  }
};

// src/generated-public/PublicGameBinaryRecordApi.ts
function PublicGameBinaryRecordApi(sdk, args) {
  const sdkAssembly = sdk.assembly();
  const namespace = args?.coreConfig?.namespace ?? sdkAssembly.coreConfig.namespace;
  const useSchemaValidation = args?.coreConfig?.useSchemaValidation ?? sdkAssembly.coreConfig.useSchemaValidation;
  let axiosInstance = sdkAssembly.axiosInstance;
  const requestConfigOverrides = args?.axiosConfig?.request;
  const baseURLOverride = args?.coreConfig?.baseURL;
  const interceptorsOverride = args?.axiosConfig?.interceptors ?? [];
  if (requestConfigOverrides || baseURLOverride || interceptorsOverride.length > 0) {
    const requestConfig = import_sdk22.ApiUtils.mergeAxiosConfigs(sdkAssembly.axiosInstance.defaults, {
      ...baseURLOverride ? { baseURL: baseURLOverride } : {},
      ...requestConfigOverrides
    });
    axiosInstance = import_sdk22.Network.create(requestConfig);
    for (const interceptor of interceptorsOverride) {
      if (interceptor.type === "request") {
        axiosInstance.interceptors.request.use(interceptor.onRequest, interceptor.onError);
      }
      if (interceptor.type === "response") {
        axiosInstance.interceptors.response.use(interceptor.onSuccess, interceptor.onError);
      }
    }
  }
  async function getBinaries(queryParams) {
    const $ = new PublicGameBinaryRecord$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getBinaries(queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function createBinary(data) {
    const $ = new PublicGameBinaryRecord$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.createBinary(data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function createBinaryBulk(data) {
    const $ = new PublicGameBinaryRecord$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.createBinaryBulk(data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function deleteBinary_ByKey(key) {
    const $ = new PublicGameBinaryRecord$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.deleteBinary_ByKey(key);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getBinary_ByKey(key) {
    const $ = new PublicGameBinaryRecord$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getBinary_ByKey(key);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function updateBinary_ByKey(key, data) {
    const $ = new PublicGameBinaryRecord$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.updateBinary_ByKey(key, data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function createPresigned_ByKey(key, data) {
    const $ = new PublicGameBinaryRecord$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.createPresigned_ByKey(key, data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  return {
    /**
     * Retrieve list of binary records by namespace.
     */
    getBinaries,
    /**
     * Create a game binary record. Other detail info: `key` should follow these rules: 1. support uppercase and lowercase letters, numbers, and separators **&#34;-&#34;**, **&#34;_&#34;**, **&#34;.&#34;** are allowed 2. begin and end with letters or numbers 3. spaces are not allowed 4. separators must not appears twice in a row Supported file types: jpeg, jpg, png, bmp, gif, mp3, webp, and bin.
     */
    createBinary,
    /**
     * Bulk get game binary records. Maximum key per request 20.
     */
    createBinaryBulk,
    /**
     * Delete a game binary record.
     */
    deleteBinary_ByKey,
    /**
     * Get a game binary record by its key.
     */
    getBinary_ByKey,
    /**
     * Update a game binary record file by its key
     */
    updateBinary_ByKey,
    /**
     * Request presigned URL to upload the binary record to s3. Other detail info: Supported file types: jpeg, jpg, png, bmp, gif, mp3, webp, and bin.
     */
    createPresigned_ByKey
  };
}

// src/generated-public/queries/PublicGameBinaryRecord.query.ts
var Key_PublicGameBinaryRecord = /* @__PURE__ */ ((Key_PublicGameBinaryRecord2) => {
  Key_PublicGameBinaryRecord2["Binaries"] = "Cloudsave.PublicGameBinaryRecord.Binaries";
  Key_PublicGameBinaryRecord2["Binary"] = "Cloudsave.PublicGameBinaryRecord.Binary";
  Key_PublicGameBinaryRecord2["BinaryBulk"] = "Cloudsave.PublicGameBinaryRecord.BinaryBulk";
  Key_PublicGameBinaryRecord2["Binary_ByKey"] = "Cloudsave.PublicGameBinaryRecord.Binary_ByKey";
  Key_PublicGameBinaryRecord2["Presigned_ByKey"] = "Cloudsave.PublicGameBinaryRecord.Presigned_ByKey";
  return Key_PublicGameBinaryRecord2;
})(Key_PublicGameBinaryRecord || {});
var usePublicGameBinaryRecordApi_GetBinaries = (sdk, input, options, callback) => {
  const queryFn = (sdk2, input2) => async () => {
    const response = await PublicGameBinaryRecordApi(sdk2, { coreConfig: input2.coreConfig, axiosConfig: input2.axiosConfig }).getBinaries(
      input2.queryParams
    );
    callback && callback(response);
    return response.data;
  };
  return (0, import_react_query11.useQuery)({
    queryKey: ["Cloudsave.PublicGameBinaryRecord.Binaries" /* Binaries */, input],
    queryFn: queryFn(sdk, input),
    ...options
  });
};
var usePublicGameBinaryRecordApi_CreateBinaryMutation = (sdk, options, callback) => {
  const mutationFn = async (input) => {
    const response = await PublicGameBinaryRecordApi(sdk, { coreConfig: input.coreConfig, axiosConfig: input.axiosConfig }).createBinary(
      input.data
    );
    callback && callback(response.data);
    return response.data;
  };
  return (0, import_react_query11.useMutation)({
    mutationKey: ["Cloudsave.PublicGameBinaryRecord.Binary" /* Binary */],
    mutationFn,
    ...options
  });
};
var usePublicGameBinaryRecordApi_CreateBinaryBulkMutation = (sdk, options, callback) => {
  const mutationFn = async (input) => {
    const response = await PublicGameBinaryRecordApi(sdk, {
      coreConfig: input.coreConfig,
      axiosConfig: input.axiosConfig
    }).createBinaryBulk(input.data);
    callback && callback(response.data);
    return response.data;
  };
  return (0, import_react_query11.useMutation)({
    mutationKey: ["Cloudsave.PublicGameBinaryRecord.BinaryBulk" /* BinaryBulk */],
    mutationFn,
    ...options
  });
};
var usePublicGameBinaryRecordApi_DeleteBinary_ByKeyMutation = (sdk, options, callback) => {
  const mutationFn = async (input) => {
    const response = await PublicGameBinaryRecordApi(sdk, {
      coreConfig: input.coreConfig,
      axiosConfig: input.axiosConfig
    }).deleteBinary_ByKey(input.key);
    callback && callback(response.data);
    return response.data;
  };
  return (0, import_react_query11.useMutation)({
    mutationKey: ["Cloudsave.PublicGameBinaryRecord.Binary_ByKey" /* Binary_ByKey */],
    mutationFn,
    ...options
  });
};
var usePublicGameBinaryRecordApi_GetBinary_ByKey = (sdk, input, options, callback) => {
  const queryFn = (sdk2, input2) => async () => {
    const response = await PublicGameBinaryRecordApi(sdk2, { coreConfig: input2.coreConfig, axiosConfig: input2.axiosConfig }).getBinary_ByKey(
      input2.key
    );
    callback && callback(response);
    return response.data;
  };
  return (0, import_react_query11.useQuery)({
    queryKey: ["Cloudsave.PublicGameBinaryRecord.Binary_ByKey" /* Binary_ByKey */, input],
    queryFn: queryFn(sdk, input),
    ...options
  });
};
var usePublicGameBinaryRecordApi_UpdateBinary_ByKeyMutation = (sdk, options, callback) => {
  const mutationFn = async (input) => {
    const response = await PublicGameBinaryRecordApi(sdk, {
      coreConfig: input.coreConfig,
      axiosConfig: input.axiosConfig
    }).updateBinary_ByKey(input.key, input.data);
    callback && callback(response.data);
    return response.data;
  };
  return (0, import_react_query11.useMutation)({
    mutationKey: ["Cloudsave.PublicGameBinaryRecord.Binary_ByKey" /* Binary_ByKey */],
    mutationFn,
    ...options
  });
};
var usePublicGameBinaryRecordApi_CreatePresigned_ByKeyMutation = (sdk, options, callback) => {
  const mutationFn = async (input) => {
    const response = await PublicGameBinaryRecordApi(sdk, {
      coreConfig: input.coreConfig,
      axiosConfig: input.axiosConfig
    }).createPresigned_ByKey(input.key, input.data);
    callback && callback(response.data);
    return response.data;
  };
  return (0, import_react_query11.useMutation)({
    mutationKey: ["Cloudsave.PublicGameBinaryRecord.Presigned_ByKey" /* Presigned_ByKey */],
    mutationFn,
    ...options
  });
};

// src/generated-public/queries/PublicGameRecord.query.ts
var import_react_query12 = require("@tanstack/react-query");

// src/generated-public/PublicGameRecordApi.ts
var import_sdk24 = require("@accelbyte/sdk");

// src/generated-public/endpoints/PublicGameRecord$.ts
var import_sdk23 = require("@accelbyte/sdk");
var import_zod51 = require("zod");

// src/generated-definitions/BulkGetGameRecordResponse.ts
var import_zod50 = require("zod");

// src/generated-definitions/GameRecordResponse.ts
var import_zod49 = require("zod");
var GameRecordResponse = import_zod49.z.object({
  created_at: import_zod49.z.string(),
  key: import_zod49.z.string(),
  namespace: import_zod49.z.string(),
  set_by: import_zod49.z.enum(["CLIENT", "SERVER"]).nullish(),
  tags: import_zod49.z.array(import_zod49.z.string()).nullish(),
  updated_at: import_zod49.z.string(),
  value: import_zod49.z.record(import_zod49.z.any())
});

// src/generated-definitions/BulkGetGameRecordResponse.ts
var BulkGetGameRecordResponse = import_zod50.z.object({ data: import_zod50.z.array(GameRecordResponse) });

// src/generated-public/endpoints/PublicGameRecord$.ts
var PublicGameRecord$ = class {
  // @ts-ignore
  // prettier-ignore
  constructor(axiosInstance, namespace, useSchemaValidation = true) {
    this.axiosInstance = axiosInstance;
    this.namespace = namespace;
    this.useSchemaValidation = useSchemaValidation;
  }
  /**
   * Bulk get game records. Maximum key per request 20.
   */
  fetchRecordBulk(data) {
    const params = {};
    const url = "/cloudsave/v1/namespaces/{namespace}/records/bulk".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.post(url, data, { params });
    return import_sdk23.Validate.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      BulkGetGameRecordResponse,
      "BulkGetGameRecordResponse"
    );
  }
  /**
   * Delete records by its key
   */
  deleteRecord_ByKey(key) {
    const params = {};
    const url = "/cloudsave/v1/namespaces/{namespace}/records/{key}".replace("{namespace}", this.namespace).replace("{key}", key);
    const resultPromise = this.axiosInstance.delete(url, { params });
    return import_sdk23.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, import_zod51.z.unknown(), "z.unknown()");
  }
  /**
   * Get game record by its key.
   */
  getRecord_ByKey(key) {
    const params = {};
    const url = "/cloudsave/v1/namespaces/{namespace}/records/{key}".replace("{namespace}", this.namespace).replace("{key}", key);
    const resultPromise = this.axiosInstance.get(url, { params });
    return import_sdk23.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, GameRecordResponse, "GameRecordResponse");
  }
  /**
   * ## Description This endpoints will create new game record or append the existing game record. **Append example:** Example 1 - Existing JSON: `{ &#34;data1&#34;: &#34;value&#34; }` - New JSON: `{ &#34;data2&#34;: &#34;new value&#34; }` - Result: `{ &#34;data1&#34;: &#34;value&#34;, &#34;data2&#34;: &#34;new value&#34; }` Example 2 - Existing JSON: `{ &#34;data1&#34;: { &#34;data2&#34;: &#34;value&#34; }` - New JSON: `{ &#34;data1&#34;: { &#34;data3&#34;: &#34;new value&#34; }` - Result: `{ &#34;data1&#34;: { &#34;data2&#34;: &#34;value&#34;, &#34;data3&#34;: &#34;new value&#34; }` ## Restriction This is the restriction of Key Naming for the record: 1. Cannot use **&#34;.&#34;** as the key name - `{ &#34;data.2&#34;: &#34;value&#34; }` 2. Cannot use **&#34;$&#34;** as the prefix in key names - `{ &#34;$data&#34;: &#34;value&#34; }` 3. Cannot use empty string in key names - `{ &#34;&#34;: &#34;value&#34; }` ## Reserved Word Reserved Word List: **__META** The reserved word cannot be used as a field in record value, If still defining the field when creating or updating the record, it will be ignored.
   */
  createRecord_ByKey(key, data) {
    const params = {};
    const url = "/cloudsave/v1/namespaces/{namespace}/records/{key}".replace("{namespace}", this.namespace).replace("{key}", key);
    const resultPromise = this.axiosInstance.post(url, data, { params });
    return import_sdk23.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, GameRecordResponse, "GameRecordResponse");
  }
  /**
   * ## Description This endpoints will create new game record or replace the existing game record. **Replace behaviour:** The existing value will be replaced completely with the new value. Example - Existing JSON: `{ &#34;data1&#34;: &#34;value&#34; }` - New JSON: `{ &#34;data2&#34;: &#34;new value&#34; }` - Result: `{ &#34;data2&#34;: &#34;new value&#34; }` ## Restriction This is the restriction of Key Naming for the record: 1. Cannot use **&#34;.&#34;** as the key name - `{ &#34;data.2&#34;: &#34;value&#34; }` 2. Cannot use **&#34;$&#34;** as the prefix in key names - `{ &#34;$data&#34;: &#34;value&#34; }` 3. Cannot use empty string in key names - `{ &#34;&#34;: &#34;value&#34; }` ## Reserved Word Reserved Word List: **__META** The reserved word cannot be used as a field in record value, If still defining the field when creating or updating the record, it will be ignored.
   */
  updateRecord_ByKey(key, data) {
    const params = {};
    const url = "/cloudsave/v1/namespaces/{namespace}/records/{key}".replace("{namespace}", this.namespace).replace("{key}", key);
    const resultPromise = this.axiosInstance.put(url, data, { params });
    return import_sdk23.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, GameRecordResponse, "GameRecordResponse");
  }
};

// src/generated-public/PublicGameRecordApi.ts
function PublicGameRecordApi(sdk, args) {
  const sdkAssembly = sdk.assembly();
  const namespace = args?.coreConfig?.namespace ?? sdkAssembly.coreConfig.namespace;
  const useSchemaValidation = args?.coreConfig?.useSchemaValidation ?? sdkAssembly.coreConfig.useSchemaValidation;
  let axiosInstance = sdkAssembly.axiosInstance;
  const requestConfigOverrides = args?.axiosConfig?.request;
  const baseURLOverride = args?.coreConfig?.baseURL;
  const interceptorsOverride = args?.axiosConfig?.interceptors ?? [];
  if (requestConfigOverrides || baseURLOverride || interceptorsOverride.length > 0) {
    const requestConfig = import_sdk24.ApiUtils.mergeAxiosConfigs(sdkAssembly.axiosInstance.defaults, {
      ...baseURLOverride ? { baseURL: baseURLOverride } : {},
      ...requestConfigOverrides
    });
    axiosInstance = import_sdk24.Network.create(requestConfig);
    for (const interceptor of interceptorsOverride) {
      if (interceptor.type === "request") {
        axiosInstance.interceptors.request.use(interceptor.onRequest, interceptor.onError);
      }
      if (interceptor.type === "response") {
        axiosInstance.interceptors.response.use(interceptor.onSuccess, interceptor.onError);
      }
    }
  }
  async function fetchRecordBulk(data) {
    const $ = new PublicGameRecord$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.fetchRecordBulk(data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function deleteRecord_ByKey(key) {
    const $ = new PublicGameRecord$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.deleteRecord_ByKey(key);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getRecord_ByKey(key) {
    const $ = new PublicGameRecord$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getRecord_ByKey(key);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function createRecord_ByKey(key, data) {
    const $ = new PublicGameRecord$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.createRecord_ByKey(key, data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function updateRecord_ByKey(key, data) {
    const $ = new PublicGameRecord$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.updateRecord_ByKey(key, data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  return {
    /**
     * Bulk get game records. Maximum key per request 20.
     */
    fetchRecordBulk,
    /**
     * Delete records by its key
     */
    deleteRecord_ByKey,
    /**
     * Get game record by its key.
     */
    getRecord_ByKey,
    /**
     * ## Description This endpoints will create new game record or append the existing game record. **Append example:** Example 1 - Existing JSON: `{ &#34;data1&#34;: &#34;value&#34; }` - New JSON: `{ &#34;data2&#34;: &#34;new value&#34; }` - Result: `{ &#34;data1&#34;: &#34;value&#34;, &#34;data2&#34;: &#34;new value&#34; }` Example 2 - Existing JSON: `{ &#34;data1&#34;: { &#34;data2&#34;: &#34;value&#34; }` - New JSON: `{ &#34;data1&#34;: { &#34;data3&#34;: &#34;new value&#34; }` - Result: `{ &#34;data1&#34;: { &#34;data2&#34;: &#34;value&#34;, &#34;data3&#34;: &#34;new value&#34; }` ## Restriction This is the restriction of Key Naming for the record: 1. Cannot use **&#34;.&#34;** as the key name - `{ &#34;data.2&#34;: &#34;value&#34; }` 2. Cannot use **&#34;$&#34;** as the prefix in key names - `{ &#34;$data&#34;: &#34;value&#34; }` 3. Cannot use empty string in key names - `{ &#34;&#34;: &#34;value&#34; }` ## Reserved Word Reserved Word List: **__META** The reserved word cannot be used as a field in record value, If still defining the field when creating or updating the record, it will be ignored.
     */
    createRecord_ByKey,
    /**
     * ## Description This endpoints will create new game record or replace the existing game record. **Replace behaviour:** The existing value will be replaced completely with the new value. Example - Existing JSON: `{ &#34;data1&#34;: &#34;value&#34; }` - New JSON: `{ &#34;data2&#34;: &#34;new value&#34; }` - Result: `{ &#34;data2&#34;: &#34;new value&#34; }` ## Restriction This is the restriction of Key Naming for the record: 1. Cannot use **&#34;.&#34;** as the key name - `{ &#34;data.2&#34;: &#34;value&#34; }` 2. Cannot use **&#34;$&#34;** as the prefix in key names - `{ &#34;$data&#34;: &#34;value&#34; }` 3. Cannot use empty string in key names - `{ &#34;&#34;: &#34;value&#34; }` ## Reserved Word Reserved Word List: **__META** The reserved word cannot be used as a field in record value, If still defining the field when creating or updating the record, it will be ignored.
     */
    updateRecord_ByKey
  };
}

// src/generated-public/queries/PublicGameRecord.query.ts
var Key_PublicGameRecord = /* @__PURE__ */ ((Key_PublicGameRecord2) => {
  Key_PublicGameRecord2["RecordBulk"] = "Cloudsave.PublicGameRecord.RecordBulk";
  Key_PublicGameRecord2["Record_ByKey"] = "Cloudsave.PublicGameRecord.Record_ByKey";
  return Key_PublicGameRecord2;
})(Key_PublicGameRecord || {});
var usePublicGameRecordApi_FetchRecordBulk = (sdk, input, options, callback) => {
  const queryFn = (sdk2, input2) => async () => {
    const response = await PublicGameRecordApi(sdk2, { coreConfig: input2.coreConfig, axiosConfig: input2.axiosConfig }).fetchRecordBulk(
      input2.data
    );
    callback && callback(response);
    return response.data;
  };
  return (0, import_react_query12.useQuery)({
    queryKey: ["Cloudsave.PublicGameRecord.RecordBulk" /* RecordBulk */, input],
    queryFn: queryFn(sdk, input),
    ...options
  });
};
var usePublicGameRecordApi_DeleteRecord_ByKeyMutation = (sdk, options, callback) => {
  const mutationFn = async (input) => {
    const response = await PublicGameRecordApi(sdk, { coreConfig: input.coreConfig, axiosConfig: input.axiosConfig }).deleteRecord_ByKey(
      input.key
    );
    callback && callback(response.data);
    return response.data;
  };
  return (0, import_react_query12.useMutation)({
    mutationKey: ["Cloudsave.PublicGameRecord.Record_ByKey" /* Record_ByKey */],
    mutationFn,
    ...options
  });
};
var usePublicGameRecordApi_GetRecord_ByKey = (sdk, input, options, callback) => {
  const queryFn = (sdk2, input2) => async () => {
    const response = await PublicGameRecordApi(sdk2, { coreConfig: input2.coreConfig, axiosConfig: input2.axiosConfig }).getRecord_ByKey(
      input2.key
    );
    callback && callback(response);
    return response.data;
  };
  return (0, import_react_query12.useQuery)({
    queryKey: ["Cloudsave.PublicGameRecord.Record_ByKey" /* Record_ByKey */, input],
    queryFn: queryFn(sdk, input),
    ...options
  });
};
var usePublicGameRecordApi_CreateRecord_ByKeyMutation = (sdk, options, callback) => {
  const mutationFn = async (input) => {
    const response = await PublicGameRecordApi(sdk, { coreConfig: input.coreConfig, axiosConfig: input.axiosConfig }).createRecord_ByKey(
      input.key,
      input.data
    );
    callback && callback(response.data);
    return response.data;
  };
  return (0, import_react_query12.useMutation)({
    mutationKey: ["Cloudsave.PublicGameRecord.Record_ByKey" /* Record_ByKey */],
    mutationFn,
    ...options
  });
};
var usePublicGameRecordApi_UpdateRecord_ByKeyMutation = (sdk, options, callback) => {
  const mutationFn = async (input) => {
    const response = await PublicGameRecordApi(sdk, { coreConfig: input.coreConfig, axiosConfig: input.axiosConfig }).updateRecord_ByKey(
      input.key,
      input.data
    );
    callback && callback(response.data);
    return response.data;
  };
  return (0, import_react_query12.useMutation)({
    mutationKey: ["Cloudsave.PublicGameRecord.Record_ByKey" /* Record_ByKey */],
    mutationFn,
    ...options
  });
};

// src/generated-public/queries/PublicPlayerBinaryRecord.query.ts
var import_react_query13 = require("@tanstack/react-query");

// src/generated-public/PublicPlayerBinaryRecordApi.ts
var import_sdk26 = require("@accelbyte/sdk");

// src/generated-public/endpoints/PublicPlayerBinaryRecord$.ts
var import_sdk25 = require("@accelbyte/sdk");
var import_zod53 = require("zod");

// src/generated-definitions/BulkGetPlayerBinaryRecordResponse.ts
var import_zod52 = require("zod");
var BulkGetPlayerBinaryRecordResponse = import_zod52.z.object({ data: import_zod52.z.array(PlayerBinaryRecordResponse) });

// src/generated-public/endpoints/PublicPlayerBinaryRecord$.ts
var PublicPlayerBinaryRecord$ = class {
  // @ts-ignore
  // prettier-ignore
  constructor(axiosInstance, namespace, useSchemaValidation = true) {
    this.axiosInstance = axiosInstance;
    this.namespace = namespace;
    this.useSchemaValidation = useSchemaValidation;
  }
  /**
   * Retrieve list of my binary records by namespace.
   */
  getUsersMeBinaries(queryParams) {
    const params = { limit: 25, ...queryParams };
    const url = "/cloudsave/v1/namespaces/{namespace}/users/me/binaries".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.get(url, { params });
    return import_sdk25.Validate.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      ListPlayerBinaryRecordsResponse,
      "ListPlayerBinaryRecordsResponse"
    );
  }
  /**
   * Retrieve player record key and payload in bulk under given namespace. Maximum bulk key limit per request 20
   */
  createUserMeBinaryBulk(data) {
    const params = {};
    const url = "/cloudsave/v1/namespaces/{namespace}/users/me/binaries/bulk".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.post(url, data, { params });
    return import_sdk25.Validate.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      BulkGetPlayerBinaryRecordResponse,
      "BulkGetPlayerBinaryRecordResponse"
    );
  }
  /**
   * Create a player binary record. Other detail info: `key` should follow these rules: 1. support uppercase and lowercase letters, numbers, and separators **&#34;-&#34;**, **&#34;_&#34;**, **&#34;.&#34;** are allowed 2. begin and end with letters or numbers 3. spaces are not allowed 4. separators must not appears twice in a row Supported file types: jpeg, jpg, png, bmp, gif, mp3, webp, and bin.
   */
  createBinary_ByUserId(userId, data) {
    const params = {};
    const url = "/cloudsave/v1/namespaces/{namespace}/users/{userId}/binaries".replace("{namespace}", this.namespace).replace("{userId}", userId);
    const resultPromise = this.axiosInstance.post(url, data, { params });
    return import_sdk25.Validate.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      UploadBinaryRecordResponse,
      "UploadBinaryRecordResponse"
    );
  }
  /**
   * Delete a player binary record. Only player who own the record can delete it
   */
  deleteBinary_ByUserId_ByKey(userId, key) {
    const params = {};
    const url = "/cloudsave/v1/namespaces/{namespace}/users/{userId}/binaries/{key}".replace("{namespace}", this.namespace).replace("{userId}", userId).replace("{key}", key);
    const resultPromise = this.axiosInstance.delete(url, { params });
    return import_sdk25.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, import_zod53.z.unknown(), "z.unknown()");
  }
  /**
   * Get a player binary record by its key. **Private Record**: Only user who own the record could retrieve it.
   */
  getBinary_ByUserId_ByKey(userId, key) {
    const params = {};
    const url = "/cloudsave/v1/namespaces/{namespace}/users/{userId}/binaries/{key}".replace("{namespace}", this.namespace).replace("{userId}", userId).replace("{key}", key);
    const resultPromise = this.axiosInstance.get(url, { params });
    return import_sdk25.Validate.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      PlayerBinaryRecordResponse,
      "PlayerBinaryRecordResponse"
    );
  }
  /**
   * Update a player binary record file by its key
   */
  updateBinary_ByUserId_ByKey(userId, key, data) {
    const params = {};
    const url = "/cloudsave/v1/namespaces/{namespace}/users/{userId}/binaries/{key}".replace("{namespace}", this.namespace).replace("{userId}", userId).replace("{key}", key);
    const resultPromise = this.axiosInstance.put(url, data, { params });
    return import_sdk25.Validate.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      PlayerBinaryRecordResponse,
      "PlayerBinaryRecordResponse"
    );
  }
  /**
   * Retrieve list of other player public binary records under given namespace.
   */
  getBinariesPublic_ByUserId(userId, queryParams) {
    const params = { limit: 25, ...queryParams };
    const url = "/cloudsave/v1/namespaces/{namespace}/users/{userId}/binaries/public".replace("{namespace}", this.namespace).replace("{userId}", userId);
    const resultPromise = this.axiosInstance.get(url, { params });
    return import_sdk25.Validate.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      ListPlayerBinaryRecordsResponse,
      "ListPlayerBinaryRecordsResponse"
    );
  }
  /**
   * Bulk get other player&#39;s public binary record by userIds, max allowed 20 at a time. Only record with `isPublic=true` can be retrieved using this endpoint.
   */
  fetchPublicBulkUser_ByKey(key, data) {
    const params = {};
    const url = "/cloudsave/v1/namespaces/{namespace}/users/bulk/binaries/{key}/public".replace("{namespace}", this.namespace).replace("{key}", key);
    const resultPromise = this.axiosInstance.post(url, data, { params });
    return import_sdk25.Validate.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      BulkGetPlayerBinaryRecordResponse,
      "BulkGetPlayerBinaryRecordResponse"
    );
  }
  /**
   * Retrieve other player public binary record in bulk under given namespace. Maximum bulk key limit per request 20
   */
  fetchBinaryBulk_ByUserId(userId, data) {
    const params = {};
    const url = "/cloudsave/v1/namespaces/{namespace}/users/{userId}/binaries/public/bulk".replace("{namespace}", this.namespace).replace("{userId}", userId);
    const resultPromise = this.axiosInstance.post(url, data, { params });
    return import_sdk25.Validate.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      BulkGetPlayerBinaryRecordResponse,
      "BulkGetPlayerBinaryRecordResponse"
    );
  }
  /**
   * Get other player&#39;s public binary record. Only record with `isPublic=true` can be retrieved using this endpoint.
   */
  getPublic_ByUserId_ByKey(userId, key) {
    const params = {};
    const url = "/cloudsave/v1/namespaces/{namespace}/users/{userId}/binaries/{key}/public".replace("{namespace}", this.namespace).replace("{userId}", userId).replace("{key}", key);
    const resultPromise = this.axiosInstance.get(url, { params });
    return import_sdk25.Validate.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      PlayerBinaryRecordResponse,
      "PlayerBinaryRecordResponse"
    );
  }
  /**
   * Update a player binary record metadata by its key
   */
  updateMetadata_ByUserId_ByKey(userId, key, data) {
    const params = {};
    const url = "/cloudsave/v1/namespaces/{namespace}/users/{userId}/binaries/{key}/metadata".replace("{namespace}", this.namespace).replace("{userId}", userId).replace("{key}", key);
    const resultPromise = this.axiosInstance.put(url, data, { params });
    return import_sdk25.Validate.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      PlayerBinaryRecordResponse,
      "PlayerBinaryRecordResponse"
    );
  }
  /**
   * Request presigned URL to upload the binary record to s3. Other detail info: Supported file types: jpeg, jpg, png, bmp, gif, mp3, webp, and bin.
   */
  createPresigned_ByUserId_ByKey(userId, key, data) {
    const params = {};
    const url = "/cloudsave/v1/namespaces/{namespace}/users/{userId}/binaries/{key}/presigned".replace("{namespace}", this.namespace).replace("{userId}", userId).replace("{key}", key);
    const resultPromise = this.axiosInstance.post(url, data, { params });
    return import_sdk25.Validate.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      UploadBinaryRecordResponse,
      "UploadBinaryRecordResponse"
    );
  }
};

// src/generated-public/PublicPlayerBinaryRecordApi.ts
function PublicPlayerBinaryRecordApi(sdk, args) {
  const sdkAssembly = sdk.assembly();
  const namespace = args?.coreConfig?.namespace ?? sdkAssembly.coreConfig.namespace;
  const useSchemaValidation = args?.coreConfig?.useSchemaValidation ?? sdkAssembly.coreConfig.useSchemaValidation;
  let axiosInstance = sdkAssembly.axiosInstance;
  const requestConfigOverrides = args?.axiosConfig?.request;
  const baseURLOverride = args?.coreConfig?.baseURL;
  const interceptorsOverride = args?.axiosConfig?.interceptors ?? [];
  if (requestConfigOverrides || baseURLOverride || interceptorsOverride.length > 0) {
    const requestConfig = import_sdk26.ApiUtils.mergeAxiosConfigs(sdkAssembly.axiosInstance.defaults, {
      ...baseURLOverride ? { baseURL: baseURLOverride } : {},
      ...requestConfigOverrides
    });
    axiosInstance = import_sdk26.Network.create(requestConfig);
    for (const interceptor of interceptorsOverride) {
      if (interceptor.type === "request") {
        axiosInstance.interceptors.request.use(interceptor.onRequest, interceptor.onError);
      }
      if (interceptor.type === "response") {
        axiosInstance.interceptors.response.use(interceptor.onSuccess, interceptor.onError);
      }
    }
  }
  async function getUsersMeBinaries(queryParams) {
    const $ = new PublicPlayerBinaryRecord$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getUsersMeBinaries(queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function createUserMeBinaryBulk(data) {
    const $ = new PublicPlayerBinaryRecord$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.createUserMeBinaryBulk(data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function createBinary_ByUserId(userId, data) {
    const $ = new PublicPlayerBinaryRecord$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.createBinary_ByUserId(userId, data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function deleteBinary_ByUserId_ByKey(userId, key) {
    const $ = new PublicPlayerBinaryRecord$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.deleteBinary_ByUserId_ByKey(userId, key);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getBinary_ByUserId_ByKey(userId, key) {
    const $ = new PublicPlayerBinaryRecord$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getBinary_ByUserId_ByKey(userId, key);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function updateBinary_ByUserId_ByKey(userId, key, data) {
    const $ = new PublicPlayerBinaryRecord$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.updateBinary_ByUserId_ByKey(userId, key, data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getBinariesPublic_ByUserId(userId, queryParams) {
    const $ = new PublicPlayerBinaryRecord$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getBinariesPublic_ByUserId(userId, queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function fetchPublicBulkUser_ByKey(key, data) {
    const $ = new PublicPlayerBinaryRecord$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.fetchPublicBulkUser_ByKey(key, data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function fetchBinaryBulk_ByUserId(userId, data) {
    const $ = new PublicPlayerBinaryRecord$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.fetchBinaryBulk_ByUserId(userId, data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getPublic_ByUserId_ByKey(userId, key) {
    const $ = new PublicPlayerBinaryRecord$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getPublic_ByUserId_ByKey(userId, key);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function updateMetadata_ByUserId_ByKey(userId, key, data) {
    const $ = new PublicPlayerBinaryRecord$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.updateMetadata_ByUserId_ByKey(userId, key, data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function createPresigned_ByUserId_ByKey(userId, key, data) {
    const $ = new PublicPlayerBinaryRecord$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.createPresigned_ByUserId_ByKey(userId, key, data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  return {
    /**
     * Retrieve list of my binary records by namespace.
     */
    getUsersMeBinaries,
    /**
     * Retrieve player record key and payload in bulk under given namespace. Maximum bulk key limit per request 20
     */
    createUserMeBinaryBulk,
    /**
     * Create a player binary record. Other detail info: `key` should follow these rules: 1. support uppercase and lowercase letters, numbers, and separators **&#34;-&#34;**, **&#34;_&#34;**, **&#34;.&#34;** are allowed 2. begin and end with letters or numbers 3. spaces are not allowed 4. separators must not appears twice in a row Supported file types: jpeg, jpg, png, bmp, gif, mp3, webp, and bin.
     */
    createBinary_ByUserId,
    /**
     * Delete a player binary record. Only player who own the record can delete it
     */
    deleteBinary_ByUserId_ByKey,
    /**
     * Get a player binary record by its key. **Private Record**: Only user who own the record could retrieve it.
     */
    getBinary_ByUserId_ByKey,
    /**
     * Update a player binary record file by its key
     */
    updateBinary_ByUserId_ByKey,
    /**
     * Retrieve list of other player public binary records under given namespace.
     */
    getBinariesPublic_ByUserId,
    /**
     * Bulk get other player&#39;s public binary record by userIds, max allowed 20 at a time. Only record with `isPublic=true` can be retrieved using this endpoint.
     */
    fetchPublicBulkUser_ByKey,
    /**
     * Retrieve other player public binary record in bulk under given namespace. Maximum bulk key limit per request 20
     */
    fetchBinaryBulk_ByUserId,
    /**
     * Get other player&#39;s public binary record. Only record with `isPublic=true` can be retrieved using this endpoint.
     */
    getPublic_ByUserId_ByKey,
    /**
     * Update a player binary record metadata by its key
     */
    updateMetadata_ByUserId_ByKey,
    /**
     * Request presigned URL to upload the binary record to s3. Other detail info: Supported file types: jpeg, jpg, png, bmp, gif, mp3, webp, and bin.
     */
    createPresigned_ByUserId_ByKey
  };
}

// src/generated-public/queries/PublicPlayerBinaryRecord.query.ts
var Key_PublicPlayerBinaryRecord = /* @__PURE__ */ ((Key_PublicPlayerBinaryRecord2) => {
  Key_PublicPlayerBinaryRecord2["UsersMeBinaries"] = "Cloudsave.PublicPlayerBinaryRecord.UsersMeBinaries";
  Key_PublicPlayerBinaryRecord2["UserMeBinaryBulk"] = "Cloudsave.PublicPlayerBinaryRecord.UserMeBinaryBulk";
  Key_PublicPlayerBinaryRecord2["Binary_ByUserId"] = "Cloudsave.PublicPlayerBinaryRecord.Binary_ByUserId";
  Key_PublicPlayerBinaryRecord2["Binary_ByUserId_ByKey"] = "Cloudsave.PublicPlayerBinaryRecord.Binary_ByUserId_ByKey";
  Key_PublicPlayerBinaryRecord2["BinariesPublic_ByUserId"] = "Cloudsave.PublicPlayerBinaryRecord.BinariesPublic_ByUserId";
  Key_PublicPlayerBinaryRecord2["PublicBulkUser_ByKey"] = "Cloudsave.PublicPlayerBinaryRecord.PublicBulkUser_ByKey";
  Key_PublicPlayerBinaryRecord2["BinaryBulk_ByUserId"] = "Cloudsave.PublicPlayerBinaryRecord.BinaryBulk_ByUserId";
  Key_PublicPlayerBinaryRecord2["Public_ByUserId_ByKey"] = "Cloudsave.PublicPlayerBinaryRecord.Public_ByUserId_ByKey";
  Key_PublicPlayerBinaryRecord2["Metadata_ByUserId_ByKey"] = "Cloudsave.PublicPlayerBinaryRecord.Metadata_ByUserId_ByKey";
  Key_PublicPlayerBinaryRecord2["Presigned_ByUserId_ByKey"] = "Cloudsave.PublicPlayerBinaryRecord.Presigned_ByUserId_ByKey";
  return Key_PublicPlayerBinaryRecord2;
})(Key_PublicPlayerBinaryRecord || {});
var usePublicPlayerBinaryRecordApi_GetUsersMeBinaries = (sdk, input, options, callback) => {
  const queryFn = (sdk2, input2) => async () => {
    const response = await PublicPlayerBinaryRecordApi(sdk2, {
      coreConfig: input2.coreConfig,
      axiosConfig: input2.axiosConfig
    }).getUsersMeBinaries(input2.queryParams);
    callback && callback(response);
    return response.data;
  };
  return (0, import_react_query13.useQuery)({
    queryKey: ["Cloudsave.PublicPlayerBinaryRecord.UsersMeBinaries" /* UsersMeBinaries */, input],
    queryFn: queryFn(sdk, input),
    ...options
  });
};
var usePublicPlayerBinaryRecordApi_CreateUserMeBinaryBulkMutation = (sdk, options, callback) => {
  const mutationFn = async (input) => {
    const response = await PublicPlayerBinaryRecordApi(sdk, {
      coreConfig: input.coreConfig,
      axiosConfig: input.axiosConfig
    }).createUserMeBinaryBulk(input.data);
    callback && callback(response.data);
    return response.data;
  };
  return (0, import_react_query13.useMutation)({
    mutationKey: ["Cloudsave.PublicPlayerBinaryRecord.UserMeBinaryBulk" /* UserMeBinaryBulk */],
    mutationFn,
    ...options
  });
};
var usePublicPlayerBinaryRecordApi_CreateBinary_ByUserIdMutation = (sdk, options, callback) => {
  const mutationFn = async (input) => {
    const response = await PublicPlayerBinaryRecordApi(sdk, {
      coreConfig: input.coreConfig,
      axiosConfig: input.axiosConfig
    }).createBinary_ByUserId(input.userId, input.data);
    callback && callback(response.data);
    return response.data;
  };
  return (0, import_react_query13.useMutation)({
    mutationKey: ["Cloudsave.PublicPlayerBinaryRecord.Binary_ByUserId" /* Binary_ByUserId */],
    mutationFn,
    ...options
  });
};
var usePublicPlayerBinaryRecordApi_DeleteBinary_ByUserId_ByKeyMutation = (sdk, options, callback) => {
  const mutationFn = async (input) => {
    const response = await PublicPlayerBinaryRecordApi(sdk, {
      coreConfig: input.coreConfig,
      axiosConfig: input.axiosConfig
    }).deleteBinary_ByUserId_ByKey(input.userId, input.key);
    callback && callback(response.data);
    return response.data;
  };
  return (0, import_react_query13.useMutation)({
    mutationKey: ["Cloudsave.PublicPlayerBinaryRecord.Binary_ByUserId_ByKey" /* Binary_ByUserId_ByKey */],
    mutationFn,
    ...options
  });
};
var usePublicPlayerBinaryRecordApi_GetBinary_ByUserId_ByKey = (sdk, input, options, callback) => {
  const queryFn = (sdk2, input2) => async () => {
    const response = await PublicPlayerBinaryRecordApi(sdk2, {
      coreConfig: input2.coreConfig,
      axiosConfig: input2.axiosConfig
    }).getBinary_ByUserId_ByKey(input2.userId, input2.key);
    callback && callback(response);
    return response.data;
  };
  return (0, import_react_query13.useQuery)({
    queryKey: ["Cloudsave.PublicPlayerBinaryRecord.Binary_ByUserId_ByKey" /* Binary_ByUserId_ByKey */, input],
    queryFn: queryFn(sdk, input),
    ...options
  });
};
var usePublicPlayerBinaryRecordApi_UpdateBinary_ByUserId_ByKeyMutation = (sdk, options, callback) => {
  const mutationFn = async (input) => {
    const response = await PublicPlayerBinaryRecordApi(sdk, {
      coreConfig: input.coreConfig,
      axiosConfig: input.axiosConfig
    }).updateBinary_ByUserId_ByKey(input.userId, input.key, input.data);
    callback && callback(response.data);
    return response.data;
  };
  return (0, import_react_query13.useMutation)({
    mutationKey: ["Cloudsave.PublicPlayerBinaryRecord.Binary_ByUserId_ByKey" /* Binary_ByUserId_ByKey */],
    mutationFn,
    ...options
  });
};
var usePublicPlayerBinaryRecordApi_GetBinariesPublic_ByUserId = (sdk, input, options, callback) => {
  const queryFn = (sdk2, input2) => async () => {
    const response = await PublicPlayerBinaryRecordApi(sdk2, {
      coreConfig: input2.coreConfig,
      axiosConfig: input2.axiosConfig
    }).getBinariesPublic_ByUserId(input2.userId, input2.queryParams);
    callback && callback(response);
    return response.data;
  };
  return (0, import_react_query13.useQuery)({
    queryKey: ["Cloudsave.PublicPlayerBinaryRecord.BinariesPublic_ByUserId" /* BinariesPublic_ByUserId */, input],
    queryFn: queryFn(sdk, input),
    ...options
  });
};
var usePublicPlayerBinaryRecordApi_FetchPublicBulkUser_ByKey = (sdk, input, options, callback) => {
  const queryFn = (sdk2, input2) => async () => {
    const response = await PublicPlayerBinaryRecordApi(sdk2, {
      coreConfig: input2.coreConfig,
      axiosConfig: input2.axiosConfig
    }).fetchPublicBulkUser_ByKey(input2.key, input2.data);
    callback && callback(response);
    return response.data;
  };
  return (0, import_react_query13.useQuery)({
    queryKey: ["Cloudsave.PublicPlayerBinaryRecord.PublicBulkUser_ByKey" /* PublicBulkUser_ByKey */, input],
    queryFn: queryFn(sdk, input),
    ...options
  });
};
var usePublicPlayerBinaryRecordApi_FetchBinaryBulk_ByUserId = (sdk, input, options, callback) => {
  const queryFn = (sdk2, input2) => async () => {
    const response = await PublicPlayerBinaryRecordApi(sdk2, {
      coreConfig: input2.coreConfig,
      axiosConfig: input2.axiosConfig
    }).fetchBinaryBulk_ByUserId(input2.userId, input2.data);
    callback && callback(response);
    return response.data;
  };
  return (0, import_react_query13.useQuery)({
    queryKey: ["Cloudsave.PublicPlayerBinaryRecord.BinaryBulk_ByUserId" /* BinaryBulk_ByUserId */, input],
    queryFn: queryFn(sdk, input),
    ...options
  });
};
var usePublicPlayerBinaryRecordApi_GetPublic_ByUserId_ByKey = (sdk, input, options, callback) => {
  const queryFn = (sdk2, input2) => async () => {
    const response = await PublicPlayerBinaryRecordApi(sdk2, {
      coreConfig: input2.coreConfig,
      axiosConfig: input2.axiosConfig
    }).getPublic_ByUserId_ByKey(input2.userId, input2.key);
    callback && callback(response);
    return response.data;
  };
  return (0, import_react_query13.useQuery)({
    queryKey: ["Cloudsave.PublicPlayerBinaryRecord.Public_ByUserId_ByKey" /* Public_ByUserId_ByKey */, input],
    queryFn: queryFn(sdk, input),
    ...options
  });
};
var usePublicPlayerBinaryRecordApi_UpdateMetadata_ByUserId_ByKeyMutation = (sdk, options, callback) => {
  const mutationFn = async (input) => {
    const response = await PublicPlayerBinaryRecordApi(sdk, {
      coreConfig: input.coreConfig,
      axiosConfig: input.axiosConfig
    }).updateMetadata_ByUserId_ByKey(input.userId, input.key, input.data);
    callback && callback(response.data);
    return response.data;
  };
  return (0, import_react_query13.useMutation)({
    mutationKey: ["Cloudsave.PublicPlayerBinaryRecord.Metadata_ByUserId_ByKey" /* Metadata_ByUserId_ByKey */],
    mutationFn,
    ...options
  });
};
var usePublicPlayerBinaryRecordApi_CreatePresigned_ByUserId_ByKeyMutation = (sdk, options, callback) => {
  const mutationFn = async (input) => {
    const response = await PublicPlayerBinaryRecordApi(sdk, {
      coreConfig: input.coreConfig,
      axiosConfig: input.axiosConfig
    }).createPresigned_ByUserId_ByKey(input.userId, input.key, input.data);
    callback && callback(response.data);
    return response.data;
  };
  return (0, import_react_query13.useMutation)({
    mutationKey: ["Cloudsave.PublicPlayerBinaryRecord.Presigned_ByUserId_ByKey" /* Presigned_ByUserId_ByKey */],
    mutationFn,
    ...options
  });
};

// src/generated-public/queries/PublicPlayerRecord.query.ts
var import_react_query14 = require("@tanstack/react-query");

// src/generated-public/PublicPlayerRecordApi.ts
var import_sdk28 = require("@accelbyte/sdk");

// src/generated-public/endpoints/PublicPlayerRecord$.ts
var import_sdk27 = require("@accelbyte/sdk");
var import_zod54 = require("zod");
var PublicPlayerRecord$ = class {
  // @ts-ignore
  // prettier-ignore
  constructor(axiosInstance, namespace, useSchemaValidation = true) {
    this.axiosInstance = axiosInstance;
    this.namespace = namespace;
    this.useSchemaValidation = useSchemaValidation;
  }
  /**
   * Retrieve list of player records key under given namespace.
   */
  getUsersMeRecords(queryParams) {
    const params = { limit: 25, ...queryParams };
    const url = "/cloudsave/v1/namespaces/{namespace}/users/me/records".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.get(url, { params });
    return import_sdk27.Validate.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      ListPlayerRecordKeysResponse,
      "ListPlayerRecordKeysResponse"
    );
  }
  /**
   * Retrieve player record key and payload in bulk under given namespace. Maximum bulk key limit per request 20
   */
  createUserMeRecordBulk(data) {
    const params = {};
    const url = "/cloudsave/v1/namespaces/{namespace}/users/me/records/bulk".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.post(url, data, { params });
    return import_sdk27.Validate.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      BulkGetPlayerRecordResponse,
      "BulkGetPlayerRecordResponse"
    );
  }
  /**
   * Delete player record by its key. Only user that own the player record could delete it.
   */
  deleteRecord_ByUserId_ByKey(userId, key) {
    const params = {};
    const url = "/cloudsave/v1/namespaces/{namespace}/users/{userId}/records/{key}".replace("{namespace}", this.namespace).replace("{userId}", userId).replace("{key}", key);
    const resultPromise = this.axiosInstance.delete(url, { params });
    return import_sdk27.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, import_zod54.z.unknown(), "z.unknown()");
  }
  /**
   * Get player record by its key. **Private Record**: Only user that own the player record could retrieve it.
   */
  getRecord_ByUserId_ByKey(userId, key) {
    const params = {};
    const url = "/cloudsave/v1/namespaces/{namespace}/users/{userId}/records/{key}".replace("{namespace}", this.namespace).replace("{userId}", userId).replace("{key}", key);
    const resultPromise = this.axiosInstance.get(url, { params });
    return import_sdk27.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, PlayerRecordResponse, "PlayerRecordResponse");
  }
  /**
   * ## Description This endpoints will create new player record or append the existing player record. Only user that own the existing player record could modify. **Append example:** Example 1 - Existing JSON: `{ &#34;data1&#34;: &#34;value&#34; }` - New JSON: `{ &#34;data2&#34;: &#34;new value&#34; }` - Result: `{ &#34;data1&#34;: &#34;value&#34;, &#34;data2&#34;: &#34;new value&#34; }` Example 2 - Existing JSON: `{ &#34;data1&#34;: { &#34;data2&#34;: &#34;value&#34; }` - New JSON: `{ &#34;data1&#34;: { &#34;data3&#34;: &#34;new value&#34; }` - Result: `{ &#34;data1&#34;: { &#34;data2&#34;: &#34;value&#34;, &#34;data3&#34;: &#34;new value&#34; }` ## Restriction This is the restriction of Key Naming for the record: 1. Cannot use **&#34;.&#34;** as the key name - `{ &#34;data.2&#34;: &#34;value&#34; }` 2. Cannot use **&#34;$&#34;** as the prefix in key names - `{ &#34;$data&#34;: &#34;value&#34; }` 3. Cannot use empty string in key names - `{ &#34;&#34;: &#34;value&#34; }` ## Record Metadata Metadata allows user to define the behaviour of the record. Metadata can be defined in request body with field name **__META**. When creating record, if **__META** field is not defined, the metadata value will use the default value. When updating record, if **__META** field is not defined, the existing metadata value will stay as is. **Metadata List:** 1. is_public (default: false, type: bool) Indicate whether the player record is a public record or not. **Request Body Example:** ``` { &#34;__META&#34;: { &#34;is_public&#34;: true } ... } ```
   */
  createRecord_ByUserId_ByKey(userId, key, data) {
    const params = {};
    const url = "/cloudsave/v1/namespaces/{namespace}/users/{userId}/records/{key}".replace("{namespace}", this.namespace).replace("{userId}", userId).replace("{key}", key);
    const resultPromise = this.axiosInstance.post(url, data, { params });
    return import_sdk27.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, PlayerRecordResponse, "PlayerRecordResponse");
  }
  /**
   * ## Description This endpoints will create new player record or replace the existing player record. Only user that own the existing player record could modify it. **Replace behaviour:** The existing value will be replaced completely with the new value. Example - Existing JSON: `{ &#34;data1&#34;: &#34;value&#34; }` - New JSON: `{ &#34;data2&#34;: &#34;new value&#34; }` - Result: `{ &#34;data2&#34;: &#34;new value&#34; }` ## Restriction This is the restriction of Key Naming for the record: 1. Cannot use **&#34;.&#34;** as the key name - `{ &#34;data.2&#34;: &#34;value&#34; }` 2. Cannot use **&#34;$&#34;** as the prefix in key names - `{ &#34;$data&#34;: &#34;value&#34; }` 3. Cannot use empty string in key names - `{ &#34;&#34;: &#34;value&#34; }` ## Record Metadata Metadata allows user to define the behaviour of the record. Metadata can be defined in request body with field name **__META**. When creating record, if **__META** field is not defined, the metadata value will use the default value. When updating record, if **__META** field is not defined, the existing metadata value will stay as is. **Metadata List:** 1. is_public (default: false, type: bool) Indicate whether the player record is a public record or not. **Request Body Example:** ``` { &#34;__META&#34;: { &#34;is_public&#34;: true } ... } ```
   */
  updateRecord_ByUserId_ByKey(userId, key, data) {
    const params = {};
    const url = "/cloudsave/v1/namespaces/{namespace}/users/{userId}/records/{key}".replace("{namespace}", this.namespace).replace("{userId}", userId).replace("{key}", key);
    const resultPromise = this.axiosInstance.put(url, data, { params });
    return import_sdk27.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, PlayerRecordResponse, "PlayerRecordResponse");
  }
  /**
   * Retrieve list of other public player records key under given namespace.
   */
  getRecordsPublic_ByUserId(userId, queryParams) {
    const params = { limit: 25, ...queryParams };
    const url = "/cloudsave/v1/namespaces/{namespace}/users/{userId}/records/public".replace("{namespace}", this.namespace).replace("{userId}", userId);
    const resultPromise = this.axiosInstance.get(url, { params });
    return import_sdk27.Validate.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      ListPlayerRecordKeysResponse,
      "ListPlayerRecordKeysResponse"
    );
  }
  /**
   * Delete player public record. ## Warning: This endpoint is going to deprecate This endpoint is going to deprecate in the future please don&#39;t use it. For alternative, please use these endpoints: - **POST /cloudsave/v1/namespaces/{namespace}/users/{userId}/records/{key}** and utilizing **__META** functionality - **PUT /cloudsave/v1/namespaces/{namespace}/users/{userId}/records/{key}** and utilizing **__META** functionality - **DELETE /cloudsave/v1/namespaces/{namespace}/users/{userId}/records/{key}**
   */
  deletePublicMeUser_ByKey(key) {
    const params = {};
    const url = "/cloudsave/v1/namespaces/{namespace}/users/me/records/{key}/public".replace("{namespace}", this.namespace).replace("{key}", key);
    const resultPromise = this.axiosInstance.delete(url, { params });
    return import_sdk27.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, import_zod54.z.unknown(), "z.unknown()");
  }
  /**
   * Bulk get other player&#39;s record that is public by userIds, max allowed 20 at a time. Only record with `isPublic=true` that can be retrieved using this endpoint.
   */
  fetchPublicBulkUser_ByKey(key, data) {
    const params = {};
    const url = "/cloudsave/v1/namespaces/{namespace}/users/bulk/records/{key}/public".replace("{namespace}", this.namespace).replace("{key}", key);
    const resultPromise = this.axiosInstance.post(url, data, { params });
    return import_sdk27.Validate.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      BulkGetPlayerRecordResponse,
      "BulkGetPlayerRecordResponse"
    );
  }
  /**
   * Retrieve other player public record key and payload in bulk under given namespace. Maximum bulk key limit per request 20
   */
  fetchRecordBulk_ByUserId(userId, data) {
    const params = {};
    const url = "/cloudsave/v1/namespaces/{namespace}/users/{userId}/records/public/bulk".replace("{namespace}", this.namespace).replace("{userId}", userId);
    const resultPromise = this.axiosInstance.post(url, data, { params });
    return import_sdk27.Validate.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      BulkGetPlayerRecordResponse,
      "BulkGetPlayerRecordResponse"
    );
  }
  /**
   * Get other player&#39;s record that is public. Only record with `isPublic=true` that can be retrieved using this endpoint.
   */
  getPublic_ByUserId_ByKey(userId, key) {
    const params = {};
    const url = "/cloudsave/v1/namespaces/{namespace}/users/{userId}/records/{key}/public".replace("{namespace}", this.namespace).replace("{userId}", userId).replace("{key}", key);
    const resultPromise = this.axiosInstance.get(url, { params });
    return import_sdk27.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, PlayerRecordResponse, "PlayerRecordResponse");
  }
  /**
   * ## Description This endpoints will create new player public record or append the existing player public record. **Append example:** Example 1 - Existing JSON: `{ &#34;data1&#34;: &#34;value&#34; }` - New JSON: `{ &#34;data2&#34;: &#34;new value&#34; }` - Result: `{ &#34;data1&#34;: &#34;value&#34;, &#34;data2&#34;: &#34;new value&#34; }` Example 2 - Existing JSON: `{ &#34;data1&#34;: { &#34;data2&#34;: &#34;value&#34; }` - New JSON: `{ &#34;data1&#34;: { &#34;data3&#34;: &#34;new value&#34; }` - Result: `{ &#34;data1&#34;: { &#34;data2&#34;: &#34;value&#34;, &#34;data3&#34;: &#34;new value&#34; }` ## Restriction This is the restriction of Key Naming for the record: 1. Cannot use **&#34;.&#34;** as the key name - `{ &#34;data.2&#34;: &#34;value&#34; }` 2. Cannot use **&#34;$&#34;** as the prefix in key names - `{ &#34;$data&#34;: &#34;value&#34; }` 3. Cannot use empty string in key names - `{ &#34;&#34;: &#34;value&#34; }` ## Reserved Word Reserved Word List: **__META** The reserved word cannot be used as a field in record value, If still defining the field when creating or updating the record, it will be ignored. ## Warning: This endpoint is going to deprecate This endpoint is going to deprecate in the future please don&#39;t use it. For alternative, please use these endpoints: - **POST /cloudsave/v1/namespaces/{namespace}/users/{userId}/records/{key}** and utilizing **__META** functionality - **PUT /cloudsave/v1/namespaces/{namespace}/users/{userId}/records/{key}** and utilizing **__META** functionality - **DELETE /cloudsave/v1/namespaces/{namespace}/users/{userId}/records/{key}**
   */
  createPublic_ByUserId_ByKey(userId, key, data) {
    const params = {};
    const url = "/cloudsave/v1/namespaces/{namespace}/users/{userId}/records/{key}/public".replace("{namespace}", this.namespace).replace("{userId}", userId).replace("{key}", key);
    const resultPromise = this.axiosInstance.post(url, data, { params });
    return import_sdk27.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, PlayerRecordResponse, "PlayerRecordResponse");
  }
  /**
   * ## Description This endpoints will create new player public record or replace the existing player public record. **Replace behaviour:** The existing value will be replaced completely with the new value. Example - Existing JSON: `{ &#34;data1&#34;: &#34;value&#34; }` - New JSON: `{ &#34;data2&#34;: &#34;new value&#34; }` - Result: `{ &#34;data2&#34;: &#34;new value&#34; }` ## Restriction This is the restriction of Key Naming for the record: 1. Cannot use **&#34;.&#34;** as the key name - `{ &#34;data.2&#34;: &#34;value&#34; }` 2. Cannot use **&#34;$&#34;** as the prefix in key names - `{ &#34;$data&#34;: &#34;value&#34; }` 3. Cannot use empty string in key names - `{ &#34;&#34;: &#34;value&#34; }` ## Reserved Word Reserved Word List: **__META** The reserved word cannot be used as a field in record value, If still defining the field when creating or updating the record, it will be ignored. ## Warning: This endpoint is going to deprecate This endpoint is going to deprecate in the future please don&#39;t use it. For alternative, please use these endpoints: - **POST /cloudsave/v1/namespaces/{namespace}/users/{userId}/records/{key}** and utilizing **__META** functionality - **PUT /cloudsave/v1/namespaces/{namespace}/users/{userId}/records/{key}** and utilizing **__META** functionality - **DELETE /cloudsave/v1/namespaces/{namespace}/users/{userId}/records/{key}**
   */
  updatePublic_ByUserId_ByKey(userId, key, data) {
    const params = {};
    const url = "/cloudsave/v1/namespaces/{namespace}/users/{userId}/records/{key}/public".replace("{namespace}", this.namespace).replace("{userId}", userId).replace("{key}", key);
    const resultPromise = this.axiosInstance.put(url, data, { params });
    return import_sdk27.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, PlayerRecordResponse, "PlayerRecordResponse");
  }
};

// src/generated-public/PublicPlayerRecordApi.ts
function PublicPlayerRecordApi(sdk, args) {
  const sdkAssembly = sdk.assembly();
  const namespace = args?.coreConfig?.namespace ?? sdkAssembly.coreConfig.namespace;
  const useSchemaValidation = args?.coreConfig?.useSchemaValidation ?? sdkAssembly.coreConfig.useSchemaValidation;
  let axiosInstance = sdkAssembly.axiosInstance;
  const requestConfigOverrides = args?.axiosConfig?.request;
  const baseURLOverride = args?.coreConfig?.baseURL;
  const interceptorsOverride = args?.axiosConfig?.interceptors ?? [];
  if (requestConfigOverrides || baseURLOverride || interceptorsOverride.length > 0) {
    const requestConfig = import_sdk28.ApiUtils.mergeAxiosConfigs(sdkAssembly.axiosInstance.defaults, {
      ...baseURLOverride ? { baseURL: baseURLOverride } : {},
      ...requestConfigOverrides
    });
    axiosInstance = import_sdk28.Network.create(requestConfig);
    for (const interceptor of interceptorsOverride) {
      if (interceptor.type === "request") {
        axiosInstance.interceptors.request.use(interceptor.onRequest, interceptor.onError);
      }
      if (interceptor.type === "response") {
        axiosInstance.interceptors.response.use(interceptor.onSuccess, interceptor.onError);
      }
    }
  }
  async function getUsersMeRecords(queryParams) {
    const $ = new PublicPlayerRecord$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getUsersMeRecords(queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function createUserMeRecordBulk(data) {
    const $ = new PublicPlayerRecord$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.createUserMeRecordBulk(data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function deleteRecord_ByUserId_ByKey(userId, key) {
    const $ = new PublicPlayerRecord$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.deleteRecord_ByUserId_ByKey(userId, key);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getRecord_ByUserId_ByKey(userId, key) {
    const $ = new PublicPlayerRecord$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getRecord_ByUserId_ByKey(userId, key);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function createRecord_ByUserId_ByKey(userId, key, data) {
    const $ = new PublicPlayerRecord$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.createRecord_ByUserId_ByKey(userId, key, data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function updateRecord_ByUserId_ByKey(userId, key, data) {
    const $ = new PublicPlayerRecord$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.updateRecord_ByUserId_ByKey(userId, key, data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getRecordsPublic_ByUserId(userId, queryParams) {
    const $ = new PublicPlayerRecord$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getRecordsPublic_ByUserId(userId, queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function deletePublicMeUser_ByKey(key) {
    const $ = new PublicPlayerRecord$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.deletePublicMeUser_ByKey(key);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function fetchPublicBulkUser_ByKey(key, data) {
    const $ = new PublicPlayerRecord$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.fetchPublicBulkUser_ByKey(key, data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function fetchRecordBulk_ByUserId(userId, data) {
    const $ = new PublicPlayerRecord$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.fetchRecordBulk_ByUserId(userId, data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getPublic_ByUserId_ByKey(userId, key) {
    const $ = new PublicPlayerRecord$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getPublic_ByUserId_ByKey(userId, key);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function createPublic_ByUserId_ByKey(userId, key, data) {
    const $ = new PublicPlayerRecord$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.createPublic_ByUserId_ByKey(userId, key, data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function updatePublic_ByUserId_ByKey(userId, key, data) {
    const $ = new PublicPlayerRecord$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.updatePublic_ByUserId_ByKey(userId, key, data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  return {
    /**
     * Retrieve list of player records key under given namespace.
     */
    getUsersMeRecords,
    /**
     * Retrieve player record key and payload in bulk under given namespace. Maximum bulk key limit per request 20
     */
    createUserMeRecordBulk,
    /**
     * Delete player record by its key. Only user that own the player record could delete it.
     */
    deleteRecord_ByUserId_ByKey,
    /**
     * Get player record by its key. **Private Record**: Only user that own the player record could retrieve it.
     */
    getRecord_ByUserId_ByKey,
    /**
     * ## Description This endpoints will create new player record or append the existing player record. Only user that own the existing player record could modify. **Append example:** Example 1 - Existing JSON: `{ &#34;data1&#34;: &#34;value&#34; }` - New JSON: `{ &#34;data2&#34;: &#34;new value&#34; }` - Result: `{ &#34;data1&#34;: &#34;value&#34;, &#34;data2&#34;: &#34;new value&#34; }` Example 2 - Existing JSON: `{ &#34;data1&#34;: { &#34;data2&#34;: &#34;value&#34; }` - New JSON: `{ &#34;data1&#34;: { &#34;data3&#34;: &#34;new value&#34; }` - Result: `{ &#34;data1&#34;: { &#34;data2&#34;: &#34;value&#34;, &#34;data3&#34;: &#34;new value&#34; }` ## Restriction This is the restriction of Key Naming for the record: 1. Cannot use **&#34;.&#34;** as the key name - `{ &#34;data.2&#34;: &#34;value&#34; }` 2. Cannot use **&#34;$&#34;** as the prefix in key names - `{ &#34;$data&#34;: &#34;value&#34; }` 3. Cannot use empty string in key names - `{ &#34;&#34;: &#34;value&#34; }` ## Record Metadata Metadata allows user to define the behaviour of the record. Metadata can be defined in request body with field name **__META**. When creating record, if **__META** field is not defined, the metadata value will use the default value. When updating record, if **__META** field is not defined, the existing metadata value will stay as is. **Metadata List:** 1. is_public (default: false, type: bool) Indicate whether the player record is a public record or not. **Request Body Example:** ``` { &#34;__META&#34;: { &#34;is_public&#34;: true } ... } ```
     */
    createRecord_ByUserId_ByKey,
    /**
     * ## Description This endpoints will create new player record or replace the existing player record. Only user that own the existing player record could modify it. **Replace behaviour:** The existing value will be replaced completely with the new value. Example - Existing JSON: `{ &#34;data1&#34;: &#34;value&#34; }` - New JSON: `{ &#34;data2&#34;: &#34;new value&#34; }` - Result: `{ &#34;data2&#34;: &#34;new value&#34; }` ## Restriction This is the restriction of Key Naming for the record: 1. Cannot use **&#34;.&#34;** as the key name - `{ &#34;data.2&#34;: &#34;value&#34; }` 2. Cannot use **&#34;$&#34;** as the prefix in key names - `{ &#34;$data&#34;: &#34;value&#34; }` 3. Cannot use empty string in key names - `{ &#34;&#34;: &#34;value&#34; }` ## Record Metadata Metadata allows user to define the behaviour of the record. Metadata can be defined in request body with field name **__META**. When creating record, if **__META** field is not defined, the metadata value will use the default value. When updating record, if **__META** field is not defined, the existing metadata value will stay as is. **Metadata List:** 1. is_public (default: false, type: bool) Indicate whether the player record is a public record or not. **Request Body Example:** ``` { &#34;__META&#34;: { &#34;is_public&#34;: true } ... } ```
     */
    updateRecord_ByUserId_ByKey,
    /**
     * Retrieve list of other public player records key under given namespace.
     */
    getRecordsPublic_ByUserId,
    /**
     * Delete player public record. ## Warning: This endpoint is going to deprecate This endpoint is going to deprecate in the future please don&#39;t use it. For alternative, please use these endpoints: - **POST /cloudsave/v1/namespaces/{namespace}/users/{userId}/records/{key}** and utilizing **__META** functionality - **PUT /cloudsave/v1/namespaces/{namespace}/users/{userId}/records/{key}** and utilizing **__META** functionality - **DELETE /cloudsave/v1/namespaces/{namespace}/users/{userId}/records/{key}**
     */
    deletePublicMeUser_ByKey,
    /**
     * Bulk get other player&#39;s record that is public by userIds, max allowed 20 at a time. Only record with `isPublic=true` that can be retrieved using this endpoint.
     */
    fetchPublicBulkUser_ByKey,
    /**
     * Retrieve other player public record key and payload in bulk under given namespace. Maximum bulk key limit per request 20
     */
    fetchRecordBulk_ByUserId,
    /**
     * Get other player&#39;s record that is public. Only record with `isPublic=true` that can be retrieved using this endpoint.
     */
    getPublic_ByUserId_ByKey,
    /**
     * ## Description This endpoints will create new player public record or append the existing player public record. **Append example:** Example 1 - Existing JSON: `{ &#34;data1&#34;: &#34;value&#34; }` - New JSON: `{ &#34;data2&#34;: &#34;new value&#34; }` - Result: `{ &#34;data1&#34;: &#34;value&#34;, &#34;data2&#34;: &#34;new value&#34; }` Example 2 - Existing JSON: `{ &#34;data1&#34;: { &#34;data2&#34;: &#34;value&#34; }` - New JSON: `{ &#34;data1&#34;: { &#34;data3&#34;: &#34;new value&#34; }` - Result: `{ &#34;data1&#34;: { &#34;data2&#34;: &#34;value&#34;, &#34;data3&#34;: &#34;new value&#34; }` ## Restriction This is the restriction of Key Naming for the record: 1. Cannot use **&#34;.&#34;** as the key name - `{ &#34;data.2&#34;: &#34;value&#34; }` 2. Cannot use **&#34;$&#34;** as the prefix in key names - `{ &#34;$data&#34;: &#34;value&#34; }` 3. Cannot use empty string in key names - `{ &#34;&#34;: &#34;value&#34; }` ## Reserved Word Reserved Word List: **__META** The reserved word cannot be used as a field in record value, If still defining the field when creating or updating the record, it will be ignored. ## Warning: This endpoint is going to deprecate This endpoint is going to deprecate in the future please don&#39;t use it. For alternative, please use these endpoints: - **POST /cloudsave/v1/namespaces/{namespace}/users/{userId}/records/{key}** and utilizing **__META** functionality - **PUT /cloudsave/v1/namespaces/{namespace}/users/{userId}/records/{key}** and utilizing **__META** functionality - **DELETE /cloudsave/v1/namespaces/{namespace}/users/{userId}/records/{key}**
     */
    createPublic_ByUserId_ByKey,
    /**
     * ## Description This endpoints will create new player public record or replace the existing player public record. **Replace behaviour:** The existing value will be replaced completely with the new value. Example - Existing JSON: `{ &#34;data1&#34;: &#34;value&#34; }` - New JSON: `{ &#34;data2&#34;: &#34;new value&#34; }` - Result: `{ &#34;data2&#34;: &#34;new value&#34; }` ## Restriction This is the restriction of Key Naming for the record: 1. Cannot use **&#34;.&#34;** as the key name - `{ &#34;data.2&#34;: &#34;value&#34; }` 2. Cannot use **&#34;$&#34;** as the prefix in key names - `{ &#34;$data&#34;: &#34;value&#34; }` 3. Cannot use empty string in key names - `{ &#34;&#34;: &#34;value&#34; }` ## Reserved Word Reserved Word List: **__META** The reserved word cannot be used as a field in record value, If still defining the field when creating or updating the record, it will be ignored. ## Warning: This endpoint is going to deprecate This endpoint is going to deprecate in the future please don&#39;t use it. For alternative, please use these endpoints: - **POST /cloudsave/v1/namespaces/{namespace}/users/{userId}/records/{key}** and utilizing **__META** functionality - **PUT /cloudsave/v1/namespaces/{namespace}/users/{userId}/records/{key}** and utilizing **__META** functionality - **DELETE /cloudsave/v1/namespaces/{namespace}/users/{userId}/records/{key}**
     */
    updatePublic_ByUserId_ByKey
  };
}

// src/generated-public/queries/PublicPlayerRecord.query.ts
var Key_PublicPlayerRecord = /* @__PURE__ */ ((Key_PublicPlayerRecord2) => {
  Key_PublicPlayerRecord2["UsersMeRecords"] = "Cloudsave.PublicPlayerRecord.UsersMeRecords";
  Key_PublicPlayerRecord2["UserMeRecordBulk"] = "Cloudsave.PublicPlayerRecord.UserMeRecordBulk";
  Key_PublicPlayerRecord2["Record_ByUserId_ByKey"] = "Cloudsave.PublicPlayerRecord.Record_ByUserId_ByKey";
  Key_PublicPlayerRecord2["RecordsPublic_ByUserId"] = "Cloudsave.PublicPlayerRecord.RecordsPublic_ByUserId";
  Key_PublicPlayerRecord2["PublicMeUser_ByKey"] = "Cloudsave.PublicPlayerRecord.PublicMeUser_ByKey";
  Key_PublicPlayerRecord2["PublicBulkUser_ByKey"] = "Cloudsave.PublicPlayerRecord.PublicBulkUser_ByKey";
  Key_PublicPlayerRecord2["RecordBulk_ByUserId"] = "Cloudsave.PublicPlayerRecord.RecordBulk_ByUserId";
  Key_PublicPlayerRecord2["Public_ByUserId_ByKey"] = "Cloudsave.PublicPlayerRecord.Public_ByUserId_ByKey";
  return Key_PublicPlayerRecord2;
})(Key_PublicPlayerRecord || {});
var usePublicPlayerRecordApi_GetUsersMeRecords = (sdk, input, options, callback) => {
  const queryFn = (sdk2, input2) => async () => {
    const response = await PublicPlayerRecordApi(sdk2, { coreConfig: input2.coreConfig, axiosConfig: input2.axiosConfig }).getUsersMeRecords(
      input2.queryParams
    );
    callback && callback(response);
    return response.data;
  };
  return (0, import_react_query14.useQuery)({
    queryKey: ["Cloudsave.PublicPlayerRecord.UsersMeRecords" /* UsersMeRecords */, input],
    queryFn: queryFn(sdk, input),
    ...options
  });
};
var usePublicPlayerRecordApi_CreateUserMeRecordBulkMutation = (sdk, options, callback) => {
  const mutationFn = async (input) => {
    const response = await PublicPlayerRecordApi(sdk, {
      coreConfig: input.coreConfig,
      axiosConfig: input.axiosConfig
    }).createUserMeRecordBulk(input.data);
    callback && callback(response.data);
    return response.data;
  };
  return (0, import_react_query14.useMutation)({
    mutationKey: ["Cloudsave.PublicPlayerRecord.UserMeRecordBulk" /* UserMeRecordBulk */],
    mutationFn,
    ...options
  });
};
var usePublicPlayerRecordApi_DeleteRecord_ByUserId_ByKeyMutation = (sdk, options, callback) => {
  const mutationFn = async (input) => {
    const response = await PublicPlayerRecordApi(sdk, {
      coreConfig: input.coreConfig,
      axiosConfig: input.axiosConfig
    }).deleteRecord_ByUserId_ByKey(input.userId, input.key);
    callback && callback(response.data);
    return response.data;
  };
  return (0, import_react_query14.useMutation)({
    mutationKey: ["Cloudsave.PublicPlayerRecord.Record_ByUserId_ByKey" /* Record_ByUserId_ByKey */],
    mutationFn,
    ...options
  });
};
var usePublicPlayerRecordApi_GetRecord_ByUserId_ByKey = (sdk, input, options, callback) => {
  const queryFn = (sdk2, input2) => async () => {
    const response = await PublicPlayerRecordApi(sdk2, {
      coreConfig: input2.coreConfig,
      axiosConfig: input2.axiosConfig
    }).getRecord_ByUserId_ByKey(input2.userId, input2.key);
    callback && callback(response);
    return response.data;
  };
  return (0, import_react_query14.useQuery)({
    queryKey: ["Cloudsave.PublicPlayerRecord.Record_ByUserId_ByKey" /* Record_ByUserId_ByKey */, input],
    queryFn: queryFn(sdk, input),
    ...options
  });
};
var usePublicPlayerRecordApi_CreateRecord_ByUserId_ByKeyMutation = (sdk, options, callback) => {
  const mutationFn = async (input) => {
    const response = await PublicPlayerRecordApi(sdk, {
      coreConfig: input.coreConfig,
      axiosConfig: input.axiosConfig
    }).createRecord_ByUserId_ByKey(input.userId, input.key, input.data);
    callback && callback(response.data);
    return response.data;
  };
  return (0, import_react_query14.useMutation)({
    mutationKey: ["Cloudsave.PublicPlayerRecord.Record_ByUserId_ByKey" /* Record_ByUserId_ByKey */],
    mutationFn,
    ...options
  });
};
var usePublicPlayerRecordApi_UpdateRecord_ByUserId_ByKeyMutation = (sdk, options, callback) => {
  const mutationFn = async (input) => {
    const response = await PublicPlayerRecordApi(sdk, {
      coreConfig: input.coreConfig,
      axiosConfig: input.axiosConfig
    }).updateRecord_ByUserId_ByKey(input.userId, input.key, input.data);
    callback && callback(response.data);
    return response.data;
  };
  return (0, import_react_query14.useMutation)({
    mutationKey: ["Cloudsave.PublicPlayerRecord.Record_ByUserId_ByKey" /* Record_ByUserId_ByKey */],
    mutationFn,
    ...options
  });
};
var usePublicPlayerRecordApi_GetRecordsPublic_ByUserId = (sdk, input, options, callback) => {
  const queryFn = (sdk2, input2) => async () => {
    const response = await PublicPlayerRecordApi(sdk2, {
      coreConfig: input2.coreConfig,
      axiosConfig: input2.axiosConfig
    }).getRecordsPublic_ByUserId(input2.userId, input2.queryParams);
    callback && callback(response);
    return response.data;
  };
  return (0, import_react_query14.useQuery)({
    queryKey: ["Cloudsave.PublicPlayerRecord.RecordsPublic_ByUserId" /* RecordsPublic_ByUserId */, input],
    queryFn: queryFn(sdk, input),
    ...options
  });
};
var usePublicPlayerRecordApi_DeletePublicMeUser_ByKeyMutation = (sdk, options, callback) => {
  const mutationFn = async (input) => {
    const response = await PublicPlayerRecordApi(sdk, {
      coreConfig: input.coreConfig,
      axiosConfig: input.axiosConfig
    }).deletePublicMeUser_ByKey(input.key);
    callback && callback(response.data);
    return response.data;
  };
  return (0, import_react_query14.useMutation)({
    mutationKey: ["Cloudsave.PublicPlayerRecord.PublicMeUser_ByKey" /* PublicMeUser_ByKey */],
    mutationFn,
    ...options
  });
};
var usePublicPlayerRecordApi_FetchPublicBulkUser_ByKey = (sdk, input, options, callback) => {
  const queryFn = (sdk2, input2) => async () => {
    const response = await PublicPlayerRecordApi(sdk2, {
      coreConfig: input2.coreConfig,
      axiosConfig: input2.axiosConfig
    }).fetchPublicBulkUser_ByKey(input2.key, input2.data);
    callback && callback(response);
    return response.data;
  };
  return (0, import_react_query14.useQuery)({
    queryKey: ["Cloudsave.PublicPlayerRecord.PublicBulkUser_ByKey" /* PublicBulkUser_ByKey */, input],
    queryFn: queryFn(sdk, input),
    ...options
  });
};
var usePublicPlayerRecordApi_FetchRecordBulk_ByUserId = (sdk, input, options, callback) => {
  const queryFn = (sdk2, input2) => async () => {
    const response = await PublicPlayerRecordApi(sdk2, {
      coreConfig: input2.coreConfig,
      axiosConfig: input2.axiosConfig
    }).fetchRecordBulk_ByUserId(input2.userId, input2.data);
    callback && callback(response);
    return response.data;
  };
  return (0, import_react_query14.useQuery)({
    queryKey: ["Cloudsave.PublicPlayerRecord.RecordBulk_ByUserId" /* RecordBulk_ByUserId */, input],
    queryFn: queryFn(sdk, input),
    ...options
  });
};
var usePublicPlayerRecordApi_GetPublic_ByUserId_ByKey = (sdk, input, options, callback) => {
  const queryFn = (sdk2, input2) => async () => {
    const response = await PublicPlayerRecordApi(sdk2, {
      coreConfig: input2.coreConfig,
      axiosConfig: input2.axiosConfig
    }).getPublic_ByUserId_ByKey(input2.userId, input2.key);
    callback && callback(response);
    return response.data;
  };
  return (0, import_react_query14.useQuery)({
    queryKey: ["Cloudsave.PublicPlayerRecord.Public_ByUserId_ByKey" /* Public_ByUserId_ByKey */, input],
    queryFn: queryFn(sdk, input),
    ...options
  });
};
var usePublicPlayerRecordApi_CreatePublic_ByUserId_ByKeyMutation = (sdk, options, callback) => {
  const mutationFn = async (input) => {
    const response = await PublicPlayerRecordApi(sdk, {
      coreConfig: input.coreConfig,
      axiosConfig: input.axiosConfig
    }).createPublic_ByUserId_ByKey(input.userId, input.key, input.data);
    callback && callback(response.data);
    return response.data;
  };
  return (0, import_react_query14.useMutation)({
    mutationKey: ["Cloudsave.PublicPlayerRecord.Public_ByUserId_ByKey" /* Public_ByUserId_ByKey */],
    mutationFn,
    ...options
  });
};
var usePublicPlayerRecordApi_UpdatePublic_ByUserId_ByKeyMutation = (sdk, options, callback) => {
  const mutationFn = async (input) => {
    const response = await PublicPlayerRecordApi(sdk, {
      coreConfig: input.coreConfig,
      axiosConfig: input.axiosConfig
    }).updatePublic_ByUserId_ByKey(input.userId, input.key, input.data);
    callback && callback(response.data);
    return response.data;
  };
  return (0, import_react_query14.useMutation)({
    mutationKey: ["Cloudsave.PublicPlayerRecord.Public_ByUserId_ByKey" /* Public_ByUserId_ByKey */],
    mutationFn,
    ...options
  });
};

// src/generated-public/queries/PublicTags.query.ts
var import_react_query15 = require("@tanstack/react-query");

// src/generated-public/PublicTagsApi.ts
var import_sdk30 = require("@accelbyte/sdk");

// src/generated-public/endpoints/PublicTags$.ts
var import_sdk29 = require("@accelbyte/sdk");
var PublicTags$ = class {
  // @ts-ignore
  // prettier-ignore
  constructor(axiosInstance, namespace, useSchemaValidation = true) {
    this.axiosInstance = axiosInstance;
    this.namespace = namespace;
    this.useSchemaValidation = useSchemaValidation;
  }
  /**
   * ## Description Retrieve list of available tags by namespace
   */
  getTags(queryParams) {
    const params = { limit: 25, ...queryParams };
    const url = "/cloudsave/v1/namespaces/{namespace}/tags".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.get(url, { params });
    return import_sdk29.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, ListTagsResponse, "ListTagsResponse");
  }
};

// src/generated-public/PublicTagsApi.ts
function PublicTagsApi(sdk, args) {
  const sdkAssembly = sdk.assembly();
  const namespace = args?.coreConfig?.namespace ?? sdkAssembly.coreConfig.namespace;
  const useSchemaValidation = args?.coreConfig?.useSchemaValidation ?? sdkAssembly.coreConfig.useSchemaValidation;
  let axiosInstance = sdkAssembly.axiosInstance;
  const requestConfigOverrides = args?.axiosConfig?.request;
  const baseURLOverride = args?.coreConfig?.baseURL;
  const interceptorsOverride = args?.axiosConfig?.interceptors ?? [];
  if (requestConfigOverrides || baseURLOverride || interceptorsOverride.length > 0) {
    const requestConfig = import_sdk30.ApiUtils.mergeAxiosConfigs(sdkAssembly.axiosInstance.defaults, {
      ...baseURLOverride ? { baseURL: baseURLOverride } : {},
      ...requestConfigOverrides
    });
    axiosInstance = import_sdk30.Network.create(requestConfig);
    for (const interceptor of interceptorsOverride) {
      if (interceptor.type === "request") {
        axiosInstance.interceptors.request.use(interceptor.onRequest, interceptor.onError);
      }
      if (interceptor.type === "response") {
        axiosInstance.interceptors.response.use(interceptor.onSuccess, interceptor.onError);
      }
    }
  }
  async function getTags(queryParams) {
    const $ = new PublicTags$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getTags(queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  return {
    /**
     * ## Description Retrieve list of available tags by namespace
     */
    getTags
  };
}

// src/generated-public/queries/PublicTags.query.ts
var Key_PublicTags = /* @__PURE__ */ ((Key_PublicTags2) => {
  Key_PublicTags2["Tags"] = "Cloudsave.PublicTags.Tags";
  return Key_PublicTags2;
})(Key_PublicTags || {});
var usePublicTagsApi_GetTags = (sdk, input, options, callback) => {
  const queryFn = (sdk2, input2) => async () => {
    const response = await PublicTagsApi(sdk2, { coreConfig: input2.coreConfig, axiosConfig: input2.axiosConfig }).getTags(input2.queryParams);
    callback && callback(response);
    return response.data;
  };
  return (0, import_react_query15.useQuery)({
    queryKey: ["Cloudsave.PublicTags.Tags" /* Tags */, input],
    queryFn: queryFn(sdk, input),
    ...options
  });
};
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  Key_ConcurrentRecord,
  Key_ConcurrentRecordAdmin,
  Key_GameBinaryRecordAdmin,
  Key_GameRecordAdmin,
  Key_PlayerBinaryRecordAdmin,
  Key_PlayerRecordAdmin,
  Key_PluginConfigAdmin,
  Key_PublicGameBinaryRecord,
  Key_PublicGameRecord,
  Key_PublicPlayerBinaryRecord,
  Key_PublicPlayerRecord,
  Key_PublicTags,
  Key_RecordAdmin,
  Key_TagsAdmin,
  Key_TtlConfigAdmin,
  useConcurrentRecordAdminApi_UpdateConcurrentAdminrecord_ByKeyMutation,
  useConcurrentRecordAdminApi_UpdateConcurrentAdminrecord_ByUserId_ByKeyMutation,
  useConcurrentRecordAdminApi_UpdateConcurrentRecord_ByKeyMutation,
  useConcurrentRecordAdminApi_UpdateConcurrentRecord_ByUserId_ByKeyMutation,
  useConcurrentRecordAdminApi_UpdatePublicConcurrent_ByUserId_ByKeyMutation,
  useConcurrentRecordApi_UpdateConcurrentRecord_ByKeyMutation,
  useConcurrentRecordApi_UpdateConcurrentRecord_ByUserId_ByKeyMutation,
  useConcurrentRecordApi_UpdatePublicConcurrent_ByUserId_ByKeyMutation,
  useGameBinaryRecordAdminApi_CreateBinaryMutation,
  useGameBinaryRecordAdminApi_CreatePresigned_ByKeyMutation,
  useGameBinaryRecordAdminApi_DeleteBinary_ByKeyMutation,
  useGameBinaryRecordAdminApi_GetBinaries,
  useGameBinaryRecordAdminApi_GetBinary_ByKey,
  useGameBinaryRecordAdminApi_UpdateBinary_ByKeyMutation,
  useGameBinaryRecordAdminApi_UpdateMetadata_ByKeyMutation,
  useGameRecordAdminApi_CreateRecord_ByKeyMutation,
  useGameRecordAdminApi_DeleteRecord_ByKeyMutation,
  useGameRecordAdminApi_GetRecord_ByKey,
  useGameRecordAdminApi_GetRecords,
  useGameRecordAdminApi_UpdateRecord_ByKeyMutation,
  usePlayerBinaryRecordAdminApi_CreateBinary_ByUserIdMutation,
  usePlayerBinaryRecordAdminApi_CreatePresigned_ByUserId_ByKeyMutation,
  usePlayerBinaryRecordAdminApi_DeleteBinary_ByUserId_ByKeyMutation,
  usePlayerBinaryRecordAdminApi_GetBinaries_ByUserId,
  usePlayerBinaryRecordAdminApi_GetBinary_ByUserId_ByKey,
  usePlayerBinaryRecordAdminApi_UpdateBinary_ByUserId_ByKeyMutation,
  usePlayerBinaryRecordAdminApi_UpdateMetadata_ByUserId_ByKeyMutation,
  usePlayerRecordAdminApi_CreatePublic_ByUserId_ByKeyMutation,
  usePlayerRecordAdminApi_CreateRecord_ByUserId_ByKeyMutation,
  usePlayerRecordAdminApi_DeletePublic_ByUserId_ByKeyMutation,
  usePlayerRecordAdminApi_DeleteRecord_ByUserId_ByKeyMutation,
  usePlayerRecordAdminApi_FetchBulkUser_ByKey,
  usePlayerRecordAdminApi_FetchRecordBulk_ByUserId,
  usePlayerRecordAdminApi_FetchUserBulkRecordSize,
  usePlayerRecordAdminApi_GetPublic_ByUserId_ByKey,
  usePlayerRecordAdminApi_GetRecord_ByUserId_ByKey,
  usePlayerRecordAdminApi_GetRecords_ByUserId,
  usePlayerRecordAdminApi_GetSize_ByUserId_ByKey,
  usePlayerRecordAdminApi_GetUsersRecords,
  usePlayerRecordAdminApi_UpdateBulkUser_ByKeyMutation,
  usePlayerRecordAdminApi_UpdatePublic_ByUserId_ByKeyMutation,
  usePlayerRecordAdminApi_UpdateRecordBulk_ByUserIdMutation,
  usePlayerRecordAdminApi_UpdateRecord_ByUserId_ByKeyMutation,
  usePluginConfigAdminApi_CreatePluginMutation,
  usePluginConfigAdminApi_DeletePluginMutation,
  usePluginConfigAdminApi_GetPlugins,
  usePluginConfigAdminApi_PatchPluginMutation,
  usePublicGameBinaryRecordApi_CreateBinaryBulkMutation,
  usePublicGameBinaryRecordApi_CreateBinaryMutation,
  usePublicGameBinaryRecordApi_CreatePresigned_ByKeyMutation,
  usePublicGameBinaryRecordApi_DeleteBinary_ByKeyMutation,
  usePublicGameBinaryRecordApi_GetBinaries,
  usePublicGameBinaryRecordApi_GetBinary_ByKey,
  usePublicGameBinaryRecordApi_UpdateBinary_ByKeyMutation,
  usePublicGameRecordApi_CreateRecord_ByKeyMutation,
  usePublicGameRecordApi_DeleteRecord_ByKeyMutation,
  usePublicGameRecordApi_FetchRecordBulk,
  usePublicGameRecordApi_GetRecord_ByKey,
  usePublicGameRecordApi_UpdateRecord_ByKeyMutation,
  usePublicPlayerBinaryRecordApi_CreateBinary_ByUserIdMutation,
  usePublicPlayerBinaryRecordApi_CreatePresigned_ByUserId_ByKeyMutation,
  usePublicPlayerBinaryRecordApi_CreateUserMeBinaryBulkMutation,
  usePublicPlayerBinaryRecordApi_DeleteBinary_ByUserId_ByKeyMutation,
  usePublicPlayerBinaryRecordApi_FetchBinaryBulk_ByUserId,
  usePublicPlayerBinaryRecordApi_FetchPublicBulkUser_ByKey,
  usePublicPlayerBinaryRecordApi_GetBinariesPublic_ByUserId,
  usePublicPlayerBinaryRecordApi_GetBinary_ByUserId_ByKey,
  usePublicPlayerBinaryRecordApi_GetPublic_ByUserId_ByKey,
  usePublicPlayerBinaryRecordApi_GetUsersMeBinaries,
  usePublicPlayerBinaryRecordApi_UpdateBinary_ByUserId_ByKeyMutation,
  usePublicPlayerBinaryRecordApi_UpdateMetadata_ByUserId_ByKeyMutation,
  usePublicPlayerRecordApi_CreatePublic_ByUserId_ByKeyMutation,
  usePublicPlayerRecordApi_CreateRecord_ByUserId_ByKeyMutation,
  usePublicPlayerRecordApi_CreateUserMeRecordBulkMutation,
  usePublicPlayerRecordApi_DeletePublicMeUser_ByKeyMutation,
  usePublicPlayerRecordApi_DeleteRecord_ByUserId_ByKeyMutation,
  usePublicPlayerRecordApi_FetchPublicBulkUser_ByKey,
  usePublicPlayerRecordApi_FetchRecordBulk_ByUserId,
  usePublicPlayerRecordApi_GetPublic_ByUserId_ByKey,
  usePublicPlayerRecordApi_GetRecord_ByUserId_ByKey,
  usePublicPlayerRecordApi_GetRecordsPublic_ByUserId,
  usePublicPlayerRecordApi_GetUsersMeRecords,
  usePublicPlayerRecordApi_UpdatePublic_ByUserId_ByKeyMutation,
  usePublicPlayerRecordApi_UpdateRecord_ByUserId_ByKeyMutation,
  usePublicTagsApi_GetTags,
  useRecordAdminApi_CreateAdminrecord_ByKeyMutation,
  useRecordAdminApi_CreateAdminrecord_ByUserId_ByKeyMutation,
  useRecordAdminApi_DeleteAdminrecord_ByKeyMutation,
  useRecordAdminApi_DeleteAdminrecord_ByUserId_ByKeyMutation,
  useRecordAdminApi_FetchAdminrecordBulk,
  useRecordAdminApi_FetchAdminrecordBulk_ByUserId,
  useRecordAdminApi_FetchBulkUser_ByKey,
  useRecordAdminApi_GetAdminrecord_ByKey,
  useRecordAdminApi_GetAdminrecord_ByUserId_ByKey,
  useRecordAdminApi_GetAdminrecords,
  useRecordAdminApi_GetAdminrecords_ByUserId,
  useRecordAdminApi_UpdateAdminrecord_ByKeyMutation,
  useRecordAdminApi_UpdateAdminrecord_ByUserId_ByKeyMutation,
  useTagsAdminApi_CreateTagMutation,
  useTagsAdminApi_DeleteTag_ByTagMutation,
  useTagsAdminApi_GetTags,
  useTtlConfigAdminApi_DeleteTtl_ByKeyMutation,
  useTtlConfigAdminApi_DeleteTtl_ByKey_ByNSMutation
});

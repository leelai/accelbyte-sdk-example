// src/generated-definitions/Configuration.ts
import { z } from "zod";
var Configuration = z.object({ logLevel: z.enum(["debug", "error", "fatal", "info", "panic", "trace", "warning"]).nullish() });

// src/generated-admin/endpoints/ConfigAdmin$.ts
import { Validate } from "@accelbyte/sdk";
var ConfigAdmin$ = class {
  // @ts-ignore
  // prettier-ignore
  constructor(axiosInstance, namespace, useSchemaValidation = true) {
    this.axiosInstance = axiosInstance;
    this.namespace = namespace;
    this.useSchemaValidation = useSchemaValidation;
  }
  /**
   * Get Log Configuration.&lt;br&gt;
   */
  getConfigLog() {
    const params = {};
    const url = "/sessionhistory/v1/admin/config/log";
    const resultPromise = this.axiosInstance.get(url, { params });
    return Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, Configuration, "Configuration");
  }
  /**
   * Update Log Configuration.&lt;br&gt;
   */
  patchConfigLog(data) {
    const params = {};
    const url = "/sessionhistory/v1/admin/config/log";
    const resultPromise = this.axiosInstance.patch(url, data, { params });
    return Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, Configuration, "Configuration");
  }
};

// src/generated-admin/ConfigAdminApi.ts
import { ApiUtils, Network } from "@accelbyte/sdk";
function ConfigAdminApi(sdk, args) {
  const sdkAssembly = sdk.assembly();
  const namespace = args?.coreConfig?.namespace ?? sdkAssembly.coreConfig.namespace;
  const useSchemaValidation = args?.coreConfig?.useSchemaValidation ?? sdkAssembly.coreConfig.useSchemaValidation;
  let axiosInstance = sdkAssembly.axiosInstance;
  const requestConfigOverrides = args?.axiosConfig?.request;
  const baseURLOverride = args?.coreConfig?.baseURL;
  const interceptorsOverride = args?.axiosConfig?.interceptors ?? [];
  if (requestConfigOverrides || baseURLOverride || interceptorsOverride.length > 0) {
    const requestConfig = ApiUtils.mergeAxiosConfigs(sdkAssembly.axiosInstance.defaults, {
      ...baseURLOverride ? { baseURL: baseURLOverride } : {},
      ...requestConfigOverrides
    });
    axiosInstance = Network.create(requestConfig);
    for (const interceptor of interceptorsOverride) {
      if (interceptor.type === "request") {
        axiosInstance.interceptors.request.use(interceptor.onRequest, interceptor.onError);
      }
      if (interceptor.type === "response") {
        axiosInstance.interceptors.response.use(interceptor.onSuccess, interceptor.onError);
      }
    }
  }
  async function getConfigLog() {
    const $ = new ConfigAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getConfigLog();
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function patchConfigLog(data) {
    const $ = new ConfigAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.patchConfigLog(data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  return {
    /**
     * Get Log Configuration.&lt;br&gt;
     */
    getConfigLog,
    /**
     * Update Log Configuration.&lt;br&gt;
     */
    patchConfigLog
  };
}

// src/generated-definitions/GameServer.ts
import { z as z2 } from "zod";
var GameServer = z2.object({
  alternate_ips: z2.array(z2.string()).nullish(),
  custom_attribute: z2.string().nullish(),
  deployment: z2.string().nullish(),
  game_version: z2.string().nullish(),
  image_version: z2.string().nullish(),
  ip: z2.string().nullish(),
  is_override_game_version: z2.boolean().nullish(),
  last_update: z2.string().nullish(),
  namespace: z2.string().nullish(),
  pod_name: z2.string().nullish(),
  port: z2.number().int().nullish(),
  ports: z2.record(z2.number().int()).nullish(),
  protocol: z2.string().nullish(),
  provider: z2.string().nullish(),
  region: z2.string().nullish(),
  session_id: z2.string().nullish(),
  status: z2.string().nullish()
});

// src/generated-definitions/DsInformation.ts
import { z as z3 } from "zod";
var DsInformation = z3.object({
  RequestedAt: z3.string().nullish(),
  Server: GameServer.nullish(),
  Status: z3.string().nullish(),
  StatusV2: z3.string().nullish()
});

// src/generated-definitions/PartyMembers.ts
import { z as z4 } from "zod";
var PartyMembers = z4.object({ partyID: z4.string().nullish(), userIDs: z4.array(z4.string()).nullish() });

// src/generated-definitions/GameSessionTeam.ts
import { z as z5 } from "zod";
var GameSessionTeam = z5.object({ parties: z5.array(PartyMembers).nullish(), userIDs: z5.array(z5.string()).nullish() });

// src/generated-definitions/SessionConfig.ts
import { z as z6 } from "zod";
var SessionConfig = z6.object({
  ClientVersion: z6.string().nullish(),
  Deployment: z6.string().nullish(),
  InactiveTimeout: z6.number().int().nullish(),
  InviteTimeout: z6.number().int().nullish(),
  Joinability: z6.string().nullish(),
  MaxPlayers: z6.number().int().nullish(),
  MinPlayers: z6.number().int().nullish(),
  Name: z6.string().nullish(),
  Persistent: z6.boolean().nullish(),
  RequestedRegions: z6.array(z6.string()).nullish(),
  Type: z6.string().nullish()
});

// src/generated-definitions/User.ts
import { z as z7 } from "zod";
var User = z7.object({
  ID: z7.string().nullish(),
  PlatformID: z7.string().nullish(),
  PlatformUserID: z7.string().nullish(),
  Status: z7.string().nullish(),
  StatusV2: z7.string().nullish(),
  UpdatedAt: z7.string().nullish()
});

// src/generated-definitions/GameSession.ts
import { z as z8 } from "zod";
var GameSession = z8.object({
  Attributes: z8.record(z8.any()).nullish(),
  BackfillTicketID: z8.string().nullish(),
  Code: z8.string().nullish(),
  Configuration: SessionConfig.nullish(),
  ConfigurationName: z8.string().nullish(),
  CreatedAt: z8.string().nullish(),
  CreatedBy: z8.string().nullish(),
  DSInformation: DsInformation.nullish(),
  GameMode: z8.string().nullish(),
  ID: z8.string().nullish(),
  IsFull: z8.boolean().nullish(),
  LeaderID: z8.string().nullish(),
  MatchPool: z8.string().nullish(),
  Members: z8.array(User).nullish(),
  Namespace: z8.string().nullish(),
  ProcessingTime: z8.number().int().nullish(),
  Teams: z8.array(GameSessionTeam).nullish(),
  TicketIDs: z8.array(z8.string()).nullish(),
  UpdatedAt: z8.string().nullish(),
  Version: z8.number().int().nullish(),
  isActive: z8.boolean().nullish()
});

// src/generated-definitions/History.ts
import { z as z9 } from "zod";
var History = z9.object({
  eventName: z9.string(),
  payload: GameSession,
  requesterClientID: z9.string().nullish(),
  requesterUserID: z9.string().nullish(),
  timestamp: z9.string()
});

// src/generated-definitions/GameSessionDetail.ts
import { z as z10 } from "zod";
var GameSessionDetail = z10.object({
  created_at: z10.string(),
  histories: z10.array(History),
  namespace: z10.string(),
  sessionID: z10.string(),
  session_template: z10.string()
});

// src/generated-definitions/Pagination.ts
import { z as z11 } from "zod";
var Pagination = z11.object({ first: z11.string(), last: z11.string(), next: z11.string(), previous: z11.string() });

// src/generated-definitions/GameSessionDetailQueryResponse.ts
import { z as z12 } from "zod";
var GameSessionDetailQueryResponse = z12.object({ data: z12.array(GameSessionDetail), paging: Pagination });

// src/generated-definitions/PartyTeam.ts
import { z as z13 } from "zod";
var PartyTeam = z13.object({ PartyID: z13.string().nullish(), UserIDs: z13.array(z13.string()).nullish() });

// src/generated-definitions/Team.ts
import { z as z14 } from "zod";
var Team = z14.object({ Parties: z14.array(PartyTeam).nullish(), UserIDs: z14.array(z14.string()).nullish() });

// src/generated-definitions/PlayerData.ts
import { z as z15 } from "zod";
var PlayerData = z15.object({
  Attributes: z15.record(z15.any()).nullish(),
  PartyID: z15.string().nullish(),
  PlatformID: z15.string().nullish(),
  PlayerID: z15.string().nullish()
});

// src/generated-definitions/ProposedProposal.ts
import { z as z16 } from "zod";
var ProposedProposal = z16.object({
  BackfillID: z16.string().nullish(),
  ProposalID: z16.string().nullish(),
  Status: z16.string().nullish()
});

// src/generated-definitions/Ticket.ts
import { z as z17 } from "zod";
var Ticket = z17.object({
  CreatedAt: z17.string().nullish(),
  Latencies: z17.record(z17.number().int()).nullish(),
  MatchPool: z17.string().nullish(),
  MatchedAt: z17.string().nullish(),
  Namespace: z17.string().nullish(),
  PartySessionID: z17.string().nullish(),
  Players: z17.array(PlayerData).nullish(),
  ProposedProposal: ProposedProposal.nullish(),
  TicketAttributes: z17.record(z17.any()).nullish(),
  TicketID: z17.string().nullish()
});

// src/generated-definitions/BackfillProposal.ts
import { z as z18 } from "zod";
var BackfillProposal = z18.object({
  AddedTickets: z18.array(Ticket).nullish(),
  BackfillTicketID: z18.string().nullish(),
  CreatedAt: z18.string().nullish(),
  MatchPool: z18.string().nullish(),
  MatchSessionID: z18.string().nullish(),
  ProposalID: z18.string().nullish(),
  ProposedTeams: z18.array(Team).nullish()
});

// src/generated-definitions/MatchTicket.ts
import { z as z19 } from "zod";
var MatchTicket = z19.object({
  CreatedAt: z19.string().nullish(),
  IsPivot: z19.boolean().nullish(),
  Latencies: z19.record(z19.number().int()).nullish(),
  MatchPool: z19.string().nullish(),
  MatchedAt: z19.string().nullish(),
  Namespace: z19.string().nullish(),
  PartySessionID: z19.string().nullish(),
  Players: z19.array(PlayerData).nullish(),
  ProposedProposal: ProposedProposal.nullish(),
  RegionPreference: z19.array(z19.string()).nullish(),
  TicketAttributes: z19.record(z19.any()).nullish(),
  TicketID: z19.string().nullish(),
  TimeToMatch: z19.number().nullish()
});

// src/generated-definitions/Match.ts
import { z as z20 } from "zod";
var Match = z20.object({
  Backfill: z20.boolean().nullish(),
  ClientVersion: z20.string().nullish(),
  MatchAttributes: z20.record(z20.any()).nullish(),
  PivotID: z20.string().nullish(),
  RegionPreference: z20.array(z20.string()).nullish(),
  ServerName: z20.string().nullish(),
  Teams: z20.array(Team).nullish(),
  Tickets: z20.array(MatchTicket).nullish(),
  Timestamp: z20.string().nullish()
});

// src/generated-definitions/BackfillTicket.ts
import { z as z21 } from "zod";
var BackfillTicket = z21.object({
  CreatedAt: z21.string().nullish(),
  MatchPool: z21.string().nullish(),
  MatchSessionID: z21.string().nullish(),
  MatchSessionVersion: z21.number().int().nullish(),
  PartialMatch: Match.nullish(),
  TicketID: z21.string().nullish()
});

// src/generated-definitions/MatchmakingHistory.ts
import { z as z22 } from "zod";
var MatchmakingHistory = z22.object({
  backfillProposal: BackfillProposal.nullish(),
  backfillTicket: BackfillTicket.nullish(),
  eventName: z22.string().nullish(),
  requestedUserID: z22.string().nullish(),
  ticket: Ticket.nullish(),
  timestamp: z22.string().nullish(),
  unbackfillReason: z22.string().nullish()
});

// src/generated-definitions/MatchmakingDetail.ts
import { z as z23 } from "zod";
var MatchmakingDetail = z23.object({
  createdAt: z23.string().nullish(),
  expiredAt: z23.string().nullish(),
  gameSessionID: z23.string().nullish(),
  histories: z23.array(MatchmakingHistory).nullish(),
  matchPool: z23.string().nullish(),
  matchRule: z23.string().nullish(),
  namespace: z23.string().nullish(),
  partySessionID: z23.string().nullish(),
  ticketID: z23.string().nullish()
});

// src/generated-definitions/MatchmakingDetailQueryResponse.ts
import { z as z24 } from "zod";
var MatchmakingDetailQueryResponse = z24.object({ data: z24.array(MatchmakingDetail), paging: Pagination });

// src/generated-definitions/SessionConfiguration.ts
import { z as z25 } from "zod";
var SessionConfiguration = z25.object({
  ClientVersion: z25.string().nullish(),
  Deployment: z25.string().nullish(),
  InactiveTimeout: z25.number().int().nullish(),
  InviteTimeout: z25.number().int().nullish(),
  Joinability: z25.string().nullish(),
  MaxPlayers: z25.number().int().nullish(),
  MinPlayers: z25.number().int().nullish(),
  Persistent: z25.boolean().nullish(),
  RequestedRegions: z25.array(z25.string()).nullish(),
  TextChat: z25.boolean().nullish(),
  Type: z25.string().nullish()
});

// src/generated-definitions/Party.ts
import { z as z26 } from "zod";
var Party = z26.object({
  Attributes: z26.record(z26.any()).nullish(),
  Code: z26.string().nullish(),
  Configuration: SessionConfiguration.nullish(),
  ConfigurationName: z26.string().nullish(),
  CreatedAt: z26.string().nullish(),
  CreatedBy: z26.string().nullish(),
  ExpiredAt: z26.string().nullish(),
  ID: z26.string().nullish(),
  IsActive: z26.boolean().nullish(),
  IsFull: z26.boolean().nullish(),
  LeaderID: z26.string().nullish(),
  Members: z26.array(User).nullish(),
  Namespace: z26.string().nullish(),
  UpdatedAt: z26.string().nullish(),
  Version: z26.number().int().nullish()
});

// src/generated-definitions/PartyHistory.ts
import { z as z27 } from "zod";
var PartyHistory = z27.object({
  eventName: z27.string(),
  payload: Party,
  requesterClientID: z27.string().nullish(),
  requesterUserID: z27.string().nullish(),
  timestamp: z27.string()
});

// src/generated-definitions/PartyDetail.ts
import { z as z28 } from "zod";
var PartyDetail = z28.object({
  created_at: z28.string(),
  histories: z28.array(PartyHistory),
  namespace: z28.string(),
  partySessionID: z28.string(),
  session_template: z28.string()
});

// src/generated-definitions/PartyDetailQueryResponse.ts
import { z as z29 } from "zod";
var PartyDetailQueryResponse = z29.object({ data: z29.array(PartyDetail), paging: Pagination });

// src/generated-definitions/AllianceRule.ts
import { z as z30 } from "zod";
var AllianceRule = z30.object({
  max_number: z30.number().int(),
  min_number: z30.number().int(),
  player_max_number: z30.number().int(),
  player_min_number: z30.number().int()
});

// src/generated-definitions/MatchingRule.ts
import { z as z31 } from "zod";
var MatchingRule = z31.object({ attribute: z31.string(), criteria: z31.string(), reference: z31.number() });

// src/generated-definitions/PartyMember.ts
import { z as z32 } from "zod";
var PartyMember = z32.object({ extra_attributes: z32.record(z32.any()).nullish(), user_id: z32.string() });

// src/generated-definitions/MatchingParty.ts
import { z as z33 } from "zod";
var MatchingParty = z33.object({
  first_ticket_created_at: z33.number().int(),
  party_attributes: z33.record(z33.any()).nullish(),
  party_id: z33.string(),
  party_members: z33.array(PartyMember),
  ticket_id: z33.string()
});

// src/generated-definitions/MatchingAlly.ts
import { z as z34 } from "zod";
var MatchingAlly = z34.object({ matching_parties: z34.array(MatchingParty) });

// src/generated-definitions/MatchmakingResult.ts
import { z as z35 } from "zod";
var MatchmakingResult = z35.object({
  channel: z35.string().nullish(),
  client_version: z35.string().nullish(),
  deployment: z35.string().nullish(),
  error_code: z35.number().int().nullish(),
  error_message: z35.string().nullish(),
  game_mode: z35.string().nullish(),
  joinable: z35.boolean().nullish(),
  match_id: z35.string(),
  match_session_id: z35.string().nullish(),
  matching_allies: z35.array(MatchingAlly),
  namespace: z35.string().nullish(),
  party_attributes: z35.record(z35.any()).nullish(),
  party_id: z35.string().nullish(),
  queued_at: z35.number().int(),
  region: z35.string().nullish(),
  server_name: z35.string().nullish(),
  status: z35.string().nullish(),
  ticket_id: z35.string(),
  updated_at: z35.string()
});

// src/generated-definitions/TicketData.ts
import { z as z36 } from "zod";
var TicketData = z36.object({
  action: z36.string(),
  activeAllianceRule: AllianceRule.nullish(),
  activeMatchingRule: z36.array(MatchingRule).nullish(),
  elapsedTime: z36.number().nullish(),
  function: z36.string().nullish(),
  gameMode: z36.string(),
  isBackfillMatch: z36.boolean(),
  isPivot: z36.boolean(),
  isRuleSetFlexed: z36.boolean(),
  iteration: z36.number().int().nullish(),
  matchID: z36.string().nullish(),
  matchedRegion: z36.string(),
  memberAttributes: z36.record(z36.any()),
  namespace: z36.string(),
  partyID: z36.string(),
  podName: z36.string(),
  remainingPlayersPerTicket: z36.array(z36.number().int()).nullish(),
  remainingTickets: z36.number().int().nullish(),
  session: MatchmakingResult.nullish(),
  sessionTickID: z36.string(),
  tickID: z36.number().int(),
  timeToMatchSec: z36.number().nullish(),
  timestamp: z36.string(),
  totalPlayers: z36.number().int(),
  unbackfillReason: z36.string().nullish(),
  unmatchReason: z36.string().nullish()
});

// src/generated-definitions/TicketObservability.ts
import { z as z37 } from "zod";
var TicketObservability = z37.object({ ticket: TicketData });

// src/generated-definitions/TicketObservabilityHistory.ts
import { z as z38 } from "zod";
var TicketObservabilityHistory = z38.object({
  Action: z38.string(),
  ExpiredAt: z38.string(),
  ID: z38.string(),
  Payload: z38.record(z38.any()),
  PodName: z38.string(),
  TickID: z38.number().int(),
  Timestamp: z38.string(),
  party_id: z38.string(),
  ticket_id: z38.string()
});

// src/generated-definitions/TicketObservabilityDetail.ts
import { z as z39 } from "zod";
var TicketObservabilityDetail = z39.object({
  action: z39.string(),
  createdAt: z39.string(),
  expiredAt: z39.string(),
  game_mode: z39.string(),
  history: z39.array(TicketObservabilityHistory).nullish(),
  lastData: TicketObservability.nullish(),
  matchId: z39.string(),
  namespace: z39.string(),
  party_id: z39.string(),
  regions: z39.string(),
  remainingPlayersPerTicket: z39.array(z39.number().int()).nullish(),
  remainingTickets: z39.number().int(),
  requestedRegion: z39.array(z39.string()).nullish(),
  ticket: Ticket.nullish(),
  ticket_id: z39.string(),
  timeToMatchSec: z39.number().nullish(),
  updatedAt: z39.string(),
  userIDs: z39.array(z39.string()).nullish()
});

// src/generated-definitions/TicketDetailQueryResponse.ts
import { z as z40 } from "zod";
var TicketDetailQueryResponse = z40.object({ data: z40.array(TicketObservabilityDetail), paging: Pagination });

// src/generated-admin/endpoints/GameSessionDetailAdmin$.ts
import { Validate as Validate2 } from "@accelbyte/sdk";
var GameSessionDetailAdmin$ = class {
  // @ts-ignore
  // prettier-ignore
  constructor(axiosInstance, namespace, useSchemaValidation = true) {
    this.axiosInstance = axiosInstance;
    this.namespace = namespace;
    this.useSchemaValidation = useSchemaValidation;
  }
  /**
   * Get all parties.
   */
  getParties(queryParams) {
    const params = { limit: 20, ...queryParams };
    const url = "/sessionhistory/v1/admin/namespaces/{namespace}/parties".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.get(url, { params });
    return Validate2.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      PartyDetailQueryResponse,
      "PartyDetailQueryResponse"
    );
  }
  /**
   * Get all matchmaking ticket.
   */
  getTickets(queryParams) {
    const params = { limit: 20, ...queryParams };
    const url = "/sessionhistory/v1/admin/namespaces/{namespace}/tickets".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.get(url, { params });
    return Validate2.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      TicketDetailQueryResponse,
      "TicketDetailQueryResponse"
    );
  }
  /**
   * Get all matchmaking.
   */
  getMatchmaking(queryParams) {
    const params = { limit: 20, ...queryParams };
    const url = "/sessionhistory/v1/admin/namespaces/{namespace}/matchmaking".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.get(url, { params });
    return Validate2.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      MatchmakingDetailQueryResponse,
      "MatchmakingDetailQueryResponse"
    );
  }
  /**
   * Get all game sessions.
   */
  getGamesessions(queryParams) {
    const params = { limit: 20, ...queryParams };
    const url = "/sessionhistory/v1/admin/namespaces/{namespace}/gamesessions".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.get(url, { params });
    return Validate2.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      GameSessionDetailQueryResponse,
      "GameSessionDetailQueryResponse"
    );
  }
  /**
   * Get detail matchmaking ticket history by ticket ID.
   */
  getTicket_ByTicketId(ticketId) {
    const params = {};
    const url = "/sessionhistory/v1/admin/namespaces/{namespace}/tickets/{ticketId}".replace("{namespace}", this.namespace).replace("{ticketId}", ticketId);
    const resultPromise = this.axiosInstance.get(url, { params });
    return Validate2.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      TicketObservabilityDetail,
      "TicketObservabilityDetail"
    );
  }
  /**
   * Get party detail.
   */
  getParty_BySessionId(sessionId) {
    const params = {};
    const url = "/sessionhistory/v1/admin/namespaces/{namespace}/parties/{sessionId}".replace("{namespace}", this.namespace).replace("{sessionId}", sessionId);
    const resultPromise = this.axiosInstance.get(url, { params });
    return Validate2.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, PartyDetail, "PartyDetail");
  }
  /**
   * Get game session detail.
   */
  getGamesession_BySessionId(sessionId) {
    const params = {};
    const url = "/sessionhistory/v1/admin/namespaces/{namespace}/gamesessions/{sessionId}".replace("{namespace}", this.namespace).replace("{sessionId}", sessionId);
    const resultPromise = this.axiosInstance.get(url, { params });
    return Validate2.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, GameSessionDetail, "GameSessionDetail");
  }
  /**
   * Get detail matchmaking history by ticket ID.
   */
  getMatchmakingTicket_ByTicketId(ticketId) {
    const params = {};
    const url = "/sessionhistory/v1/admin/namespaces/{namespace}/matchmaking/ticket/{ticketId}".replace("{namespace}", this.namespace).replace("{ticketId}", ticketId);
    const resultPromise = this.axiosInstance.get(url, { params });
    return Validate2.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, MatchmakingDetail, "MatchmakingDetail");
  }
  /**
   * Get detail matchmaking history by session ID.
   */
  getMatchmakingSession_BySessionId(sessionId) {
    const params = {};
    const url = "/sessionhistory/v1/admin/namespaces/{namespace}/matchmaking/session/{sessionId}".replace("{namespace}", this.namespace).replace("{sessionId}", sessionId);
    const resultPromise = this.axiosInstance.get(url, { params });
    return Validate2.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, MatchmakingDetail, "MatchmakingDetail");
  }
};

// src/generated-definitions/AcquiringDs.ts
import { z as z41 } from "zod";
var AcquiringDs = z41.object({
  createdAt: z41.string().nullish(),
  matchPool: z41.string().nullish(),
  namespace: z41.string().nullish(),
  region: z41.string().nullish(),
  success: z41.boolean().nullish(),
  value: z41.number().int().nullish()
});

// src/generated-definitions/XRayAcquiringDsQueryResponse.ts
import { z as z42 } from "zod";
var XRayAcquiringDsQueryResponse = z42.object({ data: z42.array(AcquiringDs) });

// src/generated-definitions/AcquiringDsWaitTime.ts
import { z as z43 } from "zod";
var AcquiringDsWaitTime = z43.object({
  createdAt: z43.string().nullish(),
  matchPool: z43.string().nullish(),
  namespace: z43.string().nullish(),
  value: z43.number().nullish()
});

// src/generated-definitions/XRayAcquiringDsWaitTimeQueryResponse.ts
import { z as z44 } from "zod";
var XRayAcquiringDsWaitTimeQueryResponse = z44.object({ data: z44.array(AcquiringDsWaitTime) });

// src/generated-definitions/XRayBulkTicketObservabilityResponse.ts
import { z as z45 } from "zod";
var XRayBulkTicketObservabilityResponse = z45.object({ ticketIDs: z45.array(z45.string()) });

// src/generated-definitions/CanceledMatchmakingTicket.ts
import { z as z46 } from "zod";
var CanceledMatchmakingTicket = z46.object({
  createdAt: z46.string().nullish(),
  matchPool: z46.string().nullish(),
  namespace: z46.string().nullish(),
  value: z46.number().int().nullish()
});

// src/generated-definitions/XRayCanceledMatchmakingTicketQueryResponse.ts
import { z as z47 } from "zod";
var XRayCanceledMatchmakingTicketQueryResponse = z47.object({ data: z47.array(CanceledMatchmakingTicket) });

// src/generated-definitions/CreatedMatchmakingTicket.ts
import { z as z48 } from "zod";
var CreatedMatchmakingTicket = z48.object({
  createdAt: z48.string().nullish(),
  matchPool: z48.string().nullish(),
  namespace: z48.string().nullish(),
  value: z48.number().int().nullish()
});

// src/generated-definitions/XRayCreatedMatchmakingTicketQueryResponse.ts
import { z as z49 } from "zod";
var XRayCreatedMatchmakingTicketQueryResponse = z49.object({ data: z49.array(CreatedMatchmakingTicket) });

// src/generated-definitions/ExpiredMatchmakingTicket.ts
import { z as z50 } from "zod";
var ExpiredMatchmakingTicket = z50.object({
  createdAt: z50.string().nullish(),
  matchPool: z50.string().nullish(),
  namespace: z50.string().nullish(),
  value: z50.number().int().nullish()
});

// src/generated-definitions/XRayExpiredMatchmakingTicketQueryResponse.ts
import { z as z51 } from "zod";
var XRayExpiredMatchmakingTicketQueryResponse = z51.object({ data: z51.array(ExpiredMatchmakingTicket) });

// src/generated-definitions/EventMatchHistory.ts
import { z as z52 } from "zod";
var EventMatchHistory = z52.object({
  action: z52.string(),
  match: Match.nullish(),
  matchID: z52.string(),
  matchpool: z52.string(),
  namespace: z52.string(),
  podName: z52.string(),
  ruleSet: z52.string().nullish(),
  tickID: z52.string().nullish(),
  timestamp: z52.string()
});

// src/generated-definitions/XRayMatchHistorQueryResponse.ts
import { z as z53 } from "zod";
var XRayMatchHistorQueryResponse = z53.object({ data: z53.array(EventMatchHistory), paging: Pagination });

// src/generated-definitions/MatchLengthDuration.ts
import { z as z54 } from "zod";
var MatchLengthDuration = z54.object({
  createdAt: z54.string().nullish(),
  matchPool: z54.string().nullish(),
  namespace: z54.string().nullish(),
  value: z54.number().nullish()
});

// src/generated-definitions/XRayMatchLengthDurationQueryResponse.ts
import { z as z55 } from "zod";
var XRayMatchLengthDurationQueryResponse = z55.object({ data: z55.array(MatchLengthDuration) });

// src/generated-definitions/MatchMatchmaking.ts
import { z as z56 } from "zod";
var MatchMatchmaking = z56.object({
  createdAt: z56.string().nullish(),
  matchPool: z56.string().nullish(),
  namespace: z56.string().nullish(),
  value: z56.number().int().nullish()
});

// src/generated-definitions/XRayMatchMatchmakingQueryResponse.ts
import { z as z57 } from "zod";
var XRayMatchMatchmakingQueryResponse = z57.object({ data: z57.array(MatchMatchmaking) });

// src/generated-definitions/MatchMatchmakingTicket.ts
import { z as z58 } from "zod";
var MatchMatchmakingTicket = z58.object({
  createdAt: z58.string().nullish(),
  matchPool: z58.string().nullish(),
  namespace: z58.string().nullish(),
  value: z58.number().int().nullish()
});

// src/generated-definitions/XRayMatchMatchmakingTicketQueryResponse.ts
import { z as z59 } from "zod";
var XRayMatchMatchmakingTicketQueryResponse = z59.object({ data: z59.array(MatchMatchmakingTicket) });

// src/generated-definitions/XRayMatchPoolPodTickMatchResponse.ts
import { z as z60 } from "zod";
var XRayMatchPoolPodTickMatchResponse = z60.object({ data: z60.array(EventMatchHistory) });

// src/generated-definitions/XRayMatchPoolPodTickResult.ts
import { z as z61 } from "zod";
var XRayMatchPoolPodTickResult = z61.object({
  podName: z61.string(),
  tickId: z61.string(),
  timestamp: z61.string(),
  totalMatchBackfilled: z61.number().int(),
  totalMatchCreated: z61.number().int(),
  totalMatchToBackfill: z61.number().int(),
  totalTicketBackfilled: z61.number().int(),
  totalTicketForBackfill: z61.number().int(),
  totalTicketForMatch: z61.number().int(),
  totalTicketInQueue: z61.number().int(),
  totalTicketMatched: z61.number().int()
});

// src/generated-definitions/XRayMatchPoolPodTickQueryResponse.ts
import { z as z62 } from "zod";
var XRayMatchPoolPodTickQueryResponse = z62.object({ data: z62.array(XRayMatchPoolPodTickResult), paging: Pagination });

// src/generated-definitions/TicketStatus.ts
import { z as z63 } from "zod";
var TicketStatus = z63.object({ matched: z63.boolean(), ticket: Ticket });

// src/generated-definitions/XRayMatchPoolPodTickTicketResponse.ts
import { z as z64 } from "zod";
var XRayMatchPoolPodTickTicketResponse = z64.object({ data: z64.array(TicketStatus) });

// src/generated-definitions/XRayMatchPoolResult.ts
import { z as z65 } from "zod";
var XRayMatchPoolResult = z65.object({ podName: z65.string() });

// src/generated-definitions/XRayMatchPoolQueryResponse.ts
import { z as z66 } from "zod";
var XRayMatchPoolQueryResponse = z66.object({ data: z66.array(XRayMatchPoolResult) });

// src/generated-definitions/XRayMatchTicketHistory.ts
import { z as z67 } from "zod";
var XRayMatchTicketHistory = z67.object({
  action: z67.string(),
  match: EventMatchHistory.nullish(),
  ticket: Ticket.nullish(),
  timestamp: z67.string()
});

// src/generated-definitions/XRayMatchTicketHistoryQueryResponse.ts
import { z as z68 } from "zod";
var XRayMatchTicketHistoryQueryResponse = z68.object({ data: z68.array(XRayMatchTicketHistory) });

// src/generated-definitions/XRayTicketMatchesResult.ts
import { z as z69 } from "zod";
var XRayTicketMatchesResult = z69.object({
  CreatedAt: z69.string().nullish(),
  IsPivot: z69.boolean().nullish(),
  Latencies: z69.record(z69.number().int()).nullish(),
  MatchPool: z69.string().nullish(),
  MatchedAt: z69.string().nullish(),
  Namespace: z69.string().nullish(),
  PartySessionID: z69.string().nullish(),
  Players: z69.array(PlayerData).nullish(),
  ProposedProposal: ProposedProposal.nullish(),
  RegionPreference: z69.array(z69.string()).nullish(),
  TicketAttributes: z69.record(z69.any()).nullish(),
  TicketID: z69.string().nullish(),
  TimeToMatch: z69.number().nullish()
});

// src/generated-definitions/XRayMatchesQueryResponse.ts
import { z as z70 } from "zod";
var XRayMatchesQueryResponse = z70.object({ data: z70.array(XRayTicketMatchesResult) });

// src/generated-definitions/XRayTicketObservabilityResponse.ts
import { z as z71 } from "zod";
var XRayTicketObservabilityResponse = z71.object({ ticketID: z71.string() });

// src/generated-definitions/XRayTicketResult.ts
import { z as z72 } from "zod";
var XRayTicketResult = z72.object({
  elapsedTime: z72.number(),
  id: z72.string(),
  isBackfill: z72.boolean().nullish(),
  isPivot: z72.boolean().nullish(),
  matchpool: z72.string(),
  memberAttributes: z72.record(z72.any()).nullish(),
  podName: z72.string(),
  reason: z72.string(),
  region: z72.string(),
  tickId: z72.string(),
  ticketId: z72.string(),
  ticketStatus: z72.string(),
  timestamp: z72.string(),
  totalPlayers: z72.number().int().nullish()
});

// src/generated-definitions/XRayTicketQueryResponse.ts
import { z as z73 } from "zod";
var XRayTicketQueryResponse = z73.object({ data: z73.array(XRayTicketResult), paging: Pagination });

// src/generated-definitions/TotalActiveSession.ts
import { z as z74 } from "zod";
var TotalActiveSession = z74.object({
  createdAt: z74.string().nullish(),
  matchPool: z74.string().nullish(),
  namespace: z74.string().nullish(),
  region: z74.string().nullish(),
  value: z74.number().int().nullish()
});

// src/generated-definitions/XRayTotalActiveSessionQueryResponse.ts
import { z as z75 } from "zod";
var XRayTotalActiveSessionQueryResponse = z75.object({ data: z75.array(TotalActiveSession) });

// src/generated-definitions/TotalPlayerPersession.ts
import { z as z76 } from "zod";
var TotalPlayerPersession = z76.object({
  createdAt: z76.string().nullish(),
  matchPool: z76.string().nullish(),
  namespace: z76.string().nullish(),
  region: z76.string().nullish(),
  value: z76.number().nullish()
});

// src/generated-definitions/XRayTotalPlayerPersessionAvgQueryResponse.ts
import { z as z77 } from "zod";
var XRayTotalPlayerPersessionAvgQueryResponse = z77.object({ data: z77.array(TotalPlayerPersession) });

// src/generated-admin/endpoints/XRayAdmin$.ts
import { Validate as Validate3 } from "@accelbyte/sdk";
var XRayAdmin$ = class {
  // @ts-ignore
  // prettier-ignore
  constructor(axiosInstance, namespace, useSchemaValidation = true) {
    this.axiosInstance = axiosInstance;
    this.namespace = namespace;
    this.useSchemaValidation = useSchemaValidation;
  }
  /**
   * Create ticket observability request Request body details (all attributes are optional): Timestamp : timestamp when calling this endpoint Action : support one of the following value: 1. &#34;matchFound&#34; 2. &#34;matchNotFound&#34; 3. &#34;flexed&#34; TicketID : ticket ID MatchID : match ID will be filled only when match found Namespace : ticket current namespace GameMode : ticket current matchpool ActiveAllianceRule : current active alliance ruleset ActiveMatchingRule : current active matching ruleset Function : name of the function that called the endpoint Iteration : total iteration before match found TimeToMatchSec : time to match (in seconds) will be filled only when match found UnmatchReason : reason when unable to find match RemainingTickets : remaining ticket when unable to find match RemainingPlayersPerTicket : remaining players when unable to find match UnbackfillReason : reason when unable to backfill IsBackfillMatch : flag to distinguish between new match and backfill match IsRuleSetFlexed : flag if ruleset is getting flexed TickID : tick id for the matchmaking tick SessionTickID : session tick id for differentiate session when doing matches
   */
  createXrayTicket_v2(data) {
    const params = {};
    const url = "/sessionhistory/v2/admin/namespaces/{namespace}/xray/tickets".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.post(url, data, { params });
    return Validate3.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      XRayTicketObservabilityResponse,
      "XRayTicketObservabilityResponse"
    );
  }
  /**
   * Create bulk ticket observability request Request body details (all attributes are optional): Timestamp : timestamp when calling this endpoint Action : support one of the following value: 1. &#34;matchFound&#34; 2. &#34;matchNotFound&#34; 3. &#34;flexed&#34; PartyID : ticket Party ID MatchID : match ID will be filled only when match found Namespace : ticket current namespace GameMode : ticket current matchpool ActiveAllianceRule : current active alliance ruleset ActiveMatchingRule : current active matching ruleset Function : name of the function that called the endpoint Iteration : total iteration before match found TimeToMatchSec : time to match (in seconds) will be filled only when match found UnmatchReason : reason when unable to find match RemainingTickets : remaining ticket when unable to find match RemainingPlayersPerTicket : remaining players when unable to find match UnbackfillReason : reason when unable to backfill IsBackfillMatch : flag to distinguish between new match and backfill match IsRuleSetFlexed : flag if ruleset is getting flexed TickID : tick id for the matchmaking tick SessionTickID : session tick id for differentiate session when doing matches
   */
  createXrayTicketBulk_v2(data) {
    const params = {};
    const url = "/sessionhistory/v2/admin/namespaces/{namespace}/xray/tickets/bulk".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.post(url, data, { params });
    return Validate3.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      XRayBulkTicketObservabilityResponse,
      "XRayBulkTicketObservabilityResponse"
    );
  }
  /**
   * Query xray timeline by ticketID
   */
  getXrayTicket_ByTicketId_v2(ticketId, queryParams) {
    const params = { limit: 20, ...queryParams };
    const url = "/sessionhistory/v2/admin/namespaces/{namespace}/xray/tickets/{ticketId}".replace("{namespace}", this.namespace).replace("{ticketId}", ticketId);
    const resultPromise = this.axiosInstance.get(url, { params });
    return Validate3.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      XRayTicketQueryResponse,
      "XRayTicketQueryResponse"
    );
  }
  /**
   * Query total match.
   */
  getXrayMetricsTotalMatch_v2(queryParams) {
    const params = { ...queryParams };
    const url = "/sessionhistory/v2/admin/namespaces/{namespace}/xray/metrics/total-match".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.get(url, { params });
    return Validate3.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      XRayMatchMatchmakingQueryResponse,
      "XRayMatchMatchmakingQueryResponse"
    );
  }
  /**
   * Query total success and failed claim DS.
   */
  getXrayMetricsAcquiringDs_v2(queryParams) {
    const params = { ...queryParams };
    const url = "/sessionhistory/v2/admin/namespaces/{namespace}/xray/metrics/acquiring-ds".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.get(url, { params });
    return Validate3.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      XRayAcquiringDsQueryResponse,
      "XRayAcquiringDsQueryResponse"
    );
  }
  /**
   * Query xray match pool. query can using matchpool array with separate &#34;,&#34;
   */
  getXrayMatchPool_ByPoolName_v2(poolName, queryParams) {
    const params = { ...queryParams };
    const url = "/sessionhistory/v2/admin/namespaces/{namespace}/xray/match-pools/{poolName}".replace("{namespace}", this.namespace).replace("{poolName}", String(poolName));
    const resultPromise = this.axiosInstance.get(url, { params });
    return Validate3.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      XRayMatchPoolQueryResponse,
      "XRayMatchPoolQueryResponse"
    );
  }
  /**
   * Query xray timeline by userID or ticketID
   */
  getTicketsXray_ByUserId_v2(userId, queryParams) {
    const params = { limit: 20, ...queryParams };
    const url = "/sessionhistory/v2/admin/namespaces/{namespace}/xray/users/{userId}/tickets".replace("{namespace}", this.namespace).replace("{userId}", userId);
    const resultPromise = this.axiosInstance.get(url, { params });
    return Validate3.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      XRayTicketQueryResponse,
      "XRayTicketQueryResponse"
    );
  }
  /**
   * Query xray timeline by matchID.
   */
  getTicketsXray_ByMatchId_v2(matchId) {
    const params = {};
    const url = "/sessionhistory/v2/admin/namespaces/{namespace}/xray/matches/{matchId}/tickets".replace("{namespace}", this.namespace).replace("{matchId}", matchId);
    const resultPromise = this.axiosInstance.get(url, { params });
    return Validate3.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      XRayMatchesQueryResponse,
      "XRayMatchesQueryResponse"
    );
  }
  /**
   * Query total ticket match.
   */
  getXrayMetricsTotalTicketMatch_v2(queryParams) {
    const params = { ...queryParams };
    const url = "/sessionhistory/v2/admin/namespaces/{namespace}/xray/metrics/total-ticket-match".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.get(url, { params });
    return Validate3.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      XRayMatchMatchmakingTicketQueryResponse,
      "XRayMatchMatchmakingTicketQueryResponse"
    );
  }
  /**
   * Query xray match histories.
   */
  getHistoriesXray_ByMatchId_v2(matchId, queryParams) {
    const params = { limit: 20, ...queryParams };
    const url = "/sessionhistory/v2/admin/namespaces/{namespace}/xray/matches/{matchId}/histories".replace("{namespace}", this.namespace).replace("{matchId}", matchId);
    const resultPromise = this.axiosInstance.get(url, { params });
    return Validate3.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      XRayMatchHistorQueryResponse,
      "XRayMatchHistorQueryResponse"
    );
  }
  /**
   * Query total active session.
   */
  getXrayMetricsTotalActiveSession_v2(queryParams) {
    const params = { ...queryParams };
    const url = "/sessionhistory/v2/admin/namespaces/{namespace}/xray/metrics/total-active-session".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.get(url, { params });
    return Validate3.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      XRayTotalActiveSessionQueryResponse,
      "XRayTotalActiveSessionQueryResponse"
    );
  }
  /**
   * Query total ticket created.
   */
  getXrayMetricsTotalTicketCreated_v2(queryParams) {
    const params = { ...queryParams };
    const url = "/sessionhistory/v2/admin/namespaces/{namespace}/xray/metrics/total-ticket-created".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.get(url, { params });
    return Validate3.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      XRayCreatedMatchmakingTicketQueryResponse,
      "XRayCreatedMatchmakingTicketQueryResponse"
    );
  }
  /**
   * Query total ticket expired.
   */
  getXrayMetricsTotalTicketExpired_v2(queryParams) {
    const params = { ...queryParams };
    const url = "/sessionhistory/v2/admin/namespaces/{namespace}/xray/metrics/total-ticket-expired".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.get(url, { params });
    return Validate3.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      XRayExpiredMatchmakingTicketQueryResponse,
      "XRayExpiredMatchmakingTicketQueryResponse"
    );
  }
  /**
   * Query total ticket canceled.
   */
  getXrayMetricsTotalTicketCanceled_v2(queryParams) {
    const params = { ...queryParams };
    const url = "/sessionhistory/v2/admin/namespaces/{namespace}/xray/metrics/total-ticket-canceled".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.get(url, { params });
    return Validate3.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      XRayCanceledMatchmakingTicketQueryResponse,
      "XRayCanceledMatchmakingTicketQueryResponse"
    );
  }
  /**
   * Query match length duration avg. time in seconds
   */
  getXrayMetricsMatchLengthDurationAvg_v2(queryParams) {
    const params = { ...queryParams };
    const url = "/sessionhistory/v2/admin/namespaces/{namespace}/xray/metrics/match-length-duration-avg".replace(
      "{namespace}",
      this.namespace
    );
    const resultPromise = this.axiosInstance.get(url, { params });
    return Validate3.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      XRayMatchLengthDurationQueryResponse,
      "XRayMatchLengthDurationQueryResponse"
    );
  }
  /**
   * Query match length duration p99. time in seconds
   */
  getXrayMetricsMatchLengthDurationP99_v2(queryParams) {
    const params = { ...queryParams };
    const url = "/sessionhistory/v2/admin/namespaces/{namespace}/xray/metrics/match-length-duration-p99".replace(
      "{namespace}",
      this.namespace
    );
    const resultPromise = this.axiosInstance.get(url, { params });
    return Validate3.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      XRayMatchLengthDurationQueryResponse,
      "XRayMatchLengthDurationQueryResponse"
    );
  }
  /**
   * Query xray match ticket histories.
   */
  getTicketHistoriesXray_ByMatchId_v2(matchId) {
    const params = {};
    const url = "/sessionhistory/v2/admin/namespaces/{namespace}/xray/matches/{matchId}/ticket-histories".replace("{namespace}", this.namespace).replace("{matchId}", matchId);
    const resultPromise = this.axiosInstance.get(url, { params });
    return Validate3.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      XRayMatchTicketHistoryQueryResponse,
      "XRayMatchTicketHistoryQueryResponse"
    );
  }
  /**
   * Query acquiring ds wait time average. time in seconds
   */
  getXrayMetricsAcquiringDsWaitTimeAvg_v2(queryParams) {
    const params = { ...queryParams };
    const url = "/sessionhistory/v2/admin/namespaces/{namespace}/xray/metrics/acquiring-ds-wait-time-avg".replace(
      "{namespace}",
      this.namespace
    );
    const resultPromise = this.axiosInstance.get(url, { params });
    return Validate3.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      XRayAcquiringDsWaitTimeQueryResponse,
      "XRayAcquiringDsWaitTimeQueryResponse"
    );
  }
  /**
   * Query total player persession average.
   */
  getXrayMetricsTotalPlayerPersessionAvg_v2(queryParams) {
    const params = { ...queryParams };
    const url = "/sessionhistory/v2/admin/namespaces/{namespace}/xray/metrics/total-player-persession-avg".replace(
      "{namespace}",
      this.namespace
    );
    const resultPromise = this.axiosInstance.get(url, { params });
    return Validate3.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      XRayTotalPlayerPersessionAvgQueryResponse,
      "XRayTotalPlayerPersessionAvgQueryResponse"
    );
  }
  /**
   * Query xray match pool ticks.
   */
  getTicksXray_ByPoolName_ByPodName_v2(poolName, podName, queryParams) {
    const params = { limit: 20, ...queryParams };
    const url = "/sessionhistory/v2/admin/namespaces/{namespace}/xray/match-pools/{poolName}/pods/{podName}/ticks".replace("{namespace}", this.namespace).replace("{poolName}", poolName).replace("{podName}", podName);
    const resultPromise = this.axiosInstance.get(url, { params });
    return Validate3.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      XRayMatchPoolPodTickQueryResponse,
      "XRayMatchPoolPodTickQueryResponse"
    );
  }
  /**
   * Query xray match pool tick matches by tick id.
   */
  getMatchesXray_ByPoolName_ByPodName_ByTickId_v2(poolName, podName, tickId) {
    const params = {};
    const url = "/sessionhistory/v2/admin/namespaces/{namespace}/xray/match-pools/{poolName}/pods/{podName}/ticks/{tickId}/matches".replace("{namespace}", this.namespace).replace("{poolName}", poolName).replace("{podName}", podName).replace("{tickId}", tickId);
    const resultPromise = this.axiosInstance.get(url, { params });
    return Validate3.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      XRayMatchPoolPodTickMatchResponse,
      "XRayMatchPoolPodTickMatchResponse"
    );
  }
  /**
   * Query xray match pool tick tickets detail by tick id.
   */
  getTicketsXray_ByPoolName_ByPodName_ByTickId_v2(poolName, podName, tickId) {
    const params = {};
    const url = "/sessionhistory/v2/admin/namespaces/{namespace}/xray/match-pools/{poolName}/pods/{podName}/ticks/{tickId}/tickets".replace("{namespace}", this.namespace).replace("{poolName}", poolName).replace("{podName}", podName).replace("{tickId}", tickId);
    const resultPromise = this.axiosInstance.get(url, { params });
    return Validate3.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      XRayMatchPoolPodTickTicketResponse,
      "XRayMatchPoolPodTickTicketResponse"
    );
  }
};

// src/generated-admin/GameSessionDetailAdminApi.ts
import { ApiUtils as ApiUtils2, Network as Network2 } from "@accelbyte/sdk";
function GameSessionDetailAdminApi(sdk, args) {
  const sdkAssembly = sdk.assembly();
  const namespace = args?.coreConfig?.namespace ?? sdkAssembly.coreConfig.namespace;
  const useSchemaValidation = args?.coreConfig?.useSchemaValidation ?? sdkAssembly.coreConfig.useSchemaValidation;
  let axiosInstance = sdkAssembly.axiosInstance;
  const requestConfigOverrides = args?.axiosConfig?.request;
  const baseURLOverride = args?.coreConfig?.baseURL;
  const interceptorsOverride = args?.axiosConfig?.interceptors ?? [];
  if (requestConfigOverrides || baseURLOverride || interceptorsOverride.length > 0) {
    const requestConfig = ApiUtils2.mergeAxiosConfigs(sdkAssembly.axiosInstance.defaults, {
      ...baseURLOverride ? { baseURL: baseURLOverride } : {},
      ...requestConfigOverrides
    });
    axiosInstance = Network2.create(requestConfig);
    for (const interceptor of interceptorsOverride) {
      if (interceptor.type === "request") {
        axiosInstance.interceptors.request.use(interceptor.onRequest, interceptor.onError);
      }
      if (interceptor.type === "response") {
        axiosInstance.interceptors.response.use(interceptor.onSuccess, interceptor.onError);
      }
    }
  }
  async function getParties(queryParams) {
    const $ = new GameSessionDetailAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getParties(queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getTickets(queryParams) {
    const $ = new GameSessionDetailAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getTickets(queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getMatchmaking(queryParams) {
    const $ = new GameSessionDetailAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getMatchmaking(queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getGamesessions(queryParams) {
    const $ = new GameSessionDetailAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getGamesessions(queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getTicket_ByTicketId(ticketId) {
    const $ = new GameSessionDetailAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getTicket_ByTicketId(ticketId);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getParty_BySessionId(sessionId) {
    const $ = new GameSessionDetailAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getParty_BySessionId(sessionId);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getGamesession_BySessionId(sessionId) {
    const $ = new GameSessionDetailAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getGamesession_BySessionId(sessionId);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getMatchmakingTicket_ByTicketId(ticketId) {
    const $ = new GameSessionDetailAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getMatchmakingTicket_ByTicketId(ticketId);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getMatchmakingSession_BySessionId(sessionId) {
    const $ = new GameSessionDetailAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getMatchmakingSession_BySessionId(sessionId);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  return {
    /**
     * Get all parties.
     */
    getParties,
    /**
     * Get all matchmaking ticket.
     */
    getTickets,
    /**
     * Get all matchmaking.
     */
    getMatchmaking,
    /**
     * Get all game sessions.
     */
    getGamesessions,
    /**
     * Get detail matchmaking ticket history by ticket ID.
     */
    getTicket_ByTicketId,
    /**
     * Get party detail.
     */
    getParty_BySessionId,
    /**
     * Get game session detail.
     */
    getGamesession_BySessionId,
    /**
     * Get detail matchmaking history by ticket ID.
     */
    getMatchmakingTicket_ByTicketId,
    /**
     * Get detail matchmaking history by session ID.
     */
    getMatchmakingSession_BySessionId
  };
}

// src/generated-admin/XRayAdminApi.ts
import { ApiUtils as ApiUtils3, Network as Network3 } from "@accelbyte/sdk";
function XRayAdminApi(sdk, args) {
  const sdkAssembly = sdk.assembly();
  const namespace = args?.coreConfig?.namespace ?? sdkAssembly.coreConfig.namespace;
  const useSchemaValidation = args?.coreConfig?.useSchemaValidation ?? sdkAssembly.coreConfig.useSchemaValidation;
  let axiosInstance = sdkAssembly.axiosInstance;
  const requestConfigOverrides = args?.axiosConfig?.request;
  const baseURLOverride = args?.coreConfig?.baseURL;
  const interceptorsOverride = args?.axiosConfig?.interceptors ?? [];
  if (requestConfigOverrides || baseURLOverride || interceptorsOverride.length > 0) {
    const requestConfig = ApiUtils3.mergeAxiosConfigs(sdkAssembly.axiosInstance.defaults, {
      ...baseURLOverride ? { baseURL: baseURLOverride } : {},
      ...requestConfigOverrides
    });
    axiosInstance = Network3.create(requestConfig);
    for (const interceptor of interceptorsOverride) {
      if (interceptor.type === "request") {
        axiosInstance.interceptors.request.use(interceptor.onRequest, interceptor.onError);
      }
      if (interceptor.type === "response") {
        axiosInstance.interceptors.response.use(interceptor.onSuccess, interceptor.onError);
      }
    }
  }
  async function createXrayTicket_v2(data) {
    const $ = new XRayAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.createXrayTicket_v2(data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function createXrayTicketBulk_v2(data) {
    const $ = new XRayAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.createXrayTicketBulk_v2(data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getXrayTicket_ByTicketId_v2(ticketId, queryParams) {
    const $ = new XRayAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getXrayTicket_ByTicketId_v2(ticketId, queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getXrayMetricsTotalMatch_v2(queryParams) {
    const $ = new XRayAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getXrayMetricsTotalMatch_v2(queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getXrayMetricsAcquiringDs_v2(queryParams) {
    const $ = new XRayAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getXrayMetricsAcquiringDs_v2(queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getXrayMatchPool_ByPoolName_v2(poolName, queryParams) {
    const $ = new XRayAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getXrayMatchPool_ByPoolName_v2(poolName, queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getTicketsXray_ByUserId_v2(userId, queryParams) {
    const $ = new XRayAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getTicketsXray_ByUserId_v2(userId, queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getTicketsXray_ByMatchId_v2(matchId) {
    const $ = new XRayAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getTicketsXray_ByMatchId_v2(matchId);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getXrayMetricsTotalTicketMatch_v2(queryParams) {
    const $ = new XRayAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getXrayMetricsTotalTicketMatch_v2(queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getHistoriesXray_ByMatchId_v2(matchId, queryParams) {
    const $ = new XRayAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getHistoriesXray_ByMatchId_v2(matchId, queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getXrayMetricsTotalActiveSession_v2(queryParams) {
    const $ = new XRayAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getXrayMetricsTotalActiveSession_v2(queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getXrayMetricsTotalTicketCreated_v2(queryParams) {
    const $ = new XRayAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getXrayMetricsTotalTicketCreated_v2(queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getXrayMetricsTotalTicketExpired_v2(queryParams) {
    const $ = new XRayAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getXrayMetricsTotalTicketExpired_v2(queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getXrayMetricsTotalTicketCanceled_v2(queryParams) {
    const $ = new XRayAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getXrayMetricsTotalTicketCanceled_v2(queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getXrayMetricsMatchLengthDurationAvg_v2(queryParams) {
    const $ = new XRayAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getXrayMetricsMatchLengthDurationAvg_v2(queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getXrayMetricsMatchLengthDurationP99_v2(queryParams) {
    const $ = new XRayAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getXrayMetricsMatchLengthDurationP99_v2(queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getTicketHistoriesXray_ByMatchId_v2(matchId) {
    const $ = new XRayAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getTicketHistoriesXray_ByMatchId_v2(matchId);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getXrayMetricsAcquiringDsWaitTimeAvg_v2(queryParams) {
    const $ = new XRayAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getXrayMetricsAcquiringDsWaitTimeAvg_v2(queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getXrayMetricsTotalPlayerPersessionAvg_v2(queryParams) {
    const $ = new XRayAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getXrayMetricsTotalPlayerPersessionAvg_v2(queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getTicksXray_ByPoolName_ByPodName_v2(poolName, podName, queryParams) {
    const $ = new XRayAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getTicksXray_ByPoolName_ByPodName_v2(poolName, podName, queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getMatchesXray_ByPoolName_ByPodName_ByTickId_v2(poolName, podName, tickId) {
    const $ = new XRayAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getMatchesXray_ByPoolName_ByPodName_ByTickId_v2(poolName, podName, tickId);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getTicketsXray_ByPoolName_ByPodName_ByTickId_v2(poolName, podName, tickId) {
    const $ = new XRayAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getTicketsXray_ByPoolName_ByPodName_ByTickId_v2(poolName, podName, tickId);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  return {
    /**
     * Create ticket observability request Request body details (all attributes are optional): Timestamp : timestamp when calling this endpoint Action : support one of the following value: 1. &#34;matchFound&#34; 2. &#34;matchNotFound&#34; 3. &#34;flexed&#34; TicketID : ticket ID MatchID : match ID will be filled only when match found Namespace : ticket current namespace GameMode : ticket current matchpool ActiveAllianceRule : current active alliance ruleset ActiveMatchingRule : current active matching ruleset Function : name of the function that called the endpoint Iteration : total iteration before match found TimeToMatchSec : time to match (in seconds) will be filled only when match found UnmatchReason : reason when unable to find match RemainingTickets : remaining ticket when unable to find match RemainingPlayersPerTicket : remaining players when unable to find match UnbackfillReason : reason when unable to backfill IsBackfillMatch : flag to distinguish between new match and backfill match IsRuleSetFlexed : flag if ruleset is getting flexed TickID : tick id for the matchmaking tick SessionTickID : session tick id for differentiate session when doing matches
     */
    createXrayTicket_v2,
    /**
     * Create bulk ticket observability request Request body details (all attributes are optional): Timestamp : timestamp when calling this endpoint Action : support one of the following value: 1. &#34;matchFound&#34; 2. &#34;matchNotFound&#34; 3. &#34;flexed&#34; PartyID : ticket Party ID MatchID : match ID will be filled only when match found Namespace : ticket current namespace GameMode : ticket current matchpool ActiveAllianceRule : current active alliance ruleset ActiveMatchingRule : current active matching ruleset Function : name of the function that called the endpoint Iteration : total iteration before match found TimeToMatchSec : time to match (in seconds) will be filled only when match found UnmatchReason : reason when unable to find match RemainingTickets : remaining ticket when unable to find match RemainingPlayersPerTicket : remaining players when unable to find match UnbackfillReason : reason when unable to backfill IsBackfillMatch : flag to distinguish between new match and backfill match IsRuleSetFlexed : flag if ruleset is getting flexed TickID : tick id for the matchmaking tick SessionTickID : session tick id for differentiate session when doing matches
     */
    createXrayTicketBulk_v2,
    /**
     * Query xray timeline by ticketID
     */
    getXrayTicket_ByTicketId_v2,
    /**
     * Query total match.
     */
    getXrayMetricsTotalMatch_v2,
    /**
     * Query total success and failed claim DS.
     */
    getXrayMetricsAcquiringDs_v2,
    /**
     * Query xray match pool. query can using matchpool array with separate &#34;,&#34;
     */
    getXrayMatchPool_ByPoolName_v2,
    /**
     * Query xray timeline by userID or ticketID
     */
    getTicketsXray_ByUserId_v2,
    /**
     * Query xray timeline by matchID.
     */
    getTicketsXray_ByMatchId_v2,
    /**
     * Query total ticket match.
     */
    getXrayMetricsTotalTicketMatch_v2,
    /**
     * Query xray match histories.
     */
    getHistoriesXray_ByMatchId_v2,
    /**
     * Query total active session.
     */
    getXrayMetricsTotalActiveSession_v2,
    /**
     * Query total ticket created.
     */
    getXrayMetricsTotalTicketCreated_v2,
    /**
     * Query total ticket expired.
     */
    getXrayMetricsTotalTicketExpired_v2,
    /**
     * Query total ticket canceled.
     */
    getXrayMetricsTotalTicketCanceled_v2,
    /**
     * Query match length duration avg. time in seconds
     */
    getXrayMetricsMatchLengthDurationAvg_v2,
    /**
     * Query match length duration p99. time in seconds
     */
    getXrayMetricsMatchLengthDurationP99_v2,
    /**
     * Query xray match ticket histories.
     */
    getTicketHistoriesXray_ByMatchId_v2,
    /**
     * Query acquiring ds wait time average. time in seconds
     */
    getXrayMetricsAcquiringDsWaitTimeAvg_v2,
    /**
     * Query total player persession average.
     */
    getXrayMetricsTotalPlayerPersessionAvg_v2,
    /**
     * Query xray match pool ticks.
     */
    getTicksXray_ByPoolName_ByPodName_v2,
    /**
     * Query xray match pool tick matches by tick id.
     */
    getMatchesXray_ByPoolName_ByPodName_ByTickId_v2,
    /**
     * Query xray match pool tick tickets detail by tick id.
     */
    getTicketsXray_ByPoolName_ByPodName_ByTickId_v2
  };
}

// src/generated-public/endpoints/GameSessionDetail$.ts
import { Validate as Validate4 } from "@accelbyte/sdk";
var GameSessionDetail$ = class {
  // @ts-ignore
  // prettier-ignore
  constructor(axiosInstance, namespace, useSchemaValidation = true) {
    this.axiosInstance = axiosInstance;
    this.namespace = namespace;
    this.useSchemaValidation = useSchemaValidation;
  }
  /**
   * Get all game sessions history for current user.
   */
  getUsersMeGamesessions(queryParams) {
    const params = { limit: 20, ...queryParams };
    const url = "/sessionhistory/v1/public/namespaces/{namespace}/users/me/gamesessions".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.get(url, { params });
    return Validate4.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      GameSessionDetailQueryResponse,
      "GameSessionDetailQueryResponse"
    );
  }
};

// src/generated-public/GameSessionDetailApi.ts
import { ApiUtils as ApiUtils4, Network as Network4 } from "@accelbyte/sdk";
function GameSessionDetailApi(sdk, args) {
  const sdkAssembly = sdk.assembly();
  const namespace = args?.coreConfig?.namespace ?? sdkAssembly.coreConfig.namespace;
  const useSchemaValidation = args?.coreConfig?.useSchemaValidation ?? sdkAssembly.coreConfig.useSchemaValidation;
  let axiosInstance = sdkAssembly.axiosInstance;
  const requestConfigOverrides = args?.axiosConfig?.request;
  const baseURLOverride = args?.coreConfig?.baseURL;
  const interceptorsOverride = args?.axiosConfig?.interceptors ?? [];
  if (requestConfigOverrides || baseURLOverride || interceptorsOverride.length > 0) {
    const requestConfig = ApiUtils4.mergeAxiosConfigs(sdkAssembly.axiosInstance.defaults, {
      ...baseURLOverride ? { baseURL: baseURLOverride } : {},
      ...requestConfigOverrides
    });
    axiosInstance = Network4.create(requestConfig);
    for (const interceptor of interceptorsOverride) {
      if (interceptor.type === "request") {
        axiosInstance.interceptors.request.use(interceptor.onRequest, interceptor.onError);
      }
      if (interceptor.type === "response") {
        axiosInstance.interceptors.response.use(interceptor.onSuccess, interceptor.onError);
      }
    }
  }
  async function getUsersMeGamesessions(queryParams) {
    const $ = new GameSessionDetail$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getUsersMeGamesessions(queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  return {
    /**
     * Get all game sessions history for current user.
     */
    getUsersMeGamesessions
  };
}

export {
  Configuration,
  ConfigAdmin$,
  ConfigAdminApi,
  GameServer,
  DsInformation,
  PartyMembers,
  GameSessionTeam,
  SessionConfig,
  User,
  GameSession,
  History,
  GameSessionDetail,
  Pagination,
  GameSessionDetailQueryResponse,
  PartyTeam,
  Team,
  PlayerData,
  ProposedProposal,
  Ticket,
  BackfillProposal,
  MatchTicket,
  Match,
  BackfillTicket,
  MatchmakingHistory,
  MatchmakingDetail,
  MatchmakingDetailQueryResponse,
  SessionConfiguration,
  Party,
  PartyHistory,
  PartyDetail,
  PartyDetailQueryResponse,
  AllianceRule,
  MatchingRule,
  PartyMember,
  MatchingParty,
  MatchingAlly,
  MatchmakingResult,
  TicketData,
  TicketObservability,
  TicketObservabilityHistory,
  TicketObservabilityDetail,
  TicketDetailQueryResponse,
  GameSessionDetailAdmin$,
  AcquiringDs,
  XRayAcquiringDsQueryResponse,
  AcquiringDsWaitTime,
  XRayAcquiringDsWaitTimeQueryResponse,
  XRayBulkTicketObservabilityResponse,
  CanceledMatchmakingTicket,
  XRayCanceledMatchmakingTicketQueryResponse,
  CreatedMatchmakingTicket,
  XRayCreatedMatchmakingTicketQueryResponse,
  ExpiredMatchmakingTicket,
  XRayExpiredMatchmakingTicketQueryResponse,
  EventMatchHistory,
  XRayMatchHistorQueryResponse,
  MatchLengthDuration,
  XRayMatchLengthDurationQueryResponse,
  MatchMatchmaking,
  XRayMatchMatchmakingQueryResponse,
  MatchMatchmakingTicket,
  XRayMatchMatchmakingTicketQueryResponse,
  XRayMatchPoolPodTickMatchResponse,
  XRayMatchPoolPodTickResult,
  XRayMatchPoolPodTickQueryResponse,
  TicketStatus,
  XRayMatchPoolPodTickTicketResponse,
  XRayMatchPoolResult,
  XRayMatchPoolQueryResponse,
  XRayMatchTicketHistory,
  XRayMatchTicketHistoryQueryResponse,
  XRayTicketMatchesResult,
  XRayMatchesQueryResponse,
  XRayTicketObservabilityResponse,
  XRayTicketResult,
  XRayTicketQueryResponse,
  TotalActiveSession,
  XRayTotalActiveSessionQueryResponse,
  TotalPlayerPersession,
  XRayTotalPlayerPersessionAvgQueryResponse,
  XRayAdmin$,
  GameSessionDetailAdminApi,
  XRayAdminApi,
  GameSessionDetail$,
  GameSessionDetailApi
};

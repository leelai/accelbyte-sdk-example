"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/all-query-imports.ts
var all_query_imports_exports = {};
__export(all_query_imports_exports, {
  Key_Admin: () => Key_Admin,
  Key_AdminAdmin: () => Key_AdminAdmin,
  Key_Blocks: () => Key_Blocks,
  Key_ConfigAdmin: () => Key_ConfigAdmin,
  Key_Friends: () => Key_Friends,
  Key_FriendsAdmin: () => Key_FriendsAdmin,
  Key_LobbyOperations: () => Key_LobbyOperations,
  Key_LobbyOperationsAdmin: () => Key_LobbyOperationsAdmin,
  Key_Notification: () => Key_Notification,
  Key_NotificationAdmin: () => Key_NotificationAdmin,
  Key_Party: () => Key_Party,
  Key_PartyAdmin: () => Key_PartyAdmin,
  Key_Player: () => Key_Player,
  Key_PlayerAdmin: () => Key_PlayerAdmin,
  Key_Presence: () => Key_Presence,
  Key_ProfanityAdmin: () => Key_ProfanityAdmin,
  Key_ThirdPartyAdmin: () => Key_ThirdPartyAdmin,
  useAdminAdminApi_DeleteGlobalConfigurationMutation: () => useAdminAdminApi_DeleteGlobalConfigurationMutation,
  useAdminAdminApi_GetGlobalConfigurations: () => useAdminAdminApi_GetGlobalConfigurations,
  useAdminAdminApi_UpdateGlobalConfigurationMutation: () => useAdminAdminApi_UpdateGlobalConfigurationMutation,
  useAdminApi_CreateNotificationFreeformMutation: () => useAdminApi_CreateNotificationFreeformMutation,
  useAdminApi_CreateNotificationTemplateMutation: () => useAdminApi_CreateNotificationTemplateMutation,
  useAdminApi_CreateNotificationTemplatedMutation: () => useAdminApi_CreateNotificationTemplatedMutation,
  useAdminApi_CreatePublishNotification_ByTemplateSlug_ByTemplateLanguageMutation: () => useAdminApi_CreatePublishNotification_ByTemplateSlug_ByTemplateLanguageMutation,
  useAdminApi_DeleteLanguageNotification_ByTemplateSlug_ByTemplateLanguageMutation: () => useAdminApi_DeleteLanguageNotification_ByTemplateSlug_ByTemplateLanguageMutation,
  useAdminApi_DeleteNotificationTemplate_ByTemplateSlugMutation: () => useAdminApi_DeleteNotificationTemplate_ByTemplateSlugMutation,
  useAdminApi_GetLanguageNotification_ByTemplateSlug_ByTemplateLanguage: () => useAdminApi_GetLanguageNotification_ByTemplateSlug_ByTemplateLanguage,
  useAdminApi_GetNotificationTemplate_ByTemplateSlug: () => useAdminApi_GetNotificationTemplate_ByTemplateSlug,
  useAdminApi_GetNotificationTemplates: () => useAdminApi_GetNotificationTemplates,
  useAdminApi_UpdateLanguageNotification_ByTemplateSlug_ByTemplateLanguageMutation: () => useAdminApi_UpdateLanguageNotification_ByTemplateSlug_ByTemplateLanguageMutation,
  useBlocksApi_PatchSyncMeBlockMutation: () => useBlocksApi_PatchSyncMeBlockMutation,
  useConfigAdminApi_GetConfig: () => useConfigAdminApi_GetConfig,
  useConfigAdminApi_GetConfigExport: () => useConfigAdminApi_GetConfigExport,
  useConfigAdminApi_GetConfigLog: () => useConfigAdminApi_GetConfigLog,
  useConfigAdminApi_GetConfig_ByNamespace: () => useConfigAdminApi_GetConfig_ByNamespace,
  useConfigAdminApi_PatchConfigLogMutation: () => useConfigAdminApi_PatchConfigLogMutation,
  useConfigAdminApi_UpdateConfigImportMutation: () => useConfigAdminApi_UpdateConfigImportMutation,
  useConfigAdminApi_UpdateConfig_ByNamespaceMutation: () => useConfigAdminApi_UpdateConfig_ByNamespaceMutation,
  useFriendsAdminApi_GetFriendUser_ByUserId: () => useFriendsAdminApi_GetFriendUser_ByUserId,
  useFriendsAdminApi_GetIncomingFriend_ByUserId: () => useFriendsAdminApi_GetIncomingFriend_ByUserId,
  useFriendsAdminApi_GetOfFriends_ByUserId: () => useFriendsAdminApi_GetOfFriends_ByUserId,
  useFriendsAdminApi_GetOutgoingFriend_ByUserId: () => useFriendsAdminApi_GetOutgoingFriend_ByUserId,
  useFriendsApi_CreateAddBulkFriend_ByUserIdMutation: () => useFriendsApi_CreateAddBulkFriend_ByUserIdMutation,
  useFriendsApi_CreateDeleteBulkFriend_ByUserIdMutation: () => useFriendsApi_CreateDeleteBulkFriend_ByUserIdMutation,
  useFriendsApi_CreateFriendMeRequestAcceptMutation: () => useFriendsApi_CreateFriendMeRequestAcceptMutation,
  useFriendsApi_CreateFriendMeRequestCancelMutation: () => useFriendsApi_CreateFriendMeRequestCancelMutation,
  useFriendsApi_CreateFriendMeRequestMutation: () => useFriendsApi_CreateFriendMeRequestMutation,
  useFriendsApi_CreateFriendMeRequestRejectMutation: () => useFriendsApi_CreateFriendMeRequestRejectMutation,
  useFriendsApi_CreateFriendMeUnfriendMutation: () => useFriendsApi_CreateFriendMeUnfriendMutation,
  useFriendsApi_GetFriendMeStatu_ByFriendId: () => useFriendsApi_GetFriendMeStatu_ByFriendId,
  useFriendsApi_GetFriendsMe: () => useFriendsApi_GetFriendsMe,
  useFriendsApi_GetFriendsMeIncoming: () => useFriendsApi_GetFriendsMeIncoming,
  useFriendsApi_GetFriendsMeIncomingTime: () => useFriendsApi_GetFriendsMeIncomingTime,
  useFriendsApi_GetFriendsMeOutgoing: () => useFriendsApi_GetFriendsMeOutgoing,
  useFriendsApi_GetFriendsMeOutgoingTime: () => useFriendsApi_GetFriendsMeOutgoingTime,
  useFriendsApi_GetFriendsMePlatforms: () => useFriendsApi_GetFriendsMePlatforms,
  useFriendsApi_PatchFriendSyncMeMutation: () => useFriendsApi_PatchFriendSyncMeMutation,
  useLobbyOperationsAdminApi_UpdateAttributeParty_ByPartyIdMutation: () => useLobbyOperationsAdminApi_UpdateAttributeParty_ByPartyIdMutation,
  useLobbyOperationsAdminApi_UpdateJoinParty_ByPartyId_ByUserIdMutation: () => useLobbyOperationsAdminApi_UpdateJoinParty_ByPartyId_ByUserIdMutation,
  useLobbyOperationsApi_GetMessages: () => useLobbyOperationsApi_GetMessages,
  useNotificationAdminApi_CreateFreeformNotifyNotification_ByPartyIdMutation: () => useNotificationAdminApi_CreateFreeformNotifyNotification_ByPartyIdMutation,
  useNotificationAdminApi_CreateFreeformNotifyNotification_ByUserIdMutation: () => useNotificationAdminApi_CreateFreeformNotifyNotification_ByUserIdMutation,
  useNotificationAdminApi_CreateNotificationBulkUserFreeformNotifyMutation: () => useNotificationAdminApi_CreateNotificationBulkUserFreeformNotifyMutation,
  useNotificationAdminApi_CreateNotificationFreeformNotifyMutation: () => useNotificationAdminApi_CreateNotificationFreeformNotifyMutation,
  useNotificationAdminApi_CreateNotificationTemplateMutation: () => useNotificationAdminApi_CreateNotificationTemplateMutation,
  useNotificationAdminApi_CreateNotificationTemplateNotifyMutation: () => useNotificationAdminApi_CreateNotificationTemplateNotifyMutation,
  useNotificationAdminApi_CreateNotificationTopicMutation: () => useNotificationAdminApi_CreateNotificationTopicMutation,
  useNotificationAdminApi_CreatePublishNotification_ByTemplateSlug_ByTemplateLanguageMutation: () => useNotificationAdminApi_CreatePublishNotification_ByTemplateSlug_ByTemplateLanguageMutation,
  useNotificationAdminApi_CreateTemplateNotifyNotification_ByPartyIdMutation: () => useNotificationAdminApi_CreateTemplateNotifyNotification_ByPartyIdMutation,
  useNotificationAdminApi_CreateTemplateNotifyNotification_ByUserIdMutation: () => useNotificationAdminApi_CreateTemplateNotifyNotification_ByUserIdMutation,
  useNotificationAdminApi_DeleteLanguageNotification_ByTemplateSlug_ByTemplateLanguageMutation: () => useNotificationAdminApi_DeleteLanguageNotification_ByTemplateSlug_ByTemplateLanguageMutation,
  useNotificationAdminApi_DeleteNotificationTemplate_ByTemplateSlugMutation: () => useNotificationAdminApi_DeleteNotificationTemplate_ByTemplateSlugMutation,
  useNotificationAdminApi_DeleteNotificationTopic_ByTopicNameMutation: () => useNotificationAdminApi_DeleteNotificationTopic_ByTopicNameMutation,
  useNotificationAdminApi_GetLanguageNotification_ByTemplateSlug_ByTemplateLanguage: () => useNotificationAdminApi_GetLanguageNotification_ByTemplateSlug_ByTemplateLanguage,
  useNotificationAdminApi_GetNotificationTemplate_ByTemplateSlug: () => useNotificationAdminApi_GetNotificationTemplate_ByTemplateSlug,
  useNotificationAdminApi_GetNotificationTemplates: () => useNotificationAdminApi_GetNotificationTemplates,
  useNotificationAdminApi_GetNotificationTopic_ByTopicName: () => useNotificationAdminApi_GetNotificationTopic_ByTopicName,
  useNotificationAdminApi_GetNotificationTopics: () => useNotificationAdminApi_GetNotificationTopics,
  useNotificationAdminApi_UpdateLanguageNotification_ByTemplateSlug_ByTemplateLanguageMutation: () => useNotificationAdminApi_UpdateLanguageNotification_ByTemplateSlug_ByTemplateLanguageMutation,
  useNotificationAdminApi_UpdateNotificationTopic_ByTopicNameMutation: () => useNotificationAdminApi_UpdateNotificationTopic_ByTopicNameMutation,
  useNotificationApi_CreateFreeformNotification_ByUserIdMutation: () => useNotificationApi_CreateFreeformNotification_ByUserIdMutation,
  useNotificationApi_CreateNotificationTopicMutation: () => useNotificationApi_CreateNotificationTopicMutation,
  useNotificationApi_CreateTemplatedNotification_ByUserIdMutation: () => useNotificationApi_CreateTemplatedNotification_ByUserIdMutation,
  useNotificationApi_DeleteNotificationTopic_ByTopicMutation: () => useNotificationApi_DeleteNotificationTopic_ByTopicMutation,
  useNotificationApi_GetNotificationMe: () => useNotificationApi_GetNotificationMe,
  useNotificationApi_GetNotificationTopic_ByTopic: () => useNotificationApi_GetNotificationTopic_ByTopic,
  useNotificationApi_GetNotificationTopics: () => useNotificationApi_GetNotificationTopics,
  useNotificationApi_UpdateNotificationTopic_ByTopicMutation: () => useNotificationApi_UpdateNotificationTopic_ByTopicMutation,
  usePartyAdminApi_GetPartyParty_ByPartyId: () => usePartyAdminApi_GetPartyParty_ByPartyId,
  usePartyAdminApi_GetParty_ByUserId: () => usePartyAdminApi_GetParty_ByUserId,
  usePartyApi_GetPartyParty_ByPartyId: () => usePartyApi_GetPartyParty_ByPartyId,
  usePartyApi_UpdateAttributeParty_ByPartyIdMutation: () => usePartyApi_UpdateAttributeParty_ByPartyIdMutation,
  usePartyApi_UpdateLimitParty_ByPartyIdMutation: () => usePartyApi_UpdateLimitParty_ByPartyIdMutation,
  usePlayerAdminApi_CreateBulkBlockPlayer_ByUserIdMutation: () => usePlayerAdminApi_CreateBulkBlockPlayer_ByUserIdMutation,
  usePlayerAdminApi_DeleteBulkUnblockPlayer_ByUserIdMutation: () => usePlayerAdminApi_DeleteBulkUnblockPlayer_ByUserIdMutation,
  usePlayerAdminApi_FetchPlayerUserBulkBlocked: () => usePlayerAdminApi_FetchPlayerUserBulkBlocked,
  usePlayerAdminApi_GetAttributePlayer_ByUserId_ByAttribute: () => usePlayerAdminApi_GetAttributePlayer_ByUserId_ByAttribute,
  usePlayerAdminApi_GetAttributesPlayer_ByUserId: () => usePlayerAdminApi_GetAttributesPlayer_ByUserId,
  usePlayerAdminApi_GetBlockedByPlayer_ByUserId: () => usePlayerAdminApi_GetBlockedByPlayer_ByUserId,
  usePlayerAdminApi_GetBlockedPlayer_ByUserId: () => usePlayerAdminApi_GetBlockedPlayer_ByUserId,
  usePlayerAdminApi_GetPlayerCcu: () => usePlayerAdminApi_GetPlayerCcu,
  usePlayerAdminApi_UpdateAttributePlayer_ByUserIdMutation: () => usePlayerAdminApi_UpdateAttributePlayer_ByUserIdMutation,
  usePlayerApi_CreatePlayerUserMeBlockMutation: () => usePlayerApi_CreatePlayerUserMeBlockMutation,
  usePlayerApi_CreatePlayerUserMeUnblockMutation: () => usePlayerApi_CreatePlayerUserMeUnblockMutation,
  usePlayerApi_GetPlayerUsersMeBlocked: () => usePlayerApi_GetPlayerUsersMeBlocked,
  usePlayerApi_GetPlayerUsersMeBlockedBy: () => usePlayerApi_GetPlayerUsersMeBlockedBy,
  usePresenceApi_CreatePresenceUserPresenceMutation: () => usePresenceApi_CreatePresenceUserPresenceMutation,
  usePresenceApi_GetPresenceUsersPresence: () => usePresenceApi_GetPresenceUsersPresence,
  useProfanityAdminApi_CreateFilterBulkFileProfanity_ByListMutation: () => useProfanityAdminApi_CreateFilterBulkFileProfanity_ByListMutation,
  useProfanityAdminApi_CreateFilterBulkProfanity_ByListMutation: () => useProfanityAdminApi_CreateFilterBulkProfanity_ByListMutation,
  useProfanityAdminApi_CreateFilterDeleteProfanity_ByListMutation: () => useProfanityAdminApi_CreateFilterDeleteProfanity_ByListMutation,
  useProfanityAdminApi_CreateFilterProfanity_ByListMutation: () => useProfanityAdminApi_CreateFilterProfanity_ByListMutation,
  useProfanityAdminApi_CreateProfanityListMutation: () => useProfanityAdminApi_CreateProfanityListMutation,
  useProfanityAdminApi_DeleteProfanityList_ByListMutation: () => useProfanityAdminApi_DeleteProfanityList_ByListMutation,
  useProfanityAdminApi_FetchProfanityFilterDebug: () => useProfanityAdminApi_FetchProfanityFilterDebug,
  useProfanityAdminApi_FetchProfanityVerify: () => useProfanityAdminApi_FetchProfanityVerify,
  useProfanityAdminApi_GetFiltersProfanity_ByList: () => useProfanityAdminApi_GetFiltersProfanity_ByList,
  useProfanityAdminApi_GetProfanityLists: () => useProfanityAdminApi_GetProfanityLists,
  useProfanityAdminApi_GetProfanityRule: () => useProfanityAdminApi_GetProfanityRule,
  useProfanityAdminApi_UpdateProfanityList_ByListMutation: () => useProfanityAdminApi_UpdateProfanityList_ByListMutation,
  useProfanityAdminApi_UpdateProfanityRuleMutation: () => useProfanityAdminApi_UpdateProfanityRuleMutation,
  useThirdPartyAdminApi_CreateThirdpartyConfigSteamMutation: () => useThirdPartyAdminApi_CreateThirdpartyConfigSteamMutation,
  useThirdPartyAdminApi_DeleteThirdpartyConfigSteamMutation: () => useThirdPartyAdminApi_DeleteThirdpartyConfigSteamMutation,
  useThirdPartyAdminApi_GetThirdpartyConfigSteam: () => useThirdPartyAdminApi_GetThirdpartyConfigSteam,
  useThirdPartyAdminApi_UpdateThirdpartyConfigSteamMutation: () => useThirdPartyAdminApi_UpdateThirdpartyConfigSteamMutation
});
module.exports = __toCommonJS(all_query_imports_exports);

// src/generated-admin/queries/AdminAdmin.query.ts
var import_react_query = require("@tanstack/react-query");

// src/generated-admin/AdminAdminApi.ts
var import_sdk2 = require("@accelbyte/sdk");

// src/generated-admin/endpoints/AdminAdmin$.ts
var import_sdk = require("@accelbyte/sdk");
var import_zod2 = require("zod");

// src/generated-definitions/GlobalConfiguration.ts
var import_zod = require("zod");
var GlobalConfiguration = import_zod.z.object({
  regionRetryMapping: import_zod.z.record(import_zod.z.array(import_zod.z.string())),
  regionURLMapping: import_zod.z.array(import_zod.z.string()),
  testGameMode: import_zod.z.string(),
  testRegionURLMapping: import_zod.z.array(import_zod.z.string()),
  testTargetUserIDs: import_zod.z.array(import_zod.z.string()),
  updatedAt: import_zod.z.string()
});

// src/generated-admin/endpoints/AdminAdmin$.ts
var AdminAdmin$ = class {
  // @ts-ignore
  // prettier-ignore
  constructor(axiosInstance, namespace, useSchemaValidation = true) {
    this.axiosInstance = axiosInstance;
    this.namespace = namespace;
    this.useSchemaValidation = useSchemaValidation;
  }
  /**
   * Delete of global configuration data.
   */
  deleteGlobalConfiguration() {
    const params = {};
    const url = "/lobby/v1/admin/global-configurations";
    const resultPromise = this.axiosInstance.delete(url, { params });
    return import_sdk.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, import_zod2.z.unknown(), "z.unknown()");
  }
  /**
   * Get dsmc global configuration.
   */
  getGlobalConfigurations() {
    const params = {};
    const url = "/lobby/v1/admin/global-configurations";
    const resultPromise = this.axiosInstance.get(url, { params });
    return import_sdk.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, GlobalConfiguration, "GlobalConfiguration");
  }
  /**
   * Upsert global configuration data.
   */
  updateGlobalConfiguration(data) {
    const params = {};
    const url = "/lobby/v1/admin/global-configurations";
    const resultPromise = this.axiosInstance.put(url, data, { params });
    return import_sdk.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, GlobalConfiguration, "GlobalConfiguration");
  }
};

// src/generated-admin/AdminAdminApi.ts
function AdminAdminApi(sdk, args) {
  const sdkAssembly = sdk.assembly();
  const namespace = args?.coreConfig?.namespace ?? sdkAssembly.coreConfig.namespace;
  const useSchemaValidation = args?.coreConfig?.useSchemaValidation ?? sdkAssembly.coreConfig.useSchemaValidation;
  let axiosInstance = sdkAssembly.axiosInstance;
  const requestConfigOverrides = args?.axiosConfig?.request;
  const baseURLOverride = args?.coreConfig?.baseURL;
  const interceptorsOverride = args?.axiosConfig?.interceptors ?? [];
  if (requestConfigOverrides || baseURLOverride || interceptorsOverride.length > 0) {
    const requestConfig = import_sdk2.ApiUtils.mergeAxiosConfigs(sdkAssembly.axiosInstance.defaults, {
      ...baseURLOverride ? { baseURL: baseURLOverride } : {},
      ...requestConfigOverrides
    });
    axiosInstance = import_sdk2.Network.create(requestConfig);
    for (const interceptor of interceptorsOverride) {
      if (interceptor.type === "request") {
        axiosInstance.interceptors.request.use(interceptor.onRequest, interceptor.onError);
      }
      if (interceptor.type === "response") {
        axiosInstance.interceptors.response.use(interceptor.onSuccess, interceptor.onError);
      }
    }
  }
  async function deleteGlobalConfiguration() {
    const $ = new AdminAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.deleteGlobalConfiguration();
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getGlobalConfigurations() {
    const $ = new AdminAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getGlobalConfigurations();
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function updateGlobalConfiguration(data) {
    const $ = new AdminAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.updateGlobalConfiguration(data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  return {
    /**
     * Delete of global configuration data.
     */
    deleteGlobalConfiguration,
    /**
     * Get dsmc global configuration.
     */
    getGlobalConfigurations,
    /**
     * Upsert global configuration data.
     */
    updateGlobalConfiguration
  };
}

// src/generated-admin/queries/AdminAdmin.query.ts
var Key_AdminAdmin = /* @__PURE__ */ ((Key_AdminAdmin2) => {
  Key_AdminAdmin2["GlobalConfiguration"] = "Lobby.AdminAdmin.GlobalConfiguration";
  Key_AdminAdmin2["GlobalConfigurations"] = "Lobby.AdminAdmin.GlobalConfigurations";
  return Key_AdminAdmin2;
})(Key_AdminAdmin || {});
var useAdminAdminApi_DeleteGlobalConfigurationMutation = (sdk, options, callback) => {
  const mutationFn = async (input) => {
    const response = await AdminAdminApi(sdk, { coreConfig: input.coreConfig, axiosConfig: input.axiosConfig }).deleteGlobalConfiguration();
    callback && callback(response.data);
    return response.data;
  };
  return (0, import_react_query.useMutation)({
    mutationKey: ["Lobby.AdminAdmin.GlobalConfiguration" /* GlobalConfiguration */],
    mutationFn,
    ...options
  });
};
var useAdminAdminApi_GetGlobalConfigurations = (sdk, input, options, callback) => {
  const queryFn = (sdk2, input2) => async () => {
    const response = await AdminAdminApi(sdk2, { coreConfig: input2.coreConfig, axiosConfig: input2.axiosConfig }).getGlobalConfigurations();
    callback && callback(response);
    return response.data;
  };
  return (0, import_react_query.useQuery)({
    queryKey: ["Lobby.AdminAdmin.GlobalConfigurations" /* GlobalConfigurations */, input],
    queryFn: queryFn(sdk, input),
    ...options
  });
};
var useAdminAdminApi_UpdateGlobalConfigurationMutation = (sdk, options, callback) => {
  const mutationFn = async (input) => {
    const response = await AdminAdminApi(sdk, { coreConfig: input.coreConfig, axiosConfig: input.axiosConfig }).updateGlobalConfiguration(
      input.data
    );
    callback && callback(response.data);
    return response.data;
  };
  return (0, import_react_query.useMutation)({
    mutationKey: ["Lobby.AdminAdmin.GlobalConfiguration" /* GlobalConfiguration */],
    mutationFn,
    ...options
  });
};

// src/generated-admin/queries/ConfigAdmin.query.ts
var import_react_query2 = require("@tanstack/react-query");

// src/generated-admin/ConfigAdminApi.ts
var import_sdk4 = require("@accelbyte/sdk");

// src/generated-admin/endpoints/ConfigAdmin$.ts
var import_sdk3 = require("@accelbyte/sdk");
var import_zod8 = require("zod");

// src/generated-definitions/ConfigList.ts
var import_zod4 = require("zod");

// src/generated-definitions/Config.ts
var import_zod3 = require("zod");
var Config = import_zod3.z.object({
  allowInviteNonConnectedUser: import_zod3.z.boolean().nullish(),
  allowJoinPartyDuringMatchmaking: import_zod3.z.boolean().nullish(),
  autoKickOnDisconnect: import_zod3.z.boolean().nullish(),
  autoKickOnDisconnectDelay: import_zod3.z.number().int().nullish(),
  cancelTicketOnDisconnect: import_zod3.z.boolean().nullish(),
  chatRateLimitBurst: import_zod3.z.number().int().nullish(),
  chatRateLimitDuration: import_zod3.z.number().int().nullish(),
  concurrentUsersLimit: import_zod3.z.number().int().nullish(),
  disableInvitationOnJoinParty: import_zod3.z.boolean().nullish(),
  disableRemoveSocketOldConnection: import_zod3.z.boolean().nullish(),
  enableChat: import_zod3.z.boolean().nullish(),
  entitlementCheck: import_zod3.z.boolean().nullish(),
  entitlementItemID: import_zod3.z.string().nullish(),
  generalRateLimitBurst: import_zod3.z.number().int().nullish(),
  generalRateLimitDuration: import_zod3.z.number().int().nullish(),
  keepPresenceActivityOnDisconnect: import_zod3.z.boolean().nullish(),
  maxDSWaitTime: import_zod3.z.number().int(),
  maxFriendsLimit: import_zod3.z.number().int().nullish(),
  maxPartyMember: import_zod3.z.number().int().nullish(),
  namespace: import_zod3.z.string().nullish(),
  profanityFilter: import_zod3.z.boolean().nullish(),
  readyConsentTimeout: import_zod3.z.number().int().nullish(),
  unregisterDelay: import_zod3.z.number().int()
});

// src/generated-definitions/ConfigList.ts
var ConfigList = import_zod4.z.object({ configs: import_zod4.z.array(Config) });

// src/generated-definitions/ConfigReq.ts
var import_zod5 = require("zod");
var ConfigReq = import_zod5.z.object({
  allowInviteNonConnectedUser: import_zod5.z.boolean().nullish(),
  allowJoinPartyDuringMatchmaking: import_zod5.z.boolean().nullish(),
  autoKickOnDisconnect: import_zod5.z.boolean().nullish(),
  autoKickOnDisconnectDelay: import_zod5.z.number().int().nullish(),
  cancelTicketOnDisconnect: import_zod5.z.boolean().nullish(),
  chatRateLimitBurst: import_zod5.z.number().int().nullish(),
  chatRateLimitDuration: import_zod5.z.number().int().nullish(),
  concurrentUsersLimit: import_zod5.z.number().int().nullish(),
  disableInvitationOnJoinParty: import_zod5.z.boolean().nullish(),
  enableChat: import_zod5.z.boolean().nullish(),
  entitlementCheck: import_zod5.z.boolean().nullish(),
  entitlementItemID: import_zod5.z.string().nullish(),
  generalRateLimitBurst: import_zod5.z.number().int().nullish(),
  generalRateLimitDuration: import_zod5.z.number().int().nullish(),
  keepPresenceActivityOnDisconnect: import_zod5.z.boolean().nullish(),
  maxDSWaitTime: import_zod5.z.number().int().nullish(),
  maxFriendsLimit: import_zod5.z.number().int().nullish(),
  maxPartyMember: import_zod5.z.number().int().nullish(),
  profanityFilter: import_zod5.z.boolean().nullish(),
  readyConsentTimeout: import_zod5.z.number().int().nullish(),
  unregisterDelay: import_zod5.z.number().int().nullish()
});

// src/generated-definitions/Configuration.ts
var import_zod6 = require("zod");
var Configuration = import_zod6.z.object({
  logLevel: import_zod6.z.enum(["debug", "error", "fatal", "info", "panic", "trace", "warning"]).nullish(),
  logLevelDB: import_zod6.z.enum(["debug", "error", "fatal", "info", "panic", "trace", "warning"]).nullish(),
  slowQueryThreshold: import_zod6.z.number().int().nullish(),
  socketLogEnabled: import_zod6.z.boolean().nullish()
});

// src/generated-definitions/ImportConfigResponse.ts
var import_zod7 = require("zod");
var ImportConfigResponse = import_zod7.z.object({
  failedConfigs: import_zod7.z.array(import_zod7.z.string()),
  ignoredConfigs: import_zod7.z.array(import_zod7.z.string()),
  newConfigs: import_zod7.z.array(import_zod7.z.string()),
  replacedConfigs: import_zod7.z.array(import_zod7.z.string())
});

// src/generated-admin/endpoints/ConfigAdmin$.ts
var ConfigAdmin$ = class {
  // @ts-ignore
  // prettier-ignore
  constructor(axiosInstance, namespace, useSchemaValidation = true) {
    this.axiosInstance = axiosInstance;
    this.namespace = namespace;
    this.useSchemaValidation = useSchemaValidation;
  }
  /**
   * Get lobby config of all namespaces.&lt;br&gt;default MaxDSWaitTime is 120 (second)
   */
  getConfig() {
    const params = {};
    const url = "/lobby/v1/admin/config";
    const resultPromise = this.axiosInstance.get(url, { params });
    return import_sdk3.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, ConfigList, "ConfigList");
  }
  /**
   *  Get Log Configuration logLevel use for logging in service, the value can use is trace|debug|info|warning|error|fatal|panic socketLogEnabled is use for enable socket log logLevelDB use for logging in DB, the value can use is trace|debug|info|warning|error|fatal|panic slowQueryThreshold use for logging slow threshold in time measure is nano second
   */
  getConfigLog() {
    const params = {};
    const url = "/lobby/v1/admin/config/log";
    const resultPromise = this.axiosInstance.get(url, { params });
    return import_sdk3.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, Configuration, "Configuration");
  }
  /**
   *  Update Log Configuration logLevel use for logging in service, the value can use is trace|debug|info|warning|error|fatal|panic socketLogEnabled is use for enable socket log logLevelDB use for logging in DB, the value can use is trace|debug|info|warning|error|fatal|panic slowQueryThreshold use for logging slow threshold in time measure is nano second
   */
  patchConfigLog(data) {
    const params = {};
    const url = "/lobby/v1/admin/config/log";
    const resultPromise = this.axiosInstance.patch(url, data, { params });
    return import_sdk3.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, Configuration, "Configuration");
  }
  /**
   * Get lobby config of a namespace.&lt;br&gt;default MaxDSWaitTime is 120 (second)
   */
  getConfig_ByNamespace() {
    const params = {};
    const url = "/lobby/v1/admin/config/namespaces/{namespace}".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.get(url, { params });
    return import_sdk3.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, ConfigReq, "ConfigReq");
  }
  /**
   * Update lobby config of a namespace.&lt;br&gt;MaxDSWaitTime value is cannot less than 1, if null it will use default value in 120 (second)
   */
  updateConfig_ByNamespace(data) {
    const params = {};
    const url = "/lobby/v1/admin/config/namespaces/{namespace}".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.put(url, data, { params });
    return import_sdk3.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, ConfigReq, "ConfigReq");
  }
  /**
   *  Export lobby configuration to a json file. The file can then be imported from the /import endpoint. JSON Schema of the exported file: { &#34;required&#34;: [ &#34;namespace&#34;, &#34;entitlementItemID&#34;, &#34;chatRateLimitDuration&#34;, &#34;unregisterDelay&#34;, &#34;generalRateLimitDuration&#34;, &#34;autoKickOnDisconnectDelay&#34;, &#34;chatRateLimitBurst&#34;, &#34;generalRateLimitBurst&#34;, &#34;maxPartyMember&#34;, &#34;autoKickOnDisconnect&#34;, &#34;profanityFilter&#34;, &#34;enableChat&#34;, &#34;entitlementCheck&#34;, &#34;cancelTicketOnDisconnect&#34;, &#34;concurrentUsersLimit&#34;, &#34;readyConsentTimeout&#34;, &#34;disableInvitationOnJoinParty&#34;, &#34;allowJoinPartyDuringMatchmaking&#34;, &#34;allowInviteNonConnectedUser&#34;, &#34;keepPresenceActivityOnDisconnect&#34;, &#34;maxDSWaitTime&#34;, &#34;maxFriendsLimit&#34; ], &#34;properties&#34;: { &#34;allowInviteNonConnectedUser&#34;: { &#34;type&#34;: &#34;boolean&#34; }, &#34;allowJoinPartyDuringMatchmaking&#34;: { &#34;type&#34;: &#34;boolean&#34; }, &#34;autoKickOnDisconnect&#34;: { &#34;type&#34;: &#34;boolean&#34; }, &#34;autoKickOnDisconnectDelay&#34;: { &#34;type&#34;: &#34;integer&#34;, &#34;format&#34;: &#34;int64&#34; }, &#34;cancelTicketOnDisconnect&#34;: { &#34;type&#34;: &#34;boolean&#34; }, &#34;chatRateLimitBurst&#34;: { &#34;type&#34;: &#34;integer&#34;, &#34;format&#34;: &#34;int32&#34; }, &#34;chatRateLimitDuration&#34;: { &#34;type&#34;: &#34;integer&#34;, &#34;format&#34;: &#34;int64&#34; }, &#34;concurrentUsersLimit&#34;: { &#34;type&#34;: &#34;integer&#34;, &#34;format&#34;: &#34;int32&#34; }, &#34;disableInvitationOnJoinParty&#34;: { &#34;type&#34;: &#34;boolean&#34; }, &#34;enableChat&#34;: { &#34;type&#34;: &#34;boolean&#34; }, &#34;entitlementCheck&#34;: { &#34;type&#34;: &#34;boolean&#34; }, &#34;entitlementItemID&#34;: { &#34;type&#34;: &#34;string&#34; }, &#34;generalRateLimitBurst&#34;: { &#34;type&#34;: &#34;integer&#34;, &#34;format&#34;: &#34;int32&#34; }, &#34;generalRateLimitDuration&#34;: { &#34;type&#34;: &#34;integer&#34;, &#34;format&#34;: &#34;int64&#34; }, &#34;keepPresenceActivityOnDisconnect&#34;: { &#34;type&#34;: &#34;boolean&#34; }, &#34;maxDSWaitTime&#34;: { &#34;type&#34;: &#34;integer&#34;, &#34;format&#34;: &#34;int64&#34; }, &#34;maxFriendsLimit&#34;: { &#34;type&#34;: &#34;integer&#34;, &#34;format&#34;: &#34;int32&#34; }, &#34;maxPartyMember&#34;: { &#34;type&#34;: &#34;integer&#34;, &#34;format&#34;: &#34;int32&#34; }, &#34;namespace&#34;: { &#34;type&#34;: &#34;string&#34; }, &#34;profanityFilter&#34;: { &#34;type&#34;: &#34;boolean&#34; }, &#34;readyConsentTimeout&#34;: { &#34;type&#34;: &#34;integer&#34;, &#34;format&#34;: &#34;int64&#34; }, &#34;unregisterDelay&#34;: { &#34;type&#34;: &#34;integer&#34;, &#34;format&#34;: &#34;int64&#34; } } }
   */
  getConfigExport() {
    const params = {};
    const url = "/lobby/v1/admin/config/namespaces/{namespace}/export".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.get(url, { params });
    return import_sdk3.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, import_zod8.z.unknown(), "z.unknown()");
  }
  /**
   *  Import config configuration from file. The existing configuration will be replaced. The json file to import can be obtained from the /export endpoint. MaxDSWaitTime value is cannot less than 1, if null it will use default value in 120 (second)
   */
  updateConfigImport(data) {
    const params = {};
    const url = "/lobby/v1/admin/config/namespaces/{namespace}/import".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.post(url, data, { params });
    return import_sdk3.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, ImportConfigResponse, "ImportConfigResponse");
  }
};

// src/generated-admin/ConfigAdminApi.ts
function ConfigAdminApi(sdk, args) {
  const sdkAssembly = sdk.assembly();
  const namespace = args?.coreConfig?.namespace ?? sdkAssembly.coreConfig.namespace;
  const useSchemaValidation = args?.coreConfig?.useSchemaValidation ?? sdkAssembly.coreConfig.useSchemaValidation;
  let axiosInstance = sdkAssembly.axiosInstance;
  const requestConfigOverrides = args?.axiosConfig?.request;
  const baseURLOverride = args?.coreConfig?.baseURL;
  const interceptorsOverride = args?.axiosConfig?.interceptors ?? [];
  if (requestConfigOverrides || baseURLOverride || interceptorsOverride.length > 0) {
    const requestConfig = import_sdk4.ApiUtils.mergeAxiosConfigs(sdkAssembly.axiosInstance.defaults, {
      ...baseURLOverride ? { baseURL: baseURLOverride } : {},
      ...requestConfigOverrides
    });
    axiosInstance = import_sdk4.Network.create(requestConfig);
    for (const interceptor of interceptorsOverride) {
      if (interceptor.type === "request") {
        axiosInstance.interceptors.request.use(interceptor.onRequest, interceptor.onError);
      }
      if (interceptor.type === "response") {
        axiosInstance.interceptors.response.use(interceptor.onSuccess, interceptor.onError);
      }
    }
  }
  async function getConfig() {
    const $ = new ConfigAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getConfig();
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getConfigLog() {
    const $ = new ConfigAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getConfigLog();
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function patchConfigLog(data) {
    const $ = new ConfigAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.patchConfigLog(data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getConfig_ByNamespace() {
    const $ = new ConfigAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getConfig_ByNamespace();
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function updateConfig_ByNamespace(data) {
    const $ = new ConfigAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.updateConfig_ByNamespace(data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getConfigExport() {
    const $ = new ConfigAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getConfigExport();
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function updateConfigImport(data) {
    const $ = new ConfigAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.updateConfigImport(data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  return {
    /**
     * Get lobby config of all namespaces.&lt;br&gt;default MaxDSWaitTime is 120 (second)
     */
    getConfig,
    /**
     *  Get Log Configuration logLevel use for logging in service, the value can use is trace|debug|info|warning|error|fatal|panic socketLogEnabled is use for enable socket log logLevelDB use for logging in DB, the value can use is trace|debug|info|warning|error|fatal|panic slowQueryThreshold use for logging slow threshold in time measure is nano second
     */
    getConfigLog,
    /**
     *  Update Log Configuration logLevel use for logging in service, the value can use is trace|debug|info|warning|error|fatal|panic socketLogEnabled is use for enable socket log logLevelDB use for logging in DB, the value can use is trace|debug|info|warning|error|fatal|panic slowQueryThreshold use for logging slow threshold in time measure is nano second
     */
    patchConfigLog,
    /**
     * Get lobby config of a namespace.&lt;br&gt;default MaxDSWaitTime is 120 (second)
     */
    getConfig_ByNamespace,
    /**
     * Update lobby config of a namespace.&lt;br&gt;MaxDSWaitTime value is cannot less than 1, if null it will use default value in 120 (second)
     */
    updateConfig_ByNamespace,
    /**
     *  Export lobby configuration to a json file. The file can then be imported from the /import endpoint. JSON Schema of the exported file: { &#34;required&#34;: [ &#34;namespace&#34;, &#34;entitlementItemID&#34;, &#34;chatRateLimitDuration&#34;, &#34;unregisterDelay&#34;, &#34;generalRateLimitDuration&#34;, &#34;autoKickOnDisconnectDelay&#34;, &#34;chatRateLimitBurst&#34;, &#34;generalRateLimitBurst&#34;, &#34;maxPartyMember&#34;, &#34;autoKickOnDisconnect&#34;, &#34;profanityFilter&#34;, &#34;enableChat&#34;, &#34;entitlementCheck&#34;, &#34;cancelTicketOnDisconnect&#34;, &#34;concurrentUsersLimit&#34;, &#34;readyConsentTimeout&#34;, &#34;disableInvitationOnJoinParty&#34;, &#34;allowJoinPartyDuringMatchmaking&#34;, &#34;allowInviteNonConnectedUser&#34;, &#34;keepPresenceActivityOnDisconnect&#34;, &#34;maxDSWaitTime&#34;, &#34;maxFriendsLimit&#34; ], &#34;properties&#34;: { &#34;allowInviteNonConnectedUser&#34;: { &#34;type&#34;: &#34;boolean&#34; }, &#34;allowJoinPartyDuringMatchmaking&#34;: { &#34;type&#34;: &#34;boolean&#34; }, &#34;autoKickOnDisconnect&#34;: { &#34;type&#34;: &#34;boolean&#34; }, &#34;autoKickOnDisconnectDelay&#34;: { &#34;type&#34;: &#34;integer&#34;, &#34;format&#34;: &#34;int64&#34; }, &#34;cancelTicketOnDisconnect&#34;: { &#34;type&#34;: &#34;boolean&#34; }, &#34;chatRateLimitBurst&#34;: { &#34;type&#34;: &#34;integer&#34;, &#34;format&#34;: &#34;int32&#34; }, &#34;chatRateLimitDuration&#34;: { &#34;type&#34;: &#34;integer&#34;, &#34;format&#34;: &#34;int64&#34; }, &#34;concurrentUsersLimit&#34;: { &#34;type&#34;: &#34;integer&#34;, &#34;format&#34;: &#34;int32&#34; }, &#34;disableInvitationOnJoinParty&#34;: { &#34;type&#34;: &#34;boolean&#34; }, &#34;enableChat&#34;: { &#34;type&#34;: &#34;boolean&#34; }, &#34;entitlementCheck&#34;: { &#34;type&#34;: &#34;boolean&#34; }, &#34;entitlementItemID&#34;: { &#34;type&#34;: &#34;string&#34; }, &#34;generalRateLimitBurst&#34;: { &#34;type&#34;: &#34;integer&#34;, &#34;format&#34;: &#34;int32&#34; }, &#34;generalRateLimitDuration&#34;: { &#34;type&#34;: &#34;integer&#34;, &#34;format&#34;: &#34;int64&#34; }, &#34;keepPresenceActivityOnDisconnect&#34;: { &#34;type&#34;: &#34;boolean&#34; }, &#34;maxDSWaitTime&#34;: { &#34;type&#34;: &#34;integer&#34;, &#34;format&#34;: &#34;int64&#34; }, &#34;maxFriendsLimit&#34;: { &#34;type&#34;: &#34;integer&#34;, &#34;format&#34;: &#34;int32&#34; }, &#34;maxPartyMember&#34;: { &#34;type&#34;: &#34;integer&#34;, &#34;format&#34;: &#34;int32&#34; }, &#34;namespace&#34;: { &#34;type&#34;: &#34;string&#34; }, &#34;profanityFilter&#34;: { &#34;type&#34;: &#34;boolean&#34; }, &#34;readyConsentTimeout&#34;: { &#34;type&#34;: &#34;integer&#34;, &#34;format&#34;: &#34;int64&#34; }, &#34;unregisterDelay&#34;: { &#34;type&#34;: &#34;integer&#34;, &#34;format&#34;: &#34;int64&#34; } } }
     */
    getConfigExport,
    /**
     *  Import config configuration from file. The existing configuration will be replaced. The json file to import can be obtained from the /export endpoint. MaxDSWaitTime value is cannot less than 1, if null it will use default value in 120 (second)
     */
    updateConfigImport
  };
}

// src/generated-admin/queries/ConfigAdmin.query.ts
var Key_ConfigAdmin = /* @__PURE__ */ ((Key_ConfigAdmin2) => {
  Key_ConfigAdmin2["Config"] = "Lobby.ConfigAdmin.Config";
  Key_ConfigAdmin2["ConfigLog"] = "Lobby.ConfigAdmin.ConfigLog";
  Key_ConfigAdmin2["Config_ByNamespace"] = "Lobby.ConfigAdmin.Config_ByNamespace";
  Key_ConfigAdmin2["ConfigExport"] = "Lobby.ConfigAdmin.ConfigExport";
  Key_ConfigAdmin2["ConfigImport"] = "Lobby.ConfigAdmin.ConfigImport";
  return Key_ConfigAdmin2;
})(Key_ConfigAdmin || {});
var useConfigAdminApi_GetConfig = (sdk, input, options, callback) => {
  const queryFn = (sdk2, input2) => async () => {
    const response = await ConfigAdminApi(sdk2, { coreConfig: input2.coreConfig, axiosConfig: input2.axiosConfig }).getConfig();
    callback && callback(response);
    return response.data;
  };
  return (0, import_react_query2.useQuery)({
    queryKey: ["Lobby.ConfigAdmin.Config" /* Config */, input],
    queryFn: queryFn(sdk, input),
    ...options
  });
};
var useConfigAdminApi_GetConfigLog = (sdk, input, options, callback) => {
  const queryFn = (sdk2, input2) => async () => {
    const response = await ConfigAdminApi(sdk2, { coreConfig: input2.coreConfig, axiosConfig: input2.axiosConfig }).getConfigLog();
    callback && callback(response);
    return response.data;
  };
  return (0, import_react_query2.useQuery)({
    queryKey: ["Lobby.ConfigAdmin.ConfigLog" /* ConfigLog */, input],
    queryFn: queryFn(sdk, input),
    ...options
  });
};
var useConfigAdminApi_PatchConfigLogMutation = (sdk, options, callback) => {
  const mutationFn = async (input) => {
    const response = await ConfigAdminApi(sdk, { coreConfig: input.coreConfig, axiosConfig: input.axiosConfig }).patchConfigLog(input.data);
    callback && callback(response.data);
    return response.data;
  };
  return (0, import_react_query2.useMutation)({
    mutationKey: ["Lobby.ConfigAdmin.ConfigLog" /* ConfigLog */],
    mutationFn,
    ...options
  });
};
var useConfigAdminApi_GetConfig_ByNamespace = (sdk, input, options, callback) => {
  const queryFn = (sdk2, input2) => async () => {
    const response = await ConfigAdminApi(sdk2, { coreConfig: input2.coreConfig, axiosConfig: input2.axiosConfig }).getConfig_ByNamespace();
    callback && callback(response);
    return response.data;
  };
  return (0, import_react_query2.useQuery)({
    queryKey: ["Lobby.ConfigAdmin.Config_ByNamespace" /* Config_ByNamespace */, input],
    queryFn: queryFn(sdk, input),
    ...options
  });
};
var useConfigAdminApi_UpdateConfig_ByNamespaceMutation = (sdk, options, callback) => {
  const mutationFn = async (input) => {
    const response = await ConfigAdminApi(sdk, { coreConfig: input.coreConfig, axiosConfig: input.axiosConfig }).updateConfig_ByNamespace(
      input.data
    );
    callback && callback(response.data);
    return response.data;
  };
  return (0, import_react_query2.useMutation)({
    mutationKey: ["Lobby.ConfigAdmin.Config_ByNamespace" /* Config_ByNamespace */],
    mutationFn,
    ...options
  });
};
var useConfigAdminApi_GetConfigExport = (sdk, input, options, callback) => {
  const queryFn = (sdk2, input2) => async () => {
    const response = await ConfigAdminApi(sdk2, { coreConfig: input2.coreConfig, axiosConfig: input2.axiosConfig }).getConfigExport();
    callback && callback(response);
    return response.data;
  };
  return (0, import_react_query2.useQuery)({
    queryKey: ["Lobby.ConfigAdmin.ConfigExport" /* ConfigExport */, input],
    queryFn: queryFn(sdk, input),
    ...options
  });
};
var useConfigAdminApi_UpdateConfigImportMutation = (sdk, options, callback) => {
  const mutationFn = async (input) => {
    const response = await ConfigAdminApi(sdk, { coreConfig: input.coreConfig, axiosConfig: input.axiosConfig }).updateConfigImport(
      input.data
    );
    callback && callback(response.data);
    return response.data;
  };
  return (0, import_react_query2.useMutation)({
    mutationKey: ["Lobby.ConfigAdmin.ConfigImport" /* ConfigImport */],
    mutationFn,
    ...options
  });
};

// src/generated-admin/queries/FriendsAdmin.query.ts
var import_react_query3 = require("@tanstack/react-query");

// src/generated-admin/FriendsAdminApi.ts
var import_sdk6 = require("@accelbyte/sdk");

// src/generated-admin/endpoints/FriendsAdmin$.ts
var import_sdk5 = require("@accelbyte/sdk");

// src/generated-definitions/FriendshipConnectionResponse.ts
var import_zod11 = require("zod");

// src/generated-definitions/FriendshipConnection.ts
var import_zod9 = require("zod");
var FriendshipConnection = import_zod9.z.object({ friendId: import_zod9.z.string(), subjectId: import_zod9.z.string() });

// src/generated-definitions/Pagination.ts
var import_zod10 = require("zod");
var Pagination = import_zod10.z.object({ first: import_zod10.z.string(), last: import_zod10.z.string(), next: import_zod10.z.string(), previous: import_zod10.z.string() });

// src/generated-definitions/FriendshipConnectionResponse.ts
var FriendshipConnectionResponse = import_zod11.z.object({ data: import_zod11.z.array(FriendshipConnection), paging: Pagination });

// src/generated-definitions/GetFriendsResponse.ts
var import_zod13 = require("zod");

// src/generated-definitions/FriendWithPlatform.ts
var import_zod12 = require("zod");
var FriendWithPlatform = import_zod12.z.object({ platformId: import_zod12.z.string(), userId: import_zod12.z.string() });

// src/generated-definitions/GetFriendsResponse.ts
var GetFriendsResponse = import_zod13.z.object({
  friendIDs: import_zod13.z.array(import_zod13.z.string()),
  friends: import_zod13.z.array(FriendWithPlatform).nullish(),
  friendsSinceTimes: import_zod13.z.array(import_zod13.z.string()),
  paging: Pagination
});

// src/generated-definitions/LoadIncomingFriendsWithTimeResponse.ts
var import_zod15 = require("zod");

// src/generated-definitions/IncomingFriendsWithTimeData.ts
var import_zod14 = require("zod");
var IncomingFriendsWithTimeData = import_zod14.z.object({ friendId: import_zod14.z.string(), requestedAt: import_zod14.z.string() });

// src/generated-definitions/LoadIncomingFriendsWithTimeResponse.ts
var LoadIncomingFriendsWithTimeResponse = import_zod15.z.object({ data: import_zod15.z.array(IncomingFriendsWithTimeData), paging: Pagination });

// src/generated-definitions/LoadOutgoingFriendsWithTimeResponse.ts
var import_zod17 = require("zod");

// src/generated-definitions/OutgoingFriendsWithTimeData.ts
var import_zod16 = require("zod");
var OutgoingFriendsWithTimeData = import_zod16.z.object({ friendId: import_zod16.z.string(), requestedAt: import_zod16.z.string() });

// src/generated-definitions/LoadOutgoingFriendsWithTimeResponse.ts
var LoadOutgoingFriendsWithTimeResponse = import_zod17.z.object({ data: import_zod17.z.array(OutgoingFriendsWithTimeData), paging: Pagination });

// src/generated-admin/endpoints/FriendsAdmin$.ts
var FriendsAdmin$ = class {
  // @ts-ignore
  // prettier-ignore
  constructor(axiosInstance, namespace, useSchemaValidation = true) {
    this.axiosInstance = axiosInstance;
    this.namespace = namespace;
    this.useSchemaValidation = useSchemaValidation;
  }
  /**
   * Get list of friends in a namespace.
   */
  getFriendUser_ByUserId(userId, queryParams) {
    const params = { limit: 25, ...queryParams };
    const url = "/lobby/v1/admin/friend/namespaces/{namespace}/users/{userId}".replace("{namespace}", this.namespace).replace("{userId}", userId);
    const resultPromise = this.axiosInstance.get(url, { params });
    return import_sdk5.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, GetFriendsResponse, "GetFriendsResponse");
  }
  /**
   * Get list of incoming friend requests.
   */
  getIncomingFriend_ByUserId(userId, queryParams) {
    const params = { limit: 25, ...queryParams };
    const url = "/lobby/v1/admin/friend/namespaces/{namespace}/users/{userId}/incoming".replace("{namespace}", this.namespace).replace("{userId}", userId);
    const resultPromise = this.axiosInstance.get(url, { params });
    return import_sdk5.Validate.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      LoadIncomingFriendsWithTimeResponse,
      "LoadIncomingFriendsWithTimeResponse"
    );
  }
  /**
   * Get list of outgoing friend requests in a namespace.
   */
  getOutgoingFriend_ByUserId(userId, queryParams) {
    const params = { limit: 25, ...queryParams };
    const url = "/lobby/v1/admin/friend/namespaces/{namespace}/users/{userId}/outgoing".replace("{namespace}", this.namespace).replace("{userId}", userId);
    const resultPromise = this.axiosInstance.get(url, { params });
    return import_sdk5.Validate.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      LoadOutgoingFriendsWithTimeResponse,
      "LoadOutgoingFriendsWithTimeResponse"
    );
  }
  /**
   * Load list friends and friends of friends in a namespace. Response subjectId will be different with requested userId if the user is not directly friend
   */
  getOfFriends_ByUserId(userId, queryParams) {
    const params = { limit: 25, ...queryParams };
    const url = "/lobby/v1/admin/friend/namespaces/{namespace}/users/{userId}/of-friends".replace("{namespace}", this.namespace).replace("{userId}", userId);
    const resultPromise = this.axiosInstance.get(url, { params });
    return import_sdk5.Validate.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      FriendshipConnectionResponse,
      "FriendshipConnectionResponse"
    );
  }
};

// src/generated-admin/FriendsAdminApi.ts
function FriendsAdminApi(sdk, args) {
  const sdkAssembly = sdk.assembly();
  const namespace = args?.coreConfig?.namespace ?? sdkAssembly.coreConfig.namespace;
  const useSchemaValidation = args?.coreConfig?.useSchemaValidation ?? sdkAssembly.coreConfig.useSchemaValidation;
  let axiosInstance = sdkAssembly.axiosInstance;
  const requestConfigOverrides = args?.axiosConfig?.request;
  const baseURLOverride = args?.coreConfig?.baseURL;
  const interceptorsOverride = args?.axiosConfig?.interceptors ?? [];
  if (requestConfigOverrides || baseURLOverride || interceptorsOverride.length > 0) {
    const requestConfig = import_sdk6.ApiUtils.mergeAxiosConfigs(sdkAssembly.axiosInstance.defaults, {
      ...baseURLOverride ? { baseURL: baseURLOverride } : {},
      ...requestConfigOverrides
    });
    axiosInstance = import_sdk6.Network.create(requestConfig);
    for (const interceptor of interceptorsOverride) {
      if (interceptor.type === "request") {
        axiosInstance.interceptors.request.use(interceptor.onRequest, interceptor.onError);
      }
      if (interceptor.type === "response") {
        axiosInstance.interceptors.response.use(interceptor.onSuccess, interceptor.onError);
      }
    }
  }
  async function getFriendUser_ByUserId(userId, queryParams) {
    const $ = new FriendsAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getFriendUser_ByUserId(userId, queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getIncomingFriend_ByUserId(userId, queryParams) {
    const $ = new FriendsAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getIncomingFriend_ByUserId(userId, queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getOutgoingFriend_ByUserId(userId, queryParams) {
    const $ = new FriendsAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getOutgoingFriend_ByUserId(userId, queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getOfFriends_ByUserId(userId, queryParams) {
    const $ = new FriendsAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getOfFriends_ByUserId(userId, queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  return {
    /**
     * Get list of friends in a namespace.
     */
    getFriendUser_ByUserId,
    /**
     * Get list of incoming friend requests.
     */
    getIncomingFriend_ByUserId,
    /**
     * Get list of outgoing friend requests in a namespace.
     */
    getOutgoingFriend_ByUserId,
    /**
     * Load list friends and friends of friends in a namespace. Response subjectId will be different with requested userId if the user is not directly friend
     */
    getOfFriends_ByUserId
  };
}

// src/generated-admin/queries/FriendsAdmin.query.ts
var Key_FriendsAdmin = /* @__PURE__ */ ((Key_FriendsAdmin2) => {
  Key_FriendsAdmin2["FriendUser_ByUserId"] = "Lobby.FriendsAdmin.FriendUser_ByUserId";
  Key_FriendsAdmin2["IncomingFriend_ByUserId"] = "Lobby.FriendsAdmin.IncomingFriend_ByUserId";
  Key_FriendsAdmin2["OutgoingFriend_ByUserId"] = "Lobby.FriendsAdmin.OutgoingFriend_ByUserId";
  Key_FriendsAdmin2["OfFriends_ByUserId"] = "Lobby.FriendsAdmin.OfFriends_ByUserId";
  return Key_FriendsAdmin2;
})(Key_FriendsAdmin || {});
var useFriendsAdminApi_GetFriendUser_ByUserId = (sdk, input, options, callback) => {
  const queryFn = (sdk2, input2) => async () => {
    const response = await FriendsAdminApi(sdk2, { coreConfig: input2.coreConfig, axiosConfig: input2.axiosConfig }).getFriendUser_ByUserId(
      input2.userId,
      input2.queryParams
    );
    callback && callback(response);
    return response.data;
  };
  return (0, import_react_query3.useQuery)({
    queryKey: ["Lobby.FriendsAdmin.FriendUser_ByUserId" /* FriendUser_ByUserId */, input],
    queryFn: queryFn(sdk, input),
    ...options
  });
};
var useFriendsAdminApi_GetIncomingFriend_ByUserId = (sdk, input, options, callback) => {
  const queryFn = (sdk2, input2) => async () => {
    const response = await FriendsAdminApi(sdk2, {
      coreConfig: input2.coreConfig,
      axiosConfig: input2.axiosConfig
    }).getIncomingFriend_ByUserId(input2.userId, input2.queryParams);
    callback && callback(response);
    return response.data;
  };
  return (0, import_react_query3.useQuery)({
    queryKey: ["Lobby.FriendsAdmin.IncomingFriend_ByUserId" /* IncomingFriend_ByUserId */, input],
    queryFn: queryFn(sdk, input),
    ...options
  });
};
var useFriendsAdminApi_GetOutgoingFriend_ByUserId = (sdk, input, options, callback) => {
  const queryFn = (sdk2, input2) => async () => {
    const response = await FriendsAdminApi(sdk2, {
      coreConfig: input2.coreConfig,
      axiosConfig: input2.axiosConfig
    }).getOutgoingFriend_ByUserId(input2.userId, input2.queryParams);
    callback && callback(response);
    return response.data;
  };
  return (0, import_react_query3.useQuery)({
    queryKey: ["Lobby.FriendsAdmin.OutgoingFriend_ByUserId" /* OutgoingFriend_ByUserId */, input],
    queryFn: queryFn(sdk, input),
    ...options
  });
};
var useFriendsAdminApi_GetOfFriends_ByUserId = (sdk, input, options, callback) => {
  const queryFn = (sdk2, input2) => async () => {
    const response = await FriendsAdminApi(sdk2, { coreConfig: input2.coreConfig, axiosConfig: input2.axiosConfig }).getOfFriends_ByUserId(
      input2.userId,
      input2.queryParams
    );
    callback && callback(response);
    return response.data;
  };
  return (0, import_react_query3.useQuery)({
    queryKey: ["Lobby.FriendsAdmin.OfFriends_ByUserId" /* OfFriends_ByUserId */, input],
    queryFn: queryFn(sdk, input),
    ...options
  });
};

// src/generated-admin/queries/LobbyOperationsAdmin.query.ts
var import_react_query4 = require("@tanstack/react-query");

// src/generated-admin/LobbyOperationsAdminApi.ts
var import_sdk8 = require("@accelbyte/sdk");

// src/generated-admin/endpoints/LobbyOperationsAdmin$.ts
var import_sdk7 = require("@accelbyte/sdk");
var import_zod19 = require("zod");

// src/generated-definitions/PartyData.ts
var import_zod18 = require("zod");
var PartyData = import_zod18.z.object({
  custom_attribute: import_zod18.z.record(import_zod18.z.any()),
  invitees: import_zod18.z.array(import_zod18.z.string()),
  leader: import_zod18.z.string(),
  members: import_zod18.z.array(import_zod18.z.string()),
  namespace: import_zod18.z.string(),
  partyId: import_zod18.z.string(),
  updatedAt: import_zod18.z.number().int()
});

// src/generated-admin/endpoints/LobbyOperationsAdmin$.ts
var LobbyOperationsAdmin$ = class {
  // @ts-ignore
  // prettier-ignore
  constructor(axiosInstance, namespace, useSchemaValidation = true) {
    this.axiosInstance = axiosInstance;
    this.namespace = namespace;
    this.useSchemaValidation = useSchemaValidation;
  }
  /**
   * Update party attributes in a namespace.
   */
  updateAttributeParty_ByPartyId(partyId, data) {
    const params = {};
    const url = "/lobby/v1/admin/party/namespaces/{namespace}/parties/{partyId}/attributes".replace("{namespace}", this.namespace).replace("{partyId}", partyId);
    const resultPromise = this.axiosInstance.put(url, data, { params });
    return import_sdk7.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, PartyData, "PartyData");
  }
  /**
   * Admin join a player into a party.
   */
  updateJoinParty_ByPartyId_ByUserId(partyId, userId) {
    const params = {};
    const url = "/lobby/v1/admin/party/namespaces/{namespace}/parties/{partyId}/join/{userId}".replace("{namespace}", this.namespace).replace("{partyId}", partyId).replace("{userId}", userId);
    const resultPromise = this.axiosInstance.post(url, null, { params });
    return import_sdk7.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, import_zod19.z.unknown(), "z.unknown()");
  }
};

// src/generated-admin/LobbyOperationsAdminApi.ts
function LobbyOperationsAdminApi(sdk, args) {
  const sdkAssembly = sdk.assembly();
  const namespace = args?.coreConfig?.namespace ?? sdkAssembly.coreConfig.namespace;
  const useSchemaValidation = args?.coreConfig?.useSchemaValidation ?? sdkAssembly.coreConfig.useSchemaValidation;
  let axiosInstance = sdkAssembly.axiosInstance;
  const requestConfigOverrides = args?.axiosConfig?.request;
  const baseURLOverride = args?.coreConfig?.baseURL;
  const interceptorsOverride = args?.axiosConfig?.interceptors ?? [];
  if (requestConfigOverrides || baseURLOverride || interceptorsOverride.length > 0) {
    const requestConfig = import_sdk8.ApiUtils.mergeAxiosConfigs(sdkAssembly.axiosInstance.defaults, {
      ...baseURLOverride ? { baseURL: baseURLOverride } : {},
      ...requestConfigOverrides
    });
    axiosInstance = import_sdk8.Network.create(requestConfig);
    for (const interceptor of interceptorsOverride) {
      if (interceptor.type === "request") {
        axiosInstance.interceptors.request.use(interceptor.onRequest, interceptor.onError);
      }
      if (interceptor.type === "response") {
        axiosInstance.interceptors.response.use(interceptor.onSuccess, interceptor.onError);
      }
    }
  }
  async function updateAttributeParty_ByPartyId(partyId, data) {
    const $ = new LobbyOperationsAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.updateAttributeParty_ByPartyId(partyId, data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function updateJoinParty_ByPartyId_ByUserId(partyId, userId) {
    const $ = new LobbyOperationsAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.updateJoinParty_ByPartyId_ByUserId(partyId, userId);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  return {
    /**
     * Update party attributes in a namespace.
     */
    updateAttributeParty_ByPartyId,
    /**
     * Admin join a player into a party.
     */
    updateJoinParty_ByPartyId_ByUserId
  };
}

// src/generated-admin/queries/LobbyOperationsAdmin.query.ts
var Key_LobbyOperationsAdmin = /* @__PURE__ */ ((Key_LobbyOperationsAdmin2) => {
  Key_LobbyOperationsAdmin2["AttributeParty_ByPartyId"] = "Lobby.LobbyOperationsAdmin.AttributeParty_ByPartyId";
  Key_LobbyOperationsAdmin2["JoinParty_ByPartyId_ByUserId"] = "Lobby.LobbyOperationsAdmin.JoinParty_ByPartyId_ByUserId";
  return Key_LobbyOperationsAdmin2;
})(Key_LobbyOperationsAdmin || {});
var useLobbyOperationsAdminApi_UpdateAttributeParty_ByPartyIdMutation = (sdk, options, callback) => {
  const mutationFn = async (input) => {
    const response = await LobbyOperationsAdminApi(sdk, {
      coreConfig: input.coreConfig,
      axiosConfig: input.axiosConfig
    }).updateAttributeParty_ByPartyId(input.partyId, input.data);
    callback && callback(response.data);
    return response.data;
  };
  return (0, import_react_query4.useMutation)({
    mutationKey: ["Lobby.LobbyOperationsAdmin.AttributeParty_ByPartyId" /* AttributeParty_ByPartyId */],
    mutationFn,
    ...options
  });
};
var useLobbyOperationsAdminApi_UpdateJoinParty_ByPartyId_ByUserIdMutation = (sdk, options, callback) => {
  const mutationFn = async (input) => {
    const response = await LobbyOperationsAdminApi(sdk, {
      coreConfig: input.coreConfig,
      axiosConfig: input.axiosConfig
    }).updateJoinParty_ByPartyId_ByUserId(input.partyId, input.userId);
    callback && callback(response.data);
    return response.data;
  };
  return (0, import_react_query4.useMutation)({
    mutationKey: ["Lobby.LobbyOperationsAdmin.JoinParty_ByPartyId_ByUserId" /* JoinParty_ByPartyId_ByUserId */],
    mutationFn,
    ...options
  });
};

// src/generated-admin/queries/NotificationAdmin.query.ts
var import_react_query5 = require("@tanstack/react-query");

// src/generated-admin/NotificationAdminApi.ts
var import_sdk10 = require("@accelbyte/sdk");

// src/generated-admin/endpoints/NotificationAdmin$.ts
var import_sdk9 = require("@accelbyte/sdk");
var import_zod27 = require("zod");

// src/generated-definitions/GetAllNotificationTemplateSlugResp.ts
var import_zod22 = require("zod");

// src/generated-definitions/Localization.ts
var import_zod21 = require("zod");

// src/generated-definitions/TemplateContent.ts
var import_zod20 = require("zod");
var TemplateContent = import_zod20.z.object({ draft: import_zod20.z.string(), published: import_zod20.z.string() });

// src/generated-definitions/Localization.ts
var Localization = import_zod21.z.object({
  lastDraftAt: import_zod21.z.string(),
  lastPublishedAt: import_zod21.z.string(),
  templateContent: TemplateContent,
  templateLanguage: import_zod21.z.string()
});

// src/generated-definitions/GetAllNotificationTemplateSlugResp.ts
var GetAllNotificationTemplateSlugResp = import_zod22.z.object({ data: import_zod22.z.array(Localization), paging: Pagination });

// src/generated-definitions/GetAllNotificationTopicsResponse.ts
var import_zod24 = require("zod");

// src/generated-definitions/NotificationTopicResponseV1.ts
var import_zod23 = require("zod");
var NotificationTopicResponseV1 = import_zod23.z.object({
  createdAt: import_zod23.z.number().int(),
  description: import_zod23.z.string(),
  namespace: import_zod23.z.string(),
  topicName: import_zod23.z.string()
});

// src/generated-definitions/GetAllNotificationTopicsResponse.ts
var GetAllNotificationTopicsResponse = import_zod24.z.object({ data: import_zod24.z.array(NotificationTopicResponseV1), paging: Pagination });

// src/generated-definitions/NotificationTemplateResponseArray.ts
var import_zod26 = require("zod");

// src/generated-definitions/NotificationTemplateResponse.ts
var import_zod25 = require("zod");
var NotificationTemplateResponse = import_zod25.z.object({ templateLocalizations: import_zod25.z.array(Localization), templateSlug: import_zod25.z.string() });

// src/generated-definitions/NotificationTemplateResponseArray.ts
var NotificationTemplateResponseArray = import_zod26.z.array(NotificationTemplateResponse);

// src/generated-admin/endpoints/NotificationAdmin$.ts
var NotificationAdmin$ = class {
  // @ts-ignore
  // prettier-ignore
  constructor(axiosInstance, namespace, useSchemaValidation = true) {
    this.axiosInstance = axiosInstance;
    this.namespace = namespace;
    this.useSchemaValidation = useSchemaValidation;
  }
  /**
   * Get topic by namespace.&lt;br/&gt; Action Code: 50213
   */
  getNotificationTopics(queryParams) {
    const params = { ...queryParams };
    const url = "/lobby/v1/admin/notification/namespaces/{namespace}/topics".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.get(url, { params });
    return import_sdk9.Validate.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      GetAllNotificationTopicsResponse,
      "GetAllNotificationTopicsResponse"
    );
  }
  /**
   * Create new notification topic. &lt;br&gt;topic should be alphabets, no special char except underscore, uppercase and no spacing. for example: TOPIC_TEST. Already existing topic can not be created&lt;br/&gt; Action Code: 50214
   */
  createNotificationTopic(data) {
    const params = {};
    const url = "/lobby/v1/admin/notification/namespaces/{namespace}/topics".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.post(url, data, { params });
    return import_sdk9.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, import_zod27.z.unknown(), "z.unknown()");
  }
  /**
   * Get all templates in a namespace&lt;br&gt; Action Code: 50203
   */
  getNotificationTemplates() {
    const params = {};
    const url = "/lobby/v1/admin/notification/namespaces/{namespace}/templates".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.get(url, { params });
    return import_sdk9.Validate.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      NotificationTemplateResponseArray,
      "NotificationTemplateResponseArray"
    );
  }
  /**
   * Create new notification template. Include handlebars {{key}} for replaceable contexts. The key inside handlebars will be the key to be replaced when sending notification. Already existing template with the same slug and language can not be created. &lt;br&gt;Check model description for detailed input restrictions.&lt;br&gt; Action Code: 50204
   */
  createNotificationTemplate(data) {
    const params = {};
    const url = "/lobby/v1/admin/notification/namespaces/{namespace}/templates".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.post(url, data, { params });
    return import_sdk9.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, import_zod27.z.unknown(), "z.unknown()");
  }
  /**
   * Sends notification to all connected users in a namespace.&lt;br&gt; Action Code: 50201
   */
  createNotificationFreeformNotify(data) {
    const params = {};
    const url = "/lobby/v1/admin/notification/namespaces/{namespace}/freeform/notify".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.post(url, data, { params });
    return import_sdk9.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, import_zod27.z.unknown(), "z.unknown()");
  }
  /**
   * Sends notification to all connected users in a namespace with predefined template. &lt;br&gt;In the request body, specify which template slug (template identifier) to use and the template language. &lt;br&gt;NotificationTemplate context is the key-value pair defining the value of each handlebar specified in the template content. Template need to be published before it can be use to send notifications&lt;br/&gt; Action Code: 50202
   */
  createNotificationTemplateNotify(data) {
    const params = {};
    const url = "/lobby/v1/admin/notification/namespaces/{namespace}/templates/notify".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.post(url, data, { params });
    return import_sdk9.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, import_zod27.z.unknown(), "z.unknown()");
  }
  /**
   * Delete topic information by topic name. &lt;br&gt;topic should be alphabets, no special char except underscore, uppercase and no spacing. for example: TOPIC_TEST. Already existing topic can not be created &lt;br/&gt; Action Code: 50217
   */
  deleteNotificationTopic_ByTopicName(topicName) {
    const params = {};
    const url = "/lobby/v1/admin/notification/namespaces/{namespace}/topics/{topicName}".replace("{namespace}", this.namespace).replace("{topicName}", topicName);
    const resultPromise = this.axiosInstance.delete(url, { params });
    return import_sdk9.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, import_zod27.z.unknown(), "z.unknown()");
  }
  /**
   * Get topic information by topic name.&lt;br/&gt; Action Code: 50215
   */
  getNotificationTopic_ByTopicName(topicName) {
    const params = {};
    const url = "/lobby/v1/admin/notification/namespaces/{namespace}/topics/{topicName}".replace("{namespace}", this.namespace).replace("{topicName}", topicName);
    const resultPromise = this.axiosInstance.get(url, { params });
    return import_sdk9.Validate.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      NotificationTopicResponseV1,
      "NotificationTopicResponseV1"
    );
  }
  /**
   * Update topic information by topic name. &lt;br&gt;topic should be alphabets, no special char except underscore, uppercase and no spacing. for example: TOPIC_TEST. Already existing topic can not be created &lt;br/&gt; Action Code: 50216
   */
  updateNotificationTopic_ByTopicName(topicName, data) {
    const params = {};
    const url = "/lobby/v1/admin/notification/namespaces/{namespace}/topics/{topicName}".replace("{namespace}", this.namespace).replace("{topicName}", topicName);
    const resultPromise = this.axiosInstance.put(url, data, { params });
    return import_sdk9.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, import_zod27.z.unknown(), "z.unknown()");
  }
  /**
   * Delete template slug in notification template&lt;br&gt; Action Code: 50206
   */
  deleteNotificationTemplate_ByTemplateSlug(templateSlug) {
    const params = {};
    const url = "/lobby/v1/admin/notification/namespaces/{namespace}/templates/{templateSlug}".replace("{namespace}", this.namespace).replace("{templateSlug}", templateSlug);
    const resultPromise = this.axiosInstance.delete(url, { params });
    return import_sdk9.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, import_zod27.z.unknown(), "z.unknown()");
  }
  /**
   * Get all templates in a namespace&lt;br&gt; Action Code: 50205
   */
  getNotificationTemplate_ByTemplateSlug(templateSlug, queryParams) {
    const params = { ...queryParams };
    const url = "/lobby/v1/admin/notification/namespaces/{namespace}/templates/{templateSlug}".replace("{namespace}", this.namespace).replace("{templateSlug}", templateSlug);
    const resultPromise = this.axiosInstance.get(url, { params });
    return import_sdk9.Validate.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      GetAllNotificationTemplateSlugResp,
      "GetAllNotificationTemplateSlugResp"
    );
  }
  /**
   * Sends notification to multiple user. Action Code: 50211
   */
  createNotificationBulkUserFreeformNotify(data) {
    const params = {};
    const url = "/lobby/v1/admin/notification/namespaces/{namespace}/bulkUsers/freeform/notify".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.post(url, data, { params });
    return import_sdk9.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, import_zod27.z.unknown(), "z.unknown()");
  }
  /**
   * Sends notification to a user. Action Code: 50211
   */
  createFreeformNotifyNotification_ByUserId(userId, data) {
    const params = {};
    const url = "/lobby/v1/admin/notification/namespaces/{namespace}/users/{userId}/freeform/notify".replace("{namespace}", this.namespace).replace("{userId}", userId);
    const resultPromise = this.axiosInstance.post(url, data, { params });
    return import_sdk9.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, import_zod27.z.unknown(), "z.unknown()");
  }
  /**
   * Sends templated notification to a user. &lt;br&gt;In the request body, specify which template slug (template identifier) to use and the template language. &lt;br&gt;NotificationTemplate context is the key-value pair defining the value of each handlebar specified in the template content. Template need to be published before it can be use to send notifications&lt;br&gt; Action Code: 50212
   */
  createTemplateNotifyNotification_ByUserId(userId, data) {
    const params = {};
    const url = "/lobby/v1/admin/notification/namespaces/{namespace}/users/{userId}/templates/notify".replace("{namespace}", this.namespace).replace("{userId}", userId);
    const resultPromise = this.axiosInstance.post(url, data, { params });
    return import_sdk9.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, import_zod27.z.unknown(), "z.unknown()");
  }
  /**
   * Sends notification to a party.
   */
  createFreeformNotifyNotification_ByPartyId(partyId, data) {
    const params = {};
    const url = "/lobby/v1/admin/notification/namespaces/{namespace}/parties/{partyId}/freeform/notify".replace("{namespace}", this.namespace).replace("{partyId}", partyId);
    const resultPromise = this.axiosInstance.post(url, data, { params });
    return import_sdk9.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, import_zod27.z.unknown(), "z.unknown()");
  }
  /**
   * Sends templated notification to a party. &lt;br&gt;In the request body, specify which template slug (template identifier) to use and the template language. &lt;br&gt;NotificationTemplate context is the key-value pair defining the value of each handlebar specified in the template content. Template need to be published before it can be use to send notifications&lt;br&gt;
   */
  createTemplateNotifyNotification_ByPartyId(partyId, data) {
    const params = {};
    const url = "/lobby/v1/admin/notification/namespaces/{namespace}/parties/{partyId}/templates/notify".replace("{namespace}", this.namespace).replace("{partyId}", partyId);
    const resultPromise = this.axiosInstance.post(url, data, { params });
    return import_sdk9.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, import_zod27.z.unknown(), "z.unknown()");
  }
  /**
   * Delete template localization&lt;br/&gt; Action Code: 50209
   */
  deleteLanguageNotification_ByTemplateSlug_ByTemplateLanguage(templateSlug, templateLanguage) {
    const params = {};
    const url = "/lobby/v1/admin/notification/namespaces/{namespace}/templates/{templateSlug}/languages/{templateLanguage}".replace("{namespace}", this.namespace).replace("{templateSlug}", templateSlug).replace("{templateLanguage}", templateLanguage);
    const resultPromise = this.axiosInstance.delete(url, { params });
    return import_sdk9.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, import_zod27.z.unknown(), "z.unknown()");
  }
  /**
   * Get a template localization&lt;br/&gt; Action Code: 50207
   */
  getLanguageNotification_ByTemplateSlug_ByTemplateLanguage(templateSlug, templateLanguage) {
    const params = {};
    const url = "/lobby/v1/admin/notification/namespaces/{namespace}/templates/{templateSlug}/languages/{templateLanguage}".replace("{namespace}", this.namespace).replace("{templateSlug}", templateSlug).replace("{templateLanguage}", templateLanguage);
    const resultPromise = this.axiosInstance.get(url, { params });
    return import_sdk9.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, Localization, "Localization");
  }
  /**
   * Update template localization&lt;br/&gt; Action Code: 50208
   */
  updateLanguageNotification_ByTemplateSlug_ByTemplateLanguage(templateSlug, templateLanguage, data) {
    const params = {};
    const url = "/lobby/v1/admin/notification/namespaces/{namespace}/templates/{templateSlug}/languages/{templateLanguage}".replace("{namespace}", this.namespace).replace("{templateSlug}", templateSlug).replace("{templateLanguage}", templateLanguage);
    const resultPromise = this.axiosInstance.put(url, data, { params });
    return import_sdk9.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, import_zod27.z.unknown(), "z.unknown()");
  }
  /**
   * Publish notification template draft. Empty draft can not be published.&lt;br/&gt; Action Code: 50210
   */
  createPublishNotification_ByTemplateSlug_ByTemplateLanguage(templateSlug, templateLanguage) {
    const params = {};
    const url = "/lobby/v1/admin/notification/namespaces/{namespace}/templates/{templateSlug}/languages/{templateLanguage}/publish".replace("{namespace}", this.namespace).replace("{templateSlug}", templateSlug).replace("{templateLanguage}", templateLanguage);
    const resultPromise = this.axiosInstance.post(url, null, { params });
    return import_sdk9.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, import_zod27.z.unknown(), "z.unknown()");
  }
};

// src/generated-admin/NotificationAdminApi.ts
function NotificationAdminApi(sdk, args) {
  const sdkAssembly = sdk.assembly();
  const namespace = args?.coreConfig?.namespace ?? sdkAssembly.coreConfig.namespace;
  const useSchemaValidation = args?.coreConfig?.useSchemaValidation ?? sdkAssembly.coreConfig.useSchemaValidation;
  let axiosInstance = sdkAssembly.axiosInstance;
  const requestConfigOverrides = args?.axiosConfig?.request;
  const baseURLOverride = args?.coreConfig?.baseURL;
  const interceptorsOverride = args?.axiosConfig?.interceptors ?? [];
  if (requestConfigOverrides || baseURLOverride || interceptorsOverride.length > 0) {
    const requestConfig = import_sdk10.ApiUtils.mergeAxiosConfigs(sdkAssembly.axiosInstance.defaults, {
      ...baseURLOverride ? { baseURL: baseURLOverride } : {},
      ...requestConfigOverrides
    });
    axiosInstance = import_sdk10.Network.create(requestConfig);
    for (const interceptor of interceptorsOverride) {
      if (interceptor.type === "request") {
        axiosInstance.interceptors.request.use(interceptor.onRequest, interceptor.onError);
      }
      if (interceptor.type === "response") {
        axiosInstance.interceptors.response.use(interceptor.onSuccess, interceptor.onError);
      }
    }
  }
  async function getNotificationTopics(queryParams) {
    const $ = new NotificationAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getNotificationTopics(queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function createNotificationTopic(data) {
    const $ = new NotificationAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.createNotificationTopic(data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getNotificationTemplates() {
    const $ = new NotificationAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getNotificationTemplates();
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function createNotificationTemplate(data) {
    const $ = new NotificationAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.createNotificationTemplate(data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function createNotificationFreeformNotify(data) {
    const $ = new NotificationAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.createNotificationFreeformNotify(data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function createNotificationTemplateNotify(data) {
    const $ = new NotificationAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.createNotificationTemplateNotify(data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function deleteNotificationTopic_ByTopicName(topicName) {
    const $ = new NotificationAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.deleteNotificationTopic_ByTopicName(topicName);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getNotificationTopic_ByTopicName(topicName) {
    const $ = new NotificationAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getNotificationTopic_ByTopicName(topicName);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function updateNotificationTopic_ByTopicName(topicName, data) {
    const $ = new NotificationAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.updateNotificationTopic_ByTopicName(topicName, data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function deleteNotificationTemplate_ByTemplateSlug(templateSlug) {
    const $ = new NotificationAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.deleteNotificationTemplate_ByTemplateSlug(templateSlug);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getNotificationTemplate_ByTemplateSlug(templateSlug, queryParams) {
    const $ = new NotificationAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getNotificationTemplate_ByTemplateSlug(templateSlug, queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function createNotificationBulkUserFreeformNotify(data) {
    const $ = new NotificationAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.createNotificationBulkUserFreeformNotify(data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function createFreeformNotifyNotification_ByUserId(userId, data) {
    const $ = new NotificationAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.createFreeformNotifyNotification_ByUserId(userId, data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function createTemplateNotifyNotification_ByUserId(userId, data) {
    const $ = new NotificationAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.createTemplateNotifyNotification_ByUserId(userId, data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function createFreeformNotifyNotification_ByPartyId(partyId, data) {
    const $ = new NotificationAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.createFreeformNotifyNotification_ByPartyId(partyId, data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function createTemplateNotifyNotification_ByPartyId(partyId, data) {
    const $ = new NotificationAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.createTemplateNotifyNotification_ByPartyId(partyId, data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function deleteLanguageNotification_ByTemplateSlug_ByTemplateLanguage(templateSlug, templateLanguage) {
    const $ = new NotificationAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.deleteLanguageNotification_ByTemplateSlug_ByTemplateLanguage(templateSlug, templateLanguage);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getLanguageNotification_ByTemplateSlug_ByTemplateLanguage(templateSlug, templateLanguage) {
    const $ = new NotificationAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getLanguageNotification_ByTemplateSlug_ByTemplateLanguage(templateSlug, templateLanguage);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function updateLanguageNotification_ByTemplateSlug_ByTemplateLanguage(templateSlug, templateLanguage, data) {
    const $ = new NotificationAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.updateLanguageNotification_ByTemplateSlug_ByTemplateLanguage(templateSlug, templateLanguage, data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function createPublishNotification_ByTemplateSlug_ByTemplateLanguage(templateSlug, templateLanguage) {
    const $ = new NotificationAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.createPublishNotification_ByTemplateSlug_ByTemplateLanguage(templateSlug, templateLanguage);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  return {
    /**
     * Get topic by namespace.&lt;br/&gt; Action Code: 50213
     */
    getNotificationTopics,
    /**
     * Create new notification topic. &lt;br&gt;topic should be alphabets, no special char except underscore, uppercase and no spacing. for example: TOPIC_TEST. Already existing topic can not be created&lt;br/&gt; Action Code: 50214
     */
    createNotificationTopic,
    /**
     * Get all templates in a namespace&lt;br&gt; Action Code: 50203
     */
    getNotificationTemplates,
    /**
     * Create new notification template. Include handlebars {{key}} for replaceable contexts. The key inside handlebars will be the key to be replaced when sending notification. Already existing template with the same slug and language can not be created. &lt;br&gt;Check model description for detailed input restrictions.&lt;br&gt; Action Code: 50204
     */
    createNotificationTemplate,
    /**
     * Sends notification to all connected users in a namespace.&lt;br&gt; Action Code: 50201
     */
    createNotificationFreeformNotify,
    /**
     * Sends notification to all connected users in a namespace with predefined template. &lt;br&gt;In the request body, specify which template slug (template identifier) to use and the template language. &lt;br&gt;NotificationTemplate context is the key-value pair defining the value of each handlebar specified in the template content. Template need to be published before it can be use to send notifications&lt;br/&gt; Action Code: 50202
     */
    createNotificationTemplateNotify,
    /**
     * Delete topic information by topic name. &lt;br&gt;topic should be alphabets, no special char except underscore, uppercase and no spacing. for example: TOPIC_TEST. Already existing topic can not be created &lt;br/&gt; Action Code: 50217
     */
    deleteNotificationTopic_ByTopicName,
    /**
     * Get topic information by topic name.&lt;br/&gt; Action Code: 50215
     */
    getNotificationTopic_ByTopicName,
    /**
     * Update topic information by topic name. &lt;br&gt;topic should be alphabets, no special char except underscore, uppercase and no spacing. for example: TOPIC_TEST. Already existing topic can not be created &lt;br/&gt; Action Code: 50216
     */
    updateNotificationTopic_ByTopicName,
    /**
     * Delete template slug in notification template&lt;br&gt; Action Code: 50206
     */
    deleteNotificationTemplate_ByTemplateSlug,
    /**
     * Get all templates in a namespace&lt;br&gt; Action Code: 50205
     */
    getNotificationTemplate_ByTemplateSlug,
    /**
     * Sends notification to multiple user. Action Code: 50211
     */
    createNotificationBulkUserFreeformNotify,
    /**
     * Sends notification to a user. Action Code: 50211
     */
    createFreeformNotifyNotification_ByUserId,
    /**
     * Sends templated notification to a user. &lt;br&gt;In the request body, specify which template slug (template identifier) to use and the template language. &lt;br&gt;NotificationTemplate context is the key-value pair defining the value of each handlebar specified in the template content. Template need to be published before it can be use to send notifications&lt;br&gt; Action Code: 50212
     */
    createTemplateNotifyNotification_ByUserId,
    /**
     * Sends notification to a party.
     */
    createFreeformNotifyNotification_ByPartyId,
    /**
     * Sends templated notification to a party. &lt;br&gt;In the request body, specify which template slug (template identifier) to use and the template language. &lt;br&gt;NotificationTemplate context is the key-value pair defining the value of each handlebar specified in the template content. Template need to be published before it can be use to send notifications&lt;br&gt;
     */
    createTemplateNotifyNotification_ByPartyId,
    /**
     * Delete template localization&lt;br/&gt; Action Code: 50209
     */
    deleteLanguageNotification_ByTemplateSlug_ByTemplateLanguage,
    /**
     * Get a template localization&lt;br/&gt; Action Code: 50207
     */
    getLanguageNotification_ByTemplateSlug_ByTemplateLanguage,
    /**
     * Update template localization&lt;br/&gt; Action Code: 50208
     */
    updateLanguageNotification_ByTemplateSlug_ByTemplateLanguage,
    /**
     * Publish notification template draft. Empty draft can not be published.&lt;br/&gt; Action Code: 50210
     */
    createPublishNotification_ByTemplateSlug_ByTemplateLanguage
  };
}

// src/generated-admin/queries/NotificationAdmin.query.ts
var Key_NotificationAdmin = /* @__PURE__ */ ((Key_NotificationAdmin2) => {
  Key_NotificationAdmin2["NotificationTopics"] = "Lobby.NotificationAdmin.NotificationTopics";
  Key_NotificationAdmin2["NotificationTopic"] = "Lobby.NotificationAdmin.NotificationTopic";
  Key_NotificationAdmin2["NotificationTemplates"] = "Lobby.NotificationAdmin.NotificationTemplates";
  Key_NotificationAdmin2["NotificationTemplate"] = "Lobby.NotificationAdmin.NotificationTemplate";
  Key_NotificationAdmin2["NotificationFreeformNotify"] = "Lobby.NotificationAdmin.NotificationFreeformNotify";
  Key_NotificationAdmin2["NotificationTemplateNotify"] = "Lobby.NotificationAdmin.NotificationTemplateNotify";
  Key_NotificationAdmin2["NotificationTopic_ByTopicName"] = "Lobby.NotificationAdmin.NotificationTopic_ByTopicName";
  Key_NotificationAdmin2["NotificationTemplate_ByTemplateSlug"] = "Lobby.NotificationAdmin.NotificationTemplate_ByTemplateSlug";
  Key_NotificationAdmin2["NotificationBulkUserFreeformNotify"] = "Lobby.NotificationAdmin.NotificationBulkUserFreeformNotify";
  Key_NotificationAdmin2["FreeformNotifyNotification_ByUserId"] = "Lobby.NotificationAdmin.FreeformNotifyNotification_ByUserId";
  Key_NotificationAdmin2["TemplateNotifyNotification_ByUserId"] = "Lobby.NotificationAdmin.TemplateNotifyNotification_ByUserId";
  Key_NotificationAdmin2["FreeformNotifyNotification_ByPartyId"] = "Lobby.NotificationAdmin.FreeformNotifyNotification_ByPartyId";
  Key_NotificationAdmin2["TemplateNotifyNotification_ByPartyId"] = "Lobby.NotificationAdmin.TemplateNotifyNotification_ByPartyId";
  Key_NotificationAdmin2["LanguageNotification_ByTemplateSlug_ByTemplateLanguage"] = "Lobby.NotificationAdmin.LanguageNotification_ByTemplateSlug_ByTemplateLanguage";
  Key_NotificationAdmin2["PublishNotification_ByTemplateSlug_ByTemplateLanguage"] = "Lobby.NotificationAdmin.PublishNotification_ByTemplateSlug_ByTemplateLanguage";
  return Key_NotificationAdmin2;
})(Key_NotificationAdmin || {});
var useNotificationAdminApi_GetNotificationTopics = (sdk, input, options, callback) => {
  const queryFn = (sdk2, input2) => async () => {
    const response = await NotificationAdminApi(sdk2, {
      coreConfig: input2.coreConfig,
      axiosConfig: input2.axiosConfig
    }).getNotificationTopics(input2.queryParams);
    callback && callback(response);
    return response.data;
  };
  return (0, import_react_query5.useQuery)({
    queryKey: ["Lobby.NotificationAdmin.NotificationTopics" /* NotificationTopics */, input],
    queryFn: queryFn(sdk, input),
    ...options
  });
};
var useNotificationAdminApi_CreateNotificationTopicMutation = (sdk, options, callback) => {
  const mutationFn = async (input) => {
    const response = await NotificationAdminApi(sdk, {
      coreConfig: input.coreConfig,
      axiosConfig: input.axiosConfig
    }).createNotificationTopic(input.data);
    callback && callback(response.data);
    return response.data;
  };
  return (0, import_react_query5.useMutation)({
    mutationKey: ["Lobby.NotificationAdmin.NotificationTopic" /* NotificationTopic */],
    mutationFn,
    ...options
  });
};
var useNotificationAdminApi_GetNotificationTemplates = (sdk, input, options, callback) => {
  const queryFn = (sdk2, input2) => async () => {
    const response = await NotificationAdminApi(sdk2, {
      coreConfig: input2.coreConfig,
      axiosConfig: input2.axiosConfig
    }).getNotificationTemplates();
    callback && callback(response);
    return response.data;
  };
  return (0, import_react_query5.useQuery)({
    queryKey: ["Lobby.NotificationAdmin.NotificationTemplates" /* NotificationTemplates */, input],
    queryFn: queryFn(sdk, input),
    ...options
  });
};
var useNotificationAdminApi_CreateNotificationTemplateMutation = (sdk, options, callback) => {
  const mutationFn = async (input) => {
    const response = await NotificationAdminApi(sdk, {
      coreConfig: input.coreConfig,
      axiosConfig: input.axiosConfig
    }).createNotificationTemplate(input.data);
    callback && callback(response.data);
    return response.data;
  };
  return (0, import_react_query5.useMutation)({
    mutationKey: ["Lobby.NotificationAdmin.NotificationTemplate" /* NotificationTemplate */],
    mutationFn,
    ...options
  });
};
var useNotificationAdminApi_CreateNotificationFreeformNotifyMutation = (sdk, options, callback) => {
  const mutationFn = async (input) => {
    const response = await NotificationAdminApi(sdk, {
      coreConfig: input.coreConfig,
      axiosConfig: input.axiosConfig
    }).createNotificationFreeformNotify(input.data);
    callback && callback(response.data);
    return response.data;
  };
  return (0, import_react_query5.useMutation)({
    mutationKey: ["Lobby.NotificationAdmin.NotificationFreeformNotify" /* NotificationFreeformNotify */],
    mutationFn,
    ...options
  });
};
var useNotificationAdminApi_CreateNotificationTemplateNotifyMutation = (sdk, options, callback) => {
  const mutationFn = async (input) => {
    const response = await NotificationAdminApi(sdk, {
      coreConfig: input.coreConfig,
      axiosConfig: input.axiosConfig
    }).createNotificationTemplateNotify(input.data);
    callback && callback(response.data);
    return response.data;
  };
  return (0, import_react_query5.useMutation)({
    mutationKey: ["Lobby.NotificationAdmin.NotificationTemplateNotify" /* NotificationTemplateNotify */],
    mutationFn,
    ...options
  });
};
var useNotificationAdminApi_DeleteNotificationTopic_ByTopicNameMutation = (sdk, options, callback) => {
  const mutationFn = async (input) => {
    const response = await NotificationAdminApi(sdk, {
      coreConfig: input.coreConfig,
      axiosConfig: input.axiosConfig
    }).deleteNotificationTopic_ByTopicName(input.topicName);
    callback && callback(response.data);
    return response.data;
  };
  return (0, import_react_query5.useMutation)({
    mutationKey: ["Lobby.NotificationAdmin.NotificationTopic_ByTopicName" /* NotificationTopic_ByTopicName */],
    mutationFn,
    ...options
  });
};
var useNotificationAdminApi_GetNotificationTopic_ByTopicName = (sdk, input, options, callback) => {
  const queryFn = (sdk2, input2) => async () => {
    const response = await NotificationAdminApi(sdk2, {
      coreConfig: input2.coreConfig,
      axiosConfig: input2.axiosConfig
    }).getNotificationTopic_ByTopicName(input2.topicName);
    callback && callback(response);
    return response.data;
  };
  return (0, import_react_query5.useQuery)({
    queryKey: ["Lobby.NotificationAdmin.NotificationTopic_ByTopicName" /* NotificationTopic_ByTopicName */, input],
    queryFn: queryFn(sdk, input),
    ...options
  });
};
var useNotificationAdminApi_UpdateNotificationTopic_ByTopicNameMutation = (sdk, options, callback) => {
  const mutationFn = async (input) => {
    const response = await NotificationAdminApi(sdk, {
      coreConfig: input.coreConfig,
      axiosConfig: input.axiosConfig
    }).updateNotificationTopic_ByTopicName(input.topicName, input.data);
    callback && callback(response.data);
    return response.data;
  };
  return (0, import_react_query5.useMutation)({
    mutationKey: ["Lobby.NotificationAdmin.NotificationTopic_ByTopicName" /* NotificationTopic_ByTopicName */],
    mutationFn,
    ...options
  });
};
var useNotificationAdminApi_DeleteNotificationTemplate_ByTemplateSlugMutation = (sdk, options, callback) => {
  const mutationFn = async (input) => {
    const response = await NotificationAdminApi(sdk, {
      coreConfig: input.coreConfig,
      axiosConfig: input.axiosConfig
    }).deleteNotificationTemplate_ByTemplateSlug(input.templateSlug);
    callback && callback(response.data);
    return response.data;
  };
  return (0, import_react_query5.useMutation)({
    mutationKey: ["Lobby.NotificationAdmin.NotificationTemplate_ByTemplateSlug" /* NotificationTemplate_ByTemplateSlug */],
    mutationFn,
    ...options
  });
};
var useNotificationAdminApi_GetNotificationTemplate_ByTemplateSlug = (sdk, input, options, callback) => {
  const queryFn = (sdk2, input2) => async () => {
    const response = await NotificationAdminApi(sdk2, {
      coreConfig: input2.coreConfig,
      axiosConfig: input2.axiosConfig
    }).getNotificationTemplate_ByTemplateSlug(input2.templateSlug, input2.queryParams);
    callback && callback(response);
    return response.data;
  };
  return (0, import_react_query5.useQuery)({
    queryKey: ["Lobby.NotificationAdmin.NotificationTemplate_ByTemplateSlug" /* NotificationTemplate_ByTemplateSlug */, input],
    queryFn: queryFn(sdk, input),
    ...options
  });
};
var useNotificationAdminApi_CreateNotificationBulkUserFreeformNotifyMutation = (sdk, options, callback) => {
  const mutationFn = async (input) => {
    const response = await NotificationAdminApi(sdk, {
      coreConfig: input.coreConfig,
      axiosConfig: input.axiosConfig
    }).createNotificationBulkUserFreeformNotify(input.data);
    callback && callback(response.data);
    return response.data;
  };
  return (0, import_react_query5.useMutation)({
    mutationKey: ["Lobby.NotificationAdmin.NotificationBulkUserFreeformNotify" /* NotificationBulkUserFreeformNotify */],
    mutationFn,
    ...options
  });
};
var useNotificationAdminApi_CreateFreeformNotifyNotification_ByUserIdMutation = (sdk, options, callback) => {
  const mutationFn = async (input) => {
    const response = await NotificationAdminApi(sdk, {
      coreConfig: input.coreConfig,
      axiosConfig: input.axiosConfig
    }).createFreeformNotifyNotification_ByUserId(input.userId, input.data);
    callback && callback(response.data);
    return response.data;
  };
  return (0, import_react_query5.useMutation)({
    mutationKey: ["Lobby.NotificationAdmin.FreeformNotifyNotification_ByUserId" /* FreeformNotifyNotification_ByUserId */],
    mutationFn,
    ...options
  });
};
var useNotificationAdminApi_CreateTemplateNotifyNotification_ByUserIdMutation = (sdk, options, callback) => {
  const mutationFn = async (input) => {
    const response = await NotificationAdminApi(sdk, {
      coreConfig: input.coreConfig,
      axiosConfig: input.axiosConfig
    }).createTemplateNotifyNotification_ByUserId(input.userId, input.data);
    callback && callback(response.data);
    return response.data;
  };
  return (0, import_react_query5.useMutation)({
    mutationKey: ["Lobby.NotificationAdmin.TemplateNotifyNotification_ByUserId" /* TemplateNotifyNotification_ByUserId */],
    mutationFn,
    ...options
  });
};
var useNotificationAdminApi_CreateFreeformNotifyNotification_ByPartyIdMutation = (sdk, options, callback) => {
  const mutationFn = async (input) => {
    const response = await NotificationAdminApi(sdk, {
      coreConfig: input.coreConfig,
      axiosConfig: input.axiosConfig
    }).createFreeformNotifyNotification_ByPartyId(input.partyId, input.data);
    callback && callback(response.data);
    return response.data;
  };
  return (0, import_react_query5.useMutation)({
    mutationKey: ["Lobby.NotificationAdmin.FreeformNotifyNotification_ByPartyId" /* FreeformNotifyNotification_ByPartyId */],
    mutationFn,
    ...options
  });
};
var useNotificationAdminApi_CreateTemplateNotifyNotification_ByPartyIdMutation = (sdk, options, callback) => {
  const mutationFn = async (input) => {
    const response = await NotificationAdminApi(sdk, {
      coreConfig: input.coreConfig,
      axiosConfig: input.axiosConfig
    }).createTemplateNotifyNotification_ByPartyId(input.partyId, input.data);
    callback && callback(response.data);
    return response.data;
  };
  return (0, import_react_query5.useMutation)({
    mutationKey: ["Lobby.NotificationAdmin.TemplateNotifyNotification_ByPartyId" /* TemplateNotifyNotification_ByPartyId */],
    mutationFn,
    ...options
  });
};
var useNotificationAdminApi_DeleteLanguageNotification_ByTemplateSlug_ByTemplateLanguageMutation = (sdk, options, callback) => {
  const mutationFn = async (input) => {
    const response = await NotificationAdminApi(sdk, {
      coreConfig: input.coreConfig,
      axiosConfig: input.axiosConfig
    }).deleteLanguageNotification_ByTemplateSlug_ByTemplateLanguage(input.templateSlug, input.templateLanguage);
    callback && callback(response.data);
    return response.data;
  };
  return (0, import_react_query5.useMutation)({
    mutationKey: ["Lobby.NotificationAdmin.LanguageNotification_ByTemplateSlug_ByTemplateLanguage" /* LanguageNotification_ByTemplateSlug_ByTemplateLanguage */],
    mutationFn,
    ...options
  });
};
var useNotificationAdminApi_GetLanguageNotification_ByTemplateSlug_ByTemplateLanguage = (sdk, input, options, callback) => {
  const queryFn = (sdk2, input2) => async () => {
    const response = await NotificationAdminApi(sdk2, {
      coreConfig: input2.coreConfig,
      axiosConfig: input2.axiosConfig
    }).getLanguageNotification_ByTemplateSlug_ByTemplateLanguage(input2.templateSlug, input2.templateLanguage);
    callback && callback(response);
    return response.data;
  };
  return (0, import_react_query5.useQuery)({
    queryKey: ["Lobby.NotificationAdmin.LanguageNotification_ByTemplateSlug_ByTemplateLanguage" /* LanguageNotification_ByTemplateSlug_ByTemplateLanguage */, input],
    queryFn: queryFn(sdk, input),
    ...options
  });
};
var useNotificationAdminApi_UpdateLanguageNotification_ByTemplateSlug_ByTemplateLanguageMutation = (sdk, options, callback) => {
  const mutationFn = async (input) => {
    const response = await NotificationAdminApi(sdk, {
      coreConfig: input.coreConfig,
      axiosConfig: input.axiosConfig
    }).updateLanguageNotification_ByTemplateSlug_ByTemplateLanguage(input.templateSlug, input.templateLanguage, input.data);
    callback && callback(response.data);
    return response.data;
  };
  return (0, import_react_query5.useMutation)({
    mutationKey: ["Lobby.NotificationAdmin.LanguageNotification_ByTemplateSlug_ByTemplateLanguage" /* LanguageNotification_ByTemplateSlug_ByTemplateLanguage */],
    mutationFn,
    ...options
  });
};
var useNotificationAdminApi_CreatePublishNotification_ByTemplateSlug_ByTemplateLanguageMutation = (sdk, options, callback) => {
  const mutationFn = async (input) => {
    const response = await NotificationAdminApi(sdk, {
      coreConfig: input.coreConfig,
      axiosConfig: input.axiosConfig
    }).createPublishNotification_ByTemplateSlug_ByTemplateLanguage(input.templateSlug, input.templateLanguage);
    callback && callback(response.data);
    return response.data;
  };
  return (0, import_react_query5.useMutation)({
    mutationKey: ["Lobby.NotificationAdmin.PublishNotification_ByTemplateSlug_ByTemplateLanguage" /* PublishNotification_ByTemplateSlug_ByTemplateLanguage */],
    mutationFn,
    ...options
  });
};

// src/generated-admin/queries/PartyAdmin.query.ts
var import_react_query6 = require("@tanstack/react-query");

// src/generated-admin/PartyAdminApi.ts
var import_sdk12 = require("@accelbyte/sdk");

// src/generated-admin/endpoints/PartyAdmin$.ts
var import_sdk11 = require("@accelbyte/sdk");
var PartyAdmin$ = class {
  // @ts-ignore
  // prettier-ignore
  constructor(axiosInstance, namespace, useSchemaValidation = true) {
    this.axiosInstance = axiosInstance;
    this.namespace = namespace;
    this.useSchemaValidation = useSchemaValidation;
  }
  /**
   * Get party data in a namespace.
   */
  getPartyParty_ByPartyId(partyId) {
    const params = {};
    const url = "/lobby/v1/admin/party/namespaces/{namespace}/parties/{partyId}".replace("{namespace}", this.namespace).replace("{partyId}", partyId);
    const resultPromise = this.axiosInstance.get(url, { params });
    return import_sdk11.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, PartyData, "PartyData");
  }
  /**
   * Get party data in a namespace.
   */
  getParty_ByUserId(userId) {
    const params = {};
    const url = "/lobby/v1/admin/party/namespaces/{namespace}/users/{userId}/party".replace("{namespace}", this.namespace).replace("{userId}", userId);
    const resultPromise = this.axiosInstance.get(url, { params });
    return import_sdk11.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, PartyData, "PartyData");
  }
};

// src/generated-admin/PartyAdminApi.ts
function PartyAdminApi(sdk, args) {
  const sdkAssembly = sdk.assembly();
  const namespace = args?.coreConfig?.namespace ?? sdkAssembly.coreConfig.namespace;
  const useSchemaValidation = args?.coreConfig?.useSchemaValidation ?? sdkAssembly.coreConfig.useSchemaValidation;
  let axiosInstance = sdkAssembly.axiosInstance;
  const requestConfigOverrides = args?.axiosConfig?.request;
  const baseURLOverride = args?.coreConfig?.baseURL;
  const interceptorsOverride = args?.axiosConfig?.interceptors ?? [];
  if (requestConfigOverrides || baseURLOverride || interceptorsOverride.length > 0) {
    const requestConfig = import_sdk12.ApiUtils.mergeAxiosConfigs(sdkAssembly.axiosInstance.defaults, {
      ...baseURLOverride ? { baseURL: baseURLOverride } : {},
      ...requestConfigOverrides
    });
    axiosInstance = import_sdk12.Network.create(requestConfig);
    for (const interceptor of interceptorsOverride) {
      if (interceptor.type === "request") {
        axiosInstance.interceptors.request.use(interceptor.onRequest, interceptor.onError);
      }
      if (interceptor.type === "response") {
        axiosInstance.interceptors.response.use(interceptor.onSuccess, interceptor.onError);
      }
    }
  }
  async function getPartyParty_ByPartyId(partyId) {
    const $ = new PartyAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getPartyParty_ByPartyId(partyId);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getParty_ByUserId(userId) {
    const $ = new PartyAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getParty_ByUserId(userId);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  return {
    /**
     * Get party data in a namespace.
     */
    getPartyParty_ByPartyId,
    /**
     * Get party data in a namespace.
     */
    getParty_ByUserId
  };
}

// src/generated-admin/queries/PartyAdmin.query.ts
var Key_PartyAdmin = /* @__PURE__ */ ((Key_PartyAdmin2) => {
  Key_PartyAdmin2["PartyParty_ByPartyId"] = "Lobby.PartyAdmin.PartyParty_ByPartyId";
  Key_PartyAdmin2["Party_ByUserId"] = "Lobby.PartyAdmin.Party_ByUserId";
  return Key_PartyAdmin2;
})(Key_PartyAdmin || {});
var usePartyAdminApi_GetPartyParty_ByPartyId = (sdk, input, options, callback) => {
  const queryFn = (sdk2, input2) => async () => {
    const response = await PartyAdminApi(sdk2, { coreConfig: input2.coreConfig, axiosConfig: input2.axiosConfig }).getPartyParty_ByPartyId(
      input2.partyId
    );
    callback && callback(response);
    return response.data;
  };
  return (0, import_react_query6.useQuery)({
    queryKey: ["Lobby.PartyAdmin.PartyParty_ByPartyId" /* PartyParty_ByPartyId */, input],
    queryFn: queryFn(sdk, input),
    ...options
  });
};
var usePartyAdminApi_GetParty_ByUserId = (sdk, input, options, callback) => {
  const queryFn = (sdk2, input2) => async () => {
    const response = await PartyAdminApi(sdk2, { coreConfig: input2.coreConfig, axiosConfig: input2.axiosConfig }).getParty_ByUserId(
      input2.userId
    );
    callback && callback(response);
    return response.data;
  };
  return (0, import_react_query6.useQuery)({
    queryKey: ["Lobby.PartyAdmin.Party_ByUserId" /* Party_ByUserId */, input],
    queryFn: queryFn(sdk, input),
    ...options
  });
};

// src/generated-admin/queries/PlayerAdmin.query.ts
var import_react_query7 = require("@tanstack/react-query");

// src/generated-admin/PlayerAdminApi.ts
var import_sdk14 = require("@accelbyte/sdk");

// src/generated-admin/endpoints/PlayerAdmin$.ts
var import_sdk13 = require("@accelbyte/sdk");
var import_zod36 = require("zod");

// src/generated-definitions/GetAllPlayerBlockedByUsersResponse.ts
var import_zod29 = require("zod");

// src/generated-definitions/BlockedByPlayerData.ts
var import_zod28 = require("zod");
var BlockedByPlayerData = import_zod28.z.object({ blockedAt: import_zod28.z.string(), userId: import_zod28.z.string() });

// src/generated-definitions/GetAllPlayerBlockedByUsersResponse.ts
var GetAllPlayerBlockedByUsersResponse = import_zod29.z.object({ data: import_zod29.z.array(BlockedByPlayerData) });

// src/generated-definitions/GetAllPlayerBlockedUsersResponse.ts
var import_zod31 = require("zod");

// src/generated-definitions/BlockedPlayerData.ts
var import_zod30 = require("zod");
var BlockedPlayerData = import_zod30.z.object({ blockedAt: import_zod30.z.string(), blockedUserId: import_zod30.z.string() });

// src/generated-definitions/GetAllPlayerBlockedUsersResponse.ts
var GetAllPlayerBlockedUsersResponse = import_zod31.z.object({ data: import_zod31.z.array(BlockedPlayerData) });

// src/generated-definitions/GetAllPlayerSessionAttributeResponse.ts
var import_zod32 = require("zod");
var GetAllPlayerSessionAttributeResponse = import_zod32.z.object({ attributes: import_zod32.z.record(import_zod32.z.string()) });

// src/generated-definitions/GetBulkAllPlayerBlockedUsersResponse.ts
var import_zod33 = require("zod");
var GetBulkAllPlayerBlockedUsersResponse = import_zod33.z.object({ data: import_zod33.z.record(import_zod33.z.array(BlockedPlayerData)) });

// src/generated-definitions/GetLobbyCcuResponse.ts
var import_zod34 = require("zod");
var GetLobbyCcuResponse = import_zod34.z.object({ countCurrentUsers: import_zod34.z.number().int() });

// src/generated-definitions/GetPlayerSessionAttributeResponse.ts
var import_zod35 = require("zod");
var GetPlayerSessionAttributeResponse = import_zod35.z.object({ key: import_zod35.z.string(), value: import_zod35.z.string() });

// src/generated-admin/endpoints/PlayerAdmin$.ts
var PlayerAdmin$ = class {
  // @ts-ignore
  // prettier-ignore
  constructor(axiosInstance, namespace, useSchemaValidation = true) {
    this.axiosInstance = axiosInstance;
    this.namespace = namespace;
    this.useSchemaValidation = useSchemaValidation;
  }
  /**
   * Get the number of players connected to the Lobby in the given namespace.
   */
  getPlayerCcu() {
    const params = {};
    const url = "/lobby/v1/admin/player/namespaces/{namespace}/ccu".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.get(url, { params });
    return import_sdk13.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, GetLobbyCcuResponse, "GetLobbyCcuResponse");
  }
  /**
   * Get blocked players data by bulk user ids in a namespace.
   */
  fetchPlayerUserBulkBlocked(data) {
    const params = {};
    const url = "/lobby/v1/admin/player/namespaces/{namespace}/users/bulk/blocked".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.post(url, data, { params });
    return import_sdk13.Validate.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      GetBulkAllPlayerBlockedUsersResponse,
      "GetBulkAllPlayerBlockedUsersResponse"
    );
  }
  /**
   * Get blocked players data by user id in a namespace.
   */
  getBlockedPlayer_ByUserId(userId) {
    const params = {};
    const url = "/lobby/v1/admin/player/namespaces/{namespace}/users/{userId}/blocked".replace("{namespace}", this.namespace).replace("{userId}", userId);
    const resultPromise = this.axiosInstance.get(url, { params });
    return import_sdk13.Validate.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      GetAllPlayerBlockedUsersResponse,
      "GetAllPlayerBlockedUsersResponse"
    );
  }
  /**
   * Get all player&#39;s session attribute by user id in a namespace.
   */
  getAttributesPlayer_ByUserId(userId) {
    const params = {};
    const url = "/lobby/v1/admin/player/namespaces/{namespace}/users/{userId}/attributes".replace("{namespace}", this.namespace).replace("{userId}", userId);
    const resultPromise = this.axiosInstance.get(url, { params });
    return import_sdk13.Validate.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      GetAllPlayerSessionAttributeResponse,
      "GetAllPlayerSessionAttributeResponse"
    );
  }
  /**
   * Set player&#39;s session attribute by user id in a namespace.
   */
  updateAttributePlayer_ByUserId(userId, data) {
    const params = {};
    const url = "/lobby/v1/admin/player/namespaces/{namespace}/users/{userId}/attributes".replace("{namespace}", this.namespace).replace("{userId}", userId);
    const resultPromise = this.axiosInstance.put(url, data, { params });
    return import_sdk13.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, import_zod36.z.unknown(), "z.unknown()");
  }
  /**
   * Load get players who blocked this player in a namespace based on user id
   */
  getBlockedByPlayer_ByUserId(userId) {
    const params = {};
    const url = "/lobby/v1/admin/player/namespaces/{namespace}/users/{userId}/blocked-by".replace("{namespace}", this.namespace).replace("{userId}", userId);
    const resultPromise = this.axiosInstance.get(url, { params });
    return import_sdk13.Validate.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      GetAllPlayerBlockedByUsersResponse,
      "GetAllPlayerBlockedByUsersResponse"
    );
  }
  /**
   * Bulk block player in a namespace by list of user id
   */
  createBulkBlockPlayer_ByUserId(userId, data) {
    const params = {};
    const url = "/lobby/v1/admin/player/namespaces/{namespace}/users/{userId}/bulk/block".replace("{namespace}", this.namespace).replace("{userId}", userId);
    const resultPromise = this.axiosInstance.post(url, data, { params });
    return import_sdk13.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, import_zod36.z.unknown(), "z.unknown()");
  }
  /**
   * Bulk unblock player in a namespace by list of user id
   */
  deleteBulkUnblockPlayer_ByUserId(userId, data) {
    const params = {};
    const url = "/lobby/v1/admin/player/namespaces/{namespace}/users/{userId}/bulk/unblock".replace("{namespace}", this.namespace).replace("{userId}", userId);
    const resultPromise = this.axiosInstance.delete(url, { data, params });
    return import_sdk13.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, import_zod36.z.unknown(), "z.unknown()");
  }
  /**
   * Get player&#39;s specific session attribute by user id in a namespace.
   */
  getAttributePlayer_ByUserId_ByAttribute(userId, attribute) {
    const params = {};
    const url = "/lobby/v1/admin/player/namespaces/{namespace}/users/{userId}/attributes/{attribute}".replace("{namespace}", this.namespace).replace("{userId}", userId).replace("{attribute}", attribute);
    const resultPromise = this.axiosInstance.get(url, { params });
    return import_sdk13.Validate.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      GetPlayerSessionAttributeResponse,
      "GetPlayerSessionAttributeResponse"
    );
  }
};

// src/generated-admin/PlayerAdminApi.ts
function PlayerAdminApi(sdk, args) {
  const sdkAssembly = sdk.assembly();
  const namespace = args?.coreConfig?.namespace ?? sdkAssembly.coreConfig.namespace;
  const useSchemaValidation = args?.coreConfig?.useSchemaValidation ?? sdkAssembly.coreConfig.useSchemaValidation;
  let axiosInstance = sdkAssembly.axiosInstance;
  const requestConfigOverrides = args?.axiosConfig?.request;
  const baseURLOverride = args?.coreConfig?.baseURL;
  const interceptorsOverride = args?.axiosConfig?.interceptors ?? [];
  if (requestConfigOverrides || baseURLOverride || interceptorsOverride.length > 0) {
    const requestConfig = import_sdk14.ApiUtils.mergeAxiosConfigs(sdkAssembly.axiosInstance.defaults, {
      ...baseURLOverride ? { baseURL: baseURLOverride } : {},
      ...requestConfigOverrides
    });
    axiosInstance = import_sdk14.Network.create(requestConfig);
    for (const interceptor of interceptorsOverride) {
      if (interceptor.type === "request") {
        axiosInstance.interceptors.request.use(interceptor.onRequest, interceptor.onError);
      }
      if (interceptor.type === "response") {
        axiosInstance.interceptors.response.use(interceptor.onSuccess, interceptor.onError);
      }
    }
  }
  async function getPlayerCcu() {
    const $ = new PlayerAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getPlayerCcu();
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function fetchPlayerUserBulkBlocked(data) {
    const $ = new PlayerAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.fetchPlayerUserBulkBlocked(data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getBlockedPlayer_ByUserId(userId) {
    const $ = new PlayerAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getBlockedPlayer_ByUserId(userId);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getAttributesPlayer_ByUserId(userId) {
    const $ = new PlayerAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getAttributesPlayer_ByUserId(userId);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function updateAttributePlayer_ByUserId(userId, data) {
    const $ = new PlayerAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.updateAttributePlayer_ByUserId(userId, data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getBlockedByPlayer_ByUserId(userId) {
    const $ = new PlayerAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getBlockedByPlayer_ByUserId(userId);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function createBulkBlockPlayer_ByUserId(userId, data) {
    const $ = new PlayerAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.createBulkBlockPlayer_ByUserId(userId, data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function deleteBulkUnblockPlayer_ByUserId(userId, data) {
    const $ = new PlayerAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.deleteBulkUnblockPlayer_ByUserId(userId, data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getAttributePlayer_ByUserId_ByAttribute(userId, attribute) {
    const $ = new PlayerAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getAttributePlayer_ByUserId_ByAttribute(userId, attribute);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  return {
    /**
     * Get the number of players connected to the Lobby in the given namespace.
     */
    getPlayerCcu,
    /**
     * Get blocked players data by bulk user ids in a namespace.
     */
    fetchPlayerUserBulkBlocked,
    /**
     * Get blocked players data by user id in a namespace.
     */
    getBlockedPlayer_ByUserId,
    /**
     * Get all player&#39;s session attribute by user id in a namespace.
     */
    getAttributesPlayer_ByUserId,
    /**
     * Set player&#39;s session attribute by user id in a namespace.
     */
    updateAttributePlayer_ByUserId,
    /**
     * Load get players who blocked this player in a namespace based on user id
     */
    getBlockedByPlayer_ByUserId,
    /**
     * Bulk block player in a namespace by list of user id
     */
    createBulkBlockPlayer_ByUserId,
    /**
     * Bulk unblock player in a namespace by list of user id
     */
    deleteBulkUnblockPlayer_ByUserId,
    /**
     * Get player&#39;s specific session attribute by user id in a namespace.
     */
    getAttributePlayer_ByUserId_ByAttribute
  };
}

// src/generated-admin/queries/PlayerAdmin.query.ts
var Key_PlayerAdmin = /* @__PURE__ */ ((Key_PlayerAdmin2) => {
  Key_PlayerAdmin2["PlayerCcu"] = "Lobby.PlayerAdmin.PlayerCcu";
  Key_PlayerAdmin2["PlayerUserBulkBlocked"] = "Lobby.PlayerAdmin.PlayerUserBulkBlocked";
  Key_PlayerAdmin2["BlockedPlayer_ByUserId"] = "Lobby.PlayerAdmin.BlockedPlayer_ByUserId";
  Key_PlayerAdmin2["AttributesPlayer_ByUserId"] = "Lobby.PlayerAdmin.AttributesPlayer_ByUserId";
  Key_PlayerAdmin2["AttributePlayer_ByUserId"] = "Lobby.PlayerAdmin.AttributePlayer_ByUserId";
  Key_PlayerAdmin2["BlockedByPlayer_ByUserId"] = "Lobby.PlayerAdmin.BlockedByPlayer_ByUserId";
  Key_PlayerAdmin2["BulkBlockPlayer_ByUserId"] = "Lobby.PlayerAdmin.BulkBlockPlayer_ByUserId";
  Key_PlayerAdmin2["BulkUnblockPlayer_ByUserId"] = "Lobby.PlayerAdmin.BulkUnblockPlayer_ByUserId";
  Key_PlayerAdmin2["AttributePlayer_ByUserId_ByAttribute"] = "Lobby.PlayerAdmin.AttributePlayer_ByUserId_ByAttribute";
  return Key_PlayerAdmin2;
})(Key_PlayerAdmin || {});
var usePlayerAdminApi_GetPlayerCcu = (sdk, input, options, callback) => {
  const queryFn = (sdk2, input2) => async () => {
    const response = await PlayerAdminApi(sdk2, { coreConfig: input2.coreConfig, axiosConfig: input2.axiosConfig }).getPlayerCcu();
    callback && callback(response);
    return response.data;
  };
  return (0, import_react_query7.useQuery)({
    queryKey: ["Lobby.PlayerAdmin.PlayerCcu" /* PlayerCcu */, input],
    queryFn: queryFn(sdk, input),
    ...options
  });
};
var usePlayerAdminApi_FetchPlayerUserBulkBlocked = (sdk, input, options, callback) => {
  const queryFn = (sdk2, input2) => async () => {
    const response = await PlayerAdminApi(sdk2, { coreConfig: input2.coreConfig, axiosConfig: input2.axiosConfig }).fetchPlayerUserBulkBlocked(
      input2.data
    );
    callback && callback(response);
    return response.data;
  };
  return (0, import_react_query7.useQuery)({
    queryKey: ["Lobby.PlayerAdmin.PlayerUserBulkBlocked" /* PlayerUserBulkBlocked */, input],
    queryFn: queryFn(sdk, input),
    ...options
  });
};
var usePlayerAdminApi_GetBlockedPlayer_ByUserId = (sdk, input, options, callback) => {
  const queryFn = (sdk2, input2) => async () => {
    const response = await PlayerAdminApi(sdk2, { coreConfig: input2.coreConfig, axiosConfig: input2.axiosConfig }).getBlockedPlayer_ByUserId(
      input2.userId
    );
    callback && callback(response);
    return response.data;
  };
  return (0, import_react_query7.useQuery)({
    queryKey: ["Lobby.PlayerAdmin.BlockedPlayer_ByUserId" /* BlockedPlayer_ByUserId */, input],
    queryFn: queryFn(sdk, input),
    ...options
  });
};
var usePlayerAdminApi_GetAttributesPlayer_ByUserId = (sdk, input, options, callback) => {
  const queryFn = (sdk2, input2) => async () => {
    const response = await PlayerAdminApi(sdk2, {
      coreConfig: input2.coreConfig,
      axiosConfig: input2.axiosConfig
    }).getAttributesPlayer_ByUserId(input2.userId);
    callback && callback(response);
    return response.data;
  };
  return (0, import_react_query7.useQuery)({
    queryKey: ["Lobby.PlayerAdmin.AttributesPlayer_ByUserId" /* AttributesPlayer_ByUserId */, input],
    queryFn: queryFn(sdk, input),
    ...options
  });
};
var usePlayerAdminApi_UpdateAttributePlayer_ByUserIdMutation = (sdk, options, callback) => {
  const mutationFn = async (input) => {
    const response = await PlayerAdminApi(sdk, {
      coreConfig: input.coreConfig,
      axiosConfig: input.axiosConfig
    }).updateAttributePlayer_ByUserId(input.userId, input.data);
    callback && callback(response.data);
    return response.data;
  };
  return (0, import_react_query7.useMutation)({
    mutationKey: ["Lobby.PlayerAdmin.AttributePlayer_ByUserId" /* AttributePlayer_ByUserId */],
    mutationFn,
    ...options
  });
};
var usePlayerAdminApi_GetBlockedByPlayer_ByUserId = (sdk, input, options, callback) => {
  const queryFn = (sdk2, input2) => async () => {
    const response = await PlayerAdminApi(sdk2, {
      coreConfig: input2.coreConfig,
      axiosConfig: input2.axiosConfig
    }).getBlockedByPlayer_ByUserId(input2.userId);
    callback && callback(response);
    return response.data;
  };
  return (0, import_react_query7.useQuery)({
    queryKey: ["Lobby.PlayerAdmin.BlockedByPlayer_ByUserId" /* BlockedByPlayer_ByUserId */, input],
    queryFn: queryFn(sdk, input),
    ...options
  });
};
var usePlayerAdminApi_CreateBulkBlockPlayer_ByUserIdMutation = (sdk, options, callback) => {
  const mutationFn = async (input) => {
    const response = await PlayerAdminApi(sdk, {
      coreConfig: input.coreConfig,
      axiosConfig: input.axiosConfig
    }).createBulkBlockPlayer_ByUserId(input.userId, input.data);
    callback && callback(response.data);
    return response.data;
  };
  return (0, import_react_query7.useMutation)({
    mutationKey: ["Lobby.PlayerAdmin.BulkBlockPlayer_ByUserId" /* BulkBlockPlayer_ByUserId */],
    mutationFn,
    ...options
  });
};
var usePlayerAdminApi_DeleteBulkUnblockPlayer_ByUserIdMutation = (sdk, options, callback) => {
  const mutationFn = async (input) => {
    const response = await PlayerAdminApi(sdk, {
      coreConfig: input.coreConfig,
      axiosConfig: input.axiosConfig
    }).deleteBulkUnblockPlayer_ByUserId(input.userId, input.data);
    callback && callback(response.data);
    return response.data;
  };
  return (0, import_react_query7.useMutation)({
    mutationKey: ["Lobby.PlayerAdmin.BulkUnblockPlayer_ByUserId" /* BulkUnblockPlayer_ByUserId */],
    mutationFn,
    ...options
  });
};
var usePlayerAdminApi_GetAttributePlayer_ByUserId_ByAttribute = (sdk, input, options, callback) => {
  const queryFn = (sdk2, input2) => async () => {
    const response = await PlayerAdminApi(sdk2, {
      coreConfig: input2.coreConfig,
      axiosConfig: input2.axiosConfig
    }).getAttributePlayer_ByUserId_ByAttribute(input2.userId, input2.attribute);
    callback && callback(response);
    return response.data;
  };
  return (0, import_react_query7.useQuery)({
    queryKey: ["Lobby.PlayerAdmin.AttributePlayer_ByUserId_ByAttribute" /* AttributePlayer_ByUserId_ByAttribute */, input],
    queryFn: queryFn(sdk, input),
    ...options
  });
};

// src/generated-admin/queries/ProfanityAdmin.query.ts
var import_react_query8 = require("@tanstack/react-query");

// src/generated-admin/ProfanityAdminApi.ts
var import_sdk16 = require("@accelbyte/sdk");

// src/generated-admin/endpoints/ProfanityAdmin$.ts
var import_sdk15 = require("@accelbyte/sdk");
var import_zod44 = require("zod");

// src/generated-definitions/AdminGetProfanityListFiltersV1Response.ts
var import_zod38 = require("zod");

// src/generated-definitions/ProfanityFilter.ts
var import_zod37 = require("zod");
var ProfanityFilter = import_zod37.z.object({ filter: import_zod37.z.string(), listName: import_zod37.z.string(), namespace: import_zod37.z.string(), note: import_zod37.z.string() });

// src/generated-definitions/AdminGetProfanityListFiltersV1Response.ts
var AdminGetProfanityListFiltersV1Response = import_zod38.z.object({ filters: import_zod38.z.array(ProfanityFilter) });

// src/generated-definitions/AdminGetProfanityListsListResponseArray.ts
var import_zod40 = require("zod");

// src/generated-definitions/AdminGetProfanityListsListResponse.ts
var import_zod39 = require("zod");
var AdminGetProfanityListsListResponse = import_zod39.z.object({ isEnabled: import_zod39.z.boolean(), isMandatory: import_zod39.z.boolean(), name: import_zod39.z.string() });

// src/generated-definitions/AdminGetProfanityListsListResponseArray.ts
var AdminGetProfanityListsListResponseArray = import_zod40.z.array(AdminGetProfanityListsListResponse);

// src/generated-definitions/AdminVerifyMessageProfanityResponse.ts
var import_zod41 = require("zod");
var AdminVerifyMessageProfanityResponse = import_zod41.z.object({ filteredMessage: import_zod41.z.string(), hasProfanity: import_zod41.z.boolean() });

// src/generated-definitions/ProfanityFilterArray.ts
var import_zod42 = require("zod");
var ProfanityFilterArray = import_zod42.z.array(ProfanityFilter);

// src/generated-definitions/ProfanityRule.ts
var import_zod43 = require("zod");
var ProfanityRule = import_zod43.z.object({ Namespace: import_zod43.z.string(), Rule: import_zod43.z.string() });

// src/generated-admin/endpoints/ProfanityAdmin$.ts
var ProfanityAdmin$ = class {
  // @ts-ignore
  // prettier-ignore
  constructor(axiosInstance, namespace, useSchemaValidation = true) {
    this.axiosInstance = axiosInstance;
    this.namespace = namespace;
    this.useSchemaValidation = useSchemaValidation;
  }
  /**
   * Get current profanity rule
   */
  getProfanityRule() {
    const params = {};
    const url = "/lobby/v1/admin/profanity/namespaces/{namespace}/rule".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.get(url, { params });
    return import_sdk15.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, ProfanityRule, "ProfanityRule");
  }
  /**
   * Set current profanity rule
   */
  updateProfanityRule(data) {
    const params = {};
    const url = "/lobby/v1/admin/profanity/namespaces/{namespace}/rule".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.post(url, data, { params });
    return import_sdk15.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, import_zod44.z.unknown(), "z.unknown()");
  }
  /**
   * Get lists
   */
  getProfanityLists() {
    const params = {};
    const url = "/lobby/v1/admin/profanity/namespaces/{namespace}/lists".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.get(url, { params });
    return import_sdk15.Validate.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      AdminGetProfanityListsListResponseArray,
      "AdminGetProfanityListsListResponseArray"
    );
  }
  /**
   * Create a new list
   */
  createProfanityList(data) {
    const params = {};
    const url = "/lobby/v1/admin/profanity/namespaces/{namespace}/lists".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.post(url, data, { params });
    return import_sdk15.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, import_zod44.z.unknown(), "z.unknown()");
  }
  /**
   * Verify a message directly from the UI or other services
   */
  fetchProfanityVerify(data) {
    const params = {};
    const url = "/lobby/v1/admin/profanity/namespaces/{namespace}/verify".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.post(url, data, { params });
    return import_sdk15.Validate.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      AdminVerifyMessageProfanityResponse,
      "AdminVerifyMessageProfanityResponse"
    );
  }
  /**
   * Delete a list include all filters inside of it
   */
  deleteProfanityList_ByList(list) {
    const params = {};
    const url = "/lobby/v1/admin/profanity/namespaces/{namespace}/lists/{list}".replace("{namespace}", this.namespace).replace("{list}", list);
    const resultPromise = this.axiosInstance.delete(url, { params });
    return import_sdk15.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, import_zod44.z.unknown(), "z.unknown()");
  }
  /**
   * Update the list
   */
  updateProfanityList_ByList(list, data) {
    const params = {};
    const url = "/lobby/v1/admin/profanity/namespaces/{namespace}/lists/{list}".replace("{namespace}", this.namespace).replace("{list}", list);
    const resultPromise = this.axiosInstance.post(url, data, { params });
    return import_sdk15.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, import_zod44.z.unknown(), "z.unknown()");
  }
  /**
   * Get the list of filters that would modify the phrase
   */
  fetchProfanityFilterDebug(data) {
    const params = {};
    const url = "/lobby/v1/admin/profanity/namespaces/{namespace}/filters/debug".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.post(url, data, { params });
    return import_sdk15.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, ProfanityFilterArray, "ProfanityFilterArray");
  }
  /**
   * Get the list of filters inside the list.
   */
  getFiltersProfanity_ByList(list) {
    const params = {};
    const url = "/lobby/v1/admin/profanity/namespaces/{namespace}/list/{list}/filters".replace("{namespace}", this.namespace).replace("{list}", list);
    const resultPromise = this.axiosInstance.get(url, { params });
    return import_sdk15.Validate.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      AdminGetProfanityListFiltersV1Response,
      "AdminGetProfanityListFiltersV1Response"
    );
  }
  /**
   * Add a single filter into the list
   */
  createFilterProfanity_ByList(list, data) {
    const params = {};
    const url = "/lobby/v1/admin/profanity/namespaces/{namespace}/list/{list}/filters".replace("{namespace}", this.namespace).replace("{list}", list);
    const resultPromise = this.axiosInstance.post(url, data, { params });
    return import_sdk15.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, import_zod44.z.unknown(), "z.unknown()");
  }
  /**
   * Add multiple filters into the list
   */
  createFilterBulkProfanity_ByList(list, data) {
    const params = {};
    const url = "/lobby/v1/admin/profanity/namespaces/{namespace}/list/{list}/filters/bulk".replace("{namespace}", this.namespace).replace("{list}", list);
    const resultPromise = this.axiosInstance.post(url, data, { params });
    return import_sdk15.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, import_zod44.z.unknown(), "z.unknown()");
  }
  /**
   * Delete the filter from the list
   */
  createFilterDeleteProfanity_ByList(list, data) {
    const params = {};
    const url = "/lobby/v1/admin/profanity/namespaces/{namespace}/list/{list}/filters/delete".replace("{namespace}", this.namespace).replace("{list}", list);
    const resultPromise = this.axiosInstance.post(url, data, { params });
    return import_sdk15.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, ProfanityFilterArray, "ProfanityFilterArray");
  }
  /**
   * Import a file with filters
   */
  createFilterBulkFileProfanity_ByList(list, data) {
    const params = {};
    const url = "/lobby/v1/admin/profanity/namespaces/{namespace}/list/{list}/filters/bulk-file".replace("{namespace}", this.namespace).replace("{list}", list);
    const resultPromise = this.axiosInstance.post(url, data, { params });
    return import_sdk15.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, import_zod44.z.unknown(), "z.unknown()");
  }
};

// src/generated-admin/ProfanityAdminApi.ts
function ProfanityAdminApi(sdk, args) {
  const sdkAssembly = sdk.assembly();
  const namespace = args?.coreConfig?.namespace ?? sdkAssembly.coreConfig.namespace;
  const useSchemaValidation = args?.coreConfig?.useSchemaValidation ?? sdkAssembly.coreConfig.useSchemaValidation;
  let axiosInstance = sdkAssembly.axiosInstance;
  const requestConfigOverrides = args?.axiosConfig?.request;
  const baseURLOverride = args?.coreConfig?.baseURL;
  const interceptorsOverride = args?.axiosConfig?.interceptors ?? [];
  if (requestConfigOverrides || baseURLOverride || interceptorsOverride.length > 0) {
    const requestConfig = import_sdk16.ApiUtils.mergeAxiosConfigs(sdkAssembly.axiosInstance.defaults, {
      ...baseURLOverride ? { baseURL: baseURLOverride } : {},
      ...requestConfigOverrides
    });
    axiosInstance = import_sdk16.Network.create(requestConfig);
    for (const interceptor of interceptorsOverride) {
      if (interceptor.type === "request") {
        axiosInstance.interceptors.request.use(interceptor.onRequest, interceptor.onError);
      }
      if (interceptor.type === "response") {
        axiosInstance.interceptors.response.use(interceptor.onSuccess, interceptor.onError);
      }
    }
  }
  async function getProfanityRule() {
    const $ = new ProfanityAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getProfanityRule();
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function updateProfanityRule(data) {
    const $ = new ProfanityAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.updateProfanityRule(data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getProfanityLists() {
    const $ = new ProfanityAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getProfanityLists();
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function createProfanityList(data) {
    const $ = new ProfanityAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.createProfanityList(data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function fetchProfanityVerify(data) {
    const $ = new ProfanityAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.fetchProfanityVerify(data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function deleteProfanityList_ByList(list) {
    const $ = new ProfanityAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.deleteProfanityList_ByList(list);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function updateProfanityList_ByList(list, data) {
    const $ = new ProfanityAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.updateProfanityList_ByList(list, data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function fetchProfanityFilterDebug(data) {
    const $ = new ProfanityAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.fetchProfanityFilterDebug(data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getFiltersProfanity_ByList(list) {
    const $ = new ProfanityAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getFiltersProfanity_ByList(list);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function createFilterProfanity_ByList(list, data) {
    const $ = new ProfanityAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.createFilterProfanity_ByList(list, data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function createFilterBulkProfanity_ByList(list, data) {
    const $ = new ProfanityAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.createFilterBulkProfanity_ByList(list, data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function createFilterDeleteProfanity_ByList(list, data) {
    const $ = new ProfanityAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.createFilterDeleteProfanity_ByList(list, data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function createFilterBulkFileProfanity_ByList(list, data) {
    const $ = new ProfanityAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.createFilterBulkFileProfanity_ByList(list, data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  return {
    /**
     * Get current profanity rule
     */
    getProfanityRule,
    /**
     * Set current profanity rule
     */
    updateProfanityRule,
    /**
     * Get lists
     */
    getProfanityLists,
    /**
     * Create a new list
     */
    createProfanityList,
    /**
     * Verify a message directly from the UI or other services
     */
    fetchProfanityVerify,
    /**
     * Delete a list include all filters inside of it
     */
    deleteProfanityList_ByList,
    /**
     * Update the list
     */
    updateProfanityList_ByList,
    /**
     * Get the list of filters that would modify the phrase
     */
    fetchProfanityFilterDebug,
    /**
     * Get the list of filters inside the list.
     */
    getFiltersProfanity_ByList,
    /**
     * Add a single filter into the list
     */
    createFilterProfanity_ByList,
    /**
     * Add multiple filters into the list
     */
    createFilterBulkProfanity_ByList,
    /**
     * Delete the filter from the list
     */
    createFilterDeleteProfanity_ByList,
    /**
     * Import a file with filters
     */
    createFilterBulkFileProfanity_ByList
  };
}

// src/generated-admin/queries/ProfanityAdmin.query.ts
var Key_ProfanityAdmin = /* @__PURE__ */ ((Key_ProfanityAdmin2) => {
  Key_ProfanityAdmin2["ProfanityRule"] = "Lobby.ProfanityAdmin.ProfanityRule";
  Key_ProfanityAdmin2["ProfanityLists"] = "Lobby.ProfanityAdmin.ProfanityLists";
  Key_ProfanityAdmin2["ProfanityList"] = "Lobby.ProfanityAdmin.ProfanityList";
  Key_ProfanityAdmin2["ProfanityVerify"] = "Lobby.ProfanityAdmin.ProfanityVerify";
  Key_ProfanityAdmin2["ProfanityList_ByList"] = "Lobby.ProfanityAdmin.ProfanityList_ByList";
  Key_ProfanityAdmin2["ProfanityFilterDebug"] = "Lobby.ProfanityAdmin.ProfanityFilterDebug";
  Key_ProfanityAdmin2["FiltersProfanity_ByList"] = "Lobby.ProfanityAdmin.FiltersProfanity_ByList";
  Key_ProfanityAdmin2["FilterProfanity_ByList"] = "Lobby.ProfanityAdmin.FilterProfanity_ByList";
  Key_ProfanityAdmin2["FilterBulkProfanity_ByList"] = "Lobby.ProfanityAdmin.FilterBulkProfanity_ByList";
  Key_ProfanityAdmin2["FilterDeleteProfanity_ByList"] = "Lobby.ProfanityAdmin.FilterDeleteProfanity_ByList";
  Key_ProfanityAdmin2["FilterBulkFileProfanity_ByList"] = "Lobby.ProfanityAdmin.FilterBulkFileProfanity_ByList";
  return Key_ProfanityAdmin2;
})(Key_ProfanityAdmin || {});
var useProfanityAdminApi_GetProfanityRule = (sdk, input, options, callback) => {
  const queryFn = (sdk2, input2) => async () => {
    const response = await ProfanityAdminApi(sdk2, { coreConfig: input2.coreConfig, axiosConfig: input2.axiosConfig }).getProfanityRule();
    callback && callback(response);
    return response.data;
  };
  return (0, import_react_query8.useQuery)({
    queryKey: ["Lobby.ProfanityAdmin.ProfanityRule" /* ProfanityRule */, input],
    queryFn: queryFn(sdk, input),
    ...options
  });
};
var useProfanityAdminApi_UpdateProfanityRuleMutation = (sdk, options, callback) => {
  const mutationFn = async (input) => {
    const response = await ProfanityAdminApi(sdk, { coreConfig: input.coreConfig, axiosConfig: input.axiosConfig }).updateProfanityRule(
      input.data
    );
    callback && callback(response.data);
    return response.data;
  };
  return (0, import_react_query8.useMutation)({
    mutationKey: ["Lobby.ProfanityAdmin.ProfanityRule" /* ProfanityRule */],
    mutationFn,
    ...options
  });
};
var useProfanityAdminApi_GetProfanityLists = (sdk, input, options, callback) => {
  const queryFn = (sdk2, input2) => async () => {
    const response = await ProfanityAdminApi(sdk2, { coreConfig: input2.coreConfig, axiosConfig: input2.axiosConfig }).getProfanityLists();
    callback && callback(response);
    return response.data;
  };
  return (0, import_react_query8.useQuery)({
    queryKey: ["Lobby.ProfanityAdmin.ProfanityLists" /* ProfanityLists */, input],
    queryFn: queryFn(sdk, input),
    ...options
  });
};
var useProfanityAdminApi_CreateProfanityListMutation = (sdk, options, callback) => {
  const mutationFn = async (input) => {
    const response = await ProfanityAdminApi(sdk, { coreConfig: input.coreConfig, axiosConfig: input.axiosConfig }).createProfanityList(
      input.data
    );
    callback && callback(response.data);
    return response.data;
  };
  return (0, import_react_query8.useMutation)({
    mutationKey: ["Lobby.ProfanityAdmin.ProfanityList" /* ProfanityList */],
    mutationFn,
    ...options
  });
};
var useProfanityAdminApi_FetchProfanityVerify = (sdk, input, options, callback) => {
  const queryFn = (sdk2, input2) => async () => {
    const response = await ProfanityAdminApi(sdk2, { coreConfig: input2.coreConfig, axiosConfig: input2.axiosConfig }).fetchProfanityVerify(
      input2.data
    );
    callback && callback(response);
    return response.data;
  };
  return (0, import_react_query8.useQuery)({
    queryKey: ["Lobby.ProfanityAdmin.ProfanityVerify" /* ProfanityVerify */, input],
    queryFn: queryFn(sdk, input),
    ...options
  });
};
var useProfanityAdminApi_DeleteProfanityList_ByListMutation = (sdk, options, callback) => {
  const mutationFn = async (input) => {
    const response = await ProfanityAdminApi(sdk, {
      coreConfig: input.coreConfig,
      axiosConfig: input.axiosConfig
    }).deleteProfanityList_ByList(input.list);
    callback && callback(response.data);
    return response.data;
  };
  return (0, import_react_query8.useMutation)({
    mutationKey: ["Lobby.ProfanityAdmin.ProfanityList_ByList" /* ProfanityList_ByList */],
    mutationFn,
    ...options
  });
};
var useProfanityAdminApi_UpdateProfanityList_ByListMutation = (sdk, options, callback) => {
  const mutationFn = async (input) => {
    const response = await ProfanityAdminApi(sdk, {
      coreConfig: input.coreConfig,
      axiosConfig: input.axiosConfig
    }).updateProfanityList_ByList(input.list, input.data);
    callback && callback(response.data);
    return response.data;
  };
  return (0, import_react_query8.useMutation)({
    mutationKey: ["Lobby.ProfanityAdmin.ProfanityList_ByList" /* ProfanityList_ByList */],
    mutationFn,
    ...options
  });
};
var useProfanityAdminApi_FetchProfanityFilterDebug = (sdk, input, options, callback) => {
  const queryFn = (sdk2, input2) => async () => {
    const response = await ProfanityAdminApi(sdk2, {
      coreConfig: input2.coreConfig,
      axiosConfig: input2.axiosConfig
    }).fetchProfanityFilterDebug(input2.data);
    callback && callback(response);
    return response.data;
  };
  return (0, import_react_query8.useQuery)({
    queryKey: ["Lobby.ProfanityAdmin.ProfanityFilterDebug" /* ProfanityFilterDebug */, input],
    queryFn: queryFn(sdk, input),
    ...options
  });
};
var useProfanityAdminApi_GetFiltersProfanity_ByList = (sdk, input, options, callback) => {
  const queryFn = (sdk2, input2) => async () => {
    const response = await ProfanityAdminApi(sdk2, {
      coreConfig: input2.coreConfig,
      axiosConfig: input2.axiosConfig
    }).getFiltersProfanity_ByList(input2.list);
    callback && callback(response);
    return response.data;
  };
  return (0, import_react_query8.useQuery)({
    queryKey: ["Lobby.ProfanityAdmin.FiltersProfanity_ByList" /* FiltersProfanity_ByList */, input],
    queryFn: queryFn(sdk, input),
    ...options
  });
};
var useProfanityAdminApi_CreateFilterProfanity_ByListMutation = (sdk, options, callback) => {
  const mutationFn = async (input) => {
    const response = await ProfanityAdminApi(sdk, {
      coreConfig: input.coreConfig,
      axiosConfig: input.axiosConfig
    }).createFilterProfanity_ByList(input.list, input.data);
    callback && callback(response.data);
    return response.data;
  };
  return (0, import_react_query8.useMutation)({
    mutationKey: ["Lobby.ProfanityAdmin.FilterProfanity_ByList" /* FilterProfanity_ByList */],
    mutationFn,
    ...options
  });
};
var useProfanityAdminApi_CreateFilterBulkProfanity_ByListMutation = (sdk, options, callback) => {
  const mutationFn = async (input) => {
    const response = await ProfanityAdminApi(sdk, {
      coreConfig: input.coreConfig,
      axiosConfig: input.axiosConfig
    }).createFilterBulkProfanity_ByList(input.list, input.data);
    callback && callback(response.data);
    return response.data;
  };
  return (0, import_react_query8.useMutation)({
    mutationKey: ["Lobby.ProfanityAdmin.FilterBulkProfanity_ByList" /* FilterBulkProfanity_ByList */],
    mutationFn,
    ...options
  });
};
var useProfanityAdminApi_CreateFilterDeleteProfanity_ByListMutation = (sdk, options, callback) => {
  const mutationFn = async (input) => {
    const response = await ProfanityAdminApi(sdk, {
      coreConfig: input.coreConfig,
      axiosConfig: input.axiosConfig
    }).createFilterDeleteProfanity_ByList(input.list, input.data);
    callback && callback(response.data);
    return response.data;
  };
  return (0, import_react_query8.useMutation)({
    mutationKey: ["Lobby.ProfanityAdmin.FilterDeleteProfanity_ByList" /* FilterDeleteProfanity_ByList */],
    mutationFn,
    ...options
  });
};
var useProfanityAdminApi_CreateFilterBulkFileProfanity_ByListMutation = (sdk, options, callback) => {
  const mutationFn = async (input) => {
    const response = await ProfanityAdminApi(sdk, {
      coreConfig: input.coreConfig,
      axiosConfig: input.axiosConfig
    }).createFilterBulkFileProfanity_ByList(input.list, input.data);
    callback && callback(response.data);
    return response.data;
  };
  return (0, import_react_query8.useMutation)({
    mutationKey: ["Lobby.ProfanityAdmin.FilterBulkFileProfanity_ByList" /* FilterBulkFileProfanity_ByList */],
    mutationFn,
    ...options
  });
};

// src/generated-admin/queries/ThirdPartyAdmin.query.ts
var import_react_query9 = require("@tanstack/react-query");

// src/generated-admin/ThirdPartyAdminApi.ts
var import_sdk18 = require("@accelbyte/sdk");

// src/generated-admin/endpoints/ThirdPartyAdmin$.ts
var import_sdk17 = require("@accelbyte/sdk");
var import_zod48 = require("zod");

// src/generated-definitions/CreateConfigResponse.ts
var import_zod45 = require("zod");
var CreateConfigResponse = import_zod45.z.object({ apiKey: import_zod45.z.string(), namespace: import_zod45.z.string() });

// src/generated-definitions/GetConfigResponse.ts
var import_zod46 = require("zod");
var GetConfigResponse = import_zod46.z.object({ apiKey: import_zod46.z.string(), namespace: import_zod46.z.string() });

// src/generated-definitions/UpdateConfigResponse.ts
var import_zod47 = require("zod");
var UpdateConfigResponse = import_zod47.z.object({ apiKey: import_zod47.z.string(), namespace: import_zod47.z.string() });

// src/generated-admin/endpoints/ThirdPartyAdmin$.ts
var ThirdPartyAdmin$ = class {
  // @ts-ignore
  // prettier-ignore
  constructor(axiosInstance, namespace, useSchemaValidation = true) {
    this.axiosInstance = axiosInstance;
    this.namespace = namespace;
    this.useSchemaValidation = useSchemaValidation;
  }
  /**
   * Required permission : &lt;code&gt;ADMIN:NAMESPACE:{namespace}:THIRDPARTY:CONFIG [DELETE]&lt;/code&gt; with scope &lt;code&gt;social&lt;/code&gt; &lt;br&gt;delete third party config in a namespace.
   */
  deleteThirdpartyConfigSteam() {
    const params = {};
    const url = "/lobby/v1/admin/thirdparty/namespaces/{namespace}/config/steam".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.delete(url, { params });
    return import_sdk17.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, import_zod48.z.unknown(), "z.unknown()");
  }
  /**
   * Get third party config for specified namespace.
   */
  getThirdpartyConfigSteam() {
    const params = {};
    const url = "/lobby/v1/admin/thirdparty/namespaces/{namespace}/config/steam".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.get(url, { params });
    return import_sdk17.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, GetConfigResponse, "GetConfigResponse");
  }
  /**
   * Create third party config in a namespace.
   */
  createThirdpartyConfigSteam(data) {
    const params = {};
    const url = "/lobby/v1/admin/thirdparty/namespaces/{namespace}/config/steam".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.post(url, data, { params });
    return import_sdk17.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, CreateConfigResponse, "CreateConfigResponse");
  }
  /**
   * Update third party config in a namespace.
   */
  updateThirdpartyConfigSteam(data) {
    const params = {};
    const url = "/lobby/v1/admin/thirdparty/namespaces/{namespace}/config/steam".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.put(url, data, { params });
    return import_sdk17.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, UpdateConfigResponse, "UpdateConfigResponse");
  }
};

// src/generated-admin/ThirdPartyAdminApi.ts
function ThirdPartyAdminApi(sdk, args) {
  const sdkAssembly = sdk.assembly();
  const namespace = args?.coreConfig?.namespace ?? sdkAssembly.coreConfig.namespace;
  const useSchemaValidation = args?.coreConfig?.useSchemaValidation ?? sdkAssembly.coreConfig.useSchemaValidation;
  let axiosInstance = sdkAssembly.axiosInstance;
  const requestConfigOverrides = args?.axiosConfig?.request;
  const baseURLOverride = args?.coreConfig?.baseURL;
  const interceptorsOverride = args?.axiosConfig?.interceptors ?? [];
  if (requestConfigOverrides || baseURLOverride || interceptorsOverride.length > 0) {
    const requestConfig = import_sdk18.ApiUtils.mergeAxiosConfigs(sdkAssembly.axiosInstance.defaults, {
      ...baseURLOverride ? { baseURL: baseURLOverride } : {},
      ...requestConfigOverrides
    });
    axiosInstance = import_sdk18.Network.create(requestConfig);
    for (const interceptor of interceptorsOverride) {
      if (interceptor.type === "request") {
        axiosInstance.interceptors.request.use(interceptor.onRequest, interceptor.onError);
      }
      if (interceptor.type === "response") {
        axiosInstance.interceptors.response.use(interceptor.onSuccess, interceptor.onError);
      }
    }
  }
  async function deleteThirdpartyConfigSteam() {
    const $ = new ThirdPartyAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.deleteThirdpartyConfigSteam();
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getThirdpartyConfigSteam() {
    const $ = new ThirdPartyAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getThirdpartyConfigSteam();
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function createThirdpartyConfigSteam(data) {
    const $ = new ThirdPartyAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.createThirdpartyConfigSteam(data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function updateThirdpartyConfigSteam(data) {
    const $ = new ThirdPartyAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.updateThirdpartyConfigSteam(data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  return {
    /**
     * Required permission : &lt;code&gt;ADMIN:NAMESPACE:{namespace}:THIRDPARTY:CONFIG [DELETE]&lt;/code&gt; with scope &lt;code&gt;social&lt;/code&gt; &lt;br&gt;delete third party config in a namespace.
     */
    deleteThirdpartyConfigSteam,
    /**
     * Get third party config for specified namespace.
     */
    getThirdpartyConfigSteam,
    /**
     * Create third party config in a namespace.
     */
    createThirdpartyConfigSteam,
    /**
     * Update third party config in a namespace.
     */
    updateThirdpartyConfigSteam
  };
}

// src/generated-admin/queries/ThirdPartyAdmin.query.ts
var Key_ThirdPartyAdmin = /* @__PURE__ */ ((Key_ThirdPartyAdmin2) => {
  Key_ThirdPartyAdmin2["ThirdpartyConfigSteam"] = "Lobby.ThirdPartyAdmin.ThirdpartyConfigSteam";
  return Key_ThirdPartyAdmin2;
})(Key_ThirdPartyAdmin || {});
var useThirdPartyAdminApi_DeleteThirdpartyConfigSteamMutation = (sdk, options, callback) => {
  const mutationFn = async (input) => {
    const response = await ThirdPartyAdminApi(sdk, {
      coreConfig: input.coreConfig,
      axiosConfig: input.axiosConfig
    }).deleteThirdpartyConfigSteam();
    callback && callback(response.data);
    return response.data;
  };
  return (0, import_react_query9.useMutation)({
    mutationKey: ["Lobby.ThirdPartyAdmin.ThirdpartyConfigSteam" /* ThirdpartyConfigSteam */],
    mutationFn,
    ...options
  });
};
var useThirdPartyAdminApi_GetThirdpartyConfigSteam = (sdk, input, options, callback) => {
  const queryFn = (sdk2, input2) => async () => {
    const response = await ThirdPartyAdminApi(sdk2, {
      coreConfig: input2.coreConfig,
      axiosConfig: input2.axiosConfig
    }).getThirdpartyConfigSteam();
    callback && callback(response);
    return response.data;
  };
  return (0, import_react_query9.useQuery)({
    queryKey: ["Lobby.ThirdPartyAdmin.ThirdpartyConfigSteam" /* ThirdpartyConfigSteam */, input],
    queryFn: queryFn(sdk, input),
    ...options
  });
};
var useThirdPartyAdminApi_CreateThirdpartyConfigSteamMutation = (sdk, options, callback) => {
  const mutationFn = async (input) => {
    const response = await ThirdPartyAdminApi(sdk, {
      coreConfig: input.coreConfig,
      axiosConfig: input.axiosConfig
    }).createThirdpartyConfigSteam(input.data);
    callback && callback(response.data);
    return response.data;
  };
  return (0, import_react_query9.useMutation)({
    mutationKey: ["Lobby.ThirdPartyAdmin.ThirdpartyConfigSteam" /* ThirdpartyConfigSteam */],
    mutationFn,
    ...options
  });
};
var useThirdPartyAdminApi_UpdateThirdpartyConfigSteamMutation = (sdk, options, callback) => {
  const mutationFn = async (input) => {
    const response = await ThirdPartyAdminApi(sdk, {
      coreConfig: input.coreConfig,
      axiosConfig: input.axiosConfig
    }).updateThirdpartyConfigSteam(input.data);
    callback && callback(response.data);
    return response.data;
  };
  return (0, import_react_query9.useMutation)({
    mutationKey: ["Lobby.ThirdPartyAdmin.ThirdpartyConfigSteam" /* ThirdpartyConfigSteam */],
    mutationFn,
    ...options
  });
};

// src/generated-public/queries/Admin.query.ts
var import_react_query10 = require("@tanstack/react-query");

// src/generated-public/AdminApi.ts
var import_sdk20 = require("@accelbyte/sdk");

// src/generated-public/endpoints/Admin$.ts
var import_sdk19 = require("@accelbyte/sdk");
var import_zod53 = require("zod");

// src/generated-definitions/TemplateLocalization.ts
var import_zod49 = require("zod");
var TemplateLocalization = import_zod49.z.object({
  lastDraftAt: import_zod49.z.string(),
  lastPublishedAt: import_zod49.z.string(),
  templateContent: TemplateContent,
  templateLanguage: import_zod49.z.string(),
  templateSlug: import_zod49.z.string()
});

// src/generated-definitions/TemplateLocalizationResponse.ts
var import_zod50 = require("zod");
var TemplateLocalizationResponse = import_zod50.z.object({
  first: import_zod50.z.string(),
  last: import_zod50.z.string(),
  next: import_zod50.z.string(),
  previous: import_zod50.z.string(),
  templateLocalization: import_zod50.z.array(TemplateLocalization)
});

// src/generated-definitions/TemplateResponseArray.ts
var import_zod52 = require("zod");

// src/generated-definitions/TemplateResponse.ts
var import_zod51 = require("zod");
var TemplateResponse = import_zod51.z.object({ localizations: import_zod51.z.array(Localization), templateSlug: import_zod51.z.string() });

// src/generated-definitions/TemplateResponseArray.ts
var TemplateResponseArray = import_zod52.z.array(TemplateResponse);

// src/generated-public/endpoints/Admin$.ts
var Admin$ = class {
  // @ts-ignore
  // prettier-ignore
  constructor(axiosInstance, namespace, useSchemaValidation = true) {
    this.axiosInstance = axiosInstance;
    this.namespace = namespace;
    this.useSchemaValidation = useSchemaValidation;
  }
  /**
   * Sends notification to all connected users in a namespace.
   */
  createNotificationFreeform(data) {
    const params = {};
    const url = "/notification/namespaces/{namespace}/freeform".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.post(url, data, { params });
    return import_sdk19.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, import_zod53.z.unknown(), "z.unknown()");
  }
  /**
   * Sends notification to all connected users in a namespace with predefined template. &lt;br&gt;In the request body, specify which template slug (template identifier) to use and the template language. &lt;br&gt;NotificationTemplate context is the key-value pair defining the value of each handlebar specified in the template content. Template need to be published before it can be use to send notifications
   */
  createNotificationTemplated(data) {
    const params = {};
    const url = "/notification/namespaces/{namespace}/templated".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.post(url, data, { params });
    return import_sdk19.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, import_zod53.z.unknown(), "z.unknown()");
  }
  /**
   * Get all templates in a namespace
   */
  getNotificationTemplates() {
    const params = {};
    const url = "/notification/namespaces/{namespace}/templates".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.get(url, { params });
    return import_sdk19.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, TemplateResponseArray, "TemplateResponseArray");
  }
  /**
   * Create new notification template. Include handlebars {{key}} for replaceable contexts. The the key inside handlebars will be the key to be replaced when sending notification. Already existing template with the same slug and language can not be created. &lt;br&gt;Check model description for detailed input restrictions.
   */
  createNotificationTemplate(data) {
    const params = {};
    const url = "/notification/namespaces/{namespace}/templates".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.post(url, data, { params });
    return import_sdk19.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, import_zod53.z.unknown(), "z.unknown()");
  }
  /**
   * Delete localization template
   */
  deleteNotificationTemplate_ByTemplateSlug(templateSlug) {
    const params = {};
    const url = "/notification/namespaces/{namespace}/templates/{templateSlug}".replace("{namespace}", this.namespace).replace("{templateSlug}", templateSlug);
    const resultPromise = this.axiosInstance.delete(url, { params });
    return import_sdk19.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, import_zod53.z.unknown(), "z.unknown()");
  }
  /**
   * Get all templates in a namespace
   */
  getNotificationTemplate_ByTemplateSlug(templateSlug, queryParams) {
    const params = { ...queryParams };
    const url = "/notification/namespaces/{namespace}/templates/{templateSlug}".replace("{namespace}", this.namespace).replace("{templateSlug}", templateSlug);
    const resultPromise = this.axiosInstance.get(url, { params });
    return import_sdk19.Validate.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      TemplateLocalizationResponse,
      "TemplateLocalizationResponse"
    );
  }
  /**
   * Delete all template in a slug
   */
  deleteLanguageNotification_ByTemplateSlug_ByTemplateLanguage(templateSlug, templateLanguage) {
    const params = {};
    const url = "/notification/namespaces/{namespace}/templates/{templateSlug}/languages/{templateLanguage}".replace("{namespace}", this.namespace).replace("{templateSlug}", templateSlug).replace("{templateLanguage}", templateLanguage);
    const resultPromise = this.axiosInstance.delete(url, { params });
    return import_sdk19.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, import_zod53.z.unknown(), "z.unknown()");
  }
  /**
   * Get a template localization
   */
  getLanguageNotification_ByTemplateSlug_ByTemplateLanguage(templateSlug, templateLanguage) {
    const params = {};
    const url = "/notification/namespaces/{namespace}/templates/{templateSlug}/languages/{templateLanguage}".replace("{namespace}", this.namespace).replace("{templateSlug}", templateSlug).replace("{templateLanguage}", templateLanguage);
    const resultPromise = this.axiosInstance.get(url, { params });
    return import_sdk19.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, TemplateLocalization, "TemplateLocalization");
  }
  /**
   * Modify draft template
   */
  updateLanguageNotification_ByTemplateSlug_ByTemplateLanguage(templateSlug, templateLanguage, data) {
    const params = {};
    const url = "/notification/namespaces/{namespace}/templates/{templateSlug}/languages/{templateLanguage}".replace("{namespace}", this.namespace).replace("{templateSlug}", templateSlug).replace("{templateLanguage}", templateLanguage);
    const resultPromise = this.axiosInstance.put(url, data, { params });
    return import_sdk19.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, import_zod53.z.unknown(), "z.unknown()");
  }
  /**
   * Publish notification template draft. Empty draft can not be published.
   */
  createPublishNotification_ByTemplateSlug_ByTemplateLanguage(templateSlug, templateLanguage) {
    const params = {};
    const url = "/notification/namespaces/{namespace}/templates/{templateSlug}/languages/{templateLanguage}/publish".replace("{namespace}", this.namespace).replace("{templateSlug}", templateSlug).replace("{templateLanguage}", templateLanguage);
    const resultPromise = this.axiosInstance.post(url, null, { params });
    return import_sdk19.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, import_zod53.z.unknown(), "z.unknown()");
  }
};

// src/generated-public/AdminApi.ts
function AdminApi(sdk, args) {
  const sdkAssembly = sdk.assembly();
  const namespace = args?.coreConfig?.namespace ?? sdkAssembly.coreConfig.namespace;
  const useSchemaValidation = args?.coreConfig?.useSchemaValidation ?? sdkAssembly.coreConfig.useSchemaValidation;
  let axiosInstance = sdkAssembly.axiosInstance;
  const requestConfigOverrides = args?.axiosConfig?.request;
  const baseURLOverride = args?.coreConfig?.baseURL;
  const interceptorsOverride = args?.axiosConfig?.interceptors ?? [];
  if (requestConfigOverrides || baseURLOverride || interceptorsOverride.length > 0) {
    const requestConfig = import_sdk20.ApiUtils.mergeAxiosConfigs(sdkAssembly.axiosInstance.defaults, {
      ...baseURLOverride ? { baseURL: baseURLOverride } : {},
      ...requestConfigOverrides
    });
    axiosInstance = import_sdk20.Network.create(requestConfig);
    for (const interceptor of interceptorsOverride) {
      if (interceptor.type === "request") {
        axiosInstance.interceptors.request.use(interceptor.onRequest, interceptor.onError);
      }
      if (interceptor.type === "response") {
        axiosInstance.interceptors.response.use(interceptor.onSuccess, interceptor.onError);
      }
    }
  }
  async function createNotificationFreeform(data) {
    const $ = new Admin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.createNotificationFreeform(data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function createNotificationTemplated(data) {
    const $ = new Admin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.createNotificationTemplated(data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getNotificationTemplates() {
    const $ = new Admin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getNotificationTemplates();
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function createNotificationTemplate(data) {
    const $ = new Admin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.createNotificationTemplate(data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function deleteNotificationTemplate_ByTemplateSlug(templateSlug) {
    const $ = new Admin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.deleteNotificationTemplate_ByTemplateSlug(templateSlug);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getNotificationTemplate_ByTemplateSlug(templateSlug, queryParams) {
    const $ = new Admin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getNotificationTemplate_ByTemplateSlug(templateSlug, queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function deleteLanguageNotification_ByTemplateSlug_ByTemplateLanguage(templateSlug, templateLanguage) {
    const $ = new Admin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.deleteLanguageNotification_ByTemplateSlug_ByTemplateLanguage(templateSlug, templateLanguage);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getLanguageNotification_ByTemplateSlug_ByTemplateLanguage(templateSlug, templateLanguage) {
    const $ = new Admin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getLanguageNotification_ByTemplateSlug_ByTemplateLanguage(templateSlug, templateLanguage);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function updateLanguageNotification_ByTemplateSlug_ByTemplateLanguage(templateSlug, templateLanguage, data) {
    const $ = new Admin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.updateLanguageNotification_ByTemplateSlug_ByTemplateLanguage(templateSlug, templateLanguage, data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function createPublishNotification_ByTemplateSlug_ByTemplateLanguage(templateSlug, templateLanguage) {
    const $ = new Admin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.createPublishNotification_ByTemplateSlug_ByTemplateLanguage(templateSlug, templateLanguage);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  return {
    /**
     * Sends notification to all connected users in a namespace.
     */
    createNotificationFreeform,
    /**
     * Sends notification to all connected users in a namespace with predefined template. &lt;br&gt;In the request body, specify which template slug (template identifier) to use and the template language. &lt;br&gt;NotificationTemplate context is the key-value pair defining the value of each handlebar specified in the template content. Template need to be published before it can be use to send notifications
     */
    createNotificationTemplated,
    /**
     * Get all templates in a namespace
     */
    getNotificationTemplates,
    /**
     * Create new notification template. Include handlebars {{key}} for replaceable contexts. The the key inside handlebars will be the key to be replaced when sending notification. Already existing template with the same slug and language can not be created. &lt;br&gt;Check model description for detailed input restrictions.
     */
    createNotificationTemplate,
    /**
     * Delete localization template
     */
    deleteNotificationTemplate_ByTemplateSlug,
    /**
     * Get all templates in a namespace
     */
    getNotificationTemplate_ByTemplateSlug,
    /**
     * Delete all template in a slug
     */
    deleteLanguageNotification_ByTemplateSlug_ByTemplateLanguage,
    /**
     * Get a template localization
     */
    getLanguageNotification_ByTemplateSlug_ByTemplateLanguage,
    /**
     * Modify draft template
     */
    updateLanguageNotification_ByTemplateSlug_ByTemplateLanguage,
    /**
     * Publish notification template draft. Empty draft can not be published.
     */
    createPublishNotification_ByTemplateSlug_ByTemplateLanguage
  };
}

// src/generated-public/queries/Admin.query.ts
var Key_Admin = /* @__PURE__ */ ((Key_Admin2) => {
  Key_Admin2["NotificationFreeform"] = "Lobby.Admin.NotificationFreeform";
  Key_Admin2["NotificationTemplated"] = "Lobby.Admin.NotificationTemplated";
  Key_Admin2["NotificationTemplates"] = "Lobby.Admin.NotificationTemplates";
  Key_Admin2["NotificationTemplate"] = "Lobby.Admin.NotificationTemplate";
  Key_Admin2["NotificationTemplate_ByTemplateSlug"] = "Lobby.Admin.NotificationTemplate_ByTemplateSlug";
  Key_Admin2["LanguageNotification_ByTemplateSlug_ByTemplateLanguage"] = "Lobby.Admin.LanguageNotification_ByTemplateSlug_ByTemplateLanguage";
  Key_Admin2["PublishNotification_ByTemplateSlug_ByTemplateLanguage"] = "Lobby.Admin.PublishNotification_ByTemplateSlug_ByTemplateLanguage";
  return Key_Admin2;
})(Key_Admin || {});
var useAdminApi_CreateNotificationFreeformMutation = (sdk, options, callback) => {
  const mutationFn = async (input) => {
    const response = await AdminApi(sdk, { coreConfig: input.coreConfig, axiosConfig: input.axiosConfig }).createNotificationFreeform(
      input.data
    );
    callback && callback(response.data);
    return response.data;
  };
  return (0, import_react_query10.useMutation)({
    mutationKey: ["Lobby.Admin.NotificationFreeform" /* NotificationFreeform */],
    mutationFn,
    ...options
  });
};
var useAdminApi_CreateNotificationTemplatedMutation = (sdk, options, callback) => {
  const mutationFn = async (input) => {
    const response = await AdminApi(sdk, { coreConfig: input.coreConfig, axiosConfig: input.axiosConfig }).createNotificationTemplated(
      input.data
    );
    callback && callback(response.data);
    return response.data;
  };
  return (0, import_react_query10.useMutation)({
    mutationKey: ["Lobby.Admin.NotificationTemplated" /* NotificationTemplated */],
    mutationFn,
    ...options
  });
};
var useAdminApi_GetNotificationTemplates = (sdk, input, options, callback) => {
  const queryFn = (sdk2, input2) => async () => {
    const response = await AdminApi(sdk2, { coreConfig: input2.coreConfig, axiosConfig: input2.axiosConfig }).getNotificationTemplates();
    callback && callback(response);
    return response.data;
  };
  return (0, import_react_query10.useQuery)({
    queryKey: ["Lobby.Admin.NotificationTemplates" /* NotificationTemplates */, input],
    queryFn: queryFn(sdk, input),
    ...options
  });
};
var useAdminApi_CreateNotificationTemplateMutation = (sdk, options, callback) => {
  const mutationFn = async (input) => {
    const response = await AdminApi(sdk, { coreConfig: input.coreConfig, axiosConfig: input.axiosConfig }).createNotificationTemplate(
      input.data
    );
    callback && callback(response.data);
    return response.data;
  };
  return (0, import_react_query10.useMutation)({
    mutationKey: ["Lobby.Admin.NotificationTemplate" /* NotificationTemplate */],
    mutationFn,
    ...options
  });
};
var useAdminApi_DeleteNotificationTemplate_ByTemplateSlugMutation = (sdk, options, callback) => {
  const mutationFn = async (input) => {
    const response = await AdminApi(sdk, {
      coreConfig: input.coreConfig,
      axiosConfig: input.axiosConfig
    }).deleteNotificationTemplate_ByTemplateSlug(input.templateSlug);
    callback && callback(response.data);
    return response.data;
  };
  return (0, import_react_query10.useMutation)({
    mutationKey: ["Lobby.Admin.NotificationTemplate_ByTemplateSlug" /* NotificationTemplate_ByTemplateSlug */],
    mutationFn,
    ...options
  });
};
var useAdminApi_GetNotificationTemplate_ByTemplateSlug = (sdk, input, options, callback) => {
  const queryFn = (sdk2, input2) => async () => {
    const response = await AdminApi(sdk2, {
      coreConfig: input2.coreConfig,
      axiosConfig: input2.axiosConfig
    }).getNotificationTemplate_ByTemplateSlug(input2.templateSlug, input2.queryParams);
    callback && callback(response);
    return response.data;
  };
  return (0, import_react_query10.useQuery)({
    queryKey: ["Lobby.Admin.NotificationTemplate_ByTemplateSlug" /* NotificationTemplate_ByTemplateSlug */, input],
    queryFn: queryFn(sdk, input),
    ...options
  });
};
var useAdminApi_DeleteLanguageNotification_ByTemplateSlug_ByTemplateLanguageMutation = (sdk, options, callback) => {
  const mutationFn = async (input) => {
    const response = await AdminApi(sdk, {
      coreConfig: input.coreConfig,
      axiosConfig: input.axiosConfig
    }).deleteLanguageNotification_ByTemplateSlug_ByTemplateLanguage(input.templateSlug, input.templateLanguage);
    callback && callback(response.data);
    return response.data;
  };
  return (0, import_react_query10.useMutation)({
    mutationKey: ["Lobby.Admin.LanguageNotification_ByTemplateSlug_ByTemplateLanguage" /* LanguageNotification_ByTemplateSlug_ByTemplateLanguage */],
    mutationFn,
    ...options
  });
};
var useAdminApi_GetLanguageNotification_ByTemplateSlug_ByTemplateLanguage = (sdk, input, options, callback) => {
  const queryFn = (sdk2, input2) => async () => {
    const response = await AdminApi(sdk2, {
      coreConfig: input2.coreConfig,
      axiosConfig: input2.axiosConfig
    }).getLanguageNotification_ByTemplateSlug_ByTemplateLanguage(input2.templateSlug, input2.templateLanguage);
    callback && callback(response);
    return response.data;
  };
  return (0, import_react_query10.useQuery)({
    queryKey: ["Lobby.Admin.LanguageNotification_ByTemplateSlug_ByTemplateLanguage" /* LanguageNotification_ByTemplateSlug_ByTemplateLanguage */, input],
    queryFn: queryFn(sdk, input),
    ...options
  });
};
var useAdminApi_UpdateLanguageNotification_ByTemplateSlug_ByTemplateLanguageMutation = (sdk, options, callback) => {
  const mutationFn = async (input) => {
    const response = await AdminApi(sdk, {
      coreConfig: input.coreConfig,
      axiosConfig: input.axiosConfig
    }).updateLanguageNotification_ByTemplateSlug_ByTemplateLanguage(input.templateSlug, input.templateLanguage, input.data);
    callback && callback(response.data);
    return response.data;
  };
  return (0, import_react_query10.useMutation)({
    mutationKey: ["Lobby.Admin.LanguageNotification_ByTemplateSlug_ByTemplateLanguage" /* LanguageNotification_ByTemplateSlug_ByTemplateLanguage */],
    mutationFn,
    ...options
  });
};
var useAdminApi_CreatePublishNotification_ByTemplateSlug_ByTemplateLanguageMutation = (sdk, options, callback) => {
  const mutationFn = async (input) => {
    const response = await AdminApi(sdk, {
      coreConfig: input.coreConfig,
      axiosConfig: input.axiosConfig
    }).createPublishNotification_ByTemplateSlug_ByTemplateLanguage(input.templateSlug, input.templateLanguage);
    callback && callback(response.data);
    return response.data;
  };
  return (0, import_react_query10.useMutation)({
    mutationKey: ["Lobby.Admin.PublishNotification_ByTemplateSlug_ByTemplateLanguage" /* PublishNotification_ByTemplateSlug_ByTemplateLanguage */],
    mutationFn,
    ...options
  });
};

// src/generated-public/queries/Blocks.query.ts
var import_react_query11 = require("@tanstack/react-query");

// src/generated-public/BlocksApi.ts
var import_sdk22 = require("@accelbyte/sdk");

// src/generated-public/endpoints/Blocks$.ts
var import_sdk21 = require("@accelbyte/sdk");

// src/generated-definitions/NativeUserBlockResponseArray.ts
var import_zod55 = require("zod");

// src/generated-definitions/NativeUserBlockResponse.ts
var import_zod54 = require("zod");
var NativeUserBlockResponse = import_zod54.z.object({ detail: import_zod54.z.string().nullish(), platformId: import_zod54.z.string(), status: import_zod54.z.string() });

// src/generated-definitions/NativeUserBlockResponseArray.ts
var NativeUserBlockResponseArray = import_zod55.z.array(NativeUserBlockResponse);

// src/generated-public/endpoints/Blocks$.ts
var Blocks$ = class {
  // @ts-ignore
  // prettier-ignore
  constructor(axiosInstance, namespace, useSchemaValidation = true) {
    this.axiosInstance = axiosInstance;
    this.namespace = namespace;
    this.useSchemaValidation = useSchemaValidation;
  }
  /**
   * Sync blocked user using server to server call to native first party server. Supported platforms: ps5, ps4 and pspc : the default environment would be sp-int, can be override using psnEnv. psnEnv consist of sp-int (default), prod-qa, np
   */
  patchSyncMeBlock(data) {
    const params = {};
    const url = "/lobby/sync/namespaces/{namespace}/me/block".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.patch(url, data, { params });
    return import_sdk21.Validate.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      NativeUserBlockResponseArray,
      "NativeUserBlockResponseArray"
    );
  }
};

// src/generated-public/BlocksApi.ts
function BlocksApi(sdk, args) {
  const sdkAssembly = sdk.assembly();
  const namespace = args?.coreConfig?.namespace ?? sdkAssembly.coreConfig.namespace;
  const useSchemaValidation = args?.coreConfig?.useSchemaValidation ?? sdkAssembly.coreConfig.useSchemaValidation;
  let axiosInstance = sdkAssembly.axiosInstance;
  const requestConfigOverrides = args?.axiosConfig?.request;
  const baseURLOverride = args?.coreConfig?.baseURL;
  const interceptorsOverride = args?.axiosConfig?.interceptors ?? [];
  if (requestConfigOverrides || baseURLOverride || interceptorsOverride.length > 0) {
    const requestConfig = import_sdk22.ApiUtils.mergeAxiosConfigs(sdkAssembly.axiosInstance.defaults, {
      ...baseURLOverride ? { baseURL: baseURLOverride } : {},
      ...requestConfigOverrides
    });
    axiosInstance = import_sdk22.Network.create(requestConfig);
    for (const interceptor of interceptorsOverride) {
      if (interceptor.type === "request") {
        axiosInstance.interceptors.request.use(interceptor.onRequest, interceptor.onError);
      }
      if (interceptor.type === "response") {
        axiosInstance.interceptors.response.use(interceptor.onSuccess, interceptor.onError);
      }
    }
  }
  async function patchSyncMeBlock(data) {
    const $ = new Blocks$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.patchSyncMeBlock(data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  return {
    /**
     * Sync blocked user using server to server call to native first party server. Supported platforms: ps5, ps4 and pspc : the default environment would be sp-int, can be override using psnEnv. psnEnv consist of sp-int (default), prod-qa, np
     */
    patchSyncMeBlock
  };
}

// src/generated-public/queries/Blocks.query.ts
var Key_Blocks = /* @__PURE__ */ ((Key_Blocks2) => {
  Key_Blocks2["SyncMeBlock"] = "Lobby.Blocks.SyncMeBlock";
  return Key_Blocks2;
})(Key_Blocks || {});
var useBlocksApi_PatchSyncMeBlockMutation = (sdk, options, callback) => {
  const mutationFn = async (input) => {
    const response = await BlocksApi(sdk, { coreConfig: input.coreConfig, axiosConfig: input.axiosConfig }).patchSyncMeBlock(input.data);
    callback && callback(response.data);
    return response.data;
  };
  return (0, import_react_query11.useMutation)({
    mutationKey: ["Lobby.Blocks.SyncMeBlock" /* SyncMeBlock */],
    mutationFn,
    ...options
  });
};

// src/generated-public/queries/Friends.query.ts
var import_react_query12 = require("@tanstack/react-query");

// src/generated-public/FriendsApi.ts
var import_sdk24 = require("@accelbyte/sdk");

// src/generated-public/endpoints/Friends$.ts
var import_sdk23 = require("@accelbyte/sdk");
var import_zod71 = require("zod");

// src/generated-definitions/BulkFriendsResponse.ts
var import_zod56 = require("zod");
var BulkFriendsResponse = import_zod56.z.object({ rowsAffected: import_zod56.z.number().int() });

// src/generated-definitions/GetUserFriendsResponseArray.ts
var import_zod58 = require("zod");

// src/generated-definitions/GetUserFriendsResponse.ts
var import_zod57 = require("zod");
var GetUserFriendsResponse = import_zod57.z.object({
  friendIDs: import_zod57.z.array(import_zod57.z.string()),
  friends: import_zod57.z.array(FriendWithPlatform).nullish(),
  paging: Pagination
});

// src/generated-definitions/GetUserFriendsResponseArray.ts
var GetUserFriendsResponseArray = import_zod58.z.array(GetUserFriendsResponse);

// src/generated-definitions/GetUserIncomingFriendsResponseArray.ts
var import_zod60 = require("zod");

// src/generated-definitions/GetUserIncomingFriendsResponse.ts
var import_zod59 = require("zod");
var GetUserIncomingFriendsResponse = import_zod59.z.object({ friendIDs: import_zod59.z.array(import_zod59.z.string()), paging: Pagination });

// src/generated-definitions/GetUserIncomingFriendsResponseArray.ts
var GetUserIncomingFriendsResponseArray = import_zod60.z.array(GetUserIncomingFriendsResponse);

// src/generated-definitions/GetUserOutgoingFriendsResponseArray.ts
var import_zod62 = require("zod");

// src/generated-definitions/GetUserOutgoingFriendsResponse.ts
var import_zod61 = require("zod");
var GetUserOutgoingFriendsResponse = import_zod61.z.object({ friendIDs: import_zod61.z.array(import_zod61.z.string()), paging: Pagination });

// src/generated-definitions/GetUserOutgoingFriendsResponseArray.ts
var GetUserOutgoingFriendsResponseArray = import_zod62.z.array(GetUserOutgoingFriendsResponse);

// src/generated-definitions/ListBulkUserPlatformsResponse.ts
var import_zod65 = require("zod");

// src/generated-definitions/UserWithPlatformInfo.ts
var import_zod64 = require("zod");

// src/generated-definitions/UserPlatformInfo.ts
var import_zod63 = require("zod");
var UserPlatformInfo = import_zod63.z.object({ platformDisplayName: import_zod63.z.string(), platformName: import_zod63.z.string(), platformUserId: import_zod63.z.string() });

// src/generated-definitions/UserWithPlatformInfo.ts
var UserWithPlatformInfo = import_zod64.z.object({
  avatarUrl: import_zod64.z.string(),
  displayName: import_zod64.z.string(),
  platformInfos: import_zod64.z.array(UserPlatformInfo),
  userId: import_zod64.z.string(),
  username: import_zod64.z.string().nullish()
});

// src/generated-definitions/ListBulkUserPlatformsResponse.ts
var ListBulkUserPlatformsResponse = import_zod65.z.object({ data: import_zod65.z.array(UserWithPlatformInfo) });

// src/generated-definitions/LoadIncomingFriendsWithTimeResponseArray.ts
var import_zod66 = require("zod");
var LoadIncomingFriendsWithTimeResponseArray = import_zod66.z.array(LoadIncomingFriendsWithTimeResponse);

// src/generated-definitions/LoadOutgoingFriendsWithTimeResponseArray.ts
var import_zod67 = require("zod");
var LoadOutgoingFriendsWithTimeResponseArray = import_zod67.z.array(LoadOutgoingFriendsWithTimeResponse);

// src/generated-definitions/NativeFriendSyncResponseArray.ts
var import_zod69 = require("zod");

// src/generated-definitions/NativeFriendSyncResponse.ts
var import_zod68 = require("zod");
var NativeFriendSyncResponse = import_zod68.z.object({ detail: import_zod68.z.string().nullish(), platformId: import_zod68.z.string(), status: import_zod68.z.string() });

// src/generated-definitions/NativeFriendSyncResponseArray.ts
var NativeFriendSyncResponseArray = import_zod69.z.array(NativeFriendSyncResponse);

// src/generated-definitions/UserGetFriendshipStatusResponse.ts
var import_zod70 = require("zod");
var UserGetFriendshipStatusResponse = import_zod70.z.object({ code: import_zod70.z.number().int(), name: import_zod70.z.string() });

// src/generated-public/endpoints/Friends$.ts
var Friends$ = class {
  // @ts-ignore
  // prettier-ignore
  constructor(axiosInstance, namespace, useSchemaValidation = true) {
    this.axiosInstance = axiosInstance;
    this.namespace = namespace;
    this.useSchemaValidation = useSchemaValidation;
  }
  /**
   * Get list of friends in a namespace.
   */
  getFriendsMe(queryParams) {
    const params = { limit: 25, ...queryParams };
    const url = "/friends/namespaces/{namespace}/me".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.get(url, { params });
    return import_sdk23.Validate.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      GetUserFriendsResponseArray,
      "GetUserFriendsResponseArray"
    );
  }
  /**
   * Sync friends using server to server call to native first party server. Supported platforms: steam: The platform_tokens value is the binary ticket returned by Steam. If this ticket was generated by Steam GetAuthTicketForWebApi with version &gt;= 1.57, then platform token should use this style: {identity}:{ticket} the {identity} was the parameter to call GetAuthTicketForWebApi when the ticket was created. Note: Do not contain : in this {identity} ps4: The platform_tokens value is the authorization code returned by Sony OAuth. ps5: The platform_tokens value is the authorization code returned by Sony OAuth. pspc: The platform_tokens value is the authorization code returned by Sony OAuth.
   */
  patchFriendSyncMe(data) {
    const params = {};
    const url = "/friends/sync/namespaces/{namespace}/me".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.patch(url, data, { params });
    return import_sdk23.Validate.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      NativeFriendSyncResponseArray,
      "NativeFriendSyncResponseArray"
    );
  }
  /**
   * Client should provide either friendID or friendPublicID. If both are provided, friendID will be chosen to be used. This endpoint will only send a pending invite that can be either rejected/accepted
   */
  createFriendMeRequest(data) {
    const params = {};
    const url = "/friends/namespaces/{namespace}/me/request".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.post(url, data, { params });
    return import_sdk23.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, import_zod71.z.unknown(), "z.unknown()");
  }
  /**
   * Get list of incoming friends in a namespace.
   */
  getFriendsMeIncoming(queryParams) {
    const params = { limit: 25, ...queryParams };
    const url = "/friends/namespaces/{namespace}/me/incoming".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.get(url, { params });
    return import_sdk23.Validate.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      GetUserIncomingFriendsResponseArray,
      "GetUserIncomingFriendsResponseArray"
    );
  }
  /**
   * Get list of outgoing friends in a namespace.
   */
  getFriendsMeOutgoing(queryParams) {
    const params = { limit: 25, ...queryParams };
    const url = "/friends/namespaces/{namespace}/me/outgoing".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.get(url, { params });
    return import_sdk23.Validate.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      GetUserOutgoingFriendsResponseArray,
      "GetUserOutgoingFriendsResponseArray"
    );
  }
  /**
   * User unfriend a friend.
   */
  createFriendMeUnfriend(data) {
    const params = {};
    const url = "/friends/namespaces/{namespace}/me/unfriend".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.post(url, data, { params });
    return import_sdk23.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, import_zod71.z.unknown(), "z.unknown()");
  }
  /**
   * Get list of friends with platform data in a namespace.
   */
  getFriendsMePlatforms(queryParams) {
    const params = { limit: 25, ...queryParams };
    const url = "/friends/namespaces/{namespace}/me/platforms".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.get(url, { params });
    return import_sdk23.Validate.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      ListBulkUserPlatformsResponse,
      "ListBulkUserPlatformsResponse"
    );
  }
  /**
   * Get list of incoming friends with requested time info in a namespace.
   */
  getFriendsMeIncomingTime(queryParams) {
    const params = { limit: 25, ...queryParams };
    const url = "/friends/namespaces/{namespace}/me/incoming-time".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.get(url, { params });
    return import_sdk23.Validate.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      LoadIncomingFriendsWithTimeResponseArray,
      "LoadIncomingFriendsWithTimeResponseArray"
    );
  }
  /**
   * Get list of outgoing friends with requested time info in a namespace.
   */
  getFriendsMeOutgoingTime(queryParams) {
    const params = { limit: 25, ...queryParams };
    const url = "/friends/namespaces/{namespace}/me/outgoing-time".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.get(url, { params });
    return import_sdk23.Validate.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      LoadOutgoingFriendsWithTimeResponseArray,
      "LoadOutgoingFriendsWithTimeResponseArray"
    );
  }
  /**
   * User accept friend.
   */
  createFriendMeRequestAccept(data) {
    const params = {};
    const url = "/friends/namespaces/{namespace}/me/request/accept".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.post(url, data, { params });
    return import_sdk23.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, import_zod71.z.unknown(), "z.unknown()");
  }
  /**
   * User cancel a friend request.
   */
  createFriendMeRequestCancel(data) {
    const params = {};
    const url = "/friends/namespaces/{namespace}/me/request/cancel".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.post(url, data, { params });
    return import_sdk23.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, import_zod71.z.unknown(), "z.unknown()");
  }
  /**
   * User reject a friend request.
   */
  createFriendMeRequestReject(data) {
    const params = {};
    const url = "/friends/namespaces/{namespace}/me/request/reject".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.post(url, data, { params });
    return import_sdk23.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, import_zod71.z.unknown(), "z.unknown()");
  }
  /**
   * User get friendship status. Code: 0 - Message: &#34;not friend&#34; Code: 1 - Message: &#34;outgoing&#34; Code: 2 - Message: &#34;incoming&#34; Code: 3 - Message: &#34;friend&#34;
   */
  getFriendMeStatu_ByFriendId(friendId) {
    const params = {};
    const url = "/friends/namespaces/{namespace}/me/status/{friendId}".replace("{namespace}", this.namespace).replace("{friendId}", friendId);
    const resultPromise = this.axiosInstance.get(url, { params });
    return import_sdk23.Validate.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      UserGetFriendshipStatusResponse,
      "UserGetFriendshipStatusResponse"
    );
  }
  /**
   * Friends request in a namespace.
   */
  createAddBulkFriend_ByUserId(userId, data) {
    const params = {};
    const url = "/friends/namespaces/{namespace}/users/{userId}/add/bulk".replace("{namespace}", this.namespace).replace("{userId}", userId);
    const resultPromise = this.axiosInstance.post(url, data, { params });
    return import_sdk23.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, import_zod71.z.unknown(), "z.unknown()");
  }
  /**
   * Friends request in a namespace.
   */
  createDeleteBulkFriend_ByUserId(userId, data) {
    const params = {};
    const url = "/friends/namespaces/{namespace}/users/{userId}/delete/bulk".replace("{namespace}", this.namespace).replace("{userId}", userId);
    const resultPromise = this.axiosInstance.post(url, data, { params });
    return import_sdk23.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, BulkFriendsResponse, "BulkFriendsResponse");
  }
};

// src/generated-public/FriendsApi.ts
function FriendsApi(sdk, args) {
  const sdkAssembly = sdk.assembly();
  const namespace = args?.coreConfig?.namespace ?? sdkAssembly.coreConfig.namespace;
  const useSchemaValidation = args?.coreConfig?.useSchemaValidation ?? sdkAssembly.coreConfig.useSchemaValidation;
  let axiosInstance = sdkAssembly.axiosInstance;
  const requestConfigOverrides = args?.axiosConfig?.request;
  const baseURLOverride = args?.coreConfig?.baseURL;
  const interceptorsOverride = args?.axiosConfig?.interceptors ?? [];
  if (requestConfigOverrides || baseURLOverride || interceptorsOverride.length > 0) {
    const requestConfig = import_sdk24.ApiUtils.mergeAxiosConfigs(sdkAssembly.axiosInstance.defaults, {
      ...baseURLOverride ? { baseURL: baseURLOverride } : {},
      ...requestConfigOverrides
    });
    axiosInstance = import_sdk24.Network.create(requestConfig);
    for (const interceptor of interceptorsOverride) {
      if (interceptor.type === "request") {
        axiosInstance.interceptors.request.use(interceptor.onRequest, interceptor.onError);
      }
      if (interceptor.type === "response") {
        axiosInstance.interceptors.response.use(interceptor.onSuccess, interceptor.onError);
      }
    }
  }
  async function getFriendsMe(queryParams) {
    const $ = new Friends$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getFriendsMe(queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function patchFriendSyncMe(data) {
    const $ = new Friends$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.patchFriendSyncMe(data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function createFriendMeRequest(data) {
    const $ = new Friends$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.createFriendMeRequest(data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getFriendsMeIncoming(queryParams) {
    const $ = new Friends$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getFriendsMeIncoming(queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getFriendsMeOutgoing(queryParams) {
    const $ = new Friends$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getFriendsMeOutgoing(queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function createFriendMeUnfriend(data) {
    const $ = new Friends$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.createFriendMeUnfriend(data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getFriendsMePlatforms(queryParams) {
    const $ = new Friends$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getFriendsMePlatforms(queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getFriendsMeIncomingTime(queryParams) {
    const $ = new Friends$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getFriendsMeIncomingTime(queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getFriendsMeOutgoingTime(queryParams) {
    const $ = new Friends$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getFriendsMeOutgoingTime(queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function createFriendMeRequestAccept(data) {
    const $ = new Friends$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.createFriendMeRequestAccept(data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function createFriendMeRequestCancel(data) {
    const $ = new Friends$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.createFriendMeRequestCancel(data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function createFriendMeRequestReject(data) {
    const $ = new Friends$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.createFriendMeRequestReject(data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getFriendMeStatu_ByFriendId(friendId) {
    const $ = new Friends$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getFriendMeStatu_ByFriendId(friendId);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function createAddBulkFriend_ByUserId(userId, data) {
    const $ = new Friends$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.createAddBulkFriend_ByUserId(userId, data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function createDeleteBulkFriend_ByUserId(userId, data) {
    const $ = new Friends$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.createDeleteBulkFriend_ByUserId(userId, data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  return {
    /**
     * Get list of friends in a namespace.
     */
    getFriendsMe,
    /**
     * Sync friends using server to server call to native first party server. Supported platforms: steam: The platform_tokens value is the binary ticket returned by Steam. If this ticket was generated by Steam GetAuthTicketForWebApi with version &gt;= 1.57, then platform token should use this style: {identity}:{ticket} the {identity} was the parameter to call GetAuthTicketForWebApi when the ticket was created. Note: Do not contain : in this {identity} ps4: The platform_tokens value is the authorization code returned by Sony OAuth. ps5: The platform_tokens value is the authorization code returned by Sony OAuth. pspc: The platform_tokens value is the authorization code returned by Sony OAuth.
     */
    patchFriendSyncMe,
    /**
     * Client should provide either friendID or friendPublicID. If both are provided, friendID will be chosen to be used. This endpoint will only send a pending invite that can be either rejected/accepted
     */
    createFriendMeRequest,
    /**
     * Get list of incoming friends in a namespace.
     */
    getFriendsMeIncoming,
    /**
     * Get list of outgoing friends in a namespace.
     */
    getFriendsMeOutgoing,
    /**
     * User unfriend a friend.
     */
    createFriendMeUnfriend,
    /**
     * Get list of friends with platform data in a namespace.
     */
    getFriendsMePlatforms,
    /**
     * Get list of incoming friends with requested time info in a namespace.
     */
    getFriendsMeIncomingTime,
    /**
     * Get list of outgoing friends with requested time info in a namespace.
     */
    getFriendsMeOutgoingTime,
    /**
     * User accept friend.
     */
    createFriendMeRequestAccept,
    /**
     * User cancel a friend request.
     */
    createFriendMeRequestCancel,
    /**
     * User reject a friend request.
     */
    createFriendMeRequestReject,
    /**
     * User get friendship status. Code: 0 - Message: &#34;not friend&#34; Code: 1 - Message: &#34;outgoing&#34; Code: 2 - Message: &#34;incoming&#34; Code: 3 - Message: &#34;friend&#34;
     */
    getFriendMeStatu_ByFriendId,
    /**
     * Friends request in a namespace.
     */
    createAddBulkFriend_ByUserId,
    /**
     * Friends request in a namespace.
     */
    createDeleteBulkFriend_ByUserId
  };
}

// src/generated-public/queries/Friends.query.ts
var Key_Friends = /* @__PURE__ */ ((Key_Friends2) => {
  Key_Friends2["FriendsMe"] = "Lobby.Friends.FriendsMe";
  Key_Friends2["FriendSyncMe"] = "Lobby.Friends.FriendSyncMe";
  Key_Friends2["FriendMeRequest"] = "Lobby.Friends.FriendMeRequest";
  Key_Friends2["FriendsMeIncoming"] = "Lobby.Friends.FriendsMeIncoming";
  Key_Friends2["FriendsMeOutgoing"] = "Lobby.Friends.FriendsMeOutgoing";
  Key_Friends2["FriendMeUnfriend"] = "Lobby.Friends.FriendMeUnfriend";
  Key_Friends2["FriendsMePlatforms"] = "Lobby.Friends.FriendsMePlatforms";
  Key_Friends2["FriendsMeIncomingTime"] = "Lobby.Friends.FriendsMeIncomingTime";
  Key_Friends2["FriendsMeOutgoingTime"] = "Lobby.Friends.FriendsMeOutgoingTime";
  Key_Friends2["FriendMeRequestAccept"] = "Lobby.Friends.FriendMeRequestAccept";
  Key_Friends2["FriendMeRequestCancel"] = "Lobby.Friends.FriendMeRequestCancel";
  Key_Friends2["FriendMeRequestReject"] = "Lobby.Friends.FriendMeRequestReject";
  Key_Friends2["FriendMeStatu_ByFriendId"] = "Lobby.Friends.FriendMeStatu_ByFriendId";
  Key_Friends2["AddBulkFriend_ByUserId"] = "Lobby.Friends.AddBulkFriend_ByUserId";
  Key_Friends2["DeleteBulkFriend_ByUserId"] = "Lobby.Friends.DeleteBulkFriend_ByUserId";
  return Key_Friends2;
})(Key_Friends || {});
var useFriendsApi_GetFriendsMe = (sdk, input, options, callback) => {
  const queryFn = (sdk2, input2) => async () => {
    const response = await FriendsApi(sdk2, { coreConfig: input2.coreConfig, axiosConfig: input2.axiosConfig }).getFriendsMe(input2.queryParams);
    callback && callback(response);
    return response.data;
  };
  return (0, import_react_query12.useQuery)({
    queryKey: ["Lobby.Friends.FriendsMe" /* FriendsMe */, input],
    queryFn: queryFn(sdk, input),
    ...options
  });
};
var useFriendsApi_PatchFriendSyncMeMutation = (sdk, options, callback) => {
  const mutationFn = async (input) => {
    const response = await FriendsApi(sdk, { coreConfig: input.coreConfig, axiosConfig: input.axiosConfig }).patchFriendSyncMe(input.data);
    callback && callback(response.data);
    return response.data;
  };
  return (0, import_react_query12.useMutation)({
    mutationKey: ["Lobby.Friends.FriendSyncMe" /* FriendSyncMe */],
    mutationFn,
    ...options
  });
};
var useFriendsApi_CreateFriendMeRequestMutation = (sdk, options, callback) => {
  const mutationFn = async (input) => {
    const response = await FriendsApi(sdk, { coreConfig: input.coreConfig, axiosConfig: input.axiosConfig }).createFriendMeRequest(
      input.data
    );
    callback && callback(response.data);
    return response.data;
  };
  return (0, import_react_query12.useMutation)({
    mutationKey: ["Lobby.Friends.FriendMeRequest" /* FriendMeRequest */],
    mutationFn,
    ...options
  });
};
var useFriendsApi_GetFriendsMeIncoming = (sdk, input, options, callback) => {
  const queryFn = (sdk2, input2) => async () => {
    const response = await FriendsApi(sdk2, { coreConfig: input2.coreConfig, axiosConfig: input2.axiosConfig }).getFriendsMeIncoming(
      input2.queryParams
    );
    callback && callback(response);
    return response.data;
  };
  return (0, import_react_query12.useQuery)({
    queryKey: ["Lobby.Friends.FriendsMeIncoming" /* FriendsMeIncoming */, input],
    queryFn: queryFn(sdk, input),
    ...options
  });
};
var useFriendsApi_GetFriendsMeOutgoing = (sdk, input, options, callback) => {
  const queryFn = (sdk2, input2) => async () => {
    const response = await FriendsApi(sdk2, { coreConfig: input2.coreConfig, axiosConfig: input2.axiosConfig }).getFriendsMeOutgoing(
      input2.queryParams
    );
    callback && callback(response);
    return response.data;
  };
  return (0, import_react_query12.useQuery)({
    queryKey: ["Lobby.Friends.FriendsMeOutgoing" /* FriendsMeOutgoing */, input],
    queryFn: queryFn(sdk, input),
    ...options
  });
};
var useFriendsApi_CreateFriendMeUnfriendMutation = (sdk, options, callback) => {
  const mutationFn = async (input) => {
    const response = await FriendsApi(sdk, { coreConfig: input.coreConfig, axiosConfig: input.axiosConfig }).createFriendMeUnfriend(
      input.data
    );
    callback && callback(response.data);
    return response.data;
  };
  return (0, import_react_query12.useMutation)({
    mutationKey: ["Lobby.Friends.FriendMeUnfriend" /* FriendMeUnfriend */],
    mutationFn,
    ...options
  });
};
var useFriendsApi_GetFriendsMePlatforms = (sdk, input, options, callback) => {
  const queryFn = (sdk2, input2) => async () => {
    const response = await FriendsApi(sdk2, { coreConfig: input2.coreConfig, axiosConfig: input2.axiosConfig }).getFriendsMePlatforms(
      input2.queryParams
    );
    callback && callback(response);
    return response.data;
  };
  return (0, import_react_query12.useQuery)({
    queryKey: ["Lobby.Friends.FriendsMePlatforms" /* FriendsMePlatforms */, input],
    queryFn: queryFn(sdk, input),
    ...options
  });
};
var useFriendsApi_GetFriendsMeIncomingTime = (sdk, input, options, callback) => {
  const queryFn = (sdk2, input2) => async () => {
    const response = await FriendsApi(sdk2, { coreConfig: input2.coreConfig, axiosConfig: input2.axiosConfig }).getFriendsMeIncomingTime(
      input2.queryParams
    );
    callback && callback(response);
    return response.data;
  };
  return (0, import_react_query12.useQuery)({
    queryKey: ["Lobby.Friends.FriendsMeIncomingTime" /* FriendsMeIncomingTime */, input],
    queryFn: queryFn(sdk, input),
    ...options
  });
};
var useFriendsApi_GetFriendsMeOutgoingTime = (sdk, input, options, callback) => {
  const queryFn = (sdk2, input2) => async () => {
    const response = await FriendsApi(sdk2, { coreConfig: input2.coreConfig, axiosConfig: input2.axiosConfig }).getFriendsMeOutgoingTime(
      input2.queryParams
    );
    callback && callback(response);
    return response.data;
  };
  return (0, import_react_query12.useQuery)({
    queryKey: ["Lobby.Friends.FriendsMeOutgoingTime" /* FriendsMeOutgoingTime */, input],
    queryFn: queryFn(sdk, input),
    ...options
  });
};
var useFriendsApi_CreateFriendMeRequestAcceptMutation = (sdk, options, callback) => {
  const mutationFn = async (input) => {
    const response = await FriendsApi(sdk, { coreConfig: input.coreConfig, axiosConfig: input.axiosConfig }).createFriendMeRequestAccept(
      input.data
    );
    callback && callback(response.data);
    return response.data;
  };
  return (0, import_react_query12.useMutation)({
    mutationKey: ["Lobby.Friends.FriendMeRequestAccept" /* FriendMeRequestAccept */],
    mutationFn,
    ...options
  });
};
var useFriendsApi_CreateFriendMeRequestCancelMutation = (sdk, options, callback) => {
  const mutationFn = async (input) => {
    const response = await FriendsApi(sdk, { coreConfig: input.coreConfig, axiosConfig: input.axiosConfig }).createFriendMeRequestCancel(
      input.data
    );
    callback && callback(response.data);
    return response.data;
  };
  return (0, import_react_query12.useMutation)({
    mutationKey: ["Lobby.Friends.FriendMeRequestCancel" /* FriendMeRequestCancel */],
    mutationFn,
    ...options
  });
};
var useFriendsApi_CreateFriendMeRequestRejectMutation = (sdk, options, callback) => {
  const mutationFn = async (input) => {
    const response = await FriendsApi(sdk, { coreConfig: input.coreConfig, axiosConfig: input.axiosConfig }).createFriendMeRequestReject(
      input.data
    );
    callback && callback(response.data);
    return response.data;
  };
  return (0, import_react_query12.useMutation)({
    mutationKey: ["Lobby.Friends.FriendMeRequestReject" /* FriendMeRequestReject */],
    mutationFn,
    ...options
  });
};
var useFriendsApi_GetFriendMeStatu_ByFriendId = (sdk, input, options, callback) => {
  const queryFn = (sdk2, input2) => async () => {
    const response = await FriendsApi(sdk2, { coreConfig: input2.coreConfig, axiosConfig: input2.axiosConfig }).getFriendMeStatu_ByFriendId(
      input2.friendId
    );
    callback && callback(response);
    return response.data;
  };
  return (0, import_react_query12.useQuery)({
    queryKey: ["Lobby.Friends.FriendMeStatu_ByFriendId" /* FriendMeStatu_ByFriendId */, input],
    queryFn: queryFn(sdk, input),
    ...options
  });
};
var useFriendsApi_CreateAddBulkFriend_ByUserIdMutation = (sdk, options, callback) => {
  const mutationFn = async (input) => {
    const response = await FriendsApi(sdk, { coreConfig: input.coreConfig, axiosConfig: input.axiosConfig }).createAddBulkFriend_ByUserId(
      input.userId,
      input.data
    );
    callback && callback(response.data);
    return response.data;
  };
  return (0, import_react_query12.useMutation)({
    mutationKey: ["Lobby.Friends.AddBulkFriend_ByUserId" /* AddBulkFriend_ByUserId */],
    mutationFn,
    ...options
  });
};
var useFriendsApi_CreateDeleteBulkFriend_ByUserIdMutation = (sdk, options, callback) => {
  const mutationFn = async (input) => {
    const response = await FriendsApi(sdk, {
      coreConfig: input.coreConfig,
      axiosConfig: input.axiosConfig
    }).createDeleteBulkFriend_ByUserId(input.userId, input.data);
    callback && callback(response.data);
    return response.data;
  };
  return (0, import_react_query12.useMutation)({
    mutationKey: ["Lobby.Friends.DeleteBulkFriend_ByUserId" /* DeleteBulkFriend_ByUserId */],
    mutationFn,
    ...options
  });
};

// src/generated-public/queries/LobbyOperations.query.ts
var import_react_query13 = require("@tanstack/react-query");

// src/generated-public/LobbyOperationsApi.ts
var import_sdk26 = require("@accelbyte/sdk");

// src/generated-public/endpoints/LobbyOperations$.ts
var import_sdk25 = require("@accelbyte/sdk");

// src/generated-definitions/AppMessageDeclarationArray.ts
var import_zod73 = require("zod");

// src/generated-definitions/AppMessageDeclaration.ts
var import_zod72 = require("zod");
var AppMessageDeclaration = import_zod72.z.object({
  Attributes: import_zod72.z.array(import_zod72.z.string()),
  Code: import_zod72.z.string(),
  CodeName: import_zod72.z.string(),
  Section: import_zod72.z.string(),
  Service: import_zod72.z.string(),
  Text: import_zod72.z.string()
});

// src/generated-definitions/AppMessageDeclarationArray.ts
var AppMessageDeclarationArray = import_zod73.z.array(AppMessageDeclaration);

// src/generated-public/endpoints/LobbyOperations$.ts
var LobbyOperations$ = class {
  // @ts-ignore
  // prettier-ignore
  constructor(axiosInstance, namespace, useSchemaValidation = true) {
    this.axiosInstance = axiosInstance;
    this.namespace = namespace;
    this.useSchemaValidation = useSchemaValidation;
  }
  /**
   * get the list of messages.
   */
  getMessages() {
    const params = {};
    const url = "/lobby/v1/messages";
    const resultPromise = this.axiosInstance.get(url, { params });
    return import_sdk25.Validate.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      AppMessageDeclarationArray,
      "AppMessageDeclarationArray"
    );
  }
};

// src/generated-public/LobbyOperationsApi.ts
function LobbyOperationsApi(sdk, args) {
  const sdkAssembly = sdk.assembly();
  const namespace = args?.coreConfig?.namespace ?? sdkAssembly.coreConfig.namespace;
  const useSchemaValidation = args?.coreConfig?.useSchemaValidation ?? sdkAssembly.coreConfig.useSchemaValidation;
  let axiosInstance = sdkAssembly.axiosInstance;
  const requestConfigOverrides = args?.axiosConfig?.request;
  const baseURLOverride = args?.coreConfig?.baseURL;
  const interceptorsOverride = args?.axiosConfig?.interceptors ?? [];
  if (requestConfigOverrides || baseURLOverride || interceptorsOverride.length > 0) {
    const requestConfig = import_sdk26.ApiUtils.mergeAxiosConfigs(sdkAssembly.axiosInstance.defaults, {
      ...baseURLOverride ? { baseURL: baseURLOverride } : {},
      ...requestConfigOverrides
    });
    axiosInstance = import_sdk26.Network.create(requestConfig);
    for (const interceptor of interceptorsOverride) {
      if (interceptor.type === "request") {
        axiosInstance.interceptors.request.use(interceptor.onRequest, interceptor.onError);
      }
      if (interceptor.type === "response") {
        axiosInstance.interceptors.response.use(interceptor.onSuccess, interceptor.onError);
      }
    }
  }
  async function getMessages() {
    const $ = new LobbyOperations$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getMessages();
    if (resp.error) throw resp.error;
    return resp.response;
  }
  return {
    /**
     * get the list of messages.
     */
    getMessages
  };
}

// src/generated-public/queries/LobbyOperations.query.ts
var Key_LobbyOperations = /* @__PURE__ */ ((Key_LobbyOperations2) => {
  Key_LobbyOperations2["Messages"] = "Lobby.LobbyOperations.Messages";
  return Key_LobbyOperations2;
})(Key_LobbyOperations || {});
var useLobbyOperationsApi_GetMessages = (sdk, input, options, callback) => {
  const queryFn = (sdk2, input2) => async () => {
    const response = await LobbyOperationsApi(sdk2, { coreConfig: input2.coreConfig, axiosConfig: input2.axiosConfig }).getMessages();
    callback && callback(response);
    return response.data;
  };
  return (0, import_react_query13.useQuery)({
    queryKey: ["Lobby.LobbyOperations.Messages" /* Messages */, input],
    queryFn: queryFn(sdk, input),
    ...options
  });
};

// src/generated-public/queries/Notification.query.ts
var import_react_query14 = require("@tanstack/react-query");

// src/generated-public/NotificationApi.ts
var import_sdk28 = require("@accelbyte/sdk");

// src/generated-public/endpoints/Notification$.ts
var import_sdk27 = require("@accelbyte/sdk");
var import_zod77 = require("zod");

// src/generated-definitions/NotificationResponse.ts
var import_zod74 = require("zod");
var NotificationResponse = import_zod74.z.object({
  from: import_zod74.z.string().nullish(),
  id: import_zod74.z.string().nullish(),
  lobbySessionID: import_zod74.z.string().nullish(),
  loginType: import_zod74.z.string().nullish(),
  payload: import_zod74.z.string().nullish(),
  reconnectFromCode: import_zod74.z.number().int().nullish(),
  sentAt: import_zod74.z.string().nullish(),
  sequenceID: import_zod74.z.number().int(),
  sequenceNumber: import_zod74.z.number().int(),
  to: import_zod74.z.string().nullish(),
  topic: import_zod74.z.string().nullish(),
  type: import_zod74.z.string()
});

// src/generated-definitions/NotificationTopicResponse.ts
var import_zod75 = require("zod");
var NotificationTopicResponse = import_zod75.z.object({
  createdAt: import_zod75.z.number().int(),
  description: import_zod75.z.string(),
  namespace: import_zod75.z.string(),
  topic: import_zod75.z.string()
});

// src/generated-definitions/TopicByNamespacesResponse.ts
var import_zod76 = require("zod");
var TopicByNamespacesResponse = import_zod76.z.object({
  first: import_zod76.z.string(),
  last: import_zod76.z.string(),
  next: import_zod76.z.string(),
  previous: import_zod76.z.string(),
  topics: import_zod76.z.array(NotificationTopicResponse)
});

// src/generated-public/endpoints/Notification$.ts
var Notification$ = class {
  // @ts-ignore
  // prettier-ignore
  constructor(axiosInstance, namespace, useSchemaValidation = true) {
    this.axiosInstance = axiosInstance;
    this.namespace = namespace;
    this.useSchemaValidation = useSchemaValidation;
  }
  /**
   * Get list of notifications in a namespace. The query parameters **startTime** and **endTime** can be filled with the **sequenceID** value in the notification, where the value is an epoch timestamp. Example **sequenceID** or epoch timestamp value: **1706595813**
   */
  getNotificationMe(queryParams) {
    const params = { limit: 25, ...queryParams };
    const url = "/notification/namespaces/{namespace}/me".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.get(url, { params });
    return import_sdk27.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, NotificationResponse, "NotificationResponse");
  }
  /**
   * get topic by namespace.
   */
  getNotificationTopics(queryParams) {
    const params = { ...queryParams };
    const url = "/notification/namespaces/{namespace}/topics".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.get(url, { params });
    return import_sdk27.Validate.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      TopicByNamespacesResponse,
      "TopicByNamespacesResponse"
    );
  }
  /**
   * Create new notification topic. &lt;br&gt;topic should be alphabets, no special char except underscore, uppercase and no spacing. for example: TOPIC_TEST. Already existing topic can not be created
   */
  createNotificationTopic(data) {
    const params = {};
    const url = "/notification/namespaces/{namespace}/topics".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.post(url, data, { params });
    return import_sdk27.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, import_zod77.z.unknown(), "z.unknown()");
  }
  /**
   * delete topic information by topic name. &lt;br&gt;topic should be alphabets, no special char except underscore, uppercase and no spacing. for example: TOPIC_TEST. Already existing topic can not be created
   */
  deleteNotificationTopic_ByTopic(topic) {
    const params = {};
    const url = "/notification/namespaces/{namespace}/topics/{topic}".replace("{namespace}", this.namespace).replace("{topic}", topic);
    const resultPromise = this.axiosInstance.delete(url, { params });
    return import_sdk27.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, import_zod77.z.unknown(), "z.unknown()");
  }
  /**
   * get topic information by topic name.
   */
  getNotificationTopic_ByTopic(topic) {
    const params = {};
    const url = "/notification/namespaces/{namespace}/topics/{topic}".replace("{namespace}", this.namespace).replace("{topic}", topic);
    const resultPromise = this.axiosInstance.get(url, { params });
    return import_sdk27.Validate.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      NotificationTopicResponse,
      "NotificationTopicResponse"
    );
  }
  /**
   * update topic information by topic name. &lt;br&gt;topic should be alphabets, no special char except underscore, uppercase and no spacing. for example: TOPIC_TEST. Already existing topic can not be created
   */
  updateNotificationTopic_ByTopic(topic, data) {
    const params = {};
    const url = "/notification/namespaces/{namespace}/topics/{topic}".replace("{namespace}", this.namespace).replace("{topic}", topic);
    const resultPromise = this.axiosInstance.put(url, data, { params });
    return import_sdk27.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, import_zod77.z.unknown(), "z.unknown()");
  }
  /**
   * Sends notification to a user.
   */
  createFreeformNotification_ByUserId(userId, data) {
    const params = {};
    const url = "/notification/namespaces/{namespace}/users/{userId}/freeform".replace("{namespace}", this.namespace).replace("{userId}", userId);
    const resultPromise = this.axiosInstance.post(url, data, { params });
    return import_sdk27.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, import_zod77.z.unknown(), "z.unknown()");
  }
  /**
   * Sends notification to a user with predefined template. &lt;br&gt;In the request body, specify which template slug (template identifier) to use and the template language. &lt;br&gt;NotificationTemplate context is the key-value pair defining the value of each handlebar specified in the template content. Template need to be published before it can be use to send notifications
   */
  createTemplatedNotification_ByUserId(userId, data) {
    const params = {};
    const url = "/notification/namespaces/{namespace}/users/{userId}/templated".replace("{namespace}", this.namespace).replace("{userId}", userId);
    const resultPromise = this.axiosInstance.post(url, data, { params });
    return import_sdk27.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, import_zod77.z.unknown(), "z.unknown()");
  }
};

// src/generated-public/NotificationApi.ts
function NotificationApi(sdk, args) {
  const sdkAssembly = sdk.assembly();
  const namespace = args?.coreConfig?.namespace ?? sdkAssembly.coreConfig.namespace;
  const useSchemaValidation = args?.coreConfig?.useSchemaValidation ?? sdkAssembly.coreConfig.useSchemaValidation;
  let axiosInstance = sdkAssembly.axiosInstance;
  const requestConfigOverrides = args?.axiosConfig?.request;
  const baseURLOverride = args?.coreConfig?.baseURL;
  const interceptorsOverride = args?.axiosConfig?.interceptors ?? [];
  if (requestConfigOverrides || baseURLOverride || interceptorsOverride.length > 0) {
    const requestConfig = import_sdk28.ApiUtils.mergeAxiosConfigs(sdkAssembly.axiosInstance.defaults, {
      ...baseURLOverride ? { baseURL: baseURLOverride } : {},
      ...requestConfigOverrides
    });
    axiosInstance = import_sdk28.Network.create(requestConfig);
    for (const interceptor of interceptorsOverride) {
      if (interceptor.type === "request") {
        axiosInstance.interceptors.request.use(interceptor.onRequest, interceptor.onError);
      }
      if (interceptor.type === "response") {
        axiosInstance.interceptors.response.use(interceptor.onSuccess, interceptor.onError);
      }
    }
  }
  async function getNotificationMe(queryParams) {
    const $ = new Notification$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getNotificationMe(queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getNotificationTopics(queryParams) {
    const $ = new Notification$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getNotificationTopics(queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function createNotificationTopic(data) {
    const $ = new Notification$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.createNotificationTopic(data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function deleteNotificationTopic_ByTopic(topic) {
    const $ = new Notification$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.deleteNotificationTopic_ByTopic(topic);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getNotificationTopic_ByTopic(topic) {
    const $ = new Notification$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getNotificationTopic_ByTopic(topic);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function updateNotificationTopic_ByTopic(topic, data) {
    const $ = new Notification$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.updateNotificationTopic_ByTopic(topic, data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function createFreeformNotification_ByUserId(userId, data) {
    const $ = new Notification$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.createFreeformNotification_ByUserId(userId, data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function createTemplatedNotification_ByUserId(userId, data) {
    const $ = new Notification$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.createTemplatedNotification_ByUserId(userId, data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  return {
    /**
     * Get list of notifications in a namespace. The query parameters **startTime** and **endTime** can be filled with the **sequenceID** value in the notification, where the value is an epoch timestamp. Example **sequenceID** or epoch timestamp value: **1706595813**
     */
    getNotificationMe,
    /**
     * get topic by namespace.
     */
    getNotificationTopics,
    /**
     * Create new notification topic. &lt;br&gt;topic should be alphabets, no special char except underscore, uppercase and no spacing. for example: TOPIC_TEST. Already existing topic can not be created
     */
    createNotificationTopic,
    /**
     * delete topic information by topic name. &lt;br&gt;topic should be alphabets, no special char except underscore, uppercase and no spacing. for example: TOPIC_TEST. Already existing topic can not be created
     */
    deleteNotificationTopic_ByTopic,
    /**
     * get topic information by topic name.
     */
    getNotificationTopic_ByTopic,
    /**
     * update topic information by topic name. &lt;br&gt;topic should be alphabets, no special char except underscore, uppercase and no spacing. for example: TOPIC_TEST. Already existing topic can not be created
     */
    updateNotificationTopic_ByTopic,
    /**
     * Sends notification to a user.
     */
    createFreeformNotification_ByUserId,
    /**
     * Sends notification to a user with predefined template. &lt;br&gt;In the request body, specify which template slug (template identifier) to use and the template language. &lt;br&gt;NotificationTemplate context is the key-value pair defining the value of each handlebar specified in the template content. Template need to be published before it can be use to send notifications
     */
    createTemplatedNotification_ByUserId
  };
}

// src/generated-public/queries/Notification.query.ts
var Key_Notification = /* @__PURE__ */ ((Key_Notification2) => {
  Key_Notification2["NotificationMe"] = "Lobby.Notification.NotificationMe";
  Key_Notification2["NotificationTopics"] = "Lobby.Notification.NotificationTopics";
  Key_Notification2["NotificationTopic"] = "Lobby.Notification.NotificationTopic";
  Key_Notification2["NotificationTopic_ByTopic"] = "Lobby.Notification.NotificationTopic_ByTopic";
  Key_Notification2["FreeformNotification_ByUserId"] = "Lobby.Notification.FreeformNotification_ByUserId";
  Key_Notification2["TemplatedNotification_ByUserId"] = "Lobby.Notification.TemplatedNotification_ByUserId";
  return Key_Notification2;
})(Key_Notification || {});
var useNotificationApi_GetNotificationMe = (sdk, input, options, callback) => {
  const queryFn = (sdk2, input2) => async () => {
    const response = await NotificationApi(sdk2, { coreConfig: input2.coreConfig, axiosConfig: input2.axiosConfig }).getNotificationMe(
      input2.queryParams
    );
    callback && callback(response);
    return response.data;
  };
  return (0, import_react_query14.useQuery)({
    queryKey: ["Lobby.Notification.NotificationMe" /* NotificationMe */, input],
    queryFn: queryFn(sdk, input),
    ...options
  });
};
var useNotificationApi_GetNotificationTopics = (sdk, input, options, callback) => {
  const queryFn = (sdk2, input2) => async () => {
    const response = await NotificationApi(sdk2, { coreConfig: input2.coreConfig, axiosConfig: input2.axiosConfig }).getNotificationTopics(
      input2.queryParams
    );
    callback && callback(response);
    return response.data;
  };
  return (0, import_react_query14.useQuery)({
    queryKey: ["Lobby.Notification.NotificationTopics" /* NotificationTopics */, input],
    queryFn: queryFn(sdk, input),
    ...options
  });
};
var useNotificationApi_CreateNotificationTopicMutation = (sdk, options, callback) => {
  const mutationFn = async (input) => {
    const response = await NotificationApi(sdk, { coreConfig: input.coreConfig, axiosConfig: input.axiosConfig }).createNotificationTopic(
      input.data
    );
    callback && callback(response.data);
    return response.data;
  };
  return (0, import_react_query14.useMutation)({
    mutationKey: ["Lobby.Notification.NotificationTopic" /* NotificationTopic */],
    mutationFn,
    ...options
  });
};
var useNotificationApi_DeleteNotificationTopic_ByTopicMutation = (sdk, options, callback) => {
  const mutationFn = async (input) => {
    const response = await NotificationApi(sdk, {
      coreConfig: input.coreConfig,
      axiosConfig: input.axiosConfig
    }).deleteNotificationTopic_ByTopic(input.topic);
    callback && callback(response.data);
    return response.data;
  };
  return (0, import_react_query14.useMutation)({
    mutationKey: ["Lobby.Notification.NotificationTopic_ByTopic" /* NotificationTopic_ByTopic */],
    mutationFn,
    ...options
  });
};
var useNotificationApi_GetNotificationTopic_ByTopic = (sdk, input, options, callback) => {
  const queryFn = (sdk2, input2) => async () => {
    const response = await NotificationApi(sdk2, {
      coreConfig: input2.coreConfig,
      axiosConfig: input2.axiosConfig
    }).getNotificationTopic_ByTopic(input2.topic);
    callback && callback(response);
    return response.data;
  };
  return (0, import_react_query14.useQuery)({
    queryKey: ["Lobby.Notification.NotificationTopic_ByTopic" /* NotificationTopic_ByTopic */, input],
    queryFn: queryFn(sdk, input),
    ...options
  });
};
var useNotificationApi_UpdateNotificationTopic_ByTopicMutation = (sdk, options, callback) => {
  const mutationFn = async (input) => {
    const response = await NotificationApi(sdk, {
      coreConfig: input.coreConfig,
      axiosConfig: input.axiosConfig
    }).updateNotificationTopic_ByTopic(input.topic, input.data);
    callback && callback(response.data);
    return response.data;
  };
  return (0, import_react_query14.useMutation)({
    mutationKey: ["Lobby.Notification.NotificationTopic_ByTopic" /* NotificationTopic_ByTopic */],
    mutationFn,
    ...options
  });
};
var useNotificationApi_CreateFreeformNotification_ByUserIdMutation = (sdk, options, callback) => {
  const mutationFn = async (input) => {
    const response = await NotificationApi(sdk, {
      coreConfig: input.coreConfig,
      axiosConfig: input.axiosConfig
    }).createFreeformNotification_ByUserId(input.userId, input.data);
    callback && callback(response.data);
    return response.data;
  };
  return (0, import_react_query14.useMutation)({
    mutationKey: ["Lobby.Notification.FreeformNotification_ByUserId" /* FreeformNotification_ByUserId */],
    mutationFn,
    ...options
  });
};
var useNotificationApi_CreateTemplatedNotification_ByUserIdMutation = (sdk, options, callback) => {
  const mutationFn = async (input) => {
    const response = await NotificationApi(sdk, {
      coreConfig: input.coreConfig,
      axiosConfig: input.axiosConfig
    }).createTemplatedNotification_ByUserId(input.userId, input.data);
    callback && callback(response.data);
    return response.data;
  };
  return (0, import_react_query14.useMutation)({
    mutationKey: ["Lobby.Notification.TemplatedNotification_ByUserId" /* TemplatedNotification_ByUserId */],
    mutationFn,
    ...options
  });
};

// src/generated-public/queries/Party.query.ts
var import_react_query15 = require("@tanstack/react-query");

// src/generated-public/PartyApi.ts
var import_sdk30 = require("@accelbyte/sdk");

// src/generated-public/endpoints/Party$.ts
var import_sdk29 = require("@accelbyte/sdk");
var import_zod78 = require("zod");
var Party$ = class {
  // @ts-ignore
  // prettier-ignore
  constructor(axiosInstance, namespace, useSchemaValidation = true) {
    this.axiosInstance = axiosInstance;
    this.namespace = namespace;
    this.useSchemaValidation = useSchemaValidation;
  }
  /**
   * Required valid user authorization &lt;br/&gt; &lt;br&gt;load personal party data in a namespace based on Party ID &lt;br/&gt; Action Code: 50101
   */
  getPartyParty_ByPartyId(partyId) {
    const params = {};
    const url = "/lobby/v1/public/party/namespaces/{namespace}/parties/{partyId}".replace("{namespace}", this.namespace).replace("{partyId}", partyId);
    const resultPromise = this.axiosInstance.get(url, { params });
    return import_sdk29.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, PartyData, "PartyData");
  }
  /**
   * Required valid user authorization &lt;br/&gt; &lt;br&gt;Set party limit, only party leader can call this endpoint.
   */
  updateLimitParty_ByPartyId(partyId, data) {
    const params = {};
    const url = "/lobby/v1/public/party/namespaces/{namespace}/parties/{partyId}/limit".replace("{namespace}", this.namespace).replace("{partyId}", partyId);
    const resultPromise = this.axiosInstance.put(url, data, { params });
    return import_sdk29.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, import_zod78.z.unknown(), "z.unknown()");
  }
  /**
   * Required valid user authorization &lt;br/&gt; &lt;br&gt;update party attributes in a namespace.
   */
  updateAttributeParty_ByPartyId(partyId, data) {
    const params = {};
    const url = "/lobby/v1/public/party/namespaces/{namespace}/parties/{partyId}/attributes".replace("{namespace}", this.namespace).replace("{partyId}", partyId);
    const resultPromise = this.axiosInstance.put(url, data, { params });
    return import_sdk29.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, PartyData, "PartyData");
  }
};

// src/generated-public/PartyApi.ts
function PartyApi(sdk, args) {
  const sdkAssembly = sdk.assembly();
  const namespace = args?.coreConfig?.namespace ?? sdkAssembly.coreConfig.namespace;
  const useSchemaValidation = args?.coreConfig?.useSchemaValidation ?? sdkAssembly.coreConfig.useSchemaValidation;
  let axiosInstance = sdkAssembly.axiosInstance;
  const requestConfigOverrides = args?.axiosConfig?.request;
  const baseURLOverride = args?.coreConfig?.baseURL;
  const interceptorsOverride = args?.axiosConfig?.interceptors ?? [];
  if (requestConfigOverrides || baseURLOverride || interceptorsOverride.length > 0) {
    const requestConfig = import_sdk30.ApiUtils.mergeAxiosConfigs(sdkAssembly.axiosInstance.defaults, {
      ...baseURLOverride ? { baseURL: baseURLOverride } : {},
      ...requestConfigOverrides
    });
    axiosInstance = import_sdk30.Network.create(requestConfig);
    for (const interceptor of interceptorsOverride) {
      if (interceptor.type === "request") {
        axiosInstance.interceptors.request.use(interceptor.onRequest, interceptor.onError);
      }
      if (interceptor.type === "response") {
        axiosInstance.interceptors.response.use(interceptor.onSuccess, interceptor.onError);
      }
    }
  }
  async function getPartyParty_ByPartyId(partyId) {
    const $ = new Party$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getPartyParty_ByPartyId(partyId);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function updateLimitParty_ByPartyId(partyId, data) {
    const $ = new Party$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.updateLimitParty_ByPartyId(partyId, data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function updateAttributeParty_ByPartyId(partyId, data) {
    const $ = new Party$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.updateAttributeParty_ByPartyId(partyId, data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  return {
    /**
     * Required valid user authorization &lt;br/&gt; &lt;br&gt;load personal party data in a namespace based on Party ID &lt;br/&gt; Action Code: 50101
     */
    getPartyParty_ByPartyId,
    /**
     * Required valid user authorization &lt;br/&gt; &lt;br&gt;Set party limit, only party leader can call this endpoint.
     */
    updateLimitParty_ByPartyId,
    /**
     * Required valid user authorization &lt;br/&gt; &lt;br&gt;update party attributes in a namespace.
     */
    updateAttributeParty_ByPartyId
  };
}

// src/generated-public/queries/Party.query.ts
var Key_Party = /* @__PURE__ */ ((Key_Party2) => {
  Key_Party2["PartyParty_ByPartyId"] = "Lobby.Party.PartyParty_ByPartyId";
  Key_Party2["LimitParty_ByPartyId"] = "Lobby.Party.LimitParty_ByPartyId";
  Key_Party2["AttributeParty_ByPartyId"] = "Lobby.Party.AttributeParty_ByPartyId";
  return Key_Party2;
})(Key_Party || {});
var usePartyApi_GetPartyParty_ByPartyId = (sdk, input, options, callback) => {
  const queryFn = (sdk2, input2) => async () => {
    const response = await PartyApi(sdk2, { coreConfig: input2.coreConfig, axiosConfig: input2.axiosConfig }).getPartyParty_ByPartyId(
      input2.partyId
    );
    callback && callback(response);
    return response.data;
  };
  return (0, import_react_query15.useQuery)({
    queryKey: ["Lobby.Party.PartyParty_ByPartyId" /* PartyParty_ByPartyId */, input],
    queryFn: queryFn(sdk, input),
    ...options
  });
};
var usePartyApi_UpdateLimitParty_ByPartyIdMutation = (sdk, options, callback) => {
  const mutationFn = async (input) => {
    const response = await PartyApi(sdk, { coreConfig: input.coreConfig, axiosConfig: input.axiosConfig }).updateLimitParty_ByPartyId(
      input.partyId,
      input.data
    );
    callback && callback(response.data);
    return response.data;
  };
  return (0, import_react_query15.useMutation)({
    mutationKey: ["Lobby.Party.LimitParty_ByPartyId" /* LimitParty_ByPartyId */],
    mutationFn,
    ...options
  });
};
var usePartyApi_UpdateAttributeParty_ByPartyIdMutation = (sdk, options, callback) => {
  const mutationFn = async (input) => {
    const response = await PartyApi(sdk, { coreConfig: input.coreConfig, axiosConfig: input.axiosConfig }).updateAttributeParty_ByPartyId(
      input.partyId,
      input.data
    );
    callback && callback(response.data);
    return response.data;
  };
  return (0, import_react_query15.useMutation)({
    mutationKey: ["Lobby.Party.AttributeParty_ByPartyId" /* AttributeParty_ByPartyId */],
    mutationFn,
    ...options
  });
};

// src/generated-public/queries/Player.query.ts
var import_react_query16 = require("@tanstack/react-query");

// src/generated-public/PlayerApi.ts
var import_sdk32 = require("@accelbyte/sdk");

// src/generated-public/endpoints/Player$.ts
var import_sdk31 = require("@accelbyte/sdk");
var import_zod79 = require("zod");
var Player$ = class {
  // @ts-ignore
  // prettier-ignore
  constructor(axiosInstance, namespace, useSchemaValidation = true) {
    this.axiosInstance = axiosInstance;
    this.namespace = namespace;
    this.useSchemaValidation = useSchemaValidation;
  }
  /**
   * Required valid user authorization &lt;br/&gt; &lt;br&gt;add blocked players in a namespace based on user id &lt;br/&gt;
   */
  createPlayerUserMeBlock(data) {
    const params = {};
    const url = "/lobby/v1/public/player/namespaces/{namespace}/users/me/block".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.post(url, data, { params });
    return import_sdk31.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, import_zod79.z.unknown(), "z.unknown()");
  }
  /**
   * Required valid user authorization &lt;br/&gt; &lt;br&gt;load blocked players in a namespace based on user id &lt;br/&gt; Action Code: 50101
   */
  getPlayerUsersMeBlocked() {
    const params = {};
    const url = "/lobby/v1/public/player/namespaces/{namespace}/users/me/blocked".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.get(url, { params });
    return import_sdk31.Validate.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      GetAllPlayerBlockedUsersResponse,
      "GetAllPlayerBlockedUsersResponse"
    );
  }
  /**
   * Required valid user authorization &lt;br/&gt; unblock player in a namespace based on user id &lt;br/&gt;
   */
  createPlayerUserMeUnblock(data) {
    const params = {};
    const url = "/lobby/v1/public/player/namespaces/{namespace}/users/me/unblock".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.post(url, data, { params });
    return import_sdk31.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, import_zod79.z.unknown(), "z.unknown()");
  }
  /**
   * Required valid user authorization &lt;br/&gt; &lt;br&gt;load get players who blocked this player in a namespace based on user id &lt;br/&gt; Action Code: 50101
   */
  getPlayerUsersMeBlockedBy() {
    const params = {};
    const url = "/lobby/v1/public/player/namespaces/{namespace}/users/me/blocked-by".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.get(url, { params });
    return import_sdk31.Validate.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      GetAllPlayerBlockedByUsersResponse,
      "GetAllPlayerBlockedByUsersResponse"
    );
  }
};

// src/generated-public/PlayerApi.ts
function PlayerApi(sdk, args) {
  const sdkAssembly = sdk.assembly();
  const namespace = args?.coreConfig?.namespace ?? sdkAssembly.coreConfig.namespace;
  const useSchemaValidation = args?.coreConfig?.useSchemaValidation ?? sdkAssembly.coreConfig.useSchemaValidation;
  let axiosInstance = sdkAssembly.axiosInstance;
  const requestConfigOverrides = args?.axiosConfig?.request;
  const baseURLOverride = args?.coreConfig?.baseURL;
  const interceptorsOverride = args?.axiosConfig?.interceptors ?? [];
  if (requestConfigOverrides || baseURLOverride || interceptorsOverride.length > 0) {
    const requestConfig = import_sdk32.ApiUtils.mergeAxiosConfigs(sdkAssembly.axiosInstance.defaults, {
      ...baseURLOverride ? { baseURL: baseURLOverride } : {},
      ...requestConfigOverrides
    });
    axiosInstance = import_sdk32.Network.create(requestConfig);
    for (const interceptor of interceptorsOverride) {
      if (interceptor.type === "request") {
        axiosInstance.interceptors.request.use(interceptor.onRequest, interceptor.onError);
      }
      if (interceptor.type === "response") {
        axiosInstance.interceptors.response.use(interceptor.onSuccess, interceptor.onError);
      }
    }
  }
  async function createPlayerUserMeBlock(data) {
    const $ = new Player$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.createPlayerUserMeBlock(data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getPlayerUsersMeBlocked() {
    const $ = new Player$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getPlayerUsersMeBlocked();
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function createPlayerUserMeUnblock(data) {
    const $ = new Player$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.createPlayerUserMeUnblock(data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getPlayerUsersMeBlockedBy() {
    const $ = new Player$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getPlayerUsersMeBlockedBy();
    if (resp.error) throw resp.error;
    return resp.response;
  }
  return {
    /**
     * Required valid user authorization &lt;br/&gt; &lt;br&gt;add blocked players in a namespace based on user id &lt;br/&gt;
     */
    createPlayerUserMeBlock,
    /**
     * Required valid user authorization &lt;br/&gt; &lt;br&gt;load blocked players in a namespace based on user id &lt;br/&gt; Action Code: 50101
     */
    getPlayerUsersMeBlocked,
    /**
     * Required valid user authorization &lt;br/&gt; unblock player in a namespace based on user id &lt;br/&gt;
     */
    createPlayerUserMeUnblock,
    /**
     * Required valid user authorization &lt;br/&gt; &lt;br&gt;load get players who blocked this player in a namespace based on user id &lt;br/&gt; Action Code: 50101
     */
    getPlayerUsersMeBlockedBy
  };
}

// src/generated-public/queries/Player.query.ts
var Key_Player = /* @__PURE__ */ ((Key_Player2) => {
  Key_Player2["PlayerUserMeBlock"] = "Lobby.Player.PlayerUserMeBlock";
  Key_Player2["PlayerUsersMeBlocked"] = "Lobby.Player.PlayerUsersMeBlocked";
  Key_Player2["PlayerUserMeUnblock"] = "Lobby.Player.PlayerUserMeUnblock";
  Key_Player2["PlayerUsersMeBlockedBy"] = "Lobby.Player.PlayerUsersMeBlockedBy";
  return Key_Player2;
})(Key_Player || {});
var usePlayerApi_CreatePlayerUserMeBlockMutation = (sdk, options, callback) => {
  const mutationFn = async (input) => {
    const response = await PlayerApi(sdk, { coreConfig: input.coreConfig, axiosConfig: input.axiosConfig }).createPlayerUserMeBlock(
      input.data
    );
    callback && callback(response.data);
    return response.data;
  };
  return (0, import_react_query16.useMutation)({
    mutationKey: ["Lobby.Player.PlayerUserMeBlock" /* PlayerUserMeBlock */],
    mutationFn,
    ...options
  });
};
var usePlayerApi_GetPlayerUsersMeBlocked = (sdk, input, options, callback) => {
  const queryFn = (sdk2, input2) => async () => {
    const response = await PlayerApi(sdk2, { coreConfig: input2.coreConfig, axiosConfig: input2.axiosConfig }).getPlayerUsersMeBlocked();
    callback && callback(response);
    return response.data;
  };
  return (0, import_react_query16.useQuery)({
    queryKey: ["Lobby.Player.PlayerUsersMeBlocked" /* PlayerUsersMeBlocked */, input],
    queryFn: queryFn(sdk, input),
    ...options
  });
};
var usePlayerApi_CreatePlayerUserMeUnblockMutation = (sdk, options, callback) => {
  const mutationFn = async (input) => {
    const response = await PlayerApi(sdk, { coreConfig: input.coreConfig, axiosConfig: input.axiosConfig }).createPlayerUserMeUnblock(
      input.data
    );
    callback && callback(response.data);
    return response.data;
  };
  return (0, import_react_query16.useMutation)({
    mutationKey: ["Lobby.Player.PlayerUserMeUnblock" /* PlayerUserMeUnblock */],
    mutationFn,
    ...options
  });
};
var usePlayerApi_GetPlayerUsersMeBlockedBy = (sdk, input, options, callback) => {
  const queryFn = (sdk2, input2) => async () => {
    const response = await PlayerApi(sdk2, { coreConfig: input2.coreConfig, axiosConfig: input2.axiosConfig }).getPlayerUsersMeBlockedBy();
    callback && callback(response);
    return response.data;
  };
  return (0, import_react_query16.useQuery)({
    queryKey: ["Lobby.Player.PlayerUsersMeBlockedBy" /* PlayerUsersMeBlockedBy */, input],
    queryFn: queryFn(sdk, input),
    ...options
  });
};

// src/generated-public/queries/Presence.query.ts
var import_react_query17 = require("@tanstack/react-query");

// src/generated-public/PresenceApi.ts
var import_sdk34 = require("@accelbyte/sdk");

// src/generated-public/endpoints/Presence$.ts
var import_sdk33 = require("@accelbyte/sdk");

// src/generated-definitions/GetUsersPresenceResponse.ts
var import_zod81 = require("zod");

// src/generated-definitions/UserPresence.ts
var import_zod80 = require("zod");
var UserPresence = import_zod80.z.object({
  activity: import_zod80.z.string(),
  availability: import_zod80.z.string(),
  lastSeenAt: import_zod80.z.string(),
  namespace: import_zod80.z.string(),
  platform: import_zod80.z.string(),
  userID: import_zod80.z.string()
});

// src/generated-definitions/GetUsersPresenceResponse.ts
var GetUsersPresenceResponse = import_zod81.z.object({
  away: import_zod81.z.number().int(),
  busy: import_zod81.z.number().int(),
  data: import_zod81.z.array(UserPresence),
  invisible: import_zod81.z.number().int(),
  offline: import_zod81.z.number().int(),
  online: import_zod81.z.number().int()
});

// src/generated-public/endpoints/Presence$.ts
var Presence$ = class {
  // @ts-ignore
  // prettier-ignore
  constructor(axiosInstance, namespace, useSchemaValidation = true) {
    this.axiosInstance = axiosInstance;
    this.namespace = namespace;
    this.useSchemaValidation = useSchemaValidation;
  }
  /**
   * Query users presence with given namespace and userIds.
   */
  getPresenceUsersPresence(queryParams) {
    const params = { ...queryParams };
    const url = "/lobby/v1/public/presence/namespaces/{namespace}/users/presence".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.get(url, { params });
    return import_sdk33.Validate.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      GetUsersPresenceResponse,
      "GetUsersPresenceResponse"
    );
  }
  /**
   * Query users presence with given namespace and userIds.
   */
  createPresenceUserPresence(data, queryParams) {
    const params = { ...queryParams };
    const url = "/lobby/v1/public/presence/namespaces/{namespace}/users/presence".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.post(url, data, { params });
    return import_sdk33.Validate.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      GetUsersPresenceResponse,
      "GetUsersPresenceResponse"
    );
  }
};

// src/generated-public/PresenceApi.ts
function PresenceApi(sdk, args) {
  const sdkAssembly = sdk.assembly();
  const namespace = args?.coreConfig?.namespace ?? sdkAssembly.coreConfig.namespace;
  const useSchemaValidation = args?.coreConfig?.useSchemaValidation ?? sdkAssembly.coreConfig.useSchemaValidation;
  let axiosInstance = sdkAssembly.axiosInstance;
  const requestConfigOverrides = args?.axiosConfig?.request;
  const baseURLOverride = args?.coreConfig?.baseURL;
  const interceptorsOverride = args?.axiosConfig?.interceptors ?? [];
  if (requestConfigOverrides || baseURLOverride || interceptorsOverride.length > 0) {
    const requestConfig = import_sdk34.ApiUtils.mergeAxiosConfigs(sdkAssembly.axiosInstance.defaults, {
      ...baseURLOverride ? { baseURL: baseURLOverride } : {},
      ...requestConfigOverrides
    });
    axiosInstance = import_sdk34.Network.create(requestConfig);
    for (const interceptor of interceptorsOverride) {
      if (interceptor.type === "request") {
        axiosInstance.interceptors.request.use(interceptor.onRequest, interceptor.onError);
      }
      if (interceptor.type === "response") {
        axiosInstance.interceptors.response.use(interceptor.onSuccess, interceptor.onError);
      }
    }
  }
  async function getPresenceUsersPresence(queryParams) {
    const $ = new Presence$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getPresenceUsersPresence(queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function createPresenceUserPresence(data, queryParams) {
    const $ = new Presence$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.createPresenceUserPresence(data, queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  return {
    /**
     * Query users presence with given namespace and userIds.
     */
    getPresenceUsersPresence,
    /**
     * Query users presence with given namespace and userIds.
     */
    createPresenceUserPresence
  };
}

// src/generated-public/queries/Presence.query.ts
var Key_Presence = /* @__PURE__ */ ((Key_Presence2) => {
  Key_Presence2["PresenceUsersPresence"] = "Lobby.Presence.PresenceUsersPresence";
  Key_Presence2["PresenceUserPresence"] = "Lobby.Presence.PresenceUserPresence";
  return Key_Presence2;
})(Key_Presence || {});
var usePresenceApi_GetPresenceUsersPresence = (sdk, input, options, callback) => {
  const queryFn = (sdk2, input2) => async () => {
    const response = await PresenceApi(sdk2, { coreConfig: input2.coreConfig, axiosConfig: input2.axiosConfig }).getPresenceUsersPresence(
      input2.queryParams
    );
    callback && callback(response);
    return response.data;
  };
  return (0, import_react_query17.useQuery)({
    queryKey: ["Lobby.Presence.PresenceUsersPresence" /* PresenceUsersPresence */, input],
    queryFn: queryFn(sdk, input),
    ...options
  });
};
var usePresenceApi_CreatePresenceUserPresenceMutation = (sdk, options, callback) => {
  const mutationFn = async (input) => {
    const response = await PresenceApi(sdk, { coreConfig: input.coreConfig, axiosConfig: input.axiosConfig }).createPresenceUserPresence(
      input.data,
      input.queryParams
    );
    callback && callback(response.data);
    return response.data;
  };
  return (0, import_react_query17.useMutation)({
    mutationKey: ["Lobby.Presence.PresenceUserPresence" /* PresenceUserPresence */],
    mutationFn,
    ...options
  });
};
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  Key_Admin,
  Key_AdminAdmin,
  Key_Blocks,
  Key_ConfigAdmin,
  Key_Friends,
  Key_FriendsAdmin,
  Key_LobbyOperations,
  Key_LobbyOperationsAdmin,
  Key_Notification,
  Key_NotificationAdmin,
  Key_Party,
  Key_PartyAdmin,
  Key_Player,
  Key_PlayerAdmin,
  Key_Presence,
  Key_ProfanityAdmin,
  Key_ThirdPartyAdmin,
  useAdminAdminApi_DeleteGlobalConfigurationMutation,
  useAdminAdminApi_GetGlobalConfigurations,
  useAdminAdminApi_UpdateGlobalConfigurationMutation,
  useAdminApi_CreateNotificationFreeformMutation,
  useAdminApi_CreateNotificationTemplateMutation,
  useAdminApi_CreateNotificationTemplatedMutation,
  useAdminApi_CreatePublishNotification_ByTemplateSlug_ByTemplateLanguageMutation,
  useAdminApi_DeleteLanguageNotification_ByTemplateSlug_ByTemplateLanguageMutation,
  useAdminApi_DeleteNotificationTemplate_ByTemplateSlugMutation,
  useAdminApi_GetLanguageNotification_ByTemplateSlug_ByTemplateLanguage,
  useAdminApi_GetNotificationTemplate_ByTemplateSlug,
  useAdminApi_GetNotificationTemplates,
  useAdminApi_UpdateLanguageNotification_ByTemplateSlug_ByTemplateLanguageMutation,
  useBlocksApi_PatchSyncMeBlockMutation,
  useConfigAdminApi_GetConfig,
  useConfigAdminApi_GetConfigExport,
  useConfigAdminApi_GetConfigLog,
  useConfigAdminApi_GetConfig_ByNamespace,
  useConfigAdminApi_PatchConfigLogMutation,
  useConfigAdminApi_UpdateConfigImportMutation,
  useConfigAdminApi_UpdateConfig_ByNamespaceMutation,
  useFriendsAdminApi_GetFriendUser_ByUserId,
  useFriendsAdminApi_GetIncomingFriend_ByUserId,
  useFriendsAdminApi_GetOfFriends_ByUserId,
  useFriendsAdminApi_GetOutgoingFriend_ByUserId,
  useFriendsApi_CreateAddBulkFriend_ByUserIdMutation,
  useFriendsApi_CreateDeleteBulkFriend_ByUserIdMutation,
  useFriendsApi_CreateFriendMeRequestAcceptMutation,
  useFriendsApi_CreateFriendMeRequestCancelMutation,
  useFriendsApi_CreateFriendMeRequestMutation,
  useFriendsApi_CreateFriendMeRequestRejectMutation,
  useFriendsApi_CreateFriendMeUnfriendMutation,
  useFriendsApi_GetFriendMeStatu_ByFriendId,
  useFriendsApi_GetFriendsMe,
  useFriendsApi_GetFriendsMeIncoming,
  useFriendsApi_GetFriendsMeIncomingTime,
  useFriendsApi_GetFriendsMeOutgoing,
  useFriendsApi_GetFriendsMeOutgoingTime,
  useFriendsApi_GetFriendsMePlatforms,
  useFriendsApi_PatchFriendSyncMeMutation,
  useLobbyOperationsAdminApi_UpdateAttributeParty_ByPartyIdMutation,
  useLobbyOperationsAdminApi_UpdateJoinParty_ByPartyId_ByUserIdMutation,
  useLobbyOperationsApi_GetMessages,
  useNotificationAdminApi_CreateFreeformNotifyNotification_ByPartyIdMutation,
  useNotificationAdminApi_CreateFreeformNotifyNotification_ByUserIdMutation,
  useNotificationAdminApi_CreateNotificationBulkUserFreeformNotifyMutation,
  useNotificationAdminApi_CreateNotificationFreeformNotifyMutation,
  useNotificationAdminApi_CreateNotificationTemplateMutation,
  useNotificationAdminApi_CreateNotificationTemplateNotifyMutation,
  useNotificationAdminApi_CreateNotificationTopicMutation,
  useNotificationAdminApi_CreatePublishNotification_ByTemplateSlug_ByTemplateLanguageMutation,
  useNotificationAdminApi_CreateTemplateNotifyNotification_ByPartyIdMutation,
  useNotificationAdminApi_CreateTemplateNotifyNotification_ByUserIdMutation,
  useNotificationAdminApi_DeleteLanguageNotification_ByTemplateSlug_ByTemplateLanguageMutation,
  useNotificationAdminApi_DeleteNotificationTemplate_ByTemplateSlugMutation,
  useNotificationAdminApi_DeleteNotificationTopic_ByTopicNameMutation,
  useNotificationAdminApi_GetLanguageNotification_ByTemplateSlug_ByTemplateLanguage,
  useNotificationAdminApi_GetNotificationTemplate_ByTemplateSlug,
  useNotificationAdminApi_GetNotificationTemplates,
  useNotificationAdminApi_GetNotificationTopic_ByTopicName,
  useNotificationAdminApi_GetNotificationTopics,
  useNotificationAdminApi_UpdateLanguageNotification_ByTemplateSlug_ByTemplateLanguageMutation,
  useNotificationAdminApi_UpdateNotificationTopic_ByTopicNameMutation,
  useNotificationApi_CreateFreeformNotification_ByUserIdMutation,
  useNotificationApi_CreateNotificationTopicMutation,
  useNotificationApi_CreateTemplatedNotification_ByUserIdMutation,
  useNotificationApi_DeleteNotificationTopic_ByTopicMutation,
  useNotificationApi_GetNotificationMe,
  useNotificationApi_GetNotificationTopic_ByTopic,
  useNotificationApi_GetNotificationTopics,
  useNotificationApi_UpdateNotificationTopic_ByTopicMutation,
  usePartyAdminApi_GetPartyParty_ByPartyId,
  usePartyAdminApi_GetParty_ByUserId,
  usePartyApi_GetPartyParty_ByPartyId,
  usePartyApi_UpdateAttributeParty_ByPartyIdMutation,
  usePartyApi_UpdateLimitParty_ByPartyIdMutation,
  usePlayerAdminApi_CreateBulkBlockPlayer_ByUserIdMutation,
  usePlayerAdminApi_DeleteBulkUnblockPlayer_ByUserIdMutation,
  usePlayerAdminApi_FetchPlayerUserBulkBlocked,
  usePlayerAdminApi_GetAttributePlayer_ByUserId_ByAttribute,
  usePlayerAdminApi_GetAttributesPlayer_ByUserId,
  usePlayerAdminApi_GetBlockedByPlayer_ByUserId,
  usePlayerAdminApi_GetBlockedPlayer_ByUserId,
  usePlayerAdminApi_GetPlayerCcu,
  usePlayerAdminApi_UpdateAttributePlayer_ByUserIdMutation,
  usePlayerApi_CreatePlayerUserMeBlockMutation,
  usePlayerApi_CreatePlayerUserMeUnblockMutation,
  usePlayerApi_GetPlayerUsersMeBlocked,
  usePlayerApi_GetPlayerUsersMeBlockedBy,
  usePresenceApi_CreatePresenceUserPresenceMutation,
  usePresenceApi_GetPresenceUsersPresence,
  useProfanityAdminApi_CreateFilterBulkFileProfanity_ByListMutation,
  useProfanityAdminApi_CreateFilterBulkProfanity_ByListMutation,
  useProfanityAdminApi_CreateFilterDeleteProfanity_ByListMutation,
  useProfanityAdminApi_CreateFilterProfanity_ByListMutation,
  useProfanityAdminApi_CreateProfanityListMutation,
  useProfanityAdminApi_DeleteProfanityList_ByListMutation,
  useProfanityAdminApi_FetchProfanityFilterDebug,
  useProfanityAdminApi_FetchProfanityVerify,
  useProfanityAdminApi_GetFiltersProfanity_ByList,
  useProfanityAdminApi_GetProfanityLists,
  useProfanityAdminApi_GetProfanityRule,
  useProfanityAdminApi_UpdateProfanityList_ByListMutation,
  useProfanityAdminApi_UpdateProfanityRuleMutation,
  useThirdPartyAdminApi_CreateThirdpartyConfigSteamMutation,
  useThirdPartyAdminApi_DeleteThirdpartyConfigSteamMutation,
  useThirdPartyAdminApi_GetThirdpartyConfigSteam,
  useThirdPartyAdminApi_UpdateThirdpartyConfigSteamMutation
});

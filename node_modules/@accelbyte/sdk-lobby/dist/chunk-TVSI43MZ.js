// src/generated-definitions/GlobalConfiguration.ts
import { z } from "zod";
var GlobalConfiguration = z.object({
  regionRetryMapping: z.record(z.array(z.string())),
  regionURLMapping: z.array(z.string()),
  testGameMode: z.string(),
  testRegionURLMapping: z.array(z.string()),
  testTargetUserIDs: z.array(z.string()),
  updatedAt: z.string()
});

// src/generated-admin/endpoints/AdminAdmin$.ts
import { Validate } from "@accelbyte/sdk";
import { z as z2 } from "zod";
var AdminAdmin$ = class {
  // @ts-ignore
  // prettier-ignore
  constructor(axiosInstance, namespace, useSchemaValidation = true) {
    this.axiosInstance = axiosInstance;
    this.namespace = namespace;
    this.useSchemaValidation = useSchemaValidation;
  }
  /**
   * Delete of global configuration data.
   */
  deleteGlobalConfiguration() {
    const params = {};
    const url = "/lobby/v1/admin/global-configurations";
    const resultPromise = this.axiosInstance.delete(url, { params });
    return Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, z2.unknown(), "z.unknown()");
  }
  /**
   * Get dsmc global configuration.
   */
  getGlobalConfigurations() {
    const params = {};
    const url = "/lobby/v1/admin/global-configurations";
    const resultPromise = this.axiosInstance.get(url, { params });
    return Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, GlobalConfiguration, "GlobalConfiguration");
  }
  /**
   * Upsert global configuration data.
   */
  updateGlobalConfiguration(data) {
    const params = {};
    const url = "/lobby/v1/admin/global-configurations";
    const resultPromise = this.axiosInstance.put(url, data, { params });
    return Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, GlobalConfiguration, "GlobalConfiguration");
  }
};

// src/generated-admin/AdminAdminApi.ts
import { ApiUtils, Network } from "@accelbyte/sdk";
function AdminAdminApi(sdk, args) {
  const sdkAssembly = sdk.assembly();
  const namespace = args?.coreConfig?.namespace ?? sdkAssembly.coreConfig.namespace;
  const useSchemaValidation = args?.coreConfig?.useSchemaValidation ?? sdkAssembly.coreConfig.useSchemaValidation;
  let axiosInstance = sdkAssembly.axiosInstance;
  const requestConfigOverrides = args?.axiosConfig?.request;
  const baseURLOverride = args?.coreConfig?.baseURL;
  const interceptorsOverride = args?.axiosConfig?.interceptors ?? [];
  if (requestConfigOverrides || baseURLOverride || interceptorsOverride.length > 0) {
    const requestConfig = ApiUtils.mergeAxiosConfigs(sdkAssembly.axiosInstance.defaults, {
      ...baseURLOverride ? { baseURL: baseURLOverride } : {},
      ...requestConfigOverrides
    });
    axiosInstance = Network.create(requestConfig);
    for (const interceptor of interceptorsOverride) {
      if (interceptor.type === "request") {
        axiosInstance.interceptors.request.use(interceptor.onRequest, interceptor.onError);
      }
      if (interceptor.type === "response") {
        axiosInstance.interceptors.response.use(interceptor.onSuccess, interceptor.onError);
      }
    }
  }
  async function deleteGlobalConfiguration() {
    const $ = new AdminAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.deleteGlobalConfiguration();
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getGlobalConfigurations() {
    const $ = new AdminAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getGlobalConfigurations();
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function updateGlobalConfiguration(data) {
    const $ = new AdminAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.updateGlobalConfiguration(data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  return {
    /**
     * Delete of global configuration data.
     */
    deleteGlobalConfiguration,
    /**
     * Get dsmc global configuration.
     */
    getGlobalConfigurations,
    /**
     * Upsert global configuration data.
     */
    updateGlobalConfiguration
  };
}

// src/generated-definitions/Config.ts
import { z as z3 } from "zod";
var Config = z3.object({
  allowInviteNonConnectedUser: z3.boolean().nullish(),
  allowJoinPartyDuringMatchmaking: z3.boolean().nullish(),
  autoKickOnDisconnect: z3.boolean().nullish(),
  autoKickOnDisconnectDelay: z3.number().int().nullish(),
  cancelTicketOnDisconnect: z3.boolean().nullish(),
  chatRateLimitBurst: z3.number().int().nullish(),
  chatRateLimitDuration: z3.number().int().nullish(),
  concurrentUsersLimit: z3.number().int().nullish(),
  disableInvitationOnJoinParty: z3.boolean().nullish(),
  disableRemoveSocketOldConnection: z3.boolean().nullish(),
  enableChat: z3.boolean().nullish(),
  entitlementCheck: z3.boolean().nullish(),
  entitlementItemID: z3.string().nullish(),
  generalRateLimitBurst: z3.number().int().nullish(),
  generalRateLimitDuration: z3.number().int().nullish(),
  keepPresenceActivityOnDisconnect: z3.boolean().nullish(),
  maxDSWaitTime: z3.number().int(),
  maxFriendsLimit: z3.number().int().nullish(),
  maxPartyMember: z3.number().int().nullish(),
  namespace: z3.string().nullish(),
  profanityFilter: z3.boolean().nullish(),
  readyConsentTimeout: z3.number().int().nullish(),
  unregisterDelay: z3.number().int()
});

// src/generated-definitions/ConfigList.ts
import { z as z4 } from "zod";
var ConfigList = z4.object({ configs: z4.array(Config) });

// src/generated-definitions/ConfigReq.ts
import { z as z5 } from "zod";
var ConfigReq = z5.object({
  allowInviteNonConnectedUser: z5.boolean().nullish(),
  allowJoinPartyDuringMatchmaking: z5.boolean().nullish(),
  autoKickOnDisconnect: z5.boolean().nullish(),
  autoKickOnDisconnectDelay: z5.number().int().nullish(),
  cancelTicketOnDisconnect: z5.boolean().nullish(),
  chatRateLimitBurst: z5.number().int().nullish(),
  chatRateLimitDuration: z5.number().int().nullish(),
  concurrentUsersLimit: z5.number().int().nullish(),
  disableInvitationOnJoinParty: z5.boolean().nullish(),
  enableChat: z5.boolean().nullish(),
  entitlementCheck: z5.boolean().nullish(),
  entitlementItemID: z5.string().nullish(),
  generalRateLimitBurst: z5.number().int().nullish(),
  generalRateLimitDuration: z5.number().int().nullish(),
  keepPresenceActivityOnDisconnect: z5.boolean().nullish(),
  maxDSWaitTime: z5.number().int().nullish(),
  maxFriendsLimit: z5.number().int().nullish(),
  maxPartyMember: z5.number().int().nullish(),
  profanityFilter: z5.boolean().nullish(),
  readyConsentTimeout: z5.number().int().nullish(),
  unregisterDelay: z5.number().int().nullish()
});

// src/generated-definitions/Configuration.ts
import { z as z6 } from "zod";
var Configuration = z6.object({
  logLevel: z6.enum(["debug", "error", "fatal", "info", "panic", "trace", "warning"]).nullish(),
  logLevelDB: z6.enum(["debug", "error", "fatal", "info", "panic", "trace", "warning"]).nullish(),
  slowQueryThreshold: z6.number().int().nullish(),
  socketLogEnabled: z6.boolean().nullish()
});

// src/generated-definitions/ImportConfigResponse.ts
import { z as z7 } from "zod";
var ImportConfigResponse = z7.object({
  failedConfigs: z7.array(z7.string()),
  ignoredConfigs: z7.array(z7.string()),
  newConfigs: z7.array(z7.string()),
  replacedConfigs: z7.array(z7.string())
});

// src/generated-admin/endpoints/ConfigAdmin$.ts
import { Validate as Validate2 } from "@accelbyte/sdk";
import { z as z8 } from "zod";
var ConfigAdmin$ = class {
  // @ts-ignore
  // prettier-ignore
  constructor(axiosInstance, namespace, useSchemaValidation = true) {
    this.axiosInstance = axiosInstance;
    this.namespace = namespace;
    this.useSchemaValidation = useSchemaValidation;
  }
  /**
   * Get lobby config of all namespaces.&lt;br&gt;default MaxDSWaitTime is 120 (second)
   */
  getConfig() {
    const params = {};
    const url = "/lobby/v1/admin/config";
    const resultPromise = this.axiosInstance.get(url, { params });
    return Validate2.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, ConfigList, "ConfigList");
  }
  /**
   *  Get Log Configuration logLevel use for logging in service, the value can use is trace|debug|info|warning|error|fatal|panic socketLogEnabled is use for enable socket log logLevelDB use for logging in DB, the value can use is trace|debug|info|warning|error|fatal|panic slowQueryThreshold use for logging slow threshold in time measure is nano second
   */
  getConfigLog() {
    const params = {};
    const url = "/lobby/v1/admin/config/log";
    const resultPromise = this.axiosInstance.get(url, { params });
    return Validate2.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, Configuration, "Configuration");
  }
  /**
   *  Update Log Configuration logLevel use for logging in service, the value can use is trace|debug|info|warning|error|fatal|panic socketLogEnabled is use for enable socket log logLevelDB use for logging in DB, the value can use is trace|debug|info|warning|error|fatal|panic slowQueryThreshold use for logging slow threshold in time measure is nano second
   */
  patchConfigLog(data) {
    const params = {};
    const url = "/lobby/v1/admin/config/log";
    const resultPromise = this.axiosInstance.patch(url, data, { params });
    return Validate2.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, Configuration, "Configuration");
  }
  /**
   * Get lobby config of a namespace.&lt;br&gt;default MaxDSWaitTime is 120 (second)
   */
  getConfig_ByNamespace() {
    const params = {};
    const url = "/lobby/v1/admin/config/namespaces/{namespace}".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.get(url, { params });
    return Validate2.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, ConfigReq, "ConfigReq");
  }
  /**
   * Update lobby config of a namespace.&lt;br&gt;MaxDSWaitTime value is cannot less than 1, if null it will use default value in 120 (second)
   */
  updateConfig_ByNamespace(data) {
    const params = {};
    const url = "/lobby/v1/admin/config/namespaces/{namespace}".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.put(url, data, { params });
    return Validate2.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, ConfigReq, "ConfigReq");
  }
  /**
   *  Export lobby configuration to a json file. The file can then be imported from the /import endpoint. JSON Schema of the exported file: { &#34;required&#34;: [ &#34;namespace&#34;, &#34;entitlementItemID&#34;, &#34;chatRateLimitDuration&#34;, &#34;unregisterDelay&#34;, &#34;generalRateLimitDuration&#34;, &#34;autoKickOnDisconnectDelay&#34;, &#34;chatRateLimitBurst&#34;, &#34;generalRateLimitBurst&#34;, &#34;maxPartyMember&#34;, &#34;autoKickOnDisconnect&#34;, &#34;profanityFilter&#34;, &#34;enableChat&#34;, &#34;entitlementCheck&#34;, &#34;cancelTicketOnDisconnect&#34;, &#34;concurrentUsersLimit&#34;, &#34;readyConsentTimeout&#34;, &#34;disableInvitationOnJoinParty&#34;, &#34;allowJoinPartyDuringMatchmaking&#34;, &#34;allowInviteNonConnectedUser&#34;, &#34;keepPresenceActivityOnDisconnect&#34;, &#34;maxDSWaitTime&#34;, &#34;maxFriendsLimit&#34; ], &#34;properties&#34;: { &#34;allowInviteNonConnectedUser&#34;: { &#34;type&#34;: &#34;boolean&#34; }, &#34;allowJoinPartyDuringMatchmaking&#34;: { &#34;type&#34;: &#34;boolean&#34; }, &#34;autoKickOnDisconnect&#34;: { &#34;type&#34;: &#34;boolean&#34; }, &#34;autoKickOnDisconnectDelay&#34;: { &#34;type&#34;: &#34;integer&#34;, &#34;format&#34;: &#34;int64&#34; }, &#34;cancelTicketOnDisconnect&#34;: { &#34;type&#34;: &#34;boolean&#34; }, &#34;chatRateLimitBurst&#34;: { &#34;type&#34;: &#34;integer&#34;, &#34;format&#34;: &#34;int32&#34; }, &#34;chatRateLimitDuration&#34;: { &#34;type&#34;: &#34;integer&#34;, &#34;format&#34;: &#34;int64&#34; }, &#34;concurrentUsersLimit&#34;: { &#34;type&#34;: &#34;integer&#34;, &#34;format&#34;: &#34;int32&#34; }, &#34;disableInvitationOnJoinParty&#34;: { &#34;type&#34;: &#34;boolean&#34; }, &#34;enableChat&#34;: { &#34;type&#34;: &#34;boolean&#34; }, &#34;entitlementCheck&#34;: { &#34;type&#34;: &#34;boolean&#34; }, &#34;entitlementItemID&#34;: { &#34;type&#34;: &#34;string&#34; }, &#34;generalRateLimitBurst&#34;: { &#34;type&#34;: &#34;integer&#34;, &#34;format&#34;: &#34;int32&#34; }, &#34;generalRateLimitDuration&#34;: { &#34;type&#34;: &#34;integer&#34;, &#34;format&#34;: &#34;int64&#34; }, &#34;keepPresenceActivityOnDisconnect&#34;: { &#34;type&#34;: &#34;boolean&#34; }, &#34;maxDSWaitTime&#34;: { &#34;type&#34;: &#34;integer&#34;, &#34;format&#34;: &#34;int64&#34; }, &#34;maxFriendsLimit&#34;: { &#34;type&#34;: &#34;integer&#34;, &#34;format&#34;: &#34;int32&#34; }, &#34;maxPartyMember&#34;: { &#34;type&#34;: &#34;integer&#34;, &#34;format&#34;: &#34;int32&#34; }, &#34;namespace&#34;: { &#34;type&#34;: &#34;string&#34; }, &#34;profanityFilter&#34;: { &#34;type&#34;: &#34;boolean&#34; }, &#34;readyConsentTimeout&#34;: { &#34;type&#34;: &#34;integer&#34;, &#34;format&#34;: &#34;int64&#34; }, &#34;unregisterDelay&#34;: { &#34;type&#34;: &#34;integer&#34;, &#34;format&#34;: &#34;int64&#34; } } }
   */
  getConfigExport() {
    const params = {};
    const url = "/lobby/v1/admin/config/namespaces/{namespace}/export".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.get(url, { params });
    return Validate2.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, z8.unknown(), "z.unknown()");
  }
  /**
   *  Import config configuration from file. The existing configuration will be replaced. The json file to import can be obtained from the /export endpoint. MaxDSWaitTime value is cannot less than 1, if null it will use default value in 120 (second)
   */
  updateConfigImport(data) {
    const params = {};
    const url = "/lobby/v1/admin/config/namespaces/{namespace}/import".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.post(url, data, { params });
    return Validate2.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, ImportConfigResponse, "ImportConfigResponse");
  }
};

// src/generated-admin/ConfigAdminApi.ts
import { ApiUtils as ApiUtils2, Network as Network2 } from "@accelbyte/sdk";
function ConfigAdminApi(sdk, args) {
  const sdkAssembly = sdk.assembly();
  const namespace = args?.coreConfig?.namespace ?? sdkAssembly.coreConfig.namespace;
  const useSchemaValidation = args?.coreConfig?.useSchemaValidation ?? sdkAssembly.coreConfig.useSchemaValidation;
  let axiosInstance = sdkAssembly.axiosInstance;
  const requestConfigOverrides = args?.axiosConfig?.request;
  const baseURLOverride = args?.coreConfig?.baseURL;
  const interceptorsOverride = args?.axiosConfig?.interceptors ?? [];
  if (requestConfigOverrides || baseURLOverride || interceptorsOverride.length > 0) {
    const requestConfig = ApiUtils2.mergeAxiosConfigs(sdkAssembly.axiosInstance.defaults, {
      ...baseURLOverride ? { baseURL: baseURLOverride } : {},
      ...requestConfigOverrides
    });
    axiosInstance = Network2.create(requestConfig);
    for (const interceptor of interceptorsOverride) {
      if (interceptor.type === "request") {
        axiosInstance.interceptors.request.use(interceptor.onRequest, interceptor.onError);
      }
      if (interceptor.type === "response") {
        axiosInstance.interceptors.response.use(interceptor.onSuccess, interceptor.onError);
      }
    }
  }
  async function getConfig() {
    const $ = new ConfigAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getConfig();
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getConfigLog() {
    const $ = new ConfigAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getConfigLog();
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function patchConfigLog(data) {
    const $ = new ConfigAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.patchConfigLog(data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getConfig_ByNamespace() {
    const $ = new ConfigAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getConfig_ByNamespace();
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function updateConfig_ByNamespace(data) {
    const $ = new ConfigAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.updateConfig_ByNamespace(data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getConfigExport() {
    const $ = new ConfigAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getConfigExport();
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function updateConfigImport(data) {
    const $ = new ConfigAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.updateConfigImport(data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  return {
    /**
     * Get lobby config of all namespaces.&lt;br&gt;default MaxDSWaitTime is 120 (second)
     */
    getConfig,
    /**
     *  Get Log Configuration logLevel use for logging in service, the value can use is trace|debug|info|warning|error|fatal|panic socketLogEnabled is use for enable socket log logLevelDB use for logging in DB, the value can use is trace|debug|info|warning|error|fatal|panic slowQueryThreshold use for logging slow threshold in time measure is nano second
     */
    getConfigLog,
    /**
     *  Update Log Configuration logLevel use for logging in service, the value can use is trace|debug|info|warning|error|fatal|panic socketLogEnabled is use for enable socket log logLevelDB use for logging in DB, the value can use is trace|debug|info|warning|error|fatal|panic slowQueryThreshold use for logging slow threshold in time measure is nano second
     */
    patchConfigLog,
    /**
     * Get lobby config of a namespace.&lt;br&gt;default MaxDSWaitTime is 120 (second)
     */
    getConfig_ByNamespace,
    /**
     * Update lobby config of a namespace.&lt;br&gt;MaxDSWaitTime value is cannot less than 1, if null it will use default value in 120 (second)
     */
    updateConfig_ByNamespace,
    /**
     *  Export lobby configuration to a json file. The file can then be imported from the /import endpoint. JSON Schema of the exported file: { &#34;required&#34;: [ &#34;namespace&#34;, &#34;entitlementItemID&#34;, &#34;chatRateLimitDuration&#34;, &#34;unregisterDelay&#34;, &#34;generalRateLimitDuration&#34;, &#34;autoKickOnDisconnectDelay&#34;, &#34;chatRateLimitBurst&#34;, &#34;generalRateLimitBurst&#34;, &#34;maxPartyMember&#34;, &#34;autoKickOnDisconnect&#34;, &#34;profanityFilter&#34;, &#34;enableChat&#34;, &#34;entitlementCheck&#34;, &#34;cancelTicketOnDisconnect&#34;, &#34;concurrentUsersLimit&#34;, &#34;readyConsentTimeout&#34;, &#34;disableInvitationOnJoinParty&#34;, &#34;allowJoinPartyDuringMatchmaking&#34;, &#34;allowInviteNonConnectedUser&#34;, &#34;keepPresenceActivityOnDisconnect&#34;, &#34;maxDSWaitTime&#34;, &#34;maxFriendsLimit&#34; ], &#34;properties&#34;: { &#34;allowInviteNonConnectedUser&#34;: { &#34;type&#34;: &#34;boolean&#34; }, &#34;allowJoinPartyDuringMatchmaking&#34;: { &#34;type&#34;: &#34;boolean&#34; }, &#34;autoKickOnDisconnect&#34;: { &#34;type&#34;: &#34;boolean&#34; }, &#34;autoKickOnDisconnectDelay&#34;: { &#34;type&#34;: &#34;integer&#34;, &#34;format&#34;: &#34;int64&#34; }, &#34;cancelTicketOnDisconnect&#34;: { &#34;type&#34;: &#34;boolean&#34; }, &#34;chatRateLimitBurst&#34;: { &#34;type&#34;: &#34;integer&#34;, &#34;format&#34;: &#34;int32&#34; }, &#34;chatRateLimitDuration&#34;: { &#34;type&#34;: &#34;integer&#34;, &#34;format&#34;: &#34;int64&#34; }, &#34;concurrentUsersLimit&#34;: { &#34;type&#34;: &#34;integer&#34;, &#34;format&#34;: &#34;int32&#34; }, &#34;disableInvitationOnJoinParty&#34;: { &#34;type&#34;: &#34;boolean&#34; }, &#34;enableChat&#34;: { &#34;type&#34;: &#34;boolean&#34; }, &#34;entitlementCheck&#34;: { &#34;type&#34;: &#34;boolean&#34; }, &#34;entitlementItemID&#34;: { &#34;type&#34;: &#34;string&#34; }, &#34;generalRateLimitBurst&#34;: { &#34;type&#34;: &#34;integer&#34;, &#34;format&#34;: &#34;int32&#34; }, &#34;generalRateLimitDuration&#34;: { &#34;type&#34;: &#34;integer&#34;, &#34;format&#34;: &#34;int64&#34; }, &#34;keepPresenceActivityOnDisconnect&#34;: { &#34;type&#34;: &#34;boolean&#34; }, &#34;maxDSWaitTime&#34;: { &#34;type&#34;: &#34;integer&#34;, &#34;format&#34;: &#34;int64&#34; }, &#34;maxFriendsLimit&#34;: { &#34;type&#34;: &#34;integer&#34;, &#34;format&#34;: &#34;int32&#34; }, &#34;maxPartyMember&#34;: { &#34;type&#34;: &#34;integer&#34;, &#34;format&#34;: &#34;int32&#34; }, &#34;namespace&#34;: { &#34;type&#34;: &#34;string&#34; }, &#34;profanityFilter&#34;: { &#34;type&#34;: &#34;boolean&#34; }, &#34;readyConsentTimeout&#34;: { &#34;type&#34;: &#34;integer&#34;, &#34;format&#34;: &#34;int64&#34; }, &#34;unregisterDelay&#34;: { &#34;type&#34;: &#34;integer&#34;, &#34;format&#34;: &#34;int64&#34; } } }
     */
    getConfigExport,
    /**
     *  Import config configuration from file. The existing configuration will be replaced. The json file to import can be obtained from the /export endpoint. MaxDSWaitTime value is cannot less than 1, if null it will use default value in 120 (second)
     */
    updateConfigImport
  };
}

// src/generated-definitions/FriendshipConnection.ts
import { z as z9 } from "zod";
var FriendshipConnection = z9.object({ friendId: z9.string(), subjectId: z9.string() });

// src/generated-definitions/Pagination.ts
import { z as z10 } from "zod";
var Pagination = z10.object({ first: z10.string(), last: z10.string(), next: z10.string(), previous: z10.string() });

// src/generated-definitions/FriendshipConnectionResponse.ts
import { z as z11 } from "zod";
var FriendshipConnectionResponse = z11.object({ data: z11.array(FriendshipConnection), paging: Pagination });

// src/generated-definitions/FriendWithPlatform.ts
import { z as z12 } from "zod";
var FriendWithPlatform = z12.object({ platformId: z12.string(), userId: z12.string() });

// src/generated-definitions/GetFriendsResponse.ts
import { z as z13 } from "zod";
var GetFriendsResponse = z13.object({
  friendIDs: z13.array(z13.string()),
  friends: z13.array(FriendWithPlatform).nullish(),
  friendsSinceTimes: z13.array(z13.string()),
  paging: Pagination
});

// src/generated-definitions/IncomingFriendsWithTimeData.ts
import { z as z14 } from "zod";
var IncomingFriendsWithTimeData = z14.object({ friendId: z14.string(), requestedAt: z14.string() });

// src/generated-definitions/LoadIncomingFriendsWithTimeResponse.ts
import { z as z15 } from "zod";
var LoadIncomingFriendsWithTimeResponse = z15.object({ data: z15.array(IncomingFriendsWithTimeData), paging: Pagination });

// src/generated-definitions/OutgoingFriendsWithTimeData.ts
import { z as z16 } from "zod";
var OutgoingFriendsWithTimeData = z16.object({ friendId: z16.string(), requestedAt: z16.string() });

// src/generated-definitions/LoadOutgoingFriendsWithTimeResponse.ts
import { z as z17 } from "zod";
var LoadOutgoingFriendsWithTimeResponse = z17.object({ data: z17.array(OutgoingFriendsWithTimeData), paging: Pagination });

// src/generated-admin/endpoints/FriendsAdmin$.ts
import { Validate as Validate3 } from "@accelbyte/sdk";
var FriendsAdmin$ = class {
  // @ts-ignore
  // prettier-ignore
  constructor(axiosInstance, namespace, useSchemaValidation = true) {
    this.axiosInstance = axiosInstance;
    this.namespace = namespace;
    this.useSchemaValidation = useSchemaValidation;
  }
  /**
   * Get list of friends in a namespace.
   */
  getFriendUser_ByUserId(userId, queryParams) {
    const params = { limit: 25, ...queryParams };
    const url = "/lobby/v1/admin/friend/namespaces/{namespace}/users/{userId}".replace("{namespace}", this.namespace).replace("{userId}", userId);
    const resultPromise = this.axiosInstance.get(url, { params });
    return Validate3.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, GetFriendsResponse, "GetFriendsResponse");
  }
  /**
   * Get list of incoming friend requests.
   */
  getIncomingFriend_ByUserId(userId, queryParams) {
    const params = { limit: 25, ...queryParams };
    const url = "/lobby/v1/admin/friend/namespaces/{namespace}/users/{userId}/incoming".replace("{namespace}", this.namespace).replace("{userId}", userId);
    const resultPromise = this.axiosInstance.get(url, { params });
    return Validate3.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      LoadIncomingFriendsWithTimeResponse,
      "LoadIncomingFriendsWithTimeResponse"
    );
  }
  /**
   * Get list of outgoing friend requests in a namespace.
   */
  getOutgoingFriend_ByUserId(userId, queryParams) {
    const params = { limit: 25, ...queryParams };
    const url = "/lobby/v1/admin/friend/namespaces/{namespace}/users/{userId}/outgoing".replace("{namespace}", this.namespace).replace("{userId}", userId);
    const resultPromise = this.axiosInstance.get(url, { params });
    return Validate3.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      LoadOutgoingFriendsWithTimeResponse,
      "LoadOutgoingFriendsWithTimeResponse"
    );
  }
  /**
   * Load list friends and friends of friends in a namespace. Response subjectId will be different with requested userId if the user is not directly friend
   */
  getOfFriends_ByUserId(userId, queryParams) {
    const params = { limit: 25, ...queryParams };
    const url = "/lobby/v1/admin/friend/namespaces/{namespace}/users/{userId}/of-friends".replace("{namespace}", this.namespace).replace("{userId}", userId);
    const resultPromise = this.axiosInstance.get(url, { params });
    return Validate3.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      FriendshipConnectionResponse,
      "FriendshipConnectionResponse"
    );
  }
};

// src/generated-definitions/PartyData.ts
import { z as z18 } from "zod";
var PartyData = z18.object({
  custom_attribute: z18.record(z18.any()),
  invitees: z18.array(z18.string()),
  leader: z18.string(),
  members: z18.array(z18.string()),
  namespace: z18.string(),
  partyId: z18.string(),
  updatedAt: z18.number().int()
});

// src/generated-admin/endpoints/LobbyOperationsAdmin$.ts
import { Validate as Validate4 } from "@accelbyte/sdk";
import { z as z19 } from "zod";
var LobbyOperationsAdmin$ = class {
  // @ts-ignore
  // prettier-ignore
  constructor(axiosInstance, namespace, useSchemaValidation = true) {
    this.axiosInstance = axiosInstance;
    this.namespace = namespace;
    this.useSchemaValidation = useSchemaValidation;
  }
  /**
   * Update party attributes in a namespace.
   */
  updateAttributeParty_ByPartyId(partyId, data) {
    const params = {};
    const url = "/lobby/v1/admin/party/namespaces/{namespace}/parties/{partyId}/attributes".replace("{namespace}", this.namespace).replace("{partyId}", partyId);
    const resultPromise = this.axiosInstance.put(url, data, { params });
    return Validate4.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, PartyData, "PartyData");
  }
  /**
   * Admin join a player into a party.
   */
  updateJoinParty_ByPartyId_ByUserId(partyId, userId) {
    const params = {};
    const url = "/lobby/v1/admin/party/namespaces/{namespace}/parties/{partyId}/join/{userId}".replace("{namespace}", this.namespace).replace("{partyId}", partyId).replace("{userId}", userId);
    const resultPromise = this.axiosInstance.post(url, null, { params });
    return Validate4.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, z19.unknown(), "z.unknown()");
  }
};

// src/generated-definitions/TemplateContent.ts
import { z as z20 } from "zod";
var TemplateContent = z20.object({ draft: z20.string(), published: z20.string() });

// src/generated-definitions/Localization.ts
import { z as z21 } from "zod";
var Localization = z21.object({
  lastDraftAt: z21.string(),
  lastPublishedAt: z21.string(),
  templateContent: TemplateContent,
  templateLanguage: z21.string()
});

// src/generated-definitions/GetAllNotificationTemplateSlugResp.ts
import { z as z22 } from "zod";
var GetAllNotificationTemplateSlugResp = z22.object({ data: z22.array(Localization), paging: Pagination });

// src/generated-definitions/NotificationTopicResponseV1.ts
import { z as z23 } from "zod";
var NotificationTopicResponseV1 = z23.object({
  createdAt: z23.number().int(),
  description: z23.string(),
  namespace: z23.string(),
  topicName: z23.string()
});

// src/generated-definitions/GetAllNotificationTopicsResponse.ts
import { z as z24 } from "zod";
var GetAllNotificationTopicsResponse = z24.object({ data: z24.array(NotificationTopicResponseV1), paging: Pagination });

// src/generated-definitions/NotificationTemplateResponse.ts
import { z as z25 } from "zod";
var NotificationTemplateResponse = z25.object({ templateLocalizations: z25.array(Localization), templateSlug: z25.string() });

// src/generated-definitions/NotificationTemplateResponseArray.ts
import { z as z26 } from "zod";
var NotificationTemplateResponseArray = z26.array(NotificationTemplateResponse);

// src/generated-admin/endpoints/NotificationAdmin$.ts
import { Validate as Validate5 } from "@accelbyte/sdk";
import { z as z27 } from "zod";
var NotificationAdmin$ = class {
  // @ts-ignore
  // prettier-ignore
  constructor(axiosInstance, namespace, useSchemaValidation = true) {
    this.axiosInstance = axiosInstance;
    this.namespace = namespace;
    this.useSchemaValidation = useSchemaValidation;
  }
  /**
   * Get topic by namespace.&lt;br/&gt; Action Code: 50213
   */
  getNotificationTopics(queryParams) {
    const params = { ...queryParams };
    const url = "/lobby/v1/admin/notification/namespaces/{namespace}/topics".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.get(url, { params });
    return Validate5.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      GetAllNotificationTopicsResponse,
      "GetAllNotificationTopicsResponse"
    );
  }
  /**
   * Create new notification topic. &lt;br&gt;topic should be alphabets, no special char except underscore, uppercase and no spacing. for example: TOPIC_TEST. Already existing topic can not be created&lt;br/&gt; Action Code: 50214
   */
  createNotificationTopic(data) {
    const params = {};
    const url = "/lobby/v1/admin/notification/namespaces/{namespace}/topics".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.post(url, data, { params });
    return Validate5.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, z27.unknown(), "z.unknown()");
  }
  /**
   * Get all templates in a namespace&lt;br&gt; Action Code: 50203
   */
  getNotificationTemplates() {
    const params = {};
    const url = "/lobby/v1/admin/notification/namespaces/{namespace}/templates".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.get(url, { params });
    return Validate5.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      NotificationTemplateResponseArray,
      "NotificationTemplateResponseArray"
    );
  }
  /**
   * Create new notification template. Include handlebars {{key}} for replaceable contexts. The key inside handlebars will be the key to be replaced when sending notification. Already existing template with the same slug and language can not be created. &lt;br&gt;Check model description for detailed input restrictions.&lt;br&gt; Action Code: 50204
   */
  createNotificationTemplate(data) {
    const params = {};
    const url = "/lobby/v1/admin/notification/namespaces/{namespace}/templates".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.post(url, data, { params });
    return Validate5.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, z27.unknown(), "z.unknown()");
  }
  /**
   * Sends notification to all connected users in a namespace.&lt;br&gt; Action Code: 50201
   */
  createNotificationFreeformNotify(data) {
    const params = {};
    const url = "/lobby/v1/admin/notification/namespaces/{namespace}/freeform/notify".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.post(url, data, { params });
    return Validate5.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, z27.unknown(), "z.unknown()");
  }
  /**
   * Sends notification to all connected users in a namespace with predefined template. &lt;br&gt;In the request body, specify which template slug (template identifier) to use and the template language. &lt;br&gt;NotificationTemplate context is the key-value pair defining the value of each handlebar specified in the template content. Template need to be published before it can be use to send notifications&lt;br/&gt; Action Code: 50202
   */
  createNotificationTemplateNotify(data) {
    const params = {};
    const url = "/lobby/v1/admin/notification/namespaces/{namespace}/templates/notify".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.post(url, data, { params });
    return Validate5.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, z27.unknown(), "z.unknown()");
  }
  /**
   * Delete topic information by topic name. &lt;br&gt;topic should be alphabets, no special char except underscore, uppercase and no spacing. for example: TOPIC_TEST. Already existing topic can not be created &lt;br/&gt; Action Code: 50217
   */
  deleteNotificationTopic_ByTopicName(topicName) {
    const params = {};
    const url = "/lobby/v1/admin/notification/namespaces/{namespace}/topics/{topicName}".replace("{namespace}", this.namespace).replace("{topicName}", topicName);
    const resultPromise = this.axiosInstance.delete(url, { params });
    return Validate5.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, z27.unknown(), "z.unknown()");
  }
  /**
   * Get topic information by topic name.&lt;br/&gt; Action Code: 50215
   */
  getNotificationTopic_ByTopicName(topicName) {
    const params = {};
    const url = "/lobby/v1/admin/notification/namespaces/{namespace}/topics/{topicName}".replace("{namespace}", this.namespace).replace("{topicName}", topicName);
    const resultPromise = this.axiosInstance.get(url, { params });
    return Validate5.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      NotificationTopicResponseV1,
      "NotificationTopicResponseV1"
    );
  }
  /**
   * Update topic information by topic name. &lt;br&gt;topic should be alphabets, no special char except underscore, uppercase and no spacing. for example: TOPIC_TEST. Already existing topic can not be created &lt;br/&gt; Action Code: 50216
   */
  updateNotificationTopic_ByTopicName(topicName, data) {
    const params = {};
    const url = "/lobby/v1/admin/notification/namespaces/{namespace}/topics/{topicName}".replace("{namespace}", this.namespace).replace("{topicName}", topicName);
    const resultPromise = this.axiosInstance.put(url, data, { params });
    return Validate5.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, z27.unknown(), "z.unknown()");
  }
  /**
   * Delete template slug in notification template&lt;br&gt; Action Code: 50206
   */
  deleteNotificationTemplate_ByTemplateSlug(templateSlug) {
    const params = {};
    const url = "/lobby/v1/admin/notification/namespaces/{namespace}/templates/{templateSlug}".replace("{namespace}", this.namespace).replace("{templateSlug}", templateSlug);
    const resultPromise = this.axiosInstance.delete(url, { params });
    return Validate5.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, z27.unknown(), "z.unknown()");
  }
  /**
   * Get all templates in a namespace&lt;br&gt; Action Code: 50205
   */
  getNotificationTemplate_ByTemplateSlug(templateSlug, queryParams) {
    const params = { ...queryParams };
    const url = "/lobby/v1/admin/notification/namespaces/{namespace}/templates/{templateSlug}".replace("{namespace}", this.namespace).replace("{templateSlug}", templateSlug);
    const resultPromise = this.axiosInstance.get(url, { params });
    return Validate5.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      GetAllNotificationTemplateSlugResp,
      "GetAllNotificationTemplateSlugResp"
    );
  }
  /**
   * Sends notification to multiple user. Action Code: 50211
   */
  createNotificationBulkUserFreeformNotify(data) {
    const params = {};
    const url = "/lobby/v1/admin/notification/namespaces/{namespace}/bulkUsers/freeform/notify".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.post(url, data, { params });
    return Validate5.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, z27.unknown(), "z.unknown()");
  }
  /**
   * Sends notification to a user. Action Code: 50211
   */
  createFreeformNotifyNotification_ByUserId(userId, data) {
    const params = {};
    const url = "/lobby/v1/admin/notification/namespaces/{namespace}/users/{userId}/freeform/notify".replace("{namespace}", this.namespace).replace("{userId}", userId);
    const resultPromise = this.axiosInstance.post(url, data, { params });
    return Validate5.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, z27.unknown(), "z.unknown()");
  }
  /**
   * Sends templated notification to a user. &lt;br&gt;In the request body, specify which template slug (template identifier) to use and the template language. &lt;br&gt;NotificationTemplate context is the key-value pair defining the value of each handlebar specified in the template content. Template need to be published before it can be use to send notifications&lt;br&gt; Action Code: 50212
   */
  createTemplateNotifyNotification_ByUserId(userId, data) {
    const params = {};
    const url = "/lobby/v1/admin/notification/namespaces/{namespace}/users/{userId}/templates/notify".replace("{namespace}", this.namespace).replace("{userId}", userId);
    const resultPromise = this.axiosInstance.post(url, data, { params });
    return Validate5.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, z27.unknown(), "z.unknown()");
  }
  /**
   * Sends notification to a party.
   */
  createFreeformNotifyNotification_ByPartyId(partyId, data) {
    const params = {};
    const url = "/lobby/v1/admin/notification/namespaces/{namespace}/parties/{partyId}/freeform/notify".replace("{namespace}", this.namespace).replace("{partyId}", partyId);
    const resultPromise = this.axiosInstance.post(url, data, { params });
    return Validate5.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, z27.unknown(), "z.unknown()");
  }
  /**
   * Sends templated notification to a party. &lt;br&gt;In the request body, specify which template slug (template identifier) to use and the template language. &lt;br&gt;NotificationTemplate context is the key-value pair defining the value of each handlebar specified in the template content. Template need to be published before it can be use to send notifications&lt;br&gt;
   */
  createTemplateNotifyNotification_ByPartyId(partyId, data) {
    const params = {};
    const url = "/lobby/v1/admin/notification/namespaces/{namespace}/parties/{partyId}/templates/notify".replace("{namespace}", this.namespace).replace("{partyId}", partyId);
    const resultPromise = this.axiosInstance.post(url, data, { params });
    return Validate5.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, z27.unknown(), "z.unknown()");
  }
  /**
   * Delete template localization&lt;br/&gt; Action Code: 50209
   */
  deleteLanguageNotification_ByTemplateSlug_ByTemplateLanguage(templateSlug, templateLanguage) {
    const params = {};
    const url = "/lobby/v1/admin/notification/namespaces/{namespace}/templates/{templateSlug}/languages/{templateLanguage}".replace("{namespace}", this.namespace).replace("{templateSlug}", templateSlug).replace("{templateLanguage}", templateLanguage);
    const resultPromise = this.axiosInstance.delete(url, { params });
    return Validate5.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, z27.unknown(), "z.unknown()");
  }
  /**
   * Get a template localization&lt;br/&gt; Action Code: 50207
   */
  getLanguageNotification_ByTemplateSlug_ByTemplateLanguage(templateSlug, templateLanguage) {
    const params = {};
    const url = "/lobby/v1/admin/notification/namespaces/{namespace}/templates/{templateSlug}/languages/{templateLanguage}".replace("{namespace}", this.namespace).replace("{templateSlug}", templateSlug).replace("{templateLanguage}", templateLanguage);
    const resultPromise = this.axiosInstance.get(url, { params });
    return Validate5.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, Localization, "Localization");
  }
  /**
   * Update template localization&lt;br/&gt; Action Code: 50208
   */
  updateLanguageNotification_ByTemplateSlug_ByTemplateLanguage(templateSlug, templateLanguage, data) {
    const params = {};
    const url = "/lobby/v1/admin/notification/namespaces/{namespace}/templates/{templateSlug}/languages/{templateLanguage}".replace("{namespace}", this.namespace).replace("{templateSlug}", templateSlug).replace("{templateLanguage}", templateLanguage);
    const resultPromise = this.axiosInstance.put(url, data, { params });
    return Validate5.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, z27.unknown(), "z.unknown()");
  }
  /**
   * Publish notification template draft. Empty draft can not be published.&lt;br/&gt; Action Code: 50210
   */
  createPublishNotification_ByTemplateSlug_ByTemplateLanguage(templateSlug, templateLanguage) {
    const params = {};
    const url = "/lobby/v1/admin/notification/namespaces/{namespace}/templates/{templateSlug}/languages/{templateLanguage}/publish".replace("{namespace}", this.namespace).replace("{templateSlug}", templateSlug).replace("{templateLanguage}", templateLanguage);
    const resultPromise = this.axiosInstance.post(url, null, { params });
    return Validate5.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, z27.unknown(), "z.unknown()");
  }
};

// src/generated-admin/endpoints/PartyAdmin$.ts
import { Validate as Validate6 } from "@accelbyte/sdk";
var PartyAdmin$ = class {
  // @ts-ignore
  // prettier-ignore
  constructor(axiosInstance, namespace, useSchemaValidation = true) {
    this.axiosInstance = axiosInstance;
    this.namespace = namespace;
    this.useSchemaValidation = useSchemaValidation;
  }
  /**
   * Get party data in a namespace.
   */
  getPartyParty_ByPartyId(partyId) {
    const params = {};
    const url = "/lobby/v1/admin/party/namespaces/{namespace}/parties/{partyId}".replace("{namespace}", this.namespace).replace("{partyId}", partyId);
    const resultPromise = this.axiosInstance.get(url, { params });
    return Validate6.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, PartyData, "PartyData");
  }
  /**
   * Get party data in a namespace.
   */
  getParty_ByUserId(userId) {
    const params = {};
    const url = "/lobby/v1/admin/party/namespaces/{namespace}/users/{userId}/party".replace("{namespace}", this.namespace).replace("{userId}", userId);
    const resultPromise = this.axiosInstance.get(url, { params });
    return Validate6.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, PartyData, "PartyData");
  }
};

// src/generated-definitions/BlockedByPlayerData.ts
import { z as z28 } from "zod";
var BlockedByPlayerData = z28.object({ blockedAt: z28.string(), userId: z28.string() });

// src/generated-definitions/GetAllPlayerBlockedByUsersResponse.ts
import { z as z29 } from "zod";
var GetAllPlayerBlockedByUsersResponse = z29.object({ data: z29.array(BlockedByPlayerData) });

// src/generated-definitions/BlockedPlayerData.ts
import { z as z30 } from "zod";
var BlockedPlayerData = z30.object({ blockedAt: z30.string(), blockedUserId: z30.string() });

// src/generated-definitions/GetAllPlayerBlockedUsersResponse.ts
import { z as z31 } from "zod";
var GetAllPlayerBlockedUsersResponse = z31.object({ data: z31.array(BlockedPlayerData) });

// src/generated-definitions/GetAllPlayerSessionAttributeResponse.ts
import { z as z32 } from "zod";
var GetAllPlayerSessionAttributeResponse = z32.object({ attributes: z32.record(z32.string()) });

// src/generated-definitions/GetBulkAllPlayerBlockedUsersResponse.ts
import { z as z33 } from "zod";
var GetBulkAllPlayerBlockedUsersResponse = z33.object({ data: z33.record(z33.array(BlockedPlayerData)) });

// src/generated-definitions/GetLobbyCcuResponse.ts
import { z as z34 } from "zod";
var GetLobbyCcuResponse = z34.object({ countCurrentUsers: z34.number().int() });

// src/generated-definitions/GetPlayerSessionAttributeResponse.ts
import { z as z35 } from "zod";
var GetPlayerSessionAttributeResponse = z35.object({ key: z35.string(), value: z35.string() });

// src/generated-admin/endpoints/PlayerAdmin$.ts
import { Validate as Validate7 } from "@accelbyte/sdk";
import { z as z36 } from "zod";
var PlayerAdmin$ = class {
  // @ts-ignore
  // prettier-ignore
  constructor(axiosInstance, namespace, useSchemaValidation = true) {
    this.axiosInstance = axiosInstance;
    this.namespace = namespace;
    this.useSchemaValidation = useSchemaValidation;
  }
  /**
   * Get the number of players connected to the Lobby in the given namespace.
   */
  getPlayerCcu() {
    const params = {};
    const url = "/lobby/v1/admin/player/namespaces/{namespace}/ccu".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.get(url, { params });
    return Validate7.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, GetLobbyCcuResponse, "GetLobbyCcuResponse");
  }
  /**
   * Get blocked players data by bulk user ids in a namespace.
   */
  fetchPlayerUserBulkBlocked(data) {
    const params = {};
    const url = "/lobby/v1/admin/player/namespaces/{namespace}/users/bulk/blocked".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.post(url, data, { params });
    return Validate7.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      GetBulkAllPlayerBlockedUsersResponse,
      "GetBulkAllPlayerBlockedUsersResponse"
    );
  }
  /**
   * Get blocked players data by user id in a namespace.
   */
  getBlockedPlayer_ByUserId(userId) {
    const params = {};
    const url = "/lobby/v1/admin/player/namespaces/{namespace}/users/{userId}/blocked".replace("{namespace}", this.namespace).replace("{userId}", userId);
    const resultPromise = this.axiosInstance.get(url, { params });
    return Validate7.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      GetAllPlayerBlockedUsersResponse,
      "GetAllPlayerBlockedUsersResponse"
    );
  }
  /**
   * Get all player&#39;s session attribute by user id in a namespace.
   */
  getAttributesPlayer_ByUserId(userId) {
    const params = {};
    const url = "/lobby/v1/admin/player/namespaces/{namespace}/users/{userId}/attributes".replace("{namespace}", this.namespace).replace("{userId}", userId);
    const resultPromise = this.axiosInstance.get(url, { params });
    return Validate7.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      GetAllPlayerSessionAttributeResponse,
      "GetAllPlayerSessionAttributeResponse"
    );
  }
  /**
   * Set player&#39;s session attribute by user id in a namespace.
   */
  updateAttributePlayer_ByUserId(userId, data) {
    const params = {};
    const url = "/lobby/v1/admin/player/namespaces/{namespace}/users/{userId}/attributes".replace("{namespace}", this.namespace).replace("{userId}", userId);
    const resultPromise = this.axiosInstance.put(url, data, { params });
    return Validate7.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, z36.unknown(), "z.unknown()");
  }
  /**
   * Load get players who blocked this player in a namespace based on user id
   */
  getBlockedByPlayer_ByUserId(userId) {
    const params = {};
    const url = "/lobby/v1/admin/player/namespaces/{namespace}/users/{userId}/blocked-by".replace("{namespace}", this.namespace).replace("{userId}", userId);
    const resultPromise = this.axiosInstance.get(url, { params });
    return Validate7.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      GetAllPlayerBlockedByUsersResponse,
      "GetAllPlayerBlockedByUsersResponse"
    );
  }
  /**
   * Bulk block player in a namespace by list of user id
   */
  createBulkBlockPlayer_ByUserId(userId, data) {
    const params = {};
    const url = "/lobby/v1/admin/player/namespaces/{namespace}/users/{userId}/bulk/block".replace("{namespace}", this.namespace).replace("{userId}", userId);
    const resultPromise = this.axiosInstance.post(url, data, { params });
    return Validate7.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, z36.unknown(), "z.unknown()");
  }
  /**
   * Bulk unblock player in a namespace by list of user id
   */
  deleteBulkUnblockPlayer_ByUserId(userId, data) {
    const params = {};
    const url = "/lobby/v1/admin/player/namespaces/{namespace}/users/{userId}/bulk/unblock".replace("{namespace}", this.namespace).replace("{userId}", userId);
    const resultPromise = this.axiosInstance.delete(url, { data, params });
    return Validate7.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, z36.unknown(), "z.unknown()");
  }
  /**
   * Get player&#39;s specific session attribute by user id in a namespace.
   */
  getAttributePlayer_ByUserId_ByAttribute(userId, attribute) {
    const params = {};
    const url = "/lobby/v1/admin/player/namespaces/{namespace}/users/{userId}/attributes/{attribute}".replace("{namespace}", this.namespace).replace("{userId}", userId).replace("{attribute}", attribute);
    const resultPromise = this.axiosInstance.get(url, { params });
    return Validate7.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      GetPlayerSessionAttributeResponse,
      "GetPlayerSessionAttributeResponse"
    );
  }
};

// src/generated-definitions/ProfanityFilter.ts
import { z as z37 } from "zod";
var ProfanityFilter = z37.object({ filter: z37.string(), listName: z37.string(), namespace: z37.string(), note: z37.string() });

// src/generated-definitions/AdminGetProfanityListFiltersV1Response.ts
import { z as z38 } from "zod";
var AdminGetProfanityListFiltersV1Response = z38.object({ filters: z38.array(ProfanityFilter) });

// src/generated-definitions/AdminGetProfanityListsListResponse.ts
import { z as z39 } from "zod";
var AdminGetProfanityListsListResponse = z39.object({ isEnabled: z39.boolean(), isMandatory: z39.boolean(), name: z39.string() });

// src/generated-definitions/AdminGetProfanityListsListResponseArray.ts
import { z as z40 } from "zod";
var AdminGetProfanityListsListResponseArray = z40.array(AdminGetProfanityListsListResponse);

// src/generated-definitions/AdminVerifyMessageProfanityResponse.ts
import { z as z41 } from "zod";
var AdminVerifyMessageProfanityResponse = z41.object({ filteredMessage: z41.string(), hasProfanity: z41.boolean() });

// src/generated-definitions/ProfanityFilterArray.ts
import { z as z42 } from "zod";
var ProfanityFilterArray = z42.array(ProfanityFilter);

// src/generated-definitions/ProfanityRule.ts
import { z as z43 } from "zod";
var ProfanityRule = z43.object({ Namespace: z43.string(), Rule: z43.string() });

// src/generated-admin/endpoints/ProfanityAdmin$.ts
import { Validate as Validate8 } from "@accelbyte/sdk";
import { z as z44 } from "zod";
var ProfanityAdmin$ = class {
  // @ts-ignore
  // prettier-ignore
  constructor(axiosInstance, namespace, useSchemaValidation = true) {
    this.axiosInstance = axiosInstance;
    this.namespace = namespace;
    this.useSchemaValidation = useSchemaValidation;
  }
  /**
   * Get current profanity rule
   */
  getProfanityRule() {
    const params = {};
    const url = "/lobby/v1/admin/profanity/namespaces/{namespace}/rule".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.get(url, { params });
    return Validate8.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, ProfanityRule, "ProfanityRule");
  }
  /**
   * Set current profanity rule
   */
  updateProfanityRule(data) {
    const params = {};
    const url = "/lobby/v1/admin/profanity/namespaces/{namespace}/rule".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.post(url, data, { params });
    return Validate8.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, z44.unknown(), "z.unknown()");
  }
  /**
   * Get lists
   */
  getProfanityLists() {
    const params = {};
    const url = "/lobby/v1/admin/profanity/namespaces/{namespace}/lists".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.get(url, { params });
    return Validate8.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      AdminGetProfanityListsListResponseArray,
      "AdminGetProfanityListsListResponseArray"
    );
  }
  /**
   * Create a new list
   */
  createProfanityList(data) {
    const params = {};
    const url = "/lobby/v1/admin/profanity/namespaces/{namespace}/lists".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.post(url, data, { params });
    return Validate8.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, z44.unknown(), "z.unknown()");
  }
  /**
   * Verify a message directly from the UI or other services
   */
  fetchProfanityVerify(data) {
    const params = {};
    const url = "/lobby/v1/admin/profanity/namespaces/{namespace}/verify".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.post(url, data, { params });
    return Validate8.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      AdminVerifyMessageProfanityResponse,
      "AdminVerifyMessageProfanityResponse"
    );
  }
  /**
   * Delete a list include all filters inside of it
   */
  deleteProfanityList_ByList(list) {
    const params = {};
    const url = "/lobby/v1/admin/profanity/namespaces/{namespace}/lists/{list}".replace("{namespace}", this.namespace).replace("{list}", list);
    const resultPromise = this.axiosInstance.delete(url, { params });
    return Validate8.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, z44.unknown(), "z.unknown()");
  }
  /**
   * Update the list
   */
  updateProfanityList_ByList(list, data) {
    const params = {};
    const url = "/lobby/v1/admin/profanity/namespaces/{namespace}/lists/{list}".replace("{namespace}", this.namespace).replace("{list}", list);
    const resultPromise = this.axiosInstance.post(url, data, { params });
    return Validate8.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, z44.unknown(), "z.unknown()");
  }
  /**
   * Get the list of filters that would modify the phrase
   */
  fetchProfanityFilterDebug(data) {
    const params = {};
    const url = "/lobby/v1/admin/profanity/namespaces/{namespace}/filters/debug".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.post(url, data, { params });
    return Validate8.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, ProfanityFilterArray, "ProfanityFilterArray");
  }
  /**
   * Get the list of filters inside the list.
   */
  getFiltersProfanity_ByList(list) {
    const params = {};
    const url = "/lobby/v1/admin/profanity/namespaces/{namespace}/list/{list}/filters".replace("{namespace}", this.namespace).replace("{list}", list);
    const resultPromise = this.axiosInstance.get(url, { params });
    return Validate8.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      AdminGetProfanityListFiltersV1Response,
      "AdminGetProfanityListFiltersV1Response"
    );
  }
  /**
   * Add a single filter into the list
   */
  createFilterProfanity_ByList(list, data) {
    const params = {};
    const url = "/lobby/v1/admin/profanity/namespaces/{namespace}/list/{list}/filters".replace("{namespace}", this.namespace).replace("{list}", list);
    const resultPromise = this.axiosInstance.post(url, data, { params });
    return Validate8.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, z44.unknown(), "z.unknown()");
  }
  /**
   * Add multiple filters into the list
   */
  createFilterBulkProfanity_ByList(list, data) {
    const params = {};
    const url = "/lobby/v1/admin/profanity/namespaces/{namespace}/list/{list}/filters/bulk".replace("{namespace}", this.namespace).replace("{list}", list);
    const resultPromise = this.axiosInstance.post(url, data, { params });
    return Validate8.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, z44.unknown(), "z.unknown()");
  }
  /**
   * Delete the filter from the list
   */
  createFilterDeleteProfanity_ByList(list, data) {
    const params = {};
    const url = "/lobby/v1/admin/profanity/namespaces/{namespace}/list/{list}/filters/delete".replace("{namespace}", this.namespace).replace("{list}", list);
    const resultPromise = this.axiosInstance.post(url, data, { params });
    return Validate8.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, ProfanityFilterArray, "ProfanityFilterArray");
  }
  /**
   * Import a file with filters
   */
  createFilterBulkFileProfanity_ByList(list, data) {
    const params = {};
    const url = "/lobby/v1/admin/profanity/namespaces/{namespace}/list/{list}/filters/bulk-file".replace("{namespace}", this.namespace).replace("{list}", list);
    const resultPromise = this.axiosInstance.post(url, data, { params });
    return Validate8.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, z44.unknown(), "z.unknown()");
  }
};

// src/generated-definitions/CreateConfigResponse.ts
import { z as z45 } from "zod";
var CreateConfigResponse = z45.object({ apiKey: z45.string(), namespace: z45.string() });

// src/generated-definitions/GetConfigResponse.ts
import { z as z46 } from "zod";
var GetConfigResponse = z46.object({ apiKey: z46.string(), namespace: z46.string() });

// src/generated-definitions/UpdateConfigResponse.ts
import { z as z47 } from "zod";
var UpdateConfigResponse = z47.object({ apiKey: z47.string(), namespace: z47.string() });

// src/generated-admin/endpoints/ThirdPartyAdmin$.ts
import { Validate as Validate9 } from "@accelbyte/sdk";
import { z as z48 } from "zod";
var ThirdPartyAdmin$ = class {
  // @ts-ignore
  // prettier-ignore
  constructor(axiosInstance, namespace, useSchemaValidation = true) {
    this.axiosInstance = axiosInstance;
    this.namespace = namespace;
    this.useSchemaValidation = useSchemaValidation;
  }
  /**
   * Required permission : &lt;code&gt;ADMIN:NAMESPACE:{namespace}:THIRDPARTY:CONFIG [DELETE]&lt;/code&gt; with scope &lt;code&gt;social&lt;/code&gt; &lt;br&gt;delete third party config in a namespace.
   */
  deleteThirdpartyConfigSteam() {
    const params = {};
    const url = "/lobby/v1/admin/thirdparty/namespaces/{namespace}/config/steam".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.delete(url, { params });
    return Validate9.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, z48.unknown(), "z.unknown()");
  }
  /**
   * Get third party config for specified namespace.
   */
  getThirdpartyConfigSteam() {
    const params = {};
    const url = "/lobby/v1/admin/thirdparty/namespaces/{namespace}/config/steam".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.get(url, { params });
    return Validate9.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, GetConfigResponse, "GetConfigResponse");
  }
  /**
   * Create third party config in a namespace.
   */
  createThirdpartyConfigSteam(data) {
    const params = {};
    const url = "/lobby/v1/admin/thirdparty/namespaces/{namespace}/config/steam".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.post(url, data, { params });
    return Validate9.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, CreateConfigResponse, "CreateConfigResponse");
  }
  /**
   * Update third party config in a namespace.
   */
  updateThirdpartyConfigSteam(data) {
    const params = {};
    const url = "/lobby/v1/admin/thirdparty/namespaces/{namespace}/config/steam".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.put(url, data, { params });
    return Validate9.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, UpdateConfigResponse, "UpdateConfigResponse");
  }
};

// src/generated-admin/FriendsAdminApi.ts
import { ApiUtils as ApiUtils3, Network as Network3 } from "@accelbyte/sdk";
function FriendsAdminApi(sdk, args) {
  const sdkAssembly = sdk.assembly();
  const namespace = args?.coreConfig?.namespace ?? sdkAssembly.coreConfig.namespace;
  const useSchemaValidation = args?.coreConfig?.useSchemaValidation ?? sdkAssembly.coreConfig.useSchemaValidation;
  let axiosInstance = sdkAssembly.axiosInstance;
  const requestConfigOverrides = args?.axiosConfig?.request;
  const baseURLOverride = args?.coreConfig?.baseURL;
  const interceptorsOverride = args?.axiosConfig?.interceptors ?? [];
  if (requestConfigOverrides || baseURLOverride || interceptorsOverride.length > 0) {
    const requestConfig = ApiUtils3.mergeAxiosConfigs(sdkAssembly.axiosInstance.defaults, {
      ...baseURLOverride ? { baseURL: baseURLOverride } : {},
      ...requestConfigOverrides
    });
    axiosInstance = Network3.create(requestConfig);
    for (const interceptor of interceptorsOverride) {
      if (interceptor.type === "request") {
        axiosInstance.interceptors.request.use(interceptor.onRequest, interceptor.onError);
      }
      if (interceptor.type === "response") {
        axiosInstance.interceptors.response.use(interceptor.onSuccess, interceptor.onError);
      }
    }
  }
  async function getFriendUser_ByUserId(userId, queryParams) {
    const $ = new FriendsAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getFriendUser_ByUserId(userId, queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getIncomingFriend_ByUserId(userId, queryParams) {
    const $ = new FriendsAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getIncomingFriend_ByUserId(userId, queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getOutgoingFriend_ByUserId(userId, queryParams) {
    const $ = new FriendsAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getOutgoingFriend_ByUserId(userId, queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getOfFriends_ByUserId(userId, queryParams) {
    const $ = new FriendsAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getOfFriends_ByUserId(userId, queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  return {
    /**
     * Get list of friends in a namespace.
     */
    getFriendUser_ByUserId,
    /**
     * Get list of incoming friend requests.
     */
    getIncomingFriend_ByUserId,
    /**
     * Get list of outgoing friend requests in a namespace.
     */
    getOutgoingFriend_ByUserId,
    /**
     * Load list friends and friends of friends in a namespace. Response subjectId will be different with requested userId if the user is not directly friend
     */
    getOfFriends_ByUserId
  };
}

// src/generated-admin/LobbyOperationsAdminApi.ts
import { ApiUtils as ApiUtils4, Network as Network4 } from "@accelbyte/sdk";
function LobbyOperationsAdminApi(sdk, args) {
  const sdkAssembly = sdk.assembly();
  const namespace = args?.coreConfig?.namespace ?? sdkAssembly.coreConfig.namespace;
  const useSchemaValidation = args?.coreConfig?.useSchemaValidation ?? sdkAssembly.coreConfig.useSchemaValidation;
  let axiosInstance = sdkAssembly.axiosInstance;
  const requestConfigOverrides = args?.axiosConfig?.request;
  const baseURLOverride = args?.coreConfig?.baseURL;
  const interceptorsOverride = args?.axiosConfig?.interceptors ?? [];
  if (requestConfigOverrides || baseURLOverride || interceptorsOverride.length > 0) {
    const requestConfig = ApiUtils4.mergeAxiosConfigs(sdkAssembly.axiosInstance.defaults, {
      ...baseURLOverride ? { baseURL: baseURLOverride } : {},
      ...requestConfigOverrides
    });
    axiosInstance = Network4.create(requestConfig);
    for (const interceptor of interceptorsOverride) {
      if (interceptor.type === "request") {
        axiosInstance.interceptors.request.use(interceptor.onRequest, interceptor.onError);
      }
      if (interceptor.type === "response") {
        axiosInstance.interceptors.response.use(interceptor.onSuccess, interceptor.onError);
      }
    }
  }
  async function updateAttributeParty_ByPartyId(partyId, data) {
    const $ = new LobbyOperationsAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.updateAttributeParty_ByPartyId(partyId, data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function updateJoinParty_ByPartyId_ByUserId(partyId, userId) {
    const $ = new LobbyOperationsAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.updateJoinParty_ByPartyId_ByUserId(partyId, userId);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  return {
    /**
     * Update party attributes in a namespace.
     */
    updateAttributeParty_ByPartyId,
    /**
     * Admin join a player into a party.
     */
    updateJoinParty_ByPartyId_ByUserId
  };
}

// src/generated-admin/NotificationAdminApi.ts
import { ApiUtils as ApiUtils5, Network as Network5 } from "@accelbyte/sdk";
function NotificationAdminApi(sdk, args) {
  const sdkAssembly = sdk.assembly();
  const namespace = args?.coreConfig?.namespace ?? sdkAssembly.coreConfig.namespace;
  const useSchemaValidation = args?.coreConfig?.useSchemaValidation ?? sdkAssembly.coreConfig.useSchemaValidation;
  let axiosInstance = sdkAssembly.axiosInstance;
  const requestConfigOverrides = args?.axiosConfig?.request;
  const baseURLOverride = args?.coreConfig?.baseURL;
  const interceptorsOverride = args?.axiosConfig?.interceptors ?? [];
  if (requestConfigOverrides || baseURLOverride || interceptorsOverride.length > 0) {
    const requestConfig = ApiUtils5.mergeAxiosConfigs(sdkAssembly.axiosInstance.defaults, {
      ...baseURLOverride ? { baseURL: baseURLOverride } : {},
      ...requestConfigOverrides
    });
    axiosInstance = Network5.create(requestConfig);
    for (const interceptor of interceptorsOverride) {
      if (interceptor.type === "request") {
        axiosInstance.interceptors.request.use(interceptor.onRequest, interceptor.onError);
      }
      if (interceptor.type === "response") {
        axiosInstance.interceptors.response.use(interceptor.onSuccess, interceptor.onError);
      }
    }
  }
  async function getNotificationTopics(queryParams) {
    const $ = new NotificationAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getNotificationTopics(queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function createNotificationTopic(data) {
    const $ = new NotificationAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.createNotificationTopic(data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getNotificationTemplates() {
    const $ = new NotificationAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getNotificationTemplates();
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function createNotificationTemplate(data) {
    const $ = new NotificationAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.createNotificationTemplate(data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function createNotificationFreeformNotify(data) {
    const $ = new NotificationAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.createNotificationFreeformNotify(data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function createNotificationTemplateNotify(data) {
    const $ = new NotificationAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.createNotificationTemplateNotify(data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function deleteNotificationTopic_ByTopicName(topicName) {
    const $ = new NotificationAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.deleteNotificationTopic_ByTopicName(topicName);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getNotificationTopic_ByTopicName(topicName) {
    const $ = new NotificationAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getNotificationTopic_ByTopicName(topicName);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function updateNotificationTopic_ByTopicName(topicName, data) {
    const $ = new NotificationAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.updateNotificationTopic_ByTopicName(topicName, data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function deleteNotificationTemplate_ByTemplateSlug(templateSlug) {
    const $ = new NotificationAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.deleteNotificationTemplate_ByTemplateSlug(templateSlug);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getNotificationTemplate_ByTemplateSlug(templateSlug, queryParams) {
    const $ = new NotificationAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getNotificationTemplate_ByTemplateSlug(templateSlug, queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function createNotificationBulkUserFreeformNotify(data) {
    const $ = new NotificationAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.createNotificationBulkUserFreeformNotify(data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function createFreeformNotifyNotification_ByUserId(userId, data) {
    const $ = new NotificationAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.createFreeformNotifyNotification_ByUserId(userId, data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function createTemplateNotifyNotification_ByUserId(userId, data) {
    const $ = new NotificationAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.createTemplateNotifyNotification_ByUserId(userId, data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function createFreeformNotifyNotification_ByPartyId(partyId, data) {
    const $ = new NotificationAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.createFreeformNotifyNotification_ByPartyId(partyId, data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function createTemplateNotifyNotification_ByPartyId(partyId, data) {
    const $ = new NotificationAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.createTemplateNotifyNotification_ByPartyId(partyId, data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function deleteLanguageNotification_ByTemplateSlug_ByTemplateLanguage(templateSlug, templateLanguage) {
    const $ = new NotificationAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.deleteLanguageNotification_ByTemplateSlug_ByTemplateLanguage(templateSlug, templateLanguage);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getLanguageNotification_ByTemplateSlug_ByTemplateLanguage(templateSlug, templateLanguage) {
    const $ = new NotificationAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getLanguageNotification_ByTemplateSlug_ByTemplateLanguage(templateSlug, templateLanguage);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function updateLanguageNotification_ByTemplateSlug_ByTemplateLanguage(templateSlug, templateLanguage, data) {
    const $ = new NotificationAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.updateLanguageNotification_ByTemplateSlug_ByTemplateLanguage(templateSlug, templateLanguage, data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function createPublishNotification_ByTemplateSlug_ByTemplateLanguage(templateSlug, templateLanguage) {
    const $ = new NotificationAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.createPublishNotification_ByTemplateSlug_ByTemplateLanguage(templateSlug, templateLanguage);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  return {
    /**
     * Get topic by namespace.&lt;br/&gt; Action Code: 50213
     */
    getNotificationTopics,
    /**
     * Create new notification topic. &lt;br&gt;topic should be alphabets, no special char except underscore, uppercase and no spacing. for example: TOPIC_TEST. Already existing topic can not be created&lt;br/&gt; Action Code: 50214
     */
    createNotificationTopic,
    /**
     * Get all templates in a namespace&lt;br&gt; Action Code: 50203
     */
    getNotificationTemplates,
    /**
     * Create new notification template. Include handlebars {{key}} for replaceable contexts. The key inside handlebars will be the key to be replaced when sending notification. Already existing template with the same slug and language can not be created. &lt;br&gt;Check model description for detailed input restrictions.&lt;br&gt; Action Code: 50204
     */
    createNotificationTemplate,
    /**
     * Sends notification to all connected users in a namespace.&lt;br&gt; Action Code: 50201
     */
    createNotificationFreeformNotify,
    /**
     * Sends notification to all connected users in a namespace with predefined template. &lt;br&gt;In the request body, specify which template slug (template identifier) to use and the template language. &lt;br&gt;NotificationTemplate context is the key-value pair defining the value of each handlebar specified in the template content. Template need to be published before it can be use to send notifications&lt;br/&gt; Action Code: 50202
     */
    createNotificationTemplateNotify,
    /**
     * Delete topic information by topic name. &lt;br&gt;topic should be alphabets, no special char except underscore, uppercase and no spacing. for example: TOPIC_TEST. Already existing topic can not be created &lt;br/&gt; Action Code: 50217
     */
    deleteNotificationTopic_ByTopicName,
    /**
     * Get topic information by topic name.&lt;br/&gt; Action Code: 50215
     */
    getNotificationTopic_ByTopicName,
    /**
     * Update topic information by topic name. &lt;br&gt;topic should be alphabets, no special char except underscore, uppercase and no spacing. for example: TOPIC_TEST. Already existing topic can not be created &lt;br/&gt; Action Code: 50216
     */
    updateNotificationTopic_ByTopicName,
    /**
     * Delete template slug in notification template&lt;br&gt; Action Code: 50206
     */
    deleteNotificationTemplate_ByTemplateSlug,
    /**
     * Get all templates in a namespace&lt;br&gt; Action Code: 50205
     */
    getNotificationTemplate_ByTemplateSlug,
    /**
     * Sends notification to multiple user. Action Code: 50211
     */
    createNotificationBulkUserFreeformNotify,
    /**
     * Sends notification to a user. Action Code: 50211
     */
    createFreeformNotifyNotification_ByUserId,
    /**
     * Sends templated notification to a user. &lt;br&gt;In the request body, specify which template slug (template identifier) to use and the template language. &lt;br&gt;NotificationTemplate context is the key-value pair defining the value of each handlebar specified in the template content. Template need to be published before it can be use to send notifications&lt;br&gt; Action Code: 50212
     */
    createTemplateNotifyNotification_ByUserId,
    /**
     * Sends notification to a party.
     */
    createFreeformNotifyNotification_ByPartyId,
    /**
     * Sends templated notification to a party. &lt;br&gt;In the request body, specify which template slug (template identifier) to use and the template language. &lt;br&gt;NotificationTemplate context is the key-value pair defining the value of each handlebar specified in the template content. Template need to be published before it can be use to send notifications&lt;br&gt;
     */
    createTemplateNotifyNotification_ByPartyId,
    /**
     * Delete template localization&lt;br/&gt; Action Code: 50209
     */
    deleteLanguageNotification_ByTemplateSlug_ByTemplateLanguage,
    /**
     * Get a template localization&lt;br/&gt; Action Code: 50207
     */
    getLanguageNotification_ByTemplateSlug_ByTemplateLanguage,
    /**
     * Update template localization&lt;br/&gt; Action Code: 50208
     */
    updateLanguageNotification_ByTemplateSlug_ByTemplateLanguage,
    /**
     * Publish notification template draft. Empty draft can not be published.&lt;br/&gt; Action Code: 50210
     */
    createPublishNotification_ByTemplateSlug_ByTemplateLanguage
  };
}

// src/generated-admin/PartyAdminApi.ts
import { ApiUtils as ApiUtils6, Network as Network6 } from "@accelbyte/sdk";
function PartyAdminApi(sdk, args) {
  const sdkAssembly = sdk.assembly();
  const namespace = args?.coreConfig?.namespace ?? sdkAssembly.coreConfig.namespace;
  const useSchemaValidation = args?.coreConfig?.useSchemaValidation ?? sdkAssembly.coreConfig.useSchemaValidation;
  let axiosInstance = sdkAssembly.axiosInstance;
  const requestConfigOverrides = args?.axiosConfig?.request;
  const baseURLOverride = args?.coreConfig?.baseURL;
  const interceptorsOverride = args?.axiosConfig?.interceptors ?? [];
  if (requestConfigOverrides || baseURLOverride || interceptorsOverride.length > 0) {
    const requestConfig = ApiUtils6.mergeAxiosConfigs(sdkAssembly.axiosInstance.defaults, {
      ...baseURLOverride ? { baseURL: baseURLOverride } : {},
      ...requestConfigOverrides
    });
    axiosInstance = Network6.create(requestConfig);
    for (const interceptor of interceptorsOverride) {
      if (interceptor.type === "request") {
        axiosInstance.interceptors.request.use(interceptor.onRequest, interceptor.onError);
      }
      if (interceptor.type === "response") {
        axiosInstance.interceptors.response.use(interceptor.onSuccess, interceptor.onError);
      }
    }
  }
  async function getPartyParty_ByPartyId(partyId) {
    const $ = new PartyAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getPartyParty_ByPartyId(partyId);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getParty_ByUserId(userId) {
    const $ = new PartyAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getParty_ByUserId(userId);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  return {
    /**
     * Get party data in a namespace.
     */
    getPartyParty_ByPartyId,
    /**
     * Get party data in a namespace.
     */
    getParty_ByUserId
  };
}

// src/generated-admin/PlayerAdminApi.ts
import { ApiUtils as ApiUtils7, Network as Network7 } from "@accelbyte/sdk";
function PlayerAdminApi(sdk, args) {
  const sdkAssembly = sdk.assembly();
  const namespace = args?.coreConfig?.namespace ?? sdkAssembly.coreConfig.namespace;
  const useSchemaValidation = args?.coreConfig?.useSchemaValidation ?? sdkAssembly.coreConfig.useSchemaValidation;
  let axiosInstance = sdkAssembly.axiosInstance;
  const requestConfigOverrides = args?.axiosConfig?.request;
  const baseURLOverride = args?.coreConfig?.baseURL;
  const interceptorsOverride = args?.axiosConfig?.interceptors ?? [];
  if (requestConfigOverrides || baseURLOverride || interceptorsOverride.length > 0) {
    const requestConfig = ApiUtils7.mergeAxiosConfigs(sdkAssembly.axiosInstance.defaults, {
      ...baseURLOverride ? { baseURL: baseURLOverride } : {},
      ...requestConfigOverrides
    });
    axiosInstance = Network7.create(requestConfig);
    for (const interceptor of interceptorsOverride) {
      if (interceptor.type === "request") {
        axiosInstance.interceptors.request.use(interceptor.onRequest, interceptor.onError);
      }
      if (interceptor.type === "response") {
        axiosInstance.interceptors.response.use(interceptor.onSuccess, interceptor.onError);
      }
    }
  }
  async function getPlayerCcu() {
    const $ = new PlayerAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getPlayerCcu();
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function fetchPlayerUserBulkBlocked(data) {
    const $ = new PlayerAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.fetchPlayerUserBulkBlocked(data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getBlockedPlayer_ByUserId(userId) {
    const $ = new PlayerAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getBlockedPlayer_ByUserId(userId);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getAttributesPlayer_ByUserId(userId) {
    const $ = new PlayerAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getAttributesPlayer_ByUserId(userId);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function updateAttributePlayer_ByUserId(userId, data) {
    const $ = new PlayerAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.updateAttributePlayer_ByUserId(userId, data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getBlockedByPlayer_ByUserId(userId) {
    const $ = new PlayerAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getBlockedByPlayer_ByUserId(userId);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function createBulkBlockPlayer_ByUserId(userId, data) {
    const $ = new PlayerAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.createBulkBlockPlayer_ByUserId(userId, data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function deleteBulkUnblockPlayer_ByUserId(userId, data) {
    const $ = new PlayerAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.deleteBulkUnblockPlayer_ByUserId(userId, data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getAttributePlayer_ByUserId_ByAttribute(userId, attribute) {
    const $ = new PlayerAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getAttributePlayer_ByUserId_ByAttribute(userId, attribute);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  return {
    /**
     * Get the number of players connected to the Lobby in the given namespace.
     */
    getPlayerCcu,
    /**
     * Get blocked players data by bulk user ids in a namespace.
     */
    fetchPlayerUserBulkBlocked,
    /**
     * Get blocked players data by user id in a namespace.
     */
    getBlockedPlayer_ByUserId,
    /**
     * Get all player&#39;s session attribute by user id in a namespace.
     */
    getAttributesPlayer_ByUserId,
    /**
     * Set player&#39;s session attribute by user id in a namespace.
     */
    updateAttributePlayer_ByUserId,
    /**
     * Load get players who blocked this player in a namespace based on user id
     */
    getBlockedByPlayer_ByUserId,
    /**
     * Bulk block player in a namespace by list of user id
     */
    createBulkBlockPlayer_ByUserId,
    /**
     * Bulk unblock player in a namespace by list of user id
     */
    deleteBulkUnblockPlayer_ByUserId,
    /**
     * Get player&#39;s specific session attribute by user id in a namespace.
     */
    getAttributePlayer_ByUserId_ByAttribute
  };
}

// src/generated-admin/ProfanityAdminApi.ts
import { ApiUtils as ApiUtils8, Network as Network8 } from "@accelbyte/sdk";
function ProfanityAdminApi(sdk, args) {
  const sdkAssembly = sdk.assembly();
  const namespace = args?.coreConfig?.namespace ?? sdkAssembly.coreConfig.namespace;
  const useSchemaValidation = args?.coreConfig?.useSchemaValidation ?? sdkAssembly.coreConfig.useSchemaValidation;
  let axiosInstance = sdkAssembly.axiosInstance;
  const requestConfigOverrides = args?.axiosConfig?.request;
  const baseURLOverride = args?.coreConfig?.baseURL;
  const interceptorsOverride = args?.axiosConfig?.interceptors ?? [];
  if (requestConfigOverrides || baseURLOverride || interceptorsOverride.length > 0) {
    const requestConfig = ApiUtils8.mergeAxiosConfigs(sdkAssembly.axiosInstance.defaults, {
      ...baseURLOverride ? { baseURL: baseURLOverride } : {},
      ...requestConfigOverrides
    });
    axiosInstance = Network8.create(requestConfig);
    for (const interceptor of interceptorsOverride) {
      if (interceptor.type === "request") {
        axiosInstance.interceptors.request.use(interceptor.onRequest, interceptor.onError);
      }
      if (interceptor.type === "response") {
        axiosInstance.interceptors.response.use(interceptor.onSuccess, interceptor.onError);
      }
    }
  }
  async function getProfanityRule() {
    const $ = new ProfanityAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getProfanityRule();
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function updateProfanityRule(data) {
    const $ = new ProfanityAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.updateProfanityRule(data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getProfanityLists() {
    const $ = new ProfanityAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getProfanityLists();
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function createProfanityList(data) {
    const $ = new ProfanityAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.createProfanityList(data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function fetchProfanityVerify(data) {
    const $ = new ProfanityAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.fetchProfanityVerify(data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function deleteProfanityList_ByList(list) {
    const $ = new ProfanityAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.deleteProfanityList_ByList(list);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function updateProfanityList_ByList(list, data) {
    const $ = new ProfanityAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.updateProfanityList_ByList(list, data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function fetchProfanityFilterDebug(data) {
    const $ = new ProfanityAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.fetchProfanityFilterDebug(data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getFiltersProfanity_ByList(list) {
    const $ = new ProfanityAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getFiltersProfanity_ByList(list);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function createFilterProfanity_ByList(list, data) {
    const $ = new ProfanityAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.createFilterProfanity_ByList(list, data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function createFilterBulkProfanity_ByList(list, data) {
    const $ = new ProfanityAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.createFilterBulkProfanity_ByList(list, data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function createFilterDeleteProfanity_ByList(list, data) {
    const $ = new ProfanityAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.createFilterDeleteProfanity_ByList(list, data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function createFilterBulkFileProfanity_ByList(list, data) {
    const $ = new ProfanityAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.createFilterBulkFileProfanity_ByList(list, data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  return {
    /**
     * Get current profanity rule
     */
    getProfanityRule,
    /**
     * Set current profanity rule
     */
    updateProfanityRule,
    /**
     * Get lists
     */
    getProfanityLists,
    /**
     * Create a new list
     */
    createProfanityList,
    /**
     * Verify a message directly from the UI or other services
     */
    fetchProfanityVerify,
    /**
     * Delete a list include all filters inside of it
     */
    deleteProfanityList_ByList,
    /**
     * Update the list
     */
    updateProfanityList_ByList,
    /**
     * Get the list of filters that would modify the phrase
     */
    fetchProfanityFilterDebug,
    /**
     * Get the list of filters inside the list.
     */
    getFiltersProfanity_ByList,
    /**
     * Add a single filter into the list
     */
    createFilterProfanity_ByList,
    /**
     * Add multiple filters into the list
     */
    createFilterBulkProfanity_ByList,
    /**
     * Delete the filter from the list
     */
    createFilterDeleteProfanity_ByList,
    /**
     * Import a file with filters
     */
    createFilterBulkFileProfanity_ByList
  };
}

// src/generated-admin/ThirdPartyAdminApi.ts
import { ApiUtils as ApiUtils9, Network as Network9 } from "@accelbyte/sdk";
function ThirdPartyAdminApi(sdk, args) {
  const sdkAssembly = sdk.assembly();
  const namespace = args?.coreConfig?.namespace ?? sdkAssembly.coreConfig.namespace;
  const useSchemaValidation = args?.coreConfig?.useSchemaValidation ?? sdkAssembly.coreConfig.useSchemaValidation;
  let axiosInstance = sdkAssembly.axiosInstance;
  const requestConfigOverrides = args?.axiosConfig?.request;
  const baseURLOverride = args?.coreConfig?.baseURL;
  const interceptorsOverride = args?.axiosConfig?.interceptors ?? [];
  if (requestConfigOverrides || baseURLOverride || interceptorsOverride.length > 0) {
    const requestConfig = ApiUtils9.mergeAxiosConfigs(sdkAssembly.axiosInstance.defaults, {
      ...baseURLOverride ? { baseURL: baseURLOverride } : {},
      ...requestConfigOverrides
    });
    axiosInstance = Network9.create(requestConfig);
    for (const interceptor of interceptorsOverride) {
      if (interceptor.type === "request") {
        axiosInstance.interceptors.request.use(interceptor.onRequest, interceptor.onError);
      }
      if (interceptor.type === "response") {
        axiosInstance.interceptors.response.use(interceptor.onSuccess, interceptor.onError);
      }
    }
  }
  async function deleteThirdpartyConfigSteam() {
    const $ = new ThirdPartyAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.deleteThirdpartyConfigSteam();
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getThirdpartyConfigSteam() {
    const $ = new ThirdPartyAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getThirdpartyConfigSteam();
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function createThirdpartyConfigSteam(data) {
    const $ = new ThirdPartyAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.createThirdpartyConfigSteam(data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function updateThirdpartyConfigSteam(data) {
    const $ = new ThirdPartyAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.updateThirdpartyConfigSteam(data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  return {
    /**
     * Required permission : &lt;code&gt;ADMIN:NAMESPACE:{namespace}:THIRDPARTY:CONFIG [DELETE]&lt;/code&gt; with scope &lt;code&gt;social&lt;/code&gt; &lt;br&gt;delete third party config in a namespace.
     */
    deleteThirdpartyConfigSteam,
    /**
     * Get third party config for specified namespace.
     */
    getThirdpartyConfigSteam,
    /**
     * Create third party config in a namespace.
     */
    createThirdpartyConfigSteam,
    /**
     * Update third party config in a namespace.
     */
    updateThirdpartyConfigSteam
  };
}

// src/generated-definitions/AppMessageDeclaration.ts
import { z as z49 } from "zod";
var AppMessageDeclaration = z49.object({
  Attributes: z49.array(z49.string()),
  Code: z49.string(),
  CodeName: z49.string(),
  Section: z49.string(),
  Service: z49.string(),
  Text: z49.string()
});

// src/generated-definitions/AppMessageDeclarationArray.ts
import { z as z50 } from "zod";
var AppMessageDeclarationArray = z50.array(AppMessageDeclaration);

// src/generated-definitions/BulkFriendsResponse.ts
import { z as z51 } from "zod";
var BulkFriendsResponse = z51.object({ rowsAffected: z51.number().int() });

// src/generated-definitions/GetUserFriendsResponse.ts
import { z as z52 } from "zod";
var GetUserFriendsResponse = z52.object({
  friendIDs: z52.array(z52.string()),
  friends: z52.array(FriendWithPlatform).nullish(),
  paging: Pagination
});

// src/generated-definitions/GetUserFriendsResponseArray.ts
import { z as z53 } from "zod";
var GetUserFriendsResponseArray = z53.array(GetUserFriendsResponse);

// src/generated-definitions/GetUserIncomingFriendsResponse.ts
import { z as z54 } from "zod";
var GetUserIncomingFriendsResponse = z54.object({ friendIDs: z54.array(z54.string()), paging: Pagination });

// src/generated-definitions/GetUserIncomingFriendsResponseArray.ts
import { z as z55 } from "zod";
var GetUserIncomingFriendsResponseArray = z55.array(GetUserIncomingFriendsResponse);

// src/generated-definitions/GetUserOutgoingFriendsResponse.ts
import { z as z56 } from "zod";
var GetUserOutgoingFriendsResponse = z56.object({ friendIDs: z56.array(z56.string()), paging: Pagination });

// src/generated-definitions/GetUserOutgoingFriendsResponseArray.ts
import { z as z57 } from "zod";
var GetUserOutgoingFriendsResponseArray = z57.array(GetUserOutgoingFriendsResponse);

// src/generated-definitions/UserPresence.ts
import { z as z58 } from "zod";
var UserPresence = z58.object({
  activity: z58.string(),
  availability: z58.string(),
  lastSeenAt: z58.string(),
  namespace: z58.string(),
  platform: z58.string(),
  userID: z58.string()
});

// src/generated-definitions/GetUsersPresenceResponse.ts
import { z as z59 } from "zod";
var GetUsersPresenceResponse = z59.object({
  away: z59.number().int(),
  busy: z59.number().int(),
  data: z59.array(UserPresence),
  invisible: z59.number().int(),
  offline: z59.number().int(),
  online: z59.number().int()
});

// src/generated-definitions/UserPlatformInfo.ts
import { z as z60 } from "zod";
var UserPlatformInfo = z60.object({ platformDisplayName: z60.string(), platformName: z60.string(), platformUserId: z60.string() });

// src/generated-definitions/UserWithPlatformInfo.ts
import { z as z61 } from "zod";
var UserWithPlatformInfo = z61.object({
  avatarUrl: z61.string(),
  displayName: z61.string(),
  platformInfos: z61.array(UserPlatformInfo),
  userId: z61.string(),
  username: z61.string().nullish()
});

// src/generated-definitions/ListBulkUserPlatformsResponse.ts
import { z as z62 } from "zod";
var ListBulkUserPlatformsResponse = z62.object({ data: z62.array(UserWithPlatformInfo) });

// src/generated-definitions/LoadIncomingFriendsWithTimeResponseArray.ts
import { z as z63 } from "zod";
var LoadIncomingFriendsWithTimeResponseArray = z63.array(LoadIncomingFriendsWithTimeResponse);

// src/generated-definitions/LoadOutgoingFriendsWithTimeResponseArray.ts
import { z as z64 } from "zod";
var LoadOutgoingFriendsWithTimeResponseArray = z64.array(LoadOutgoingFriendsWithTimeResponse);

// src/generated-definitions/NativeFriendSyncResponse.ts
import { z as z65 } from "zod";
var NativeFriendSyncResponse = z65.object({ detail: z65.string().nullish(), platformId: z65.string(), status: z65.string() });

// src/generated-definitions/NativeFriendSyncResponseArray.ts
import { z as z66 } from "zod";
var NativeFriendSyncResponseArray = z66.array(NativeFriendSyncResponse);

// src/generated-definitions/NativeUserBlockResponse.ts
import { z as z67 } from "zod";
var NativeUserBlockResponse = z67.object({ detail: z67.string().nullish(), platformId: z67.string(), status: z67.string() });

// src/generated-definitions/NativeUserBlockResponseArray.ts
import { z as z68 } from "zod";
var NativeUserBlockResponseArray = z68.array(NativeUserBlockResponse);

// src/generated-definitions/NotificationResponse.ts
import { z as z69 } from "zod";
var NotificationResponse = z69.object({
  from: z69.string().nullish(),
  id: z69.string().nullish(),
  lobbySessionID: z69.string().nullish(),
  loginType: z69.string().nullish(),
  payload: z69.string().nullish(),
  reconnectFromCode: z69.number().int().nullish(),
  sentAt: z69.string().nullish(),
  sequenceID: z69.number().int(),
  sequenceNumber: z69.number().int(),
  to: z69.string().nullish(),
  topic: z69.string().nullish(),
  type: z69.string()
});

// src/generated-definitions/NotificationTopicResponse.ts
import { z as z70 } from "zod";
var NotificationTopicResponse = z70.object({
  createdAt: z70.number().int(),
  description: z70.string(),
  namespace: z70.string(),
  topic: z70.string()
});

// src/generated-definitions/TemplateLocalization.ts
import { z as z71 } from "zod";
var TemplateLocalization = z71.object({
  lastDraftAt: z71.string(),
  lastPublishedAt: z71.string(),
  templateContent: TemplateContent,
  templateLanguage: z71.string(),
  templateSlug: z71.string()
});

// src/generated-definitions/TemplateLocalizationResponse.ts
import { z as z72 } from "zod";
var TemplateLocalizationResponse = z72.object({
  first: z72.string(),
  last: z72.string(),
  next: z72.string(),
  previous: z72.string(),
  templateLocalization: z72.array(TemplateLocalization)
});

// src/generated-definitions/TemplateResponse.ts
import { z as z73 } from "zod";
var TemplateResponse = z73.object({ localizations: z73.array(Localization), templateSlug: z73.string() });

// src/generated-definitions/TemplateResponseArray.ts
import { z as z74 } from "zod";
var TemplateResponseArray = z74.array(TemplateResponse);

// src/generated-definitions/TopicByNamespacesResponse.ts
import { z as z75 } from "zod";
var TopicByNamespacesResponse = z75.object({
  first: z75.string(),
  last: z75.string(),
  next: z75.string(),
  previous: z75.string(),
  topics: z75.array(NotificationTopicResponse)
});

// src/generated-definitions/UserGetFriendshipStatusResponse.ts
import { z as z76 } from "zod";
var UserGetFriendshipStatusResponse = z76.object({ code: z76.number().int(), name: z76.string() });

// src/generated-public/endpoints/Admin$.ts
import { Validate as Validate10 } from "@accelbyte/sdk";
import { z as z77 } from "zod";
var Admin$ = class {
  // @ts-ignore
  // prettier-ignore
  constructor(axiosInstance, namespace, useSchemaValidation = true) {
    this.axiosInstance = axiosInstance;
    this.namespace = namespace;
    this.useSchemaValidation = useSchemaValidation;
  }
  /**
   * Sends notification to all connected users in a namespace.
   */
  createNotificationFreeform(data) {
    const params = {};
    const url = "/notification/namespaces/{namespace}/freeform".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.post(url, data, { params });
    return Validate10.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, z77.unknown(), "z.unknown()");
  }
  /**
   * Sends notification to all connected users in a namespace with predefined template. &lt;br&gt;In the request body, specify which template slug (template identifier) to use and the template language. &lt;br&gt;NotificationTemplate context is the key-value pair defining the value of each handlebar specified in the template content. Template need to be published before it can be use to send notifications
   */
  createNotificationTemplated(data) {
    const params = {};
    const url = "/notification/namespaces/{namespace}/templated".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.post(url, data, { params });
    return Validate10.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, z77.unknown(), "z.unknown()");
  }
  /**
   * Get all templates in a namespace
   */
  getNotificationTemplates() {
    const params = {};
    const url = "/notification/namespaces/{namespace}/templates".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.get(url, { params });
    return Validate10.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, TemplateResponseArray, "TemplateResponseArray");
  }
  /**
   * Create new notification template. Include handlebars {{key}} for replaceable contexts. The the key inside handlebars will be the key to be replaced when sending notification. Already existing template with the same slug and language can not be created. &lt;br&gt;Check model description for detailed input restrictions.
   */
  createNotificationTemplate(data) {
    const params = {};
    const url = "/notification/namespaces/{namespace}/templates".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.post(url, data, { params });
    return Validate10.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, z77.unknown(), "z.unknown()");
  }
  /**
   * Delete localization template
   */
  deleteNotificationTemplate_ByTemplateSlug(templateSlug) {
    const params = {};
    const url = "/notification/namespaces/{namespace}/templates/{templateSlug}".replace("{namespace}", this.namespace).replace("{templateSlug}", templateSlug);
    const resultPromise = this.axiosInstance.delete(url, { params });
    return Validate10.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, z77.unknown(), "z.unknown()");
  }
  /**
   * Get all templates in a namespace
   */
  getNotificationTemplate_ByTemplateSlug(templateSlug, queryParams) {
    const params = { ...queryParams };
    const url = "/notification/namespaces/{namespace}/templates/{templateSlug}".replace("{namespace}", this.namespace).replace("{templateSlug}", templateSlug);
    const resultPromise = this.axiosInstance.get(url, { params });
    return Validate10.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      TemplateLocalizationResponse,
      "TemplateLocalizationResponse"
    );
  }
  /**
   * Delete all template in a slug
   */
  deleteLanguageNotification_ByTemplateSlug_ByTemplateLanguage(templateSlug, templateLanguage) {
    const params = {};
    const url = "/notification/namespaces/{namespace}/templates/{templateSlug}/languages/{templateLanguage}".replace("{namespace}", this.namespace).replace("{templateSlug}", templateSlug).replace("{templateLanguage}", templateLanguage);
    const resultPromise = this.axiosInstance.delete(url, { params });
    return Validate10.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, z77.unknown(), "z.unknown()");
  }
  /**
   * Get a template localization
   */
  getLanguageNotification_ByTemplateSlug_ByTemplateLanguage(templateSlug, templateLanguage) {
    const params = {};
    const url = "/notification/namespaces/{namespace}/templates/{templateSlug}/languages/{templateLanguage}".replace("{namespace}", this.namespace).replace("{templateSlug}", templateSlug).replace("{templateLanguage}", templateLanguage);
    const resultPromise = this.axiosInstance.get(url, { params });
    return Validate10.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, TemplateLocalization, "TemplateLocalization");
  }
  /**
   * Modify draft template
   */
  updateLanguageNotification_ByTemplateSlug_ByTemplateLanguage(templateSlug, templateLanguage, data) {
    const params = {};
    const url = "/notification/namespaces/{namespace}/templates/{templateSlug}/languages/{templateLanguage}".replace("{namespace}", this.namespace).replace("{templateSlug}", templateSlug).replace("{templateLanguage}", templateLanguage);
    const resultPromise = this.axiosInstance.put(url, data, { params });
    return Validate10.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, z77.unknown(), "z.unknown()");
  }
  /**
   * Publish notification template draft. Empty draft can not be published.
   */
  createPublishNotification_ByTemplateSlug_ByTemplateLanguage(templateSlug, templateLanguage) {
    const params = {};
    const url = "/notification/namespaces/{namespace}/templates/{templateSlug}/languages/{templateLanguage}/publish".replace("{namespace}", this.namespace).replace("{templateSlug}", templateSlug).replace("{templateLanguage}", templateLanguage);
    const resultPromise = this.axiosInstance.post(url, null, { params });
    return Validate10.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, z77.unknown(), "z.unknown()");
  }
};

// src/generated-public/AdminApi.ts
import { ApiUtils as ApiUtils10, Network as Network10 } from "@accelbyte/sdk";
function AdminApi(sdk, args) {
  const sdkAssembly = sdk.assembly();
  const namespace = args?.coreConfig?.namespace ?? sdkAssembly.coreConfig.namespace;
  const useSchemaValidation = args?.coreConfig?.useSchemaValidation ?? sdkAssembly.coreConfig.useSchemaValidation;
  let axiosInstance = sdkAssembly.axiosInstance;
  const requestConfigOverrides = args?.axiosConfig?.request;
  const baseURLOverride = args?.coreConfig?.baseURL;
  const interceptorsOverride = args?.axiosConfig?.interceptors ?? [];
  if (requestConfigOverrides || baseURLOverride || interceptorsOverride.length > 0) {
    const requestConfig = ApiUtils10.mergeAxiosConfigs(sdkAssembly.axiosInstance.defaults, {
      ...baseURLOverride ? { baseURL: baseURLOverride } : {},
      ...requestConfigOverrides
    });
    axiosInstance = Network10.create(requestConfig);
    for (const interceptor of interceptorsOverride) {
      if (interceptor.type === "request") {
        axiosInstance.interceptors.request.use(interceptor.onRequest, interceptor.onError);
      }
      if (interceptor.type === "response") {
        axiosInstance.interceptors.response.use(interceptor.onSuccess, interceptor.onError);
      }
    }
  }
  async function createNotificationFreeform(data) {
    const $ = new Admin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.createNotificationFreeform(data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function createNotificationTemplated(data) {
    const $ = new Admin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.createNotificationTemplated(data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getNotificationTemplates() {
    const $ = new Admin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getNotificationTemplates();
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function createNotificationTemplate(data) {
    const $ = new Admin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.createNotificationTemplate(data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function deleteNotificationTemplate_ByTemplateSlug(templateSlug) {
    const $ = new Admin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.deleteNotificationTemplate_ByTemplateSlug(templateSlug);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getNotificationTemplate_ByTemplateSlug(templateSlug, queryParams) {
    const $ = new Admin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getNotificationTemplate_ByTemplateSlug(templateSlug, queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function deleteLanguageNotification_ByTemplateSlug_ByTemplateLanguage(templateSlug, templateLanguage) {
    const $ = new Admin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.deleteLanguageNotification_ByTemplateSlug_ByTemplateLanguage(templateSlug, templateLanguage);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getLanguageNotification_ByTemplateSlug_ByTemplateLanguage(templateSlug, templateLanguage) {
    const $ = new Admin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getLanguageNotification_ByTemplateSlug_ByTemplateLanguage(templateSlug, templateLanguage);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function updateLanguageNotification_ByTemplateSlug_ByTemplateLanguage(templateSlug, templateLanguage, data) {
    const $ = new Admin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.updateLanguageNotification_ByTemplateSlug_ByTemplateLanguage(templateSlug, templateLanguage, data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function createPublishNotification_ByTemplateSlug_ByTemplateLanguage(templateSlug, templateLanguage) {
    const $ = new Admin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.createPublishNotification_ByTemplateSlug_ByTemplateLanguage(templateSlug, templateLanguage);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  return {
    /**
     * Sends notification to all connected users in a namespace.
     */
    createNotificationFreeform,
    /**
     * Sends notification to all connected users in a namespace with predefined template. &lt;br&gt;In the request body, specify which template slug (template identifier) to use and the template language. &lt;br&gt;NotificationTemplate context is the key-value pair defining the value of each handlebar specified in the template content. Template need to be published before it can be use to send notifications
     */
    createNotificationTemplated,
    /**
     * Get all templates in a namespace
     */
    getNotificationTemplates,
    /**
     * Create new notification template. Include handlebars {{key}} for replaceable contexts. The the key inside handlebars will be the key to be replaced when sending notification. Already existing template with the same slug and language can not be created. &lt;br&gt;Check model description for detailed input restrictions.
     */
    createNotificationTemplate,
    /**
     * Delete localization template
     */
    deleteNotificationTemplate_ByTemplateSlug,
    /**
     * Get all templates in a namespace
     */
    getNotificationTemplate_ByTemplateSlug,
    /**
     * Delete all template in a slug
     */
    deleteLanguageNotification_ByTemplateSlug_ByTemplateLanguage,
    /**
     * Get a template localization
     */
    getLanguageNotification_ByTemplateSlug_ByTemplateLanguage,
    /**
     * Modify draft template
     */
    updateLanguageNotification_ByTemplateSlug_ByTemplateLanguage,
    /**
     * Publish notification template draft. Empty draft can not be published.
     */
    createPublishNotification_ByTemplateSlug_ByTemplateLanguage
  };
}

// src/generated-public/endpoints/Blocks$.ts
import { Validate as Validate11 } from "@accelbyte/sdk";
var Blocks$ = class {
  // @ts-ignore
  // prettier-ignore
  constructor(axiosInstance, namespace, useSchemaValidation = true) {
    this.axiosInstance = axiosInstance;
    this.namespace = namespace;
    this.useSchemaValidation = useSchemaValidation;
  }
  /**
   * Sync blocked user using server to server call to native first party server. Supported platforms: ps5, ps4 and pspc : the default environment would be sp-int, can be override using psnEnv. psnEnv consist of sp-int (default), prod-qa, np
   */
  patchSyncMeBlock(data) {
    const params = {};
    const url = "/lobby/sync/namespaces/{namespace}/me/block".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.patch(url, data, { params });
    return Validate11.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      NativeUserBlockResponseArray,
      "NativeUserBlockResponseArray"
    );
  }
};

// src/generated-public/BlocksApi.ts
import { ApiUtils as ApiUtils11, Network as Network11 } from "@accelbyte/sdk";
function BlocksApi(sdk, args) {
  const sdkAssembly = sdk.assembly();
  const namespace = args?.coreConfig?.namespace ?? sdkAssembly.coreConfig.namespace;
  const useSchemaValidation = args?.coreConfig?.useSchemaValidation ?? sdkAssembly.coreConfig.useSchemaValidation;
  let axiosInstance = sdkAssembly.axiosInstance;
  const requestConfigOverrides = args?.axiosConfig?.request;
  const baseURLOverride = args?.coreConfig?.baseURL;
  const interceptorsOverride = args?.axiosConfig?.interceptors ?? [];
  if (requestConfigOverrides || baseURLOverride || interceptorsOverride.length > 0) {
    const requestConfig = ApiUtils11.mergeAxiosConfigs(sdkAssembly.axiosInstance.defaults, {
      ...baseURLOverride ? { baseURL: baseURLOverride } : {},
      ...requestConfigOverrides
    });
    axiosInstance = Network11.create(requestConfig);
    for (const interceptor of interceptorsOverride) {
      if (interceptor.type === "request") {
        axiosInstance.interceptors.request.use(interceptor.onRequest, interceptor.onError);
      }
      if (interceptor.type === "response") {
        axiosInstance.interceptors.response.use(interceptor.onSuccess, interceptor.onError);
      }
    }
  }
  async function patchSyncMeBlock(data) {
    const $ = new Blocks$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.patchSyncMeBlock(data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  return {
    /**
     * Sync blocked user using server to server call to native first party server. Supported platforms: ps5, ps4 and pspc : the default environment would be sp-int, can be override using psnEnv. psnEnv consist of sp-int (default), prod-qa, np
     */
    patchSyncMeBlock
  };
}

// src/generated-public/endpoints/Friends$.ts
import { Validate as Validate12 } from "@accelbyte/sdk";
import { z as z78 } from "zod";
var Friends$ = class {
  // @ts-ignore
  // prettier-ignore
  constructor(axiosInstance, namespace, useSchemaValidation = true) {
    this.axiosInstance = axiosInstance;
    this.namespace = namespace;
    this.useSchemaValidation = useSchemaValidation;
  }
  /**
   * Get list of friends in a namespace.
   */
  getFriendsMe(queryParams) {
    const params = { limit: 25, ...queryParams };
    const url = "/friends/namespaces/{namespace}/me".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.get(url, { params });
    return Validate12.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      GetUserFriendsResponseArray,
      "GetUserFriendsResponseArray"
    );
  }
  /**
   * Sync friends using server to server call to native first party server. Supported platforms: steam: The platform_token’s value is the binary ticket returned by Steam. If this ticket was generated by Steam GetAuthTicketForWebApi with version &gt;= 1.57, then platform token should use this style: {identity}:{ticket} the {identity} was the parameter to call GetAuthTicketForWebApi when the ticket was created. Note: Do not contain : in this {identity} ps4: The platform_token’s value is the authorization code returned by Sony OAuth. ps5: The platform_token’s value is the authorization code returned by Sony OAuth. pspc: The platform_token’s value is the authorization code returned by Sony OAuth.
   */
  patchFriendSyncMe(data) {
    const params = {};
    const url = "/friends/sync/namespaces/{namespace}/me".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.patch(url, data, { params });
    return Validate12.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      NativeFriendSyncResponseArray,
      "NativeFriendSyncResponseArray"
    );
  }
  /**
   * Client should provide either friendID or friendPublicID. If both are provided, friendID will be chosen to be used. This endpoint will only send a pending invite that can be either rejected/accepted
   */
  createFriendMeRequest(data) {
    const params = {};
    const url = "/friends/namespaces/{namespace}/me/request".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.post(url, data, { params });
    return Validate12.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, z78.unknown(), "z.unknown()");
  }
  /**
   * Get list of incoming friends in a namespace.
   */
  getFriendsMeIncoming(queryParams) {
    const params = { limit: 25, ...queryParams };
    const url = "/friends/namespaces/{namespace}/me/incoming".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.get(url, { params });
    return Validate12.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      GetUserIncomingFriendsResponseArray,
      "GetUserIncomingFriendsResponseArray"
    );
  }
  /**
   * Get list of outgoing friends in a namespace.
   */
  getFriendsMeOutgoing(queryParams) {
    const params = { limit: 25, ...queryParams };
    const url = "/friends/namespaces/{namespace}/me/outgoing".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.get(url, { params });
    return Validate12.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      GetUserOutgoingFriendsResponseArray,
      "GetUserOutgoingFriendsResponseArray"
    );
  }
  /**
   * User unfriend a friend.
   */
  createFriendMeUnfriend(data) {
    const params = {};
    const url = "/friends/namespaces/{namespace}/me/unfriend".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.post(url, data, { params });
    return Validate12.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, z78.unknown(), "z.unknown()");
  }
  /**
   * Get list of friends with platform data in a namespace.
   */
  getFriendsMePlatforms(queryParams) {
    const params = { limit: 25, ...queryParams };
    const url = "/friends/namespaces/{namespace}/me/platforms".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.get(url, { params });
    return Validate12.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      ListBulkUserPlatformsResponse,
      "ListBulkUserPlatformsResponse"
    );
  }
  /**
   * Get list of incoming friends with requested time info in a namespace.
   */
  getFriendsMeIncomingTime(queryParams) {
    const params = { limit: 25, ...queryParams };
    const url = "/friends/namespaces/{namespace}/me/incoming-time".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.get(url, { params });
    return Validate12.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      LoadIncomingFriendsWithTimeResponseArray,
      "LoadIncomingFriendsWithTimeResponseArray"
    );
  }
  /**
   * Get list of outgoing friends with requested time info in a namespace.
   */
  getFriendsMeOutgoingTime(queryParams) {
    const params = { limit: 25, ...queryParams };
    const url = "/friends/namespaces/{namespace}/me/outgoing-time".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.get(url, { params });
    return Validate12.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      LoadOutgoingFriendsWithTimeResponseArray,
      "LoadOutgoingFriendsWithTimeResponseArray"
    );
  }
  /**
   * User accept friend.
   */
  createFriendMeRequestAccept(data) {
    const params = {};
    const url = "/friends/namespaces/{namespace}/me/request/accept".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.post(url, data, { params });
    return Validate12.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, z78.unknown(), "z.unknown()");
  }
  /**
   * User cancel a friend request.
   */
  createFriendMeRequestCancel(data) {
    const params = {};
    const url = "/friends/namespaces/{namespace}/me/request/cancel".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.post(url, data, { params });
    return Validate12.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, z78.unknown(), "z.unknown()");
  }
  /**
   * User reject a friend request.
   */
  createFriendMeRequestReject(data) {
    const params = {};
    const url = "/friends/namespaces/{namespace}/me/request/reject".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.post(url, data, { params });
    return Validate12.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, z78.unknown(), "z.unknown()");
  }
  /**
   * User get friendship status. Code: 0 - Message: &#34;not friend&#34; Code: 1 - Message: &#34;outgoing&#34; Code: 2 - Message: &#34;incoming&#34; Code: 3 - Message: &#34;friend&#34;
   */
  getFriendMeStatu_ByFriendId(friendId) {
    const params = {};
    const url = "/friends/namespaces/{namespace}/me/status/{friendId}".replace("{namespace}", this.namespace).replace("{friendId}", friendId);
    const resultPromise = this.axiosInstance.get(url, { params });
    return Validate12.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      UserGetFriendshipStatusResponse,
      "UserGetFriendshipStatusResponse"
    );
  }
  /**
   * Friends request in a namespace.
   */
  createAddBulkFriend_ByUserId(userId, data) {
    const params = {};
    const url = "/friends/namespaces/{namespace}/users/{userId}/add/bulk".replace("{namespace}", this.namespace).replace("{userId}", userId);
    const resultPromise = this.axiosInstance.post(url, data, { params });
    return Validate12.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, z78.unknown(), "z.unknown()");
  }
  /**
   * Friends request in a namespace.
   */
  createDeleteBulkFriend_ByUserId(userId, data) {
    const params = {};
    const url = "/friends/namespaces/{namespace}/users/{userId}/delete/bulk".replace("{namespace}", this.namespace).replace("{userId}", userId);
    const resultPromise = this.axiosInstance.post(url, data, { params });
    return Validate12.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, BulkFriendsResponse, "BulkFriendsResponse");
  }
};

// src/generated-public/endpoints/LobbyOperations$.ts
import { Validate as Validate13 } from "@accelbyte/sdk";
var LobbyOperations$ = class {
  // @ts-ignore
  // prettier-ignore
  constructor(axiosInstance, namespace, useSchemaValidation = true) {
    this.axiosInstance = axiosInstance;
    this.namespace = namespace;
    this.useSchemaValidation = useSchemaValidation;
  }
  /**
   * get the list of messages.
   */
  getMessages() {
    const params = {};
    const url = "/lobby/v1/messages";
    const resultPromise = this.axiosInstance.get(url, { params });
    return Validate13.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      AppMessageDeclarationArray,
      "AppMessageDeclarationArray"
    );
  }
};

// src/generated-public/endpoints/Notification$.ts
import { Validate as Validate14 } from "@accelbyte/sdk";
import { z as z79 } from "zod";
var Notification$ = class {
  // @ts-ignore
  // prettier-ignore
  constructor(axiosInstance, namespace, useSchemaValidation = true) {
    this.axiosInstance = axiosInstance;
    this.namespace = namespace;
    this.useSchemaValidation = useSchemaValidation;
  }
  /**
   * Get list of notifications in a namespace. The query parameters **startTime** and **endTime** can be filled with the **sequenceID** value in the notification, where the value is an epoch timestamp. Example **sequenceID** or epoch timestamp value: **1706595813**
   */
  getNotificationMe(queryParams) {
    const params = { limit: 25, ...queryParams };
    const url = "/notification/namespaces/{namespace}/me".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.get(url, { params });
    return Validate14.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, NotificationResponse, "NotificationResponse");
  }
  /**
   * get topic by namespace.
   */
  getNotificationTopics(queryParams) {
    const params = { ...queryParams };
    const url = "/notification/namespaces/{namespace}/topics".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.get(url, { params });
    return Validate14.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      TopicByNamespacesResponse,
      "TopicByNamespacesResponse"
    );
  }
  /**
   * Create new notification topic. &lt;br&gt;topic should be alphabets, no special char except underscore, uppercase and no spacing. for example: TOPIC_TEST. Already existing topic can not be created
   */
  createNotificationTopic(data) {
    const params = {};
    const url = "/notification/namespaces/{namespace}/topics".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.post(url, data, { params });
    return Validate14.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, z79.unknown(), "z.unknown()");
  }
  /**
   * delete topic information by topic name. &lt;br&gt;topic should be alphabets, no special char except underscore, uppercase and no spacing. for example: TOPIC_TEST. Already existing topic can not be created
   */
  deleteNotificationTopic_ByTopic(topic) {
    const params = {};
    const url = "/notification/namespaces/{namespace}/topics/{topic}".replace("{namespace}", this.namespace).replace("{topic}", topic);
    const resultPromise = this.axiosInstance.delete(url, { params });
    return Validate14.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, z79.unknown(), "z.unknown()");
  }
  /**
   * get topic information by topic name.
   */
  getNotificationTopic_ByTopic(topic) {
    const params = {};
    const url = "/notification/namespaces/{namespace}/topics/{topic}".replace("{namespace}", this.namespace).replace("{topic}", topic);
    const resultPromise = this.axiosInstance.get(url, { params });
    return Validate14.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      NotificationTopicResponse,
      "NotificationTopicResponse"
    );
  }
  /**
   * update topic information by topic name. &lt;br&gt;topic should be alphabets, no special char except underscore, uppercase and no spacing. for example: TOPIC_TEST. Already existing topic can not be created
   */
  updateNotificationTopic_ByTopic(topic, data) {
    const params = {};
    const url = "/notification/namespaces/{namespace}/topics/{topic}".replace("{namespace}", this.namespace).replace("{topic}", topic);
    const resultPromise = this.axiosInstance.put(url, data, { params });
    return Validate14.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, z79.unknown(), "z.unknown()");
  }
  /**
   * Sends notification to a user.
   */
  createFreeformNotification_ByUserId(userId, data) {
    const params = {};
    const url = "/notification/namespaces/{namespace}/users/{userId}/freeform".replace("{namespace}", this.namespace).replace("{userId}", userId);
    const resultPromise = this.axiosInstance.post(url, data, { params });
    return Validate14.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, z79.unknown(), "z.unknown()");
  }
  /**
   * Sends notification to a user with predefined template. &lt;br&gt;In the request body, specify which template slug (template identifier) to use and the template language. &lt;br&gt;NotificationTemplate context is the key-value pair defining the value of each handlebar specified in the template content. Template need to be published before it can be use to send notifications
   */
  createTemplatedNotification_ByUserId(userId, data) {
    const params = {};
    const url = "/notification/namespaces/{namespace}/users/{userId}/templated".replace("{namespace}", this.namespace).replace("{userId}", userId);
    const resultPromise = this.axiosInstance.post(url, data, { params });
    return Validate14.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, z79.unknown(), "z.unknown()");
  }
};

// src/generated-public/endpoints/Party$.ts
import { Validate as Validate15 } from "@accelbyte/sdk";
import { z as z80 } from "zod";
var Party$ = class {
  // @ts-ignore
  // prettier-ignore
  constructor(axiosInstance, namespace, useSchemaValidation = true) {
    this.axiosInstance = axiosInstance;
    this.namespace = namespace;
    this.useSchemaValidation = useSchemaValidation;
  }
  /**
   * Required valid user authorization &lt;br/&gt; &lt;br&gt;load personal party data in a namespace based on Party ID &lt;br/&gt; Action Code: 50101
   */
  getPartyParty_ByPartyId(partyId) {
    const params = {};
    const url = "/lobby/v1/public/party/namespaces/{namespace}/parties/{partyId}".replace("{namespace}", this.namespace).replace("{partyId}", partyId);
    const resultPromise = this.axiosInstance.get(url, { params });
    return Validate15.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, PartyData, "PartyData");
  }
  /**
   * Required valid user authorization &lt;br/&gt; &lt;br&gt;Set party limit, only party leader can call this endpoint.
   */
  updateLimitParty_ByPartyId(partyId, data) {
    const params = {};
    const url = "/lobby/v1/public/party/namespaces/{namespace}/parties/{partyId}/limit".replace("{namespace}", this.namespace).replace("{partyId}", partyId);
    const resultPromise = this.axiosInstance.put(url, data, { params });
    return Validate15.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, z80.unknown(), "z.unknown()");
  }
  /**
   * Required valid user authorization &lt;br/&gt; &lt;br&gt;update party attributes in a namespace.
   */
  updateAttributeParty_ByPartyId(partyId, data) {
    const params = {};
    const url = "/lobby/v1/public/party/namespaces/{namespace}/parties/{partyId}/attributes".replace("{namespace}", this.namespace).replace("{partyId}", partyId);
    const resultPromise = this.axiosInstance.put(url, data, { params });
    return Validate15.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, PartyData, "PartyData");
  }
};

// src/generated-public/endpoints/Player$.ts
import { Validate as Validate16 } from "@accelbyte/sdk";
import { z as z81 } from "zod";
var Player$ = class {
  // @ts-ignore
  // prettier-ignore
  constructor(axiosInstance, namespace, useSchemaValidation = true) {
    this.axiosInstance = axiosInstance;
    this.namespace = namespace;
    this.useSchemaValidation = useSchemaValidation;
  }
  /**
   * Required valid user authorization &lt;br/&gt; &lt;br&gt;add blocked players in a namespace based on user id &lt;br/&gt;
   */
  createPlayerUserMeBlock(data) {
    const params = {};
    const url = "/lobby/v1/public/player/namespaces/{namespace}/users/me/block".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.post(url, data, { params });
    return Validate16.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, z81.unknown(), "z.unknown()");
  }
  /**
   * Required valid user authorization &lt;br/&gt; &lt;br&gt;load blocked players in a namespace based on user id &lt;br/&gt; Action Code: 50101
   */
  getPlayerUsersMeBlocked() {
    const params = {};
    const url = "/lobby/v1/public/player/namespaces/{namespace}/users/me/blocked".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.get(url, { params });
    return Validate16.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      GetAllPlayerBlockedUsersResponse,
      "GetAllPlayerBlockedUsersResponse"
    );
  }
  /**
   * Required valid user authorization &lt;br/&gt; unblock player in a namespace based on user id &lt;br/&gt;
   */
  createPlayerUserMeUnblock(data) {
    const params = {};
    const url = "/lobby/v1/public/player/namespaces/{namespace}/users/me/unblock".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.post(url, data, { params });
    return Validate16.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, z81.unknown(), "z.unknown()");
  }
  /**
   * Required valid user authorization &lt;br/&gt; &lt;br&gt;load get players who blocked this player in a namespace based on user id &lt;br/&gt; Action Code: 50101
   */
  getPlayerUsersMeBlockedBy() {
    const params = {};
    const url = "/lobby/v1/public/player/namespaces/{namespace}/users/me/blocked-by".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.get(url, { params });
    return Validate16.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      GetAllPlayerBlockedByUsersResponse,
      "GetAllPlayerBlockedByUsersResponse"
    );
  }
};

// src/generated-public/endpoints/Presence$.ts
import { Validate as Validate17 } from "@accelbyte/sdk";
var Presence$ = class {
  // @ts-ignore
  // prettier-ignore
  constructor(axiosInstance, namespace, useSchemaValidation = true) {
    this.axiosInstance = axiosInstance;
    this.namespace = namespace;
    this.useSchemaValidation = useSchemaValidation;
  }
  /**
   * Query users presence with given namespace and userIds.
   */
  getPresenceUsersPresence(queryParams) {
    const params = { ...queryParams };
    const url = "/lobby/v1/public/presence/namespaces/{namespace}/users/presence".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.get(url, { params });
    return Validate17.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      GetUsersPresenceResponse,
      "GetUsersPresenceResponse"
    );
  }
  /**
   * Query users presence with given namespace and userIds.
   */
  createPresenceUserPresence(data, queryParams) {
    const params = { ...queryParams };
    const url = "/lobby/v1/public/presence/namespaces/{namespace}/users/presence".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.post(url, data, { params });
    return Validate17.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      GetUsersPresenceResponse,
      "GetUsersPresenceResponse"
    );
  }
};

// src/generated-public/FriendsApi.ts
import { ApiUtils as ApiUtils12, Network as Network12 } from "@accelbyte/sdk";
function FriendsApi(sdk, args) {
  const sdkAssembly = sdk.assembly();
  const namespace = args?.coreConfig?.namespace ?? sdkAssembly.coreConfig.namespace;
  const useSchemaValidation = args?.coreConfig?.useSchemaValidation ?? sdkAssembly.coreConfig.useSchemaValidation;
  let axiosInstance = sdkAssembly.axiosInstance;
  const requestConfigOverrides = args?.axiosConfig?.request;
  const baseURLOverride = args?.coreConfig?.baseURL;
  const interceptorsOverride = args?.axiosConfig?.interceptors ?? [];
  if (requestConfigOverrides || baseURLOverride || interceptorsOverride.length > 0) {
    const requestConfig = ApiUtils12.mergeAxiosConfigs(sdkAssembly.axiosInstance.defaults, {
      ...baseURLOverride ? { baseURL: baseURLOverride } : {},
      ...requestConfigOverrides
    });
    axiosInstance = Network12.create(requestConfig);
    for (const interceptor of interceptorsOverride) {
      if (interceptor.type === "request") {
        axiosInstance.interceptors.request.use(interceptor.onRequest, interceptor.onError);
      }
      if (interceptor.type === "response") {
        axiosInstance.interceptors.response.use(interceptor.onSuccess, interceptor.onError);
      }
    }
  }
  async function getFriendsMe(queryParams) {
    const $ = new Friends$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getFriendsMe(queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function patchFriendSyncMe(data) {
    const $ = new Friends$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.patchFriendSyncMe(data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function createFriendMeRequest(data) {
    const $ = new Friends$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.createFriendMeRequest(data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getFriendsMeIncoming(queryParams) {
    const $ = new Friends$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getFriendsMeIncoming(queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getFriendsMeOutgoing(queryParams) {
    const $ = new Friends$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getFriendsMeOutgoing(queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function createFriendMeUnfriend(data) {
    const $ = new Friends$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.createFriendMeUnfriend(data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getFriendsMePlatforms(queryParams) {
    const $ = new Friends$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getFriendsMePlatforms(queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getFriendsMeIncomingTime(queryParams) {
    const $ = new Friends$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getFriendsMeIncomingTime(queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getFriendsMeOutgoingTime(queryParams) {
    const $ = new Friends$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getFriendsMeOutgoingTime(queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function createFriendMeRequestAccept(data) {
    const $ = new Friends$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.createFriendMeRequestAccept(data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function createFriendMeRequestCancel(data) {
    const $ = new Friends$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.createFriendMeRequestCancel(data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function createFriendMeRequestReject(data) {
    const $ = new Friends$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.createFriendMeRequestReject(data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getFriendMeStatu_ByFriendId(friendId) {
    const $ = new Friends$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getFriendMeStatu_ByFriendId(friendId);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function createAddBulkFriend_ByUserId(userId, data) {
    const $ = new Friends$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.createAddBulkFriend_ByUserId(userId, data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function createDeleteBulkFriend_ByUserId(userId, data) {
    const $ = new Friends$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.createDeleteBulkFriend_ByUserId(userId, data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  return {
    /**
     * Get list of friends in a namespace.
     */
    getFriendsMe,
    /**
     * Sync friends using server to server call to native first party server. Supported platforms: steam: The platform_token’s value is the binary ticket returned by Steam. If this ticket was generated by Steam GetAuthTicketForWebApi with version &gt;= 1.57, then platform token should use this style: {identity}:{ticket} the {identity} was the parameter to call GetAuthTicketForWebApi when the ticket was created. Note: Do not contain : in this {identity} ps4: The platform_token’s value is the authorization code returned by Sony OAuth. ps5: The platform_token’s value is the authorization code returned by Sony OAuth. pspc: The platform_token’s value is the authorization code returned by Sony OAuth.
     */
    patchFriendSyncMe,
    /**
     * Client should provide either friendID or friendPublicID. If both are provided, friendID will be chosen to be used. This endpoint will only send a pending invite that can be either rejected/accepted
     */
    createFriendMeRequest,
    /**
     * Get list of incoming friends in a namespace.
     */
    getFriendsMeIncoming,
    /**
     * Get list of outgoing friends in a namespace.
     */
    getFriendsMeOutgoing,
    /**
     * User unfriend a friend.
     */
    createFriendMeUnfriend,
    /**
     * Get list of friends with platform data in a namespace.
     */
    getFriendsMePlatforms,
    /**
     * Get list of incoming friends with requested time info in a namespace.
     */
    getFriendsMeIncomingTime,
    /**
     * Get list of outgoing friends with requested time info in a namespace.
     */
    getFriendsMeOutgoingTime,
    /**
     * User accept friend.
     */
    createFriendMeRequestAccept,
    /**
     * User cancel a friend request.
     */
    createFriendMeRequestCancel,
    /**
     * User reject a friend request.
     */
    createFriendMeRequestReject,
    /**
     * User get friendship status. Code: 0 - Message: &#34;not friend&#34; Code: 1 - Message: &#34;outgoing&#34; Code: 2 - Message: &#34;incoming&#34; Code: 3 - Message: &#34;friend&#34;
     */
    getFriendMeStatu_ByFriendId,
    /**
     * Friends request in a namespace.
     */
    createAddBulkFriend_ByUserId,
    /**
     * Friends request in a namespace.
     */
    createDeleteBulkFriend_ByUserId
  };
}

// src/generated-public/LobbyOperationsApi.ts
import { ApiUtils as ApiUtils13, Network as Network13 } from "@accelbyte/sdk";
function LobbyOperationsApi(sdk, args) {
  const sdkAssembly = sdk.assembly();
  const namespace = args?.coreConfig?.namespace ?? sdkAssembly.coreConfig.namespace;
  const useSchemaValidation = args?.coreConfig?.useSchemaValidation ?? sdkAssembly.coreConfig.useSchemaValidation;
  let axiosInstance = sdkAssembly.axiosInstance;
  const requestConfigOverrides = args?.axiosConfig?.request;
  const baseURLOverride = args?.coreConfig?.baseURL;
  const interceptorsOverride = args?.axiosConfig?.interceptors ?? [];
  if (requestConfigOverrides || baseURLOverride || interceptorsOverride.length > 0) {
    const requestConfig = ApiUtils13.mergeAxiosConfigs(sdkAssembly.axiosInstance.defaults, {
      ...baseURLOverride ? { baseURL: baseURLOverride } : {},
      ...requestConfigOverrides
    });
    axiosInstance = Network13.create(requestConfig);
    for (const interceptor of interceptorsOverride) {
      if (interceptor.type === "request") {
        axiosInstance.interceptors.request.use(interceptor.onRequest, interceptor.onError);
      }
      if (interceptor.type === "response") {
        axiosInstance.interceptors.response.use(interceptor.onSuccess, interceptor.onError);
      }
    }
  }
  async function getMessages() {
    const $ = new LobbyOperations$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getMessages();
    if (resp.error) throw resp.error;
    return resp.response;
  }
  return {
    /**
     * get the list of messages.
     */
    getMessages
  };
}

// src/generated-public/NotificationApi.ts
import { ApiUtils as ApiUtils14, Network as Network14 } from "@accelbyte/sdk";
function NotificationApi(sdk, args) {
  const sdkAssembly = sdk.assembly();
  const namespace = args?.coreConfig?.namespace ?? sdkAssembly.coreConfig.namespace;
  const useSchemaValidation = args?.coreConfig?.useSchemaValidation ?? sdkAssembly.coreConfig.useSchemaValidation;
  let axiosInstance = sdkAssembly.axiosInstance;
  const requestConfigOverrides = args?.axiosConfig?.request;
  const baseURLOverride = args?.coreConfig?.baseURL;
  const interceptorsOverride = args?.axiosConfig?.interceptors ?? [];
  if (requestConfigOverrides || baseURLOverride || interceptorsOverride.length > 0) {
    const requestConfig = ApiUtils14.mergeAxiosConfigs(sdkAssembly.axiosInstance.defaults, {
      ...baseURLOverride ? { baseURL: baseURLOverride } : {},
      ...requestConfigOverrides
    });
    axiosInstance = Network14.create(requestConfig);
    for (const interceptor of interceptorsOverride) {
      if (interceptor.type === "request") {
        axiosInstance.interceptors.request.use(interceptor.onRequest, interceptor.onError);
      }
      if (interceptor.type === "response") {
        axiosInstance.interceptors.response.use(interceptor.onSuccess, interceptor.onError);
      }
    }
  }
  async function getNotificationMe(queryParams) {
    const $ = new Notification$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getNotificationMe(queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getNotificationTopics(queryParams) {
    const $ = new Notification$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getNotificationTopics(queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function createNotificationTopic(data) {
    const $ = new Notification$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.createNotificationTopic(data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function deleteNotificationTopic_ByTopic(topic) {
    const $ = new Notification$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.deleteNotificationTopic_ByTopic(topic);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getNotificationTopic_ByTopic(topic) {
    const $ = new Notification$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getNotificationTopic_ByTopic(topic);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function updateNotificationTopic_ByTopic(topic, data) {
    const $ = new Notification$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.updateNotificationTopic_ByTopic(topic, data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function createFreeformNotification_ByUserId(userId, data) {
    const $ = new Notification$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.createFreeformNotification_ByUserId(userId, data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function createTemplatedNotification_ByUserId(userId, data) {
    const $ = new Notification$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.createTemplatedNotification_ByUserId(userId, data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  return {
    /**
     * Get list of notifications in a namespace. The query parameters **startTime** and **endTime** can be filled with the **sequenceID** value in the notification, where the value is an epoch timestamp. Example **sequenceID** or epoch timestamp value: **1706595813**
     */
    getNotificationMe,
    /**
     * get topic by namespace.
     */
    getNotificationTopics,
    /**
     * Create new notification topic. &lt;br&gt;topic should be alphabets, no special char except underscore, uppercase and no spacing. for example: TOPIC_TEST. Already existing topic can not be created
     */
    createNotificationTopic,
    /**
     * delete topic information by topic name. &lt;br&gt;topic should be alphabets, no special char except underscore, uppercase and no spacing. for example: TOPIC_TEST. Already existing topic can not be created
     */
    deleteNotificationTopic_ByTopic,
    /**
     * get topic information by topic name.
     */
    getNotificationTopic_ByTopic,
    /**
     * update topic information by topic name. &lt;br&gt;topic should be alphabets, no special char except underscore, uppercase and no spacing. for example: TOPIC_TEST. Already existing topic can not be created
     */
    updateNotificationTopic_ByTopic,
    /**
     * Sends notification to a user.
     */
    createFreeformNotification_ByUserId,
    /**
     * Sends notification to a user with predefined template. &lt;br&gt;In the request body, specify which template slug (template identifier) to use and the template language. &lt;br&gt;NotificationTemplate context is the key-value pair defining the value of each handlebar specified in the template content. Template need to be published before it can be use to send notifications
     */
    createTemplatedNotification_ByUserId
  };
}

// src/generated-public/PartyApi.ts
import { ApiUtils as ApiUtils15, Network as Network15 } from "@accelbyte/sdk";
function PartyApi(sdk, args) {
  const sdkAssembly = sdk.assembly();
  const namespace = args?.coreConfig?.namespace ?? sdkAssembly.coreConfig.namespace;
  const useSchemaValidation = args?.coreConfig?.useSchemaValidation ?? sdkAssembly.coreConfig.useSchemaValidation;
  let axiosInstance = sdkAssembly.axiosInstance;
  const requestConfigOverrides = args?.axiosConfig?.request;
  const baseURLOverride = args?.coreConfig?.baseURL;
  const interceptorsOverride = args?.axiosConfig?.interceptors ?? [];
  if (requestConfigOverrides || baseURLOverride || interceptorsOverride.length > 0) {
    const requestConfig = ApiUtils15.mergeAxiosConfigs(sdkAssembly.axiosInstance.defaults, {
      ...baseURLOverride ? { baseURL: baseURLOverride } : {},
      ...requestConfigOverrides
    });
    axiosInstance = Network15.create(requestConfig);
    for (const interceptor of interceptorsOverride) {
      if (interceptor.type === "request") {
        axiosInstance.interceptors.request.use(interceptor.onRequest, interceptor.onError);
      }
      if (interceptor.type === "response") {
        axiosInstance.interceptors.response.use(interceptor.onSuccess, interceptor.onError);
      }
    }
  }
  async function getPartyParty_ByPartyId(partyId) {
    const $ = new Party$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getPartyParty_ByPartyId(partyId);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function updateLimitParty_ByPartyId(partyId, data) {
    const $ = new Party$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.updateLimitParty_ByPartyId(partyId, data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function updateAttributeParty_ByPartyId(partyId, data) {
    const $ = new Party$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.updateAttributeParty_ByPartyId(partyId, data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  return {
    /**
     * Required valid user authorization &lt;br/&gt; &lt;br&gt;load personal party data in a namespace based on Party ID &lt;br/&gt; Action Code: 50101
     */
    getPartyParty_ByPartyId,
    /**
     * Required valid user authorization &lt;br/&gt; &lt;br&gt;Set party limit, only party leader can call this endpoint.
     */
    updateLimitParty_ByPartyId,
    /**
     * Required valid user authorization &lt;br/&gt; &lt;br&gt;update party attributes in a namespace.
     */
    updateAttributeParty_ByPartyId
  };
}

// src/generated-public/PlayerApi.ts
import { ApiUtils as ApiUtils16, Network as Network16 } from "@accelbyte/sdk";
function PlayerApi(sdk, args) {
  const sdkAssembly = sdk.assembly();
  const namespace = args?.coreConfig?.namespace ?? sdkAssembly.coreConfig.namespace;
  const useSchemaValidation = args?.coreConfig?.useSchemaValidation ?? sdkAssembly.coreConfig.useSchemaValidation;
  let axiosInstance = sdkAssembly.axiosInstance;
  const requestConfigOverrides = args?.axiosConfig?.request;
  const baseURLOverride = args?.coreConfig?.baseURL;
  const interceptorsOverride = args?.axiosConfig?.interceptors ?? [];
  if (requestConfigOverrides || baseURLOverride || interceptorsOverride.length > 0) {
    const requestConfig = ApiUtils16.mergeAxiosConfigs(sdkAssembly.axiosInstance.defaults, {
      ...baseURLOverride ? { baseURL: baseURLOverride } : {},
      ...requestConfigOverrides
    });
    axiosInstance = Network16.create(requestConfig);
    for (const interceptor of interceptorsOverride) {
      if (interceptor.type === "request") {
        axiosInstance.interceptors.request.use(interceptor.onRequest, interceptor.onError);
      }
      if (interceptor.type === "response") {
        axiosInstance.interceptors.response.use(interceptor.onSuccess, interceptor.onError);
      }
    }
  }
  async function createPlayerUserMeBlock(data) {
    const $ = new Player$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.createPlayerUserMeBlock(data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getPlayerUsersMeBlocked() {
    const $ = new Player$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getPlayerUsersMeBlocked();
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function createPlayerUserMeUnblock(data) {
    const $ = new Player$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.createPlayerUserMeUnblock(data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getPlayerUsersMeBlockedBy() {
    const $ = new Player$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getPlayerUsersMeBlockedBy();
    if (resp.error) throw resp.error;
    return resp.response;
  }
  return {
    /**
     * Required valid user authorization &lt;br/&gt; &lt;br&gt;add blocked players in a namespace based on user id &lt;br/&gt;
     */
    createPlayerUserMeBlock,
    /**
     * Required valid user authorization &lt;br/&gt; &lt;br&gt;load blocked players in a namespace based on user id &lt;br/&gt; Action Code: 50101
     */
    getPlayerUsersMeBlocked,
    /**
     * Required valid user authorization &lt;br/&gt; unblock player in a namespace based on user id &lt;br/&gt;
     */
    createPlayerUserMeUnblock,
    /**
     * Required valid user authorization &lt;br/&gt; &lt;br&gt;load get players who blocked this player in a namespace based on user id &lt;br/&gt; Action Code: 50101
     */
    getPlayerUsersMeBlockedBy
  };
}

// src/generated-public/PresenceApi.ts
import { ApiUtils as ApiUtils17, Network as Network17 } from "@accelbyte/sdk";
function PresenceApi(sdk, args) {
  const sdkAssembly = sdk.assembly();
  const namespace = args?.coreConfig?.namespace ?? sdkAssembly.coreConfig.namespace;
  const useSchemaValidation = args?.coreConfig?.useSchemaValidation ?? sdkAssembly.coreConfig.useSchemaValidation;
  let axiosInstance = sdkAssembly.axiosInstance;
  const requestConfigOverrides = args?.axiosConfig?.request;
  const baseURLOverride = args?.coreConfig?.baseURL;
  const interceptorsOverride = args?.axiosConfig?.interceptors ?? [];
  if (requestConfigOverrides || baseURLOverride || interceptorsOverride.length > 0) {
    const requestConfig = ApiUtils17.mergeAxiosConfigs(sdkAssembly.axiosInstance.defaults, {
      ...baseURLOverride ? { baseURL: baseURLOverride } : {},
      ...requestConfigOverrides
    });
    axiosInstance = Network17.create(requestConfig);
    for (const interceptor of interceptorsOverride) {
      if (interceptor.type === "request") {
        axiosInstance.interceptors.request.use(interceptor.onRequest, interceptor.onError);
      }
      if (interceptor.type === "response") {
        axiosInstance.interceptors.response.use(interceptor.onSuccess, interceptor.onError);
      }
    }
  }
  async function getPresenceUsersPresence(queryParams) {
    const $ = new Presence$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getPresenceUsersPresence(queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function createPresenceUserPresence(data, queryParams) {
    const $ = new Presence$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.createPresenceUserPresence(data, queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  return {
    /**
     * Query users presence with given namespace and userIds.
     */
    getPresenceUsersPresence,
    /**
     * Query users presence with given namespace and userIds.
     */
    createPresenceUserPresence
  };
}

export {
  GlobalConfiguration,
  AdminAdmin$,
  AdminAdminApi,
  Config,
  ConfigList,
  ConfigReq,
  Configuration,
  ImportConfigResponse,
  ConfigAdmin$,
  ConfigAdminApi,
  FriendshipConnection,
  Pagination,
  FriendshipConnectionResponse,
  FriendWithPlatform,
  GetFriendsResponse,
  IncomingFriendsWithTimeData,
  LoadIncomingFriendsWithTimeResponse,
  OutgoingFriendsWithTimeData,
  LoadOutgoingFriendsWithTimeResponse,
  FriendsAdmin$,
  PartyData,
  LobbyOperationsAdmin$,
  TemplateContent,
  Localization,
  GetAllNotificationTemplateSlugResp,
  NotificationTopicResponseV1,
  GetAllNotificationTopicsResponse,
  NotificationTemplateResponse,
  NotificationTemplateResponseArray,
  NotificationAdmin$,
  PartyAdmin$,
  BlockedByPlayerData,
  GetAllPlayerBlockedByUsersResponse,
  BlockedPlayerData,
  GetAllPlayerBlockedUsersResponse,
  GetAllPlayerSessionAttributeResponse,
  GetBulkAllPlayerBlockedUsersResponse,
  GetLobbyCcuResponse,
  GetPlayerSessionAttributeResponse,
  PlayerAdmin$,
  ProfanityFilter,
  AdminGetProfanityListFiltersV1Response,
  AdminGetProfanityListsListResponse,
  AdminGetProfanityListsListResponseArray,
  AdminVerifyMessageProfanityResponse,
  ProfanityFilterArray,
  ProfanityRule,
  ProfanityAdmin$,
  CreateConfigResponse,
  GetConfigResponse,
  UpdateConfigResponse,
  ThirdPartyAdmin$,
  FriendsAdminApi,
  LobbyOperationsAdminApi,
  NotificationAdminApi,
  PartyAdminApi,
  PlayerAdminApi,
  ProfanityAdminApi,
  ThirdPartyAdminApi,
  AppMessageDeclaration,
  AppMessageDeclarationArray,
  BulkFriendsResponse,
  GetUserFriendsResponse,
  GetUserFriendsResponseArray,
  GetUserIncomingFriendsResponse,
  GetUserIncomingFriendsResponseArray,
  GetUserOutgoingFriendsResponse,
  GetUserOutgoingFriendsResponseArray,
  UserPresence,
  GetUsersPresenceResponse,
  UserPlatformInfo,
  UserWithPlatformInfo,
  ListBulkUserPlatformsResponse,
  LoadIncomingFriendsWithTimeResponseArray,
  LoadOutgoingFriendsWithTimeResponseArray,
  NativeFriendSyncResponse,
  NativeFriendSyncResponseArray,
  NativeUserBlockResponse,
  NativeUserBlockResponseArray,
  NotificationResponse,
  NotificationTopicResponse,
  TemplateLocalization,
  TemplateLocalizationResponse,
  TemplateResponse,
  TemplateResponseArray,
  TopicByNamespacesResponse,
  UserGetFriendshipStatusResponse,
  Admin$,
  AdminApi,
  Blocks$,
  BlocksApi,
  Friends$,
  LobbyOperations$,
  Notification$,
  Party$,
  Player$,
  Presence$,
  FriendsApi,
  LobbyOperationsApi,
  NotificationApi,
  PartyApi,
  PlayerApi,
  PresenceApi
};

"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name2 in all)
    __defProp(target, name2, { get: all[name2], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/index.ts
var src_exports = {};
__export(src_exports, {
  Admin$: () => Admin$,
  AdminAddProfanityFilterIntoListRequest: () => AdminAddProfanityFilterIntoListRequest,
  AdminAddProfanityFiltersFilterRequest: () => AdminAddProfanityFiltersFilterRequest,
  AdminAddProfanityFiltersRequest: () => AdminAddProfanityFiltersRequest,
  AdminAdmin$: () => AdminAdmin$,
  AdminAdminApi: () => AdminAdminApi,
  AdminApi: () => AdminApi,
  AdminCreateProfanityListRequest: () => AdminCreateProfanityListRequest,
  AdminDeleteProfanityFilterRequest: () => AdminDeleteProfanityFilterRequest,
  AdminGetProfanityListFiltersV1Response: () => AdminGetProfanityListFiltersV1Response,
  AdminGetProfanityListsListResponse: () => AdminGetProfanityListsListResponse,
  AdminGetProfanityListsListResponseArray: () => AdminGetProfanityListsListResponseArray,
  AdminSetProfanityRuleForNamespaceRequest: () => AdminSetProfanityRuleForNamespaceRequest,
  AdminUpdateProfanityList: () => AdminUpdateProfanityList,
  AdminVerifyMessageProfanityRequest: () => AdminVerifyMessageProfanityRequest,
  AdminVerifyMessageProfanityResponse: () => AdminVerifyMessageProfanityResponse,
  AppMessageDeclaration: () => AppMessageDeclaration,
  AppMessageDeclarationArray: () => AppMessageDeclarationArray,
  BlockPlayerRequest: () => BlockPlayerRequest,
  BlockedByPlayerData: () => BlockedByPlayerData,
  BlockedPlayerData: () => BlockedPlayerData,
  Blocks$: () => Blocks$,
  BlocksApi: () => BlocksApi,
  BulkFriendsRequest: () => BulkFriendsRequest,
  BulkFriendsResponse: () => BulkFriendsResponse,
  BulkUsersFreeFormNotificationRequestV1: () => BulkUsersFreeFormNotificationRequestV1,
  Config: () => Config,
  ConfigAdmin$: () => ConfigAdmin$,
  ConfigAdminApi: () => ConfigAdminApi,
  ConfigList: () => ConfigList,
  ConfigReq: () => ConfigReq,
  Configuration: () => Configuration,
  CreateConfigRequest: () => CreateConfigRequest,
  CreateConfigResponse: () => CreateConfigResponse,
  CreateTemplateRequest: () => CreateTemplateRequest,
  CreateTopicRequest: () => CreateTopicRequest,
  CreateTopicRequestV1: () => CreateTopicRequestV1,
  DebugProfanityFilterRequest: () => DebugProfanityFilterRequest,
  Error: () => Error2,
  ErrorResponseBody: () => ErrorResponseBody,
  ErrorResponseV1: () => ErrorResponseV1,
  FreeFormNotificationRequest: () => FreeFormNotificationRequest,
  FreeFormNotificationRequestV1: () => FreeFormNotificationRequestV1,
  FriendWithPlatform: () => FriendWithPlatform,
  Friends$: () => Friends$,
  FriendsAdmin$: () => FriendsAdmin$,
  FriendsAdminApi: () => FriendsAdminApi,
  FriendsApi: () => FriendsApi,
  FriendshipConnection: () => FriendshipConnection,
  FriendshipConnectionResponse: () => FriendshipConnectionResponse,
  GetAllNotificationTemplateSlugResp: () => GetAllNotificationTemplateSlugResp,
  GetAllNotificationTopicsResponse: () => GetAllNotificationTopicsResponse,
  GetAllPlayerBlockedByUsersResponse: () => GetAllPlayerBlockedByUsersResponse,
  GetAllPlayerBlockedUsersResponse: () => GetAllPlayerBlockedUsersResponse,
  GetAllPlayerSessionAttributeResponse: () => GetAllPlayerSessionAttributeResponse,
  GetBulkAllPlayerBlockedUsersRequest: () => GetBulkAllPlayerBlockedUsersRequest,
  GetBulkAllPlayerBlockedUsersResponse: () => GetBulkAllPlayerBlockedUsersResponse,
  GetConfigResponse: () => GetConfigResponse,
  GetFriendsResponse: () => GetFriendsResponse,
  GetLobbyCcuResponse: () => GetLobbyCcuResponse,
  GetPlayerSessionAttributeResponse: () => GetPlayerSessionAttributeResponse,
  GetUserFriendsResponse: () => GetUserFriendsResponse,
  GetUserFriendsResponseArray: () => GetUserFriendsResponseArray,
  GetUserIncomingFriendsResponse: () => GetUserIncomingFriendsResponse,
  GetUserIncomingFriendsResponseArray: () => GetUserIncomingFriendsResponseArray,
  GetUserOutgoingFriendsResponse: () => GetUserOutgoingFriendsResponse,
  GetUserOutgoingFriendsResponseArray: () => GetUserOutgoingFriendsResponseArray,
  GetUsersPresenceResponse: () => GetUsersPresenceResponse,
  GlobalConfiguration: () => GlobalConfiguration,
  ImportConfigResponse: () => ImportConfigResponse,
  IncomingFriendsWithTimeData: () => IncomingFriendsWithTimeData,
  ListBlockedPlayerRequest: () => ListBlockedPlayerRequest,
  ListBulkUserPlatformsResponse: () => ListBulkUserPlatformsResponse,
  ListUnblockPlayerRequest: () => ListUnblockPlayerRequest,
  LoadIncomingFriendsWithTimeResponse: () => LoadIncomingFriendsWithTimeResponse,
  LoadIncomingFriendsWithTimeResponseArray: () => LoadIncomingFriendsWithTimeResponseArray,
  LoadOutgoingFriendsWithTimeResponse: () => LoadOutgoingFriendsWithTimeResponse,
  LoadOutgoingFriendsWithTimeResponseArray: () => LoadOutgoingFriendsWithTimeResponseArray,
  Lobby: () => Lobby,
  LobbyOperations$: () => LobbyOperations$,
  LobbyOperationsAdmin$: () => LobbyOperationsAdmin$,
  LobbyOperationsAdminApi: () => LobbyOperationsAdminApi,
  LobbyOperationsApi: () => LobbyOperationsApi,
  Localization: () => Localization,
  NativeFriendRequest: () => NativeFriendRequest,
  NativeFriendSyncResponse: () => NativeFriendSyncResponse,
  NativeFriendSyncResponseArray: () => NativeFriendSyncResponseArray,
  NativeUserBlockRequest: () => NativeUserBlockRequest,
  NativeUserBlockResponse: () => NativeUserBlockResponse,
  NativeUserBlockResponseArray: () => NativeUserBlockResponseArray,
  Notification$: () => Notification$,
  NotificationAdmin$: () => NotificationAdmin$,
  NotificationAdminApi: () => NotificationAdminApi,
  NotificationApi: () => NotificationApi,
  NotificationResponse: () => NotificationResponse,
  NotificationTemplateResponse: () => NotificationTemplateResponse,
  NotificationTemplateResponseArray: () => NotificationTemplateResponseArray,
  NotificationTopicResponse: () => NotificationTopicResponse,
  NotificationTopicResponseV1: () => NotificationTopicResponseV1,
  NotificationWithTemplateRequest: () => NotificationWithTemplateRequest,
  NotificationWithTemplateRequestV1: () => NotificationWithTemplateRequestV1,
  OutgoingFriendsWithTimeData: () => OutgoingFriendsWithTimeData,
  Pagination: () => Pagination,
  Party$: () => Party$,
  PartyAdmin$: () => PartyAdmin$,
  PartyAdminApi: () => PartyAdminApi,
  PartyApi: () => PartyApi,
  PartyData: () => PartyData,
  PartyPutCustomAttributesRequest: () => PartyPutCustomAttributesRequest,
  PartyPutLimitSizeRequest: () => PartyPutLimitSizeRequest,
  Player$: () => Player$,
  PlayerAdmin$: () => PlayerAdmin$,
  PlayerAdminApi: () => PlayerAdminApi,
  PlayerApi: () => PlayerApi,
  Presence$: () => Presence$,
  PresenceApi: () => PresenceApi,
  ProfanityAdmin$: () => ProfanityAdmin$,
  ProfanityAdminApi: () => ProfanityAdminApi,
  ProfanityFilter: () => ProfanityFilter,
  ProfanityFilterArray: () => ProfanityFilterArray,
  ProfanityRule: () => ProfanityRule,
  PutGlobalConfigurationRequest: () => PutGlobalConfigurationRequest,
  RequestUserPresence: () => RequestUserPresence,
  SetPlayerSessionAttributeRequest: () => SetPlayerSessionAttributeRequest,
  TemplateContent: () => TemplateContent,
  TemplateLocalization: () => TemplateLocalization,
  TemplateLocalizationResponse: () => TemplateLocalizationResponse,
  TemplateResponse: () => TemplateResponse,
  TemplateResponseArray: () => TemplateResponseArray,
  ThirdPartyAdmin$: () => ThirdPartyAdmin$,
  ThirdPartyAdminApi: () => ThirdPartyAdminApi,
  TopicByNamespacesResponse: () => TopicByNamespacesResponse,
  UnblockPlayerRequest: () => UnblockPlayerRequest,
  UpdateConfigRequest: () => UpdateConfigRequest,
  UpdateConfigResponse: () => UpdateConfigResponse,
  UpdateTemplateRequest: () => UpdateTemplateRequest,
  UpdateTopicRequest: () => UpdateTopicRequest,
  UserAcceptFriendRequest: () => UserAcceptFriendRequest,
  UserCancelFriendRequest: () => UserCancelFriendRequest,
  UserGetFriendshipStatusResponse: () => UserGetFriendshipStatusResponse,
  UserPlatformInfo: () => UserPlatformInfo,
  UserPresence: () => UserPresence,
  UserRejectFriendRequest: () => UserRejectFriendRequest,
  UserRequestFriendRequest: () => UserRequestFriendRequest,
  UserUnfriendRequest: () => UserUnfriendRequest,
  UserWithPlatformInfo: () => UserWithPlatformInfo
});
module.exports = __toCommonJS(src_exports);

// src/generated-admin/AdminAdminApi.ts
var import_sdk2 = require("@accelbyte/sdk");

// src/generated-admin/endpoints/AdminAdmin$.ts
var import_sdk = require("@accelbyte/sdk");
var import_zod2 = require("zod");

// src/generated-definitions/GlobalConfiguration.ts
var import_zod = require("zod");
var GlobalConfiguration = import_zod.z.object({
  regionRetryMapping: import_zod.z.record(import_zod.z.array(import_zod.z.string())),
  regionURLMapping: import_zod.z.array(import_zod.z.string()),
  testGameMode: import_zod.z.string(),
  testRegionURLMapping: import_zod.z.array(import_zod.z.string()),
  testTargetUserIDs: import_zod.z.array(import_zod.z.string()),
  updatedAt: import_zod.z.string()
});

// src/generated-admin/endpoints/AdminAdmin$.ts
var AdminAdmin$ = class {
  // @ts-ignore
  // prettier-ignore
  constructor(axiosInstance, namespace, useSchemaValidation = true) {
    this.axiosInstance = axiosInstance;
    this.namespace = namespace;
    this.useSchemaValidation = useSchemaValidation;
  }
  /**
   * Delete of global configuration data.
   */
  deleteGlobalConfiguration() {
    const params = {};
    const url = "/lobby/v1/admin/global-configurations";
    const resultPromise = this.axiosInstance.delete(url, { params });
    return import_sdk.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, import_zod2.z.unknown(), "z.unknown()");
  }
  /**
   * Get dsmc global configuration.
   */
  getGlobalConfigurations() {
    const params = {};
    const url = "/lobby/v1/admin/global-configurations";
    const resultPromise = this.axiosInstance.get(url, { params });
    return import_sdk.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, GlobalConfiguration, "GlobalConfiguration");
  }
  /**
   * Upsert global configuration data.
   */
  updateGlobalConfiguration(data) {
    const params = {};
    const url = "/lobby/v1/admin/global-configurations";
    const resultPromise = this.axiosInstance.put(url, data, { params });
    return import_sdk.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, GlobalConfiguration, "GlobalConfiguration");
  }
};

// src/generated-admin/AdminAdminApi.ts
function AdminAdminApi(sdk, args) {
  const sdkAssembly = sdk.assembly();
  const namespace = args?.coreConfig?.namespace ?? sdkAssembly.coreConfig.namespace;
  const useSchemaValidation = args?.coreConfig?.useSchemaValidation ?? sdkAssembly.coreConfig.useSchemaValidation;
  let axiosInstance = sdkAssembly.axiosInstance;
  const requestConfigOverrides = args?.axiosConfig?.request;
  const baseURLOverride = args?.coreConfig?.baseURL;
  const interceptorsOverride = args?.axiosConfig?.interceptors ?? [];
  if (requestConfigOverrides || baseURLOverride || interceptorsOverride.length > 0) {
    const requestConfig = import_sdk2.ApiUtils.mergeAxiosConfigs(sdkAssembly.axiosInstance.defaults, {
      ...baseURLOverride ? { baseURL: baseURLOverride } : {},
      ...requestConfigOverrides
    });
    axiosInstance = import_sdk2.Network.create(requestConfig);
    for (const interceptor of interceptorsOverride) {
      if (interceptor.type === "request") {
        axiosInstance.interceptors.request.use(interceptor.onRequest, interceptor.onError);
      }
      if (interceptor.type === "response") {
        axiosInstance.interceptors.response.use(interceptor.onSuccess, interceptor.onError);
      }
    }
  }
  async function deleteGlobalConfiguration() {
    const $ = new AdminAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.deleteGlobalConfiguration();
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getGlobalConfigurations() {
    const $ = new AdminAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getGlobalConfigurations();
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function updateGlobalConfiguration(data) {
    const $ = new AdminAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.updateGlobalConfiguration(data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  return {
    /**
     * Delete of global configuration data.
     */
    deleteGlobalConfiguration,
    /**
     * Get dsmc global configuration.
     */
    getGlobalConfigurations,
    /**
     * Upsert global configuration data.
     */
    updateGlobalConfiguration
  };
}

// src/generated-admin/ConfigAdminApi.ts
var import_sdk4 = require("@accelbyte/sdk");

// src/generated-admin/endpoints/ConfigAdmin$.ts
var import_sdk3 = require("@accelbyte/sdk");
var import_zod8 = require("zod");

// src/generated-definitions/ConfigList.ts
var import_zod4 = require("zod");

// src/generated-definitions/Config.ts
var import_zod3 = require("zod");
var Config = import_zod3.z.object({
  allowInviteNonConnectedUser: import_zod3.z.boolean().nullish(),
  allowJoinPartyDuringMatchmaking: import_zod3.z.boolean().nullish(),
  autoKickOnDisconnect: import_zod3.z.boolean().nullish(),
  autoKickOnDisconnectDelay: import_zod3.z.number().int().nullish(),
  cancelTicketOnDisconnect: import_zod3.z.boolean().nullish(),
  chatRateLimitBurst: import_zod3.z.number().int().nullish(),
  chatRateLimitDuration: import_zod3.z.number().int().nullish(),
  concurrentUsersLimit: import_zod3.z.number().int().nullish(),
  disableInvitationOnJoinParty: import_zod3.z.boolean().nullish(),
  disableRemoveSocketOldConnection: import_zod3.z.boolean().nullish(),
  enableChat: import_zod3.z.boolean().nullish(),
  entitlementCheck: import_zod3.z.boolean().nullish(),
  entitlementItemID: import_zod3.z.string().nullish(),
  generalRateLimitBurst: import_zod3.z.number().int().nullish(),
  generalRateLimitDuration: import_zod3.z.number().int().nullish(),
  keepPresenceActivityOnDisconnect: import_zod3.z.boolean().nullish(),
  maxDSWaitTime: import_zod3.z.number().int(),
  maxFriendsLimit: import_zod3.z.number().int().nullish(),
  maxPartyMember: import_zod3.z.number().int().nullish(),
  namespace: import_zod3.z.string().nullish(),
  profanityFilter: import_zod3.z.boolean().nullish(),
  readyConsentTimeout: import_zod3.z.number().int().nullish(),
  unregisterDelay: import_zod3.z.number().int()
});

// src/generated-definitions/ConfigList.ts
var ConfigList = import_zod4.z.object({ configs: import_zod4.z.array(Config) });

// src/generated-definitions/ConfigReq.ts
var import_zod5 = require("zod");
var ConfigReq = import_zod5.z.object({
  allowInviteNonConnectedUser: import_zod5.z.boolean().nullish(),
  allowJoinPartyDuringMatchmaking: import_zod5.z.boolean().nullish(),
  autoKickOnDisconnect: import_zod5.z.boolean().nullish(),
  autoKickOnDisconnectDelay: import_zod5.z.number().int().nullish(),
  cancelTicketOnDisconnect: import_zod5.z.boolean().nullish(),
  chatRateLimitBurst: import_zod5.z.number().int().nullish(),
  chatRateLimitDuration: import_zod5.z.number().int().nullish(),
  concurrentUsersLimit: import_zod5.z.number().int().nullish(),
  disableInvitationOnJoinParty: import_zod5.z.boolean().nullish(),
  enableChat: import_zod5.z.boolean().nullish(),
  entitlementCheck: import_zod5.z.boolean().nullish(),
  entitlementItemID: import_zod5.z.string().nullish(),
  generalRateLimitBurst: import_zod5.z.number().int().nullish(),
  generalRateLimitDuration: import_zod5.z.number().int().nullish(),
  keepPresenceActivityOnDisconnect: import_zod5.z.boolean().nullish(),
  maxDSWaitTime: import_zod5.z.number().int().nullish(),
  maxFriendsLimit: import_zod5.z.number().int().nullish(),
  maxPartyMember: import_zod5.z.number().int().nullish(),
  profanityFilter: import_zod5.z.boolean().nullish(),
  readyConsentTimeout: import_zod5.z.number().int().nullish(),
  unregisterDelay: import_zod5.z.number().int().nullish()
});

// src/generated-definitions/Configuration.ts
var import_zod6 = require("zod");
var Configuration = import_zod6.z.object({
  logLevel: import_zod6.z.enum(["debug", "error", "fatal", "info", "panic", "trace", "warning"]).nullish(),
  logLevelDB: import_zod6.z.enum(["debug", "error", "fatal", "info", "panic", "trace", "warning"]).nullish(),
  slowQueryThreshold: import_zod6.z.number().int().nullish(),
  socketLogEnabled: import_zod6.z.boolean().nullish()
});

// src/generated-definitions/ImportConfigResponse.ts
var import_zod7 = require("zod");
var ImportConfigResponse = import_zod7.z.object({
  failedConfigs: import_zod7.z.array(import_zod7.z.string()),
  ignoredConfigs: import_zod7.z.array(import_zod7.z.string()),
  newConfigs: import_zod7.z.array(import_zod7.z.string()),
  replacedConfigs: import_zod7.z.array(import_zod7.z.string())
});

// src/generated-admin/endpoints/ConfigAdmin$.ts
var ConfigAdmin$ = class {
  // @ts-ignore
  // prettier-ignore
  constructor(axiosInstance, namespace, useSchemaValidation = true) {
    this.axiosInstance = axiosInstance;
    this.namespace = namespace;
    this.useSchemaValidation = useSchemaValidation;
  }
  /**
   * Get lobby config of all namespaces.&lt;br&gt;default MaxDSWaitTime is 120 (second)
   */
  getConfig() {
    const params = {};
    const url = "/lobby/v1/admin/config";
    const resultPromise = this.axiosInstance.get(url, { params });
    return import_sdk3.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, ConfigList, "ConfigList");
  }
  /**
   *  Get Log Configuration logLevel use for logging in service, the value can use is trace|debug|info|warning|error|fatal|panic socketLogEnabled is use for enable socket log logLevelDB use for logging in DB, the value can use is trace|debug|info|warning|error|fatal|panic slowQueryThreshold use for logging slow threshold in time measure is nano second
   */
  getConfigLog() {
    const params = {};
    const url = "/lobby/v1/admin/config/log";
    const resultPromise = this.axiosInstance.get(url, { params });
    return import_sdk3.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, Configuration, "Configuration");
  }
  /**
   *  Update Log Configuration logLevel use for logging in service, the value can use is trace|debug|info|warning|error|fatal|panic socketLogEnabled is use for enable socket log logLevelDB use for logging in DB, the value can use is trace|debug|info|warning|error|fatal|panic slowQueryThreshold use for logging slow threshold in time measure is nano second
   */
  patchConfigLog(data) {
    const params = {};
    const url = "/lobby/v1/admin/config/log";
    const resultPromise = this.axiosInstance.patch(url, data, { params });
    return import_sdk3.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, Configuration, "Configuration");
  }
  /**
   * Get lobby config of a namespace.&lt;br&gt;default MaxDSWaitTime is 120 (second)
   */
  getConfig_ByNamespace() {
    const params = {};
    const url = "/lobby/v1/admin/config/namespaces/{namespace}".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.get(url, { params });
    return import_sdk3.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, ConfigReq, "ConfigReq");
  }
  /**
   * Update lobby config of a namespace.&lt;br&gt;MaxDSWaitTime value is cannot less than 1, if null it will use default value in 120 (second)
   */
  updateConfig_ByNamespace(data) {
    const params = {};
    const url = "/lobby/v1/admin/config/namespaces/{namespace}".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.put(url, data, { params });
    return import_sdk3.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, ConfigReq, "ConfigReq");
  }
  /**
   *  Export lobby configuration to a json file. The file can then be imported from the /import endpoint. JSON Schema of the exported file: { &#34;required&#34;: [ &#34;namespace&#34;, &#34;entitlementItemID&#34;, &#34;chatRateLimitDuration&#34;, &#34;unregisterDelay&#34;, &#34;generalRateLimitDuration&#34;, &#34;autoKickOnDisconnectDelay&#34;, &#34;chatRateLimitBurst&#34;, &#34;generalRateLimitBurst&#34;, &#34;maxPartyMember&#34;, &#34;autoKickOnDisconnect&#34;, &#34;profanityFilter&#34;, &#34;enableChat&#34;, &#34;entitlementCheck&#34;, &#34;cancelTicketOnDisconnect&#34;, &#34;concurrentUsersLimit&#34;, &#34;readyConsentTimeout&#34;, &#34;disableInvitationOnJoinParty&#34;, &#34;allowJoinPartyDuringMatchmaking&#34;, &#34;allowInviteNonConnectedUser&#34;, &#34;keepPresenceActivityOnDisconnect&#34;, &#34;maxDSWaitTime&#34;, &#34;maxFriendsLimit&#34; ], &#34;properties&#34;: { &#34;allowInviteNonConnectedUser&#34;: { &#34;type&#34;: &#34;boolean&#34; }, &#34;allowJoinPartyDuringMatchmaking&#34;: { &#34;type&#34;: &#34;boolean&#34; }, &#34;autoKickOnDisconnect&#34;: { &#34;type&#34;: &#34;boolean&#34; }, &#34;autoKickOnDisconnectDelay&#34;: { &#34;type&#34;: &#34;integer&#34;, &#34;format&#34;: &#34;int64&#34; }, &#34;cancelTicketOnDisconnect&#34;: { &#34;type&#34;: &#34;boolean&#34; }, &#34;chatRateLimitBurst&#34;: { &#34;type&#34;: &#34;integer&#34;, &#34;format&#34;: &#34;int32&#34; }, &#34;chatRateLimitDuration&#34;: { &#34;type&#34;: &#34;integer&#34;, &#34;format&#34;: &#34;int64&#34; }, &#34;concurrentUsersLimit&#34;: { &#34;type&#34;: &#34;integer&#34;, &#34;format&#34;: &#34;int32&#34; }, &#34;disableInvitationOnJoinParty&#34;: { &#34;type&#34;: &#34;boolean&#34; }, &#34;enableChat&#34;: { &#34;type&#34;: &#34;boolean&#34; }, &#34;entitlementCheck&#34;: { &#34;type&#34;: &#34;boolean&#34; }, &#34;entitlementItemID&#34;: { &#34;type&#34;: &#34;string&#34; }, &#34;generalRateLimitBurst&#34;: { &#34;type&#34;: &#34;integer&#34;, &#34;format&#34;: &#34;int32&#34; }, &#34;generalRateLimitDuration&#34;: { &#34;type&#34;: &#34;integer&#34;, &#34;format&#34;: &#34;int64&#34; }, &#34;keepPresenceActivityOnDisconnect&#34;: { &#34;type&#34;: &#34;boolean&#34; }, &#34;maxDSWaitTime&#34;: { &#34;type&#34;: &#34;integer&#34;, &#34;format&#34;: &#34;int64&#34; }, &#34;maxFriendsLimit&#34;: { &#34;type&#34;: &#34;integer&#34;, &#34;format&#34;: &#34;int32&#34; }, &#34;maxPartyMember&#34;: { &#34;type&#34;: &#34;integer&#34;, &#34;format&#34;: &#34;int32&#34; }, &#34;namespace&#34;: { &#34;type&#34;: &#34;string&#34; }, &#34;profanityFilter&#34;: { &#34;type&#34;: &#34;boolean&#34; }, &#34;readyConsentTimeout&#34;: { &#34;type&#34;: &#34;integer&#34;, &#34;format&#34;: &#34;int64&#34; }, &#34;unregisterDelay&#34;: { &#34;type&#34;: &#34;integer&#34;, &#34;format&#34;: &#34;int64&#34; } } }
   */
  getConfigExport() {
    const params = {};
    const url = "/lobby/v1/admin/config/namespaces/{namespace}/export".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.get(url, { params });
    return import_sdk3.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, import_zod8.z.unknown(), "z.unknown()");
  }
  /**
   *  Import config configuration from file. The existing configuration will be replaced. The json file to import can be obtained from the /export endpoint. MaxDSWaitTime value is cannot less than 1, if null it will use default value in 120 (second)
   */
  updateConfigImport(data) {
    const params = {};
    const url = "/lobby/v1/admin/config/namespaces/{namespace}/import".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.post(url, data, { params });
    return import_sdk3.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, ImportConfigResponse, "ImportConfigResponse");
  }
};

// src/generated-admin/ConfigAdminApi.ts
function ConfigAdminApi(sdk, args) {
  const sdkAssembly = sdk.assembly();
  const namespace = args?.coreConfig?.namespace ?? sdkAssembly.coreConfig.namespace;
  const useSchemaValidation = args?.coreConfig?.useSchemaValidation ?? sdkAssembly.coreConfig.useSchemaValidation;
  let axiosInstance = sdkAssembly.axiosInstance;
  const requestConfigOverrides = args?.axiosConfig?.request;
  const baseURLOverride = args?.coreConfig?.baseURL;
  const interceptorsOverride = args?.axiosConfig?.interceptors ?? [];
  if (requestConfigOverrides || baseURLOverride || interceptorsOverride.length > 0) {
    const requestConfig = import_sdk4.ApiUtils.mergeAxiosConfigs(sdkAssembly.axiosInstance.defaults, {
      ...baseURLOverride ? { baseURL: baseURLOverride } : {},
      ...requestConfigOverrides
    });
    axiosInstance = import_sdk4.Network.create(requestConfig);
    for (const interceptor of interceptorsOverride) {
      if (interceptor.type === "request") {
        axiosInstance.interceptors.request.use(interceptor.onRequest, interceptor.onError);
      }
      if (interceptor.type === "response") {
        axiosInstance.interceptors.response.use(interceptor.onSuccess, interceptor.onError);
      }
    }
  }
  async function getConfig() {
    const $ = new ConfigAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getConfig();
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getConfigLog() {
    const $ = new ConfigAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getConfigLog();
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function patchConfigLog(data) {
    const $ = new ConfigAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.patchConfigLog(data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getConfig_ByNamespace() {
    const $ = new ConfigAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getConfig_ByNamespace();
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function updateConfig_ByNamespace(data) {
    const $ = new ConfigAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.updateConfig_ByNamespace(data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getConfigExport() {
    const $ = new ConfigAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getConfigExport();
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function updateConfigImport(data) {
    const $ = new ConfigAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.updateConfigImport(data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  return {
    /**
     * Get lobby config of all namespaces.&lt;br&gt;default MaxDSWaitTime is 120 (second)
     */
    getConfig,
    /**
     *  Get Log Configuration logLevel use for logging in service, the value can use is trace|debug|info|warning|error|fatal|panic socketLogEnabled is use for enable socket log logLevelDB use for logging in DB, the value can use is trace|debug|info|warning|error|fatal|panic slowQueryThreshold use for logging slow threshold in time measure is nano second
     */
    getConfigLog,
    /**
     *  Update Log Configuration logLevel use for logging in service, the value can use is trace|debug|info|warning|error|fatal|panic socketLogEnabled is use for enable socket log logLevelDB use for logging in DB, the value can use is trace|debug|info|warning|error|fatal|panic slowQueryThreshold use for logging slow threshold in time measure is nano second
     */
    patchConfigLog,
    /**
     * Get lobby config of a namespace.&lt;br&gt;default MaxDSWaitTime is 120 (second)
     */
    getConfig_ByNamespace,
    /**
     * Update lobby config of a namespace.&lt;br&gt;MaxDSWaitTime value is cannot less than 1, if null it will use default value in 120 (second)
     */
    updateConfig_ByNamespace,
    /**
     *  Export lobby configuration to a json file. The file can then be imported from the /import endpoint. JSON Schema of the exported file: { &#34;required&#34;: [ &#34;namespace&#34;, &#34;entitlementItemID&#34;, &#34;chatRateLimitDuration&#34;, &#34;unregisterDelay&#34;, &#34;generalRateLimitDuration&#34;, &#34;autoKickOnDisconnectDelay&#34;, &#34;chatRateLimitBurst&#34;, &#34;generalRateLimitBurst&#34;, &#34;maxPartyMember&#34;, &#34;autoKickOnDisconnect&#34;, &#34;profanityFilter&#34;, &#34;enableChat&#34;, &#34;entitlementCheck&#34;, &#34;cancelTicketOnDisconnect&#34;, &#34;concurrentUsersLimit&#34;, &#34;readyConsentTimeout&#34;, &#34;disableInvitationOnJoinParty&#34;, &#34;allowJoinPartyDuringMatchmaking&#34;, &#34;allowInviteNonConnectedUser&#34;, &#34;keepPresenceActivityOnDisconnect&#34;, &#34;maxDSWaitTime&#34;, &#34;maxFriendsLimit&#34; ], &#34;properties&#34;: { &#34;allowInviteNonConnectedUser&#34;: { &#34;type&#34;: &#34;boolean&#34; }, &#34;allowJoinPartyDuringMatchmaking&#34;: { &#34;type&#34;: &#34;boolean&#34; }, &#34;autoKickOnDisconnect&#34;: { &#34;type&#34;: &#34;boolean&#34; }, &#34;autoKickOnDisconnectDelay&#34;: { &#34;type&#34;: &#34;integer&#34;, &#34;format&#34;: &#34;int64&#34; }, &#34;cancelTicketOnDisconnect&#34;: { &#34;type&#34;: &#34;boolean&#34; }, &#34;chatRateLimitBurst&#34;: { &#34;type&#34;: &#34;integer&#34;, &#34;format&#34;: &#34;int32&#34; }, &#34;chatRateLimitDuration&#34;: { &#34;type&#34;: &#34;integer&#34;, &#34;format&#34;: &#34;int64&#34; }, &#34;concurrentUsersLimit&#34;: { &#34;type&#34;: &#34;integer&#34;, &#34;format&#34;: &#34;int32&#34; }, &#34;disableInvitationOnJoinParty&#34;: { &#34;type&#34;: &#34;boolean&#34; }, &#34;enableChat&#34;: { &#34;type&#34;: &#34;boolean&#34; }, &#34;entitlementCheck&#34;: { &#34;type&#34;: &#34;boolean&#34; }, &#34;entitlementItemID&#34;: { &#34;type&#34;: &#34;string&#34; }, &#34;generalRateLimitBurst&#34;: { &#34;type&#34;: &#34;integer&#34;, &#34;format&#34;: &#34;int32&#34; }, &#34;generalRateLimitDuration&#34;: { &#34;type&#34;: &#34;integer&#34;, &#34;format&#34;: &#34;int64&#34; }, &#34;keepPresenceActivityOnDisconnect&#34;: { &#34;type&#34;: &#34;boolean&#34; }, &#34;maxDSWaitTime&#34;: { &#34;type&#34;: &#34;integer&#34;, &#34;format&#34;: &#34;int64&#34; }, &#34;maxFriendsLimit&#34;: { &#34;type&#34;: &#34;integer&#34;, &#34;format&#34;: &#34;int32&#34; }, &#34;maxPartyMember&#34;: { &#34;type&#34;: &#34;integer&#34;, &#34;format&#34;: &#34;int32&#34; }, &#34;namespace&#34;: { &#34;type&#34;: &#34;string&#34; }, &#34;profanityFilter&#34;: { &#34;type&#34;: &#34;boolean&#34; }, &#34;readyConsentTimeout&#34;: { &#34;type&#34;: &#34;integer&#34;, &#34;format&#34;: &#34;int64&#34; }, &#34;unregisterDelay&#34;: { &#34;type&#34;: &#34;integer&#34;, &#34;format&#34;: &#34;int64&#34; } } }
     */
    getConfigExport,
    /**
     *  Import config configuration from file. The existing configuration will be replaced. The json file to import can be obtained from the /export endpoint. MaxDSWaitTime value is cannot less than 1, if null it will use default value in 120 (second)
     */
    updateConfigImport
  };
}

// src/generated-admin/endpoints/FriendsAdmin$.ts
var import_sdk5 = require("@accelbyte/sdk");

// src/generated-definitions/FriendshipConnectionResponse.ts
var import_zod11 = require("zod");

// src/generated-definitions/FriendshipConnection.ts
var import_zod9 = require("zod");
var FriendshipConnection = import_zod9.z.object({ friendId: import_zod9.z.string(), subjectId: import_zod9.z.string() });

// src/generated-definitions/Pagination.ts
var import_zod10 = require("zod");
var Pagination = import_zod10.z.object({ first: import_zod10.z.string(), last: import_zod10.z.string(), next: import_zod10.z.string(), previous: import_zod10.z.string() });

// src/generated-definitions/FriendshipConnectionResponse.ts
var FriendshipConnectionResponse = import_zod11.z.object({ data: import_zod11.z.array(FriendshipConnection), paging: Pagination });

// src/generated-definitions/GetFriendsResponse.ts
var import_zod13 = require("zod");

// src/generated-definitions/FriendWithPlatform.ts
var import_zod12 = require("zod");
var FriendWithPlatform = import_zod12.z.object({ platformId: import_zod12.z.string(), userId: import_zod12.z.string() });

// src/generated-definitions/GetFriendsResponse.ts
var GetFriendsResponse = import_zod13.z.object({
  friendIDs: import_zod13.z.array(import_zod13.z.string()),
  friends: import_zod13.z.array(FriendWithPlatform).nullish(),
  friendsSinceTimes: import_zod13.z.array(import_zod13.z.string()),
  paging: Pagination
});

// src/generated-definitions/LoadIncomingFriendsWithTimeResponse.ts
var import_zod15 = require("zod");

// src/generated-definitions/IncomingFriendsWithTimeData.ts
var import_zod14 = require("zod");
var IncomingFriendsWithTimeData = import_zod14.z.object({ friendId: import_zod14.z.string(), requestedAt: import_zod14.z.string() });

// src/generated-definitions/LoadIncomingFriendsWithTimeResponse.ts
var LoadIncomingFriendsWithTimeResponse = import_zod15.z.object({ data: import_zod15.z.array(IncomingFriendsWithTimeData), paging: Pagination });

// src/generated-definitions/LoadOutgoingFriendsWithTimeResponse.ts
var import_zod17 = require("zod");

// src/generated-definitions/OutgoingFriendsWithTimeData.ts
var import_zod16 = require("zod");
var OutgoingFriendsWithTimeData = import_zod16.z.object({ friendId: import_zod16.z.string(), requestedAt: import_zod16.z.string() });

// src/generated-definitions/LoadOutgoingFriendsWithTimeResponse.ts
var LoadOutgoingFriendsWithTimeResponse = import_zod17.z.object({ data: import_zod17.z.array(OutgoingFriendsWithTimeData), paging: Pagination });

// src/generated-admin/endpoints/FriendsAdmin$.ts
var FriendsAdmin$ = class {
  // @ts-ignore
  // prettier-ignore
  constructor(axiosInstance, namespace, useSchemaValidation = true) {
    this.axiosInstance = axiosInstance;
    this.namespace = namespace;
    this.useSchemaValidation = useSchemaValidation;
  }
  /**
   * Get list of friends in a namespace.
   */
  getFriendUser_ByUserId(userId, queryParams) {
    const params = { limit: 25, ...queryParams };
    const url = "/lobby/v1/admin/friend/namespaces/{namespace}/users/{userId}".replace("{namespace}", this.namespace).replace("{userId}", userId);
    const resultPromise = this.axiosInstance.get(url, { params });
    return import_sdk5.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, GetFriendsResponse, "GetFriendsResponse");
  }
  /**
   * Get list of incoming friend requests.
   */
  getIncomingFriend_ByUserId(userId, queryParams) {
    const params = { limit: 25, ...queryParams };
    const url = "/lobby/v1/admin/friend/namespaces/{namespace}/users/{userId}/incoming".replace("{namespace}", this.namespace).replace("{userId}", userId);
    const resultPromise = this.axiosInstance.get(url, { params });
    return import_sdk5.Validate.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      LoadIncomingFriendsWithTimeResponse,
      "LoadIncomingFriendsWithTimeResponse"
    );
  }
  /**
   * Get list of outgoing friend requests in a namespace.
   */
  getOutgoingFriend_ByUserId(userId, queryParams) {
    const params = { limit: 25, ...queryParams };
    const url = "/lobby/v1/admin/friend/namespaces/{namespace}/users/{userId}/outgoing".replace("{namespace}", this.namespace).replace("{userId}", userId);
    const resultPromise = this.axiosInstance.get(url, { params });
    return import_sdk5.Validate.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      LoadOutgoingFriendsWithTimeResponse,
      "LoadOutgoingFriendsWithTimeResponse"
    );
  }
  /**
   * Load list friends and friends of friends in a namespace. Response subjectId will be different with requested userId if the user is not directly friend
   */
  getOfFriends_ByUserId(userId, queryParams) {
    const params = { limit: 25, ...queryParams };
    const url = "/lobby/v1/admin/friend/namespaces/{namespace}/users/{userId}/of-friends".replace("{namespace}", this.namespace).replace("{userId}", userId);
    const resultPromise = this.axiosInstance.get(url, { params });
    return import_sdk5.Validate.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      FriendshipConnectionResponse,
      "FriendshipConnectionResponse"
    );
  }
};

// src/generated-admin/endpoints/LobbyOperationsAdmin$.ts
var import_sdk6 = require("@accelbyte/sdk");
var import_zod19 = require("zod");

// src/generated-definitions/PartyData.ts
var import_zod18 = require("zod");
var PartyData = import_zod18.z.object({
  custom_attribute: import_zod18.z.record(import_zod18.z.any()),
  invitees: import_zod18.z.array(import_zod18.z.string()),
  leader: import_zod18.z.string(),
  members: import_zod18.z.array(import_zod18.z.string()),
  namespace: import_zod18.z.string(),
  partyId: import_zod18.z.string(),
  updatedAt: import_zod18.z.number().int()
});

// src/generated-admin/endpoints/LobbyOperationsAdmin$.ts
var LobbyOperationsAdmin$ = class {
  // @ts-ignore
  // prettier-ignore
  constructor(axiosInstance, namespace, useSchemaValidation = true) {
    this.axiosInstance = axiosInstance;
    this.namespace = namespace;
    this.useSchemaValidation = useSchemaValidation;
  }
  /**
   * Update party attributes in a namespace.
   */
  updateAttributeParty_ByPartyId(partyId, data) {
    const params = {};
    const url = "/lobby/v1/admin/party/namespaces/{namespace}/parties/{partyId}/attributes".replace("{namespace}", this.namespace).replace("{partyId}", partyId);
    const resultPromise = this.axiosInstance.put(url, data, { params });
    return import_sdk6.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, PartyData, "PartyData");
  }
  /**
   * Admin join a player into a party.
   */
  updateJoinParty_ByPartyId_ByUserId(partyId, userId) {
    const params = {};
    const url = "/lobby/v1/admin/party/namespaces/{namespace}/parties/{partyId}/join/{userId}".replace("{namespace}", this.namespace).replace("{partyId}", partyId).replace("{userId}", userId);
    const resultPromise = this.axiosInstance.post(url, null, { params });
    return import_sdk6.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, import_zod19.z.unknown(), "z.unknown()");
  }
};

// src/generated-admin/endpoints/NotificationAdmin$.ts
var import_sdk7 = require("@accelbyte/sdk");
var import_zod27 = require("zod");

// src/generated-definitions/GetAllNotificationTemplateSlugResp.ts
var import_zod22 = require("zod");

// src/generated-definitions/Localization.ts
var import_zod21 = require("zod");

// src/generated-definitions/TemplateContent.ts
var import_zod20 = require("zod");
var TemplateContent = import_zod20.z.object({ draft: import_zod20.z.string(), published: import_zod20.z.string() });

// src/generated-definitions/Localization.ts
var Localization = import_zod21.z.object({
  lastDraftAt: import_zod21.z.string(),
  lastPublishedAt: import_zod21.z.string(),
  templateContent: TemplateContent,
  templateLanguage: import_zod21.z.string()
});

// src/generated-definitions/GetAllNotificationTemplateSlugResp.ts
var GetAllNotificationTemplateSlugResp = import_zod22.z.object({ data: import_zod22.z.array(Localization), paging: Pagination });

// src/generated-definitions/GetAllNotificationTopicsResponse.ts
var import_zod24 = require("zod");

// src/generated-definitions/NotificationTopicResponseV1.ts
var import_zod23 = require("zod");
var NotificationTopicResponseV1 = import_zod23.z.object({
  createdAt: import_zod23.z.number().int(),
  description: import_zod23.z.string(),
  namespace: import_zod23.z.string(),
  topicName: import_zod23.z.string()
});

// src/generated-definitions/GetAllNotificationTopicsResponse.ts
var GetAllNotificationTopicsResponse = import_zod24.z.object({ data: import_zod24.z.array(NotificationTopicResponseV1), paging: Pagination });

// src/generated-definitions/NotificationTemplateResponseArray.ts
var import_zod26 = require("zod");

// src/generated-definitions/NotificationTemplateResponse.ts
var import_zod25 = require("zod");
var NotificationTemplateResponse = import_zod25.z.object({ templateLocalizations: import_zod25.z.array(Localization), templateSlug: import_zod25.z.string() });

// src/generated-definitions/NotificationTemplateResponseArray.ts
var NotificationTemplateResponseArray = import_zod26.z.array(NotificationTemplateResponse);

// src/generated-admin/endpoints/NotificationAdmin$.ts
var NotificationAdmin$ = class {
  // @ts-ignore
  // prettier-ignore
  constructor(axiosInstance, namespace, useSchemaValidation = true) {
    this.axiosInstance = axiosInstance;
    this.namespace = namespace;
    this.useSchemaValidation = useSchemaValidation;
  }
  /**
   * Get topic by namespace.&lt;br/&gt; Action Code: 50213
   */
  getNotificationTopics(queryParams) {
    const params = { ...queryParams };
    const url = "/lobby/v1/admin/notification/namespaces/{namespace}/topics".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.get(url, { params });
    return import_sdk7.Validate.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      GetAllNotificationTopicsResponse,
      "GetAllNotificationTopicsResponse"
    );
  }
  /**
   * Create new notification topic. &lt;br&gt;topic should be alphabets, no special char except underscore, uppercase and no spacing. for example: TOPIC_TEST. Already existing topic can not be created&lt;br/&gt; Action Code: 50214
   */
  createNotificationTopic(data) {
    const params = {};
    const url = "/lobby/v1/admin/notification/namespaces/{namespace}/topics".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.post(url, data, { params });
    return import_sdk7.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, import_zod27.z.unknown(), "z.unknown()");
  }
  /**
   * Get all templates in a namespace&lt;br&gt; Action Code: 50203
   */
  getNotificationTemplates() {
    const params = {};
    const url = "/lobby/v1/admin/notification/namespaces/{namespace}/templates".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.get(url, { params });
    return import_sdk7.Validate.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      NotificationTemplateResponseArray,
      "NotificationTemplateResponseArray"
    );
  }
  /**
   * Create new notification template. Include handlebars {{key}} for replaceable contexts. The key inside handlebars will be the key to be replaced when sending notification. Already existing template with the same slug and language can not be created. &lt;br&gt;Check model description for detailed input restrictions.&lt;br&gt; Action Code: 50204
   */
  createNotificationTemplate(data) {
    const params = {};
    const url = "/lobby/v1/admin/notification/namespaces/{namespace}/templates".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.post(url, data, { params });
    return import_sdk7.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, import_zod27.z.unknown(), "z.unknown()");
  }
  /**
   * Sends notification to all connected users in a namespace.&lt;br&gt; Action Code: 50201
   */
  createNotificationFreeformNotify(data) {
    const params = {};
    const url = "/lobby/v1/admin/notification/namespaces/{namespace}/freeform/notify".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.post(url, data, { params });
    return import_sdk7.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, import_zod27.z.unknown(), "z.unknown()");
  }
  /**
   * Sends notification to all connected users in a namespace with predefined template. &lt;br&gt;In the request body, specify which template slug (template identifier) to use and the template language. &lt;br&gt;NotificationTemplate context is the key-value pair defining the value of each handlebar specified in the template content. Template need to be published before it can be use to send notifications&lt;br/&gt; Action Code: 50202
   */
  createNotificationTemplateNotify(data) {
    const params = {};
    const url = "/lobby/v1/admin/notification/namespaces/{namespace}/templates/notify".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.post(url, data, { params });
    return import_sdk7.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, import_zod27.z.unknown(), "z.unknown()");
  }
  /**
   * Delete topic information by topic name. &lt;br&gt;topic should be alphabets, no special char except underscore, uppercase and no spacing. for example: TOPIC_TEST. Already existing topic can not be created &lt;br/&gt; Action Code: 50217
   */
  deleteNotificationTopic_ByTopicName(topicName) {
    const params = {};
    const url = "/lobby/v1/admin/notification/namespaces/{namespace}/topics/{topicName}".replace("{namespace}", this.namespace).replace("{topicName}", topicName);
    const resultPromise = this.axiosInstance.delete(url, { params });
    return import_sdk7.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, import_zod27.z.unknown(), "z.unknown()");
  }
  /**
   * Get topic information by topic name.&lt;br/&gt; Action Code: 50215
   */
  getNotificationTopic_ByTopicName(topicName) {
    const params = {};
    const url = "/lobby/v1/admin/notification/namespaces/{namespace}/topics/{topicName}".replace("{namespace}", this.namespace).replace("{topicName}", topicName);
    const resultPromise = this.axiosInstance.get(url, { params });
    return import_sdk7.Validate.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      NotificationTopicResponseV1,
      "NotificationTopicResponseV1"
    );
  }
  /**
   * Update topic information by topic name. &lt;br&gt;topic should be alphabets, no special char except underscore, uppercase and no spacing. for example: TOPIC_TEST. Already existing topic can not be created &lt;br/&gt; Action Code: 50216
   */
  updateNotificationTopic_ByTopicName(topicName, data) {
    const params = {};
    const url = "/lobby/v1/admin/notification/namespaces/{namespace}/topics/{topicName}".replace("{namespace}", this.namespace).replace("{topicName}", topicName);
    const resultPromise = this.axiosInstance.put(url, data, { params });
    return import_sdk7.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, import_zod27.z.unknown(), "z.unknown()");
  }
  /**
   * Delete template slug in notification template&lt;br&gt; Action Code: 50206
   */
  deleteNotificationTemplate_ByTemplateSlug(templateSlug) {
    const params = {};
    const url = "/lobby/v1/admin/notification/namespaces/{namespace}/templates/{templateSlug}".replace("{namespace}", this.namespace).replace("{templateSlug}", templateSlug);
    const resultPromise = this.axiosInstance.delete(url, { params });
    return import_sdk7.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, import_zod27.z.unknown(), "z.unknown()");
  }
  /**
   * Get all templates in a namespace&lt;br&gt; Action Code: 50205
   */
  getNotificationTemplate_ByTemplateSlug(templateSlug, queryParams) {
    const params = { ...queryParams };
    const url = "/lobby/v1/admin/notification/namespaces/{namespace}/templates/{templateSlug}".replace("{namespace}", this.namespace).replace("{templateSlug}", templateSlug);
    const resultPromise = this.axiosInstance.get(url, { params });
    return import_sdk7.Validate.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      GetAllNotificationTemplateSlugResp,
      "GetAllNotificationTemplateSlugResp"
    );
  }
  /**
   * Sends notification to multiple user. Action Code: 50211
   */
  createNotificationBulkUserFreeformNotify(data) {
    const params = {};
    const url = "/lobby/v1/admin/notification/namespaces/{namespace}/bulkUsers/freeform/notify".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.post(url, data, { params });
    return import_sdk7.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, import_zod27.z.unknown(), "z.unknown()");
  }
  /**
   * Sends notification to a user. Action Code: 50211
   */
  createFreeformNotifyNotification_ByUserId(userId, data) {
    const params = {};
    const url = "/lobby/v1/admin/notification/namespaces/{namespace}/users/{userId}/freeform/notify".replace("{namespace}", this.namespace).replace("{userId}", userId);
    const resultPromise = this.axiosInstance.post(url, data, { params });
    return import_sdk7.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, import_zod27.z.unknown(), "z.unknown()");
  }
  /**
   * Sends templated notification to a user. &lt;br&gt;In the request body, specify which template slug (template identifier) to use and the template language. &lt;br&gt;NotificationTemplate context is the key-value pair defining the value of each handlebar specified in the template content. Template need to be published before it can be use to send notifications&lt;br&gt; Action Code: 50212
   */
  createTemplateNotifyNotification_ByUserId(userId, data) {
    const params = {};
    const url = "/lobby/v1/admin/notification/namespaces/{namespace}/users/{userId}/templates/notify".replace("{namespace}", this.namespace).replace("{userId}", userId);
    const resultPromise = this.axiosInstance.post(url, data, { params });
    return import_sdk7.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, import_zod27.z.unknown(), "z.unknown()");
  }
  /**
   * Sends notification to a party.
   */
  createFreeformNotifyNotification_ByPartyId(partyId, data) {
    const params = {};
    const url = "/lobby/v1/admin/notification/namespaces/{namespace}/parties/{partyId}/freeform/notify".replace("{namespace}", this.namespace).replace("{partyId}", partyId);
    const resultPromise = this.axiosInstance.post(url, data, { params });
    return import_sdk7.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, import_zod27.z.unknown(), "z.unknown()");
  }
  /**
   * Sends templated notification to a party. &lt;br&gt;In the request body, specify which template slug (template identifier) to use and the template language. &lt;br&gt;NotificationTemplate context is the key-value pair defining the value of each handlebar specified in the template content. Template need to be published before it can be use to send notifications&lt;br&gt;
   */
  createTemplateNotifyNotification_ByPartyId(partyId, data) {
    const params = {};
    const url = "/lobby/v1/admin/notification/namespaces/{namespace}/parties/{partyId}/templates/notify".replace("{namespace}", this.namespace).replace("{partyId}", partyId);
    const resultPromise = this.axiosInstance.post(url, data, { params });
    return import_sdk7.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, import_zod27.z.unknown(), "z.unknown()");
  }
  /**
   * Delete template localization&lt;br/&gt; Action Code: 50209
   */
  deleteLanguageNotification_ByTemplateSlug_ByTemplateLanguage(templateSlug, templateLanguage) {
    const params = {};
    const url = "/lobby/v1/admin/notification/namespaces/{namespace}/templates/{templateSlug}/languages/{templateLanguage}".replace("{namespace}", this.namespace).replace("{templateSlug}", templateSlug).replace("{templateLanguage}", templateLanguage);
    const resultPromise = this.axiosInstance.delete(url, { params });
    return import_sdk7.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, import_zod27.z.unknown(), "z.unknown()");
  }
  /**
   * Get a template localization&lt;br/&gt; Action Code: 50207
   */
  getLanguageNotification_ByTemplateSlug_ByTemplateLanguage(templateSlug, templateLanguage) {
    const params = {};
    const url = "/lobby/v1/admin/notification/namespaces/{namespace}/templates/{templateSlug}/languages/{templateLanguage}".replace("{namespace}", this.namespace).replace("{templateSlug}", templateSlug).replace("{templateLanguage}", templateLanguage);
    const resultPromise = this.axiosInstance.get(url, { params });
    return import_sdk7.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, Localization, "Localization");
  }
  /**
   * Update template localization&lt;br/&gt; Action Code: 50208
   */
  updateLanguageNotification_ByTemplateSlug_ByTemplateLanguage(templateSlug, templateLanguage, data) {
    const params = {};
    const url = "/lobby/v1/admin/notification/namespaces/{namespace}/templates/{templateSlug}/languages/{templateLanguage}".replace("{namespace}", this.namespace).replace("{templateSlug}", templateSlug).replace("{templateLanguage}", templateLanguage);
    const resultPromise = this.axiosInstance.put(url, data, { params });
    return import_sdk7.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, import_zod27.z.unknown(), "z.unknown()");
  }
  /**
   * Publish notification template draft. Empty draft can not be published.&lt;br/&gt; Action Code: 50210
   */
  createPublishNotification_ByTemplateSlug_ByTemplateLanguage(templateSlug, templateLanguage) {
    const params = {};
    const url = "/lobby/v1/admin/notification/namespaces/{namespace}/templates/{templateSlug}/languages/{templateLanguage}/publish".replace("{namespace}", this.namespace).replace("{templateSlug}", templateSlug).replace("{templateLanguage}", templateLanguage);
    const resultPromise = this.axiosInstance.post(url, null, { params });
    return import_sdk7.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, import_zod27.z.unknown(), "z.unknown()");
  }
};

// src/generated-admin/endpoints/PartyAdmin$.ts
var import_sdk8 = require("@accelbyte/sdk");
var PartyAdmin$ = class {
  // @ts-ignore
  // prettier-ignore
  constructor(axiosInstance, namespace, useSchemaValidation = true) {
    this.axiosInstance = axiosInstance;
    this.namespace = namespace;
    this.useSchemaValidation = useSchemaValidation;
  }
  /**
   * Get party data in a namespace.
   */
  getPartyParty_ByPartyId(partyId) {
    const params = {};
    const url = "/lobby/v1/admin/party/namespaces/{namespace}/parties/{partyId}".replace("{namespace}", this.namespace).replace("{partyId}", partyId);
    const resultPromise = this.axiosInstance.get(url, { params });
    return import_sdk8.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, PartyData, "PartyData");
  }
  /**
   * Get party data in a namespace.
   */
  getParty_ByUserId(userId) {
    const params = {};
    const url = "/lobby/v1/admin/party/namespaces/{namespace}/users/{userId}/party".replace("{namespace}", this.namespace).replace("{userId}", userId);
    const resultPromise = this.axiosInstance.get(url, { params });
    return import_sdk8.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, PartyData, "PartyData");
  }
};

// src/generated-admin/endpoints/PlayerAdmin$.ts
var import_sdk9 = require("@accelbyte/sdk");
var import_zod36 = require("zod");

// src/generated-definitions/GetAllPlayerBlockedByUsersResponse.ts
var import_zod29 = require("zod");

// src/generated-definitions/BlockedByPlayerData.ts
var import_zod28 = require("zod");
var BlockedByPlayerData = import_zod28.z.object({ blockedAt: import_zod28.z.string(), userId: import_zod28.z.string() });

// src/generated-definitions/GetAllPlayerBlockedByUsersResponse.ts
var GetAllPlayerBlockedByUsersResponse = import_zod29.z.object({ data: import_zod29.z.array(BlockedByPlayerData) });

// src/generated-definitions/GetAllPlayerBlockedUsersResponse.ts
var import_zod31 = require("zod");

// src/generated-definitions/BlockedPlayerData.ts
var import_zod30 = require("zod");
var BlockedPlayerData = import_zod30.z.object({ blockedAt: import_zod30.z.string(), blockedUserId: import_zod30.z.string() });

// src/generated-definitions/GetAllPlayerBlockedUsersResponse.ts
var GetAllPlayerBlockedUsersResponse = import_zod31.z.object({ data: import_zod31.z.array(BlockedPlayerData) });

// src/generated-definitions/GetAllPlayerSessionAttributeResponse.ts
var import_zod32 = require("zod");
var GetAllPlayerSessionAttributeResponse = import_zod32.z.object({ attributes: import_zod32.z.record(import_zod32.z.string()) });

// src/generated-definitions/GetBulkAllPlayerBlockedUsersResponse.ts
var import_zod33 = require("zod");
var GetBulkAllPlayerBlockedUsersResponse = import_zod33.z.object({ data: import_zod33.z.record(import_zod33.z.array(BlockedPlayerData)) });

// src/generated-definitions/GetLobbyCcuResponse.ts
var import_zod34 = require("zod");
var GetLobbyCcuResponse = import_zod34.z.object({ countCurrentUsers: import_zod34.z.number().int() });

// src/generated-definitions/GetPlayerSessionAttributeResponse.ts
var import_zod35 = require("zod");
var GetPlayerSessionAttributeResponse = import_zod35.z.object({ key: import_zod35.z.string(), value: import_zod35.z.string() });

// src/generated-admin/endpoints/PlayerAdmin$.ts
var PlayerAdmin$ = class {
  // @ts-ignore
  // prettier-ignore
  constructor(axiosInstance, namespace, useSchemaValidation = true) {
    this.axiosInstance = axiosInstance;
    this.namespace = namespace;
    this.useSchemaValidation = useSchemaValidation;
  }
  /**
   * Get the number of players connected to the Lobby in the given namespace.
   */
  getPlayerCcu() {
    const params = {};
    const url = "/lobby/v1/admin/player/namespaces/{namespace}/ccu".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.get(url, { params });
    return import_sdk9.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, GetLobbyCcuResponse, "GetLobbyCcuResponse");
  }
  /**
   * Get blocked players data by bulk user ids in a namespace.
   */
  fetchPlayerUserBulkBlocked(data) {
    const params = {};
    const url = "/lobby/v1/admin/player/namespaces/{namespace}/users/bulk/blocked".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.post(url, data, { params });
    return import_sdk9.Validate.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      GetBulkAllPlayerBlockedUsersResponse,
      "GetBulkAllPlayerBlockedUsersResponse"
    );
  }
  /**
   * Get blocked players data by user id in a namespace.
   */
  getBlockedPlayer_ByUserId(userId) {
    const params = {};
    const url = "/lobby/v1/admin/player/namespaces/{namespace}/users/{userId}/blocked".replace("{namespace}", this.namespace).replace("{userId}", userId);
    const resultPromise = this.axiosInstance.get(url, { params });
    return import_sdk9.Validate.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      GetAllPlayerBlockedUsersResponse,
      "GetAllPlayerBlockedUsersResponse"
    );
  }
  /**
   * Get all player&#39;s session attribute by user id in a namespace.
   */
  getAttributesPlayer_ByUserId(userId) {
    const params = {};
    const url = "/lobby/v1/admin/player/namespaces/{namespace}/users/{userId}/attributes".replace("{namespace}", this.namespace).replace("{userId}", userId);
    const resultPromise = this.axiosInstance.get(url, { params });
    return import_sdk9.Validate.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      GetAllPlayerSessionAttributeResponse,
      "GetAllPlayerSessionAttributeResponse"
    );
  }
  /**
   * Set player&#39;s session attribute by user id in a namespace.
   */
  updateAttributePlayer_ByUserId(userId, data) {
    const params = {};
    const url = "/lobby/v1/admin/player/namespaces/{namespace}/users/{userId}/attributes".replace("{namespace}", this.namespace).replace("{userId}", userId);
    const resultPromise = this.axiosInstance.put(url, data, { params });
    return import_sdk9.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, import_zod36.z.unknown(), "z.unknown()");
  }
  /**
   * Load get players who blocked this player in a namespace based on user id
   */
  getBlockedByPlayer_ByUserId(userId) {
    const params = {};
    const url = "/lobby/v1/admin/player/namespaces/{namespace}/users/{userId}/blocked-by".replace("{namespace}", this.namespace).replace("{userId}", userId);
    const resultPromise = this.axiosInstance.get(url, { params });
    return import_sdk9.Validate.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      GetAllPlayerBlockedByUsersResponse,
      "GetAllPlayerBlockedByUsersResponse"
    );
  }
  /**
   * Bulk block player in a namespace by list of user id
   */
  createBulkBlockPlayer_ByUserId(userId, data) {
    const params = {};
    const url = "/lobby/v1/admin/player/namespaces/{namespace}/users/{userId}/bulk/block".replace("{namespace}", this.namespace).replace("{userId}", userId);
    const resultPromise = this.axiosInstance.post(url, data, { params });
    return import_sdk9.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, import_zod36.z.unknown(), "z.unknown()");
  }
  /**
   * Bulk unblock player in a namespace by list of user id
   */
  deleteBulkUnblockPlayer_ByUserId(userId, data) {
    const params = {};
    const url = "/lobby/v1/admin/player/namespaces/{namespace}/users/{userId}/bulk/unblock".replace("{namespace}", this.namespace).replace("{userId}", userId);
    const resultPromise = this.axiosInstance.delete(url, { data, params });
    return import_sdk9.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, import_zod36.z.unknown(), "z.unknown()");
  }
  /**
   * Get player&#39;s specific session attribute by user id in a namespace.
   */
  getAttributePlayer_ByUserId_ByAttribute(userId, attribute) {
    const params = {};
    const url = "/lobby/v1/admin/player/namespaces/{namespace}/users/{userId}/attributes/{attribute}".replace("{namespace}", this.namespace).replace("{userId}", userId).replace("{attribute}", attribute);
    const resultPromise = this.axiosInstance.get(url, { params });
    return import_sdk9.Validate.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      GetPlayerSessionAttributeResponse,
      "GetPlayerSessionAttributeResponse"
    );
  }
};

// src/generated-admin/endpoints/ProfanityAdmin$.ts
var import_sdk10 = require("@accelbyte/sdk");
var import_zod44 = require("zod");

// src/generated-definitions/AdminGetProfanityListFiltersV1Response.ts
var import_zod38 = require("zod");

// src/generated-definitions/ProfanityFilter.ts
var import_zod37 = require("zod");
var ProfanityFilter = import_zod37.z.object({ filter: import_zod37.z.string(), listName: import_zod37.z.string(), namespace: import_zod37.z.string(), note: import_zod37.z.string() });

// src/generated-definitions/AdminGetProfanityListFiltersV1Response.ts
var AdminGetProfanityListFiltersV1Response = import_zod38.z.object({ filters: import_zod38.z.array(ProfanityFilter) });

// src/generated-definitions/AdminGetProfanityListsListResponseArray.ts
var import_zod40 = require("zod");

// src/generated-definitions/AdminGetProfanityListsListResponse.ts
var import_zod39 = require("zod");
var AdminGetProfanityListsListResponse = import_zod39.z.object({ isEnabled: import_zod39.z.boolean(), isMandatory: import_zod39.z.boolean(), name: import_zod39.z.string() });

// src/generated-definitions/AdminGetProfanityListsListResponseArray.ts
var AdminGetProfanityListsListResponseArray = import_zod40.z.array(AdminGetProfanityListsListResponse);

// src/generated-definitions/AdminVerifyMessageProfanityResponse.ts
var import_zod41 = require("zod");
var AdminVerifyMessageProfanityResponse = import_zod41.z.object({ filteredMessage: import_zod41.z.string(), hasProfanity: import_zod41.z.boolean() });

// src/generated-definitions/ProfanityFilterArray.ts
var import_zod42 = require("zod");
var ProfanityFilterArray = import_zod42.z.array(ProfanityFilter);

// src/generated-definitions/ProfanityRule.ts
var import_zod43 = require("zod");
var ProfanityRule = import_zod43.z.object({ Namespace: import_zod43.z.string(), Rule: import_zod43.z.string() });

// src/generated-admin/endpoints/ProfanityAdmin$.ts
var ProfanityAdmin$ = class {
  // @ts-ignore
  // prettier-ignore
  constructor(axiosInstance, namespace, useSchemaValidation = true) {
    this.axiosInstance = axiosInstance;
    this.namespace = namespace;
    this.useSchemaValidation = useSchemaValidation;
  }
  /**
   * Get current profanity rule
   */
  getProfanityRule() {
    const params = {};
    const url = "/lobby/v1/admin/profanity/namespaces/{namespace}/rule".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.get(url, { params });
    return import_sdk10.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, ProfanityRule, "ProfanityRule");
  }
  /**
   * Set current profanity rule
   */
  updateProfanityRule(data) {
    const params = {};
    const url = "/lobby/v1/admin/profanity/namespaces/{namespace}/rule".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.post(url, data, { params });
    return import_sdk10.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, import_zod44.z.unknown(), "z.unknown()");
  }
  /**
   * Get lists
   */
  getProfanityLists() {
    const params = {};
    const url = "/lobby/v1/admin/profanity/namespaces/{namespace}/lists".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.get(url, { params });
    return import_sdk10.Validate.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      AdminGetProfanityListsListResponseArray,
      "AdminGetProfanityListsListResponseArray"
    );
  }
  /**
   * Create a new list
   */
  createProfanityList(data) {
    const params = {};
    const url = "/lobby/v1/admin/profanity/namespaces/{namespace}/lists".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.post(url, data, { params });
    return import_sdk10.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, import_zod44.z.unknown(), "z.unknown()");
  }
  /**
   * Verify a message directly from the UI or other services
   */
  fetchProfanityVerify(data) {
    const params = {};
    const url = "/lobby/v1/admin/profanity/namespaces/{namespace}/verify".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.post(url, data, { params });
    return import_sdk10.Validate.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      AdminVerifyMessageProfanityResponse,
      "AdminVerifyMessageProfanityResponse"
    );
  }
  /**
   * Delete a list include all filters inside of it
   */
  deleteProfanityList_ByList(list) {
    const params = {};
    const url = "/lobby/v1/admin/profanity/namespaces/{namespace}/lists/{list}".replace("{namespace}", this.namespace).replace("{list}", list);
    const resultPromise = this.axiosInstance.delete(url, { params });
    return import_sdk10.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, import_zod44.z.unknown(), "z.unknown()");
  }
  /**
   * Update the list
   */
  updateProfanityList_ByList(list, data) {
    const params = {};
    const url = "/lobby/v1/admin/profanity/namespaces/{namespace}/lists/{list}".replace("{namespace}", this.namespace).replace("{list}", list);
    const resultPromise = this.axiosInstance.post(url, data, { params });
    return import_sdk10.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, import_zod44.z.unknown(), "z.unknown()");
  }
  /**
   * Get the list of filters that would modify the phrase
   */
  fetchProfanityFilterDebug(data) {
    const params = {};
    const url = "/lobby/v1/admin/profanity/namespaces/{namespace}/filters/debug".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.post(url, data, { params });
    return import_sdk10.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, ProfanityFilterArray, "ProfanityFilterArray");
  }
  /**
   * Get the list of filters inside the list.
   */
  getFiltersProfanity_ByList(list) {
    const params = {};
    const url = "/lobby/v1/admin/profanity/namespaces/{namespace}/list/{list}/filters".replace("{namespace}", this.namespace).replace("{list}", list);
    const resultPromise = this.axiosInstance.get(url, { params });
    return import_sdk10.Validate.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      AdminGetProfanityListFiltersV1Response,
      "AdminGetProfanityListFiltersV1Response"
    );
  }
  /**
   * Add a single filter into the list
   */
  createFilterProfanity_ByList(list, data) {
    const params = {};
    const url = "/lobby/v1/admin/profanity/namespaces/{namespace}/list/{list}/filters".replace("{namespace}", this.namespace).replace("{list}", list);
    const resultPromise = this.axiosInstance.post(url, data, { params });
    return import_sdk10.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, import_zod44.z.unknown(), "z.unknown()");
  }
  /**
   * Add multiple filters into the list
   */
  createFilterBulkProfanity_ByList(list, data) {
    const params = {};
    const url = "/lobby/v1/admin/profanity/namespaces/{namespace}/list/{list}/filters/bulk".replace("{namespace}", this.namespace).replace("{list}", list);
    const resultPromise = this.axiosInstance.post(url, data, { params });
    return import_sdk10.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, import_zod44.z.unknown(), "z.unknown()");
  }
  /**
   * Delete the filter from the list
   */
  createFilterDeleteProfanity_ByList(list, data) {
    const params = {};
    const url = "/lobby/v1/admin/profanity/namespaces/{namespace}/list/{list}/filters/delete".replace("{namespace}", this.namespace).replace("{list}", list);
    const resultPromise = this.axiosInstance.post(url, data, { params });
    return import_sdk10.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, ProfanityFilterArray, "ProfanityFilterArray");
  }
  /**
   * Import a file with filters
   */
  createFilterBulkFileProfanity_ByList(list, data) {
    const params = {};
    const url = "/lobby/v1/admin/profanity/namespaces/{namespace}/list/{list}/filters/bulk-file".replace("{namespace}", this.namespace).replace("{list}", list);
    const resultPromise = this.axiosInstance.post(url, data, { params });
    return import_sdk10.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, import_zod44.z.unknown(), "z.unknown()");
  }
};

// src/generated-admin/endpoints/ThirdPartyAdmin$.ts
var import_sdk11 = require("@accelbyte/sdk");
var import_zod48 = require("zod");

// src/generated-definitions/CreateConfigResponse.ts
var import_zod45 = require("zod");
var CreateConfigResponse = import_zod45.z.object({ apiKey: import_zod45.z.string(), namespace: import_zod45.z.string() });

// src/generated-definitions/GetConfigResponse.ts
var import_zod46 = require("zod");
var GetConfigResponse = import_zod46.z.object({ apiKey: import_zod46.z.string(), namespace: import_zod46.z.string() });

// src/generated-definitions/UpdateConfigResponse.ts
var import_zod47 = require("zod");
var UpdateConfigResponse = import_zod47.z.object({ apiKey: import_zod47.z.string(), namespace: import_zod47.z.string() });

// src/generated-admin/endpoints/ThirdPartyAdmin$.ts
var ThirdPartyAdmin$ = class {
  // @ts-ignore
  // prettier-ignore
  constructor(axiosInstance, namespace, useSchemaValidation = true) {
    this.axiosInstance = axiosInstance;
    this.namespace = namespace;
    this.useSchemaValidation = useSchemaValidation;
  }
  /**
   * Required permission : &lt;code&gt;ADMIN:NAMESPACE:{namespace}:THIRDPARTY:CONFIG [DELETE]&lt;/code&gt; with scope &lt;code&gt;social&lt;/code&gt; &lt;br&gt;delete third party config in a namespace.
   */
  deleteThirdpartyConfigSteam() {
    const params = {};
    const url = "/lobby/v1/admin/thirdparty/namespaces/{namespace}/config/steam".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.delete(url, { params });
    return import_sdk11.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, import_zod48.z.unknown(), "z.unknown()");
  }
  /**
   * Get third party config for specified namespace.
   */
  getThirdpartyConfigSteam() {
    const params = {};
    const url = "/lobby/v1/admin/thirdparty/namespaces/{namespace}/config/steam".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.get(url, { params });
    return import_sdk11.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, GetConfigResponse, "GetConfigResponse");
  }
  /**
   * Create third party config in a namespace.
   */
  createThirdpartyConfigSteam(data) {
    const params = {};
    const url = "/lobby/v1/admin/thirdparty/namespaces/{namespace}/config/steam".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.post(url, data, { params });
    return import_sdk11.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, CreateConfigResponse, "CreateConfigResponse");
  }
  /**
   * Update third party config in a namespace.
   */
  updateThirdpartyConfigSteam(data) {
    const params = {};
    const url = "/lobby/v1/admin/thirdparty/namespaces/{namespace}/config/steam".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.put(url, data, { params });
    return import_sdk11.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, UpdateConfigResponse, "UpdateConfigResponse");
  }
};

// src/generated-admin/FriendsAdminApi.ts
var import_sdk12 = require("@accelbyte/sdk");
function FriendsAdminApi(sdk, args) {
  const sdkAssembly = sdk.assembly();
  const namespace = args?.coreConfig?.namespace ?? sdkAssembly.coreConfig.namespace;
  const useSchemaValidation = args?.coreConfig?.useSchemaValidation ?? sdkAssembly.coreConfig.useSchemaValidation;
  let axiosInstance = sdkAssembly.axiosInstance;
  const requestConfigOverrides = args?.axiosConfig?.request;
  const baseURLOverride = args?.coreConfig?.baseURL;
  const interceptorsOverride = args?.axiosConfig?.interceptors ?? [];
  if (requestConfigOverrides || baseURLOverride || interceptorsOverride.length > 0) {
    const requestConfig = import_sdk12.ApiUtils.mergeAxiosConfigs(sdkAssembly.axiosInstance.defaults, {
      ...baseURLOverride ? { baseURL: baseURLOverride } : {},
      ...requestConfigOverrides
    });
    axiosInstance = import_sdk12.Network.create(requestConfig);
    for (const interceptor of interceptorsOverride) {
      if (interceptor.type === "request") {
        axiosInstance.interceptors.request.use(interceptor.onRequest, interceptor.onError);
      }
      if (interceptor.type === "response") {
        axiosInstance.interceptors.response.use(interceptor.onSuccess, interceptor.onError);
      }
    }
  }
  async function getFriendUser_ByUserId(userId, queryParams) {
    const $ = new FriendsAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getFriendUser_ByUserId(userId, queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getIncomingFriend_ByUserId(userId, queryParams) {
    const $ = new FriendsAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getIncomingFriend_ByUserId(userId, queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getOutgoingFriend_ByUserId(userId, queryParams) {
    const $ = new FriendsAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getOutgoingFriend_ByUserId(userId, queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getOfFriends_ByUserId(userId, queryParams) {
    const $ = new FriendsAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getOfFriends_ByUserId(userId, queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  return {
    /**
     * Get list of friends in a namespace.
     */
    getFriendUser_ByUserId,
    /**
     * Get list of incoming friend requests.
     */
    getIncomingFriend_ByUserId,
    /**
     * Get list of outgoing friend requests in a namespace.
     */
    getOutgoingFriend_ByUserId,
    /**
     * Load list friends and friends of friends in a namespace. Response subjectId will be different with requested userId if the user is not directly friend
     */
    getOfFriends_ByUserId
  };
}

// src/generated-admin/LobbyOperationsAdminApi.ts
var import_sdk13 = require("@accelbyte/sdk");
function LobbyOperationsAdminApi(sdk, args) {
  const sdkAssembly = sdk.assembly();
  const namespace = args?.coreConfig?.namespace ?? sdkAssembly.coreConfig.namespace;
  const useSchemaValidation = args?.coreConfig?.useSchemaValidation ?? sdkAssembly.coreConfig.useSchemaValidation;
  let axiosInstance = sdkAssembly.axiosInstance;
  const requestConfigOverrides = args?.axiosConfig?.request;
  const baseURLOverride = args?.coreConfig?.baseURL;
  const interceptorsOverride = args?.axiosConfig?.interceptors ?? [];
  if (requestConfigOverrides || baseURLOverride || interceptorsOverride.length > 0) {
    const requestConfig = import_sdk13.ApiUtils.mergeAxiosConfigs(sdkAssembly.axiosInstance.defaults, {
      ...baseURLOverride ? { baseURL: baseURLOverride } : {},
      ...requestConfigOverrides
    });
    axiosInstance = import_sdk13.Network.create(requestConfig);
    for (const interceptor of interceptorsOverride) {
      if (interceptor.type === "request") {
        axiosInstance.interceptors.request.use(interceptor.onRequest, interceptor.onError);
      }
      if (interceptor.type === "response") {
        axiosInstance.interceptors.response.use(interceptor.onSuccess, interceptor.onError);
      }
    }
  }
  async function updateAttributeParty_ByPartyId(partyId, data) {
    const $ = new LobbyOperationsAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.updateAttributeParty_ByPartyId(partyId, data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function updateJoinParty_ByPartyId_ByUserId(partyId, userId) {
    const $ = new LobbyOperationsAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.updateJoinParty_ByPartyId_ByUserId(partyId, userId);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  return {
    /**
     * Update party attributes in a namespace.
     */
    updateAttributeParty_ByPartyId,
    /**
     * Admin join a player into a party.
     */
    updateJoinParty_ByPartyId_ByUserId
  };
}

// src/generated-admin/NotificationAdminApi.ts
var import_sdk14 = require("@accelbyte/sdk");
function NotificationAdminApi(sdk, args) {
  const sdkAssembly = sdk.assembly();
  const namespace = args?.coreConfig?.namespace ?? sdkAssembly.coreConfig.namespace;
  const useSchemaValidation = args?.coreConfig?.useSchemaValidation ?? sdkAssembly.coreConfig.useSchemaValidation;
  let axiosInstance = sdkAssembly.axiosInstance;
  const requestConfigOverrides = args?.axiosConfig?.request;
  const baseURLOverride = args?.coreConfig?.baseURL;
  const interceptorsOverride = args?.axiosConfig?.interceptors ?? [];
  if (requestConfigOverrides || baseURLOverride || interceptorsOverride.length > 0) {
    const requestConfig = import_sdk14.ApiUtils.mergeAxiosConfigs(sdkAssembly.axiosInstance.defaults, {
      ...baseURLOverride ? { baseURL: baseURLOverride } : {},
      ...requestConfigOverrides
    });
    axiosInstance = import_sdk14.Network.create(requestConfig);
    for (const interceptor of interceptorsOverride) {
      if (interceptor.type === "request") {
        axiosInstance.interceptors.request.use(interceptor.onRequest, interceptor.onError);
      }
      if (interceptor.type === "response") {
        axiosInstance.interceptors.response.use(interceptor.onSuccess, interceptor.onError);
      }
    }
  }
  async function getNotificationTopics(queryParams) {
    const $ = new NotificationAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getNotificationTopics(queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function createNotificationTopic(data) {
    const $ = new NotificationAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.createNotificationTopic(data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getNotificationTemplates() {
    const $ = new NotificationAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getNotificationTemplates();
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function createNotificationTemplate(data) {
    const $ = new NotificationAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.createNotificationTemplate(data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function createNotificationFreeformNotify(data) {
    const $ = new NotificationAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.createNotificationFreeformNotify(data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function createNotificationTemplateNotify(data) {
    const $ = new NotificationAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.createNotificationTemplateNotify(data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function deleteNotificationTopic_ByTopicName(topicName) {
    const $ = new NotificationAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.deleteNotificationTopic_ByTopicName(topicName);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getNotificationTopic_ByTopicName(topicName) {
    const $ = new NotificationAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getNotificationTopic_ByTopicName(topicName);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function updateNotificationTopic_ByTopicName(topicName, data) {
    const $ = new NotificationAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.updateNotificationTopic_ByTopicName(topicName, data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function deleteNotificationTemplate_ByTemplateSlug(templateSlug) {
    const $ = new NotificationAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.deleteNotificationTemplate_ByTemplateSlug(templateSlug);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getNotificationTemplate_ByTemplateSlug(templateSlug, queryParams) {
    const $ = new NotificationAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getNotificationTemplate_ByTemplateSlug(templateSlug, queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function createNotificationBulkUserFreeformNotify(data) {
    const $ = new NotificationAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.createNotificationBulkUserFreeformNotify(data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function createFreeformNotifyNotification_ByUserId(userId, data) {
    const $ = new NotificationAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.createFreeformNotifyNotification_ByUserId(userId, data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function createTemplateNotifyNotification_ByUserId(userId, data) {
    const $ = new NotificationAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.createTemplateNotifyNotification_ByUserId(userId, data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function createFreeformNotifyNotification_ByPartyId(partyId, data) {
    const $ = new NotificationAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.createFreeformNotifyNotification_ByPartyId(partyId, data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function createTemplateNotifyNotification_ByPartyId(partyId, data) {
    const $ = new NotificationAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.createTemplateNotifyNotification_ByPartyId(partyId, data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function deleteLanguageNotification_ByTemplateSlug_ByTemplateLanguage(templateSlug, templateLanguage) {
    const $ = new NotificationAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.deleteLanguageNotification_ByTemplateSlug_ByTemplateLanguage(templateSlug, templateLanguage);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getLanguageNotification_ByTemplateSlug_ByTemplateLanguage(templateSlug, templateLanguage) {
    const $ = new NotificationAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getLanguageNotification_ByTemplateSlug_ByTemplateLanguage(templateSlug, templateLanguage);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function updateLanguageNotification_ByTemplateSlug_ByTemplateLanguage(templateSlug, templateLanguage, data) {
    const $ = new NotificationAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.updateLanguageNotification_ByTemplateSlug_ByTemplateLanguage(templateSlug, templateLanguage, data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function createPublishNotification_ByTemplateSlug_ByTemplateLanguage(templateSlug, templateLanguage) {
    const $ = new NotificationAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.createPublishNotification_ByTemplateSlug_ByTemplateLanguage(templateSlug, templateLanguage);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  return {
    /**
     * Get topic by namespace.&lt;br/&gt; Action Code: 50213
     */
    getNotificationTopics,
    /**
     * Create new notification topic. &lt;br&gt;topic should be alphabets, no special char except underscore, uppercase and no spacing. for example: TOPIC_TEST. Already existing topic can not be created&lt;br/&gt; Action Code: 50214
     */
    createNotificationTopic,
    /**
     * Get all templates in a namespace&lt;br&gt; Action Code: 50203
     */
    getNotificationTemplates,
    /**
     * Create new notification template. Include handlebars {{key}} for replaceable contexts. The key inside handlebars will be the key to be replaced when sending notification. Already existing template with the same slug and language can not be created. &lt;br&gt;Check model description for detailed input restrictions.&lt;br&gt; Action Code: 50204
     */
    createNotificationTemplate,
    /**
     * Sends notification to all connected users in a namespace.&lt;br&gt; Action Code: 50201
     */
    createNotificationFreeformNotify,
    /**
     * Sends notification to all connected users in a namespace with predefined template. &lt;br&gt;In the request body, specify which template slug (template identifier) to use and the template language. &lt;br&gt;NotificationTemplate context is the key-value pair defining the value of each handlebar specified in the template content. Template need to be published before it can be use to send notifications&lt;br/&gt; Action Code: 50202
     */
    createNotificationTemplateNotify,
    /**
     * Delete topic information by topic name. &lt;br&gt;topic should be alphabets, no special char except underscore, uppercase and no spacing. for example: TOPIC_TEST. Already existing topic can not be created &lt;br/&gt; Action Code: 50217
     */
    deleteNotificationTopic_ByTopicName,
    /**
     * Get topic information by topic name.&lt;br/&gt; Action Code: 50215
     */
    getNotificationTopic_ByTopicName,
    /**
     * Update topic information by topic name. &lt;br&gt;topic should be alphabets, no special char except underscore, uppercase and no spacing. for example: TOPIC_TEST. Already existing topic can not be created &lt;br/&gt; Action Code: 50216
     */
    updateNotificationTopic_ByTopicName,
    /**
     * Delete template slug in notification template&lt;br&gt; Action Code: 50206
     */
    deleteNotificationTemplate_ByTemplateSlug,
    /**
     * Get all templates in a namespace&lt;br&gt; Action Code: 50205
     */
    getNotificationTemplate_ByTemplateSlug,
    /**
     * Sends notification to multiple user. Action Code: 50211
     */
    createNotificationBulkUserFreeformNotify,
    /**
     * Sends notification to a user. Action Code: 50211
     */
    createFreeformNotifyNotification_ByUserId,
    /**
     * Sends templated notification to a user. &lt;br&gt;In the request body, specify which template slug (template identifier) to use and the template language. &lt;br&gt;NotificationTemplate context is the key-value pair defining the value of each handlebar specified in the template content. Template need to be published before it can be use to send notifications&lt;br&gt; Action Code: 50212
     */
    createTemplateNotifyNotification_ByUserId,
    /**
     * Sends notification to a party.
     */
    createFreeformNotifyNotification_ByPartyId,
    /**
     * Sends templated notification to a party. &lt;br&gt;In the request body, specify which template slug (template identifier) to use and the template language. &lt;br&gt;NotificationTemplate context is the key-value pair defining the value of each handlebar specified in the template content. Template need to be published before it can be use to send notifications&lt;br&gt;
     */
    createTemplateNotifyNotification_ByPartyId,
    /**
     * Delete template localization&lt;br/&gt; Action Code: 50209
     */
    deleteLanguageNotification_ByTemplateSlug_ByTemplateLanguage,
    /**
     * Get a template localization&lt;br/&gt; Action Code: 50207
     */
    getLanguageNotification_ByTemplateSlug_ByTemplateLanguage,
    /**
     * Update template localization&lt;br/&gt; Action Code: 50208
     */
    updateLanguageNotification_ByTemplateSlug_ByTemplateLanguage,
    /**
     * Publish notification template draft. Empty draft can not be published.&lt;br/&gt; Action Code: 50210
     */
    createPublishNotification_ByTemplateSlug_ByTemplateLanguage
  };
}

// src/generated-admin/PartyAdminApi.ts
var import_sdk15 = require("@accelbyte/sdk");
function PartyAdminApi(sdk, args) {
  const sdkAssembly = sdk.assembly();
  const namespace = args?.coreConfig?.namespace ?? sdkAssembly.coreConfig.namespace;
  const useSchemaValidation = args?.coreConfig?.useSchemaValidation ?? sdkAssembly.coreConfig.useSchemaValidation;
  let axiosInstance = sdkAssembly.axiosInstance;
  const requestConfigOverrides = args?.axiosConfig?.request;
  const baseURLOverride = args?.coreConfig?.baseURL;
  const interceptorsOverride = args?.axiosConfig?.interceptors ?? [];
  if (requestConfigOverrides || baseURLOverride || interceptorsOverride.length > 0) {
    const requestConfig = import_sdk15.ApiUtils.mergeAxiosConfigs(sdkAssembly.axiosInstance.defaults, {
      ...baseURLOverride ? { baseURL: baseURLOverride } : {},
      ...requestConfigOverrides
    });
    axiosInstance = import_sdk15.Network.create(requestConfig);
    for (const interceptor of interceptorsOverride) {
      if (interceptor.type === "request") {
        axiosInstance.interceptors.request.use(interceptor.onRequest, interceptor.onError);
      }
      if (interceptor.type === "response") {
        axiosInstance.interceptors.response.use(interceptor.onSuccess, interceptor.onError);
      }
    }
  }
  async function getPartyParty_ByPartyId(partyId) {
    const $ = new PartyAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getPartyParty_ByPartyId(partyId);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getParty_ByUserId(userId) {
    const $ = new PartyAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getParty_ByUserId(userId);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  return {
    /**
     * Get party data in a namespace.
     */
    getPartyParty_ByPartyId,
    /**
     * Get party data in a namespace.
     */
    getParty_ByUserId
  };
}

// src/generated-admin/PlayerAdminApi.ts
var import_sdk16 = require("@accelbyte/sdk");
function PlayerAdminApi(sdk, args) {
  const sdkAssembly = sdk.assembly();
  const namespace = args?.coreConfig?.namespace ?? sdkAssembly.coreConfig.namespace;
  const useSchemaValidation = args?.coreConfig?.useSchemaValidation ?? sdkAssembly.coreConfig.useSchemaValidation;
  let axiosInstance = sdkAssembly.axiosInstance;
  const requestConfigOverrides = args?.axiosConfig?.request;
  const baseURLOverride = args?.coreConfig?.baseURL;
  const interceptorsOverride = args?.axiosConfig?.interceptors ?? [];
  if (requestConfigOverrides || baseURLOverride || interceptorsOverride.length > 0) {
    const requestConfig = import_sdk16.ApiUtils.mergeAxiosConfigs(sdkAssembly.axiosInstance.defaults, {
      ...baseURLOverride ? { baseURL: baseURLOverride } : {},
      ...requestConfigOverrides
    });
    axiosInstance = import_sdk16.Network.create(requestConfig);
    for (const interceptor of interceptorsOverride) {
      if (interceptor.type === "request") {
        axiosInstance.interceptors.request.use(interceptor.onRequest, interceptor.onError);
      }
      if (interceptor.type === "response") {
        axiosInstance.interceptors.response.use(interceptor.onSuccess, interceptor.onError);
      }
    }
  }
  async function getPlayerCcu() {
    const $ = new PlayerAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getPlayerCcu();
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function fetchPlayerUserBulkBlocked(data) {
    const $ = new PlayerAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.fetchPlayerUserBulkBlocked(data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getBlockedPlayer_ByUserId(userId) {
    const $ = new PlayerAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getBlockedPlayer_ByUserId(userId);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getAttributesPlayer_ByUserId(userId) {
    const $ = new PlayerAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getAttributesPlayer_ByUserId(userId);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function updateAttributePlayer_ByUserId(userId, data) {
    const $ = new PlayerAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.updateAttributePlayer_ByUserId(userId, data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getBlockedByPlayer_ByUserId(userId) {
    const $ = new PlayerAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getBlockedByPlayer_ByUserId(userId);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function createBulkBlockPlayer_ByUserId(userId, data) {
    const $ = new PlayerAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.createBulkBlockPlayer_ByUserId(userId, data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function deleteBulkUnblockPlayer_ByUserId(userId, data) {
    const $ = new PlayerAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.deleteBulkUnblockPlayer_ByUserId(userId, data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getAttributePlayer_ByUserId_ByAttribute(userId, attribute) {
    const $ = new PlayerAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getAttributePlayer_ByUserId_ByAttribute(userId, attribute);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  return {
    /**
     * Get the number of players connected to the Lobby in the given namespace.
     */
    getPlayerCcu,
    /**
     * Get blocked players data by bulk user ids in a namespace.
     */
    fetchPlayerUserBulkBlocked,
    /**
     * Get blocked players data by user id in a namespace.
     */
    getBlockedPlayer_ByUserId,
    /**
     * Get all player&#39;s session attribute by user id in a namespace.
     */
    getAttributesPlayer_ByUserId,
    /**
     * Set player&#39;s session attribute by user id in a namespace.
     */
    updateAttributePlayer_ByUserId,
    /**
     * Load get players who blocked this player in a namespace based on user id
     */
    getBlockedByPlayer_ByUserId,
    /**
     * Bulk block player in a namespace by list of user id
     */
    createBulkBlockPlayer_ByUserId,
    /**
     * Bulk unblock player in a namespace by list of user id
     */
    deleteBulkUnblockPlayer_ByUserId,
    /**
     * Get player&#39;s specific session attribute by user id in a namespace.
     */
    getAttributePlayer_ByUserId_ByAttribute
  };
}

// src/generated-admin/ProfanityAdminApi.ts
var import_sdk17 = require("@accelbyte/sdk");
function ProfanityAdminApi(sdk, args) {
  const sdkAssembly = sdk.assembly();
  const namespace = args?.coreConfig?.namespace ?? sdkAssembly.coreConfig.namespace;
  const useSchemaValidation = args?.coreConfig?.useSchemaValidation ?? sdkAssembly.coreConfig.useSchemaValidation;
  let axiosInstance = sdkAssembly.axiosInstance;
  const requestConfigOverrides = args?.axiosConfig?.request;
  const baseURLOverride = args?.coreConfig?.baseURL;
  const interceptorsOverride = args?.axiosConfig?.interceptors ?? [];
  if (requestConfigOverrides || baseURLOverride || interceptorsOverride.length > 0) {
    const requestConfig = import_sdk17.ApiUtils.mergeAxiosConfigs(sdkAssembly.axiosInstance.defaults, {
      ...baseURLOverride ? { baseURL: baseURLOverride } : {},
      ...requestConfigOverrides
    });
    axiosInstance = import_sdk17.Network.create(requestConfig);
    for (const interceptor of interceptorsOverride) {
      if (interceptor.type === "request") {
        axiosInstance.interceptors.request.use(interceptor.onRequest, interceptor.onError);
      }
      if (interceptor.type === "response") {
        axiosInstance.interceptors.response.use(interceptor.onSuccess, interceptor.onError);
      }
    }
  }
  async function getProfanityRule() {
    const $ = new ProfanityAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getProfanityRule();
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function updateProfanityRule(data) {
    const $ = new ProfanityAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.updateProfanityRule(data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getProfanityLists() {
    const $ = new ProfanityAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getProfanityLists();
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function createProfanityList(data) {
    const $ = new ProfanityAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.createProfanityList(data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function fetchProfanityVerify(data) {
    const $ = new ProfanityAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.fetchProfanityVerify(data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function deleteProfanityList_ByList(list) {
    const $ = new ProfanityAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.deleteProfanityList_ByList(list);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function updateProfanityList_ByList(list, data) {
    const $ = new ProfanityAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.updateProfanityList_ByList(list, data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function fetchProfanityFilterDebug(data) {
    const $ = new ProfanityAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.fetchProfanityFilterDebug(data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getFiltersProfanity_ByList(list) {
    const $ = new ProfanityAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getFiltersProfanity_ByList(list);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function createFilterProfanity_ByList(list, data) {
    const $ = new ProfanityAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.createFilterProfanity_ByList(list, data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function createFilterBulkProfanity_ByList(list, data) {
    const $ = new ProfanityAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.createFilterBulkProfanity_ByList(list, data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function createFilterDeleteProfanity_ByList(list, data) {
    const $ = new ProfanityAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.createFilterDeleteProfanity_ByList(list, data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function createFilterBulkFileProfanity_ByList(list, data) {
    const $ = new ProfanityAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.createFilterBulkFileProfanity_ByList(list, data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  return {
    /**
     * Get current profanity rule
     */
    getProfanityRule,
    /**
     * Set current profanity rule
     */
    updateProfanityRule,
    /**
     * Get lists
     */
    getProfanityLists,
    /**
     * Create a new list
     */
    createProfanityList,
    /**
     * Verify a message directly from the UI or other services
     */
    fetchProfanityVerify,
    /**
     * Delete a list include all filters inside of it
     */
    deleteProfanityList_ByList,
    /**
     * Update the list
     */
    updateProfanityList_ByList,
    /**
     * Get the list of filters that would modify the phrase
     */
    fetchProfanityFilterDebug,
    /**
     * Get the list of filters inside the list.
     */
    getFiltersProfanity_ByList,
    /**
     * Add a single filter into the list
     */
    createFilterProfanity_ByList,
    /**
     * Add multiple filters into the list
     */
    createFilterBulkProfanity_ByList,
    /**
     * Delete the filter from the list
     */
    createFilterDeleteProfanity_ByList,
    /**
     * Import a file with filters
     */
    createFilterBulkFileProfanity_ByList
  };
}

// src/generated-admin/ThirdPartyAdminApi.ts
var import_sdk18 = require("@accelbyte/sdk");
function ThirdPartyAdminApi(sdk, args) {
  const sdkAssembly = sdk.assembly();
  const namespace = args?.coreConfig?.namespace ?? sdkAssembly.coreConfig.namespace;
  const useSchemaValidation = args?.coreConfig?.useSchemaValidation ?? sdkAssembly.coreConfig.useSchemaValidation;
  let axiosInstance = sdkAssembly.axiosInstance;
  const requestConfigOverrides = args?.axiosConfig?.request;
  const baseURLOverride = args?.coreConfig?.baseURL;
  const interceptorsOverride = args?.axiosConfig?.interceptors ?? [];
  if (requestConfigOverrides || baseURLOverride || interceptorsOverride.length > 0) {
    const requestConfig = import_sdk18.ApiUtils.mergeAxiosConfigs(sdkAssembly.axiosInstance.defaults, {
      ...baseURLOverride ? { baseURL: baseURLOverride } : {},
      ...requestConfigOverrides
    });
    axiosInstance = import_sdk18.Network.create(requestConfig);
    for (const interceptor of interceptorsOverride) {
      if (interceptor.type === "request") {
        axiosInstance.interceptors.request.use(interceptor.onRequest, interceptor.onError);
      }
      if (interceptor.type === "response") {
        axiosInstance.interceptors.response.use(interceptor.onSuccess, interceptor.onError);
      }
    }
  }
  async function deleteThirdpartyConfigSteam() {
    const $ = new ThirdPartyAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.deleteThirdpartyConfigSteam();
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getThirdpartyConfigSteam() {
    const $ = new ThirdPartyAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getThirdpartyConfigSteam();
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function createThirdpartyConfigSteam(data) {
    const $ = new ThirdPartyAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.createThirdpartyConfigSteam(data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function updateThirdpartyConfigSteam(data) {
    const $ = new ThirdPartyAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.updateThirdpartyConfigSteam(data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  return {
    /**
     * Required permission : &lt;code&gt;ADMIN:NAMESPACE:{namespace}:THIRDPARTY:CONFIG [DELETE]&lt;/code&gt; with scope &lt;code&gt;social&lt;/code&gt; &lt;br&gt;delete third party config in a namespace.
     */
    deleteThirdpartyConfigSteam,
    /**
     * Get third party config for specified namespace.
     */
    getThirdpartyConfigSteam,
    /**
     * Create third party config in a namespace.
     */
    createThirdpartyConfigSteam,
    /**
     * Update third party config in a namespace.
     */
    updateThirdpartyConfigSteam
  };
}

// src/generated-definitions/AdminAddProfanityFilterIntoListRequest.ts
var import_zod49 = require("zod");
var AdminAddProfanityFilterIntoListRequest = import_zod49.z.object({ filter: import_zod49.z.string(), note: import_zod49.z.string() });

// src/generated-definitions/AdminAddProfanityFiltersFilterRequest.ts
var import_zod50 = require("zod");
var AdminAddProfanityFiltersFilterRequest = import_zod50.z.object({ filter: import_zod50.z.string(), note: import_zod50.z.string() });

// src/generated-definitions/AdminAddProfanityFiltersRequest.ts
var import_zod51 = require("zod");
var AdminAddProfanityFiltersRequest = import_zod51.z.object({ filters: import_zod51.z.array(AdminAddProfanityFiltersFilterRequest) });

// src/generated-definitions/AdminCreateProfanityListRequest.ts
var import_zod52 = require("zod");
var AdminCreateProfanityListRequest = import_zod52.z.object({ isEnabled: import_zod52.z.boolean(), isMandatory: import_zod52.z.boolean(), name: import_zod52.z.string() });

// src/generated-definitions/AdminDeleteProfanityFilterRequest.ts
var import_zod53 = require("zod");
var AdminDeleteProfanityFilterRequest = import_zod53.z.object({ filter: import_zod53.z.string() });

// src/generated-definitions/AdminSetProfanityRuleForNamespaceRequest.ts
var import_zod54 = require("zod");
var AdminSetProfanityRuleForNamespaceRequest = import_zod54.z.object({ rule: import_zod54.z.string() });

// src/generated-definitions/AdminUpdateProfanityList.ts
var import_zod55 = require("zod");
var AdminUpdateProfanityList = import_zod55.z.object({ isEnabled: import_zod55.z.boolean(), isMandatory: import_zod55.z.boolean(), newName: import_zod55.z.string() });

// src/generated-definitions/AdminVerifyMessageProfanityRequest.ts
var import_zod56 = require("zod");
var AdminVerifyMessageProfanityRequest = import_zod56.z.object({ message: import_zod56.z.string(), profanityLevel: import_zod56.z.string() });

// src/generated-definitions/AppMessageDeclaration.ts
var import_zod57 = require("zod");
var AppMessageDeclaration = import_zod57.z.object({
  Attributes: import_zod57.z.array(import_zod57.z.string()),
  Code: import_zod57.z.string(),
  CodeName: import_zod57.z.string(),
  Section: import_zod57.z.string(),
  Service: import_zod57.z.string(),
  Text: import_zod57.z.string()
});

// src/generated-definitions/AppMessageDeclarationArray.ts
var import_zod58 = require("zod");
var AppMessageDeclarationArray = import_zod58.z.array(AppMessageDeclaration);

// src/generated-definitions/BlockPlayerRequest.ts
var import_zod59 = require("zod");
var BlockPlayerRequest = import_zod59.z.object({ blockedUserId: import_zod59.z.string() });

// src/generated-definitions/BulkFriendsRequest.ts
var import_zod60 = require("zod");
var BulkFriendsRequest = import_zod60.z.object({ friendIds: import_zod60.z.array(import_zod60.z.string()) });

// src/generated-definitions/BulkFriendsResponse.ts
var import_zod61 = require("zod");
var BulkFriendsResponse = import_zod61.z.object({ rowsAffected: import_zod61.z.number().int() });

// src/generated-definitions/BulkUsersFreeFormNotificationRequestV1.ts
var import_zod62 = require("zod");
var BulkUsersFreeFormNotificationRequestV1 = import_zod62.z.object({ message: import_zod62.z.string(), topicName: import_zod62.z.string(), userIds: import_zod62.z.array(import_zod62.z.string()) });

// src/generated-definitions/CreateConfigRequest.ts
var import_zod63 = require("zod");
var CreateConfigRequest = import_zod63.z.object({ apiKey: import_zod63.z.string() });

// src/generated-definitions/CreateTemplateRequest.ts
var import_zod64 = require("zod");
var CreateTemplateRequest = import_zod64.z.object({ templateContent: import_zod64.z.string(), templateLanguage: import_zod64.z.string(), templateSlug: import_zod64.z.string() });

// src/generated-definitions/CreateTopicRequest.ts
var import_zod65 = require("zod");
var CreateTopicRequest = import_zod65.z.object({ description: import_zod65.z.string(), topic: import_zod65.z.string() });

// src/generated-definitions/CreateTopicRequestV1.ts
var import_zod66 = require("zod");
var CreateTopicRequestV1 = import_zod66.z.object({ description: import_zod66.z.string(), topicName: import_zod66.z.string() });

// src/generated-definitions/DebugProfanityFilterRequest.ts
var import_zod67 = require("zod");
var DebugProfanityFilterRequest = import_zod67.z.object({ text: import_zod67.z.string() });

// src/generated-definitions/Error.ts
var import_zod68 = require("zod");
var Error2 = import_zod68.z.object({ errorCode: import_zod68.z.number().int(), errorMessage: import_zod68.z.string() });

// src/generated-definitions/ErrorResponseBody.ts
var import_zod69 = require("zod");
var ErrorResponseBody = import_zod69.z.object({ ErrorCode: import_zod69.z.number().int(), ErrorMessage: import_zod69.z.string() });

// src/generated-definitions/ErrorResponseV1.ts
var import_zod70 = require("zod");
var ErrorResponseV1 = import_zod70.z.object({ errorCode: import_zod70.z.number().int(), errorMessage: import_zod70.z.string() });

// src/generated-definitions/FreeFormNotificationRequest.ts
var import_zod71 = require("zod");
var FreeFormNotificationRequest = import_zod71.z.object({ message: import_zod71.z.string(), topic: import_zod71.z.string() });

// src/generated-definitions/FreeFormNotificationRequestV1.ts
var import_zod72 = require("zod");
var FreeFormNotificationRequestV1 = import_zod72.z.object({ message: import_zod72.z.string(), topicName: import_zod72.z.string() });

// src/generated-definitions/GetBulkAllPlayerBlockedUsersRequest.ts
var import_zod73 = require("zod");
var GetBulkAllPlayerBlockedUsersRequest = import_zod73.z.object({ listBlockedUserId: import_zod73.z.array(import_zod73.z.string()) });

// src/generated-definitions/GetUserFriendsResponse.ts
var import_zod74 = require("zod");
var GetUserFriendsResponse = import_zod74.z.object({
  friendIDs: import_zod74.z.array(import_zod74.z.string()),
  friends: import_zod74.z.array(FriendWithPlatform).nullish(),
  paging: Pagination
});

// src/generated-definitions/GetUserFriendsResponseArray.ts
var import_zod75 = require("zod");
var GetUserFriendsResponseArray = import_zod75.z.array(GetUserFriendsResponse);

// src/generated-definitions/GetUserIncomingFriendsResponse.ts
var import_zod76 = require("zod");
var GetUserIncomingFriendsResponse = import_zod76.z.object({ friendIDs: import_zod76.z.array(import_zod76.z.string()), paging: Pagination });

// src/generated-definitions/GetUserIncomingFriendsResponseArray.ts
var import_zod77 = require("zod");
var GetUserIncomingFriendsResponseArray = import_zod77.z.array(GetUserIncomingFriendsResponse);

// src/generated-definitions/GetUserOutgoingFriendsResponse.ts
var import_zod78 = require("zod");
var GetUserOutgoingFriendsResponse = import_zod78.z.object({ friendIDs: import_zod78.z.array(import_zod78.z.string()), paging: Pagination });

// src/generated-definitions/GetUserOutgoingFriendsResponseArray.ts
var import_zod79 = require("zod");
var GetUserOutgoingFriendsResponseArray = import_zod79.z.array(GetUserOutgoingFriendsResponse);

// src/generated-definitions/GetUsersPresenceResponse.ts
var import_zod81 = require("zod");

// src/generated-definitions/UserPresence.ts
var import_zod80 = require("zod");
var UserPresence = import_zod80.z.object({
  activity: import_zod80.z.string(),
  availability: import_zod80.z.string(),
  lastSeenAt: import_zod80.z.string(),
  namespace: import_zod80.z.string(),
  platform: import_zod80.z.string(),
  userID: import_zod80.z.string()
});

// src/generated-definitions/GetUsersPresenceResponse.ts
var GetUsersPresenceResponse = import_zod81.z.object({
  away: import_zod81.z.number().int(),
  busy: import_zod81.z.number().int(),
  data: import_zod81.z.array(UserPresence),
  invisible: import_zod81.z.number().int(),
  offline: import_zod81.z.number().int(),
  online: import_zod81.z.number().int()
});

// src/generated-definitions/ListBlockedPlayerRequest.ts
var import_zod82 = require("zod");
var ListBlockedPlayerRequest = import_zod82.z.object({ listBlockedUserId: import_zod82.z.array(import_zod82.z.string()) });

// src/generated-definitions/ListBulkUserPlatformsResponse.ts
var import_zod85 = require("zod");

// src/generated-definitions/UserWithPlatformInfo.ts
var import_zod84 = require("zod");

// src/generated-definitions/UserPlatformInfo.ts
var import_zod83 = require("zod");
var UserPlatformInfo = import_zod83.z.object({ platformDisplayName: import_zod83.z.string(), platformName: import_zod83.z.string(), platformUserId: import_zod83.z.string() });

// src/generated-definitions/UserWithPlatformInfo.ts
var UserWithPlatformInfo = import_zod84.z.object({
  avatarUrl: import_zod84.z.string(),
  displayName: import_zod84.z.string(),
  platformInfos: import_zod84.z.array(UserPlatformInfo),
  userId: import_zod84.z.string(),
  username: import_zod84.z.string().nullish()
});

// src/generated-definitions/ListBulkUserPlatformsResponse.ts
var ListBulkUserPlatformsResponse = import_zod85.z.object({ data: import_zod85.z.array(UserWithPlatformInfo) });

// src/generated-definitions/ListUnblockPlayerRequest.ts
var import_zod86 = require("zod");
var ListUnblockPlayerRequest = import_zod86.z.object({ listUnblockUserId: import_zod86.z.array(import_zod86.z.string()) });

// src/generated-definitions/LoadIncomingFriendsWithTimeResponseArray.ts
var import_zod87 = require("zod");
var LoadIncomingFriendsWithTimeResponseArray = import_zod87.z.array(LoadIncomingFriendsWithTimeResponse);

// src/generated-definitions/LoadOutgoingFriendsWithTimeResponseArray.ts
var import_zod88 = require("zod");
var LoadOutgoingFriendsWithTimeResponseArray = import_zod88.z.array(LoadOutgoingFriendsWithTimeResponse);

// src/generated-definitions/NativeFriendRequest.ts
var import_zod89 = require("zod");
var NativeFriendRequest = import_zod89.z.object({
  isLogin: import_zod89.z.boolean(),
  platformId: import_zod89.z.string(),
  platformToken: import_zod89.z.string().nullish(),
  psnEnv: import_zod89.z.string().nullish()
});

// src/generated-definitions/NativeFriendSyncResponse.ts
var import_zod90 = require("zod");
var NativeFriendSyncResponse = import_zod90.z.object({ detail: import_zod90.z.string().nullish(), platformId: import_zod90.z.string(), status: import_zod90.z.string() });

// src/generated-definitions/NativeFriendSyncResponseArray.ts
var import_zod91 = require("zod");
var NativeFriendSyncResponseArray = import_zod91.z.array(NativeFriendSyncResponse);

// src/generated-definitions/NativeUserBlockRequest.ts
var import_zod92 = require("zod");
var NativeUserBlockRequest = import_zod92.z.object({ platformId: import_zod92.z.string(), psnEnv: import_zod92.z.string().nullish() });

// src/generated-definitions/NativeUserBlockResponse.ts
var import_zod93 = require("zod");
var NativeUserBlockResponse = import_zod93.z.object({ detail: import_zod93.z.string().nullish(), platformId: import_zod93.z.string(), status: import_zod93.z.string() });

// src/generated-definitions/NativeUserBlockResponseArray.ts
var import_zod94 = require("zod");
var NativeUserBlockResponseArray = import_zod94.z.array(NativeUserBlockResponse);

// src/generated-definitions/NotificationResponse.ts
var import_zod95 = require("zod");
var NotificationResponse = import_zod95.z.object({
  from: import_zod95.z.string().nullish(),
  id: import_zod95.z.string().nullish(),
  lobbySessionID: import_zod95.z.string().nullish(),
  loginType: import_zod95.z.string().nullish(),
  payload: import_zod95.z.string().nullish(),
  reconnectFromCode: import_zod95.z.number().int().nullish(),
  sentAt: import_zod95.z.string().nullish(),
  sequenceID: import_zod95.z.number().int(),
  sequenceNumber: import_zod95.z.number().int(),
  to: import_zod95.z.string().nullish(),
  topic: import_zod95.z.string().nullish(),
  type: import_zod95.z.string()
});

// src/generated-definitions/NotificationTopicResponse.ts
var import_zod96 = require("zod");
var NotificationTopicResponse = import_zod96.z.object({
  createdAt: import_zod96.z.number().int(),
  description: import_zod96.z.string(),
  namespace: import_zod96.z.string(),
  topic: import_zod96.z.string()
});

// src/generated-definitions/NotificationWithTemplateRequest.ts
var import_zod97 = require("zod");
var NotificationWithTemplateRequest = import_zod97.z.object({
  templateContext: import_zod97.z.record(import_zod97.z.string()),
  templateLanguage: import_zod97.z.string(),
  templateSlug: import_zod97.z.string(),
  topic: import_zod97.z.string()
});

// src/generated-definitions/NotificationWithTemplateRequestV1.ts
var import_zod98 = require("zod");
var NotificationWithTemplateRequestV1 = import_zod98.z.object({
  templateContext: import_zod98.z.record(import_zod98.z.string()),
  templateLanguage: import_zod98.z.string(),
  templateSlug: import_zod98.z.string(),
  topicName: import_zod98.z.string()
});

// src/generated-definitions/PartyPutCustomAttributesRequest.ts
var import_zod99 = require("zod");
var PartyPutCustomAttributesRequest = import_zod99.z.object({ custom_attribute: import_zod99.z.record(import_zod99.z.any()), updatedAt: import_zod99.z.number().int() });

// src/generated-definitions/PartyPutLimitSizeRequest.ts
var import_zod100 = require("zod");
var PartyPutLimitSizeRequest = import_zod100.z.object({ limit: import_zod100.z.number().int() });

// src/generated-definitions/PutGlobalConfigurationRequest.ts
var import_zod101 = require("zod");
var PutGlobalConfigurationRequest = import_zod101.z.object({
  regionRetryMapping: import_zod101.z.record(import_zod101.z.array(import_zod101.z.string())),
  regionURLMapping: import_zod101.z.array(import_zod101.z.string()),
  testGameMode: import_zod101.z.string(),
  testRegionURLMapping: import_zod101.z.array(import_zod101.z.string()),
  testTargetUserIDs: import_zod101.z.array(import_zod101.z.string())
});

// src/generated-definitions/RequestUserPresence.ts
var import_zod102 = require("zod");
var RequestUserPresence = import_zod102.z.object({ userIDs: import_zod102.z.array(import_zod102.z.string()).nullish() });

// src/generated-definitions/SetPlayerSessionAttributeRequest.ts
var import_zod103 = require("zod");
var SetPlayerSessionAttributeRequest = import_zod103.z.object({ attributes: import_zod103.z.record(import_zod103.z.string()) });

// src/generated-definitions/TemplateLocalization.ts
var import_zod104 = require("zod");
var TemplateLocalization = import_zod104.z.object({
  lastDraftAt: import_zod104.z.string(),
  lastPublishedAt: import_zod104.z.string(),
  templateContent: TemplateContent,
  templateLanguage: import_zod104.z.string(),
  templateSlug: import_zod104.z.string()
});

// src/generated-definitions/TemplateLocalizationResponse.ts
var import_zod105 = require("zod");
var TemplateLocalizationResponse = import_zod105.z.object({
  first: import_zod105.z.string(),
  last: import_zod105.z.string(),
  next: import_zod105.z.string(),
  previous: import_zod105.z.string(),
  templateLocalization: import_zod105.z.array(TemplateLocalization)
});

// src/generated-definitions/TemplateResponse.ts
var import_zod106 = require("zod");
var TemplateResponse = import_zod106.z.object({ localizations: import_zod106.z.array(Localization), templateSlug: import_zod106.z.string() });

// src/generated-definitions/TemplateResponseArray.ts
var import_zod107 = require("zod");
var TemplateResponseArray = import_zod107.z.array(TemplateResponse);

// src/generated-definitions/TopicByNamespacesResponse.ts
var import_zod108 = require("zod");
var TopicByNamespacesResponse = import_zod108.z.object({
  first: import_zod108.z.string(),
  last: import_zod108.z.string(),
  next: import_zod108.z.string(),
  previous: import_zod108.z.string(),
  topics: import_zod108.z.array(NotificationTopicResponse)
});

// src/generated-definitions/UnblockPlayerRequest.ts
var import_zod109 = require("zod");
var UnblockPlayerRequest = import_zod109.z.object({ userId: import_zod109.z.string() });

// src/generated-definitions/UpdateConfigRequest.ts
var import_zod110 = require("zod");
var UpdateConfigRequest = import_zod110.z.object({ apiKey: import_zod110.z.string() });

// src/generated-definitions/UpdateTemplateRequest.ts
var import_zod111 = require("zod");
var UpdateTemplateRequest = import_zod111.z.object({ templateContent: import_zod111.z.string() });

// src/generated-definitions/UpdateTopicRequest.ts
var import_zod112 = require("zod");
var UpdateTopicRequest = import_zod112.z.object({ description: import_zod112.z.string() });

// src/generated-definitions/UserAcceptFriendRequest.ts
var import_zod113 = require("zod");
var UserAcceptFriendRequest = import_zod113.z.object({ friendId: import_zod113.z.string() });

// src/generated-definitions/UserCancelFriendRequest.ts
var import_zod114 = require("zod");
var UserCancelFriendRequest = import_zod114.z.object({ friendId: import_zod114.z.string() });

// src/generated-definitions/UserGetFriendshipStatusResponse.ts
var import_zod115 = require("zod");
var UserGetFriendshipStatusResponse = import_zod115.z.object({ code: import_zod115.z.number().int(), name: import_zod115.z.string() });

// src/generated-definitions/UserRejectFriendRequest.ts
var import_zod116 = require("zod");
var UserRejectFriendRequest = import_zod116.z.object({ friendId: import_zod116.z.string() });

// src/generated-definitions/UserRequestFriendRequest.ts
var import_zod117 = require("zod");
var UserRequestFriendRequest = import_zod117.z.object({ friendId: import_zod117.z.string().nullish(), friendPublicId: import_zod117.z.string().nullish() });

// src/generated-definitions/UserUnfriendRequest.ts
var import_zod118 = require("zod");
var UserUnfriendRequest = import_zod118.z.object({ friendId: import_zod118.z.string() });

// src/generated-public/AdminApi.ts
var import_sdk20 = require("@accelbyte/sdk");

// src/generated-public/endpoints/Admin$.ts
var import_sdk19 = require("@accelbyte/sdk");
var import_zod119 = require("zod");
var Admin$ = class {
  // @ts-ignore
  // prettier-ignore
  constructor(axiosInstance, namespace, useSchemaValidation = true) {
    this.axiosInstance = axiosInstance;
    this.namespace = namespace;
    this.useSchemaValidation = useSchemaValidation;
  }
  /**
   * Sends notification to all connected users in a namespace.
   */
  createNotificationFreeform(data) {
    const params = {};
    const url = "/notification/namespaces/{namespace}/freeform".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.post(url, data, { params });
    return import_sdk19.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, import_zod119.z.unknown(), "z.unknown()");
  }
  /**
   * Sends notification to all connected users in a namespace with predefined template. &lt;br&gt;In the request body, specify which template slug (template identifier) to use and the template language. &lt;br&gt;NotificationTemplate context is the key-value pair defining the value of each handlebar specified in the template content. Template need to be published before it can be use to send notifications
   */
  createNotificationTemplated(data) {
    const params = {};
    const url = "/notification/namespaces/{namespace}/templated".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.post(url, data, { params });
    return import_sdk19.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, import_zod119.z.unknown(), "z.unknown()");
  }
  /**
   * Get all templates in a namespace
   */
  getNotificationTemplates() {
    const params = {};
    const url = "/notification/namespaces/{namespace}/templates".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.get(url, { params });
    return import_sdk19.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, TemplateResponseArray, "TemplateResponseArray");
  }
  /**
   * Create new notification template. Include handlebars {{key}} for replaceable contexts. The the key inside handlebars will be the key to be replaced when sending notification. Already existing template with the same slug and language can not be created. &lt;br&gt;Check model description for detailed input restrictions.
   */
  createNotificationTemplate(data) {
    const params = {};
    const url = "/notification/namespaces/{namespace}/templates".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.post(url, data, { params });
    return import_sdk19.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, import_zod119.z.unknown(), "z.unknown()");
  }
  /**
   * Delete localization template
   */
  deleteNotificationTemplate_ByTemplateSlug(templateSlug) {
    const params = {};
    const url = "/notification/namespaces/{namespace}/templates/{templateSlug}".replace("{namespace}", this.namespace).replace("{templateSlug}", templateSlug);
    const resultPromise = this.axiosInstance.delete(url, { params });
    return import_sdk19.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, import_zod119.z.unknown(), "z.unknown()");
  }
  /**
   * Get all templates in a namespace
   */
  getNotificationTemplate_ByTemplateSlug(templateSlug, queryParams) {
    const params = { ...queryParams };
    const url = "/notification/namespaces/{namespace}/templates/{templateSlug}".replace("{namespace}", this.namespace).replace("{templateSlug}", templateSlug);
    const resultPromise = this.axiosInstance.get(url, { params });
    return import_sdk19.Validate.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      TemplateLocalizationResponse,
      "TemplateLocalizationResponse"
    );
  }
  /**
   * Delete all template in a slug
   */
  deleteLanguageNotification_ByTemplateSlug_ByTemplateLanguage(templateSlug, templateLanguage) {
    const params = {};
    const url = "/notification/namespaces/{namespace}/templates/{templateSlug}/languages/{templateLanguage}".replace("{namespace}", this.namespace).replace("{templateSlug}", templateSlug).replace("{templateLanguage}", templateLanguage);
    const resultPromise = this.axiosInstance.delete(url, { params });
    return import_sdk19.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, import_zod119.z.unknown(), "z.unknown()");
  }
  /**
   * Get a template localization
   */
  getLanguageNotification_ByTemplateSlug_ByTemplateLanguage(templateSlug, templateLanguage) {
    const params = {};
    const url = "/notification/namespaces/{namespace}/templates/{templateSlug}/languages/{templateLanguage}".replace("{namespace}", this.namespace).replace("{templateSlug}", templateSlug).replace("{templateLanguage}", templateLanguage);
    const resultPromise = this.axiosInstance.get(url, { params });
    return import_sdk19.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, TemplateLocalization, "TemplateLocalization");
  }
  /**
   * Modify draft template
   */
  updateLanguageNotification_ByTemplateSlug_ByTemplateLanguage(templateSlug, templateLanguage, data) {
    const params = {};
    const url = "/notification/namespaces/{namespace}/templates/{templateSlug}/languages/{templateLanguage}".replace("{namespace}", this.namespace).replace("{templateSlug}", templateSlug).replace("{templateLanguage}", templateLanguage);
    const resultPromise = this.axiosInstance.put(url, data, { params });
    return import_sdk19.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, import_zod119.z.unknown(), "z.unknown()");
  }
  /**
   * Publish notification template draft. Empty draft can not be published.
   */
  createPublishNotification_ByTemplateSlug_ByTemplateLanguage(templateSlug, templateLanguage) {
    const params = {};
    const url = "/notification/namespaces/{namespace}/templates/{templateSlug}/languages/{templateLanguage}/publish".replace("{namespace}", this.namespace).replace("{templateSlug}", templateSlug).replace("{templateLanguage}", templateLanguage);
    const resultPromise = this.axiosInstance.post(url, null, { params });
    return import_sdk19.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, import_zod119.z.unknown(), "z.unknown()");
  }
};

// src/generated-public/AdminApi.ts
function AdminApi(sdk, args) {
  const sdkAssembly = sdk.assembly();
  const namespace = args?.coreConfig?.namespace ?? sdkAssembly.coreConfig.namespace;
  const useSchemaValidation = args?.coreConfig?.useSchemaValidation ?? sdkAssembly.coreConfig.useSchemaValidation;
  let axiosInstance = sdkAssembly.axiosInstance;
  const requestConfigOverrides = args?.axiosConfig?.request;
  const baseURLOverride = args?.coreConfig?.baseURL;
  const interceptorsOverride = args?.axiosConfig?.interceptors ?? [];
  if (requestConfigOverrides || baseURLOverride || interceptorsOverride.length > 0) {
    const requestConfig = import_sdk20.ApiUtils.mergeAxiosConfigs(sdkAssembly.axiosInstance.defaults, {
      ...baseURLOverride ? { baseURL: baseURLOverride } : {},
      ...requestConfigOverrides
    });
    axiosInstance = import_sdk20.Network.create(requestConfig);
    for (const interceptor of interceptorsOverride) {
      if (interceptor.type === "request") {
        axiosInstance.interceptors.request.use(interceptor.onRequest, interceptor.onError);
      }
      if (interceptor.type === "response") {
        axiosInstance.interceptors.response.use(interceptor.onSuccess, interceptor.onError);
      }
    }
  }
  async function createNotificationFreeform(data) {
    const $ = new Admin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.createNotificationFreeform(data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function createNotificationTemplated(data) {
    const $ = new Admin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.createNotificationTemplated(data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getNotificationTemplates() {
    const $ = new Admin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getNotificationTemplates();
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function createNotificationTemplate(data) {
    const $ = new Admin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.createNotificationTemplate(data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function deleteNotificationTemplate_ByTemplateSlug(templateSlug) {
    const $ = new Admin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.deleteNotificationTemplate_ByTemplateSlug(templateSlug);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getNotificationTemplate_ByTemplateSlug(templateSlug, queryParams) {
    const $ = new Admin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getNotificationTemplate_ByTemplateSlug(templateSlug, queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function deleteLanguageNotification_ByTemplateSlug_ByTemplateLanguage(templateSlug, templateLanguage) {
    const $ = new Admin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.deleteLanguageNotification_ByTemplateSlug_ByTemplateLanguage(templateSlug, templateLanguage);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getLanguageNotification_ByTemplateSlug_ByTemplateLanguage(templateSlug, templateLanguage) {
    const $ = new Admin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getLanguageNotification_ByTemplateSlug_ByTemplateLanguage(templateSlug, templateLanguage);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function updateLanguageNotification_ByTemplateSlug_ByTemplateLanguage(templateSlug, templateLanguage, data) {
    const $ = new Admin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.updateLanguageNotification_ByTemplateSlug_ByTemplateLanguage(templateSlug, templateLanguage, data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function createPublishNotification_ByTemplateSlug_ByTemplateLanguage(templateSlug, templateLanguage) {
    const $ = new Admin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.createPublishNotification_ByTemplateSlug_ByTemplateLanguage(templateSlug, templateLanguage);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  return {
    /**
     * Sends notification to all connected users in a namespace.
     */
    createNotificationFreeform,
    /**
     * Sends notification to all connected users in a namespace with predefined template. &lt;br&gt;In the request body, specify which template slug (template identifier) to use and the template language. &lt;br&gt;NotificationTemplate context is the key-value pair defining the value of each handlebar specified in the template content. Template need to be published before it can be use to send notifications
     */
    createNotificationTemplated,
    /**
     * Get all templates in a namespace
     */
    getNotificationTemplates,
    /**
     * Create new notification template. Include handlebars {{key}} for replaceable contexts. The the key inside handlebars will be the key to be replaced when sending notification. Already existing template with the same slug and language can not be created. &lt;br&gt;Check model description for detailed input restrictions.
     */
    createNotificationTemplate,
    /**
     * Delete localization template
     */
    deleteNotificationTemplate_ByTemplateSlug,
    /**
     * Get all templates in a namespace
     */
    getNotificationTemplate_ByTemplateSlug,
    /**
     * Delete all template in a slug
     */
    deleteLanguageNotification_ByTemplateSlug_ByTemplateLanguage,
    /**
     * Get a template localization
     */
    getLanguageNotification_ByTemplateSlug_ByTemplateLanguage,
    /**
     * Modify draft template
     */
    updateLanguageNotification_ByTemplateSlug_ByTemplateLanguage,
    /**
     * Publish notification template draft. Empty draft can not be published.
     */
    createPublishNotification_ByTemplateSlug_ByTemplateLanguage
  };
}

// src/generated-public/BlocksApi.ts
var import_sdk22 = require("@accelbyte/sdk");

// src/generated-public/endpoints/Blocks$.ts
var import_sdk21 = require("@accelbyte/sdk");
var Blocks$ = class {
  // @ts-ignore
  // prettier-ignore
  constructor(axiosInstance, namespace, useSchemaValidation = true) {
    this.axiosInstance = axiosInstance;
    this.namespace = namespace;
    this.useSchemaValidation = useSchemaValidation;
  }
  /**
   * Sync blocked user using server to server call to native first party server. Supported platforms: ps5, ps4 and pspc : the default environment would be sp-int, can be override using psnEnv. psnEnv consist of sp-int (default), prod-qa, np
   */
  patchSyncMeBlock(data) {
    const params = {};
    const url = "/lobby/sync/namespaces/{namespace}/me/block".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.patch(url, data, { params });
    return import_sdk21.Validate.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      NativeUserBlockResponseArray,
      "NativeUserBlockResponseArray"
    );
  }
};

// src/generated-public/BlocksApi.ts
function BlocksApi(sdk, args) {
  const sdkAssembly = sdk.assembly();
  const namespace = args?.coreConfig?.namespace ?? sdkAssembly.coreConfig.namespace;
  const useSchemaValidation = args?.coreConfig?.useSchemaValidation ?? sdkAssembly.coreConfig.useSchemaValidation;
  let axiosInstance = sdkAssembly.axiosInstance;
  const requestConfigOverrides = args?.axiosConfig?.request;
  const baseURLOverride = args?.coreConfig?.baseURL;
  const interceptorsOverride = args?.axiosConfig?.interceptors ?? [];
  if (requestConfigOverrides || baseURLOverride || interceptorsOverride.length > 0) {
    const requestConfig = import_sdk22.ApiUtils.mergeAxiosConfigs(sdkAssembly.axiosInstance.defaults, {
      ...baseURLOverride ? { baseURL: baseURLOverride } : {},
      ...requestConfigOverrides
    });
    axiosInstance = import_sdk22.Network.create(requestConfig);
    for (const interceptor of interceptorsOverride) {
      if (interceptor.type === "request") {
        axiosInstance.interceptors.request.use(interceptor.onRequest, interceptor.onError);
      }
      if (interceptor.type === "response") {
        axiosInstance.interceptors.response.use(interceptor.onSuccess, interceptor.onError);
      }
    }
  }
  async function patchSyncMeBlock(data) {
    const $ = new Blocks$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.patchSyncMeBlock(data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  return {
    /**
     * Sync blocked user using server to server call to native first party server. Supported platforms: ps5, ps4 and pspc : the default environment would be sp-int, can be override using psnEnv. psnEnv consist of sp-int (default), prod-qa, np
     */
    patchSyncMeBlock
  };
}

// src/generated-public/endpoints/Friends$.ts
var import_sdk23 = require("@accelbyte/sdk");
var import_zod120 = require("zod");
var Friends$ = class {
  // @ts-ignore
  // prettier-ignore
  constructor(axiosInstance, namespace, useSchemaValidation = true) {
    this.axiosInstance = axiosInstance;
    this.namespace = namespace;
    this.useSchemaValidation = useSchemaValidation;
  }
  /**
   * Get list of friends in a namespace.
   */
  getFriendsMe(queryParams) {
    const params = { limit: 25, ...queryParams };
    const url = "/friends/namespaces/{namespace}/me".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.get(url, { params });
    return import_sdk23.Validate.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      GetUserFriendsResponseArray,
      "GetUserFriendsResponseArray"
    );
  }
  /**
   * Sync friends using server to server call to native first party server. Supported platforms: steam: The platform_tokens value is the binary ticket returned by Steam. If this ticket was generated by Steam GetAuthTicketForWebApi with version &gt;= 1.57, then platform token should use this style: {identity}:{ticket} the {identity} was the parameter to call GetAuthTicketForWebApi when the ticket was created. Note: Do not contain : in this {identity} ps4: The platform_tokens value is the authorization code returned by Sony OAuth. ps5: The platform_tokens value is the authorization code returned by Sony OAuth. pspc: The platform_tokens value is the authorization code returned by Sony OAuth.
   */
  patchFriendSyncMe(data) {
    const params = {};
    const url = "/friends/sync/namespaces/{namespace}/me".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.patch(url, data, { params });
    return import_sdk23.Validate.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      NativeFriendSyncResponseArray,
      "NativeFriendSyncResponseArray"
    );
  }
  /**
   * Client should provide either friendID or friendPublicID. If both are provided, friendID will be chosen to be used. This endpoint will only send a pending invite that can be either rejected/accepted
   */
  createFriendMeRequest(data) {
    const params = {};
    const url = "/friends/namespaces/{namespace}/me/request".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.post(url, data, { params });
    return import_sdk23.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, import_zod120.z.unknown(), "z.unknown()");
  }
  /**
   * Get list of incoming friends in a namespace.
   */
  getFriendsMeIncoming(queryParams) {
    const params = { limit: 25, ...queryParams };
    const url = "/friends/namespaces/{namespace}/me/incoming".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.get(url, { params });
    return import_sdk23.Validate.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      GetUserIncomingFriendsResponseArray,
      "GetUserIncomingFriendsResponseArray"
    );
  }
  /**
   * Get list of outgoing friends in a namespace.
   */
  getFriendsMeOutgoing(queryParams) {
    const params = { limit: 25, ...queryParams };
    const url = "/friends/namespaces/{namespace}/me/outgoing".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.get(url, { params });
    return import_sdk23.Validate.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      GetUserOutgoingFriendsResponseArray,
      "GetUserOutgoingFriendsResponseArray"
    );
  }
  /**
   * User unfriend a friend.
   */
  createFriendMeUnfriend(data) {
    const params = {};
    const url = "/friends/namespaces/{namespace}/me/unfriend".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.post(url, data, { params });
    return import_sdk23.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, import_zod120.z.unknown(), "z.unknown()");
  }
  /**
   * Get list of friends with platform data in a namespace.
   */
  getFriendsMePlatforms(queryParams) {
    const params = { limit: 25, ...queryParams };
    const url = "/friends/namespaces/{namespace}/me/platforms".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.get(url, { params });
    return import_sdk23.Validate.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      ListBulkUserPlatformsResponse,
      "ListBulkUserPlatformsResponse"
    );
  }
  /**
   * Get list of incoming friends with requested time info in a namespace.
   */
  getFriendsMeIncomingTime(queryParams) {
    const params = { limit: 25, ...queryParams };
    const url = "/friends/namespaces/{namespace}/me/incoming-time".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.get(url, { params });
    return import_sdk23.Validate.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      LoadIncomingFriendsWithTimeResponseArray,
      "LoadIncomingFriendsWithTimeResponseArray"
    );
  }
  /**
   * Get list of outgoing friends with requested time info in a namespace.
   */
  getFriendsMeOutgoingTime(queryParams) {
    const params = { limit: 25, ...queryParams };
    const url = "/friends/namespaces/{namespace}/me/outgoing-time".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.get(url, { params });
    return import_sdk23.Validate.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      LoadOutgoingFriendsWithTimeResponseArray,
      "LoadOutgoingFriendsWithTimeResponseArray"
    );
  }
  /**
   * User accept friend.
   */
  createFriendMeRequestAccept(data) {
    const params = {};
    const url = "/friends/namespaces/{namespace}/me/request/accept".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.post(url, data, { params });
    return import_sdk23.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, import_zod120.z.unknown(), "z.unknown()");
  }
  /**
   * User cancel a friend request.
   */
  createFriendMeRequestCancel(data) {
    const params = {};
    const url = "/friends/namespaces/{namespace}/me/request/cancel".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.post(url, data, { params });
    return import_sdk23.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, import_zod120.z.unknown(), "z.unknown()");
  }
  /**
   * User reject a friend request.
   */
  createFriendMeRequestReject(data) {
    const params = {};
    const url = "/friends/namespaces/{namespace}/me/request/reject".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.post(url, data, { params });
    return import_sdk23.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, import_zod120.z.unknown(), "z.unknown()");
  }
  /**
   * User get friendship status. Code: 0 - Message: &#34;not friend&#34; Code: 1 - Message: &#34;outgoing&#34; Code: 2 - Message: &#34;incoming&#34; Code: 3 - Message: &#34;friend&#34;
   */
  getFriendMeStatu_ByFriendId(friendId) {
    const params = {};
    const url = "/friends/namespaces/{namespace}/me/status/{friendId}".replace("{namespace}", this.namespace).replace("{friendId}", friendId);
    const resultPromise = this.axiosInstance.get(url, { params });
    return import_sdk23.Validate.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      UserGetFriendshipStatusResponse,
      "UserGetFriendshipStatusResponse"
    );
  }
  /**
   * Friends request in a namespace.
   */
  createAddBulkFriend_ByUserId(userId, data) {
    const params = {};
    const url = "/friends/namespaces/{namespace}/users/{userId}/add/bulk".replace("{namespace}", this.namespace).replace("{userId}", userId);
    const resultPromise = this.axiosInstance.post(url, data, { params });
    return import_sdk23.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, import_zod120.z.unknown(), "z.unknown()");
  }
  /**
   * Friends request in a namespace.
   */
  createDeleteBulkFriend_ByUserId(userId, data) {
    const params = {};
    const url = "/friends/namespaces/{namespace}/users/{userId}/delete/bulk".replace("{namespace}", this.namespace).replace("{userId}", userId);
    const resultPromise = this.axiosInstance.post(url, data, { params });
    return import_sdk23.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, BulkFriendsResponse, "BulkFriendsResponse");
  }
};

// src/generated-public/endpoints/LobbyOperations$.ts
var import_sdk24 = require("@accelbyte/sdk");
var LobbyOperations$ = class {
  // @ts-ignore
  // prettier-ignore
  constructor(axiosInstance, namespace, useSchemaValidation = true) {
    this.axiosInstance = axiosInstance;
    this.namespace = namespace;
    this.useSchemaValidation = useSchemaValidation;
  }
  /**
   * get the list of messages.
   */
  getMessages() {
    const params = {};
    const url = "/lobby/v1/messages";
    const resultPromise = this.axiosInstance.get(url, { params });
    return import_sdk24.Validate.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      AppMessageDeclarationArray,
      "AppMessageDeclarationArray"
    );
  }
};

// src/generated-public/endpoints/Notification$.ts
var import_sdk25 = require("@accelbyte/sdk");
var import_zod121 = require("zod");
var Notification$ = class {
  // @ts-ignore
  // prettier-ignore
  constructor(axiosInstance, namespace, useSchemaValidation = true) {
    this.axiosInstance = axiosInstance;
    this.namespace = namespace;
    this.useSchemaValidation = useSchemaValidation;
  }
  /**
   * Get list of notifications in a namespace. The query parameters **startTime** and **endTime** can be filled with the **sequenceID** value in the notification, where the value is an epoch timestamp. Example **sequenceID** or epoch timestamp value: **1706595813**
   */
  getNotificationMe(queryParams) {
    const params = { limit: 25, ...queryParams };
    const url = "/notification/namespaces/{namespace}/me".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.get(url, { params });
    return import_sdk25.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, NotificationResponse, "NotificationResponse");
  }
  /**
   * get topic by namespace.
   */
  getNotificationTopics(queryParams) {
    const params = { ...queryParams };
    const url = "/notification/namespaces/{namespace}/topics".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.get(url, { params });
    return import_sdk25.Validate.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      TopicByNamespacesResponse,
      "TopicByNamespacesResponse"
    );
  }
  /**
   * Create new notification topic. &lt;br&gt;topic should be alphabets, no special char except underscore, uppercase and no spacing. for example: TOPIC_TEST. Already existing topic can not be created
   */
  createNotificationTopic(data) {
    const params = {};
    const url = "/notification/namespaces/{namespace}/topics".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.post(url, data, { params });
    return import_sdk25.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, import_zod121.z.unknown(), "z.unknown()");
  }
  /**
   * delete topic information by topic name. &lt;br&gt;topic should be alphabets, no special char except underscore, uppercase and no spacing. for example: TOPIC_TEST. Already existing topic can not be created
   */
  deleteNotificationTopic_ByTopic(topic) {
    const params = {};
    const url = "/notification/namespaces/{namespace}/topics/{topic}".replace("{namespace}", this.namespace).replace("{topic}", topic);
    const resultPromise = this.axiosInstance.delete(url, { params });
    return import_sdk25.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, import_zod121.z.unknown(), "z.unknown()");
  }
  /**
   * get topic information by topic name.
   */
  getNotificationTopic_ByTopic(topic) {
    const params = {};
    const url = "/notification/namespaces/{namespace}/topics/{topic}".replace("{namespace}", this.namespace).replace("{topic}", topic);
    const resultPromise = this.axiosInstance.get(url, { params });
    return import_sdk25.Validate.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      NotificationTopicResponse,
      "NotificationTopicResponse"
    );
  }
  /**
   * update topic information by topic name. &lt;br&gt;topic should be alphabets, no special char except underscore, uppercase and no spacing. for example: TOPIC_TEST. Already existing topic can not be created
   */
  updateNotificationTopic_ByTopic(topic, data) {
    const params = {};
    const url = "/notification/namespaces/{namespace}/topics/{topic}".replace("{namespace}", this.namespace).replace("{topic}", topic);
    const resultPromise = this.axiosInstance.put(url, data, { params });
    return import_sdk25.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, import_zod121.z.unknown(), "z.unknown()");
  }
  /**
   * Sends notification to a user.
   */
  createFreeformNotification_ByUserId(userId, data) {
    const params = {};
    const url = "/notification/namespaces/{namespace}/users/{userId}/freeform".replace("{namespace}", this.namespace).replace("{userId}", userId);
    const resultPromise = this.axiosInstance.post(url, data, { params });
    return import_sdk25.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, import_zod121.z.unknown(), "z.unknown()");
  }
  /**
   * Sends notification to a user with predefined template. &lt;br&gt;In the request body, specify which template slug (template identifier) to use and the template language. &lt;br&gt;NotificationTemplate context is the key-value pair defining the value of each handlebar specified in the template content. Template need to be published before it can be use to send notifications
   */
  createTemplatedNotification_ByUserId(userId, data) {
    const params = {};
    const url = "/notification/namespaces/{namespace}/users/{userId}/templated".replace("{namespace}", this.namespace).replace("{userId}", userId);
    const resultPromise = this.axiosInstance.post(url, data, { params });
    return import_sdk25.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, import_zod121.z.unknown(), "z.unknown()");
  }
};

// src/generated-public/endpoints/Party$.ts
var import_sdk26 = require("@accelbyte/sdk");
var import_zod122 = require("zod");
var Party$ = class {
  // @ts-ignore
  // prettier-ignore
  constructor(axiosInstance, namespace, useSchemaValidation = true) {
    this.axiosInstance = axiosInstance;
    this.namespace = namespace;
    this.useSchemaValidation = useSchemaValidation;
  }
  /**
   * Required valid user authorization &lt;br/&gt; &lt;br&gt;load personal party data in a namespace based on Party ID &lt;br/&gt; Action Code: 50101
   */
  getPartyParty_ByPartyId(partyId) {
    const params = {};
    const url = "/lobby/v1/public/party/namespaces/{namespace}/parties/{partyId}".replace("{namespace}", this.namespace).replace("{partyId}", partyId);
    const resultPromise = this.axiosInstance.get(url, { params });
    return import_sdk26.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, PartyData, "PartyData");
  }
  /**
   * Required valid user authorization &lt;br/&gt; &lt;br&gt;Set party limit, only party leader can call this endpoint.
   */
  updateLimitParty_ByPartyId(partyId, data) {
    const params = {};
    const url = "/lobby/v1/public/party/namespaces/{namespace}/parties/{partyId}/limit".replace("{namespace}", this.namespace).replace("{partyId}", partyId);
    const resultPromise = this.axiosInstance.put(url, data, { params });
    return import_sdk26.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, import_zod122.z.unknown(), "z.unknown()");
  }
  /**
   * Required valid user authorization &lt;br/&gt; &lt;br&gt;update party attributes in a namespace.
   */
  updateAttributeParty_ByPartyId(partyId, data) {
    const params = {};
    const url = "/lobby/v1/public/party/namespaces/{namespace}/parties/{partyId}/attributes".replace("{namespace}", this.namespace).replace("{partyId}", partyId);
    const resultPromise = this.axiosInstance.put(url, data, { params });
    return import_sdk26.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, PartyData, "PartyData");
  }
};

// src/generated-public/endpoints/Player$.ts
var import_sdk27 = require("@accelbyte/sdk");
var import_zod123 = require("zod");
var Player$ = class {
  // @ts-ignore
  // prettier-ignore
  constructor(axiosInstance, namespace, useSchemaValidation = true) {
    this.axiosInstance = axiosInstance;
    this.namespace = namespace;
    this.useSchemaValidation = useSchemaValidation;
  }
  /**
   * Required valid user authorization &lt;br/&gt; &lt;br&gt;add blocked players in a namespace based on user id &lt;br/&gt;
   */
  createPlayerUserMeBlock(data) {
    const params = {};
    const url = "/lobby/v1/public/player/namespaces/{namespace}/users/me/block".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.post(url, data, { params });
    return import_sdk27.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, import_zod123.z.unknown(), "z.unknown()");
  }
  /**
   * Required valid user authorization &lt;br/&gt; &lt;br&gt;load blocked players in a namespace based on user id &lt;br/&gt; Action Code: 50101
   */
  getPlayerUsersMeBlocked() {
    const params = {};
    const url = "/lobby/v1/public/player/namespaces/{namespace}/users/me/blocked".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.get(url, { params });
    return import_sdk27.Validate.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      GetAllPlayerBlockedUsersResponse,
      "GetAllPlayerBlockedUsersResponse"
    );
  }
  /**
   * Required valid user authorization &lt;br/&gt; unblock player in a namespace based on user id &lt;br/&gt;
   */
  createPlayerUserMeUnblock(data) {
    const params = {};
    const url = "/lobby/v1/public/player/namespaces/{namespace}/users/me/unblock".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.post(url, data, { params });
    return import_sdk27.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, import_zod123.z.unknown(), "z.unknown()");
  }
  /**
   * Required valid user authorization &lt;br/&gt; &lt;br&gt;load get players who blocked this player in a namespace based on user id &lt;br/&gt; Action Code: 50101
   */
  getPlayerUsersMeBlockedBy() {
    const params = {};
    const url = "/lobby/v1/public/player/namespaces/{namespace}/users/me/blocked-by".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.get(url, { params });
    return import_sdk27.Validate.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      GetAllPlayerBlockedByUsersResponse,
      "GetAllPlayerBlockedByUsersResponse"
    );
  }
};

// src/generated-public/endpoints/Presence$.ts
var import_sdk28 = require("@accelbyte/sdk");
var Presence$ = class {
  // @ts-ignore
  // prettier-ignore
  constructor(axiosInstance, namespace, useSchemaValidation = true) {
    this.axiosInstance = axiosInstance;
    this.namespace = namespace;
    this.useSchemaValidation = useSchemaValidation;
  }
  /**
   * Query users presence with given namespace and userIds.
   */
  getPresenceUsersPresence(queryParams) {
    const params = { ...queryParams };
    const url = "/lobby/v1/public/presence/namespaces/{namespace}/users/presence".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.get(url, { params });
    return import_sdk28.Validate.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      GetUsersPresenceResponse,
      "GetUsersPresenceResponse"
    );
  }
  /**
   * Query users presence with given namespace and userIds.
   */
  createPresenceUserPresence(data, queryParams) {
    const params = { ...queryParams };
    const url = "/lobby/v1/public/presence/namespaces/{namespace}/users/presence".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.post(url, data, { params });
    return import_sdk28.Validate.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      GetUsersPresenceResponse,
      "GetUsersPresenceResponse"
    );
  }
};

// src/generated-public/FriendsApi.ts
var import_sdk29 = require("@accelbyte/sdk");
function FriendsApi(sdk, args) {
  const sdkAssembly = sdk.assembly();
  const namespace = args?.coreConfig?.namespace ?? sdkAssembly.coreConfig.namespace;
  const useSchemaValidation = args?.coreConfig?.useSchemaValidation ?? sdkAssembly.coreConfig.useSchemaValidation;
  let axiosInstance = sdkAssembly.axiosInstance;
  const requestConfigOverrides = args?.axiosConfig?.request;
  const baseURLOverride = args?.coreConfig?.baseURL;
  const interceptorsOverride = args?.axiosConfig?.interceptors ?? [];
  if (requestConfigOverrides || baseURLOverride || interceptorsOverride.length > 0) {
    const requestConfig = import_sdk29.ApiUtils.mergeAxiosConfigs(sdkAssembly.axiosInstance.defaults, {
      ...baseURLOverride ? { baseURL: baseURLOverride } : {},
      ...requestConfigOverrides
    });
    axiosInstance = import_sdk29.Network.create(requestConfig);
    for (const interceptor of interceptorsOverride) {
      if (interceptor.type === "request") {
        axiosInstance.interceptors.request.use(interceptor.onRequest, interceptor.onError);
      }
      if (interceptor.type === "response") {
        axiosInstance.interceptors.response.use(interceptor.onSuccess, interceptor.onError);
      }
    }
  }
  async function getFriendsMe(queryParams) {
    const $ = new Friends$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getFriendsMe(queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function patchFriendSyncMe(data) {
    const $ = new Friends$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.patchFriendSyncMe(data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function createFriendMeRequest(data) {
    const $ = new Friends$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.createFriendMeRequest(data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getFriendsMeIncoming(queryParams) {
    const $ = new Friends$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getFriendsMeIncoming(queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getFriendsMeOutgoing(queryParams) {
    const $ = new Friends$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getFriendsMeOutgoing(queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function createFriendMeUnfriend(data) {
    const $ = new Friends$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.createFriendMeUnfriend(data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getFriendsMePlatforms(queryParams) {
    const $ = new Friends$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getFriendsMePlatforms(queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getFriendsMeIncomingTime(queryParams) {
    const $ = new Friends$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getFriendsMeIncomingTime(queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getFriendsMeOutgoingTime(queryParams) {
    const $ = new Friends$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getFriendsMeOutgoingTime(queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function createFriendMeRequestAccept(data) {
    const $ = new Friends$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.createFriendMeRequestAccept(data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function createFriendMeRequestCancel(data) {
    const $ = new Friends$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.createFriendMeRequestCancel(data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function createFriendMeRequestReject(data) {
    const $ = new Friends$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.createFriendMeRequestReject(data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getFriendMeStatu_ByFriendId(friendId) {
    const $ = new Friends$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getFriendMeStatu_ByFriendId(friendId);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function createAddBulkFriend_ByUserId(userId, data) {
    const $ = new Friends$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.createAddBulkFriend_ByUserId(userId, data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function createDeleteBulkFriend_ByUserId(userId, data) {
    const $ = new Friends$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.createDeleteBulkFriend_ByUserId(userId, data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  return {
    /**
     * Get list of friends in a namespace.
     */
    getFriendsMe,
    /**
     * Sync friends using server to server call to native first party server. Supported platforms: steam: The platform_tokens value is the binary ticket returned by Steam. If this ticket was generated by Steam GetAuthTicketForWebApi with version &gt;= 1.57, then platform token should use this style: {identity}:{ticket} the {identity} was the parameter to call GetAuthTicketForWebApi when the ticket was created. Note: Do not contain : in this {identity} ps4: The platform_tokens value is the authorization code returned by Sony OAuth. ps5: The platform_tokens value is the authorization code returned by Sony OAuth. pspc: The platform_tokens value is the authorization code returned by Sony OAuth.
     */
    patchFriendSyncMe,
    /**
     * Client should provide either friendID or friendPublicID. If both are provided, friendID will be chosen to be used. This endpoint will only send a pending invite that can be either rejected/accepted
     */
    createFriendMeRequest,
    /**
     * Get list of incoming friends in a namespace.
     */
    getFriendsMeIncoming,
    /**
     * Get list of outgoing friends in a namespace.
     */
    getFriendsMeOutgoing,
    /**
     * User unfriend a friend.
     */
    createFriendMeUnfriend,
    /**
     * Get list of friends with platform data in a namespace.
     */
    getFriendsMePlatforms,
    /**
     * Get list of incoming friends with requested time info in a namespace.
     */
    getFriendsMeIncomingTime,
    /**
     * Get list of outgoing friends with requested time info in a namespace.
     */
    getFriendsMeOutgoingTime,
    /**
     * User accept friend.
     */
    createFriendMeRequestAccept,
    /**
     * User cancel a friend request.
     */
    createFriendMeRequestCancel,
    /**
     * User reject a friend request.
     */
    createFriendMeRequestReject,
    /**
     * User get friendship status. Code: 0 - Message: &#34;not friend&#34; Code: 1 - Message: &#34;outgoing&#34; Code: 2 - Message: &#34;incoming&#34; Code: 3 - Message: &#34;friend&#34;
     */
    getFriendMeStatu_ByFriendId,
    /**
     * Friends request in a namespace.
     */
    createAddBulkFriend_ByUserId,
    /**
     * Friends request in a namespace.
     */
    createDeleteBulkFriend_ByUserId
  };
}

// src/generated-public/LobbyOperationsApi.ts
var import_sdk30 = require("@accelbyte/sdk");
function LobbyOperationsApi(sdk, args) {
  const sdkAssembly = sdk.assembly();
  const namespace = args?.coreConfig?.namespace ?? sdkAssembly.coreConfig.namespace;
  const useSchemaValidation = args?.coreConfig?.useSchemaValidation ?? sdkAssembly.coreConfig.useSchemaValidation;
  let axiosInstance = sdkAssembly.axiosInstance;
  const requestConfigOverrides = args?.axiosConfig?.request;
  const baseURLOverride = args?.coreConfig?.baseURL;
  const interceptorsOverride = args?.axiosConfig?.interceptors ?? [];
  if (requestConfigOverrides || baseURLOverride || interceptorsOverride.length > 0) {
    const requestConfig = import_sdk30.ApiUtils.mergeAxiosConfigs(sdkAssembly.axiosInstance.defaults, {
      ...baseURLOverride ? { baseURL: baseURLOverride } : {},
      ...requestConfigOverrides
    });
    axiosInstance = import_sdk30.Network.create(requestConfig);
    for (const interceptor of interceptorsOverride) {
      if (interceptor.type === "request") {
        axiosInstance.interceptors.request.use(interceptor.onRequest, interceptor.onError);
      }
      if (interceptor.type === "response") {
        axiosInstance.interceptors.response.use(interceptor.onSuccess, interceptor.onError);
      }
    }
  }
  async function getMessages() {
    const $ = new LobbyOperations$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getMessages();
    if (resp.error) throw resp.error;
    return resp.response;
  }
  return {
    /**
     * get the list of messages.
     */
    getMessages
  };
}

// src/generated-public/NotificationApi.ts
var import_sdk31 = require("@accelbyte/sdk");
function NotificationApi(sdk, args) {
  const sdkAssembly = sdk.assembly();
  const namespace = args?.coreConfig?.namespace ?? sdkAssembly.coreConfig.namespace;
  const useSchemaValidation = args?.coreConfig?.useSchemaValidation ?? sdkAssembly.coreConfig.useSchemaValidation;
  let axiosInstance = sdkAssembly.axiosInstance;
  const requestConfigOverrides = args?.axiosConfig?.request;
  const baseURLOverride = args?.coreConfig?.baseURL;
  const interceptorsOverride = args?.axiosConfig?.interceptors ?? [];
  if (requestConfigOverrides || baseURLOverride || interceptorsOverride.length > 0) {
    const requestConfig = import_sdk31.ApiUtils.mergeAxiosConfigs(sdkAssembly.axiosInstance.defaults, {
      ...baseURLOverride ? { baseURL: baseURLOverride } : {},
      ...requestConfigOverrides
    });
    axiosInstance = import_sdk31.Network.create(requestConfig);
    for (const interceptor of interceptorsOverride) {
      if (interceptor.type === "request") {
        axiosInstance.interceptors.request.use(interceptor.onRequest, interceptor.onError);
      }
      if (interceptor.type === "response") {
        axiosInstance.interceptors.response.use(interceptor.onSuccess, interceptor.onError);
      }
    }
  }
  async function getNotificationMe(queryParams) {
    const $ = new Notification$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getNotificationMe(queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getNotificationTopics(queryParams) {
    const $ = new Notification$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getNotificationTopics(queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function createNotificationTopic(data) {
    const $ = new Notification$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.createNotificationTopic(data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function deleteNotificationTopic_ByTopic(topic) {
    const $ = new Notification$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.deleteNotificationTopic_ByTopic(topic);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getNotificationTopic_ByTopic(topic) {
    const $ = new Notification$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getNotificationTopic_ByTopic(topic);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function updateNotificationTopic_ByTopic(topic, data) {
    const $ = new Notification$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.updateNotificationTopic_ByTopic(topic, data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function createFreeformNotification_ByUserId(userId, data) {
    const $ = new Notification$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.createFreeformNotification_ByUserId(userId, data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function createTemplatedNotification_ByUserId(userId, data) {
    const $ = new Notification$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.createTemplatedNotification_ByUserId(userId, data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  return {
    /**
     * Get list of notifications in a namespace. The query parameters **startTime** and **endTime** can be filled with the **sequenceID** value in the notification, where the value is an epoch timestamp. Example **sequenceID** or epoch timestamp value: **1706595813**
     */
    getNotificationMe,
    /**
     * get topic by namespace.
     */
    getNotificationTopics,
    /**
     * Create new notification topic. &lt;br&gt;topic should be alphabets, no special char except underscore, uppercase and no spacing. for example: TOPIC_TEST. Already existing topic can not be created
     */
    createNotificationTopic,
    /**
     * delete topic information by topic name. &lt;br&gt;topic should be alphabets, no special char except underscore, uppercase and no spacing. for example: TOPIC_TEST. Already existing topic can not be created
     */
    deleteNotificationTopic_ByTopic,
    /**
     * get topic information by topic name.
     */
    getNotificationTopic_ByTopic,
    /**
     * update topic information by topic name. &lt;br&gt;topic should be alphabets, no special char except underscore, uppercase and no spacing. for example: TOPIC_TEST. Already existing topic can not be created
     */
    updateNotificationTopic_ByTopic,
    /**
     * Sends notification to a user.
     */
    createFreeformNotification_ByUserId,
    /**
     * Sends notification to a user with predefined template. &lt;br&gt;In the request body, specify which template slug (template identifier) to use and the template language. &lt;br&gt;NotificationTemplate context is the key-value pair defining the value of each handlebar specified in the template content. Template need to be published before it can be use to send notifications
     */
    createTemplatedNotification_ByUserId
  };
}

// src/generated-public/PartyApi.ts
var import_sdk32 = require("@accelbyte/sdk");
function PartyApi(sdk, args) {
  const sdkAssembly = sdk.assembly();
  const namespace = args?.coreConfig?.namespace ?? sdkAssembly.coreConfig.namespace;
  const useSchemaValidation = args?.coreConfig?.useSchemaValidation ?? sdkAssembly.coreConfig.useSchemaValidation;
  let axiosInstance = sdkAssembly.axiosInstance;
  const requestConfigOverrides = args?.axiosConfig?.request;
  const baseURLOverride = args?.coreConfig?.baseURL;
  const interceptorsOverride = args?.axiosConfig?.interceptors ?? [];
  if (requestConfigOverrides || baseURLOverride || interceptorsOverride.length > 0) {
    const requestConfig = import_sdk32.ApiUtils.mergeAxiosConfigs(sdkAssembly.axiosInstance.defaults, {
      ...baseURLOverride ? { baseURL: baseURLOverride } : {},
      ...requestConfigOverrides
    });
    axiosInstance = import_sdk32.Network.create(requestConfig);
    for (const interceptor of interceptorsOverride) {
      if (interceptor.type === "request") {
        axiosInstance.interceptors.request.use(interceptor.onRequest, interceptor.onError);
      }
      if (interceptor.type === "response") {
        axiosInstance.interceptors.response.use(interceptor.onSuccess, interceptor.onError);
      }
    }
  }
  async function getPartyParty_ByPartyId(partyId) {
    const $ = new Party$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getPartyParty_ByPartyId(partyId);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function updateLimitParty_ByPartyId(partyId, data) {
    const $ = new Party$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.updateLimitParty_ByPartyId(partyId, data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function updateAttributeParty_ByPartyId(partyId, data) {
    const $ = new Party$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.updateAttributeParty_ByPartyId(partyId, data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  return {
    /**
     * Required valid user authorization &lt;br/&gt; &lt;br&gt;load personal party data in a namespace based on Party ID &lt;br/&gt; Action Code: 50101
     */
    getPartyParty_ByPartyId,
    /**
     * Required valid user authorization &lt;br/&gt; &lt;br&gt;Set party limit, only party leader can call this endpoint.
     */
    updateLimitParty_ByPartyId,
    /**
     * Required valid user authorization &lt;br/&gt; &lt;br&gt;update party attributes in a namespace.
     */
    updateAttributeParty_ByPartyId
  };
}

// src/generated-public/PlayerApi.ts
var import_sdk33 = require("@accelbyte/sdk");
function PlayerApi(sdk, args) {
  const sdkAssembly = sdk.assembly();
  const namespace = args?.coreConfig?.namespace ?? sdkAssembly.coreConfig.namespace;
  const useSchemaValidation = args?.coreConfig?.useSchemaValidation ?? sdkAssembly.coreConfig.useSchemaValidation;
  let axiosInstance = sdkAssembly.axiosInstance;
  const requestConfigOverrides = args?.axiosConfig?.request;
  const baseURLOverride = args?.coreConfig?.baseURL;
  const interceptorsOverride = args?.axiosConfig?.interceptors ?? [];
  if (requestConfigOverrides || baseURLOverride || interceptorsOverride.length > 0) {
    const requestConfig = import_sdk33.ApiUtils.mergeAxiosConfigs(sdkAssembly.axiosInstance.defaults, {
      ...baseURLOverride ? { baseURL: baseURLOverride } : {},
      ...requestConfigOverrides
    });
    axiosInstance = import_sdk33.Network.create(requestConfig);
    for (const interceptor of interceptorsOverride) {
      if (interceptor.type === "request") {
        axiosInstance.interceptors.request.use(interceptor.onRequest, interceptor.onError);
      }
      if (interceptor.type === "response") {
        axiosInstance.interceptors.response.use(interceptor.onSuccess, interceptor.onError);
      }
    }
  }
  async function createPlayerUserMeBlock(data) {
    const $ = new Player$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.createPlayerUserMeBlock(data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getPlayerUsersMeBlocked() {
    const $ = new Player$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getPlayerUsersMeBlocked();
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function createPlayerUserMeUnblock(data) {
    const $ = new Player$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.createPlayerUserMeUnblock(data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getPlayerUsersMeBlockedBy() {
    const $ = new Player$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getPlayerUsersMeBlockedBy();
    if (resp.error) throw resp.error;
    return resp.response;
  }
  return {
    /**
     * Required valid user authorization &lt;br/&gt; &lt;br&gt;add blocked players in a namespace based on user id &lt;br/&gt;
     */
    createPlayerUserMeBlock,
    /**
     * Required valid user authorization &lt;br/&gt; &lt;br&gt;load blocked players in a namespace based on user id &lt;br/&gt; Action Code: 50101
     */
    getPlayerUsersMeBlocked,
    /**
     * Required valid user authorization &lt;br/&gt; unblock player in a namespace based on user id &lt;br/&gt;
     */
    createPlayerUserMeUnblock,
    /**
     * Required valid user authorization &lt;br/&gt; &lt;br&gt;load get players who blocked this player in a namespace based on user id &lt;br/&gt; Action Code: 50101
     */
    getPlayerUsersMeBlockedBy
  };
}

// src/generated-public/PresenceApi.ts
var import_sdk34 = require("@accelbyte/sdk");
function PresenceApi(sdk, args) {
  const sdkAssembly = sdk.assembly();
  const namespace = args?.coreConfig?.namespace ?? sdkAssembly.coreConfig.namespace;
  const useSchemaValidation = args?.coreConfig?.useSchemaValidation ?? sdkAssembly.coreConfig.useSchemaValidation;
  let axiosInstance = sdkAssembly.axiosInstance;
  const requestConfigOverrides = args?.axiosConfig?.request;
  const baseURLOverride = args?.coreConfig?.baseURL;
  const interceptorsOverride = args?.axiosConfig?.interceptors ?? [];
  if (requestConfigOverrides || baseURLOverride || interceptorsOverride.length > 0) {
    const requestConfig = import_sdk34.ApiUtils.mergeAxiosConfigs(sdkAssembly.axiosInstance.defaults, {
      ...baseURLOverride ? { baseURL: baseURLOverride } : {},
      ...requestConfigOverrides
    });
    axiosInstance = import_sdk34.Network.create(requestConfig);
    for (const interceptor of interceptorsOverride) {
      if (interceptor.type === "request") {
        axiosInstance.interceptors.request.use(interceptor.onRequest, interceptor.onError);
      }
      if (interceptor.type === "response") {
        axiosInstance.interceptors.response.use(interceptor.onSuccess, interceptor.onError);
      }
    }
  }
  async function getPresenceUsersPresence(queryParams) {
    const $ = new Presence$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getPresenceUsersPresence(queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function createPresenceUserPresence(data, queryParams) {
    const $ = new Presence$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.createPresenceUserPresence(data, queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  return {
    /**
     * Query users presence with given namespace and userIds.
     */
    getPresenceUsersPresence,
    /**
     * Query users presence with given namespace and userIds.
     */
    createPresenceUserPresence
  };
}

// package.json
var name = "@accelbyte/sdk-lobby";
var version = "5.0.1";
var author = "AccelByte Inc";

// src/generated-websocket/WebSocketClass.ts
var import_sdk35 = require("@accelbyte/sdk");

// src/generated-websocket/WebSocketDefinitions.ts
var import_zod124 = require("zod");
var AcceptFriendsNotif = import_zod124.z.object({
  type: import_zod124.z.literal("acceptFriendsNotif"),
  friendId: import_zod124.z.coerce.string()
});
var AcceptFriendsRequest = import_zod124.z.object({
  type: import_zod124.z.literal("acceptFriendsRequest"),
  friendId: import_zod124.z.coerce.string(),
  id: import_zod124.z.coerce.string()
});
var AcceptFriendsResponse = import_zod124.z.object({
  type: import_zod124.z.literal("acceptFriendsResponse"),
  code: import_zod124.z.coerce.number(),
  id: import_zod124.z.coerce.string()
});
var BlockPlayerNotif = import_zod124.z.object({
  type: import_zod124.z.literal("blockPlayerNotif"),
  blockedUserId: import_zod124.z.coerce.string(),
  userId: import_zod124.z.coerce.string()
});
var BlockPlayerRequest2 = import_zod124.z.object({
  type: import_zod124.z.literal("blockPlayerRequest"),
  blockUserId: import_zod124.z.coerce.string(),
  id: import_zod124.z.coerce.string(),
  namespace: import_zod124.z.coerce.string()
});
var BlockPlayerResponse = import_zod124.z.object({
  type: import_zod124.z.literal("blockPlayerResponse"),
  blockUserId: import_zod124.z.coerce.string(),
  code: import_zod124.z.coerce.number(),
  id: import_zod124.z.coerce.string(),
  namespace: import_zod124.z.coerce.string()
});
var CancelFriendsNotif = import_zod124.z.object({
  type: import_zod124.z.literal("cancelFriendsNotif"),
  userId: import_zod124.z.coerce.string()
});
var CancelFriendsRequest = import_zod124.z.object({
  type: import_zod124.z.literal("cancelFriendsRequest"),
  friendId: import_zod124.z.coerce.string(),
  id: import_zod124.z.coerce.string()
});
var CancelFriendsResponse = import_zod124.z.object({
  type: import_zod124.z.literal("cancelFriendsResponse"),
  code: import_zod124.z.coerce.number(),
  id: import_zod124.z.coerce.string()
});
var CancelMatchmakingRequest = import_zod124.z.object({
  type: import_zod124.z.literal("cancelMatchmakingRequest"),
  gameMode: import_zod124.z.coerce.string(),
  id: import_zod124.z.coerce.string(),
  isTempParty: import_zod124.z.boolean()
});
var CancelMatchmakingResponse = import_zod124.z.object({
  type: import_zod124.z.literal("cancelMatchmakingResponse"),
  code: import_zod124.z.coerce.number(),
  id: import_zod124.z.coerce.string()
});
var ChannelChatNotif = import_zod124.z.object({
  type: import_zod124.z.literal("channelChatNotif"),
  channelSlug: import_zod124.z.coerce.string(),
  from: import_zod124.z.coerce.string(),
  payload: import_zod124.z.coerce.string(),
  sentAt: import_zod124.z.coerce.string()
});
var ClientResetRequest = import_zod124.z.object({
  type: import_zod124.z.literal("clientResetRequest"),
  namespace: import_zod124.z.coerce.string(),
  userId: import_zod124.z.coerce.string()
});
var ConnectNotif = import_zod124.z.object({
  type: import_zod124.z.literal("connectNotif"),
  lobbySessionID: import_zod124.z.coerce.string()
});
var DisconnectNotif = import_zod124.z.object({
  type: import_zod124.z.literal("disconnectNotif"),
  connectionId: import_zod124.z.coerce.string(),
  namespace: import_zod124.z.coerce.string()
});
var DsNotif = import_zod124.z.object({
  type: import_zod124.z.literal("dsNotif"),
  alternateIps: import_zod124.z.array(import_zod124.z.coerce.string()),
  customAttribute: import_zod124.z.coerce.string(),
  deployment: import_zod124.z.coerce.string(),
  gameVersion: import_zod124.z.coerce.string(),
  imageVersion: import_zod124.z.coerce.string(),
  ip: import_zod124.z.coerce.string(),
  isOK: import_zod124.z.boolean(),
  isOverrideGameVersion: import_zod124.z.boolean(),
  lastUpdate: import_zod124.z.coerce.string(),
  matchId: import_zod124.z.coerce.string(),
  message: import_zod124.z.coerce.string(),
  namespace: import_zod124.z.coerce.string(),
  podName: import_zod124.z.coerce.string(),
  port: import_zod124.z.coerce.number(),
  ports: import_zod124.z.any(),
  protocol: import_zod124.z.coerce.string(),
  provider: import_zod124.z.coerce.string(),
  region: import_zod124.z.coerce.string(),
  sessionId: import_zod124.z.coerce.string(),
  status: import_zod124.z.coerce.string()
});
var ErrorNotif = import_zod124.z.object({
  type: import_zod124.z.literal("errorNotif"),
  message: import_zod124.z.coerce.string()
});
var ExitAllChannel = import_zod124.z.object({
  type: import_zod124.z.literal("exitAllChannel"),
  namespace: import_zod124.z.coerce.string(),
  userId: import_zod124.z.coerce.string()
});
var FriendsStatusRequest = import_zod124.z.object({
  type: import_zod124.z.literal("friendsStatusRequest"),
  id: import_zod124.z.coerce.string()
});
var FriendsStatusResponse = import_zod124.z.object({
  type: import_zod124.z.literal("friendsStatusResponse"),
  activity: import_zod124.z.array(import_zod124.z.coerce.string()),
  availability: import_zod124.z.array(import_zod124.z.coerce.string()),
  code: import_zod124.z.coerce.number(),
  friendIds: import_zod124.z.array(import_zod124.z.coerce.string()),
  id: import_zod124.z.coerce.string(),
  lastSeenAt: import_zod124.z.array(import_zod124.z.coerce.string())
});
var GetAllSessionAttributeRequest = import_zod124.z.object({
  type: import_zod124.z.literal("getAllSessionAttributeRequest"),
  id: import_zod124.z.coerce.string()
});
var GetAllSessionAttributeResponse = import_zod124.z.object({
  type: import_zod124.z.literal("getAllSessionAttributeResponse"),
  attributes: import_zod124.z.any(),
  code: import_zod124.z.coerce.number(),
  id: import_zod124.z.coerce.string()
});
var GetFriendshipStatusRequest = import_zod124.z.object({
  type: import_zod124.z.literal("getFriendshipStatusRequest"),
  friendId: import_zod124.z.coerce.string(),
  id: import_zod124.z.coerce.string()
});
var GetFriendshipStatusResponse = import_zod124.z.object({
  type: import_zod124.z.literal("getFriendshipStatusResponse"),
  code: import_zod124.z.coerce.number(),
  friendshipStatus: import_zod124.z.coerce.string(),
  id: import_zod124.z.coerce.string()
});
var GetSessionAttributeRequest = import_zod124.z.object({
  type: import_zod124.z.literal("getSessionAttributeRequest"),
  id: import_zod124.z.coerce.string(),
  key: import_zod124.z.coerce.string()
});
var GetSessionAttributeResponse = import_zod124.z.object({
  type: import_zod124.z.literal("getSessionAttributeResponse"),
  code: import_zod124.z.coerce.number(),
  id: import_zod124.z.coerce.string(),
  value: import_zod124.z.coerce.string()
});
var JoinDefaultChannelRequest = import_zod124.z.object({
  type: import_zod124.z.literal("joinDefaultChannelRequest"),
  id: import_zod124.z.coerce.string()
});
var JoinDefaultChannelResponse = import_zod124.z.object({
  type: import_zod124.z.literal("joinDefaultChannelResponse"),
  channelSlug: import_zod124.z.coerce.string(),
  code: import_zod124.z.coerce.number(),
  id: import_zod124.z.coerce.string()
});
var ListIncomingFriendsRequest = import_zod124.z.object({
  type: import_zod124.z.literal("listIncomingFriendsRequest"),
  id: import_zod124.z.coerce.string()
});
var ListIncomingFriendsResponse = import_zod124.z.object({
  type: import_zod124.z.literal("listIncomingFriendsResponse"),
  code: import_zod124.z.coerce.number(),
  id: import_zod124.z.coerce.string(),
  userIds: import_zod124.z.array(import_zod124.z.coerce.string())
});
var ListOfFriendsRequest = import_zod124.z.object({
  type: import_zod124.z.literal("listOfFriendsRequest"),
  friendId: import_zod124.z.coerce.string(),
  id: import_zod124.z.coerce.string()
});
var ListOfFriendsResponse = import_zod124.z.object({
  type: import_zod124.z.literal("listOfFriendsResponse"),
  code: import_zod124.z.coerce.number(),
  friendIds: import_zod124.z.array(import_zod124.z.coerce.string()),
  id: import_zod124.z.coerce.string()
});
var ListOnlineFriendsRequest = import_zod124.z.object({
  type: import_zod124.z.literal("listOnlineFriendsRequest"),
  id: import_zod124.z.coerce.string()
});
var ListOutgoingFriendsRequest = import_zod124.z.object({
  type: import_zod124.z.literal("listOutgoingFriendsRequest"),
  id: import_zod124.z.coerce.string()
});
var ListOutgoingFriendsResponse = import_zod124.z.object({
  type: import_zod124.z.literal("listOutgoingFriendsResponse"),
  code: import_zod124.z.coerce.number(),
  friendIds: import_zod124.z.array(import_zod124.z.coerce.string()),
  id: import_zod124.z.coerce.string()
});
var MatchmakingNotif = import_zod124.z.object({
  type: import_zod124.z.literal("matchmakingNotif"),
  counterPartyMember: import_zod124.z.array(import_zod124.z.coerce.string()),
  matchId: import_zod124.z.coerce.string(),
  message: import_zod124.z.coerce.string(),
  partyMember: import_zod124.z.array(import_zod124.z.coerce.string()),
  readyDuration: import_zod124.z.coerce.number(),
  status: import_zod124.z.coerce.string()
});
var MessageNotif = import_zod124.z.object({
  type: import_zod124.z.literal("messageNotif"),
  from: import_zod124.z.coerce.string(),
  id: import_zod124.z.coerce.string(),
  payload: import_zod124.z.coerce.string(),
  sentAt: import_zod124.z.coerce.string(),
  to: import_zod124.z.coerce.string(),
  topic: import_zod124.z.coerce.string()
});
var MessageSessionNotif = import_zod124.z.object({
  type: import_zod124.z.literal("messageSessionNotif"),
  from: import_zod124.z.coerce.string(),
  id: import_zod124.z.coerce.string(),
  payload: import_zod124.z.coerce.string(),
  sentAt: import_zod124.z.coerce.string(),
  to: import_zod124.z.coerce.string(),
  topic: import_zod124.z.coerce.string()
});
var OfflineNotificationRequest = import_zod124.z.object({
  type: import_zod124.z.literal("offlineNotificationRequest"),
  id: import_zod124.z.coerce.string()
});
var OfflineNotificationResponse = import_zod124.z.object({
  type: import_zod124.z.literal("offlineNotificationResponse"),
  code: import_zod124.z.coerce.number(),
  id: import_zod124.z.coerce.string()
});
var OnlineFriends = import_zod124.z.object({
  type: import_zod124.z.literal("onlineFriends"),
  code: import_zod124.z.coerce.number(),
  id: import_zod124.z.coerce.string(),
  onlineFriendIds: import_zod124.z.array(import_zod124.z.coerce.string())
});
var PartyChatNotif = import_zod124.z.object({
  type: import_zod124.z.literal("partyChatNotif"),
  from: import_zod124.z.coerce.string(),
  id: import_zod124.z.coerce.string(),
  payload: import_zod124.z.coerce.string(),
  receivedAt: import_zod124.z.coerce.string(),
  to: import_zod124.z.coerce.string()
});
var PartyChatRequest = import_zod124.z.object({
  type: import_zod124.z.literal("partyChatRequest"),
  from: import_zod124.z.coerce.string(),
  id: import_zod124.z.coerce.string(),
  payload: import_zod124.z.coerce.string(),
  receivedAt: import_zod124.z.coerce.string(),
  to: import_zod124.z.coerce.string()
});
var PartyChatResponse = import_zod124.z.object({
  type: import_zod124.z.literal("partyChatResponse"),
  code: import_zod124.z.coerce.number(),
  id: import_zod124.z.coerce.string()
});
var PartyCreateRequest = import_zod124.z.object({
  type: import_zod124.z.literal("partyCreateRequest"),
  id: import_zod124.z.coerce.string()
});
var PartyCreateResponse = import_zod124.z.object({
  type: import_zod124.z.literal("partyCreateResponse"),
  code: import_zod124.z.coerce.number(),
  id: import_zod124.z.coerce.string(),
  invitationToken: import_zod124.z.coerce.string(),
  invitees: import_zod124.z.coerce.string(),
  leaderId: import_zod124.z.coerce.string(),
  members: import_zod124.z.coerce.string(),
  partyId: import_zod124.z.coerce.string()
});
var PartyDataUpdateNotif = import_zod124.z.object({
  type: import_zod124.z.literal("partyDataUpdateNotif"),
  customAttributes: import_zod124.z.any(),
  invitees: import_zod124.z.array(import_zod124.z.coerce.string()),
  leader: import_zod124.z.coerce.string(),
  members: import_zod124.z.array(import_zod124.z.coerce.string()),
  namespace: import_zod124.z.coerce.string(),
  partyId: import_zod124.z.coerce.string(),
  updatedAt: import_zod124.z.coerce.string()
});
var PartyGetInvitedNotif = import_zod124.z.object({
  type: import_zod124.z.literal("partyGetInvitedNotif"),
  from: import_zod124.z.coerce.string(),
  invitationToken: import_zod124.z.coerce.string(),
  partyId: import_zod124.z.coerce.string()
});
var PartyInfoRequest = import_zod124.z.object({
  type: import_zod124.z.literal("partyInfoRequest"),
  id: import_zod124.z.coerce.string()
});
var PartyInfoResponse = import_zod124.z.object({
  type: import_zod124.z.literal("partyInfoResponse"),
  code: import_zod124.z.coerce.number(),
  customAttributes: import_zod124.z.any(),
  id: import_zod124.z.coerce.string(),
  invitationToken: import_zod124.z.coerce.string(),
  invitees: import_zod124.z.coerce.string(),
  leaderId: import_zod124.z.coerce.string(),
  members: import_zod124.z.coerce.string(),
  partyId: import_zod124.z.coerce.string()
});
var PartyInviteNotif = import_zod124.z.object({
  type: import_zod124.z.literal("partyInviteNotif"),
  inviteeId: import_zod124.z.coerce.string(),
  inviterId: import_zod124.z.coerce.string()
});
var PartyInviteRequest = import_zod124.z.object({
  type: import_zod124.z.literal("partyInviteRequest"),
  friendId: import_zod124.z.coerce.string(),
  id: import_zod124.z.coerce.string()
});
var PartyInviteResponse = import_zod124.z.object({
  type: import_zod124.z.literal("partyInviteResponse"),
  code: import_zod124.z.coerce.number(),
  id: import_zod124.z.coerce.string()
});
var PartyJoinNotif = import_zod124.z.object({
  type: import_zod124.z.literal("partyJoinNotif"),
  userId: import_zod124.z.coerce.string()
});
var PartyJoinRequest = import_zod124.z.object({
  type: import_zod124.z.literal("partyJoinRequest"),
  id: import_zod124.z.coerce.string(),
  invitationToken: import_zod124.z.coerce.string(),
  partyId: import_zod124.z.coerce.string()
});
var PartyJoinResponse = import_zod124.z.object({
  type: import_zod124.z.literal("partyJoinResponse"),
  code: import_zod124.z.coerce.number(),
  id: import_zod124.z.coerce.string(),
  invitationToken: import_zod124.z.coerce.string(),
  invitees: import_zod124.z.coerce.string(),
  leaderId: import_zod124.z.coerce.string(),
  members: import_zod124.z.coerce.string(),
  partyId: import_zod124.z.coerce.string()
});
var PartyKickNotif = import_zod124.z.object({
  type: import_zod124.z.literal("partyKickNotif"),
  leaderId: import_zod124.z.coerce.string(),
  partyId: import_zod124.z.coerce.string(),
  userId: import_zod124.z.coerce.string()
});
var PartyKickRequest = import_zod124.z.object({
  type: import_zod124.z.literal("partyKickRequest"),
  id: import_zod124.z.coerce.string(),
  memberId: import_zod124.z.coerce.string()
});
var PartyKickResponse = import_zod124.z.object({
  type: import_zod124.z.literal("partyKickResponse"),
  code: import_zod124.z.coerce.number(),
  id: import_zod124.z.coerce.string()
});
var PartyLeaveNotif = import_zod124.z.object({
  type: import_zod124.z.literal("partyLeaveNotif"),
  leaderId: import_zod124.z.coerce.string(),
  userId: import_zod124.z.coerce.string()
});
var PartyLeaveRequest = import_zod124.z.object({
  type: import_zod124.z.literal("partyLeaveRequest"),
  id: import_zod124.z.coerce.string(),
  ignoreUserRegistry: import_zod124.z.boolean()
});
var PartyLeaveResponse = import_zod124.z.object({
  type: import_zod124.z.literal("partyLeaveResponse"),
  code: import_zod124.z.coerce.number(),
  id: import_zod124.z.coerce.string()
});
var PartyPromoteLeaderRequest = import_zod124.z.object({
  type: import_zod124.z.literal("partyPromoteLeaderRequest"),
  id: import_zod124.z.coerce.string(),
  newLeaderUserId: import_zod124.z.coerce.string()
});
var PartyPromoteLeaderResponse = import_zod124.z.object({
  type: import_zod124.z.literal("partyPromoteLeaderResponse"),
  code: import_zod124.z.coerce.number(),
  id: import_zod124.z.coerce.string(),
  invitationToken: import_zod124.z.coerce.string(),
  invitees: import_zod124.z.coerce.string(),
  leaderId: import_zod124.z.coerce.string(),
  members: import_zod124.z.coerce.string(),
  partyId: import_zod124.z.coerce.string()
});
var PartyRejectNotif = import_zod124.z.object({
  type: import_zod124.z.literal("partyRejectNotif"),
  leaderId: import_zod124.z.coerce.string(),
  partyId: import_zod124.z.coerce.string(),
  userId: import_zod124.z.coerce.string()
});
var PartyRejectRequest = import_zod124.z.object({
  type: import_zod124.z.literal("partyRejectRequest"),
  id: import_zod124.z.coerce.string(),
  invitationToken: import_zod124.z.coerce.string(),
  partyId: import_zod124.z.coerce.string()
});
var PartyRejectResponse = import_zod124.z.object({
  type: import_zod124.z.literal("partyRejectResponse"),
  code: import_zod124.z.coerce.number(),
  id: import_zod124.z.coerce.string(),
  partyId: import_zod124.z.coerce.string()
});
var PersonalChatHistoryRequest = import_zod124.z.object({
  type: import_zod124.z.literal("personalChatHistoryRequest"),
  friendId: import_zod124.z.coerce.string(),
  id: import_zod124.z.coerce.string()
});
var PersonalChatHistoryResponse = import_zod124.z.object({
  type: import_zod124.z.literal("personalChatHistoryResponse"),
  chat: import_zod124.z.coerce.string(),
  code: import_zod124.z.coerce.number(),
  friendId: import_zod124.z.coerce.string(),
  id: import_zod124.z.coerce.string()
});
var PersonalChatNotif = import_zod124.z.object({
  type: import_zod124.z.literal("personalChatNotif"),
  from: import_zod124.z.coerce.string(),
  id: import_zod124.z.coerce.string(),
  payload: import_zod124.z.coerce.string(),
  receivedAt: import_zod124.z.coerce.string(),
  to: import_zod124.z.coerce.string()
});
var PersonalChatRequest = import_zod124.z.object({
  type: import_zod124.z.literal("personalChatRequest"),
  from: import_zod124.z.coerce.string(),
  id: import_zod124.z.coerce.string(),
  payload: import_zod124.z.coerce.string(),
  receivedAt: import_zod124.z.coerce.string(),
  to: import_zod124.z.coerce.string()
});
var PersonalChatResponse = import_zod124.z.object({
  type: import_zod124.z.literal("personalChatResponse"),
  code: import_zod124.z.coerce.number(),
  id: import_zod124.z.coerce.string()
});
var RefreshTokenRequest = import_zod124.z.object({
  type: import_zod124.z.literal("refreshTokenRequest"),
  id: import_zod124.z.coerce.string(),
  token: import_zod124.z.coerce.string()
});
var RefreshTokenResponse = import_zod124.z.object({
  type: import_zod124.z.literal("refreshTokenResponse"),
  code: import_zod124.z.coerce.number(),
  id: import_zod124.z.coerce.string()
});
var RejectFriendsNotif = import_zod124.z.object({
  type: import_zod124.z.literal("rejectFriendsNotif"),
  userId: import_zod124.z.coerce.string()
});
var RejectFriendsRequest = import_zod124.z.object({
  type: import_zod124.z.literal("rejectFriendsRequest"),
  friendId: import_zod124.z.coerce.string(),
  id: import_zod124.z.coerce.string()
});
var RejectFriendsResponse = import_zod124.z.object({
  type: import_zod124.z.literal("rejectFriendsResponse"),
  code: import_zod124.z.coerce.number(),
  id: import_zod124.z.coerce.string()
});
var RematchmakingNotif = import_zod124.z.object({
  type: import_zod124.z.literal("rematchmakingNotif"),
  banDuration: import_zod124.z.coerce.number()
});
var RequestFriendsNotif = import_zod124.z.object({
  type: import_zod124.z.literal("requestFriendsNotif"),
  friendId: import_zod124.z.coerce.string()
});
var RequestFriendsRequest = import_zod124.z.object({
  type: import_zod124.z.literal("requestFriendsRequest"),
  friendId: import_zod124.z.coerce.string(),
  id: import_zod124.z.coerce.string()
});
var RequestFriendsResponse = import_zod124.z.object({
  type: import_zod124.z.literal("requestFriendsResponse"),
  code: import_zod124.z.coerce.number(),
  id: import_zod124.z.coerce.string()
});
var SendChannelChatRequest = import_zod124.z.object({
  type: import_zod124.z.literal("sendChannelChatRequest"),
  channelSlug: import_zod124.z.coerce.string(),
  id: import_zod124.z.coerce.string(),
  payload: import_zod124.z.coerce.string()
});
var SendChannelChatResponse = import_zod124.z.object({
  type: import_zod124.z.literal("sendChannelChatResponse"),
  code: import_zod124.z.coerce.number(),
  id: import_zod124.z.coerce.string()
});
var SetReadyConsentNotif = import_zod124.z.object({
  type: import_zod124.z.literal("setReadyConsentNotif"),
  matchId: import_zod124.z.coerce.string(),
  userId: import_zod124.z.coerce.string()
});
var SetReadyConsentRequest = import_zod124.z.object({
  type: import_zod124.z.literal("setReadyConsentRequest"),
  id: import_zod124.z.coerce.string(),
  matchId: import_zod124.z.coerce.string()
});
var SetReadyConsentResponse = import_zod124.z.object({
  type: import_zod124.z.literal("setReadyConsentResponse"),
  code: import_zod124.z.coerce.number(),
  id: import_zod124.z.coerce.string()
});
var SetSessionAttributeRequest = import_zod124.z.object({
  type: import_zod124.z.literal("setSessionAttributeRequest"),
  id: import_zod124.z.coerce.string(),
  key: import_zod124.z.coerce.string(),
  namespace: import_zod124.z.coerce.string(),
  value: import_zod124.z.coerce.string()
});
var SetSessionAttributeResponse = import_zod124.z.object({
  type: import_zod124.z.literal("setSessionAttributeResponse"),
  code: import_zod124.z.coerce.number(),
  id: import_zod124.z.coerce.string()
});
var SetUserStatusRequest = import_zod124.z.object({
  type: import_zod124.z.literal("setUserStatusRequest"),
  activity: import_zod124.z.coerce.string(),
  availability: import_zod124.z.coerce.number(),
  id: import_zod124.z.coerce.string()
});
var SetUserStatusResponse = import_zod124.z.object({
  type: import_zod124.z.literal("setUserStatusResponse"),
  code: import_zod124.z.coerce.number(),
  id: import_zod124.z.coerce.string()
});
var ShutdownNotif = import_zod124.z.object({
  type: import_zod124.z.literal("shutdownNotif"),
  message: import_zod124.z.coerce.string()
});
var SignalingP2PNotif = import_zod124.z.object({
  type: import_zod124.z.literal("signalingP2PNotif"),
  destinationId: import_zod124.z.coerce.string(),
  message: import_zod124.z.coerce.string()
});
var StartMatchmakingRequest = import_zod124.z.object({
  type: import_zod124.z.literal("startMatchmakingRequest"),
  extraAttributes: import_zod124.z.coerce.string(),
  gameMode: import_zod124.z.coerce.string(),
  id: import_zod124.z.coerce.string(),
  partyAttributes: import_zod124.z.any(),
  priority: import_zod124.z.coerce.number(),
  tempParty: import_zod124.z.coerce.string()
});
var StartMatchmakingResponse = import_zod124.z.object({
  type: import_zod124.z.literal("startMatchmakingResponse"),
  code: import_zod124.z.coerce.number(),
  id: import_zod124.z.coerce.string()
});
var UnblockPlayerNotif = import_zod124.z.object({
  type: import_zod124.z.literal("unblockPlayerNotif"),
  unblockedUserId: import_zod124.z.coerce.string(),
  userId: import_zod124.z.coerce.string()
});
var UnblockPlayerRequest2 = import_zod124.z.object({
  type: import_zod124.z.literal("unblockPlayerRequest"),
  id: import_zod124.z.coerce.string(),
  namespace: import_zod124.z.coerce.string(),
  unblockedUserId: import_zod124.z.coerce.string()
});
var UnblockPlayerResponse = import_zod124.z.object({
  type: import_zod124.z.literal("unblockPlayerResponse"),
  code: import_zod124.z.coerce.number(),
  id: import_zod124.z.coerce.string(),
  namespace: import_zod124.z.coerce.string(),
  unblockedUserId: import_zod124.z.coerce.string()
});
var UnfriendNotif = import_zod124.z.object({
  type: import_zod124.z.literal("unfriendNotif"),
  friendId: import_zod124.z.coerce.string()
});
var UnfriendRequest = import_zod124.z.object({
  type: import_zod124.z.literal("unfriendRequest"),
  friendId: import_zod124.z.coerce.string(),
  id: import_zod124.z.coerce.string()
});
var UnfriendResponse = import_zod124.z.object({
  type: import_zod124.z.literal("unfriendResponse"),
  code: import_zod124.z.coerce.number(),
  id: import_zod124.z.coerce.string()
});
var UserMetricRequest = import_zod124.z.object({
  type: import_zod124.z.literal("userMetricRequest"),
  id: import_zod124.z.coerce.string()
});
var UserMetricResponse = import_zod124.z.object({
  type: import_zod124.z.literal("userMetricResponse"),
  code: import_zod124.z.coerce.number(),
  id: import_zod124.z.coerce.string(),
  playerCount: import_zod124.z.coerce.number()
});
var UserStatusNotif = import_zod124.z.object({
  type: import_zod124.z.literal("userStatusNotif"),
  activity: import_zod124.z.coerce.string(),
  availability: import_zod124.z.coerce.number(),
  lastSeenAt: import_zod124.z.coerce.string(),
  userId: import_zod124.z.coerce.string()
});
var WebSocketRequest = import_zod124.z.discriminatedUnion("type", [
  AcceptFriendsRequest,
  BlockPlayerRequest2,
  CancelFriendsRequest,
  CancelMatchmakingRequest,
  ClientResetRequest,
  FriendsStatusRequest,
  GetAllSessionAttributeRequest,
  GetFriendshipStatusRequest,
  GetSessionAttributeRequest,
  JoinDefaultChannelRequest,
  ListIncomingFriendsRequest,
  ListOfFriendsRequest,
  ListOnlineFriendsRequest,
  ListOutgoingFriendsRequest,
  OfflineNotificationRequest,
  PartyChatRequest,
  PartyCreateRequest,
  PartyInfoRequest,
  PartyInviteRequest,
  PartyJoinRequest,
  PartyKickRequest,
  PartyLeaveRequest,
  PartyPromoteLeaderRequest,
  PartyRejectRequest,
  PersonalChatHistoryRequest,
  PersonalChatRequest,
  RefreshTokenRequest,
  RejectFriendsRequest,
  RequestFriendsRequest,
  SendChannelChatRequest,
  SetReadyConsentRequest,
  SetSessionAttributeRequest,
  SetUserStatusRequest,
  StartMatchmakingRequest,
  UnblockPlayerRequest2,
  UnfriendRequest,
  UserMetricRequest
]);
var WebSocketResponseOrNotification = import_zod124.z.discriminatedUnion("type", [
  AcceptFriendsNotif,
  AcceptFriendsResponse,
  BlockPlayerNotif,
  BlockPlayerResponse,
  CancelFriendsNotif,
  CancelFriendsResponse,
  CancelMatchmakingResponse,
  ChannelChatNotif,
  ConnectNotif,
  DisconnectNotif,
  DsNotif,
  ErrorNotif,
  FriendsStatusResponse,
  GetAllSessionAttributeResponse,
  GetFriendshipStatusResponse,
  GetSessionAttributeResponse,
  JoinDefaultChannelResponse,
  ListIncomingFriendsResponse,
  ListOfFriendsResponse,
  ListOutgoingFriendsResponse,
  MatchmakingNotif,
  MessageNotif,
  MessageSessionNotif,
  OfflineNotificationResponse,
  PartyChatNotif,
  PartyChatResponse,
  PartyCreateResponse,
  PartyDataUpdateNotif,
  PartyGetInvitedNotif,
  PartyInfoResponse,
  PartyInviteNotif,
  PartyInviteResponse,
  PartyJoinNotif,
  PartyJoinResponse,
  PartyKickNotif,
  PartyKickResponse,
  PartyLeaveNotif,
  PartyLeaveResponse,
  PartyPromoteLeaderResponse,
  PartyRejectNotif,
  PartyRejectResponse,
  PersonalChatHistoryResponse,
  PersonalChatNotif,
  PersonalChatResponse,
  RefreshTokenResponse,
  RejectFriendsNotif,
  RejectFriendsResponse,
  RematchmakingNotif,
  RequestFriendsNotif,
  RequestFriendsResponse,
  SendChannelChatResponse,
  SetReadyConsentNotif,
  SetReadyConsentResponse,
  SetSessionAttributeResponse,
  SetUserStatusResponse,
  ShutdownNotif,
  SignalingP2PNotif,
  StartMatchmakingResponse,
  UnblockPlayerNotif,
  UnblockPlayerResponse,
  UnfriendNotif,
  UnfriendResponse,
  UserMetricResponse,
  UserStatusNotif
]);

// src/generated-websocket/WebSocketClass.ts
var messageParser = (data) => {
  const toVal = (str) => {
    if (str) {
      if (str.startsWith("[") && str.endsWith("]")) {
        return str.slice(1, str.length - 1).split(",").filter((v) => v !== "");
      }
    }
    return str;
  };
  const entries = data.split("\n").filter((line) => line !== "").map((line) => {
    const [key, valStr] = line.split(": ");
    return [key, toVal(valStr)];
  });
  return Object.fromEntries(entries);
};
var messageSerializer = (data) => {
  return Object.keys(data).map((key) => {
    const toStr = (val2) => {
      if (Array.isArray(val2)) {
        return `[${String(val2)}]`;
      }
      if (!val2) {
        return "";
      }
      return String(val2);
    };
    const val = data[key];
    const valStr = toStr(val);
    return `${key}: ${valStr}`;
  }).join("\n");
};
function WebSocketClass(sdk, args) {
  const sdkAssembly = sdk.assembly();
  const baseURL = (args?.coreConfig?.baseURL ?? sdkAssembly.coreConfig.baseURL).replace("http", "ws");
  const path = "/lobby";
  const url = baseURL + path;
  let ws = null;
  let isDisconnectManually = false;
  const allowReconnect = sdkAssembly.webSocketConfig.allowReconnect ?? true;
  const maxReconnectAttempts = sdkAssembly.webSocketConfig.maxReconnectAttempts ?? 0;
  let reconnectAttempts = maxReconnectAttempts;
  const connect = () => {
    const token = sdk.getToken();
    if (!token.accessToken) {
      console.warn("No access token, please login first");
      return;
    }
    if (!ws) {
      ws = new WebSocket(url, token.accessToken);
    }
  };
  const refreshToken = async () => {
    const { refreshToken: refreshToken2 } = sdk.getToken();
    if (refreshToken2) {
      const refresh = new import_sdk35.RefreshToken({
        config: {
          axiosConfig: sdkAssembly.axiosConfig.request,
          clientId: sdkAssembly.coreConfig.clientId,
          refreshToken: refreshToken2
        }
      });
      const result = await refresh.runWithLock();
      if (result) {
        sdk.setToken({
          accessToken: result.access_token,
          refreshToken: result.refresh_token
        });
        return true;
      }
    }
    return false;
  };
  const handleReconnect = async (ev) => {
    if (!allowReconnect || isDisconnectManually || !sdk.getToken().accessToken) return;
    if (ev.code === 4020) {
      await refreshToken();
      reconnectAttempts--;
      connect();
    } else if (ev.code >= 1001 && ev.code <= 2999) {
      if (!ws || ws.readyState !== ws.OPEN) return;
      if (maxReconnectAttempts === 0) {
        setTimeout(() => {
          connect();
        }, 1e3);
      } else if (reconnectAttempts !== 0) {
        setTimeout(() => {
          reconnectAttempts--;
          connect();
        }, 1e3);
      }
    }
  };
  const disconnect = (code, reason) => {
    if (ws) {
      ws.close(code, reason);
      isDisconnectManually = true;
      ws = null;
    }
  };
  const send = (message) => {
    if (ws) {
      ws.send(messageSerializer(message));
    }
  };
  const sendRaw = (rawMessage) => {
    if (ws) {
      ws.send(rawMessage);
    }
  };
  const onOpen = (cb) => {
    if (ws) {
      let listener2 = function(_ev) {
        isDisconnectManually = false;
        reconnectAttempts = maxReconnectAttempts;
        cb();
      };
      var listener = listener2;
      ws.addEventListener("open", listener2);
      return {
        removeEventListener: () => ws?.removeEventListener("open", listener2)
      };
    }
    return {};
  };
  const onClose = (cb) => {
    if (ws) {
      let listener2 = function(ev) {
        handleReconnect(ev);
        cb(ev);
      };
      var listener = listener2;
      ws.addEventListener("close", listener2);
      return {
        removeEventListener: () => ws?.removeEventListener("close", listener2)
      };
    }
    return {};
  };
  const onMessage = (cb, raw = false) => {
    if (ws) {
      let listener2 = function(ev) {
        if (raw) {
          cb(ev.data);
        } else {
          const result = WebSocketResponseOrNotification.parse(messageParser(ev.data));
          cb(result);
        }
      };
      var listener = listener2;
      ws.addEventListener("message", listener2);
      return {
        removeEventListener: () => ws?.removeEventListener("message", listener2)
      };
    }
    return {};
  };
  const onError = (cb) => {
    if (ws) {
      let listener2 = function(err) {
        cb(err);
      };
      var listener = listener2;
      ws.addEventListener("error", listener2);
      return {
        removeEventListener: () => ws?.removeEventListener("error", listener2)
      };
    }
    return {};
  };
  const sendAcceptFriends = (data) => {
    send({ type: "acceptFriendsRequest", ...data });
  };
  const sendBlockPlayer = (data) => {
    send({ type: "blockPlayerRequest", ...data });
  };
  const sendCancelFriends = (data) => {
    send({ type: "cancelFriendsRequest", ...data });
  };
  const sendCancelMatchmaking = (data) => {
    send({ type: "cancelMatchmakingRequest", ...data });
  };
  const sendClientReset = (data) => {
    send({ type: "clientResetRequest", ...data });
  };
  const sendFriendsStatus = (data) => {
    send({ type: "friendsStatusRequest", ...data });
  };
  const sendGetAllSessionAttribute = (data) => {
    send({ type: "getAllSessionAttributeRequest", ...data });
  };
  const sendGetFriendshipStatus = (data) => {
    send({ type: "getFriendshipStatusRequest", ...data });
  };
  const sendGetSessionAttribute = (data) => {
    send({ type: "getSessionAttributeRequest", ...data });
  };
  const sendJoinDefaultChannel = (data) => {
    send({ type: "joinDefaultChannelRequest", ...data });
  };
  const sendListIncomingFriends = (data) => {
    send({ type: "listIncomingFriendsRequest", ...data });
  };
  const sendListOfFriends = (data) => {
    send({ type: "listOfFriendsRequest", ...data });
  };
  const sendListOnlineFriends = (data) => {
    send({ type: "listOnlineFriendsRequest", ...data });
  };
  const sendListOutgoingFriends = (data) => {
    send({ type: "listOutgoingFriendsRequest", ...data });
  };
  const sendOfflineNotification = (data) => {
    send({ type: "offlineNotificationRequest", ...data });
  };
  const sendPartyChat = (data) => {
    send({ type: "partyChatRequest", ...data });
  };
  const sendPartyCreate = (data) => {
    send({ type: "partyCreateRequest", ...data });
  };
  const sendPartyInfo = (data) => {
    send({ type: "partyInfoRequest", ...data });
  };
  const sendPartyInvite = (data) => {
    send({ type: "partyInviteRequest", ...data });
  };
  const sendPartyJoin = (data) => {
    send({ type: "partyJoinRequest", ...data });
  };
  const sendPartyKick = (data) => {
    send({ type: "partyKickRequest", ...data });
  };
  const sendPartyLeave = (data) => {
    send({ type: "partyLeaveRequest", ...data });
  };
  const sendPartyPromoteLeader = (data) => {
    send({ type: "partyPromoteLeaderRequest", ...data });
  };
  const sendPartyReject = (data) => {
    send({ type: "partyRejectRequest", ...data });
  };
  const sendPersonalChatHistory = (data) => {
    send({ type: "personalChatHistoryRequest", ...data });
  };
  const sendPersonalChat = (data) => {
    send({ type: "personalChatRequest", ...data });
  };
  const sendRefreshToken = (data) => {
    send({ type: "refreshTokenRequest", ...data });
  };
  const sendRejectFriends = (data) => {
    send({ type: "rejectFriendsRequest", ...data });
  };
  const sendRequestFriends = (data) => {
    send({ type: "requestFriendsRequest", ...data });
  };
  const sendSendChannelChat = (data) => {
    send({ type: "sendChannelChatRequest", ...data });
  };
  const sendSetReadyConsent = (data) => {
    send({ type: "setReadyConsentRequest", ...data });
  };
  const sendSetSessionAttribute = (data) => {
    send({ type: "setSessionAttributeRequest", ...data });
  };
  const sendSetUserStatus = (data) => {
    send({ type: "setUserStatusRequest", ...data });
  };
  const sendStartMatchmaking = (data) => {
    send({ type: "startMatchmakingRequest", ...data });
  };
  const sendUnblockPlayer = (data) => {
    send({ type: "unblockPlayerRequest", ...data });
  };
  const sendUnfriend = (data) => {
    send({ type: "unfriendRequest", ...data });
  };
  const sendUserMetric = (data) => {
    send({ type: "userMetricRequest", ...data });
  };
  return {
    instance: ws,
    connect,
    disconnect,
    send,
    sendRaw,
    onOpen,
    onClose,
    onMessage,
    onError,
    sendAcceptFriends,
    sendBlockPlayer,
    sendCancelFriends,
    sendCancelMatchmaking,
    sendClientReset,
    sendFriendsStatus,
    sendGetAllSessionAttribute,
    sendGetFriendshipStatus,
    sendGetSessionAttribute,
    sendJoinDefaultChannel,
    sendListIncomingFriends,
    sendListOfFriends,
    sendListOnlineFriends,
    sendListOutgoingFriends,
    sendOfflineNotification,
    sendPartyChat,
    sendPartyCreate,
    sendPartyInfo,
    sendPartyInvite,
    sendPartyJoin,
    sendPartyKick,
    sendPartyLeave,
    sendPartyPromoteLeader,
    sendPartyReject,
    sendPersonalChatHistory,
    sendPersonalChat,
    sendRefreshToken,
    sendRejectFriends,
    sendRequestFriends,
    sendSendChannelChat,
    sendSetReadyConsent,
    sendSetSessionAttribute,
    sendSetUserStatus,
    sendStartMatchmaking,
    sendUnblockPlayer,
    sendUnfriend,
    sendUserMetric
  };
}

// src/Lobby.ts
console.log(`${name}@${version}`);
var apis = {
  ConfigAdminApi,
  AdminAdminApi,
  PlayerAdminApi,
  ProfanityAdminApi,
  NotificationAdminApi,
  FriendsAdminApi,
  PartyAdminApi,
  ThirdPartyAdminApi,
  LobbyOperationsAdminApi,
  LobbyOperationsApi,
  FriendsApi,
  NotificationApi,
  BlocksApi,
  AdminApi,
  PlayerApi,
  PartyApi,
  PresenceApi,
  WebSocket: WebSocketClass,
  version: () => console.log({
    version,
    name,
    author
  })
};
var Lobby = apis;
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  Admin$,
  AdminAddProfanityFilterIntoListRequest,
  AdminAddProfanityFiltersFilterRequest,
  AdminAddProfanityFiltersRequest,
  AdminAdmin$,
  AdminAdminApi,
  AdminApi,
  AdminCreateProfanityListRequest,
  AdminDeleteProfanityFilterRequest,
  AdminGetProfanityListFiltersV1Response,
  AdminGetProfanityListsListResponse,
  AdminGetProfanityListsListResponseArray,
  AdminSetProfanityRuleForNamespaceRequest,
  AdminUpdateProfanityList,
  AdminVerifyMessageProfanityRequest,
  AdminVerifyMessageProfanityResponse,
  AppMessageDeclaration,
  AppMessageDeclarationArray,
  BlockPlayerRequest,
  BlockedByPlayerData,
  BlockedPlayerData,
  Blocks$,
  BlocksApi,
  BulkFriendsRequest,
  BulkFriendsResponse,
  BulkUsersFreeFormNotificationRequestV1,
  Config,
  ConfigAdmin$,
  ConfigAdminApi,
  ConfigList,
  ConfigReq,
  Configuration,
  CreateConfigRequest,
  CreateConfigResponse,
  CreateTemplateRequest,
  CreateTopicRequest,
  CreateTopicRequestV1,
  DebugProfanityFilterRequest,
  Error,
  ErrorResponseBody,
  ErrorResponseV1,
  FreeFormNotificationRequest,
  FreeFormNotificationRequestV1,
  FriendWithPlatform,
  Friends$,
  FriendsAdmin$,
  FriendsAdminApi,
  FriendsApi,
  FriendshipConnection,
  FriendshipConnectionResponse,
  GetAllNotificationTemplateSlugResp,
  GetAllNotificationTopicsResponse,
  GetAllPlayerBlockedByUsersResponse,
  GetAllPlayerBlockedUsersResponse,
  GetAllPlayerSessionAttributeResponse,
  GetBulkAllPlayerBlockedUsersRequest,
  GetBulkAllPlayerBlockedUsersResponse,
  GetConfigResponse,
  GetFriendsResponse,
  GetLobbyCcuResponse,
  GetPlayerSessionAttributeResponse,
  GetUserFriendsResponse,
  GetUserFriendsResponseArray,
  GetUserIncomingFriendsResponse,
  GetUserIncomingFriendsResponseArray,
  GetUserOutgoingFriendsResponse,
  GetUserOutgoingFriendsResponseArray,
  GetUsersPresenceResponse,
  GlobalConfiguration,
  ImportConfigResponse,
  IncomingFriendsWithTimeData,
  ListBlockedPlayerRequest,
  ListBulkUserPlatformsResponse,
  ListUnblockPlayerRequest,
  LoadIncomingFriendsWithTimeResponse,
  LoadIncomingFriendsWithTimeResponseArray,
  LoadOutgoingFriendsWithTimeResponse,
  LoadOutgoingFriendsWithTimeResponseArray,
  Lobby,
  LobbyOperations$,
  LobbyOperationsAdmin$,
  LobbyOperationsAdminApi,
  LobbyOperationsApi,
  Localization,
  NativeFriendRequest,
  NativeFriendSyncResponse,
  NativeFriendSyncResponseArray,
  NativeUserBlockRequest,
  NativeUserBlockResponse,
  NativeUserBlockResponseArray,
  Notification$,
  NotificationAdmin$,
  NotificationAdminApi,
  NotificationApi,
  NotificationResponse,
  NotificationTemplateResponse,
  NotificationTemplateResponseArray,
  NotificationTopicResponse,
  NotificationTopicResponseV1,
  NotificationWithTemplateRequest,
  NotificationWithTemplateRequestV1,
  OutgoingFriendsWithTimeData,
  Pagination,
  Party$,
  PartyAdmin$,
  PartyAdminApi,
  PartyApi,
  PartyData,
  PartyPutCustomAttributesRequest,
  PartyPutLimitSizeRequest,
  Player$,
  PlayerAdmin$,
  PlayerAdminApi,
  PlayerApi,
  Presence$,
  PresenceApi,
  ProfanityAdmin$,
  ProfanityAdminApi,
  ProfanityFilter,
  ProfanityFilterArray,
  ProfanityRule,
  PutGlobalConfigurationRequest,
  RequestUserPresence,
  SetPlayerSessionAttributeRequest,
  TemplateContent,
  TemplateLocalization,
  TemplateLocalizationResponse,
  TemplateResponse,
  TemplateResponseArray,
  ThirdPartyAdmin$,
  ThirdPartyAdminApi,
  TopicByNamespacesResponse,
  UnblockPlayerRequest,
  UpdateConfigRequest,
  UpdateConfigResponse,
  UpdateTemplateRequest,
  UpdateTopicRequest,
  UserAcceptFriendRequest,
  UserCancelFriendRequest,
  UserGetFriendshipStatusResponse,
  UserPlatformInfo,
  UserPresence,
  UserRejectFriendRequest,
  UserRequestFriendRequest,
  UserUnfriendRequest,
  UserWithPlatformInfo
});

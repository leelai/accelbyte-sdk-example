import { AccelByteSDK, SdkSetConfigParam, Response } from '@accelbyte/sdk';
import { AxiosResponse, AxiosInstance } from 'axios';
import { G as GlobalConfiguration, P as PutGlobalConfigurationRequest, C as ConfigList, a as Configuration, b as ConfigReq, I as ImportConfigResponse, c as GetFriendsResponse, L as LoadIncomingFriendsWithTimeResponse, d as LoadOutgoingFriendsWithTimeResponse, F as FriendshipConnectionResponse, e as PartyPutCustomAttributesRequest, f as PartyData, g as GetAllNotificationTopicsResponse, h as CreateTopicRequestV1, N as NotificationTemplateResponseArray, i as CreateTemplateRequest, j as FreeFormNotificationRequestV1, k as NotificationWithTemplateRequestV1, l as NotificationTopicResponseV1, U as UpdateTopicRequest, m as GetAllNotificationTemplateSlugResp, B as BulkUsersFreeFormNotificationRequestV1, n as Localization, o as UpdateTemplateRequest, p as GetLobbyCcuResponse, q as GetBulkAllPlayerBlockedUsersRequest, r as GetBulkAllPlayerBlockedUsersResponse, s as GetAllPlayerBlockedUsersResponse, t as GetAllPlayerSessionAttributeResponse, S as SetPlayerSessionAttributeRequest, u as GetAllPlayerBlockedByUsersResponse, v as ListBlockedPlayerRequest, w as ListUnblockPlayerRequest, x as GetPlayerSessionAttributeResponse, y as ProfanityRule, A as AdminSetProfanityRuleForNamespaceRequest, z as AdminGetProfanityListsListResponseArray, D as AdminCreateProfanityListRequest, E as AdminVerifyMessageProfanityRequest, H as AdminVerifyMessageProfanityResponse, J as AdminUpdateProfanityList, K as DebugProfanityFilterRequest, M as ProfanityFilterArray, O as AdminGetProfanityListFiltersV1Response, Q as AdminAddProfanityFilterIntoListRequest, R as AdminAddProfanityFiltersRequest, T as AdminDeleteProfanityFilterRequest, V as GetConfigResponse, W as CreateConfigRequest, X as CreateConfigResponse, Y as UpdateConfigRequest, Z as UpdateConfigResponse, _ as FreeFormNotificationRequest, $ as NotificationWithTemplateRequest, a0 as TemplateResponseArray, a1 as TemplateLocalizationResponse, a2 as TemplateLocalization, a3 as NativeUserBlockRequest, a4 as NativeUserBlockResponseArray, a5 as GetUserFriendsResponseArray, a6 as NativeFriendRequest, a7 as NativeFriendSyncResponseArray, a8 as UserRequestFriendRequest, a9 as GetUserIncomingFriendsResponseArray, aa as GetUserOutgoingFriendsResponseArray, ab as UserUnfriendRequest, ac as ListBulkUserPlatformsResponse, ad as LoadIncomingFriendsWithTimeResponseArray, ae as LoadOutgoingFriendsWithTimeResponseArray, af as UserAcceptFriendRequest, ag as UserCancelFriendRequest, ah as UserRejectFriendRequest, ai as UserGetFriendshipStatusResponse, aj as BulkFriendsRequest, ak as BulkFriendsResponse, al as AppMessageDeclarationArray, am as NotificationResponse, an as TopicByNamespacesResponse, ao as CreateTopicRequest, ap as NotificationTopicResponse, aq as PartyPutLimitSizeRequest, ar as BlockPlayerRequest$1, as as UnblockPlayerRequest$1, at as GetUsersPresenceResponse, au as RequestUserPresence } from './UserUnfriendRequest-BvcwS4X_.js';
import { z } from 'zod';

/**
 * AUTO GENERATED
 */

declare function AdminAdminApi(sdk: AccelByteSDK, args?: SdkSetConfigParam): {
    /**
     * Delete of global configuration data.
     */
    deleteGlobalConfiguration: () => Promise<AxiosResponse<unknown>>;
    /**
     * Get dsmc global configuration.
     */
    getGlobalConfigurations: () => Promise<AxiosResponse<GlobalConfiguration>>;
    /**
     * Upsert global configuration data.
     */
    updateGlobalConfiguration: (data: PutGlobalConfigurationRequest) => Promise<AxiosResponse<GlobalConfiguration>>;
};

/**
 * AUTO GENERATED
 */

declare function ConfigAdminApi(sdk: AccelByteSDK, args?: SdkSetConfigParam): {
    /**
     * Get lobby config of all namespaces.&lt;br&gt;default MaxDSWaitTime is 120 (second)
     */
    getConfig: () => Promise<AxiosResponse<ConfigList>>;
    /**
     *  Get Log Configuration logLevel use for logging in service, the value can use is trace|debug|info|warning|error|fatal|panic socketLogEnabled is use for enable socket log logLevelDB use for logging in DB, the value can use is trace|debug|info|warning|error|fatal|panic slowQueryThreshold use for logging slow threshold in time measure is nano second
     */
    getConfigLog: () => Promise<AxiosResponse<Configuration>>;
    /**
     *  Update Log Configuration logLevel use for logging in service, the value can use is trace|debug|info|warning|error|fatal|panic socketLogEnabled is use for enable socket log logLevelDB use for logging in DB, the value can use is trace|debug|info|warning|error|fatal|panic slowQueryThreshold use for logging slow threshold in time measure is nano second
     */
    patchConfigLog: (data: Configuration) => Promise<AxiosResponse<Configuration>>;
    /**
     * Get lobby config of a namespace.&lt;br&gt;default MaxDSWaitTime is 120 (second)
     */
    getConfig_ByNamespace: () => Promise<AxiosResponse<ConfigReq>>;
    /**
     * Update lobby config of a namespace.&lt;br&gt;MaxDSWaitTime value is cannot less than 1, if null it will use default value in 120 (second)
     */
    updateConfig_ByNamespace: (data: ConfigReq) => Promise<AxiosResponse<ConfigReq>>;
    /**
     *  Export lobby configuration to a json file. The file can then be imported from the /import endpoint. JSON Schema of the exported file: { &#34;required&#34;: [ &#34;namespace&#34;, &#34;entitlementItemID&#34;, &#34;chatRateLimitDuration&#34;, &#34;unregisterDelay&#34;, &#34;generalRateLimitDuration&#34;, &#34;autoKickOnDisconnectDelay&#34;, &#34;chatRateLimitBurst&#34;, &#34;generalRateLimitBurst&#34;, &#34;maxPartyMember&#34;, &#34;autoKickOnDisconnect&#34;, &#34;profanityFilter&#34;, &#34;enableChat&#34;, &#34;entitlementCheck&#34;, &#34;cancelTicketOnDisconnect&#34;, &#34;concurrentUsersLimit&#34;, &#34;readyConsentTimeout&#34;, &#34;disableInvitationOnJoinParty&#34;, &#34;allowJoinPartyDuringMatchmaking&#34;, &#34;allowInviteNonConnectedUser&#34;, &#34;keepPresenceActivityOnDisconnect&#34;, &#34;maxDSWaitTime&#34;, &#34;maxFriendsLimit&#34; ], &#34;properties&#34;: { &#34;allowInviteNonConnectedUser&#34;: { &#34;type&#34;: &#34;boolean&#34; }, &#34;allowJoinPartyDuringMatchmaking&#34;: { &#34;type&#34;: &#34;boolean&#34; }, &#34;autoKickOnDisconnect&#34;: { &#34;type&#34;: &#34;boolean&#34; }, &#34;autoKickOnDisconnectDelay&#34;: { &#34;type&#34;: &#34;integer&#34;, &#34;format&#34;: &#34;int64&#34; }, &#34;cancelTicketOnDisconnect&#34;: { &#34;type&#34;: &#34;boolean&#34; }, &#34;chatRateLimitBurst&#34;: { &#34;type&#34;: &#34;integer&#34;, &#34;format&#34;: &#34;int32&#34; }, &#34;chatRateLimitDuration&#34;: { &#34;type&#34;: &#34;integer&#34;, &#34;format&#34;: &#34;int64&#34; }, &#34;concurrentUsersLimit&#34;: { &#34;type&#34;: &#34;integer&#34;, &#34;format&#34;: &#34;int32&#34; }, &#34;disableInvitationOnJoinParty&#34;: { &#34;type&#34;: &#34;boolean&#34; }, &#34;enableChat&#34;: { &#34;type&#34;: &#34;boolean&#34; }, &#34;entitlementCheck&#34;: { &#34;type&#34;: &#34;boolean&#34; }, &#34;entitlementItemID&#34;: { &#34;type&#34;: &#34;string&#34; }, &#34;generalRateLimitBurst&#34;: { &#34;type&#34;: &#34;integer&#34;, &#34;format&#34;: &#34;int32&#34; }, &#34;generalRateLimitDuration&#34;: { &#34;type&#34;: &#34;integer&#34;, &#34;format&#34;: &#34;int64&#34; }, &#34;keepPresenceActivityOnDisconnect&#34;: { &#34;type&#34;: &#34;boolean&#34; }, &#34;maxDSWaitTime&#34;: { &#34;type&#34;: &#34;integer&#34;, &#34;format&#34;: &#34;int64&#34; }, &#34;maxFriendsLimit&#34;: { &#34;type&#34;: &#34;integer&#34;, &#34;format&#34;: &#34;int32&#34; }, &#34;maxPartyMember&#34;: { &#34;type&#34;: &#34;integer&#34;, &#34;format&#34;: &#34;int32&#34; }, &#34;namespace&#34;: { &#34;type&#34;: &#34;string&#34; }, &#34;profanityFilter&#34;: { &#34;type&#34;: &#34;boolean&#34; }, &#34;readyConsentTimeout&#34;: { &#34;type&#34;: &#34;integer&#34;, &#34;format&#34;: &#34;int64&#34; }, &#34;unregisterDelay&#34;: { &#34;type&#34;: &#34;integer&#34;, &#34;format&#34;: &#34;int64&#34; } } }
     */
    getConfigExport: () => Promise<AxiosResponse<unknown>>;
    /**
     *  Import config configuration from file. The existing configuration will be replaced. The json file to import can be obtained from the /export endpoint. MaxDSWaitTime value is cannot less than 1, if null it will use default value in 120 (second)
     */
    updateConfigImport: (data: {
        file?: File;
    }) => Promise<AxiosResponse<ImportConfigResponse>>;
};

/**
 * AUTO GENERATED
 */

declare class AdminAdmin$ {
    private axiosInstance;
    private namespace;
    private useSchemaValidation;
    constructor(axiosInstance: AxiosInstance, namespace: string, useSchemaValidation?: boolean);
    /**
     * Delete of global configuration data.
     */
    deleteGlobalConfiguration(): Promise<Response<unknown>>;
    /**
     * Get dsmc global configuration.
     */
    getGlobalConfigurations(): Promise<Response<GlobalConfiguration>>;
    /**
     * Upsert global configuration data.
     */
    updateGlobalConfiguration(data: PutGlobalConfigurationRequest): Promise<Response<GlobalConfiguration>>;
}

/**
 * AUTO GENERATED
 */

declare class ConfigAdmin$ {
    private axiosInstance;
    private namespace;
    private useSchemaValidation;
    constructor(axiosInstance: AxiosInstance, namespace: string, useSchemaValidation?: boolean);
    /**
     * Get lobby config of all namespaces.&lt;br&gt;default MaxDSWaitTime is 120 (second)
     */
    getConfig(): Promise<Response<ConfigList>>;
    /**
     *  Get Log Configuration logLevel use for logging in service, the value can use is trace|debug|info|warning|error|fatal|panic socketLogEnabled is use for enable socket log logLevelDB use for logging in DB, the value can use is trace|debug|info|warning|error|fatal|panic slowQueryThreshold use for logging slow threshold in time measure is nano second
     */
    getConfigLog(): Promise<Response<Configuration>>;
    /**
     *  Update Log Configuration logLevel use for logging in service, the value can use is trace|debug|info|warning|error|fatal|panic socketLogEnabled is use for enable socket log logLevelDB use for logging in DB, the value can use is trace|debug|info|warning|error|fatal|panic slowQueryThreshold use for logging slow threshold in time measure is nano second
     */
    patchConfigLog(data: Configuration): Promise<Response<Configuration>>;
    /**
     * Get lobby config of a namespace.&lt;br&gt;default MaxDSWaitTime is 120 (second)
     */
    getConfig_ByNamespace(): Promise<Response<ConfigReq>>;
    /**
     * Update lobby config of a namespace.&lt;br&gt;MaxDSWaitTime value is cannot less than 1, if null it will use default value in 120 (second)
     */
    updateConfig_ByNamespace(data: ConfigReq): Promise<Response<ConfigReq>>;
    /**
     *  Export lobby configuration to a json file. The file can then be imported from the /import endpoint. JSON Schema of the exported file: { &#34;required&#34;: [ &#34;namespace&#34;, &#34;entitlementItemID&#34;, &#34;chatRateLimitDuration&#34;, &#34;unregisterDelay&#34;, &#34;generalRateLimitDuration&#34;, &#34;autoKickOnDisconnectDelay&#34;, &#34;chatRateLimitBurst&#34;, &#34;generalRateLimitBurst&#34;, &#34;maxPartyMember&#34;, &#34;autoKickOnDisconnect&#34;, &#34;profanityFilter&#34;, &#34;enableChat&#34;, &#34;entitlementCheck&#34;, &#34;cancelTicketOnDisconnect&#34;, &#34;concurrentUsersLimit&#34;, &#34;readyConsentTimeout&#34;, &#34;disableInvitationOnJoinParty&#34;, &#34;allowJoinPartyDuringMatchmaking&#34;, &#34;allowInviteNonConnectedUser&#34;, &#34;keepPresenceActivityOnDisconnect&#34;, &#34;maxDSWaitTime&#34;, &#34;maxFriendsLimit&#34; ], &#34;properties&#34;: { &#34;allowInviteNonConnectedUser&#34;: { &#34;type&#34;: &#34;boolean&#34; }, &#34;allowJoinPartyDuringMatchmaking&#34;: { &#34;type&#34;: &#34;boolean&#34; }, &#34;autoKickOnDisconnect&#34;: { &#34;type&#34;: &#34;boolean&#34; }, &#34;autoKickOnDisconnectDelay&#34;: { &#34;type&#34;: &#34;integer&#34;, &#34;format&#34;: &#34;int64&#34; }, &#34;cancelTicketOnDisconnect&#34;: { &#34;type&#34;: &#34;boolean&#34; }, &#34;chatRateLimitBurst&#34;: { &#34;type&#34;: &#34;integer&#34;, &#34;format&#34;: &#34;int32&#34; }, &#34;chatRateLimitDuration&#34;: { &#34;type&#34;: &#34;integer&#34;, &#34;format&#34;: &#34;int64&#34; }, &#34;concurrentUsersLimit&#34;: { &#34;type&#34;: &#34;integer&#34;, &#34;format&#34;: &#34;int32&#34; }, &#34;disableInvitationOnJoinParty&#34;: { &#34;type&#34;: &#34;boolean&#34; }, &#34;enableChat&#34;: { &#34;type&#34;: &#34;boolean&#34; }, &#34;entitlementCheck&#34;: { &#34;type&#34;: &#34;boolean&#34; }, &#34;entitlementItemID&#34;: { &#34;type&#34;: &#34;string&#34; }, &#34;generalRateLimitBurst&#34;: { &#34;type&#34;: &#34;integer&#34;, &#34;format&#34;: &#34;int32&#34; }, &#34;generalRateLimitDuration&#34;: { &#34;type&#34;: &#34;integer&#34;, &#34;format&#34;: &#34;int64&#34; }, &#34;keepPresenceActivityOnDisconnect&#34;: { &#34;type&#34;: &#34;boolean&#34; }, &#34;maxDSWaitTime&#34;: { &#34;type&#34;: &#34;integer&#34;, &#34;format&#34;: &#34;int64&#34; }, &#34;maxFriendsLimit&#34;: { &#34;type&#34;: &#34;integer&#34;, &#34;format&#34;: &#34;int32&#34; }, &#34;maxPartyMember&#34;: { &#34;type&#34;: &#34;integer&#34;, &#34;format&#34;: &#34;int32&#34; }, &#34;namespace&#34;: { &#34;type&#34;: &#34;string&#34; }, &#34;profanityFilter&#34;: { &#34;type&#34;: &#34;boolean&#34; }, &#34;readyConsentTimeout&#34;: { &#34;type&#34;: &#34;integer&#34;, &#34;format&#34;: &#34;int64&#34; }, &#34;unregisterDelay&#34;: { &#34;type&#34;: &#34;integer&#34;, &#34;format&#34;: &#34;int64&#34; } } }
     */
    getConfigExport(): Promise<Response<unknown>>;
    /**
     *  Import config configuration from file. The existing configuration will be replaced. The json file to import can be obtained from the /export endpoint. MaxDSWaitTime value is cannot less than 1, if null it will use default value in 120 (second)
     */
    updateConfigImport(data: {
        file?: File;
    }): Promise<Response<ImportConfigResponse>>;
}

/**
 * AUTO GENERATED
 */

declare class FriendsAdmin$ {
    private axiosInstance;
    private namespace;
    private useSchemaValidation;
    constructor(axiosInstance: AxiosInstance, namespace: string, useSchemaValidation?: boolean);
    /**
     * Get list of friends in a namespace.
     */
    getFriendUser_ByUserId(userId: string, queryParams?: {
        friendId?: string | null;
        friendIds?: string[];
        limit?: number;
        offset?: number;
    }): Promise<Response<GetFriendsResponse>>;
    /**
     * Get list of incoming friend requests.
     */
    getIncomingFriend_ByUserId(userId: string, queryParams?: {
        friendId?: string | null;
        limit?: number;
        offset?: number;
    }): Promise<Response<LoadIncomingFriendsWithTimeResponse>>;
    /**
     * Get list of outgoing friend requests in a namespace.
     */
    getOutgoingFriend_ByUserId(userId: string, queryParams?: {
        limit?: number;
        offset?: number;
    }): Promise<Response<LoadOutgoingFriendsWithTimeResponse>>;
    /**
     * Load list friends and friends of friends in a namespace. Response subjectId will be different with requested userId if the user is not directly friend
     */
    getOfFriends_ByUserId(userId: string, queryParams?: {
        friendId?: string | null;
        limit?: number;
        nopaging?: boolean | null;
        offset?: number;
    }): Promise<Response<FriendshipConnectionResponse>>;
}

/**
 * AUTO GENERATED
 */

declare class LobbyOperationsAdmin$ {
    private axiosInstance;
    private namespace;
    private useSchemaValidation;
    constructor(axiosInstance: AxiosInstance, namespace: string, useSchemaValidation?: boolean);
    /**
     * Update party attributes in a namespace.
     */
    updateAttributeParty_ByPartyId(partyId: string, data: PartyPutCustomAttributesRequest): Promise<Response<PartyData>>;
    /**
     * Admin join a player into a party.
     */
    updateJoinParty_ByPartyId_ByUserId(partyId: string, userId: string): Promise<Response<unknown>>;
}

/**
 * AUTO GENERATED
 */

declare class NotificationAdmin$ {
    private axiosInstance;
    private namespace;
    private useSchemaValidation;
    constructor(axiosInstance: AxiosInstance, namespace: string, useSchemaValidation?: boolean);
    /**
     * Get topic by namespace.&lt;br/&gt; Action Code: 50213
     */
    getNotificationTopics(queryParams?: {
        after?: string | null;
        before?: string | null;
        limit?: number;
    }): Promise<Response<GetAllNotificationTopicsResponse>>;
    /**
     * Create new notification topic. &lt;br&gt;topic should be alphabets, no special char except underscore, uppercase and no spacing. for example: TOPIC_TEST. Already existing topic can not be created&lt;br/&gt; Action Code: 50214
     */
    createNotificationTopic(data: CreateTopicRequestV1): Promise<Response<unknown>>;
    /**
     * Get all templates in a namespace&lt;br&gt; Action Code: 50203
     */
    getNotificationTemplates(): Promise<Response<NotificationTemplateResponseArray>>;
    /**
     * Create new notification template. Include handlebars {{key}} for replaceable contexts. The key inside handlebars will be the key to be replaced when sending notification. Already existing template with the same slug and language can not be created. &lt;br&gt;Check model description for detailed input restrictions.&lt;br&gt; Action Code: 50204
     */
    createNotificationTemplate(data: CreateTemplateRequest): Promise<Response<unknown>>;
    /**
     * Sends notification to all connected users in a namespace.&lt;br&gt; Action Code: 50201
     */
    createNotificationFreeformNotify(data: FreeFormNotificationRequestV1): Promise<Response<unknown>>;
    /**
     * Sends notification to all connected users in a namespace with predefined template. &lt;br&gt;In the request body, specify which template slug (template identifier) to use and the template language. &lt;br&gt;NotificationTemplate context is the key-value pair defining the value of each handlebar specified in the template content. Template need to be published before it can be use to send notifications&lt;br/&gt; Action Code: 50202
     */
    createNotificationTemplateNotify(data: NotificationWithTemplateRequestV1): Promise<Response<unknown>>;
    /**
     * Delete topic information by topic name. &lt;br&gt;topic should be alphabets, no special char except underscore, uppercase and no spacing. for example: TOPIC_TEST. Already existing topic can not be created &lt;br/&gt; Action Code: 50217
     */
    deleteNotificationTopic_ByTopicName(topicName: string): Promise<Response<unknown>>;
    /**
     * Get topic information by topic name.&lt;br/&gt; Action Code: 50215
     */
    getNotificationTopic_ByTopicName(topicName: string): Promise<Response<NotificationTopicResponseV1>>;
    /**
     * Update topic information by topic name. &lt;br&gt;topic should be alphabets, no special char except underscore, uppercase and no spacing. for example: TOPIC_TEST. Already existing topic can not be created &lt;br/&gt; Action Code: 50216
     */
    updateNotificationTopic_ByTopicName(topicName: string, data: UpdateTopicRequest): Promise<Response<unknown>>;
    /**
     * Delete template slug in notification template&lt;br&gt; Action Code: 50206
     */
    deleteNotificationTemplate_ByTemplateSlug(templateSlug: string): Promise<Response<unknown>>;
    /**
     * Get all templates in a namespace&lt;br&gt; Action Code: 50205
     */
    getNotificationTemplate_ByTemplateSlug(templateSlug: string, queryParams?: {
        after?: string | null;
        before?: string | null;
        limit?: number;
    }): Promise<Response<GetAllNotificationTemplateSlugResp>>;
    /**
     * Sends notification to multiple user. Action Code: 50211
     */
    createNotificationBulkUserFreeformNotify(data: BulkUsersFreeFormNotificationRequestV1): Promise<Response<unknown>>;
    /**
     * Sends notification to a user. Action Code: 50211
     */
    createFreeformNotifyNotification_ByUserId(userId: string, data: FreeFormNotificationRequestV1): Promise<Response<unknown>>;
    /**
     * Sends templated notification to a user. &lt;br&gt;In the request body, specify which template slug (template identifier) to use and the template language. &lt;br&gt;NotificationTemplate context is the key-value pair defining the value of each handlebar specified in the template content. Template need to be published before it can be use to send notifications&lt;br&gt; Action Code: 50212
     */
    createTemplateNotifyNotification_ByUserId(userId: string, data: NotificationWithTemplateRequestV1): Promise<Response<unknown>>;
    /**
     * Sends notification to a party.
     */
    createFreeformNotifyNotification_ByPartyId(partyId: string, data: FreeFormNotificationRequestV1): Promise<Response<unknown>>;
    /**
     * Sends templated notification to a party. &lt;br&gt;In the request body, specify which template slug (template identifier) to use and the template language. &lt;br&gt;NotificationTemplate context is the key-value pair defining the value of each handlebar specified in the template content. Template need to be published before it can be use to send notifications&lt;br&gt;
     */
    createTemplateNotifyNotification_ByPartyId(partyId: string, data: NotificationWithTemplateRequestV1): Promise<Response<unknown>>;
    /**
     * Delete template localization&lt;br/&gt; Action Code: 50209
     */
    deleteLanguageNotification_ByTemplateSlug_ByTemplateLanguage(templateSlug: string, templateLanguage: string): Promise<Response<unknown>>;
    /**
     * Get a template localization&lt;br/&gt; Action Code: 50207
     */
    getLanguageNotification_ByTemplateSlug_ByTemplateLanguage(templateSlug: string, templateLanguage: string): Promise<Response<Localization>>;
    /**
     * Update template localization&lt;br/&gt; Action Code: 50208
     */
    updateLanguageNotification_ByTemplateSlug_ByTemplateLanguage(templateSlug: string, templateLanguage: string, data: UpdateTemplateRequest): Promise<Response<unknown>>;
    /**
     * Publish notification template draft. Empty draft can not be published.&lt;br/&gt; Action Code: 50210
     */
    createPublishNotification_ByTemplateSlug_ByTemplateLanguage(templateSlug: string, templateLanguage: string): Promise<Response<unknown>>;
}

/**
 * AUTO GENERATED
 */

declare class PartyAdmin$ {
    private axiosInstance;
    private namespace;
    private useSchemaValidation;
    constructor(axiosInstance: AxiosInstance, namespace: string, useSchemaValidation?: boolean);
    /**
     * Get party data in a namespace.
     */
    getPartyParty_ByPartyId(partyId: string): Promise<Response<PartyData>>;
    /**
     * Get party data in a namespace.
     */
    getParty_ByUserId(userId: string): Promise<Response<PartyData>>;
}

/**
 * AUTO GENERATED
 */

declare class PlayerAdmin$ {
    private axiosInstance;
    private namespace;
    private useSchemaValidation;
    constructor(axiosInstance: AxiosInstance, namespace: string, useSchemaValidation?: boolean);
    /**
     * Get the number of players connected to the Lobby in the given namespace.
     */
    getPlayerCcu(): Promise<Response<GetLobbyCcuResponse>>;
    /**
     * Get blocked players data by bulk user ids in a namespace.
     */
    fetchPlayerUserBulkBlocked(data: GetBulkAllPlayerBlockedUsersRequest): Promise<Response<GetBulkAllPlayerBlockedUsersResponse>>;
    /**
     * Get blocked players data by user id in a namespace.
     */
    getBlockedPlayer_ByUserId(userId: string): Promise<Response<GetAllPlayerBlockedUsersResponse>>;
    /**
     * Get all player&#39;s session attribute by user id in a namespace.
     */
    getAttributesPlayer_ByUserId(userId: string): Promise<Response<GetAllPlayerSessionAttributeResponse>>;
    /**
     * Set player&#39;s session attribute by user id in a namespace.
     */
    updateAttributePlayer_ByUserId(userId: string, data: SetPlayerSessionAttributeRequest): Promise<Response<unknown>>;
    /**
     * Load get players who blocked this player in a namespace based on user id
     */
    getBlockedByPlayer_ByUserId(userId: string): Promise<Response<GetAllPlayerBlockedByUsersResponse>>;
    /**
     * Bulk block player in a namespace by list of user id
     */
    createBulkBlockPlayer_ByUserId(userId: string, data: ListBlockedPlayerRequest): Promise<Response<unknown>>;
    /**
     * Bulk unblock player in a namespace by list of user id
     */
    deleteBulkUnblockPlayer_ByUserId(userId: string, data: ListUnblockPlayerRequest): Promise<Response<unknown>>;
    /**
     * Get player&#39;s specific session attribute by user id in a namespace.
     */
    getAttributePlayer_ByUserId_ByAttribute(userId: string, attribute: string): Promise<Response<GetPlayerSessionAttributeResponse>>;
}

/**
 * AUTO GENERATED
 */

declare class ProfanityAdmin$ {
    private axiosInstance;
    private namespace;
    private useSchemaValidation;
    constructor(axiosInstance: AxiosInstance, namespace: string, useSchemaValidation?: boolean);
    /**
     * Get current profanity rule
     */
    getProfanityRule(): Promise<Response<ProfanityRule>>;
    /**
     * Set current profanity rule
     */
    updateProfanityRule(data: AdminSetProfanityRuleForNamespaceRequest): Promise<Response<unknown>>;
    /**
     * Get lists
     */
    getProfanityLists(): Promise<Response<AdminGetProfanityListsListResponseArray>>;
    /**
     * Create a new list
     */
    createProfanityList(data: AdminCreateProfanityListRequest): Promise<Response<unknown>>;
    /**
     * Verify a message directly from the UI or other services
     */
    fetchProfanityVerify(data: AdminVerifyMessageProfanityRequest): Promise<Response<AdminVerifyMessageProfanityResponse>>;
    /**
     * Delete a list include all filters inside of it
     */
    deleteProfanityList_ByList(list: string): Promise<Response<unknown>>;
    /**
     * Update the list
     */
    updateProfanityList_ByList(list: string, data: AdminUpdateProfanityList): Promise<Response<unknown>>;
    /**
     * Get the list of filters that would modify the phrase
     */
    fetchProfanityFilterDebug(data: DebugProfanityFilterRequest): Promise<Response<ProfanityFilterArray>>;
    /**
     * Get the list of filters inside the list.
     */
    getFiltersProfanity_ByList(list: string): Promise<Response<AdminGetProfanityListFiltersV1Response>>;
    /**
     * Add a single filter into the list
     */
    createFilterProfanity_ByList(list: string, data: AdminAddProfanityFilterIntoListRequest): Promise<Response<unknown>>;
    /**
     * Add multiple filters into the list
     */
    createFilterBulkProfanity_ByList(list: string, data: AdminAddProfanityFiltersRequest): Promise<Response<unknown>>;
    /**
     * Delete the filter from the list
     */
    createFilterDeleteProfanity_ByList(list: string, data: AdminDeleteProfanityFilterRequest): Promise<Response<ProfanityFilterArray>>;
    /**
     * Import a file with filters
     */
    createFilterBulkFileProfanity_ByList(list: string, data: number[]): Promise<Response<unknown>>;
}

/**
 * AUTO GENERATED
 */

declare class ThirdPartyAdmin$ {
    private axiosInstance;
    private namespace;
    private useSchemaValidation;
    constructor(axiosInstance: AxiosInstance, namespace: string, useSchemaValidation?: boolean);
    /**
     * Required permission : &lt;code&gt;ADMIN:NAMESPACE:{namespace}:THIRDPARTY:CONFIG [DELETE]&lt;/code&gt; with scope &lt;code&gt;social&lt;/code&gt; &lt;br&gt;delete third party config in a namespace.
     */
    deleteThirdpartyConfigSteam(): Promise<Response<unknown>>;
    /**
     * Get third party config for specified namespace.
     */
    getThirdpartyConfigSteam(): Promise<Response<GetConfigResponse>>;
    /**
     * Create third party config in a namespace.
     */
    createThirdpartyConfigSteam(data: CreateConfigRequest): Promise<Response<CreateConfigResponse>>;
    /**
     * Update third party config in a namespace.
     */
    updateThirdpartyConfigSteam(data: UpdateConfigRequest): Promise<Response<UpdateConfigResponse>>;
}

/**
 * AUTO GENERATED
 */

declare function FriendsAdminApi(sdk: AccelByteSDK, args?: SdkSetConfigParam): {
    /**
     * Get list of friends in a namespace.
     */
    getFriendUser_ByUserId: (userId: string, queryParams?: {
        friendId?: string | null;
        friendIds?: string[];
        limit?: number;
        offset?: number;
    }) => Promise<AxiosResponse<GetFriendsResponse>>;
    /**
     * Get list of incoming friend requests.
     */
    getIncomingFriend_ByUserId: (userId: string, queryParams?: {
        friendId?: string | null;
        limit?: number;
        offset?: number;
    }) => Promise<AxiosResponse<LoadIncomingFriendsWithTimeResponse>>;
    /**
     * Get list of outgoing friend requests in a namespace.
     */
    getOutgoingFriend_ByUserId: (userId: string, queryParams?: {
        limit?: number;
        offset?: number;
    }) => Promise<AxiosResponse<LoadOutgoingFriendsWithTimeResponse>>;
    /**
     * Load list friends and friends of friends in a namespace. Response subjectId will be different with requested userId if the user is not directly friend
     */
    getOfFriends_ByUserId: (userId: string, queryParams?: {
        friendId?: string | null;
        limit?: number;
        nopaging?: boolean | null;
        offset?: number;
    }) => Promise<AxiosResponse<FriendshipConnectionResponse>>;
};

/**
 * AUTO GENERATED
 */

declare function LobbyOperationsAdminApi(sdk: AccelByteSDK, args?: SdkSetConfigParam): {
    /**
     * Update party attributes in a namespace.
     */
    updateAttributeParty_ByPartyId: (partyId: string, data: PartyPutCustomAttributesRequest) => Promise<AxiosResponse<PartyData>>;
    /**
     * Admin join a player into a party.
     */
    updateJoinParty_ByPartyId_ByUserId: (partyId: string, userId: string) => Promise<AxiosResponse<unknown>>;
};

/**
 * AUTO GENERATED
 */

declare function NotificationAdminApi(sdk: AccelByteSDK, args?: SdkSetConfigParam): {
    /**
     * Get topic by namespace.&lt;br/&gt; Action Code: 50213
     */
    getNotificationTopics: (queryParams?: {
        after?: string | null;
        before?: string | null;
        limit?: number;
    }) => Promise<AxiosResponse<GetAllNotificationTopicsResponse>>;
    /**
     * Create new notification topic. &lt;br&gt;topic should be alphabets, no special char except underscore, uppercase and no spacing. for example: TOPIC_TEST. Already existing topic can not be created&lt;br/&gt; Action Code: 50214
     */
    createNotificationTopic: (data: CreateTopicRequestV1) => Promise<AxiosResponse<unknown>>;
    /**
     * Get all templates in a namespace&lt;br&gt; Action Code: 50203
     */
    getNotificationTemplates: () => Promise<AxiosResponse<NotificationTemplateResponseArray>>;
    /**
     * Create new notification template. Include handlebars {{key}} for replaceable contexts. The key inside handlebars will be the key to be replaced when sending notification. Already existing template with the same slug and language can not be created. &lt;br&gt;Check model description for detailed input restrictions.&lt;br&gt; Action Code: 50204
     */
    createNotificationTemplate: (data: CreateTemplateRequest) => Promise<AxiosResponse<unknown>>;
    /**
     * Sends notification to all connected users in a namespace.&lt;br&gt; Action Code: 50201
     */
    createNotificationFreeformNotify: (data: FreeFormNotificationRequestV1) => Promise<AxiosResponse<unknown>>;
    /**
     * Sends notification to all connected users in a namespace with predefined template. &lt;br&gt;In the request body, specify which template slug (template identifier) to use and the template language. &lt;br&gt;NotificationTemplate context is the key-value pair defining the value of each handlebar specified in the template content. Template need to be published before it can be use to send notifications&lt;br/&gt; Action Code: 50202
     */
    createNotificationTemplateNotify: (data: NotificationWithTemplateRequestV1) => Promise<AxiosResponse<unknown>>;
    /**
     * Delete topic information by topic name. &lt;br&gt;topic should be alphabets, no special char except underscore, uppercase and no spacing. for example: TOPIC_TEST. Already existing topic can not be created &lt;br/&gt; Action Code: 50217
     */
    deleteNotificationTopic_ByTopicName: (topicName: string) => Promise<AxiosResponse<unknown>>;
    /**
     * Get topic information by topic name.&lt;br/&gt; Action Code: 50215
     */
    getNotificationTopic_ByTopicName: (topicName: string) => Promise<AxiosResponse<NotificationTopicResponseV1>>;
    /**
     * Update topic information by topic name. &lt;br&gt;topic should be alphabets, no special char except underscore, uppercase and no spacing. for example: TOPIC_TEST. Already existing topic can not be created &lt;br/&gt; Action Code: 50216
     */
    updateNotificationTopic_ByTopicName: (topicName: string, data: UpdateTopicRequest) => Promise<AxiosResponse<unknown>>;
    /**
     * Delete template slug in notification template&lt;br&gt; Action Code: 50206
     */
    deleteNotificationTemplate_ByTemplateSlug: (templateSlug: string) => Promise<AxiosResponse<unknown>>;
    /**
     * Get all templates in a namespace&lt;br&gt; Action Code: 50205
     */
    getNotificationTemplate_ByTemplateSlug: (templateSlug: string, queryParams?: {
        after?: string | null;
        before?: string | null;
        limit?: number;
    }) => Promise<AxiosResponse<GetAllNotificationTemplateSlugResp>>;
    /**
     * Sends notification to multiple user. Action Code: 50211
     */
    createNotificationBulkUserFreeformNotify: (data: BulkUsersFreeFormNotificationRequestV1) => Promise<AxiosResponse<unknown>>;
    /**
     * Sends notification to a user. Action Code: 50211
     */
    createFreeformNotifyNotification_ByUserId: (userId: string, data: FreeFormNotificationRequestV1) => Promise<AxiosResponse<unknown>>;
    /**
     * Sends templated notification to a user. &lt;br&gt;In the request body, specify which template slug (template identifier) to use and the template language. &lt;br&gt;NotificationTemplate context is the key-value pair defining the value of each handlebar specified in the template content. Template need to be published before it can be use to send notifications&lt;br&gt; Action Code: 50212
     */
    createTemplateNotifyNotification_ByUserId: (userId: string, data: NotificationWithTemplateRequestV1) => Promise<AxiosResponse<unknown>>;
    /**
     * Sends notification to a party.
     */
    createFreeformNotifyNotification_ByPartyId: (partyId: string, data: FreeFormNotificationRequestV1) => Promise<AxiosResponse<unknown>>;
    /**
     * Sends templated notification to a party. &lt;br&gt;In the request body, specify which template slug (template identifier) to use and the template language. &lt;br&gt;NotificationTemplate context is the key-value pair defining the value of each handlebar specified in the template content. Template need to be published before it can be use to send notifications&lt;br&gt;
     */
    createTemplateNotifyNotification_ByPartyId: (partyId: string, data: NotificationWithTemplateRequestV1) => Promise<AxiosResponse<unknown>>;
    /**
     * Delete template localization&lt;br/&gt; Action Code: 50209
     */
    deleteLanguageNotification_ByTemplateSlug_ByTemplateLanguage: (templateSlug: string, templateLanguage: string) => Promise<AxiosResponse<unknown>>;
    /**
     * Get a template localization&lt;br/&gt; Action Code: 50207
     */
    getLanguageNotification_ByTemplateSlug_ByTemplateLanguage: (templateSlug: string, templateLanguage: string) => Promise<AxiosResponse<Localization>>;
    /**
     * Update template localization&lt;br/&gt; Action Code: 50208
     */
    updateLanguageNotification_ByTemplateSlug_ByTemplateLanguage: (templateSlug: string, templateLanguage: string, data: UpdateTemplateRequest) => Promise<AxiosResponse<unknown>>;
    /**
     * Publish notification template draft. Empty draft can not be published.&lt;br/&gt; Action Code: 50210
     */
    createPublishNotification_ByTemplateSlug_ByTemplateLanguage: (templateSlug: string, templateLanguage: string) => Promise<AxiosResponse<unknown>>;
};

/**
 * AUTO GENERATED
 */

declare function PartyAdminApi(sdk: AccelByteSDK, args?: SdkSetConfigParam): {
    /**
     * Get party data in a namespace.
     */
    getPartyParty_ByPartyId: (partyId: string) => Promise<AxiosResponse<PartyData>>;
    /**
     * Get party data in a namespace.
     */
    getParty_ByUserId: (userId: string) => Promise<AxiosResponse<PartyData>>;
};

/**
 * AUTO GENERATED
 */

declare function PlayerAdminApi(sdk: AccelByteSDK, args?: SdkSetConfigParam): {
    /**
     * Get the number of players connected to the Lobby in the given namespace.
     */
    getPlayerCcu: () => Promise<AxiosResponse<GetLobbyCcuResponse>>;
    /**
     * Get blocked players data by bulk user ids in a namespace.
     */
    fetchPlayerUserBulkBlocked: (data: GetBulkAllPlayerBlockedUsersRequest) => Promise<AxiosResponse<GetBulkAllPlayerBlockedUsersResponse>>;
    /**
     * Get blocked players data by user id in a namespace.
     */
    getBlockedPlayer_ByUserId: (userId: string) => Promise<AxiosResponse<GetAllPlayerBlockedUsersResponse>>;
    /**
     * Get all player&#39;s session attribute by user id in a namespace.
     */
    getAttributesPlayer_ByUserId: (userId: string) => Promise<AxiosResponse<GetAllPlayerSessionAttributeResponse>>;
    /**
     * Set player&#39;s session attribute by user id in a namespace.
     */
    updateAttributePlayer_ByUserId: (userId: string, data: SetPlayerSessionAttributeRequest) => Promise<AxiosResponse<unknown>>;
    /**
     * Load get players who blocked this player in a namespace based on user id
     */
    getBlockedByPlayer_ByUserId: (userId: string) => Promise<AxiosResponse<GetAllPlayerBlockedByUsersResponse>>;
    /**
     * Bulk block player in a namespace by list of user id
     */
    createBulkBlockPlayer_ByUserId: (userId: string, data: ListBlockedPlayerRequest) => Promise<AxiosResponse<unknown>>;
    /**
     * Bulk unblock player in a namespace by list of user id
     */
    deleteBulkUnblockPlayer_ByUserId: (userId: string, data: ListUnblockPlayerRequest) => Promise<AxiosResponse<unknown>>;
    /**
     * Get player&#39;s specific session attribute by user id in a namespace.
     */
    getAttributePlayer_ByUserId_ByAttribute: (userId: string, attribute: string) => Promise<AxiosResponse<GetPlayerSessionAttributeResponse>>;
};

/**
 * AUTO GENERATED
 */

declare function ProfanityAdminApi(sdk: AccelByteSDK, args?: SdkSetConfigParam): {
    /**
     * Get current profanity rule
     */
    getProfanityRule: () => Promise<AxiosResponse<ProfanityRule>>;
    /**
     * Set current profanity rule
     */
    updateProfanityRule: (data: AdminSetProfanityRuleForNamespaceRequest) => Promise<AxiosResponse<unknown>>;
    /**
     * Get lists
     */
    getProfanityLists: () => Promise<AxiosResponse<AdminGetProfanityListsListResponseArray>>;
    /**
     * Create a new list
     */
    createProfanityList: (data: AdminCreateProfanityListRequest) => Promise<AxiosResponse<unknown>>;
    /**
     * Verify a message directly from the UI or other services
     */
    fetchProfanityVerify: (data: AdminVerifyMessageProfanityRequest) => Promise<AxiosResponse<AdminVerifyMessageProfanityResponse>>;
    /**
     * Delete a list include all filters inside of it
     */
    deleteProfanityList_ByList: (list: string) => Promise<AxiosResponse<unknown>>;
    /**
     * Update the list
     */
    updateProfanityList_ByList: (list: string, data: AdminUpdateProfanityList) => Promise<AxiosResponse<unknown>>;
    /**
     * Get the list of filters that would modify the phrase
     */
    fetchProfanityFilterDebug: (data: DebugProfanityFilterRequest) => Promise<AxiosResponse<ProfanityFilterArray>>;
    /**
     * Get the list of filters inside the list.
     */
    getFiltersProfanity_ByList: (list: string) => Promise<AxiosResponse<AdminGetProfanityListFiltersV1Response>>;
    /**
     * Add a single filter into the list
     */
    createFilterProfanity_ByList: (list: string, data: AdminAddProfanityFilterIntoListRequest) => Promise<AxiosResponse<unknown>>;
    /**
     * Add multiple filters into the list
     */
    createFilterBulkProfanity_ByList: (list: string, data: AdminAddProfanityFiltersRequest) => Promise<AxiosResponse<unknown>>;
    /**
     * Delete the filter from the list
     */
    createFilterDeleteProfanity_ByList: (list: string, data: AdminDeleteProfanityFilterRequest) => Promise<AxiosResponse<ProfanityFilterArray>>;
    /**
     * Import a file with filters
     */
    createFilterBulkFileProfanity_ByList: (list: string, data: number[]) => Promise<AxiosResponse<unknown>>;
};

/**
 * AUTO GENERATED
 */

declare function ThirdPartyAdminApi(sdk: AccelByteSDK, args?: SdkSetConfigParam): {
    /**
     * Required permission : &lt;code&gt;ADMIN:NAMESPACE:{namespace}:THIRDPARTY:CONFIG [DELETE]&lt;/code&gt; with scope &lt;code&gt;social&lt;/code&gt; &lt;br&gt;delete third party config in a namespace.
     */
    deleteThirdpartyConfigSteam: () => Promise<AxiosResponse<unknown>>;
    /**
     * Get third party config for specified namespace.
     */
    getThirdpartyConfigSteam: () => Promise<AxiosResponse<GetConfigResponse>>;
    /**
     * Create third party config in a namespace.
     */
    createThirdpartyConfigSteam: (data: CreateConfigRequest) => Promise<AxiosResponse<CreateConfigResponse>>;
    /**
     * Update third party config in a namespace.
     */
    updateThirdpartyConfigSteam: (data: UpdateConfigRequest) => Promise<AxiosResponse<UpdateConfigResponse>>;
};

declare const AdminAddProfanityFiltersFilterRequest: z.ZodObject<{
    filter: z.ZodString;
    note: z.ZodString;
}, "strip", z.ZodTypeAny, {
    filter: string;
    note: string;
}, {
    filter: string;
    note: string;
}>;
interface AdminAddProfanityFiltersFilterRequest extends z.TypeOf<typeof AdminAddProfanityFiltersFilterRequest> {
}

declare const AdminGetProfanityListsListResponse: z.ZodObject<{
    isEnabled: z.ZodBoolean;
    isMandatory: z.ZodBoolean;
    name: z.ZodString;
}, "strip", z.ZodTypeAny, {
    isEnabled: boolean;
    isMandatory: boolean;
    name: string;
}, {
    isEnabled: boolean;
    isMandatory: boolean;
    name: string;
}>;
interface AdminGetProfanityListsListResponse extends z.TypeOf<typeof AdminGetProfanityListsListResponse> {
}

declare const AppMessageDeclaration: z.ZodObject<{
    Attributes: z.ZodArray<z.ZodString, "many">;
    Code: z.ZodString;
    CodeName: z.ZodString;
    Section: z.ZodString;
    Service: z.ZodString;
    Text: z.ZodString;
}, "strip", z.ZodTypeAny, {
    Attributes: string[];
    Code: string;
    CodeName: string;
    Section: string;
    Service: string;
    Text: string;
}, {
    Attributes: string[];
    Code: string;
    CodeName: string;
    Section: string;
    Service: string;
    Text: string;
}>;
interface AppMessageDeclaration extends z.TypeOf<typeof AppMessageDeclaration> {
}

declare const BlockedByPlayerData: z.ZodObject<{
    blockedAt: z.ZodString;
    userId: z.ZodString;
}, "strip", z.ZodTypeAny, {
    userId: string;
    blockedAt: string;
}, {
    userId: string;
    blockedAt: string;
}>;
interface BlockedByPlayerData extends z.TypeOf<typeof BlockedByPlayerData> {
}

declare const BlockedPlayerData: z.ZodObject<{
    blockedAt: z.ZodString;
    blockedUserId: z.ZodString;
}, "strip", z.ZodTypeAny, {
    blockedAt: string;
    blockedUserId: string;
}, {
    blockedAt: string;
    blockedUserId: string;
}>;
interface BlockedPlayerData extends z.TypeOf<typeof BlockedPlayerData> {
}

declare const Config: z.ZodObject<{
    allowInviteNonConnectedUser: z.ZodOptional<z.ZodNullable<z.ZodBoolean>>;
    allowJoinPartyDuringMatchmaking: z.ZodOptional<z.ZodNullable<z.ZodBoolean>>;
    autoKickOnDisconnect: z.ZodOptional<z.ZodNullable<z.ZodBoolean>>;
    autoKickOnDisconnectDelay: z.ZodOptional<z.ZodNullable<z.ZodNumber>>;
    cancelTicketOnDisconnect: z.ZodOptional<z.ZodNullable<z.ZodBoolean>>;
    chatRateLimitBurst: z.ZodOptional<z.ZodNullable<z.ZodNumber>>;
    chatRateLimitDuration: z.ZodOptional<z.ZodNullable<z.ZodNumber>>;
    concurrentUsersLimit: z.ZodOptional<z.ZodNullable<z.ZodNumber>>;
    disableInvitationOnJoinParty: z.ZodOptional<z.ZodNullable<z.ZodBoolean>>;
    disableRemoveSocketOldConnection: z.ZodOptional<z.ZodNullable<z.ZodBoolean>>;
    enableChat: z.ZodOptional<z.ZodNullable<z.ZodBoolean>>;
    entitlementCheck: z.ZodOptional<z.ZodNullable<z.ZodBoolean>>;
    entitlementItemID: z.ZodOptional<z.ZodNullable<z.ZodString>>;
    generalRateLimitBurst: z.ZodOptional<z.ZodNullable<z.ZodNumber>>;
    generalRateLimitDuration: z.ZodOptional<z.ZodNullable<z.ZodNumber>>;
    keepPresenceActivityOnDisconnect: z.ZodOptional<z.ZodNullable<z.ZodBoolean>>;
    maxDSWaitTime: z.ZodNumber;
    maxFriendsLimit: z.ZodOptional<z.ZodNullable<z.ZodNumber>>;
    maxPartyMember: z.ZodOptional<z.ZodNullable<z.ZodNumber>>;
    namespace: z.ZodOptional<z.ZodNullable<z.ZodString>>;
    profanityFilter: z.ZodOptional<z.ZodNullable<z.ZodBoolean>>;
    readyConsentTimeout: z.ZodOptional<z.ZodNullable<z.ZodNumber>>;
    unregisterDelay: z.ZodNumber;
}, "strip", z.ZodTypeAny, {
    maxDSWaitTime: number;
    unregisterDelay: number;
    namespace?: string | null | undefined;
    allowInviteNonConnectedUser?: boolean | null | undefined;
    allowJoinPartyDuringMatchmaking?: boolean | null | undefined;
    autoKickOnDisconnect?: boolean | null | undefined;
    autoKickOnDisconnectDelay?: number | null | undefined;
    cancelTicketOnDisconnect?: boolean | null | undefined;
    chatRateLimitBurst?: number | null | undefined;
    chatRateLimitDuration?: number | null | undefined;
    concurrentUsersLimit?: number | null | undefined;
    disableInvitationOnJoinParty?: boolean | null | undefined;
    disableRemoveSocketOldConnection?: boolean | null | undefined;
    enableChat?: boolean | null | undefined;
    entitlementCheck?: boolean | null | undefined;
    entitlementItemID?: string | null | undefined;
    generalRateLimitBurst?: number | null | undefined;
    generalRateLimitDuration?: number | null | undefined;
    keepPresenceActivityOnDisconnect?: boolean | null | undefined;
    maxFriendsLimit?: number | null | undefined;
    maxPartyMember?: number | null | undefined;
    profanityFilter?: boolean | null | undefined;
    readyConsentTimeout?: number | null | undefined;
}, {
    maxDSWaitTime: number;
    unregisterDelay: number;
    namespace?: string | null | undefined;
    allowInviteNonConnectedUser?: boolean | null | undefined;
    allowJoinPartyDuringMatchmaking?: boolean | null | undefined;
    autoKickOnDisconnect?: boolean | null | undefined;
    autoKickOnDisconnectDelay?: number | null | undefined;
    cancelTicketOnDisconnect?: boolean | null | undefined;
    chatRateLimitBurst?: number | null | undefined;
    chatRateLimitDuration?: number | null | undefined;
    concurrentUsersLimit?: number | null | undefined;
    disableInvitationOnJoinParty?: boolean | null | undefined;
    disableRemoveSocketOldConnection?: boolean | null | undefined;
    enableChat?: boolean | null | undefined;
    entitlementCheck?: boolean | null | undefined;
    entitlementItemID?: string | null | undefined;
    generalRateLimitBurst?: number | null | undefined;
    generalRateLimitDuration?: number | null | undefined;
    keepPresenceActivityOnDisconnect?: boolean | null | undefined;
    maxFriendsLimit?: number | null | undefined;
    maxPartyMember?: number | null | undefined;
    profanityFilter?: boolean | null | undefined;
    readyConsentTimeout?: number | null | undefined;
}>;
interface Config extends z.TypeOf<typeof Config> {
}

declare const Error: z.ZodObject<{
    errorCode: z.ZodNumber;
    errorMessage: z.ZodString;
}, "strip", z.ZodTypeAny, {
    errorCode: number;
    errorMessage: string;
}, {
    errorCode: number;
    errorMessage: string;
}>;
interface Error extends z.TypeOf<typeof Error> {
}

declare const ErrorResponseBody: z.ZodObject<{
    ErrorCode: z.ZodNumber;
    ErrorMessage: z.ZodString;
}, "strip", z.ZodTypeAny, {
    ErrorCode: number;
    ErrorMessage: string;
}, {
    ErrorCode: number;
    ErrorMessage: string;
}>;
interface ErrorResponseBody extends z.TypeOf<typeof ErrorResponseBody> {
}

declare const ErrorResponseV1: z.ZodObject<{
    errorCode: z.ZodNumber;
    errorMessage: z.ZodString;
}, "strip", z.ZodTypeAny, {
    errorCode: number;
    errorMessage: string;
}, {
    errorCode: number;
    errorMessage: string;
}>;
interface ErrorResponseV1 extends z.TypeOf<typeof ErrorResponseV1> {
}

declare const FriendshipConnection: z.ZodObject<{
    friendId: z.ZodString;
    subjectId: z.ZodString;
}, "strip", z.ZodTypeAny, {
    friendId: string;
    subjectId: string;
}, {
    friendId: string;
    subjectId: string;
}>;
interface FriendshipConnection extends z.TypeOf<typeof FriendshipConnection> {
}

declare const FriendWithPlatform: z.ZodObject<{
    platformId: z.ZodString;
    userId: z.ZodString;
}, "strip", z.ZodTypeAny, {
    platformId: string;
    userId: string;
}, {
    platformId: string;
    userId: string;
}>;
interface FriendWithPlatform extends z.TypeOf<typeof FriendWithPlatform> {
}

declare const GetUserFriendsResponse: z.ZodObject<{
    friendIDs: z.ZodArray<z.ZodString, "many">;
    friends: z.ZodOptional<z.ZodNullable<z.ZodArray<z.ZodObject<{
        platformId: z.ZodString;
        userId: z.ZodString;
    }, "strip", z.ZodTypeAny, {
        platformId: string;
        userId: string;
    }, {
        platformId: string;
        userId: string;
    }>, "many">>>;
    paging: z.ZodObject<{
        first: z.ZodString;
        last: z.ZodString;
        next: z.ZodString;
        previous: z.ZodString;
    }, "strip", z.ZodTypeAny, {
        first: string;
        last: string;
        next: string;
        previous: string;
    }, {
        first: string;
        last: string;
        next: string;
        previous: string;
    }>;
}, "strip", z.ZodTypeAny, {
    paging: {
        first: string;
        last: string;
        next: string;
        previous: string;
    };
    friendIDs: string[];
    friends?: {
        platformId: string;
        userId: string;
    }[] | null | undefined;
}, {
    paging: {
        first: string;
        last: string;
        next: string;
        previous: string;
    };
    friendIDs: string[];
    friends?: {
        platformId: string;
        userId: string;
    }[] | null | undefined;
}>;
interface GetUserFriendsResponse extends z.TypeOf<typeof GetUserFriendsResponse> {
}

declare const GetUserIncomingFriendsResponse: z.ZodObject<{
    friendIDs: z.ZodArray<z.ZodString, "many">;
    paging: z.ZodObject<{
        first: z.ZodString;
        last: z.ZodString;
        next: z.ZodString;
        previous: z.ZodString;
    }, "strip", z.ZodTypeAny, {
        first: string;
        last: string;
        next: string;
        previous: string;
    }, {
        first: string;
        last: string;
        next: string;
        previous: string;
    }>;
}, "strip", z.ZodTypeAny, {
    paging: {
        first: string;
        last: string;
        next: string;
        previous: string;
    };
    friendIDs: string[];
}, {
    paging: {
        first: string;
        last: string;
        next: string;
        previous: string;
    };
    friendIDs: string[];
}>;
interface GetUserIncomingFriendsResponse extends z.TypeOf<typeof GetUserIncomingFriendsResponse> {
}

declare const GetUserOutgoingFriendsResponse: z.ZodObject<{
    friendIDs: z.ZodArray<z.ZodString, "many">;
    paging: z.ZodObject<{
        first: z.ZodString;
        last: z.ZodString;
        next: z.ZodString;
        previous: z.ZodString;
    }, "strip", z.ZodTypeAny, {
        first: string;
        last: string;
        next: string;
        previous: string;
    }, {
        first: string;
        last: string;
        next: string;
        previous: string;
    }>;
}, "strip", z.ZodTypeAny, {
    paging: {
        first: string;
        last: string;
        next: string;
        previous: string;
    };
    friendIDs: string[];
}, {
    paging: {
        first: string;
        last: string;
        next: string;
        previous: string;
    };
    friendIDs: string[];
}>;
interface GetUserOutgoingFriendsResponse extends z.TypeOf<typeof GetUserOutgoingFriendsResponse> {
}

declare const IncomingFriendsWithTimeData: z.ZodObject<{
    friendId: z.ZodString;
    requestedAt: z.ZodString;
}, "strip", z.ZodTypeAny, {
    friendId: string;
    requestedAt: string;
}, {
    friendId: string;
    requestedAt: string;
}>;
interface IncomingFriendsWithTimeData extends z.TypeOf<typeof IncomingFriendsWithTimeData> {
}

declare const NativeFriendSyncResponse: z.ZodObject<{
    detail: z.ZodOptional<z.ZodNullable<z.ZodString>>;
    platformId: z.ZodString;
    status: z.ZodString;
}, "strip", z.ZodTypeAny, {
    status: string;
    platformId: string;
    detail?: string | null | undefined;
}, {
    status: string;
    platformId: string;
    detail?: string | null | undefined;
}>;
interface NativeFriendSyncResponse extends z.TypeOf<typeof NativeFriendSyncResponse> {
}

declare const NativeUserBlockResponse: z.ZodObject<{
    detail: z.ZodOptional<z.ZodNullable<z.ZodString>>;
    platformId: z.ZodString;
    status: z.ZodString;
}, "strip", z.ZodTypeAny, {
    status: string;
    platformId: string;
    detail?: string | null | undefined;
}, {
    status: string;
    platformId: string;
    detail?: string | null | undefined;
}>;
interface NativeUserBlockResponse extends z.TypeOf<typeof NativeUserBlockResponse> {
}

declare const NotificationTemplateResponse: z.ZodObject<{
    templateLocalizations: z.ZodArray<z.ZodObject<{
        lastDraftAt: z.ZodString;
        lastPublishedAt: z.ZodString;
        templateContent: z.ZodObject<{
            draft: z.ZodString;
            published: z.ZodString;
        }, "strip", z.ZodTypeAny, {
            draft: string;
            published: string;
        }, {
            draft: string;
            published: string;
        }>;
        templateLanguage: z.ZodString;
    }, "strip", z.ZodTypeAny, {
        templateContent: {
            draft: string;
            published: string;
        };
        templateLanguage: string;
        lastDraftAt: string;
        lastPublishedAt: string;
    }, {
        templateContent: {
            draft: string;
            published: string;
        };
        templateLanguage: string;
        lastDraftAt: string;
        lastPublishedAt: string;
    }>, "many">;
    templateSlug: z.ZodString;
}, "strip", z.ZodTypeAny, {
    templateSlug: string;
    templateLocalizations: {
        templateContent: {
            draft: string;
            published: string;
        };
        templateLanguage: string;
        lastDraftAt: string;
        lastPublishedAt: string;
    }[];
}, {
    templateSlug: string;
    templateLocalizations: {
        templateContent: {
            draft: string;
            published: string;
        };
        templateLanguage: string;
        lastDraftAt: string;
        lastPublishedAt: string;
    }[];
}>;
interface NotificationTemplateResponse extends z.TypeOf<typeof NotificationTemplateResponse> {
}

declare const OutgoingFriendsWithTimeData: z.ZodObject<{
    friendId: z.ZodString;
    requestedAt: z.ZodString;
}, "strip", z.ZodTypeAny, {
    friendId: string;
    requestedAt: string;
}, {
    friendId: string;
    requestedAt: string;
}>;
interface OutgoingFriendsWithTimeData extends z.TypeOf<typeof OutgoingFriendsWithTimeData> {
}

declare const Pagination: z.ZodObject<{
    first: z.ZodString;
    last: z.ZodString;
    next: z.ZodString;
    previous: z.ZodString;
}, "strip", z.ZodTypeAny, {
    first: string;
    last: string;
    next: string;
    previous: string;
}, {
    first: string;
    last: string;
    next: string;
    previous: string;
}>;
interface Pagination extends z.TypeOf<typeof Pagination> {
}

declare const ProfanityFilter: z.ZodObject<{
    filter: z.ZodString;
    listName: z.ZodString;
    namespace: z.ZodString;
    note: z.ZodString;
}, "strip", z.ZodTypeAny, {
    namespace: string;
    filter: string;
    note: string;
    listName: string;
}, {
    namespace: string;
    filter: string;
    note: string;
    listName: string;
}>;
interface ProfanityFilter extends z.TypeOf<typeof ProfanityFilter> {
}

declare const TemplateContent: z.ZodObject<{
    draft: z.ZodString;
    published: z.ZodString;
}, "strip", z.ZodTypeAny, {
    draft: string;
    published: string;
}, {
    draft: string;
    published: string;
}>;
interface TemplateContent extends z.TypeOf<typeof TemplateContent> {
}

declare const TemplateResponse: z.ZodObject<{
    localizations: z.ZodArray<z.ZodObject<{
        lastDraftAt: z.ZodString;
        lastPublishedAt: z.ZodString;
        templateContent: z.ZodObject<{
            draft: z.ZodString;
            published: z.ZodString;
        }, "strip", z.ZodTypeAny, {
            draft: string;
            published: string;
        }, {
            draft: string;
            published: string;
        }>;
        templateLanguage: z.ZodString;
    }, "strip", z.ZodTypeAny, {
        templateContent: {
            draft: string;
            published: string;
        };
        templateLanguage: string;
        lastDraftAt: string;
        lastPublishedAt: string;
    }, {
        templateContent: {
            draft: string;
            published: string;
        };
        templateLanguage: string;
        lastDraftAt: string;
        lastPublishedAt: string;
    }>, "many">;
    templateSlug: z.ZodString;
}, "strip", z.ZodTypeAny, {
    templateSlug: string;
    localizations: {
        templateContent: {
            draft: string;
            published: string;
        };
        templateLanguage: string;
        lastDraftAt: string;
        lastPublishedAt: string;
    }[];
}, {
    templateSlug: string;
    localizations: {
        templateContent: {
            draft: string;
            published: string;
        };
        templateLanguage: string;
        lastDraftAt: string;
        lastPublishedAt: string;
    }[];
}>;
interface TemplateResponse extends z.TypeOf<typeof TemplateResponse> {
}

declare const UserPlatformInfo: z.ZodObject<{
    platformDisplayName: z.ZodString;
    platformName: z.ZodString;
    platformUserId: z.ZodString;
}, "strip", z.ZodTypeAny, {
    platformDisplayName: string;
    platformName: string;
    platformUserId: string;
}, {
    platformDisplayName: string;
    platformName: string;
    platformUserId: string;
}>;
interface UserPlatformInfo extends z.TypeOf<typeof UserPlatformInfo> {
}

declare const UserPresence: z.ZodObject<{
    activity: z.ZodString;
    availability: z.ZodString;
    lastSeenAt: z.ZodString;
    namespace: z.ZodString;
    platform: z.ZodString;
    userID: z.ZodString;
}, "strip", z.ZodTypeAny, {
    namespace: string;
    activity: string;
    availability: string;
    lastSeenAt: string;
    platform: string;
    userID: string;
}, {
    namespace: string;
    activity: string;
    availability: string;
    lastSeenAt: string;
    platform: string;
    userID: string;
}>;
interface UserPresence extends z.TypeOf<typeof UserPresence> {
}

declare const UserWithPlatformInfo: z.ZodObject<{
    avatarUrl: z.ZodString;
    displayName: z.ZodString;
    platformInfos: z.ZodArray<z.ZodObject<{
        platformDisplayName: z.ZodString;
        platformName: z.ZodString;
        platformUserId: z.ZodString;
    }, "strip", z.ZodTypeAny, {
        platformDisplayName: string;
        platformName: string;
        platformUserId: string;
    }, {
        platformDisplayName: string;
        platformName: string;
        platformUserId: string;
    }>, "many">;
    userId: z.ZodString;
    username: z.ZodOptional<z.ZodNullable<z.ZodString>>;
}, "strip", z.ZodTypeAny, {
    userId: string;
    avatarUrl: string;
    displayName: string;
    platformInfos: {
        platformDisplayName: string;
        platformName: string;
        platformUserId: string;
    }[];
    username?: string | null | undefined;
}, {
    userId: string;
    avatarUrl: string;
    displayName: string;
    platformInfos: {
        platformDisplayName: string;
        platformName: string;
        platformUserId: string;
    }[];
    username?: string | null | undefined;
}>;
interface UserWithPlatformInfo extends z.TypeOf<typeof UserWithPlatformInfo> {
}

/**
 * AUTO GENERATED
 */

declare function AdminApi(sdk: AccelByteSDK, args?: SdkSetConfigParam): {
    /**
     * Sends notification to all connected users in a namespace.
     */
    createNotificationFreeform: (data: FreeFormNotificationRequest) => Promise<AxiosResponse<unknown>>;
    /**
     * Sends notification to all connected users in a namespace with predefined template. &lt;br&gt;In the request body, specify which template slug (template identifier) to use and the template language. &lt;br&gt;NotificationTemplate context is the key-value pair defining the value of each handlebar specified in the template content. Template need to be published before it can be use to send notifications
     */
    createNotificationTemplated: (data: NotificationWithTemplateRequest) => Promise<AxiosResponse<unknown>>;
    /**
     * Get all templates in a namespace
     */
    getNotificationTemplates: () => Promise<AxiosResponse<TemplateResponseArray>>;
    /**
     * Create new notification template. Include handlebars {{key}} for replaceable contexts. The the key inside handlebars will be the key to be replaced when sending notification. Already existing template with the same slug and language can not be created. &lt;br&gt;Check model description for detailed input restrictions.
     */
    createNotificationTemplate: (data: CreateTemplateRequest) => Promise<AxiosResponse<unknown>>;
    /**
     * Delete localization template
     */
    deleteNotificationTemplate_ByTemplateSlug: (templateSlug: string) => Promise<AxiosResponse<unknown>>;
    /**
     * Get all templates in a namespace
     */
    getNotificationTemplate_ByTemplateSlug: (templateSlug: string, queryParams?: {
        after?: string | null;
        before?: string | null;
        limit?: number;
    }) => Promise<AxiosResponse<TemplateLocalizationResponse>>;
    /**
     * Delete all template in a slug
     */
    deleteLanguageNotification_ByTemplateSlug_ByTemplateLanguage: (templateSlug: string, templateLanguage: string) => Promise<AxiosResponse<unknown>>;
    /**
     * Get a template localization
     */
    getLanguageNotification_ByTemplateSlug_ByTemplateLanguage: (templateSlug: string, templateLanguage: string) => Promise<AxiosResponse<TemplateLocalization>>;
    /**
     * Modify draft template
     */
    updateLanguageNotification_ByTemplateSlug_ByTemplateLanguage: (templateSlug: string, templateLanguage: string, data: UpdateTemplateRequest) => Promise<AxiosResponse<unknown>>;
    /**
     * Publish notification template draft. Empty draft can not be published.
     */
    createPublishNotification_ByTemplateSlug_ByTemplateLanguage: (templateSlug: string, templateLanguage: string) => Promise<AxiosResponse<unknown>>;
};

/**
 * AUTO GENERATED
 */

declare function BlocksApi(sdk: AccelByteSDK, args?: SdkSetConfigParam): {
    /**
     * Sync blocked user using server to server call to native first party server. Supported platforms: ps5, ps4 and pspc : the default environment would be sp-int, can be override using psnEnv. psnEnv consist of sp-int (default), prod-qa, np
     */
    patchSyncMeBlock: (data: NativeUserBlockRequest[]) => Promise<AxiosResponse<NativeUserBlockResponseArray>>;
};

/**
 * AUTO GENERATED
 */

declare class Admin$ {
    private axiosInstance;
    private namespace;
    private useSchemaValidation;
    constructor(axiosInstance: AxiosInstance, namespace: string, useSchemaValidation?: boolean);
    /**
     * Sends notification to all connected users in a namespace.
     */
    createNotificationFreeform(data: FreeFormNotificationRequest): Promise<Response<unknown>>;
    /**
     * Sends notification to all connected users in a namespace with predefined template. &lt;br&gt;In the request body, specify which template slug (template identifier) to use and the template language. &lt;br&gt;NotificationTemplate context is the key-value pair defining the value of each handlebar specified in the template content. Template need to be published before it can be use to send notifications
     */
    createNotificationTemplated(data: NotificationWithTemplateRequest): Promise<Response<unknown>>;
    /**
     * Get all templates in a namespace
     */
    getNotificationTemplates(): Promise<Response<TemplateResponseArray>>;
    /**
     * Create new notification template. Include handlebars {{key}} for replaceable contexts. The the key inside handlebars will be the key to be replaced when sending notification. Already existing template with the same slug and language can not be created. &lt;br&gt;Check model description for detailed input restrictions.
     */
    createNotificationTemplate(data: CreateTemplateRequest): Promise<Response<unknown>>;
    /**
     * Delete localization template
     */
    deleteNotificationTemplate_ByTemplateSlug(templateSlug: string): Promise<Response<unknown>>;
    /**
     * Get all templates in a namespace
     */
    getNotificationTemplate_ByTemplateSlug(templateSlug: string, queryParams?: {
        after?: string | null;
        before?: string | null;
        limit?: number;
    }): Promise<Response<TemplateLocalizationResponse>>;
    /**
     * Delete all template in a slug
     */
    deleteLanguageNotification_ByTemplateSlug_ByTemplateLanguage(templateSlug: string, templateLanguage: string): Promise<Response<unknown>>;
    /**
     * Get a template localization
     */
    getLanguageNotification_ByTemplateSlug_ByTemplateLanguage(templateSlug: string, templateLanguage: string): Promise<Response<TemplateLocalization>>;
    /**
     * Modify draft template
     */
    updateLanguageNotification_ByTemplateSlug_ByTemplateLanguage(templateSlug: string, templateLanguage: string, data: UpdateTemplateRequest): Promise<Response<unknown>>;
    /**
     * Publish notification template draft. Empty draft can not be published.
     */
    createPublishNotification_ByTemplateSlug_ByTemplateLanguage(templateSlug: string, templateLanguage: string): Promise<Response<unknown>>;
}

/**
 * AUTO GENERATED
 */

declare class Blocks$ {
    private axiosInstance;
    private namespace;
    private useSchemaValidation;
    constructor(axiosInstance: AxiosInstance, namespace: string, useSchemaValidation?: boolean);
    /**
     * Sync blocked user using server to server call to native first party server. Supported platforms: ps5, ps4 and pspc : the default environment would be sp-int, can be override using psnEnv. psnEnv consist of sp-int (default), prod-qa, np
     */
    patchSyncMeBlock(data: NativeUserBlockRequest[]): Promise<Response<NativeUserBlockResponseArray>>;
}

/**
 * AUTO GENERATED
 */

declare class Friends$ {
    private axiosInstance;
    private namespace;
    private useSchemaValidation;
    constructor(axiosInstance: AxiosInstance, namespace: string, useSchemaValidation?: boolean);
    /**
     * Get list of friends in a namespace.
     */
    getFriendsMe(queryParams?: {
        limit?: number;
        offset?: number;
    }): Promise<Response<GetUserFriendsResponseArray>>;
    /**
     * Sync friends using server to server call to native first party server. Supported platforms: steam: The platform_token’s value is the binary ticket returned by Steam. If this ticket was generated by Steam GetAuthTicketForWebApi with version &gt;= 1.57, then platform token should use this style: {identity}:{ticket} the {identity} was the parameter to call GetAuthTicketForWebApi when the ticket was created. Note: Do not contain : in this {identity} ps4: The platform_token’s value is the authorization code returned by Sony OAuth. ps5: The platform_token’s value is the authorization code returned by Sony OAuth. pspc: The platform_token’s value is the authorization code returned by Sony OAuth.
     */
    patchFriendSyncMe(data: NativeFriendRequest[]): Promise<Response<NativeFriendSyncResponseArray>>;
    /**
     * Client should provide either friendID or friendPublicID. If both are provided, friendID will be chosen to be used. This endpoint will only send a pending invite that can be either rejected/accepted
     */
    createFriendMeRequest(data: UserRequestFriendRequest): Promise<Response<unknown>>;
    /**
     * Get list of incoming friends in a namespace.
     */
    getFriendsMeIncoming(queryParams?: {
        limit?: number;
        offset?: number;
    }): Promise<Response<GetUserIncomingFriendsResponseArray>>;
    /**
     * Get list of outgoing friends in a namespace.
     */
    getFriendsMeOutgoing(queryParams?: {
        limit?: number;
        offset?: number;
    }): Promise<Response<GetUserOutgoingFriendsResponseArray>>;
    /**
     * User unfriend a friend.
     */
    createFriendMeUnfriend(data: UserUnfriendRequest): Promise<Response<unknown>>;
    /**
     * Get list of friends with platform data in a namespace.
     */
    getFriendsMePlatforms(queryParams?: {
        limit?: number;
        offset?: number;
    }): Promise<Response<ListBulkUserPlatformsResponse>>;
    /**
     * Get list of incoming friends with requested time info in a namespace.
     */
    getFriendsMeIncomingTime(queryParams?: {
        limit?: number;
        offset?: number;
    }): Promise<Response<LoadIncomingFriendsWithTimeResponseArray>>;
    /**
     * Get list of outgoing friends with requested time info in a namespace.
     */
    getFriendsMeOutgoingTime(queryParams?: {
        limit?: number;
        offset?: number;
    }): Promise<Response<LoadOutgoingFriendsWithTimeResponseArray>>;
    /**
     * User accept friend.
     */
    createFriendMeRequestAccept(data: UserAcceptFriendRequest): Promise<Response<unknown>>;
    /**
     * User cancel a friend request.
     */
    createFriendMeRequestCancel(data: UserCancelFriendRequest): Promise<Response<unknown>>;
    /**
     * User reject a friend request.
     */
    createFriendMeRequestReject(data: UserRejectFriendRequest): Promise<Response<unknown>>;
    /**
     * User get friendship status. Code: 0 - Message: &#34;not friend&#34; Code: 1 - Message: &#34;outgoing&#34; Code: 2 - Message: &#34;incoming&#34; Code: 3 - Message: &#34;friend&#34;
     */
    getFriendMeStatu_ByFriendId(friendId: string): Promise<Response<UserGetFriendshipStatusResponse>>;
    /**
     * Friends request in a namespace.
     */
    createAddBulkFriend_ByUserId(userId: string, data: BulkFriendsRequest): Promise<Response<unknown>>;
    /**
     * Friends request in a namespace.
     */
    createDeleteBulkFriend_ByUserId(userId: string, data: BulkFriendsRequest): Promise<Response<BulkFriendsResponse>>;
}

/**
 * AUTO GENERATED
 */

declare class LobbyOperations$ {
    private axiosInstance;
    private namespace;
    private useSchemaValidation;
    constructor(axiosInstance: AxiosInstance, namespace: string, useSchemaValidation?: boolean);
    /**
     * get the list of messages.
     */
    getMessages(): Promise<Response<AppMessageDeclarationArray>>;
}

/**
 * AUTO GENERATED
 */

declare class Notification$ {
    private axiosInstance;
    private namespace;
    private useSchemaValidation;
    constructor(axiosInstance: AxiosInstance, namespace: string, useSchemaValidation?: boolean);
    /**
     * Get list of notifications in a namespace. The query parameters **startTime** and **endTime** can be filled with the **sequenceID** value in the notification, where the value is an epoch timestamp. Example **sequenceID** or epoch timestamp value: **1706595813**
     */
    getNotificationMe(queryParams?: {
        endTime?: number;
        limit?: number;
        offset?: number;
        startTime?: number;
    }): Promise<Response<NotificationResponse>>;
    /**
     * get topic by namespace.
     */
    getNotificationTopics(queryParams?: {
        after?: string | null;
        before?: string | null;
        limit?: number;
    }): Promise<Response<TopicByNamespacesResponse>>;
    /**
     * Create new notification topic. &lt;br&gt;topic should be alphabets, no special char except underscore, uppercase and no spacing. for example: TOPIC_TEST. Already existing topic can not be created
     */
    createNotificationTopic(data: CreateTopicRequest): Promise<Response<unknown>>;
    /**
     * delete topic information by topic name. &lt;br&gt;topic should be alphabets, no special char except underscore, uppercase and no spacing. for example: TOPIC_TEST. Already existing topic can not be created
     */
    deleteNotificationTopic_ByTopic(topic: string): Promise<Response<unknown>>;
    /**
     * get topic information by topic name.
     */
    getNotificationTopic_ByTopic(topic: string): Promise<Response<NotificationTopicResponse>>;
    /**
     * update topic information by topic name. &lt;br&gt;topic should be alphabets, no special char except underscore, uppercase and no spacing. for example: TOPIC_TEST. Already existing topic can not be created
     */
    updateNotificationTopic_ByTopic(topic: string, data: UpdateTopicRequest): Promise<Response<unknown>>;
    /**
     * Sends notification to a user.
     */
    createFreeformNotification_ByUserId(userId: string, data: FreeFormNotificationRequest): Promise<Response<unknown>>;
    /**
     * Sends notification to a user with predefined template. &lt;br&gt;In the request body, specify which template slug (template identifier) to use and the template language. &lt;br&gt;NotificationTemplate context is the key-value pair defining the value of each handlebar specified in the template content. Template need to be published before it can be use to send notifications
     */
    createTemplatedNotification_ByUserId(userId: string, data: NotificationWithTemplateRequest): Promise<Response<unknown>>;
}

/**
 * AUTO GENERATED
 */

declare class Party$ {
    private axiosInstance;
    private namespace;
    private useSchemaValidation;
    constructor(axiosInstance: AxiosInstance, namespace: string, useSchemaValidation?: boolean);
    /**
     * Required valid user authorization &lt;br/&gt; &lt;br&gt;load personal party data in a namespace based on Party ID &lt;br/&gt; Action Code: 50101
     */
    getPartyParty_ByPartyId(partyId: string): Promise<Response<PartyData>>;
    /**
     * Required valid user authorization &lt;br/&gt; &lt;br&gt;Set party limit, only party leader can call this endpoint.
     */
    updateLimitParty_ByPartyId(partyId: string, data: PartyPutLimitSizeRequest): Promise<Response<unknown>>;
    /**
     * Required valid user authorization &lt;br/&gt; &lt;br&gt;update party attributes in a namespace.
     */
    updateAttributeParty_ByPartyId(partyId: string, data: PartyPutCustomAttributesRequest): Promise<Response<PartyData>>;
}

/**
 * AUTO GENERATED
 */

declare class Player$ {
    private axiosInstance;
    private namespace;
    private useSchemaValidation;
    constructor(axiosInstance: AxiosInstance, namespace: string, useSchemaValidation?: boolean);
    /**
     * Required valid user authorization &lt;br/&gt; &lt;br&gt;add blocked players in a namespace based on user id &lt;br/&gt;
     */
    createPlayerUserMeBlock(data: BlockPlayerRequest$1): Promise<Response<unknown>>;
    /**
     * Required valid user authorization &lt;br/&gt; &lt;br&gt;load blocked players in a namespace based on user id &lt;br/&gt; Action Code: 50101
     */
    getPlayerUsersMeBlocked(): Promise<Response<GetAllPlayerBlockedUsersResponse>>;
    /**
     * Required valid user authorization &lt;br/&gt; unblock player in a namespace based on user id &lt;br/&gt;
     */
    createPlayerUserMeUnblock(data: UnblockPlayerRequest$1): Promise<Response<unknown>>;
    /**
     * Required valid user authorization &lt;br/&gt; &lt;br&gt;load get players who blocked this player in a namespace based on user id &lt;br/&gt; Action Code: 50101
     */
    getPlayerUsersMeBlockedBy(): Promise<Response<GetAllPlayerBlockedByUsersResponse>>;
}

/**
 * AUTO GENERATED
 */

declare class Presence$ {
    private axiosInstance;
    private namespace;
    private useSchemaValidation;
    constructor(axiosInstance: AxiosInstance, namespace: string, useSchemaValidation?: boolean);
    /**
     * Query users presence with given namespace and userIds.
     */
    getPresenceUsersPresence(queryParams: {
        userIds: string | null;
        countOnly?: boolean | null;
    }): Promise<Response<GetUsersPresenceResponse>>;
    /**
     * Query users presence with given namespace and userIds.
     */
    createPresenceUserPresence(data: RequestUserPresence, queryParams?: {
        countOnly?: boolean | null;
    }): Promise<Response<GetUsersPresenceResponse>>;
}

/**
 * AUTO GENERATED
 */

declare function FriendsApi(sdk: AccelByteSDK, args?: SdkSetConfigParam): {
    /**
     * Get list of friends in a namespace.
     */
    getFriendsMe: (queryParams?: {
        limit?: number;
        offset?: number;
    }) => Promise<AxiosResponse<GetUserFriendsResponseArray>>;
    /**
     * Sync friends using server to server call to native first party server. Supported platforms: steam: The platform_token’s value is the binary ticket returned by Steam. If this ticket was generated by Steam GetAuthTicketForWebApi with version &gt;= 1.57, then platform token should use this style: {identity}:{ticket} the {identity} was the parameter to call GetAuthTicketForWebApi when the ticket was created. Note: Do not contain : in this {identity} ps4: The platform_token’s value is the authorization code returned by Sony OAuth. ps5: The platform_token’s value is the authorization code returned by Sony OAuth. pspc: The platform_token’s value is the authorization code returned by Sony OAuth.
     */
    patchFriendSyncMe: (data: NativeFriendRequest[]) => Promise<AxiosResponse<NativeFriendSyncResponseArray>>;
    /**
     * Client should provide either friendID or friendPublicID. If both are provided, friendID will be chosen to be used. This endpoint will only send a pending invite that can be either rejected/accepted
     */
    createFriendMeRequest: (data: UserRequestFriendRequest) => Promise<AxiosResponse<unknown>>;
    /**
     * Get list of incoming friends in a namespace.
     */
    getFriendsMeIncoming: (queryParams?: {
        limit?: number;
        offset?: number;
    }) => Promise<AxiosResponse<GetUserIncomingFriendsResponseArray>>;
    /**
     * Get list of outgoing friends in a namespace.
     */
    getFriendsMeOutgoing: (queryParams?: {
        limit?: number;
        offset?: number;
    }) => Promise<AxiosResponse<GetUserOutgoingFriendsResponseArray>>;
    /**
     * User unfriend a friend.
     */
    createFriendMeUnfriend: (data: UserUnfriendRequest) => Promise<AxiosResponse<unknown>>;
    /**
     * Get list of friends with platform data in a namespace.
     */
    getFriendsMePlatforms: (queryParams?: {
        limit?: number;
        offset?: number;
    }) => Promise<AxiosResponse<ListBulkUserPlatformsResponse>>;
    /**
     * Get list of incoming friends with requested time info in a namespace.
     */
    getFriendsMeIncomingTime: (queryParams?: {
        limit?: number;
        offset?: number;
    }) => Promise<AxiosResponse<LoadIncomingFriendsWithTimeResponseArray>>;
    /**
     * Get list of outgoing friends with requested time info in a namespace.
     */
    getFriendsMeOutgoingTime: (queryParams?: {
        limit?: number;
        offset?: number;
    }) => Promise<AxiosResponse<LoadOutgoingFriendsWithTimeResponseArray>>;
    /**
     * User accept friend.
     */
    createFriendMeRequestAccept: (data: UserAcceptFriendRequest) => Promise<AxiosResponse<unknown>>;
    /**
     * User cancel a friend request.
     */
    createFriendMeRequestCancel: (data: UserCancelFriendRequest) => Promise<AxiosResponse<unknown>>;
    /**
     * User reject a friend request.
     */
    createFriendMeRequestReject: (data: UserRejectFriendRequest) => Promise<AxiosResponse<unknown>>;
    /**
     * User get friendship status. Code: 0 - Message: &#34;not friend&#34; Code: 1 - Message: &#34;outgoing&#34; Code: 2 - Message: &#34;incoming&#34; Code: 3 - Message: &#34;friend&#34;
     */
    getFriendMeStatu_ByFriendId: (friendId: string) => Promise<AxiosResponse<UserGetFriendshipStatusResponse>>;
    /**
     * Friends request in a namespace.
     */
    createAddBulkFriend_ByUserId: (userId: string, data: BulkFriendsRequest) => Promise<AxiosResponse<unknown>>;
    /**
     * Friends request in a namespace.
     */
    createDeleteBulkFriend_ByUserId: (userId: string, data: BulkFriendsRequest) => Promise<AxiosResponse<BulkFriendsResponse>>;
};

/**
 * AUTO GENERATED
 */

declare function LobbyOperationsApi(sdk: AccelByteSDK, args?: SdkSetConfigParam): {
    /**
     * get the list of messages.
     */
    getMessages: () => Promise<AxiosResponse<AppMessageDeclarationArray>>;
};

/**
 * AUTO GENERATED
 */

declare function NotificationApi(sdk: AccelByteSDK, args?: SdkSetConfigParam): {
    /**
     * Get list of notifications in a namespace. The query parameters **startTime** and **endTime** can be filled with the **sequenceID** value in the notification, where the value is an epoch timestamp. Example **sequenceID** or epoch timestamp value: **1706595813**
     */
    getNotificationMe: (queryParams?: {
        endTime?: number;
        limit?: number;
        offset?: number;
        startTime?: number;
    }) => Promise<AxiosResponse<NotificationResponse>>;
    /**
     * get topic by namespace.
     */
    getNotificationTopics: (queryParams?: {
        after?: string | null;
        before?: string | null;
        limit?: number;
    }) => Promise<AxiosResponse<TopicByNamespacesResponse>>;
    /**
     * Create new notification topic. &lt;br&gt;topic should be alphabets, no special char except underscore, uppercase and no spacing. for example: TOPIC_TEST. Already existing topic can not be created
     */
    createNotificationTopic: (data: CreateTopicRequest) => Promise<AxiosResponse<unknown>>;
    /**
     * delete topic information by topic name. &lt;br&gt;topic should be alphabets, no special char except underscore, uppercase and no spacing. for example: TOPIC_TEST. Already existing topic can not be created
     */
    deleteNotificationTopic_ByTopic: (topic: string) => Promise<AxiosResponse<unknown>>;
    /**
     * get topic information by topic name.
     */
    getNotificationTopic_ByTopic: (topic: string) => Promise<AxiosResponse<NotificationTopicResponse>>;
    /**
     * update topic information by topic name. &lt;br&gt;topic should be alphabets, no special char except underscore, uppercase and no spacing. for example: TOPIC_TEST. Already existing topic can not be created
     */
    updateNotificationTopic_ByTopic: (topic: string, data: UpdateTopicRequest) => Promise<AxiosResponse<unknown>>;
    /**
     * Sends notification to a user.
     */
    createFreeformNotification_ByUserId: (userId: string, data: FreeFormNotificationRequest) => Promise<AxiosResponse<unknown>>;
    /**
     * Sends notification to a user with predefined template. &lt;br&gt;In the request body, specify which template slug (template identifier) to use and the template language. &lt;br&gt;NotificationTemplate context is the key-value pair defining the value of each handlebar specified in the template content. Template need to be published before it can be use to send notifications
     */
    createTemplatedNotification_ByUserId: (userId: string, data: NotificationWithTemplateRequest) => Promise<AxiosResponse<unknown>>;
};

/**
 * AUTO GENERATED
 */

declare function PartyApi(sdk: AccelByteSDK, args?: SdkSetConfigParam): {
    /**
     * Required valid user authorization &lt;br/&gt; &lt;br&gt;load personal party data in a namespace based on Party ID &lt;br/&gt; Action Code: 50101
     */
    getPartyParty_ByPartyId: (partyId: string) => Promise<AxiosResponse<PartyData>>;
    /**
     * Required valid user authorization &lt;br/&gt; &lt;br&gt;Set party limit, only party leader can call this endpoint.
     */
    updateLimitParty_ByPartyId: (partyId: string, data: PartyPutLimitSizeRequest) => Promise<AxiosResponse<unknown>>;
    /**
     * Required valid user authorization &lt;br/&gt; &lt;br&gt;update party attributes in a namespace.
     */
    updateAttributeParty_ByPartyId: (partyId: string, data: PartyPutCustomAttributesRequest) => Promise<AxiosResponse<PartyData>>;
};

/**
 * AUTO GENERATED
 */

declare function PlayerApi(sdk: AccelByteSDK, args?: SdkSetConfigParam): {
    /**
     * Required valid user authorization &lt;br/&gt; &lt;br&gt;add blocked players in a namespace based on user id &lt;br/&gt;
     */
    createPlayerUserMeBlock: (data: BlockPlayerRequest$1) => Promise<AxiosResponse<unknown>>;
    /**
     * Required valid user authorization &lt;br/&gt; &lt;br&gt;load blocked players in a namespace based on user id &lt;br/&gt; Action Code: 50101
     */
    getPlayerUsersMeBlocked: () => Promise<AxiosResponse<GetAllPlayerBlockedUsersResponse>>;
    /**
     * Required valid user authorization &lt;br/&gt; unblock player in a namespace based on user id &lt;br/&gt;
     */
    createPlayerUserMeUnblock: (data: UnblockPlayerRequest$1) => Promise<AxiosResponse<unknown>>;
    /**
     * Required valid user authorization &lt;br/&gt; &lt;br&gt;load get players who blocked this player in a namespace based on user id &lt;br/&gt; Action Code: 50101
     */
    getPlayerUsersMeBlockedBy: () => Promise<AxiosResponse<GetAllPlayerBlockedByUsersResponse>>;
};

/**
 * AUTO GENERATED
 */

declare function PresenceApi(sdk: AccelByteSDK, args?: SdkSetConfigParam): {
    /**
     * Query users presence with given namespace and userIds.
     */
    getPresenceUsersPresence: (queryParams: {
        userIds: string | null;
        countOnly?: boolean | null;
    }) => Promise<AxiosResponse<GetUsersPresenceResponse>>;
    /**
     * Query users presence with given namespace and userIds.
     */
    createPresenceUserPresence: (data: RequestUserPresence, queryParams?: {
        countOnly?: boolean | null;
    }) => Promise<AxiosResponse<GetUsersPresenceResponse>>;
};

/**
 * AUTO GENERATED
 */

declare const AcceptFriendsRequest: z.ZodObject<{
    type: z.ZodLiteral<"acceptFriendsRequest">;
    friendId: z.ZodString;
    id: z.ZodString;
}, "strip", z.ZodTypeAny, {
    type: "acceptFriendsRequest";
    friendId: string;
    id: string;
}, {
    type: "acceptFriendsRequest";
    friendId: string;
    id: string;
}>;
type AcceptFriendsRequest = z.infer<typeof AcceptFriendsRequest>;
declare const BlockPlayerRequest: z.ZodObject<{
    type: z.ZodLiteral<"blockPlayerRequest">;
    blockUserId: z.ZodString;
    id: z.ZodString;
    namespace: z.ZodString;
}, "strip", z.ZodTypeAny, {
    namespace: string;
    type: "blockPlayerRequest";
    id: string;
    blockUserId: string;
}, {
    namespace: string;
    type: "blockPlayerRequest";
    id: string;
    blockUserId: string;
}>;
type BlockPlayerRequest = z.infer<typeof BlockPlayerRequest>;
declare const CancelFriendsRequest: z.ZodObject<{
    type: z.ZodLiteral<"cancelFriendsRequest">;
    friendId: z.ZodString;
    id: z.ZodString;
}, "strip", z.ZodTypeAny, {
    type: "cancelFriendsRequest";
    friendId: string;
    id: string;
}, {
    type: "cancelFriendsRequest";
    friendId: string;
    id: string;
}>;
type CancelFriendsRequest = z.infer<typeof CancelFriendsRequest>;
declare const CancelMatchmakingRequest: z.ZodObject<{
    type: z.ZodLiteral<"cancelMatchmakingRequest">;
    gameMode: z.ZodString;
    id: z.ZodString;
    isTempParty: z.ZodBoolean;
}, "strip", z.ZodTypeAny, {
    type: "cancelMatchmakingRequest";
    id: string;
    gameMode: string;
    isTempParty: boolean;
}, {
    type: "cancelMatchmakingRequest";
    id: string;
    gameMode: string;
    isTempParty: boolean;
}>;
type CancelMatchmakingRequest = z.infer<typeof CancelMatchmakingRequest>;
declare const ClientResetRequest: z.ZodObject<{
    type: z.ZodLiteral<"clientResetRequest">;
    namespace: z.ZodString;
    userId: z.ZodString;
}, "strip", z.ZodTypeAny, {
    namespace: string;
    type: "clientResetRequest";
    userId: string;
}, {
    namespace: string;
    type: "clientResetRequest";
    userId: string;
}>;
type ClientResetRequest = z.infer<typeof ClientResetRequest>;
declare const FriendsStatusRequest: z.ZodObject<{
    type: z.ZodLiteral<"friendsStatusRequest">;
    id: z.ZodString;
}, "strip", z.ZodTypeAny, {
    type: "friendsStatusRequest";
    id: string;
}, {
    type: "friendsStatusRequest";
    id: string;
}>;
type FriendsStatusRequest = z.infer<typeof FriendsStatusRequest>;
declare const GetAllSessionAttributeRequest: z.ZodObject<{
    type: z.ZodLiteral<"getAllSessionAttributeRequest">;
    id: z.ZodString;
}, "strip", z.ZodTypeAny, {
    type: "getAllSessionAttributeRequest";
    id: string;
}, {
    type: "getAllSessionAttributeRequest";
    id: string;
}>;
type GetAllSessionAttributeRequest = z.infer<typeof GetAllSessionAttributeRequest>;
declare const GetFriendshipStatusRequest: z.ZodObject<{
    type: z.ZodLiteral<"getFriendshipStatusRequest">;
    friendId: z.ZodString;
    id: z.ZodString;
}, "strip", z.ZodTypeAny, {
    type: "getFriendshipStatusRequest";
    friendId: string;
    id: string;
}, {
    type: "getFriendshipStatusRequest";
    friendId: string;
    id: string;
}>;
type GetFriendshipStatusRequest = z.infer<typeof GetFriendshipStatusRequest>;
declare const GetSessionAttributeRequest: z.ZodObject<{
    type: z.ZodLiteral<"getSessionAttributeRequest">;
    id: z.ZodString;
    key: z.ZodString;
}, "strip", z.ZodTypeAny, {
    type: "getSessionAttributeRequest";
    key: string;
    id: string;
}, {
    type: "getSessionAttributeRequest";
    key: string;
    id: string;
}>;
type GetSessionAttributeRequest = z.infer<typeof GetSessionAttributeRequest>;
declare const JoinDefaultChannelRequest: z.ZodObject<{
    type: z.ZodLiteral<"joinDefaultChannelRequest">;
    id: z.ZodString;
}, "strip", z.ZodTypeAny, {
    type: "joinDefaultChannelRequest";
    id: string;
}, {
    type: "joinDefaultChannelRequest";
    id: string;
}>;
type JoinDefaultChannelRequest = z.infer<typeof JoinDefaultChannelRequest>;
declare const ListIncomingFriendsRequest: z.ZodObject<{
    type: z.ZodLiteral<"listIncomingFriendsRequest">;
    id: z.ZodString;
}, "strip", z.ZodTypeAny, {
    type: "listIncomingFriendsRequest";
    id: string;
}, {
    type: "listIncomingFriendsRequest";
    id: string;
}>;
type ListIncomingFriendsRequest = z.infer<typeof ListIncomingFriendsRequest>;
declare const ListOfFriendsRequest: z.ZodObject<{
    type: z.ZodLiteral<"listOfFriendsRequest">;
    friendId: z.ZodString;
    id: z.ZodString;
}, "strip", z.ZodTypeAny, {
    type: "listOfFriendsRequest";
    friendId: string;
    id: string;
}, {
    type: "listOfFriendsRequest";
    friendId: string;
    id: string;
}>;
type ListOfFriendsRequest = z.infer<typeof ListOfFriendsRequest>;
declare const ListOnlineFriendsRequest: z.ZodObject<{
    type: z.ZodLiteral<"listOnlineFriendsRequest">;
    id: z.ZodString;
}, "strip", z.ZodTypeAny, {
    type: "listOnlineFriendsRequest";
    id: string;
}, {
    type: "listOnlineFriendsRequest";
    id: string;
}>;
type ListOnlineFriendsRequest = z.infer<typeof ListOnlineFriendsRequest>;
declare const ListOutgoingFriendsRequest: z.ZodObject<{
    type: z.ZodLiteral<"listOutgoingFriendsRequest">;
    id: z.ZodString;
}, "strip", z.ZodTypeAny, {
    type: "listOutgoingFriendsRequest";
    id: string;
}, {
    type: "listOutgoingFriendsRequest";
    id: string;
}>;
type ListOutgoingFriendsRequest = z.infer<typeof ListOutgoingFriendsRequest>;
declare const OfflineNotificationRequest: z.ZodObject<{
    type: z.ZodLiteral<"offlineNotificationRequest">;
    id: z.ZodString;
}, "strip", z.ZodTypeAny, {
    type: "offlineNotificationRequest";
    id: string;
}, {
    type: "offlineNotificationRequest";
    id: string;
}>;
type OfflineNotificationRequest = z.infer<typeof OfflineNotificationRequest>;
declare const PartyChatRequest: z.ZodObject<{
    type: z.ZodLiteral<"partyChatRequest">;
    from: z.ZodString;
    id: z.ZodString;
    payload: z.ZodString;
    receivedAt: z.ZodString;
    to: z.ZodString;
}, "strip", z.ZodTypeAny, {
    type: "partyChatRequest";
    from: string;
    id: string;
    payload: string;
    to: string;
    receivedAt: string;
}, {
    type: "partyChatRequest";
    from: string;
    id: string;
    payload: string;
    to: string;
    receivedAt: string;
}>;
type PartyChatRequest = z.infer<typeof PartyChatRequest>;
declare const PartyCreateRequest: z.ZodObject<{
    type: z.ZodLiteral<"partyCreateRequest">;
    id: z.ZodString;
}, "strip", z.ZodTypeAny, {
    type: "partyCreateRequest";
    id: string;
}, {
    type: "partyCreateRequest";
    id: string;
}>;
type PartyCreateRequest = z.infer<typeof PartyCreateRequest>;
declare const PartyInfoRequest: z.ZodObject<{
    type: z.ZodLiteral<"partyInfoRequest">;
    id: z.ZodString;
}, "strip", z.ZodTypeAny, {
    type: "partyInfoRequest";
    id: string;
}, {
    type: "partyInfoRequest";
    id: string;
}>;
type PartyInfoRequest = z.infer<typeof PartyInfoRequest>;
declare const PartyInviteRequest: z.ZodObject<{
    type: z.ZodLiteral<"partyInviteRequest">;
    friendId: z.ZodString;
    id: z.ZodString;
}, "strip", z.ZodTypeAny, {
    type: "partyInviteRequest";
    friendId: string;
    id: string;
}, {
    type: "partyInviteRequest";
    friendId: string;
    id: string;
}>;
type PartyInviteRequest = z.infer<typeof PartyInviteRequest>;
declare const PartyJoinRequest: z.ZodObject<{
    type: z.ZodLiteral<"partyJoinRequest">;
    id: z.ZodString;
    invitationToken: z.ZodString;
    partyId: z.ZodString;
}, "strip", z.ZodTypeAny, {
    type: "partyJoinRequest";
    partyId: string;
    id: string;
    invitationToken: string;
}, {
    type: "partyJoinRequest";
    partyId: string;
    id: string;
    invitationToken: string;
}>;
type PartyJoinRequest = z.infer<typeof PartyJoinRequest>;
declare const PartyKickRequest: z.ZodObject<{
    type: z.ZodLiteral<"partyKickRequest">;
    id: z.ZodString;
    memberId: z.ZodString;
}, "strip", z.ZodTypeAny, {
    type: "partyKickRequest";
    id: string;
    memberId: string;
}, {
    type: "partyKickRequest";
    id: string;
    memberId: string;
}>;
type PartyKickRequest = z.infer<typeof PartyKickRequest>;
declare const PartyLeaveRequest: z.ZodObject<{
    type: z.ZodLiteral<"partyLeaveRequest">;
    id: z.ZodString;
    ignoreUserRegistry: z.ZodBoolean;
}, "strip", z.ZodTypeAny, {
    type: "partyLeaveRequest";
    id: string;
    ignoreUserRegistry: boolean;
}, {
    type: "partyLeaveRequest";
    id: string;
    ignoreUserRegistry: boolean;
}>;
type PartyLeaveRequest = z.infer<typeof PartyLeaveRequest>;
declare const PartyPromoteLeaderRequest: z.ZodObject<{
    type: z.ZodLiteral<"partyPromoteLeaderRequest">;
    id: z.ZodString;
    newLeaderUserId: z.ZodString;
}, "strip", z.ZodTypeAny, {
    type: "partyPromoteLeaderRequest";
    id: string;
    newLeaderUserId: string;
}, {
    type: "partyPromoteLeaderRequest";
    id: string;
    newLeaderUserId: string;
}>;
type PartyPromoteLeaderRequest = z.infer<typeof PartyPromoteLeaderRequest>;
declare const PartyRejectRequest: z.ZodObject<{
    type: z.ZodLiteral<"partyRejectRequest">;
    id: z.ZodString;
    invitationToken: z.ZodString;
    partyId: z.ZodString;
}, "strip", z.ZodTypeAny, {
    type: "partyRejectRequest";
    partyId: string;
    id: string;
    invitationToken: string;
}, {
    type: "partyRejectRequest";
    partyId: string;
    id: string;
    invitationToken: string;
}>;
type PartyRejectRequest = z.infer<typeof PartyRejectRequest>;
declare const PersonalChatHistoryRequest: z.ZodObject<{
    type: z.ZodLiteral<"personalChatHistoryRequest">;
    friendId: z.ZodString;
    id: z.ZodString;
}, "strip", z.ZodTypeAny, {
    type: "personalChatHistoryRequest";
    friendId: string;
    id: string;
}, {
    type: "personalChatHistoryRequest";
    friendId: string;
    id: string;
}>;
type PersonalChatHistoryRequest = z.infer<typeof PersonalChatHistoryRequest>;
declare const PersonalChatRequest: z.ZodObject<{
    type: z.ZodLiteral<"personalChatRequest">;
    from: z.ZodString;
    id: z.ZodString;
    payload: z.ZodString;
    receivedAt: z.ZodString;
    to: z.ZodString;
}, "strip", z.ZodTypeAny, {
    type: "personalChatRequest";
    from: string;
    id: string;
    payload: string;
    to: string;
    receivedAt: string;
}, {
    type: "personalChatRequest";
    from: string;
    id: string;
    payload: string;
    to: string;
    receivedAt: string;
}>;
type PersonalChatRequest = z.infer<typeof PersonalChatRequest>;
declare const RefreshTokenRequest: z.ZodObject<{
    type: z.ZodLiteral<"refreshTokenRequest">;
    id: z.ZodString;
    token: z.ZodString;
}, "strip", z.ZodTypeAny, {
    type: "refreshTokenRequest";
    id: string;
    token: string;
}, {
    type: "refreshTokenRequest";
    id: string;
    token: string;
}>;
type RefreshTokenRequest = z.infer<typeof RefreshTokenRequest>;
declare const RejectFriendsRequest: z.ZodObject<{
    type: z.ZodLiteral<"rejectFriendsRequest">;
    friendId: z.ZodString;
    id: z.ZodString;
}, "strip", z.ZodTypeAny, {
    type: "rejectFriendsRequest";
    friendId: string;
    id: string;
}, {
    type: "rejectFriendsRequest";
    friendId: string;
    id: string;
}>;
type RejectFriendsRequest = z.infer<typeof RejectFriendsRequest>;
declare const RequestFriendsRequest: z.ZodObject<{
    type: z.ZodLiteral<"requestFriendsRequest">;
    friendId: z.ZodString;
    id: z.ZodString;
}, "strip", z.ZodTypeAny, {
    type: "requestFriendsRequest";
    friendId: string;
    id: string;
}, {
    type: "requestFriendsRequest";
    friendId: string;
    id: string;
}>;
type RequestFriendsRequest = z.infer<typeof RequestFriendsRequest>;
declare const SendChannelChatRequest: z.ZodObject<{
    type: z.ZodLiteral<"sendChannelChatRequest">;
    channelSlug: z.ZodString;
    id: z.ZodString;
    payload: z.ZodString;
}, "strip", z.ZodTypeAny, {
    type: "sendChannelChatRequest";
    id: string;
    payload: string;
    channelSlug: string;
}, {
    type: "sendChannelChatRequest";
    id: string;
    payload: string;
    channelSlug: string;
}>;
type SendChannelChatRequest = z.infer<typeof SendChannelChatRequest>;
declare const SetReadyConsentRequest: z.ZodObject<{
    type: z.ZodLiteral<"setReadyConsentRequest">;
    id: z.ZodString;
    matchId: z.ZodString;
}, "strip", z.ZodTypeAny, {
    type: "setReadyConsentRequest";
    id: string;
    matchId: string;
}, {
    type: "setReadyConsentRequest";
    id: string;
    matchId: string;
}>;
type SetReadyConsentRequest = z.infer<typeof SetReadyConsentRequest>;
declare const SetSessionAttributeRequest: z.ZodObject<{
    type: z.ZodLiteral<"setSessionAttributeRequest">;
    id: z.ZodString;
    key: z.ZodString;
    namespace: z.ZodString;
    value: z.ZodString;
}, "strip", z.ZodTypeAny, {
    namespace: string;
    type: "setSessionAttributeRequest";
    value: string;
    key: string;
    id: string;
}, {
    namespace: string;
    type: "setSessionAttributeRequest";
    value: string;
    key: string;
    id: string;
}>;
type SetSessionAttributeRequest = z.infer<typeof SetSessionAttributeRequest>;
declare const SetUserStatusRequest: z.ZodObject<{
    type: z.ZodLiteral<"setUserStatusRequest">;
    activity: z.ZodString;
    availability: z.ZodNumber;
    id: z.ZodString;
}, "strip", z.ZodTypeAny, {
    type: "setUserStatusRequest";
    activity: string;
    availability: number;
    id: string;
}, {
    type: "setUserStatusRequest";
    activity: string;
    availability: number;
    id: string;
}>;
type SetUserStatusRequest = z.infer<typeof SetUserStatusRequest>;
declare const StartMatchmakingRequest: z.ZodObject<{
    type: z.ZodLiteral<"startMatchmakingRequest">;
    extraAttributes: z.ZodString;
    gameMode: z.ZodString;
    id: z.ZodString;
    partyAttributes: z.ZodAny;
    priority: z.ZodNumber;
    tempParty: z.ZodString;
}, "strip", z.ZodTypeAny, {
    type: "startMatchmakingRequest";
    id: string;
    gameMode: string;
    extraAttributes: string;
    priority: number;
    tempParty: string;
    partyAttributes?: any;
}, {
    type: "startMatchmakingRequest";
    id: string;
    gameMode: string;
    extraAttributes: string;
    priority: number;
    tempParty: string;
    partyAttributes?: any;
}>;
type StartMatchmakingRequest = z.infer<typeof StartMatchmakingRequest>;
declare const UnblockPlayerRequest: z.ZodObject<{
    type: z.ZodLiteral<"unblockPlayerRequest">;
    id: z.ZodString;
    namespace: z.ZodString;
    unblockedUserId: z.ZodString;
}, "strip", z.ZodTypeAny, {
    namespace: string;
    type: "unblockPlayerRequest";
    id: string;
    unblockedUserId: string;
}, {
    namespace: string;
    type: "unblockPlayerRequest";
    id: string;
    unblockedUserId: string;
}>;
type UnblockPlayerRequest = z.infer<typeof UnblockPlayerRequest>;
declare const UnfriendRequest: z.ZodObject<{
    type: z.ZodLiteral<"unfriendRequest">;
    friendId: z.ZodString;
    id: z.ZodString;
}, "strip", z.ZodTypeAny, {
    type: "unfriendRequest";
    friendId: string;
    id: string;
}, {
    type: "unfriendRequest";
    friendId: string;
    id: string;
}>;
type UnfriendRequest = z.infer<typeof UnfriendRequest>;
declare const UserMetricRequest: z.ZodObject<{
    type: z.ZodLiteral<"userMetricRequest">;
    id: z.ZodString;
}, "strip", z.ZodTypeAny, {
    type: "userMetricRequest";
    id: string;
}, {
    type: "userMetricRequest";
    id: string;
}>;
type UserMetricRequest = z.infer<typeof UserMetricRequest>;
declare const WebSocketRequest: z.ZodDiscriminatedUnion<"type", [z.ZodObject<{
    type: z.ZodLiteral<"acceptFriendsRequest">;
    friendId: z.ZodString;
    id: z.ZodString;
}, "strip", z.ZodTypeAny, {
    type: "acceptFriendsRequest";
    friendId: string;
    id: string;
}, {
    type: "acceptFriendsRequest";
    friendId: string;
    id: string;
}>, z.ZodObject<{
    type: z.ZodLiteral<"blockPlayerRequest">;
    blockUserId: z.ZodString;
    id: z.ZodString;
    namespace: z.ZodString;
}, "strip", z.ZodTypeAny, {
    namespace: string;
    type: "blockPlayerRequest";
    id: string;
    blockUserId: string;
}, {
    namespace: string;
    type: "blockPlayerRequest";
    id: string;
    blockUserId: string;
}>, z.ZodObject<{
    type: z.ZodLiteral<"cancelFriendsRequest">;
    friendId: z.ZodString;
    id: z.ZodString;
}, "strip", z.ZodTypeAny, {
    type: "cancelFriendsRequest";
    friendId: string;
    id: string;
}, {
    type: "cancelFriendsRequest";
    friendId: string;
    id: string;
}>, z.ZodObject<{
    type: z.ZodLiteral<"cancelMatchmakingRequest">;
    gameMode: z.ZodString;
    id: z.ZodString;
    isTempParty: z.ZodBoolean;
}, "strip", z.ZodTypeAny, {
    type: "cancelMatchmakingRequest";
    id: string;
    gameMode: string;
    isTempParty: boolean;
}, {
    type: "cancelMatchmakingRequest";
    id: string;
    gameMode: string;
    isTempParty: boolean;
}>, z.ZodObject<{
    type: z.ZodLiteral<"clientResetRequest">;
    namespace: z.ZodString;
    userId: z.ZodString;
}, "strip", z.ZodTypeAny, {
    namespace: string;
    type: "clientResetRequest";
    userId: string;
}, {
    namespace: string;
    type: "clientResetRequest";
    userId: string;
}>, z.ZodObject<{
    type: z.ZodLiteral<"friendsStatusRequest">;
    id: z.ZodString;
}, "strip", z.ZodTypeAny, {
    type: "friendsStatusRequest";
    id: string;
}, {
    type: "friendsStatusRequest";
    id: string;
}>, z.ZodObject<{
    type: z.ZodLiteral<"getAllSessionAttributeRequest">;
    id: z.ZodString;
}, "strip", z.ZodTypeAny, {
    type: "getAllSessionAttributeRequest";
    id: string;
}, {
    type: "getAllSessionAttributeRequest";
    id: string;
}>, z.ZodObject<{
    type: z.ZodLiteral<"getFriendshipStatusRequest">;
    friendId: z.ZodString;
    id: z.ZodString;
}, "strip", z.ZodTypeAny, {
    type: "getFriendshipStatusRequest";
    friendId: string;
    id: string;
}, {
    type: "getFriendshipStatusRequest";
    friendId: string;
    id: string;
}>, z.ZodObject<{
    type: z.ZodLiteral<"getSessionAttributeRequest">;
    id: z.ZodString;
    key: z.ZodString;
}, "strip", z.ZodTypeAny, {
    type: "getSessionAttributeRequest";
    key: string;
    id: string;
}, {
    type: "getSessionAttributeRequest";
    key: string;
    id: string;
}>, z.ZodObject<{
    type: z.ZodLiteral<"joinDefaultChannelRequest">;
    id: z.ZodString;
}, "strip", z.ZodTypeAny, {
    type: "joinDefaultChannelRequest";
    id: string;
}, {
    type: "joinDefaultChannelRequest";
    id: string;
}>, z.ZodObject<{
    type: z.ZodLiteral<"listIncomingFriendsRequest">;
    id: z.ZodString;
}, "strip", z.ZodTypeAny, {
    type: "listIncomingFriendsRequest";
    id: string;
}, {
    type: "listIncomingFriendsRequest";
    id: string;
}>, z.ZodObject<{
    type: z.ZodLiteral<"listOfFriendsRequest">;
    friendId: z.ZodString;
    id: z.ZodString;
}, "strip", z.ZodTypeAny, {
    type: "listOfFriendsRequest";
    friendId: string;
    id: string;
}, {
    type: "listOfFriendsRequest";
    friendId: string;
    id: string;
}>, z.ZodObject<{
    type: z.ZodLiteral<"listOnlineFriendsRequest">;
    id: z.ZodString;
}, "strip", z.ZodTypeAny, {
    type: "listOnlineFriendsRequest";
    id: string;
}, {
    type: "listOnlineFriendsRequest";
    id: string;
}>, z.ZodObject<{
    type: z.ZodLiteral<"listOutgoingFriendsRequest">;
    id: z.ZodString;
}, "strip", z.ZodTypeAny, {
    type: "listOutgoingFriendsRequest";
    id: string;
}, {
    type: "listOutgoingFriendsRequest";
    id: string;
}>, z.ZodObject<{
    type: z.ZodLiteral<"offlineNotificationRequest">;
    id: z.ZodString;
}, "strip", z.ZodTypeAny, {
    type: "offlineNotificationRequest";
    id: string;
}, {
    type: "offlineNotificationRequest";
    id: string;
}>, z.ZodObject<{
    type: z.ZodLiteral<"partyChatRequest">;
    from: z.ZodString;
    id: z.ZodString;
    payload: z.ZodString;
    receivedAt: z.ZodString;
    to: z.ZodString;
}, "strip", z.ZodTypeAny, {
    type: "partyChatRequest";
    from: string;
    id: string;
    payload: string;
    to: string;
    receivedAt: string;
}, {
    type: "partyChatRequest";
    from: string;
    id: string;
    payload: string;
    to: string;
    receivedAt: string;
}>, z.ZodObject<{
    type: z.ZodLiteral<"partyCreateRequest">;
    id: z.ZodString;
}, "strip", z.ZodTypeAny, {
    type: "partyCreateRequest";
    id: string;
}, {
    type: "partyCreateRequest";
    id: string;
}>, z.ZodObject<{
    type: z.ZodLiteral<"partyInfoRequest">;
    id: z.ZodString;
}, "strip", z.ZodTypeAny, {
    type: "partyInfoRequest";
    id: string;
}, {
    type: "partyInfoRequest";
    id: string;
}>, z.ZodObject<{
    type: z.ZodLiteral<"partyInviteRequest">;
    friendId: z.ZodString;
    id: z.ZodString;
}, "strip", z.ZodTypeAny, {
    type: "partyInviteRequest";
    friendId: string;
    id: string;
}, {
    type: "partyInviteRequest";
    friendId: string;
    id: string;
}>, z.ZodObject<{
    type: z.ZodLiteral<"partyJoinRequest">;
    id: z.ZodString;
    invitationToken: z.ZodString;
    partyId: z.ZodString;
}, "strip", z.ZodTypeAny, {
    type: "partyJoinRequest";
    partyId: string;
    id: string;
    invitationToken: string;
}, {
    type: "partyJoinRequest";
    partyId: string;
    id: string;
    invitationToken: string;
}>, z.ZodObject<{
    type: z.ZodLiteral<"partyKickRequest">;
    id: z.ZodString;
    memberId: z.ZodString;
}, "strip", z.ZodTypeAny, {
    type: "partyKickRequest";
    id: string;
    memberId: string;
}, {
    type: "partyKickRequest";
    id: string;
    memberId: string;
}>, z.ZodObject<{
    type: z.ZodLiteral<"partyLeaveRequest">;
    id: z.ZodString;
    ignoreUserRegistry: z.ZodBoolean;
}, "strip", z.ZodTypeAny, {
    type: "partyLeaveRequest";
    id: string;
    ignoreUserRegistry: boolean;
}, {
    type: "partyLeaveRequest";
    id: string;
    ignoreUserRegistry: boolean;
}>, z.ZodObject<{
    type: z.ZodLiteral<"partyPromoteLeaderRequest">;
    id: z.ZodString;
    newLeaderUserId: z.ZodString;
}, "strip", z.ZodTypeAny, {
    type: "partyPromoteLeaderRequest";
    id: string;
    newLeaderUserId: string;
}, {
    type: "partyPromoteLeaderRequest";
    id: string;
    newLeaderUserId: string;
}>, z.ZodObject<{
    type: z.ZodLiteral<"partyRejectRequest">;
    id: z.ZodString;
    invitationToken: z.ZodString;
    partyId: z.ZodString;
}, "strip", z.ZodTypeAny, {
    type: "partyRejectRequest";
    partyId: string;
    id: string;
    invitationToken: string;
}, {
    type: "partyRejectRequest";
    partyId: string;
    id: string;
    invitationToken: string;
}>, z.ZodObject<{
    type: z.ZodLiteral<"personalChatHistoryRequest">;
    friendId: z.ZodString;
    id: z.ZodString;
}, "strip", z.ZodTypeAny, {
    type: "personalChatHistoryRequest";
    friendId: string;
    id: string;
}, {
    type: "personalChatHistoryRequest";
    friendId: string;
    id: string;
}>, z.ZodObject<{
    type: z.ZodLiteral<"personalChatRequest">;
    from: z.ZodString;
    id: z.ZodString;
    payload: z.ZodString;
    receivedAt: z.ZodString;
    to: z.ZodString;
}, "strip", z.ZodTypeAny, {
    type: "personalChatRequest";
    from: string;
    id: string;
    payload: string;
    to: string;
    receivedAt: string;
}, {
    type: "personalChatRequest";
    from: string;
    id: string;
    payload: string;
    to: string;
    receivedAt: string;
}>, z.ZodObject<{
    type: z.ZodLiteral<"refreshTokenRequest">;
    id: z.ZodString;
    token: z.ZodString;
}, "strip", z.ZodTypeAny, {
    type: "refreshTokenRequest";
    id: string;
    token: string;
}, {
    type: "refreshTokenRequest";
    id: string;
    token: string;
}>, z.ZodObject<{
    type: z.ZodLiteral<"rejectFriendsRequest">;
    friendId: z.ZodString;
    id: z.ZodString;
}, "strip", z.ZodTypeAny, {
    type: "rejectFriendsRequest";
    friendId: string;
    id: string;
}, {
    type: "rejectFriendsRequest";
    friendId: string;
    id: string;
}>, z.ZodObject<{
    type: z.ZodLiteral<"requestFriendsRequest">;
    friendId: z.ZodString;
    id: z.ZodString;
}, "strip", z.ZodTypeAny, {
    type: "requestFriendsRequest";
    friendId: string;
    id: string;
}, {
    type: "requestFriendsRequest";
    friendId: string;
    id: string;
}>, z.ZodObject<{
    type: z.ZodLiteral<"sendChannelChatRequest">;
    channelSlug: z.ZodString;
    id: z.ZodString;
    payload: z.ZodString;
}, "strip", z.ZodTypeAny, {
    type: "sendChannelChatRequest";
    id: string;
    payload: string;
    channelSlug: string;
}, {
    type: "sendChannelChatRequest";
    id: string;
    payload: string;
    channelSlug: string;
}>, z.ZodObject<{
    type: z.ZodLiteral<"setReadyConsentRequest">;
    id: z.ZodString;
    matchId: z.ZodString;
}, "strip", z.ZodTypeAny, {
    type: "setReadyConsentRequest";
    id: string;
    matchId: string;
}, {
    type: "setReadyConsentRequest";
    id: string;
    matchId: string;
}>, z.ZodObject<{
    type: z.ZodLiteral<"setSessionAttributeRequest">;
    id: z.ZodString;
    key: z.ZodString;
    namespace: z.ZodString;
    value: z.ZodString;
}, "strip", z.ZodTypeAny, {
    namespace: string;
    type: "setSessionAttributeRequest";
    value: string;
    key: string;
    id: string;
}, {
    namespace: string;
    type: "setSessionAttributeRequest";
    value: string;
    key: string;
    id: string;
}>, z.ZodObject<{
    type: z.ZodLiteral<"setUserStatusRequest">;
    activity: z.ZodString;
    availability: z.ZodNumber;
    id: z.ZodString;
}, "strip", z.ZodTypeAny, {
    type: "setUserStatusRequest";
    activity: string;
    availability: number;
    id: string;
}, {
    type: "setUserStatusRequest";
    activity: string;
    availability: number;
    id: string;
}>, z.ZodObject<{
    type: z.ZodLiteral<"startMatchmakingRequest">;
    extraAttributes: z.ZodString;
    gameMode: z.ZodString;
    id: z.ZodString;
    partyAttributes: z.ZodAny;
    priority: z.ZodNumber;
    tempParty: z.ZodString;
}, "strip", z.ZodTypeAny, {
    type: "startMatchmakingRequest";
    id: string;
    gameMode: string;
    extraAttributes: string;
    priority: number;
    tempParty: string;
    partyAttributes?: any;
}, {
    type: "startMatchmakingRequest";
    id: string;
    gameMode: string;
    extraAttributes: string;
    priority: number;
    tempParty: string;
    partyAttributes?: any;
}>, z.ZodObject<{
    type: z.ZodLiteral<"unblockPlayerRequest">;
    id: z.ZodString;
    namespace: z.ZodString;
    unblockedUserId: z.ZodString;
}, "strip", z.ZodTypeAny, {
    namespace: string;
    type: "unblockPlayerRequest";
    id: string;
    unblockedUserId: string;
}, {
    namespace: string;
    type: "unblockPlayerRequest";
    id: string;
    unblockedUserId: string;
}>, z.ZodObject<{
    type: z.ZodLiteral<"unfriendRequest">;
    friendId: z.ZodString;
    id: z.ZodString;
}, "strip", z.ZodTypeAny, {
    type: "unfriendRequest";
    friendId: string;
    id: string;
}, {
    type: "unfriendRequest";
    friendId: string;
    id: string;
}>, z.ZodObject<{
    type: z.ZodLiteral<"userMetricRequest">;
    id: z.ZodString;
}, "strip", z.ZodTypeAny, {
    type: "userMetricRequest";
    id: string;
}, {
    type: "userMetricRequest";
    id: string;
}>]>;
type WebSocketRequest = z.infer<typeof WebSocketRequest>;
declare const WebSocketResponseOrNotification: z.ZodDiscriminatedUnion<"type", [z.ZodObject<{
    type: z.ZodLiteral<"acceptFriendsNotif">;
    friendId: z.ZodString;
}, "strip", z.ZodTypeAny, {
    type: "acceptFriendsNotif";
    friendId: string;
}, {
    type: "acceptFriendsNotif";
    friendId: string;
}>, z.ZodObject<{
    type: z.ZodLiteral<"acceptFriendsResponse">;
    code: z.ZodNumber;
    id: z.ZodString;
}, "strip", z.ZodTypeAny, {
    type: "acceptFriendsResponse";
    code: number;
    id: string;
}, {
    type: "acceptFriendsResponse";
    code: number;
    id: string;
}>, z.ZodObject<{
    type: z.ZodLiteral<"blockPlayerNotif">;
    blockedUserId: z.ZodString;
    userId: z.ZodString;
}, "strip", z.ZodTypeAny, {
    type: "blockPlayerNotif";
    userId: string;
    blockedUserId: string;
}, {
    type: "blockPlayerNotif";
    userId: string;
    blockedUserId: string;
}>, z.ZodObject<{
    type: z.ZodLiteral<"blockPlayerResponse">;
    blockUserId: z.ZodString;
    code: z.ZodNumber;
    id: z.ZodString;
    namespace: z.ZodString;
}, "strip", z.ZodTypeAny, {
    namespace: string;
    type: "blockPlayerResponse";
    code: number;
    id: string;
    blockUserId: string;
}, {
    namespace: string;
    type: "blockPlayerResponse";
    code: number;
    id: string;
    blockUserId: string;
}>, z.ZodObject<{
    type: z.ZodLiteral<"cancelFriendsNotif">;
    userId: z.ZodString;
}, "strip", z.ZodTypeAny, {
    type: "cancelFriendsNotif";
    userId: string;
}, {
    type: "cancelFriendsNotif";
    userId: string;
}>, z.ZodObject<{
    type: z.ZodLiteral<"cancelFriendsResponse">;
    code: z.ZodNumber;
    id: z.ZodString;
}, "strip", z.ZodTypeAny, {
    type: "cancelFriendsResponse";
    code: number;
    id: string;
}, {
    type: "cancelFriendsResponse";
    code: number;
    id: string;
}>, z.ZodObject<{
    type: z.ZodLiteral<"cancelMatchmakingResponse">;
    code: z.ZodNumber;
    id: z.ZodString;
}, "strip", z.ZodTypeAny, {
    type: "cancelMatchmakingResponse";
    code: number;
    id: string;
}, {
    type: "cancelMatchmakingResponse";
    code: number;
    id: string;
}>, z.ZodObject<{
    type: z.ZodLiteral<"channelChatNotif">;
    channelSlug: z.ZodString;
    from: z.ZodString;
    payload: z.ZodString;
    sentAt: z.ZodString;
}, "strip", z.ZodTypeAny, {
    type: "channelChatNotif";
    from: string;
    payload: string;
    sentAt: string;
    channelSlug: string;
}, {
    type: "channelChatNotif";
    from: string;
    payload: string;
    sentAt: string;
    channelSlug: string;
}>, z.ZodObject<{
    type: z.ZodLiteral<"connectNotif">;
    lobbySessionID: z.ZodString;
}, "strip", z.ZodTypeAny, {
    type: "connectNotif";
    lobbySessionID: string;
}, {
    type: "connectNotif";
    lobbySessionID: string;
}>, z.ZodObject<{
    type: z.ZodLiteral<"disconnectNotif">;
    connectionId: z.ZodString;
    namespace: z.ZodString;
}, "strip", z.ZodTypeAny, {
    namespace: string;
    type: "disconnectNotif";
    connectionId: string;
}, {
    namespace: string;
    type: "disconnectNotif";
    connectionId: string;
}>, z.ZodObject<{
    type: z.ZodLiteral<"dsNotif">;
    alternateIps: z.ZodArray<z.ZodString, "many">;
    customAttribute: z.ZodString;
    deployment: z.ZodString;
    gameVersion: z.ZodString;
    imageVersion: z.ZodString;
    ip: z.ZodString;
    isOK: z.ZodBoolean;
    isOverrideGameVersion: z.ZodBoolean;
    lastUpdate: z.ZodString;
    matchId: z.ZodString;
    message: z.ZodString;
    namespace: z.ZodString;
    podName: z.ZodString;
    port: z.ZodNumber;
    ports: z.ZodAny;
    protocol: z.ZodString;
    provider: z.ZodString;
    region: z.ZodString;
    sessionId: z.ZodString;
    status: z.ZodString;
}, "strip", z.ZodTypeAny, {
    namespace: string;
    type: "dsNotif";
    message: string;
    status: string;
    alternateIps: string[];
    customAttribute: string;
    deployment: string;
    gameVersion: string;
    imageVersion: string;
    ip: string;
    isOK: boolean;
    isOverrideGameVersion: boolean;
    lastUpdate: string;
    matchId: string;
    podName: string;
    port: number;
    protocol: string;
    provider: string;
    region: string;
    sessionId: string;
    ports?: any;
}, {
    namespace: string;
    type: "dsNotif";
    message: string;
    status: string;
    alternateIps: string[];
    customAttribute: string;
    deployment: string;
    gameVersion: string;
    imageVersion: string;
    ip: string;
    isOK: boolean;
    isOverrideGameVersion: boolean;
    lastUpdate: string;
    matchId: string;
    podName: string;
    port: number;
    protocol: string;
    provider: string;
    region: string;
    sessionId: string;
    ports?: any;
}>, z.ZodObject<{
    type: z.ZodLiteral<"errorNotif">;
    message: z.ZodString;
}, "strip", z.ZodTypeAny, {
    type: "errorNotif";
    message: string;
}, {
    type: "errorNotif";
    message: string;
}>, z.ZodObject<{
    type: z.ZodLiteral<"friendsStatusResponse">;
    activity: z.ZodArray<z.ZodString, "many">;
    availability: z.ZodArray<z.ZodString, "many">;
    code: z.ZodNumber;
    friendIds: z.ZodArray<z.ZodString, "many">;
    id: z.ZodString;
    lastSeenAt: z.ZodArray<z.ZodString, "many">;
}, "strip", z.ZodTypeAny, {
    type: "friendsStatusResponse";
    code: number;
    friendIds: string[];
    activity: string[];
    availability: string[];
    lastSeenAt: string[];
    id: string;
}, {
    type: "friendsStatusResponse";
    code: number;
    friendIds: string[];
    activity: string[];
    availability: string[];
    lastSeenAt: string[];
    id: string;
}>, z.ZodObject<{
    type: z.ZodLiteral<"getAllSessionAttributeResponse">;
    attributes: z.ZodAny;
    code: z.ZodNumber;
    id: z.ZodString;
}, "strip", z.ZodTypeAny, {
    type: "getAllSessionAttributeResponse";
    code: number;
    id: string;
    attributes?: any;
}, {
    type: "getAllSessionAttributeResponse";
    code: number;
    id: string;
    attributes?: any;
}>, z.ZodObject<{
    type: z.ZodLiteral<"getFriendshipStatusResponse">;
    code: z.ZodNumber;
    friendshipStatus: z.ZodString;
    id: z.ZodString;
}, "strip", z.ZodTypeAny, {
    type: "getFriendshipStatusResponse";
    code: number;
    id: string;
    friendshipStatus: string;
}, {
    type: "getFriendshipStatusResponse";
    code: number;
    id: string;
    friendshipStatus: string;
}>, z.ZodObject<{
    type: z.ZodLiteral<"getSessionAttributeResponse">;
    code: z.ZodNumber;
    id: z.ZodString;
    value: z.ZodString;
}, "strip", z.ZodTypeAny, {
    type: "getSessionAttributeResponse";
    code: number;
    value: string;
    id: string;
}, {
    type: "getSessionAttributeResponse";
    code: number;
    value: string;
    id: string;
}>, z.ZodObject<{
    type: z.ZodLiteral<"joinDefaultChannelResponse">;
    channelSlug: z.ZodString;
    code: z.ZodNumber;
    id: z.ZodString;
}, "strip", z.ZodTypeAny, {
    type: "joinDefaultChannelResponse";
    code: number;
    id: string;
    channelSlug: string;
}, {
    type: "joinDefaultChannelResponse";
    code: number;
    id: string;
    channelSlug: string;
}>, z.ZodObject<{
    type: z.ZodLiteral<"listIncomingFriendsResponse">;
    code: z.ZodNumber;
    id: z.ZodString;
    userIds: z.ZodArray<z.ZodString, "many">;
}, "strip", z.ZodTypeAny, {
    type: "listIncomingFriendsResponse";
    code: number;
    userIds: string[];
    id: string;
}, {
    type: "listIncomingFriendsResponse";
    code: number;
    userIds: string[];
    id: string;
}>, z.ZodObject<{
    type: z.ZodLiteral<"listOfFriendsResponse">;
    code: z.ZodNumber;
    friendIds: z.ZodArray<z.ZodString, "many">;
    id: z.ZodString;
}, "strip", z.ZodTypeAny, {
    type: "listOfFriendsResponse";
    code: number;
    friendIds: string[];
    id: string;
}, {
    type: "listOfFriendsResponse";
    code: number;
    friendIds: string[];
    id: string;
}>, z.ZodObject<{
    type: z.ZodLiteral<"listOutgoingFriendsResponse">;
    code: z.ZodNumber;
    friendIds: z.ZodArray<z.ZodString, "many">;
    id: z.ZodString;
}, "strip", z.ZodTypeAny, {
    type: "listOutgoingFriendsResponse";
    code: number;
    friendIds: string[];
    id: string;
}, {
    type: "listOutgoingFriendsResponse";
    code: number;
    friendIds: string[];
    id: string;
}>, z.ZodObject<{
    type: z.ZodLiteral<"matchmakingNotif">;
    counterPartyMember: z.ZodArray<z.ZodString, "many">;
    matchId: z.ZodString;
    message: z.ZodString;
    partyMember: z.ZodArray<z.ZodString, "many">;
    readyDuration: z.ZodNumber;
    status: z.ZodString;
}, "strip", z.ZodTypeAny, {
    type: "matchmakingNotif";
    message: string;
    status: string;
    matchId: string;
    counterPartyMember: string[];
    partyMember: string[];
    readyDuration: number;
}, {
    type: "matchmakingNotif";
    message: string;
    status: string;
    matchId: string;
    counterPartyMember: string[];
    partyMember: string[];
    readyDuration: number;
}>, z.ZodObject<{
    type: z.ZodLiteral<"messageNotif">;
    from: z.ZodString;
    id: z.ZodString;
    payload: z.ZodString;
    sentAt: z.ZodString;
    to: z.ZodString;
    topic: z.ZodString;
}, "strip", z.ZodTypeAny, {
    type: "messageNotif";
    topic: string;
    from: string;
    id: string;
    payload: string;
    sentAt: string;
    to: string;
}, {
    type: "messageNotif";
    topic: string;
    from: string;
    id: string;
    payload: string;
    sentAt: string;
    to: string;
}>, z.ZodObject<{
    type: z.ZodLiteral<"messageSessionNotif">;
    from: z.ZodString;
    id: z.ZodString;
    payload: z.ZodString;
    sentAt: z.ZodString;
    to: z.ZodString;
    topic: z.ZodString;
}, "strip", z.ZodTypeAny, {
    type: "messageSessionNotif";
    topic: string;
    from: string;
    id: string;
    payload: string;
    sentAt: string;
    to: string;
}, {
    type: "messageSessionNotif";
    topic: string;
    from: string;
    id: string;
    payload: string;
    sentAt: string;
    to: string;
}>, z.ZodObject<{
    type: z.ZodLiteral<"offlineNotificationResponse">;
    code: z.ZodNumber;
    id: z.ZodString;
}, "strip", z.ZodTypeAny, {
    type: "offlineNotificationResponse";
    code: number;
    id: string;
}, {
    type: "offlineNotificationResponse";
    code: number;
    id: string;
}>, z.ZodObject<{
    type: z.ZodLiteral<"partyChatNotif">;
    from: z.ZodString;
    id: z.ZodString;
    payload: z.ZodString;
    receivedAt: z.ZodString;
    to: z.ZodString;
}, "strip", z.ZodTypeAny, {
    type: "partyChatNotif";
    from: string;
    id: string;
    payload: string;
    to: string;
    receivedAt: string;
}, {
    type: "partyChatNotif";
    from: string;
    id: string;
    payload: string;
    to: string;
    receivedAt: string;
}>, z.ZodObject<{
    type: z.ZodLiteral<"partyChatResponse">;
    code: z.ZodNumber;
    id: z.ZodString;
}, "strip", z.ZodTypeAny, {
    type: "partyChatResponse";
    code: number;
    id: string;
}, {
    type: "partyChatResponse";
    code: number;
    id: string;
}>, z.ZodObject<{
    type: z.ZodLiteral<"partyCreateResponse">;
    code: z.ZodNumber;
    id: z.ZodString;
    invitationToken: z.ZodString;
    invitees: z.ZodString;
    leaderId: z.ZodString;
    members: z.ZodString;
    partyId: z.ZodString;
}, "strip", z.ZodTypeAny, {
    type: "partyCreateResponse";
    code: number;
    invitees: string;
    members: string;
    partyId: string;
    id: string;
    invitationToken: string;
    leaderId: string;
}, {
    type: "partyCreateResponse";
    code: number;
    invitees: string;
    members: string;
    partyId: string;
    id: string;
    invitationToken: string;
    leaderId: string;
}>, z.ZodObject<{
    type: z.ZodLiteral<"partyDataUpdateNotif">;
    customAttributes: z.ZodAny;
    invitees: z.ZodArray<z.ZodString, "many">;
    leader: z.ZodString;
    members: z.ZodArray<z.ZodString, "many">;
    namespace: z.ZodString;
    partyId: z.ZodString;
    updatedAt: z.ZodString;
}, "strip", z.ZodTypeAny, {
    namespace: string;
    type: "partyDataUpdateNotif";
    updatedAt: string;
    invitees: string[];
    leader: string;
    members: string[];
    partyId: string;
    customAttributes?: any;
}, {
    namespace: string;
    type: "partyDataUpdateNotif";
    updatedAt: string;
    invitees: string[];
    leader: string;
    members: string[];
    partyId: string;
    customAttributes?: any;
}>, z.ZodObject<{
    type: z.ZodLiteral<"partyGetInvitedNotif">;
    from: z.ZodString;
    invitationToken: z.ZodString;
    partyId: z.ZodString;
}, "strip", z.ZodTypeAny, {
    type: "partyGetInvitedNotif";
    partyId: string;
    from: string;
    invitationToken: string;
}, {
    type: "partyGetInvitedNotif";
    partyId: string;
    from: string;
    invitationToken: string;
}>, z.ZodObject<{
    type: z.ZodLiteral<"partyInfoResponse">;
    code: z.ZodNumber;
    customAttributes: z.ZodAny;
    id: z.ZodString;
    invitationToken: z.ZodString;
    invitees: z.ZodString;
    leaderId: z.ZodString;
    members: z.ZodString;
    partyId: z.ZodString;
}, "strip", z.ZodTypeAny, {
    type: "partyInfoResponse";
    code: number;
    invitees: string;
    members: string;
    partyId: string;
    id: string;
    invitationToken: string;
    leaderId: string;
    customAttributes?: any;
}, {
    type: "partyInfoResponse";
    code: number;
    invitees: string;
    members: string;
    partyId: string;
    id: string;
    invitationToken: string;
    leaderId: string;
    customAttributes?: any;
}>, z.ZodObject<{
    type: z.ZodLiteral<"partyInviteNotif">;
    inviteeId: z.ZodString;
    inviterId: z.ZodString;
}, "strip", z.ZodTypeAny, {
    type: "partyInviteNotif";
    inviteeId: string;
    inviterId: string;
}, {
    type: "partyInviteNotif";
    inviteeId: string;
    inviterId: string;
}>, z.ZodObject<{
    type: z.ZodLiteral<"partyInviteResponse">;
    code: z.ZodNumber;
    id: z.ZodString;
}, "strip", z.ZodTypeAny, {
    type: "partyInviteResponse";
    code: number;
    id: string;
}, {
    type: "partyInviteResponse";
    code: number;
    id: string;
}>, z.ZodObject<{
    type: z.ZodLiteral<"partyJoinNotif">;
    userId: z.ZodString;
}, "strip", z.ZodTypeAny, {
    type: "partyJoinNotif";
    userId: string;
}, {
    type: "partyJoinNotif";
    userId: string;
}>, z.ZodObject<{
    type: z.ZodLiteral<"partyJoinResponse">;
    code: z.ZodNumber;
    id: z.ZodString;
    invitationToken: z.ZodString;
    invitees: z.ZodString;
    leaderId: z.ZodString;
    members: z.ZodString;
    partyId: z.ZodString;
}, "strip", z.ZodTypeAny, {
    type: "partyJoinResponse";
    code: number;
    invitees: string;
    members: string;
    partyId: string;
    id: string;
    invitationToken: string;
    leaderId: string;
}, {
    type: "partyJoinResponse";
    code: number;
    invitees: string;
    members: string;
    partyId: string;
    id: string;
    invitationToken: string;
    leaderId: string;
}>, z.ZodObject<{
    type: z.ZodLiteral<"partyKickNotif">;
    leaderId: z.ZodString;
    partyId: z.ZodString;
    userId: z.ZodString;
}, "strip", z.ZodTypeAny, {
    type: "partyKickNotif";
    userId: string;
    partyId: string;
    leaderId: string;
}, {
    type: "partyKickNotif";
    userId: string;
    partyId: string;
    leaderId: string;
}>, z.ZodObject<{
    type: z.ZodLiteral<"partyKickResponse">;
    code: z.ZodNumber;
    id: z.ZodString;
}, "strip", z.ZodTypeAny, {
    type: "partyKickResponse";
    code: number;
    id: string;
}, {
    type: "partyKickResponse";
    code: number;
    id: string;
}>, z.ZodObject<{
    type: z.ZodLiteral<"partyLeaveNotif">;
    leaderId: z.ZodString;
    userId: z.ZodString;
}, "strip", z.ZodTypeAny, {
    type: "partyLeaveNotif";
    userId: string;
    leaderId: string;
}, {
    type: "partyLeaveNotif";
    userId: string;
    leaderId: string;
}>, z.ZodObject<{
    type: z.ZodLiteral<"partyLeaveResponse">;
    code: z.ZodNumber;
    id: z.ZodString;
}, "strip", z.ZodTypeAny, {
    type: "partyLeaveResponse";
    code: number;
    id: string;
}, {
    type: "partyLeaveResponse";
    code: number;
    id: string;
}>, z.ZodObject<{
    type: z.ZodLiteral<"partyPromoteLeaderResponse">;
    code: z.ZodNumber;
    id: z.ZodString;
    invitationToken: z.ZodString;
    invitees: z.ZodString;
    leaderId: z.ZodString;
    members: z.ZodString;
    partyId: z.ZodString;
}, "strip", z.ZodTypeAny, {
    type: "partyPromoteLeaderResponse";
    code: number;
    invitees: string;
    members: string;
    partyId: string;
    id: string;
    invitationToken: string;
    leaderId: string;
}, {
    type: "partyPromoteLeaderResponse";
    code: number;
    invitees: string;
    members: string;
    partyId: string;
    id: string;
    invitationToken: string;
    leaderId: string;
}>, z.ZodObject<{
    type: z.ZodLiteral<"partyRejectNotif">;
    leaderId: z.ZodString;
    partyId: z.ZodString;
    userId: z.ZodString;
}, "strip", z.ZodTypeAny, {
    type: "partyRejectNotif";
    userId: string;
    partyId: string;
    leaderId: string;
}, {
    type: "partyRejectNotif";
    userId: string;
    partyId: string;
    leaderId: string;
}>, z.ZodObject<{
    type: z.ZodLiteral<"partyRejectResponse">;
    code: z.ZodNumber;
    id: z.ZodString;
    partyId: z.ZodString;
}, "strip", z.ZodTypeAny, {
    type: "partyRejectResponse";
    code: number;
    partyId: string;
    id: string;
}, {
    type: "partyRejectResponse";
    code: number;
    partyId: string;
    id: string;
}>, z.ZodObject<{
    type: z.ZodLiteral<"personalChatHistoryResponse">;
    chat: z.ZodString;
    code: z.ZodNumber;
    friendId: z.ZodString;
    id: z.ZodString;
}, "strip", z.ZodTypeAny, {
    type: "personalChatHistoryResponse";
    code: number;
    friendId: string;
    id: string;
    chat: string;
}, {
    type: "personalChatHistoryResponse";
    code: number;
    friendId: string;
    id: string;
    chat: string;
}>, z.ZodObject<{
    type: z.ZodLiteral<"personalChatNotif">;
    from: z.ZodString;
    id: z.ZodString;
    payload: z.ZodString;
    receivedAt: z.ZodString;
    to: z.ZodString;
}, "strip", z.ZodTypeAny, {
    type: "personalChatNotif";
    from: string;
    id: string;
    payload: string;
    to: string;
    receivedAt: string;
}, {
    type: "personalChatNotif";
    from: string;
    id: string;
    payload: string;
    to: string;
    receivedAt: string;
}>, z.ZodObject<{
    type: z.ZodLiteral<"personalChatResponse">;
    code: z.ZodNumber;
    id: z.ZodString;
}, "strip", z.ZodTypeAny, {
    type: "personalChatResponse";
    code: number;
    id: string;
}, {
    type: "personalChatResponse";
    code: number;
    id: string;
}>, z.ZodObject<{
    type: z.ZodLiteral<"refreshTokenResponse">;
    code: z.ZodNumber;
    id: z.ZodString;
}, "strip", z.ZodTypeAny, {
    type: "refreshTokenResponse";
    code: number;
    id: string;
}, {
    type: "refreshTokenResponse";
    code: number;
    id: string;
}>, z.ZodObject<{
    type: z.ZodLiteral<"rejectFriendsNotif">;
    userId: z.ZodString;
}, "strip", z.ZodTypeAny, {
    type: "rejectFriendsNotif";
    userId: string;
}, {
    type: "rejectFriendsNotif";
    userId: string;
}>, z.ZodObject<{
    type: z.ZodLiteral<"rejectFriendsResponse">;
    code: z.ZodNumber;
    id: z.ZodString;
}, "strip", z.ZodTypeAny, {
    type: "rejectFriendsResponse";
    code: number;
    id: string;
}, {
    type: "rejectFriendsResponse";
    code: number;
    id: string;
}>, z.ZodObject<{
    type: z.ZodLiteral<"rematchmakingNotif">;
    banDuration: z.ZodNumber;
}, "strip", z.ZodTypeAny, {
    type: "rematchmakingNotif";
    banDuration: number;
}, {
    type: "rematchmakingNotif";
    banDuration: number;
}>, z.ZodObject<{
    type: z.ZodLiteral<"requestFriendsNotif">;
    friendId: z.ZodString;
}, "strip", z.ZodTypeAny, {
    type: "requestFriendsNotif";
    friendId: string;
}, {
    type: "requestFriendsNotif";
    friendId: string;
}>, z.ZodObject<{
    type: z.ZodLiteral<"requestFriendsResponse">;
    code: z.ZodNumber;
    id: z.ZodString;
}, "strip", z.ZodTypeAny, {
    type: "requestFriendsResponse";
    code: number;
    id: string;
}, {
    type: "requestFriendsResponse";
    code: number;
    id: string;
}>, z.ZodObject<{
    type: z.ZodLiteral<"sendChannelChatResponse">;
    code: z.ZodNumber;
    id: z.ZodString;
}, "strip", z.ZodTypeAny, {
    type: "sendChannelChatResponse";
    code: number;
    id: string;
}, {
    type: "sendChannelChatResponse";
    code: number;
    id: string;
}>, z.ZodObject<{
    type: z.ZodLiteral<"setReadyConsentNotif">;
    matchId: z.ZodString;
    userId: z.ZodString;
}, "strip", z.ZodTypeAny, {
    type: "setReadyConsentNotif";
    userId: string;
    matchId: string;
}, {
    type: "setReadyConsentNotif";
    userId: string;
    matchId: string;
}>, z.ZodObject<{
    type: z.ZodLiteral<"setReadyConsentResponse">;
    code: z.ZodNumber;
    id: z.ZodString;
}, "strip", z.ZodTypeAny, {
    type: "setReadyConsentResponse";
    code: number;
    id: string;
}, {
    type: "setReadyConsentResponse";
    code: number;
    id: string;
}>, z.ZodObject<{
    type: z.ZodLiteral<"setSessionAttributeResponse">;
    code: z.ZodNumber;
    id: z.ZodString;
}, "strip", z.ZodTypeAny, {
    type: "setSessionAttributeResponse";
    code: number;
    id: string;
}, {
    type: "setSessionAttributeResponse";
    code: number;
    id: string;
}>, z.ZodObject<{
    type: z.ZodLiteral<"setUserStatusResponse">;
    code: z.ZodNumber;
    id: z.ZodString;
}, "strip", z.ZodTypeAny, {
    type: "setUserStatusResponse";
    code: number;
    id: string;
}, {
    type: "setUserStatusResponse";
    code: number;
    id: string;
}>, z.ZodObject<{
    type: z.ZodLiteral<"shutdownNotif">;
    message: z.ZodString;
}, "strip", z.ZodTypeAny, {
    type: "shutdownNotif";
    message: string;
}, {
    type: "shutdownNotif";
    message: string;
}>, z.ZodObject<{
    type: z.ZodLiteral<"signalingP2PNotif">;
    destinationId: z.ZodString;
    message: z.ZodString;
}, "strip", z.ZodTypeAny, {
    type: "signalingP2PNotif";
    message: string;
    destinationId: string;
}, {
    type: "signalingP2PNotif";
    message: string;
    destinationId: string;
}>, z.ZodObject<{
    type: z.ZodLiteral<"startMatchmakingResponse">;
    code: z.ZodNumber;
    id: z.ZodString;
}, "strip", z.ZodTypeAny, {
    type: "startMatchmakingResponse";
    code: number;
    id: string;
}, {
    type: "startMatchmakingResponse";
    code: number;
    id: string;
}>, z.ZodObject<{
    type: z.ZodLiteral<"unblockPlayerNotif">;
    unblockedUserId: z.ZodString;
    userId: z.ZodString;
}, "strip", z.ZodTypeAny, {
    type: "unblockPlayerNotif";
    userId: string;
    unblockedUserId: string;
}, {
    type: "unblockPlayerNotif";
    userId: string;
    unblockedUserId: string;
}>, z.ZodObject<{
    type: z.ZodLiteral<"unblockPlayerResponse">;
    code: z.ZodNumber;
    id: z.ZodString;
    namespace: z.ZodString;
    unblockedUserId: z.ZodString;
}, "strip", z.ZodTypeAny, {
    namespace: string;
    type: "unblockPlayerResponse";
    code: number;
    id: string;
    unblockedUserId: string;
}, {
    namespace: string;
    type: "unblockPlayerResponse";
    code: number;
    id: string;
    unblockedUserId: string;
}>, z.ZodObject<{
    type: z.ZodLiteral<"unfriendNotif">;
    friendId: z.ZodString;
}, "strip", z.ZodTypeAny, {
    type: "unfriendNotif";
    friendId: string;
}, {
    type: "unfriendNotif";
    friendId: string;
}>, z.ZodObject<{
    type: z.ZodLiteral<"unfriendResponse">;
    code: z.ZodNumber;
    id: z.ZodString;
}, "strip", z.ZodTypeAny, {
    type: "unfriendResponse";
    code: number;
    id: string;
}, {
    type: "unfriendResponse";
    code: number;
    id: string;
}>, z.ZodObject<{
    type: z.ZodLiteral<"userMetricResponse">;
    code: z.ZodNumber;
    id: z.ZodString;
    playerCount: z.ZodNumber;
}, "strip", z.ZodTypeAny, {
    type: "userMetricResponse";
    code: number;
    id: string;
    playerCount: number;
}, {
    type: "userMetricResponse";
    code: number;
    id: string;
    playerCount: number;
}>, z.ZodObject<{
    type: z.ZodLiteral<"userStatusNotif">;
    activity: z.ZodString;
    availability: z.ZodNumber;
    lastSeenAt: z.ZodString;
    userId: z.ZodString;
}, "strip", z.ZodTypeAny, {
    type: "userStatusNotif";
    userId: string;
    activity: string;
    availability: number;
    lastSeenAt: string;
}, {
    type: "userStatusNotif";
    userId: string;
    activity: string;
    availability: number;
    lastSeenAt: string;
}>]>;
type WebSocketResponseOrNotification = z.infer<typeof WebSocketResponseOrNotification>;

declare function WebSocketClass(sdk: AccelByteSDK, args?: SdkSetConfigParam): {
    instance: null;
    connect: () => void;
    disconnect: (code?: number, reason?: string) => void;
    send: (message: WebSocketRequest) => void;
    sendRaw: (rawMessage: string) => void;
    onOpen: (cb: () => any) => {
        removeEventListener: () => void | undefined;
    } | {
        removeEventListener?: undefined;
    };
    onClose: (cb: (ev: CloseEvent) => any) => {
        removeEventListener: () => void | undefined;
    } | {
        removeEventListener?: undefined;
    };
    onMessage: (cb: (message: WebSocketResponseOrNotification | string) => any, raw?: boolean) => {
        removeEventListener: () => void | undefined;
    } | {
        removeEventListener?: undefined;
    };
    onError: (cb: (err: any) => any) => {
        removeEventListener: () => void | undefined;
    } | {
        removeEventListener?: undefined;
    };
    sendAcceptFriends: (data: Omit<AcceptFriendsRequest, "type">) => void;
    sendBlockPlayer: (data: Omit<BlockPlayerRequest, "type">) => void;
    sendCancelFriends: (data: Omit<CancelFriendsRequest, "type">) => void;
    sendCancelMatchmaking: (data: Omit<CancelMatchmakingRequest, "type">) => void;
    sendClientReset: (data: Omit<ClientResetRequest, "type">) => void;
    sendFriendsStatus: (data: Omit<FriendsStatusRequest, "type">) => void;
    sendGetAllSessionAttribute: (data: Omit<GetAllSessionAttributeRequest, "type">) => void;
    sendGetFriendshipStatus: (data: Omit<GetFriendshipStatusRequest, "type">) => void;
    sendGetSessionAttribute: (data: Omit<GetSessionAttributeRequest, "type">) => void;
    sendJoinDefaultChannel: (data: Omit<JoinDefaultChannelRequest, "type">) => void;
    sendListIncomingFriends: (data: Omit<ListIncomingFriendsRequest, "type">) => void;
    sendListOfFriends: (data: Omit<ListOfFriendsRequest, "type">) => void;
    sendListOnlineFriends: (data: Omit<ListOnlineFriendsRequest, "type">) => void;
    sendListOutgoingFriends: (data: Omit<ListOutgoingFriendsRequest, "type">) => void;
    sendOfflineNotification: (data: Omit<OfflineNotificationRequest, "type">) => void;
    sendPartyChat: (data: Omit<PartyChatRequest, "type">) => void;
    sendPartyCreate: (data: Omit<PartyCreateRequest, "type">) => void;
    sendPartyInfo: (data: Omit<PartyInfoRequest, "type">) => void;
    sendPartyInvite: (data: Omit<PartyInviteRequest, "type">) => void;
    sendPartyJoin: (data: Omit<PartyJoinRequest, "type">) => void;
    sendPartyKick: (data: Omit<PartyKickRequest, "type">) => void;
    sendPartyLeave: (data: Omit<PartyLeaveRequest, "type">) => void;
    sendPartyPromoteLeader: (data: Omit<PartyPromoteLeaderRequest, "type">) => void;
    sendPartyReject: (data: Omit<PartyRejectRequest, "type">) => void;
    sendPersonalChatHistory: (data: Omit<PersonalChatHistoryRequest, "type">) => void;
    sendPersonalChat: (data: Omit<PersonalChatRequest, "type">) => void;
    sendRefreshToken: (data: Omit<RefreshTokenRequest, "type">) => void;
    sendRejectFriends: (data: Omit<RejectFriendsRequest, "type">) => void;
    sendRequestFriends: (data: Omit<RequestFriendsRequest, "type">) => void;
    sendSendChannelChat: (data: Omit<SendChannelChatRequest, "type">) => void;
    sendSetReadyConsent: (data: Omit<SetReadyConsentRequest, "type">) => void;
    sendSetSessionAttribute: (data: Omit<SetSessionAttributeRequest, "type">) => void;
    sendSetUserStatus: (data: Omit<SetUserStatusRequest, "type">) => void;
    sendStartMatchmaking: (data: Omit<StartMatchmakingRequest, "type">) => void;
    sendUnblockPlayer: (data: Omit<UnblockPlayerRequest, "type">) => void;
    sendUnfriend: (data: Omit<UnfriendRequest, "type">) => void;
    sendUserMetric: (data: Omit<UserMetricRequest, "type">) => void;
};

/**
 * AUTO GENERATED
 */

declare const Lobby: {
    ConfigAdminApi: typeof ConfigAdminApi;
    AdminAdminApi: typeof AdminAdminApi;
    PlayerAdminApi: typeof PlayerAdminApi;
    ProfanityAdminApi: typeof ProfanityAdminApi;
    NotificationAdminApi: typeof NotificationAdminApi;
    FriendsAdminApi: typeof FriendsAdminApi;
    PartyAdminApi: typeof PartyAdminApi;
    ThirdPartyAdminApi: typeof ThirdPartyAdminApi;
    LobbyOperationsAdminApi: typeof LobbyOperationsAdminApi;
    LobbyOperationsApi: typeof LobbyOperationsApi;
    FriendsApi: typeof FriendsApi;
    NotificationApi: typeof NotificationApi;
    BlocksApi: typeof BlocksApi;
    AdminApi: typeof AdminApi;
    PlayerApi: typeof PlayerApi;
    PartyApi: typeof PartyApi;
    PresenceApi: typeof PresenceApi;
    WebSocket: typeof WebSocketClass;
    version: () => void;
};

export { Admin$, AdminAddProfanityFilterIntoListRequest, AdminAddProfanityFiltersFilterRequest, AdminAddProfanityFiltersRequest, AdminAdmin$, AdminAdminApi, AdminApi, AdminCreateProfanityListRequest, AdminDeleteProfanityFilterRequest, AdminGetProfanityListFiltersV1Response, AdminGetProfanityListsListResponse, AdminGetProfanityListsListResponseArray, AdminSetProfanityRuleForNamespaceRequest, AdminUpdateProfanityList, AdminVerifyMessageProfanityRequest, AdminVerifyMessageProfanityResponse, AppMessageDeclaration, AppMessageDeclarationArray, BlockPlayerRequest$1 as BlockPlayerRequest, BlockedByPlayerData, BlockedPlayerData, Blocks$, BlocksApi, BulkFriendsRequest, BulkFriendsResponse, BulkUsersFreeFormNotificationRequestV1, Config, ConfigAdmin$, ConfigAdminApi, ConfigList, ConfigReq, Configuration, CreateConfigRequest, CreateConfigResponse, CreateTemplateRequest, CreateTopicRequest, CreateTopicRequestV1, DebugProfanityFilterRequest, Error, ErrorResponseBody, ErrorResponseV1, FreeFormNotificationRequest, FreeFormNotificationRequestV1, FriendWithPlatform, Friends$, FriendsAdmin$, FriendsAdminApi, FriendsApi, FriendshipConnection, FriendshipConnectionResponse, GetAllNotificationTemplateSlugResp, GetAllNotificationTopicsResponse, GetAllPlayerBlockedByUsersResponse, GetAllPlayerBlockedUsersResponse, GetAllPlayerSessionAttributeResponse, GetBulkAllPlayerBlockedUsersRequest, GetBulkAllPlayerBlockedUsersResponse, GetConfigResponse, GetFriendsResponse, GetLobbyCcuResponse, GetPlayerSessionAttributeResponse, GetUserFriendsResponse, GetUserFriendsResponseArray, GetUserIncomingFriendsResponse, GetUserIncomingFriendsResponseArray, GetUserOutgoingFriendsResponse, GetUserOutgoingFriendsResponseArray, GetUsersPresenceResponse, GlobalConfiguration, ImportConfigResponse, IncomingFriendsWithTimeData, ListBlockedPlayerRequest, ListBulkUserPlatformsResponse, ListUnblockPlayerRequest, LoadIncomingFriendsWithTimeResponse, LoadIncomingFriendsWithTimeResponseArray, LoadOutgoingFriendsWithTimeResponse, LoadOutgoingFriendsWithTimeResponseArray, Lobby, LobbyOperations$, LobbyOperationsAdmin$, LobbyOperationsAdminApi, LobbyOperationsApi, Localization, NativeFriendRequest, NativeFriendSyncResponse, NativeFriendSyncResponseArray, NativeUserBlockRequest, NativeUserBlockResponse, NativeUserBlockResponseArray, Notification$, NotificationAdmin$, NotificationAdminApi, NotificationApi, NotificationResponse, NotificationTemplateResponse, NotificationTemplateResponseArray, NotificationTopicResponse, NotificationTopicResponseV1, NotificationWithTemplateRequest, NotificationWithTemplateRequestV1, OutgoingFriendsWithTimeData, Pagination, Party$, PartyAdmin$, PartyAdminApi, PartyApi, PartyData, PartyPutCustomAttributesRequest, PartyPutLimitSizeRequest, Player$, PlayerAdmin$, PlayerAdminApi, PlayerApi, Presence$, PresenceApi, ProfanityAdmin$, ProfanityAdminApi, ProfanityFilter, ProfanityFilterArray, ProfanityRule, PutGlobalConfigurationRequest, RequestUserPresence, SetPlayerSessionAttributeRequest, TemplateContent, TemplateLocalization, TemplateLocalizationResponse, TemplateResponse, TemplateResponseArray, ThirdPartyAdmin$, ThirdPartyAdminApi, TopicByNamespacesResponse, UnblockPlayerRequest$1 as UnblockPlayerRequest, UpdateConfigRequest, UpdateConfigResponse, UpdateTemplateRequest, UpdateTopicRequest, UserAcceptFriendRequest, UserCancelFriendRequest, UserGetFriendshipStatusResponse, UserPlatformInfo, UserPresence, UserRejectFriendRequest, UserRequestFriendRequest, UserUnfriendRequest, UserWithPlatformInfo };

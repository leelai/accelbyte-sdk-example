import { WILDCARD_SIGN } from '../types';

function getAdminRoles(roles) {
  return roles.reduce((filtered, role) => {
    if (role.adminRole === true) {
      filtered.push(role.roleId);
    }
    return filtered;
  }, []);
}
function getAdminNamespaceRoles(namespaceRoles, roles) {
  return namespaceRoles.filter((namespaceRole) => {
    return roles.find((role) => role.adminRole === true && role.roleId === namespaceRole.roleId);
  });
}
function getRoleIdsByNamespace(namespaceRoles, namespace) {
  return namespaceRoles.reduce((filtered, role) => {
    if (namespace) {
      if (role.namespace === namespace || role.namespace === WILDCARD_SIGN) {
        filtered.push(role.roleId);
      }
    } else {
      filtered.push(role.roleId);
    }
    return filtered;
  }, []);
}
function getCurrentUserRoles(roles, userRoleIds) {
  return roles.filter((role) => userRoleIds.includes(role.roleId) && Array.isArray(role.permissions) && role.permissions.length > 0);
}
function getCurrentUserPermissions(roles) {
  return roles.reduce((acc, role) => {
    return acc.concat(role.permissions);
  }, []);
}
function getCurrentUserNamespacedPermissions(namespaceRoleWithPermission) {
  return namespaceRoleWithPermission.reduce((acc, curr) => {
    return acc.concat(curr.permissions);
  }, []);
}
function isUserHasAdminRole(userNamespaceRoles, adminRoles) {
  return adminRoles.some((role) => userNamespaceRoles.includes(role));
}
const replacePermissionNamespace = (permission, namespace) => {
  return {
    resource: permission.resource.replace("{namespace}", namespace),
    action: permission.action
  };
};

export { getAdminNamespaceRoles, getAdminRoles, getCurrentUserNamespacedPermissions, getCurrentUserPermissions, getCurrentUserRoles, getRoleIdsByNamespace, isUserHasAdminRole, replacePermissionNamespace };
//# sourceMappingURL=namespaceRole.js.map
//# sourceMappingURL=namespaceRole.js.map
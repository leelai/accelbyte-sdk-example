"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/all-query-imports.ts
var all_query_imports_exports = {};
__export(all_query_imports_exports, {
  Key_Bans: () => Key_Bans,
  Key_BansAdmin: () => Key_BansAdmin,
  Key_Clients: () => Key_Clients,
  Key_ClientsAdmin: () => Key_ClientsAdmin,
  Key_ClientsConfigV3Admin: () => Key_ClientsConfigV3Admin,
  Key_Config: () => Key_Config,
  Key_ConfigAdmin: () => Key_ConfigAdmin,
  Key_Country: () => Key_Country,
  Key_CountryAdmin: () => Key_CountryAdmin,
  Key_DevicesV4Admin: () => Key_DevicesV4Admin,
  Key_InputValidations: () => Key_InputValidations,
  Key_InputValidationsAdmin: () => Key_InputValidationsAdmin,
  Key_LoginAllowlistAdmin: () => Key_LoginAllowlistAdmin,
  Key_OAuth: () => Key_OAuth,
  Key_OAuth20: () => Key_OAuth20,
  Key_OAuth20Admin: () => Key_OAuth20Admin,
  Key_OAuth20Extension: () => Key_OAuth20Extension,
  Key_OAuth20V4: () => Key_OAuth20V4,
  Key_OverrideRoleConfigV3Admin: () => Key_OverrideRoleConfigV3Admin,
  Key_ProfileUpdateStrategy: () => Key_ProfileUpdateStrategy,
  Key_ProfileUpdateStrategyAdmin: () => Key_ProfileUpdateStrategyAdmin,
  Key_Roles: () => Key_Roles,
  Key_RolesAdmin: () => Key_RolesAdmin,
  Key_Sso: () => Key_Sso,
  Key_SsoCredentialAdmin: () => Key_SsoCredentialAdmin,
  Key_SsoSaml20: () => Key_SsoSaml20,
  Key_ThirdPartyCredential: () => Key_ThirdPartyCredential,
  Key_ThirdPartyCredentialAdmin: () => Key_ThirdPartyCredentialAdmin,
  Key_Users: () => Key_Users,
  Key_UsersAdmin: () => Key_UsersAdmin,
  Key_UsersV4: () => Key_UsersV4,
  Key_UsersV4Admin: () => Key_UsersV4Admin,
  useBansAdminApi_CreateBanUserMutation_v3: () => useBansAdminApi_CreateBanUserMutation_v3,
  useBansAdminApi_GetBansReasons_v3: () => useBansAdminApi_GetBansReasons_v3,
  useBansAdminApi_GetBansUsers_v3: () => useBansAdminApi_GetBansUsers_v3,
  useBansAdminApi_GetBans_v3: () => useBansAdminApi_GetBans_v3,
  useBansAdminApi_GetBantypes_v3: () => useBansAdminApi_GetBantypes_v3,
  useBansAdminApi_PatchBanUserDisabledMutation_v3: () => useBansAdminApi_PatchBanUserDisabledMutation_v3,
  useBansApi_GetBans: () => useBansApi_GetBans,
  useBansApi_GetBansReasons: () => useBansApi_GetBansReasons,
  useClientsAdminApi_CreateClientMutation_v3: () => useClientsAdminApi_CreateClientMutation_v3,
  useClientsAdminApi_DeleteClient_ByClientIdMutation_v3: () => useClientsAdminApi_DeleteClient_ByClientIdMutation_v3,
  useClientsAdminApi_DeletePermission_ByClientId_ByResource_ByActionMutation_v3: () => useClientsAdminApi_DeletePermission_ByClientId_ByResource_ByActionMutation_v3,
  useClientsAdminApi_GetClient_ByClientId_v3: () => useClientsAdminApi_GetClient_ByClientId_v3,
  useClientsAdminApi_GetClients_v3: () => useClientsAdminApi_GetClients_v3,
  useClientsAdminApi_PatchClient_ByClientIdMutation_v3: () => useClientsAdminApi_PatchClient_ByClientIdMutation_v3,
  useClientsAdminApi_UpdateClientMutation_v3: () => useClientsAdminApi_UpdateClientMutation_v3,
  useClientsAdminApi_UpdatePermission_ByClientIdMutation_v3: () => useClientsAdminApi_UpdatePermission_ByClientIdMutation_v3,
  useClientsAdminApi_UpdatePermission_ByClientId_ByNSMutation_v3: () => useClientsAdminApi_UpdatePermission_ByClientId_ByNSMutation_v3,
  useClientsAdminApi_UpdateSecret_ByClientIdMutation_v3: () => useClientsAdminApi_UpdateSecret_ByClientIdMutation_v3,
  useClientsApi_CreateClientMutation: () => useClientsApi_CreateClientMutation,
  useClientsApi_CreateClient_ByNSMutation: () => useClientsApi_CreateClient_ByNSMutation,
  useClientsApi_DeleteClient_ByClientIdMutation: () => useClientsApi_DeleteClient_ByClientIdMutation,
  useClientsApi_DeleteClient_ByClientId_ByNSMutation: () => useClientsApi_DeleteClient_ByClientId_ByNSMutation,
  useClientsApi_DeleteClientpermission_ByClientId_ByResource_ByActionMutation: () => useClientsApi_DeleteClientpermission_ByClientId_ByResource_ByActionMutation,
  useClientsApi_GetClient_ByClientId: () => useClientsApi_GetClient_ByClientId,
  useClientsApi_GetClients: () => useClientsApi_GetClients,
  useClientsApi_GetClients_ByNS: () => useClientsApi_GetClients_ByNS,
  useClientsApi_UpdateClient_ByClientIdMutation: () => useClientsApi_UpdateClient_ByClientIdMutation,
  useClientsApi_UpdateClientpermission_ByClientIdMutation: () => useClientsApi_UpdateClientpermission_ByClientIdMutation,
  useClientsApi_UpdateClientpermission_ByClientId_ByResource_ByActionMutation: () => useClientsApi_UpdateClientpermission_ByClientId_ByResource_ByActionMutation,
  useClientsApi_UpdateSecret_ByClientIdMutation: () => useClientsApi_UpdateSecret_ByClientIdMutation,
  useClientsConfigV3AdminApi_DeleteClientConfigPermissionMutation_v3: () => useClientsConfigV3AdminApi_DeleteClientConfigPermissionMutation_v3,
  useClientsConfigV3AdminApi_GetClientConfigPermissions_v3: () => useClientsConfigV3AdminApi_GetClientConfigPermissions_v3,
  useClientsConfigV3AdminApi_GetClientConfigTemplates_v3: () => useClientsConfigV3AdminApi_GetClientConfigTemplates_v3,
  useClientsConfigV3AdminApi_UpdateClientConfigPermissionMutation_v3: () => useClientsConfigV3AdminApi_UpdateClientConfigPermissionMutation_v3,
  useConfigAdminApi_GetConfig_ByConfigKey_v3: () => useConfigAdminApi_GetConfig_ByConfigKey_v3,
  useConfigApi_GetConfig_ByConfigKey_v3: () => useConfigApi_GetConfig_ByConfigKey_v3,
  useCountryAdminApi_GetCountriesBlacklist_v3: () => useCountryAdminApi_GetCountriesBlacklist_v3,
  useCountryAdminApi_GetCountries_v3: () => useCountryAdminApi_GetCountries_v3,
  useCountryAdminApi_UpdateCountryBlacklistMutation_v3: () => useCountryAdminApi_UpdateCountryBlacklistMutation_v3,
  useCountryApi_GetCountries_v3: () => useCountryApi_GetCountries_v3,
  useDevicesV4AdminApi_CreateDeviceBanMutation_v4: () => useDevicesV4AdminApi_CreateDeviceBanMutation_v4,
  useDevicesV4AdminApi_GetBans_ByDeviceId_v4: () => useDevicesV4AdminApi_GetBans_ByDeviceId_v4,
  useDevicesV4AdminApi_GetDecrypt_ByDeviceId_v4: () => useDevicesV4AdminApi_GetDecrypt_ByDeviceId_v4,
  useDevicesV4AdminApi_GetDeviceBan_ByBanId_v4: () => useDevicesV4AdminApi_GetDeviceBan_ByBanId_v4,
  useDevicesV4AdminApi_GetDevicesBanned_v4: () => useDevicesV4AdminApi_GetDevicesBanned_v4,
  useDevicesV4AdminApi_GetDevicesBans_v4: () => useDevicesV4AdminApi_GetDevicesBans_v4,
  useDevicesV4AdminApi_GetDevicesReport_v4: () => useDevicesV4AdminApi_GetDevicesReport_v4,
  useDevicesV4AdminApi_GetDevicesTypes_v4: () => useDevicesV4AdminApi_GetDevicesTypes_v4,
  useDevicesV4AdminApi_GetDevices_v4: () => useDevicesV4AdminApi_GetDevices_v4,
  useDevicesV4AdminApi_GetUsers_ByDeviceId_v4: () => useDevicesV4AdminApi_GetUsers_ByDeviceId_v4,
  useDevicesV4AdminApi_UpdateDeviceBan_ByBanIdMutation_v4: () => useDevicesV4AdminApi_UpdateDeviceBan_ByBanIdMutation_v4,
  useDevicesV4AdminApi_UpdateUnban_ByDeviceIdMutation_v4: () => useDevicesV4AdminApi_UpdateUnban_ByDeviceIdMutation_v4,
  useInputValidationsAdminApi_DeleteInputValidation_ByFieldMutation_v3: () => useInputValidationsAdminApi_DeleteInputValidation_ByFieldMutation_v3,
  useInputValidationsAdminApi_GetInputValidations_v3: () => useInputValidationsAdminApi_GetInputValidations_v3,
  useInputValidationsAdminApi_UpdateInputValidationMutation_v3: () => useInputValidationsAdminApi_UpdateInputValidationMutation_v3,
  useInputValidationsApi_GetInputValidation_ByField_v3: () => useInputValidationsApi_GetInputValidation_ByField_v3,
  useInputValidationsApi_GetInputValidations_v3: () => useInputValidationsApi_GetInputValidations_v3,
  useLoginAllowlistAdminApi_GetLoginAllowlist_v3: () => useLoginAllowlistAdminApi_GetLoginAllowlist_v3,
  useLoginAllowlistAdminApi_UpdateLoginAllowlistMutation_v3: () => useLoginAllowlistAdminApi_UpdateLoginAllowlistMutation_v3,
  useOAuth20AdminApi_GetPlatformTokenOauth_ByUserId_ByPlatformId_v3: () => useOAuth20AdminApi_GetPlatformTokenOauth_ByUserId_ByPlatformId_v3,
  useOAuth20AdminApi_UpdateRevokeOauth_ByUserIdMutation_v3: () => useOAuth20AdminApi_UpdateRevokeOauth_ByUserIdMutation_v3,
  useOAuth20Api_GetAuthorizeOauth_ByPlatformId_v3: () => useOAuth20Api_GetAuthorizeOauth_ByPlatformId_v3,
  useOAuth20Api_GetOauthAuthorize_v3: () => useOAuth20Api_GetOauthAuthorize_v3,
  useOAuth20Api_GetOauthJwks_v3: () => useOAuth20Api_GetOauthJwks_v3,
  useOAuth20Api_GetOauthRevocationlist_v3: () => useOAuth20Api_GetOauthRevocationlist_v3,
  useOAuth20Api_GetPlatformTokenOauth_ByUserId_ByPlatformId_v3: () => useOAuth20Api_GetPlatformTokenOauth_ByUserId_ByPlatformId_v3,
  useOAuth20Api_PostOauthIntrospectMutation_v3: () => useOAuth20Api_PostOauthIntrospectMutation_v3,
  useOAuth20Api_PostOauthMfaCodeMutation_v3: () => useOAuth20Api_PostOauthMfaCodeMutation_v3,
  useOAuth20Api_PostOauthMfaFactorChangeMutation_v3: () => useOAuth20Api_PostOauthMfaFactorChangeMutation_v3,
  useOAuth20Api_PostOauthMfaVerifyMutation_v3: () => useOAuth20Api_PostOauthMfaVerifyMutation_v3,
  useOAuth20Api_PostOauthRevokeMutation_v3: () => useOAuth20Api_PostOauthRevokeMutation_v3,
  useOAuth20Api_PostOauthSimultaneousLoginMutation_v3: () => useOAuth20Api_PostOauthSimultaneousLoginMutation_v3,
  useOAuth20Api_PostOauthTokenMutation_v3: () => useOAuth20Api_PostOauthTokenMutation_v3,
  useOAuth20Api_PostOauthVerifyMutation_v3: () => useOAuth20Api_PostOauthVerifyMutation_v3,
  useOAuth20Api_PostTokenOauth_ByPlatformIdMutation_v3: () => useOAuth20Api_PostTokenOauth_ByPlatformIdMutation_v3,
  useOAuth20ExtensionApi_CreateLogoutMutation_v3: () => useOAuth20ExtensionApi_CreateLogoutMutation_v3,
  useOAuth20ExtensionApi_GetAuthenticate_ByPlatformId_v3: () => useOAuth20ExtensionApi_GetAuthenticate_ByPlatformId_v3,
  useOAuth20ExtensionApi_GetLocationCountry_v3: () => useOAuth20ExtensionApi_GetLocationCountry_v3,
  useOAuth20ExtensionApi_PostAuthenticateMutation_v3: () => useOAuth20ExtensionApi_PostAuthenticateMutation_v3,
  useOAuth20ExtensionApi_PostAuthenticateWithLinkMutation_v3: () => useOAuth20ExtensionApi_PostAuthenticateWithLinkMutation_v3,
  useOAuth20ExtensionApi_PostHeadlesTokenMutation_v3: () => useOAuth20ExtensionApi_PostHeadlesTokenMutation_v3,
  useOAuth20ExtensionApi_PostLinkCodeRequestMutation_v3: () => useOAuth20ExtensionApi_PostLinkCodeRequestMutation_v3,
  useOAuth20ExtensionApi_PostLinkCodeValidateMutation_v3: () => useOAuth20ExtensionApi_PostLinkCodeValidateMutation_v3,
  useOAuth20ExtensionApi_PostLinkTokenExchangeMutation_v3: () => useOAuth20ExtensionApi_PostLinkTokenExchangeMutation_v3,
  useOAuth20ExtensionApi_PostTokenExchangeMutation_v3: () => useOAuth20ExtensionApi_PostTokenExchangeMutation_v3,
  useOAuth20ExtensionApi_PostTokenRequestMutation_v3: () => useOAuth20ExtensionApi_PostTokenRequestMutation_v3,
  useOAuth20ExtensionApi_PostTokenVerify_ByPlatformIdMutation_v3: () => useOAuth20ExtensionApi_PostTokenVerify_ByPlatformIdMutation_v3,
  useOAuth20V4Api_PostOauthAuthenticateWithLinkMutation_v4: () => useOAuth20V4Api_PostOauthAuthenticateWithLinkMutation_v4,
  useOAuth20V4Api_PostOauthHeadlesTokenMutation_v4: () => useOAuth20V4Api_PostOauthHeadlesTokenMutation_v4,
  useOAuth20V4Api_PostOauthMfaVerifyMutation_v4: () => useOAuth20V4Api_PostOauthMfaVerifyMutation_v4,
  useOAuth20V4Api_PostOauthSimultaneousLoginMutation_v4: () => useOAuth20V4Api_PostOauthSimultaneousLoginMutation_v4,
  useOAuth20V4Api_PostOauthTokenExchangeMutation_v4: () => useOAuth20V4Api_PostOauthTokenExchangeMutation_v4,
  useOAuth20V4Api_PostOauthTokenMutation_v4: () => useOAuth20V4Api_PostOauthTokenMutation_v4,
  useOAuth20V4Api_PostTokenOauth_ByPlatformIdMutation_v4: () => useOAuth20V4Api_PostTokenOauth_ByPlatformIdMutation_v4,
  useOAuthApi_GetOauthJwks: () => useOAuthApi_GetOauthJwks,
  useOAuthApi_GetOauthRevocationlist: () => useOAuthApi_GetOauthRevocationlist,
  useOAuthApi_PostOauthAuthorizeMutation: () => useOAuthApi_PostOauthAuthorizeMutation,
  useOAuthApi_PostOauthRevokeTokenMutation: () => useOAuthApi_PostOauthRevokeTokenMutation,
  useOAuthApi_PostOauthRevokeUserMutation: () => useOAuthApi_PostOauthRevokeUserMutation,
  useOAuthApi_PostOauthTokenMutation: () => useOAuthApi_PostOauthTokenMutation,
  useOAuthApi_PostOauthVerifyMutation: () => useOAuthApi_PostOauthVerifyMutation,
  useOAuthApi_PostTokenOauth_ByPlatformIdMutation: () => useOAuthApi_PostTokenOauth_ByPlatformIdMutation,
  useOAuthApi_UpdateRevokeOauth_ByUserIdMutation: () => useOAuthApi_UpdateRevokeOauth_ByUserIdMutation,
  useOverrideRoleConfigV3AdminApi_GetPermissions_ByRoleId_v3: () => useOverrideRoleConfigV3AdminApi_GetPermissions_ByRoleId_v3,
  useOverrideRoleConfigV3AdminApi_GetRoleoverrideSource_v3: () => useOverrideRoleConfigV3AdminApi_GetRoleoverrideSource_v3,
  useOverrideRoleConfigV3AdminApi_GetRoleoverride_v3: () => useOverrideRoleConfigV3AdminApi_GetRoleoverride_v3,
  useOverrideRoleConfigV3AdminApi_PatchRoleoverrideMutation_v3: () => useOverrideRoleConfigV3AdminApi_PatchRoleoverrideMutation_v3,
  useOverrideRoleConfigV3AdminApi_PatchRoleoverrideStatusMutation_v3: () => useOverrideRoleConfigV3AdminApi_PatchRoleoverrideStatusMutation_v3,
  useProfileUpdateStrategyAdminApi_GetProfileUpdateStrategies_v3: () => useProfileUpdateStrategyAdminApi_GetProfileUpdateStrategies_v3,
  useProfileUpdateStrategyAdminApi_UpdateProfileUpdateStrategyMutation_v3: () => useProfileUpdateStrategyAdminApi_UpdateProfileUpdateStrategyMutation_v3,
  useProfileUpdateStrategyApi_GetProfileUpdateStrategies_v3: () => useProfileUpdateStrategyApi_GetProfileUpdateStrategies_v3,
  useRolesAdminApi_CreateRoleMutation_v3: () => useRolesAdminApi_CreateRoleMutation_v3,
  useRolesAdminApi_CreateRoleMutation_v4: () => useRolesAdminApi_CreateRoleMutation_v4,
  useRolesAdminApi_DeleteAdmin_ByRoleIdMutation_v3: () => useRolesAdminApi_DeleteAdmin_ByRoleIdMutation_v3,
  useRolesAdminApi_DeleteManager_ByRoleIdMutation_v3: () => useRolesAdminApi_DeleteManager_ByRoleIdMutation_v3,
  useRolesAdminApi_DeleteMember_ByRoleIdMutation_v3: () => useRolesAdminApi_DeleteMember_ByRoleIdMutation_v3,
  useRolesAdminApi_DeletePermission_ByRoleIdMutation_v3: () => useRolesAdminApi_DeletePermission_ByRoleIdMutation_v3,
  useRolesAdminApi_DeletePermission_ByRoleIdMutation_v4: () => useRolesAdminApi_DeletePermission_ByRoleIdMutation_v4,
  useRolesAdminApi_DeletePermission_ByRoleId_ByResource_ByActionMutation_v3: () => useRolesAdminApi_DeletePermission_ByRoleId_ByResource_ByActionMutation_v3,
  useRolesAdminApi_DeleteRole_ByRoleIdMutation_v3: () => useRolesAdminApi_DeleteRole_ByRoleIdMutation_v3,
  useRolesAdminApi_DeleteRole_ByRoleIdMutation_v4: () => useRolesAdminApi_DeleteRole_ByRoleIdMutation_v4,
  useRolesAdminApi_DeleteUser_ByRoleIdMutation_v4: () => useRolesAdminApi_DeleteUser_ByRoleIdMutation_v4,
  useRolesAdminApi_GetAdmin_ByRoleId_v3: () => useRolesAdminApi_GetAdmin_ByRoleId_v3,
  useRolesAdminApi_GetManagers_ByRoleId_v3: () => useRolesAdminApi_GetManagers_ByRoleId_v3,
  useRolesAdminApi_GetMembers_ByRoleId_v3: () => useRolesAdminApi_GetMembers_ByRoleId_v3,
  useRolesAdminApi_GetRole_ByRoleId_v3: () => useRolesAdminApi_GetRole_ByRoleId_v3,
  useRolesAdminApi_GetRole_ByRoleId_v4: () => useRolesAdminApi_GetRole_ByRoleId_v4,
  useRolesAdminApi_GetRoles_v3: () => useRolesAdminApi_GetRoles_v3,
  useRolesAdminApi_GetRoles_v4: () => useRolesAdminApi_GetRoles_v4,
  useRolesAdminApi_GetUsers_ByRoleId_v4: () => useRolesAdminApi_GetUsers_ByRoleId_v4,
  useRolesAdminApi_PatchRole_ByRoleIdMutation_v3: () => useRolesAdminApi_PatchRole_ByRoleIdMutation_v3,
  useRolesAdminApi_PatchRole_ByRoleIdMutation_v4: () => useRolesAdminApi_PatchRole_ByRoleIdMutation_v4,
  useRolesAdminApi_UpdateAdmin_ByRoleIdMutation_v3: () => useRolesAdminApi_UpdateAdmin_ByRoleIdMutation_v3,
  useRolesAdminApi_UpdateManager_ByRoleIdMutation_v3: () => useRolesAdminApi_UpdateManager_ByRoleIdMutation_v3,
  useRolesAdminApi_UpdateMember_ByRoleIdMutation_v3: () => useRolesAdminApi_UpdateMember_ByRoleIdMutation_v3,
  useRolesAdminApi_UpdatePermission_ByRoleIdMutation_v3: () => useRolesAdminApi_UpdatePermission_ByRoleIdMutation_v3,
  useRolesAdminApi_UpdatePermission_ByRoleIdMutation_v4: () => useRolesAdminApi_UpdatePermission_ByRoleIdMutation_v4,
  useRolesAdminApi_UpdatePermission_ByRoleId_adminMutation_v3: () => useRolesAdminApi_UpdatePermission_ByRoleId_adminMutation_v3,
  useRolesAdminApi_UpdatePermission_ByRoleId_adminMutation_v4: () => useRolesAdminApi_UpdatePermission_ByRoleId_adminMutation_v4,
  useRolesAdminApi_UpdateUser_ByRoleIdMutation_v4: () => useRolesAdminApi_UpdateUser_ByRoleIdMutation_v4,
  useRolesApi_CreateRoleMutation: () => useRolesApi_CreateRoleMutation,
  useRolesApi_DeleteAdmin_ByRoleIdMutation: () => useRolesApi_DeleteAdmin_ByRoleIdMutation,
  useRolesApi_DeleteManager_ByRoleIdMutation: () => useRolesApi_DeleteManager_ByRoleIdMutation,
  useRolesApi_DeleteMember_ByRoleIdMutation: () => useRolesApi_DeleteMember_ByRoleIdMutation,
  useRolesApi_DeletePermission_ByRoleId_ByResource_ByActionMutation: () => useRolesApi_DeletePermission_ByRoleId_ByResource_ByActionMutation,
  useRolesApi_DeleteRole_ByRoleIdMutation: () => useRolesApi_DeleteRole_ByRoleIdMutation,
  useRolesApi_GetAdmin_ByRoleId: () => useRolesApi_GetAdmin_ByRoleId,
  useRolesApi_GetManagers_ByRoleId: () => useRolesApi_GetManagers_ByRoleId,
  useRolesApi_GetMembers_ByRoleId: () => useRolesApi_GetMembers_ByRoleId,
  useRolesApi_GetRole_ByRoleId: () => useRolesApi_GetRole_ByRoleId,
  useRolesApi_GetRole_ByRoleId_v3: () => useRolesApi_GetRole_ByRoleId_v3,
  useRolesApi_GetRoles: () => useRolesApi_GetRoles,
  useRolesApi_GetRoles_v3: () => useRolesApi_GetRoles_v3,
  useRolesApi_UpdateAdmin_ByRoleIdMutation: () => useRolesApi_UpdateAdmin_ByRoleIdMutation,
  useRolesApi_UpdateManager_ByRoleIdMutation: () => useRolesApi_UpdateManager_ByRoleIdMutation,
  useRolesApi_UpdateMember_ByRoleIdMutation: () => useRolesApi_UpdateMember_ByRoleIdMutation,
  useRolesApi_UpdatePermission_ByRoleIdMutation: () => useRolesApi_UpdatePermission_ByRoleIdMutation,
  useRolesApi_UpdatePermission_ByRoleId_ByResource_ByActionMutation: () => useRolesApi_UpdatePermission_ByRoleId_ByResource_ByActionMutation,
  useRolesApi_UpdateRole_ByRoleIdMutation: () => useRolesApi_UpdateRole_ByRoleIdMutation,
  useSsoApi_CreateLogout_ByPlatformIdMutation_v3: () => useSsoApi_CreateLogout_ByPlatformIdMutation_v3,
  useSsoApi_GetSso_ByPlatformId_v3: () => useSsoApi_GetSso_ByPlatformId_v3,
  useSsoCredentialAdminApi_CreateSso_ByPlatformIdMutation_v3: () => useSsoCredentialAdminApi_CreateSso_ByPlatformIdMutation_v3,
  useSsoCredentialAdminApi_DeleteSso_ByPlatformIdMutation_v3: () => useSsoCredentialAdminApi_DeleteSso_ByPlatformIdMutation_v3,
  useSsoCredentialAdminApi_GetPlatformsSso_v3: () => useSsoCredentialAdminApi_GetPlatformsSso_v3,
  useSsoCredentialAdminApi_GetSso_ByPlatformId_v3: () => useSsoCredentialAdminApi_GetSso_ByPlatformId_v3,
  useSsoCredentialAdminApi_PatchSso_ByPlatformIdMutation_v3: () => useSsoCredentialAdminApi_PatchSso_ByPlatformIdMutation_v3,
  useSsoSaml20Api_PostAuthenticateSamlSso_ByPlatformIdMutation_v3: () => useSsoSaml20Api_PostAuthenticateSamlSso_ByPlatformIdMutation_v3,
  useThirdPartyCredentialAdminApi_CreateClient_ByPlatformIdMutation_v3: () => useThirdPartyCredentialAdminApi_CreateClient_ByPlatformIdMutation_v3,
  useThirdPartyCredentialAdminApi_DeleteClientDomain_ByPlatformIdMutation_v3: () => useThirdPartyCredentialAdminApi_DeleteClientDomain_ByPlatformIdMutation_v3,
  useThirdPartyCredentialAdminApi_DeleteClient_ByPlatformIdMutation_v3: () => useThirdPartyCredentialAdminApi_DeleteClient_ByPlatformIdMutation_v3,
  useThirdPartyCredentialAdminApi_GetAvailability_ByPlatformId_v3: () => useThirdPartyCredentialAdminApi_GetAvailability_ByPlatformId_v3,
  useThirdPartyCredentialAdminApi_GetClients_ByPlatformId_v3: () => useThirdPartyCredentialAdminApi_GetClients_ByPlatformId_v3,
  useThirdPartyCredentialAdminApi_GetPlatformsAllClientsActive_v3: () => useThirdPartyCredentialAdminApi_GetPlatformsAllClientsActive_v3,
  useThirdPartyCredentialAdminApi_GetPlatformsAllClients_v3: () => useThirdPartyCredentialAdminApi_GetPlatformsAllClients_v3,
  useThirdPartyCredentialAdminApi_PatchClient_ByPlatformIdMutation_v3: () => useThirdPartyCredentialAdminApi_PatchClient_ByPlatformIdMutation_v3,
  useThirdPartyCredentialAdminApi_UpdateClientDomain_ByPlatformIdMutation_v3: () => useThirdPartyCredentialAdminApi_UpdateClientDomain_ByPlatformIdMutation_v3,
  useThirdPartyCredentialApi_GetPlatformsClientsActive_v3: () => useThirdPartyCredentialApi_GetPlatformsClientsActive_v3,
  useThirdPartyCredentialApi_GetPlatformsClientsOidc_v3: () => useThirdPartyCredentialApi_GetPlatformsClientsOidc_v3,
  useUsersAdminApi_CreateBan_ByUserIdMutation_v2: () => useUsersAdminApi_CreateBan_ByUserIdMutation_v2,
  useUsersAdminApi_CreateBan_ByUserIdMutation_v3: () => useUsersAdminApi_CreateBan_ByUserIdMutation_v3,
  useUsersAdminApi_CreatePermission_ByUserIdMutation_v3: () => useUsersAdminApi_CreatePermission_ByUserIdMutation_v3,
  useUsersAdminApi_CreatePlatformJustice_ByUserId_ByTargetNamespaceMutation_v3: () => useUsersAdminApi_CreatePlatformJustice_ByUserId_ByTargetNamespaceMutation_v3,
  useUsersAdminApi_CreateUserBulkMutation_v3: () => useUsersAdminApi_CreateUserBulkMutation_v3,
  useUsersAdminApi_CreateUserInviteMutation_v3: () => useUsersAdminApi_CreateUserInviteMutation_v3,
  useUsersAdminApi_DeleteAll_ByUserId_ByPlatformIdMutation_v3: () => useUsersAdminApi_DeleteAll_ByUserId_ByPlatformIdMutation_v3,
  useUsersAdminApi_DeleteInformation_ByUserIdMutation_v3: () => useUsersAdminApi_DeleteInformation_ByUserIdMutation_v3,
  useUsersAdminApi_DeleteLinkHistory_ByUserId_ByPlatformIdMutation_v3: () => useUsersAdminApi_DeleteLinkHistory_ByUserId_ByPlatformIdMutation_v3,
  useUsersAdminApi_DeleteLinkRestriction_ByUserId_ByPlatformIdMutation_v3: () => useUsersAdminApi_DeleteLinkRestriction_ByUserId_ByPlatformIdMutation_v3,
  useUsersAdminApi_DeleteLink_ByUserId_ByPlatformIdMutation_v2: () => useUsersAdminApi_DeleteLink_ByUserId_ByPlatformIdMutation_v2,
  useUsersAdminApi_DeletePermission_ByUserIdMutation_v3: () => useUsersAdminApi_DeletePermission_ByUserIdMutation_v3,
  useUsersAdminApi_DeletePermission_ByUserId_ByResource_ByActionMutation_v3: () => useUsersAdminApi_DeletePermission_ByUserId_ByResource_ByActionMutation_v3,
  useUsersAdminApi_DeletePlatform_ByUserId_ByPlatformIdMutation_v3: () => useUsersAdminApi_DeletePlatform_ByUserId_ByPlatformIdMutation_v3,
  useUsersAdminApi_DeleteRole_ByUserIdMutation_v3: () => useUsersAdminApi_DeleteRole_ByUserIdMutation_v3,
  useUsersAdminApi_DeleteRole_ByUserId_ByRoleIdMutation_v3: () => useUsersAdminApi_DeleteRole_ByUserId_ByRoleIdMutation_v3,
  useUsersAdminApi_FetchUserBan_v3: () => useUsersAdminApi_FetchUserBan_v3,
  useUsersAdminApi_FetchUserBulkPlatform_v3: () => useUsersAdminApi_FetchUserBulkPlatform_v3,
  useUsersAdminApi_FetchUserSearchBulk_v3: () => useUsersAdminApi_FetchUserSearchBulk_v3,
  useUsersAdminApi_FetchUser_ByPlatformId_v3: () => useUsersAdminApi_FetchUser_ByPlatformId_v3,
  useUsersAdminApi_GetAdmins_v3: () => useUsersAdminApi_GetAdmins_v3,
  useUsersAdminApi_GetAgerestrictionsCountries_v3: () => useUsersAdminApi_GetAgerestrictionsCountries_v3,
  useUsersAdminApi_GetAgerestrictions_v2: () => useUsersAdminApi_GetAgerestrictions_v2,
  useUsersAdminApi_GetAgerestrictions_v3: () => useUsersAdminApi_GetAgerestrictions_v3,
  useUsersAdminApi_GetBansSummary_ByUserId_v3: () => useUsersAdminApi_GetBansSummary_ByUserId_v3,
  useUsersAdminApi_GetBans_ByUserId_v2: () => useUsersAdminApi_GetBans_ByUserId_v2,
  useUsersAdminApi_GetBans_ByUserId_v3: () => useUsersAdminApi_GetBans_ByUserId_v3,
  useUsersAdminApi_GetCodes_ByUserId_v3: () => useUsersAdminApi_GetCodes_ByUserId_v3,
  useUsersAdminApi_GetCountriesAgerestrictions_v2: () => useUsersAdminApi_GetCountriesAgerestrictions_v2,
  useUsersAdminApi_GetDeletionStatus_ByUserId_v3: () => useUsersAdminApi_GetDeletionStatus_ByUserId_v3,
  useUsersAdminApi_GetDistinctPlatforms_ByUserId_v3: () => useUsersAdminApi_GetDistinctPlatforms_ByUserId_v3,
  useUsersAdminApi_GetLoginsHistories_ByUserId_v3: () => useUsersAdminApi_GetLoginsHistories_ByUserId_v3,
  useUsersAdminApi_GetMetadata_ByUserId_ByPlatformId_v3: () => useUsersAdminApi_GetMetadata_ByUserId_ByPlatformId_v3,
  useUsersAdminApi_GetPlatformJustice_ByUserId_ByTargetNamespace_v3: () => useUsersAdminApi_GetPlatformJustice_ByUserId_ByTargetNamespace_v3,
  useUsersAdminApi_GetPlatformsDistinct_ByUserId_v3: () => useUsersAdminApi_GetPlatformsDistinct_ByUserId_v3,
  useUsersAdminApi_GetPlatformsJustice_ByUserId_v3: () => useUsersAdminApi_GetPlatformsJustice_ByUserId_v3,
  useUsersAdminApi_GetPlatformsLinkHistories_ByUserId_v3: () => useUsersAdminApi_GetPlatformsLinkHistories_ByUserId_v3,
  useUsersAdminApi_GetPlatforms_ByUserId_v3: () => useUsersAdminApi_GetPlatforms_ByUserId_v3,
  useUsersAdminApi_GetUser_ByPlatformId_ByPlatformUserId_v3: () => useUsersAdminApi_GetUser_ByPlatformId_ByPlatformUserId_v3,
  useUsersAdminApi_GetUser_ByUserId_v2: () => useUsersAdminApi_GetUser_ByUserId_v2,
  useUsersAdminApi_GetUser_ByUserId_v3: () => useUsersAdminApi_GetUser_ByUserId_v3,
  useUsersAdminApi_GetUsersLinkhistories_v3: () => useUsersAdminApi_GetUsersLinkhistories_v3,
  useUsersAdminApi_GetUsersMe_v3: () => useUsersAdminApi_GetUsersMe_v3,
  useUsersAdminApi_GetUsersPlatformsJustice_v3: () => useUsersAdminApi_GetUsersPlatformsJustice_v3,
  useUsersAdminApi_GetUsersSearch_v3: () => useUsersAdminApi_GetUsersSearch_v3,
  useUsersAdminApi_GetUsers_ByRoleId_v3: () => useUsersAdminApi_GetUsers_ByRoleId_v3,
  useUsersAdminApi_GetUsers_v2: () => useUsersAdminApi_GetUsers_v2,
  useUsersAdminApi_GetUsers_v3: () => useUsersAdminApi_GetUsers_v3,
  useUsersAdminApi_PatchAgerestrictionCountry_ByCountryCodeMutation_v3: () => useUsersAdminApi_PatchAgerestrictionCountry_ByCountryCodeMutation_v3,
  useUsersAdminApi_PatchAgerestrictionMutation_v2: () => useUsersAdminApi_PatchAgerestrictionMutation_v2,
  useUsersAdminApi_PatchAgerestrictionMutation_v3: () => useUsersAdminApi_PatchAgerestrictionMutation_v3,
  useUsersAdminApi_PatchBan_ByUserId_ByBanIdMutation_v3: () => useUsersAdminApi_PatchBan_ByUserId_ByBanIdMutation_v3,
  useUsersAdminApi_PatchCountry_ByCountryCodeMutation_v2: () => useUsersAdminApi_PatchCountry_ByCountryCodeMutation_v2,
  useUsersAdminApi_PatchDeletionStatus_ByUserIdMutation_v3: () => useUsersAdminApi_PatchDeletionStatus_ByUserIdMutation_v3,
  useUsersAdminApi_PatchRole_ByUserIdMutation_v3: () => useUsersAdminApi_PatchRole_ByUserIdMutation_v3,
  useUsersAdminApi_PatchStatus_ByUserIdMutation_v3: () => useUsersAdminApi_PatchStatus_ByUserIdMutation_v3,
  useUsersAdminApi_PatchTrustlyIdentity_ByUserIdMutation_v3: () => useUsersAdminApi_PatchTrustlyIdentity_ByUserIdMutation_v3,
  useUsersAdminApi_PatchUser_ByUserIdMutation_v2: () => useUsersAdminApi_PatchUser_ByUserIdMutation_v2,
  useUsersAdminApi_PatchUser_ByUserIdMutation_v3: () => useUsersAdminApi_PatchUser_ByUserIdMutation_v3,
  useUsersAdminApi_PostLinkStatu_ByUserId_ByPlatformIdMutation_v3: () => useUsersAdminApi_PostLinkStatu_ByUserId_ByPlatformIdMutation_v3,
  useUsersAdminApi_PostLink_ByUserId_ByPlatformIdMutation_v3: () => useUsersAdminApi_PostLink_ByUserId_ByPlatformIdMutation_v3,
  useUsersAdminApi_UpdateCodeRequest_ByUserIdMutation_v3: () => useUsersAdminApi_UpdateCodeRequest_ByUserIdMutation_v3,
  useUsersAdminApi_UpdateCodeVerify_ByUserIdMutation_v3: () => useUsersAdminApi_UpdateCodeVerify_ByUserIdMutation_v3,
  useUsersAdminApi_UpdateDisable_ByUserIdMutation_v2: () => useUsersAdminApi_UpdateDisable_ByUserIdMutation_v2,
  useUsersAdminApi_UpdateEnable_ByUserIdMutation_v2: () => useUsersAdminApi_UpdateEnable_ByUserIdMutation_v2,
  useUsersAdminApi_UpdateHeadlesCodeVerify_ByUserIdMutation_v3: () => useUsersAdminApi_UpdateHeadlesCodeVerify_ByUserIdMutation_v3,
  useUsersAdminApi_UpdatePassword_ByUserIdMutation_v2: () => useUsersAdminApi_UpdatePassword_ByUserIdMutation_v2,
  useUsersAdminApi_UpdatePassword_ByUserIdMutation_v3: () => useUsersAdminApi_UpdatePassword_ByUserIdMutation_v3,
  useUsersAdminApi_UpdatePermission_ByUserIdMutation_v3: () => useUsersAdminApi_UpdatePermission_ByUserIdMutation_v3,
  useUsersAdminApi_UpdatePlatformLink_ByUserIdMutation_v3: () => useUsersAdminApi_UpdatePlatformLink_ByUserIdMutation_v3,
  useUsersAdminApi_UpdateRole_ByUserIdMutation_v2: () => useUsersAdminApi_UpdateRole_ByUserIdMutation_v2,
  useUsersAdminApi_UpdateRole_ByUserId_ByNSMutation_v2: () => useUsersAdminApi_UpdateRole_ByUserId_ByNSMutation_v2,
  useUsersAdminApi_UpdateRole_ByUserId_ByRoleIdMutation_v3: () => useUsersAdminApi_UpdateRole_ByUserId_ByRoleIdMutation_v3,
  useUsersAdminApi_UpdateUserMutation_v3: () => useUsersAdminApi_UpdateUserMutation_v3,
  useUsersAdminApi_UpdateVerify_ByUserIdMutation_v3: () => useUsersAdminApi_UpdateVerify_ByUserIdMutation_v3,
  useUsersApi_CreateBan_ByUserIdMutation: () => useUsersApi_CreateBan_ByUserIdMutation,
  useUsersApi_CreatePlatformLinkWithProgression_ByUserIdMutation_v3: () => useUsersApi_CreatePlatformLinkWithProgression_ByUserIdMutation_v3,
  useUsersApi_CreatePlatformLink_ByUserIdMutation_v3: () => useUsersApi_CreatePlatformLink_ByUserIdMutation_v3,
  useUsersApi_CreateUserBulkBasicMutation_v3: () => useUsersApi_CreateUserBulkBasicMutation_v3,
  useUsersApi_CreateUserCodeRequestMutation_v3: () => useUsersApi_CreateUserCodeRequestMutation_v3,
  useUsersApi_CreateUserCodeVerifyMutation_v3: () => useUsersApi_CreateUserCodeVerifyMutation_v3,
  useUsersApi_CreateUserForgotMutation_v3: () => useUsersApi_CreateUserForgotMutation_v3,
  useUsersApi_CreateUserForgotPasswordMutation: () => useUsersApi_CreateUserForgotPasswordMutation,
  useUsersApi_CreateUserForgotPasswordMutation_v2: () => useUsersApi_CreateUserForgotPasswordMutation_v2,
  useUsersApi_CreateUserInputValidationMutation_v3: () => useUsersApi_CreateUserInputValidationMutation_v3,
  useUsersApi_CreateUserInvite_ByInvitationIdMutation_v3: () => useUsersApi_CreateUserInvite_ByInvitationIdMutation_v3,
  useUsersApi_CreateUserMeCodeRequestMutation_v3: () => useUsersApi_CreateUserMeCodeRequestMutation_v3,
  useUsersApi_CreateUserMeCodeVerifyMutation_v3: () => useUsersApi_CreateUserMeCodeVerifyMutation_v3,
  useUsersApi_CreateUserMeHeadlesCodeVerifyMutation_v3: () => useUsersApi_CreateUserMeHeadlesCodeVerifyMutation_v3,
  useUsersApi_CreateUserMeHeadlesLinkWithProgressionMutation_v3: () => useUsersApi_CreateUserMeHeadlesLinkWithProgressionMutation_v3,
  useUsersApi_CreateUserMeHeadlesVerifyMutation_v3: () => useUsersApi_CreateUserMeHeadlesVerifyMutation_v3,
  useUsersApi_CreateUserMePlatformJustice_ByTargetNamespaceMutation_v3: () => useUsersApi_CreateUserMePlatformJustice_ByTargetNamespaceMutation_v3,
  useUsersApi_CreateUserMeVerifyLinkRequestMutation_v3: () => useUsersApi_CreateUserMeVerifyLinkRequestMutation_v3,
  useUsersApi_CreateUserMutation: () => useUsersApi_CreateUserMutation,
  useUsersApi_CreateUserMutation_v2: () => useUsersApi_CreateUserMutation_v2,
  useUsersApi_CreateUserMutation_v3: () => useUsersApi_CreateUserMutation_v3,
  useUsersApi_CreateUserPlatformMutation_v3: () => useUsersApi_CreateUserPlatformMutation_v3,
  useUsersApi_CreateUserResetMutation_v3: () => useUsersApi_CreateUserResetMutation_v3,
  useUsersApi_CreateUserResetPasswordMutation: () => useUsersApi_CreateUserResetPasswordMutation,
  useUsersApi_CreateUserResetPasswordMutation_v2: () => useUsersApi_CreateUserResetPasswordMutation_v2,
  useUsersApi_CreateUser_ByPlatformIdMutation_v3: () => useUsersApi_CreateUser_ByPlatformIdMutation_v3,
  useUsersApi_DeleteAllMeUser_ByPlatformIdMutation_v3: () => useUsersApi_DeleteAllMeUser_ByPlatformIdMutation_v3,
  useUsersApi_DeleteInformation_ByUserIdMutation: () => useUsersApi_DeleteInformation_ByUserIdMutation,
  useUsersApi_DeleteLink_ByUserId_ByPlatformIdMutation_v2: () => useUsersApi_DeleteLink_ByUserId_ByPlatformIdMutation_v2,
  useUsersApi_DeletePermission_ByUserId_ByResource_ByActionMutation: () => useUsersApi_DeletePermission_ByUserId_ByResource_ByActionMutation,
  useUsersApi_DeleteRole_ByUserId_ByRoleIdMutation: () => useUsersApi_DeleteRole_ByUserId_ByRoleIdMutation,
  useUsersApi_DeleteUserMePlatform_ByPlatformIdMutation_v3: () => useUsersApi_DeleteUserMePlatform_ByPlatformIdMutation_v3,
  useUsersApi_DeleteUser_ByUserIdMutation: () => useUsersApi_DeleteUser_ByUserIdMutation,
  useUsersApi_GetAgerestrictionCountry_ByCountryCode_v3: () => useUsersApi_GetAgerestrictionCountry_ByCountryCode_v3,
  useUsersApi_GetAgerestrictions_ByCountryCode_v2: () => useUsersApi_GetAgerestrictions_ByCountryCode_v2,
  useUsersApi_GetAsyncStatus_ByRequestId_v3: () => useUsersApi_GetAsyncStatus_ByRequestId_v3,
  useUsersApi_GetBans_ByUserId: () => useUsersApi_GetBans_ByUserId,
  useUsersApi_GetBans_ByUserId_v2: () => useUsersApi_GetBans_ByUserId_v2,
  useUsersApi_GetBans_ByUserId_v3: () => useUsersApi_GetBans_ByUserId_v3,
  useUsersApi_GetDistinctPlatforms_ByUserId_v3: () => useUsersApi_GetDistinctPlatforms_ByUserId_v3,
  useUsersApi_GetInformation_ByUserId: () => useUsersApi_GetInformation_ByUserId,
  useUsersApi_GetInformation_ByUserId_v3: () => useUsersApi_GetInformation_ByUserId_v3,
  useUsersApi_GetLoginsHistories_ByUserId: () => useUsersApi_GetLoginsHistories_ByUserId,
  useUsersApi_GetLoginsHistories_ByUserId_v3: () => useUsersApi_GetLoginsHistories_ByUserId_v3,
  useUsersApi_GetPlatformJustice_ByUserId_ByTargetNamespace: () => useUsersApi_GetPlatformJustice_ByUserId_ByTargetNamespace,
  useUsersApi_GetPlatformsJustice_ByUserId_v2: () => useUsersApi_GetPlatformsJustice_ByUserId_v2,
  useUsersApi_GetPlatformsJustice_ByUserId_v3: () => useUsersApi_GetPlatformsJustice_ByUserId_v3,
  useUsersApi_GetPlatforms_ByUserId: () => useUsersApi_GetPlatforms_ByUserId,
  useUsersApi_GetPlatforms_ByUserId_v3: () => useUsersApi_GetPlatforms_ByUserId_v3,
  useUsersApi_GetPublisher_ByUserId: () => useUsersApi_GetPublisher_ByUserId,
  useUsersApi_GetPublisher_ByUserId_v3: () => useUsersApi_GetPublisher_ByUserId_v3,
  useUsersApi_GetUserInvite_ByInvitationId_v3: () => useUsersApi_GetUserInvite_ByInvitationId_v3,
  useUsersApi_GetUser_ByPlatformId_ByPlatformUserId_v3: () => useUsersApi_GetUser_ByPlatformId_ByPlatformUserId_v3,
  useUsersApi_GetUser_ByUserId: () => useUsersApi_GetUser_ByUserId,
  useUsersApi_GetUser_ByUserId_v2: () => useUsersApi_GetUser_ByUserId_v2,
  useUsersApi_GetUser_ByUserId_v3: () => useUsersApi_GetUser_ByUserId_v3,
  useUsersApi_GetUsersAdmin: () => useUsersApi_GetUsersAdmin,
  useUsersApi_GetUsersAvailability_v3: () => useUsersApi_GetUsersAvailability_v3,
  useUsersApi_GetUsersByLoginId: () => useUsersApi_GetUsersByLoginId,
  useUsersApi_GetUsersByPlatformUserId: () => useUsersApi_GetUsersByPlatformUserId,
  useUsersApi_GetUsersListByLoginIds: () => useUsersApi_GetUsersListByLoginIds,
  useUsersApi_GetUsersMeHeadlessLinkConflict_v3: () => useUsersApi_GetUsersMeHeadlessLinkConflict_v3,
  useUsersApi_GetUsersMeProfileStatus_v3: () => useUsersApi_GetUsersMeProfileStatus_v3,
  useUsersApi_GetUsersMe_v3: () => useUsersApi_GetUsersMe_v3,
  useUsersApi_GetUsersSearch: () => useUsersApi_GetUsersSearch,
  useUsersApi_GetUsersVerifyLinkVerify_v3: () => useUsersApi_GetUsersVerifyLinkVerify_v3,
  useUsersApi_GetUsers_v3: () => useUsersApi_GetUsers_v3,
  useUsersApi_GetWebLinkEstablishMeUsers_ByPlatformId_v3: () => useUsersApi_GetWebLinkEstablishMeUsers_ByPlatformId_v3,
  useUsersApi_GetWebLinkMeUsers_ByPlatformId_v3: () => useUsersApi_GetWebLinkMeUsers_ByPlatformId_v3,
  useUsersApi_PatchUserMeMutation_v3: () => useUsersApi_PatchUserMeMutation_v3,
  useUsersApi_PatchUser_ByUserIdMutation_v2: () => useUsersApi_PatchUser_ByUserIdMutation_v2,
  useUsersApi_PostCrosslink_ByUserIdMutation: () => useUsersApi_PostCrosslink_ByUserIdMutation,
  useUsersApi_PostForceMeUser_ByPlatformIdMutation_v3: () => useUsersApi_PostForceMeUser_ByPlatformIdMutation_v3,
  useUsersApi_PostLink_ByUserId_ByPlatformIdMutation: () => useUsersApi_PostLink_ByUserId_ByPlatformIdMutation,
  useUsersApi_PostLink_ByUserId_ByPlatformIdMutation_v2: () => useUsersApi_PostLink_ByUserId_ByPlatformIdMutation_v2,
  useUsersApi_PostUnlink_ByUserId_ByPlatformIdMutation: () => useUsersApi_PostUnlink_ByUserId_ByPlatformIdMutation,
  useUsersApi_PostUserMePlatform_ByPlatformIdMutation_v3: () => useUsersApi_PostUserMePlatform_ByPlatformIdMutation_v3,
  useUsersApi_PostValidate_ByUserIdMutation_v3: () => useUsersApi_PostValidate_ByUserIdMutation_v3,
  useUsersApi_PostWebLinkProcesMeUser_ByPlatformIdMutation_v3: () => useUsersApi_PostWebLinkProcesMeUser_ByPlatformIdMutation_v3,
  useUsersApi_UpdateDisable_ByUserIdMutation: () => useUsersApi_UpdateDisable_ByUserIdMutation,
  useUsersApi_UpdateDisable_ByUserId_ByBanIdMutation: () => useUsersApi_UpdateDisable_ByUserId_ByBanIdMutation,
  useUsersApi_UpdateEnable_ByUserIdMutation: () => useUsersApi_UpdateEnable_ByUserIdMutation,
  useUsersApi_UpdateEnable_ByUserId_ByBanIdMutation: () => useUsersApi_UpdateEnable_ByUserId_ByBanIdMutation,
  useUsersApi_UpdatePassword_ByUserIdMutation: () => useUsersApi_UpdatePassword_ByUserIdMutation,
  useUsersApi_UpdatePassword_ByUserIdMutation_v2: () => useUsersApi_UpdatePassword_ByUserIdMutation_v2,
  useUsersApi_UpdatePermission_ByUserIdMutation: () => useUsersApi_UpdatePermission_ByUserIdMutation,
  useUsersApi_UpdatePermission_ByUserId_ByResource_ByActionMutation: () => useUsersApi_UpdatePermission_ByUserId_ByResource_ByActionMutation,
  useUsersApi_UpdatePlatformJustice_ByUserId_ByTargetNamespaceMutation: () => useUsersApi_UpdatePlatformJustice_ByUserId_ByTargetNamespaceMutation,
  useUsersApi_UpdateRole_ByUserIdMutation: () => useUsersApi_UpdateRole_ByUserIdMutation,
  useUsersApi_UpdateRole_ByUserId_ByRoleIdMutation: () => useUsersApi_UpdateRole_ByUserId_ByRoleIdMutation,
  useUsersApi_UpdateUpgradeHeadlessAccountWithVerificationCode_ByUserIdMutation: () => useUsersApi_UpdateUpgradeHeadlessAccountWithVerificationCode_ByUserIdMutation,
  useUsersApi_UpdateUpgradeHeadlessAccount_ByUserIdMutation: () => useUsersApi_UpdateUpgradeHeadlessAccount_ByUserIdMutation,
  useUsersApi_UpdateUserMeMutation_v3: () => useUsersApi_UpdateUserMeMutation_v3,
  useUsersApi_UpdateUserMePasswordMutation_v3: () => useUsersApi_UpdateUserMePasswordMutation_v3,
  useUsersApi_UpdateUser_ByUserIdMutation: () => useUsersApi_UpdateUser_ByUserIdMutation,
  useUsersApi_UpdateVerification_ByUserIdMutation: () => useUsersApi_UpdateVerification_ByUserIdMutation,
  useUsersApi_UpdateVerificationcode_ByUserIdMutation: () => useUsersApi_UpdateVerificationcode_ByUserIdMutation,
  useUsersV4AdminApi_CreateTestUserMutation_v4: () => useUsersV4AdminApi_CreateTestUserMutation_v4,
  useUsersV4AdminApi_CreateUserInviteMutation_v4: () => useUsersV4AdminApi_CreateUserInviteMutation_v4,
  useUsersV4AdminApi_CreateUserMeMfaAuthenticatorKeyMutation_v4: () => useUsersV4AdminApi_CreateUserMeMfaAuthenticatorKeyMutation_v4,
  useUsersV4AdminApi_CreateUserMeMfaBackupCodeEnableMutation_v4: () => useUsersV4AdminApi_CreateUserMeMfaBackupCodeEnableMutation_v4,
  useUsersV4AdminApi_CreateUserMeMfaBackupCodeEnable_adminMutation_v4: () => useUsersV4AdminApi_CreateUserMeMfaBackupCodeEnable_adminMutation_v4,
  useUsersV4AdminApi_CreateUserMeMfaBackupCodeMutation_v4: () => useUsersV4AdminApi_CreateUserMeMfaBackupCodeMutation_v4,
  useUsersV4AdminApi_CreateUserMeMfaBackupCode_adminMutation_v4: () => useUsersV4AdminApi_CreateUserMeMfaBackupCode_adminMutation_v4,
  useUsersV4AdminApi_CreateUserMeMfaEmailDisableMutation_v4: () => useUsersV4AdminApi_CreateUserMeMfaEmailDisableMutation_v4,
  useUsersV4AdminApi_CreateUserMeMfaStatusMutation_v4: () => useUsersV4AdminApi_CreateUserMeMfaStatusMutation_v4,
  useUsersV4AdminApi_CreateUserMutation_v4: () => useUsersV4AdminApi_CreateUserMutation_v4,
  useUsersV4AdminApi_CreateUserUserInviteMutation_v4: () => useUsersV4AdminApi_CreateUserUserInviteMutation_v4,
  useUsersV4AdminApi_DeleteMfaDisable_ByUserIdMutation_v4: () => useUsersV4AdminApi_DeleteMfaDisable_ByUserIdMutation_v4,
  useUsersV4AdminApi_DeleteRole_ByUserIdMutation_v4: () => useUsersV4AdminApi_DeleteRole_ByUserIdMutation_v4,
  useUsersV4AdminApi_DeleteUserMeMfaAuthenticatorDisableMutation_v4: () => useUsersV4AdminApi_DeleteUserMeMfaAuthenticatorDisableMutation_v4,
  useUsersV4AdminApi_DeleteUserMeMfaBackupCodeDisableMutation_v4: () => useUsersV4AdminApi_DeleteUserMeMfaBackupCodeDisableMutation_v4,
  useUsersV4AdminApi_FetchUserBulkValidate_v4: () => useUsersV4AdminApi_FetchUserBulkValidate_v4,
  useUsersV4AdminApi_GetInvitationHistoriesUsers_v4: () => useUsersV4AdminApi_GetInvitationHistoriesUsers_v4,
  useUsersV4AdminApi_GetInvitationHistories_ByNS_v4: () => useUsersV4AdminApi_GetInvitationHistories_ByNS_v4,
  useUsersV4AdminApi_GetInvitationHistories_v4: () => useUsersV4AdminApi_GetInvitationHistories_v4,
  useUsersV4AdminApi_GetMfaStatus_ByUserId_v4: () => useUsersV4AdminApi_GetMfaStatus_ByUserId_v4,
  useUsersV4AdminApi_GetRoles_ByUserId_v4: () => useUsersV4AdminApi_GetRoles_ByUserId_v4,
  useUsersV4AdminApi_GetUsersMeMfaBackupCodeDownload_v4: () => useUsersV4AdminApi_GetUsersMeMfaBackupCodeDownload_v4,
  useUsersV4AdminApi_GetUsersMeMfaBackupCode_v4: () => useUsersV4AdminApi_GetUsersMeMfaBackupCode_v4,
  useUsersV4AdminApi_GetUsersMeMfaBackupCodes_v4: () => useUsersV4AdminApi_GetUsersMeMfaBackupCodes_v4,
  useUsersV4AdminApi_GetUsersMeMfaFactor_v4: () => useUsersV4AdminApi_GetUsersMeMfaFactor_v4,
  useUsersV4AdminApi_GetUsersMeMfaStatus_v4: () => useUsersV4AdminApi_GetUsersMeMfaStatus_v4,
  useUsersV4AdminApi_PatchUserBulkAccountTypeMutation_v4: () => useUsersV4AdminApi_PatchUserBulkAccountTypeMutation_v4,
  useUsersV4AdminApi_PatchUserMeMutation_v4: () => useUsersV4AdminApi_PatchUserMeMutation_v4,
  useUsersV4AdminApi_PostUserMeMfaAuthenticatorEnableMutation_v4: () => useUsersV4AdminApi_PostUserMeMfaAuthenticatorEnableMutation_v4,
  useUsersV4AdminApi_PostUserMeMfaChallengeVerifyMutation_v4: () => useUsersV4AdminApi_PostUserMeMfaChallengeVerifyMutation_v4,
  useUsersV4AdminApi_PostUserMeMfaEmailCodeMutation_v4: () => useUsersV4AdminApi_PostUserMeMfaEmailCodeMutation_v4,
  useUsersV4AdminApi_PostUserMeMfaEmailEnableMutation_v4: () => useUsersV4AdminApi_PostUserMeMfaEmailEnableMutation_v4,
  useUsersV4AdminApi_PostUserMeMfaFactorMutation_v4: () => useUsersV4AdminApi_PostUserMeMfaFactorMutation_v4,
  useUsersV4AdminApi_UpdateEmail_ByUserIdMutation_v4: () => useUsersV4AdminApi_UpdateEmail_ByUserIdMutation_v4,
  useUsersV4AdminApi_UpdateRole_ByUserIdMutation_v4: () => useUsersV4AdminApi_UpdateRole_ByUserIdMutation_v4,
  useUsersV4AdminApi_UpdateRole_ByUserId_ByNSMutation_v4: () => useUsersV4AdminApi_UpdateRole_ByUserId_ByNSMutation_v4,
  useUsersV4AdminApi_UpdateUser_ByUserIdMutation_v4: () => useUsersV4AdminApi_UpdateUser_ByUserIdMutation_v4,
  useUsersV4Api_CreateTestUserMutation_v4: () => useUsersV4Api_CreateTestUserMutation_v4,
  useUsersV4Api_CreateUserInviteMutation_v4: () => useUsersV4Api_CreateUserInviteMutation_v4,
  useUsersV4Api_CreateUserInvite_ByInvitationIdMutation_v4: () => useUsersV4Api_CreateUserInvite_ByInvitationIdMutation_v4,
  useUsersV4Api_CreateUserMeHeadlesCodeVerifyMutation_v4: () => useUsersV4Api_CreateUserMeHeadlesCodeVerifyMutation_v4,
  useUsersV4Api_CreateUserMeHeadlesVerifyMutation_v4: () => useUsersV4Api_CreateUserMeHeadlesVerifyMutation_v4,
  useUsersV4Api_CreateUserMeMfaAuthenticatorKeyMutation_v4: () => useUsersV4Api_CreateUserMeMfaAuthenticatorKeyMutation_v4,
  useUsersV4Api_CreateUserMeMfaBackupCodeEnableMutation_v4: () => useUsersV4Api_CreateUserMeMfaBackupCodeEnableMutation_v4,
  useUsersV4Api_CreateUserMeMfaBackupCodeEnable_ByNSMutation_v4: () => useUsersV4Api_CreateUserMeMfaBackupCodeEnable_ByNSMutation_v4,
  useUsersV4Api_CreateUserMeMfaBackupCodeMutation_v4: () => useUsersV4Api_CreateUserMeMfaBackupCodeMutation_v4,
  useUsersV4Api_CreateUserMeMfaBackupCode_ByNSMutation_v4: () => useUsersV4Api_CreateUserMeMfaBackupCode_ByNSMutation_v4,
  useUsersV4Api_CreateUserMeMfaEmailDisableMutation_v4: () => useUsersV4Api_CreateUserMeMfaEmailDisableMutation_v4,
  useUsersV4Api_CreateUserMeMfaStatusMutation_v4: () => useUsersV4Api_CreateUserMeMfaStatusMutation_v4,
  useUsersV4Api_CreateUserMutation_v4: () => useUsersV4Api_CreateUserMutation_v4,
  useUsersV4Api_CreateUser_ByPlatformIdMutation_v4: () => useUsersV4Api_CreateUser_ByPlatformIdMutation_v4,
  useUsersV4Api_DeleteUserMeMfaAuthenticatorDisableMutation_v4: () => useUsersV4Api_DeleteUserMeMfaAuthenticatorDisableMutation_v4,
  useUsersV4Api_DeleteUserMeMfaBackupCodeDisableMutation_v4: () => useUsersV4Api_DeleteUserMeMfaBackupCodeDisableMutation_v4,
  useUsersV4Api_DeleteUserMeMfaDeviceMutation_v4: () => useUsersV4Api_DeleteUserMeMfaDeviceMutation_v4,
  useUsersV4Api_GetUser_ByUserId_v4: () => useUsersV4Api_GetUser_ByUserId_v4,
  useUsersV4Api_GetUsersMeMfaBackupCodeDownload_v4: () => useUsersV4Api_GetUsersMeMfaBackupCodeDownload_v4,
  useUsersV4Api_GetUsersMeMfaBackupCode_v4: () => useUsersV4Api_GetUsersMeMfaBackupCode_v4,
  useUsersV4Api_GetUsersMeMfaBackupCodes_v4: () => useUsersV4Api_GetUsersMeMfaBackupCodes_v4,
  useUsersV4Api_GetUsersMeMfaFactor_v4: () => useUsersV4Api_GetUsersMeMfaFactor_v4,
  useUsersV4Api_GetUsersMeMfaStatus_v4: () => useUsersV4Api_GetUsersMeMfaStatus_v4,
  useUsersV4Api_PatchUserMeMutation_v4: () => useUsersV4Api_PatchUserMeMutation_v4,
  useUsersV4Api_PostUserMeMfaAuthenticatorEnableMutation_v4: () => useUsersV4Api_PostUserMeMfaAuthenticatorEnableMutation_v4,
  useUsersV4Api_PostUserMeMfaChallengeVerifyMutation_v4: () => useUsersV4Api_PostUserMeMfaChallengeVerifyMutation_v4,
  useUsersV4Api_PostUserMeMfaEmailCodeMutation_v4: () => useUsersV4Api_PostUserMeMfaEmailCodeMutation_v4,
  useUsersV4Api_PostUserMeMfaEmailEnableMutation_v4: () => useUsersV4Api_PostUserMeMfaEmailEnableMutation_v4,
  useUsersV4Api_PostUserMeMfaFactorMutation_v4: () => useUsersV4Api_PostUserMeMfaFactorMutation_v4,
  useUsersV4Api_UpdateUserMeEmailMutation_v4: () => useUsersV4Api_UpdateUserMeEmailMutation_v4
});
module.exports = __toCommonJS(all_query_imports_exports);

// src/generated-admin/queries/BansAdmin.query.ts
var import_react_query = require("@tanstack/react-query");

// src/generated-admin/BansAdminApi.ts
var import_sdk2 = require("@accelbyte/sdk");

// src/generated-admin/endpoints/BansAdmin$.ts
var import_sdk = require("@accelbyte/sdk");

// src/generated-definitions/BanReasonsV3.ts
var import_zod2 = require("zod");

// src/generated-definitions/BanReasonV3.ts
var import_zod = require("zod");
var BanReasonV3 = import_zod.z.object({ description: import_zod.z.string(), reason: import_zod.z.string() });

// src/generated-definitions/BanReasonsV3.ts
var BanReasonsV3 = import_zod2.z.object({ reasons: import_zod2.z.array(BanReasonV3) });

// src/generated-definitions/BansV3.ts
var import_zod5 = require("zod");

// src/generated-definitions/BanV3.ts
var import_zod4 = require("zod");

// src/generated-definitions/Description.ts
var import_zod3 = require("zod");
var Description = import_zod3.z.object({ "en-US": import_zod3.z.string(), "zh-CN": import_zod3.z.string() });

// src/generated-definitions/BanV3.ts
var BanV3 = import_zod4.z.object({ ban: import_zod4.z.string(), description: import_zod4.z.string().nullish(), descriptions: Description.nullish(), type: import_zod4.z.string() });

// src/generated-definitions/BansV3.ts
var BansV3 = import_zod5.z.object({ bans: import_zod5.z.array(BanV3) });

// src/generated-definitions/GetUserBanV3Response.ts
var import_zod9 = require("zod");

// src/generated-definitions/PaginationV3.ts
var import_zod6 = require("zod");
var PaginationV3 = import_zod6.z.object({ first: import_zod6.z.string(), last: import_zod6.z.string(), next: import_zod6.z.string(), previous: import_zod6.z.string() });

// src/generated-definitions/UserBanResponseV3.ts
var import_zod8 = require("zod");

// src/generated-definitions/BannedByV3.ts
var import_zod7 = require("zod");
var BannedByV3 = import_zod7.z.object({ displayName: import_zod7.z.string(), userId: import_zod7.z.string() });

// src/generated-definitions/UserBanResponseV3.ts
var UserBanResponseV3 = import_zod8.z.object({
  ban: import_zod8.z.string(),
  banId: import_zod8.z.string(),
  bannedBy: BannedByV3,
  comment: import_zod8.z.string(),
  createdAt: import_zod8.z.string(),
  disabledDate: import_zod8.z.string(),
  enabled: import_zod8.z.boolean(),
  endDate: import_zod8.z.string(),
  namespace: import_zod8.z.string(),
  reason: import_zod8.z.string(),
  userId: import_zod8.z.string()
});

// src/generated-definitions/GetUserBanV3Response.ts
var GetUserBanV3Response = import_zod9.z.object({ data: import_zod9.z.array(UserBanResponseV3), paging: PaginationV3 });

// src/generated-definitions/ListBulkUserBanResponseV3.ts
var import_zod11 = require("zod");

// src/generated-definitions/FailedBanUnbanUserV3.ts
var import_zod10 = require("zod");
var FailedBanUnbanUserV3 = import_zod10.z.object({ reason: import_zod10.z.string(), userId: import_zod10.z.string() });

// src/generated-definitions/ListBulkUserBanResponseV3.ts
var ListBulkUserBanResponseV3 = import_zod11.z.object({ failedBans: import_zod11.z.array(FailedBanUnbanUserV3), successBans: import_zod11.z.array(UserBanResponseV3) });

// src/generated-admin/endpoints/BansAdmin$.ts
var BansAdmin$ = class {
  // @ts-ignore
  // prettier-ignore
  constructor(axiosInstance, namespace, useSchemaValidation = true) {
    this.axiosInstance = axiosInstance;
    this.namespace = namespace;
    this.useSchemaValidation = useSchemaValidation;
  }
  /**
   * Ban type is the code available for ban assignment. It is applicable globally for any namespace. action code : 10201
   */
  getBans_v3() {
    const params = {};
    const url = "/iam/v3/admin/bans";
    const resultPromise = this.axiosInstance.get(url, { params });
    return import_sdk.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, BansV3, "BansV3");
  }
  /**
   * Ban reasons is the code available to justify ban assignment. It is applicable globally for any namespace. action code : 10202
   */
  getBansReasons_v3() {
    const params = {};
    const url = "/iam/v3/admin/bans/reasons";
    const resultPromise = this.axiosInstance.get(url, { params });
    return import_sdk.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, BanReasonsV3, "BanReasonsV3");
  }
  /**
   * Ban type is the code available for ban assignment. It is applicable globally for any namespace. action code : 10201
   */
  getBantypes_v3() {
    const params = {};
    const url = "/iam/v3/admin/namespaces/{namespace}/bantypes".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.get(url, { params });
    return import_sdk.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, BansV3, "BansV3");
  }
  /**
   * Ban type is the code available for ban assignment. It is applicable globally for any namespace. action code : 10201
   */
  getBansUsers_v3(queryParams) {
    const params = { ...queryParams };
    const url = "/iam/v3/admin/namespaces/{namespace}/bans/users".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.get(url, { params });
    return import_sdk.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, GetUserBanV3Response, "GetUserBanV3Response");
  }
  /**
   * Bulk ban user with specific type of ban. Ban types and reason can be queried. The maximum limit value is 100 userIDs action code : 10141
   */
  createBanUser_v3(data) {
    const params = {};
    const url = "/iam/v3/admin/namespaces/{namespace}/bans/users".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.post(url, data, { params });
    return import_sdk.Validate.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      ListBulkUserBanResponseV3,
      "ListBulkUserBanResponseV3"
    );
  }
  /**
   * disable bulk ban user. The maximum limit value is 100 action code : 10142
   */
  patchBanUserDisabled_v3(data) {
    const params = {};
    const url = "/iam/v3/admin/namespaces/{namespace}/bans/users/disabled".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.patch(url, data, { params });
    return import_sdk.Validate.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      ListBulkUserBanResponseV3,
      "ListBulkUserBanResponseV3"
    );
  }
};

// src/generated-admin/BansAdminApi.ts
function BansAdminApi(sdk, args) {
  const sdkAssembly = sdk.assembly();
  const namespace = args?.coreConfig?.namespace ?? sdkAssembly.coreConfig.namespace;
  const useSchemaValidation = args?.coreConfig?.useSchemaValidation ?? sdkAssembly.coreConfig.useSchemaValidation;
  let axiosInstance = sdkAssembly.axiosInstance;
  const requestConfigOverrides = args?.axiosConfig?.request;
  const baseURLOverride = args?.coreConfig?.baseURL;
  const interceptorsOverride = args?.axiosConfig?.interceptors ?? [];
  if (requestConfigOverrides || baseURLOverride || interceptorsOverride.length > 0) {
    const requestConfig = import_sdk2.ApiUtils.mergeAxiosConfigs(sdkAssembly.axiosInstance.defaults, {
      ...baseURLOverride ? { baseURL: baseURLOverride } : {},
      ...requestConfigOverrides
    });
    axiosInstance = import_sdk2.Network.create(requestConfig);
    for (const interceptor of interceptorsOverride) {
      if (interceptor.type === "request") {
        axiosInstance.interceptors.request.use(interceptor.onRequest, interceptor.onError);
      }
      if (interceptor.type === "response") {
        axiosInstance.interceptors.response.use(interceptor.onSuccess, interceptor.onError);
      }
    }
  }
  async function getBans_v3() {
    const $ = new BansAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getBans_v3();
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getBansReasons_v3() {
    const $ = new BansAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getBansReasons_v3();
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getBantypes_v3() {
    const $ = new BansAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getBantypes_v3();
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getBansUsers_v3(queryParams) {
    const $ = new BansAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getBansUsers_v3(queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function createBanUser_v3(data) {
    const $ = new BansAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.createBanUser_v3(data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function patchBanUserDisabled_v3(data) {
    const $ = new BansAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.patchBanUserDisabled_v3(data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  return {
    /**
     * Ban type is the code available for ban assignment. It is applicable globally for any namespace. action code : 10201
     */
    getBans_v3,
    /**
     * Ban reasons is the code available to justify ban assignment. It is applicable globally for any namespace. action code : 10202
     */
    getBansReasons_v3,
    /**
     * Ban type is the code available for ban assignment. It is applicable globally for any namespace. action code : 10201
     */
    getBantypes_v3,
    /**
     * Ban type is the code available for ban assignment. It is applicable globally for any namespace. action code : 10201
     */
    getBansUsers_v3,
    /**
     * Bulk ban user with specific type of ban. Ban types and reason can be queried. The maximum limit value is 100 userIDs action code : 10141
     */
    createBanUser_v3,
    /**
     * disable bulk ban user. The maximum limit value is 100 action code : 10142
     */
    patchBanUserDisabled_v3
  };
}

// src/generated-admin/queries/BansAdmin.query.ts
var Key_BansAdmin = /* @__PURE__ */ ((Key_BansAdmin2) => {
  Key_BansAdmin2["Bans_v3"] = "Iam.BansAdmin.Bans_v3";
  Key_BansAdmin2["BansReasons_v3"] = "Iam.BansAdmin.BansReasons_v3";
  Key_BansAdmin2["Bantypes_v3"] = "Iam.BansAdmin.Bantypes_v3";
  Key_BansAdmin2["BansUsers_v3"] = "Iam.BansAdmin.BansUsers_v3";
  Key_BansAdmin2["BanUser_v3"] = "Iam.BansAdmin.BanUser_v3";
  Key_BansAdmin2["BanUserDisabled_v3"] = "Iam.BansAdmin.BanUserDisabled_v3";
  return Key_BansAdmin2;
})(Key_BansAdmin || {});
var useBansAdminApi_GetBans_v3 = (sdk, input, options, callback) => {
  const queryFn = (sdk2, input2) => async () => {
    const response = await BansAdminApi(sdk2, { coreConfig: input2.coreConfig, axiosConfig: input2.axiosConfig }).getBans_v3();
    callback && callback(response);
    return response.data;
  };
  return (0, import_react_query.useQuery)({
    queryKey: ["Iam.BansAdmin.Bans_v3" /* Bans_v3 */, input],
    queryFn: queryFn(sdk, input),
    ...options
  });
};
var useBansAdminApi_GetBansReasons_v3 = (sdk, input, options, callback) => {
  const queryFn = (sdk2, input2) => async () => {
    const response = await BansAdminApi(sdk2, { coreConfig: input2.coreConfig, axiosConfig: input2.axiosConfig }).getBansReasons_v3();
    callback && callback(response);
    return response.data;
  };
  return (0, import_react_query.useQuery)({
    queryKey: ["Iam.BansAdmin.BansReasons_v3" /* BansReasons_v3 */, input],
    queryFn: queryFn(sdk, input),
    ...options
  });
};
var useBansAdminApi_GetBantypes_v3 = (sdk, input, options, callback) => {
  const queryFn = (sdk2, input2) => async () => {
    const response = await BansAdminApi(sdk2, { coreConfig: input2.coreConfig, axiosConfig: input2.axiosConfig }).getBantypes_v3();
    callback && callback(response);
    return response.data;
  };
  return (0, import_react_query.useQuery)({
    queryKey: ["Iam.BansAdmin.Bantypes_v3" /* Bantypes_v3 */, input],
    queryFn: queryFn(sdk, input),
    ...options
  });
};
var useBansAdminApi_GetBansUsers_v3 = (sdk, input, options, callback) => {
  const queryFn = (sdk2, input2) => async () => {
    const response = await BansAdminApi(sdk2, { coreConfig: input2.coreConfig, axiosConfig: input2.axiosConfig }).getBansUsers_v3(
      input2.queryParams
    );
    callback && callback(response);
    return response.data;
  };
  return (0, import_react_query.useQuery)({
    queryKey: ["Iam.BansAdmin.BansUsers_v3" /* BansUsers_v3 */, input],
    queryFn: queryFn(sdk, input),
    ...options
  });
};
var useBansAdminApi_CreateBanUserMutation_v3 = (sdk, options, callback) => {
  const mutationFn = async (input) => {
    const response = await BansAdminApi(sdk, { coreConfig: input.coreConfig, axiosConfig: input.axiosConfig }).createBanUser_v3(input.data);
    callback && callback(response.data);
    return response.data;
  };
  return (0, import_react_query.useMutation)({
    mutationKey: ["Iam.BansAdmin.BanUser_v3" /* BanUser_v3 */],
    mutationFn,
    ...options
  });
};
var useBansAdminApi_PatchBanUserDisabledMutation_v3 = (sdk, options, callback) => {
  const mutationFn = async (input) => {
    const response = await BansAdminApi(sdk, { coreConfig: input.coreConfig, axiosConfig: input.axiosConfig }).patchBanUserDisabled_v3(
      input.data
    );
    callback && callback(response.data);
    return response.data;
  };
  return (0, import_react_query.useMutation)({
    mutationKey: ["Iam.BansAdmin.BanUserDisabled_v3" /* BanUserDisabled_v3 */],
    mutationFn,
    ...options
  });
};

// src/generated-admin/queries/ClientsAdmin.query.ts
var import_react_query2 = require("@tanstack/react-query");

// src/generated-admin/ClientsAdminApi.ts
var import_sdk4 = require("@accelbyte/sdk");

// src/generated-admin/endpoints/ClientsAdmin$.ts
var import_sdk3 = require("@accelbyte/sdk");
var import_zod17 = require("zod");

// src/generated-definitions/ClientV3Response.ts
var import_zod15 = require("zod");

// src/generated-definitions/ClientModulePermission.ts
var import_zod13 = require("zod");

// src/generated-definitions/ClientSelectedGroup.ts
var import_zod12 = require("zod");
var ClientSelectedGroup = import_zod12.z.object({ groupId: import_zod12.z.string(), selectedActions: import_zod12.z.array(import_zod12.z.number().int()) });

// src/generated-definitions/ClientModulePermission.ts
var ClientModulePermission = import_zod13.z.object({ moduleId: import_zod13.z.string(), selectedGroups: import_zod13.z.array(ClientSelectedGroup) });

// src/generated-definitions/PermissionV3.ts
var import_zod14 = require("zod");
var PermissionV3 = import_zod14.z.object({
  action: import_zod14.z.number().int(),
  resource: import_zod14.z.string(),
  schedAction: import_zod14.z.number().int().nullish(),
  schedCron: import_zod14.z.string().nullish(),
  schedRange: import_zod14.z.array(import_zod14.z.string()).nullish()
});

// src/generated-definitions/ClientV3Response.ts
var ClientV3Response = import_zod15.z.object({
  audiences: import_zod15.z.array(import_zod15.z.string()),
  baseUri: import_zod15.z.string(),
  clientId: import_zod15.z.string(),
  clientName: import_zod15.z.string(),
  clientPermissions: import_zod15.z.array(PermissionV3),
  clientPlatform: import_zod15.z.string(),
  createdAt: import_zod15.z.string(),
  description: import_zod15.z.string(),
  modifiedAt: import_zod15.z.string(),
  modulePermissions: import_zod15.z.array(ClientModulePermission).nullish(),
  namespace: import_zod15.z.string(),
  oauthAccessTokenExpiration: import_zod15.z.number().int().nullish(),
  oauthAccessTokenExpirationTimeUnit: import_zod15.z.string().nullish(),
  oauthClientType: import_zod15.z.string(),
  oauthRefreshTokenExpiration: import_zod15.z.number().int().nullish(),
  oauthRefreshTokenExpirationTimeUnit: import_zod15.z.string().nullish(),
  parentNamespace: import_zod15.z.string().nullish(),
  redirectUri: import_zod15.z.string(),
  roles: import_zod15.z.array(import_zod15.z.string()).nullish(),
  scopes: import_zod15.z.array(import_zod15.z.string()),
  skipLoginQueue: import_zod15.z.boolean(),
  twoFactorEnabled: import_zod15.z.boolean()
});

// src/generated-definitions/ClientsV3Response.ts
var import_zod16 = require("zod");
var ClientsV3Response = import_zod16.z.object({ data: import_zod16.z.array(ClientV3Response), paging: PaginationV3 });

// src/generated-admin/endpoints/ClientsAdmin$.ts
var ClientsAdmin$ = class {
  // @ts-ignore
  // prettier-ignore
  constructor(axiosInstance, namespace, useSchemaValidation = true) {
    this.axiosInstance = axiosInstance;
    this.namespace = namespace;
    this.useSchemaValidation = useSchemaValidation;
  }
  /**
   * action code: 10308
   */
  getClients_v3(queryParams) {
    const params = { ...queryParams };
    const url = "/iam/v3/admin/namespaces/{namespace}/clients".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.get(url, { params });
    return import_sdk3.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, ClientsV3Response, "ClientsV3Response");
  }
  /**
   * Add a new OAuth 2.0 client A new client automatically granted with these scopes: commerce, account, analytics, publishing, social. **Note for Multi Tenant Mode (Confidential Client):** Only Super admin can set permission with resource &amp; action. Studio admin &amp; game admin need set permission with permission module. action code: 10301 **Fields Description:** - **clientId** : The client ID. e.g f815e5c44f364993961be3b3f26a7bf4 - **clientName** : The client name. e.g E-commerce - **secret** : The client&#39;s secret. It&#39;s empty if the client&#39;s type is a public client. Otherwise, the client secret is required - **namespace** : The namespace where the client lives. e.g sample-game - **redirectUri** : Contains the redirect URI used in OAuth callback. e.g https://example.net/platform - **oauthClientType** : The OAuth 2.0 client type. The client type determines whether the authorization needs Proof Of Key Exchange or not. A public client type doesn&#39;t have a client secret and should use PKCE flow. A confidential client type has a client secret and don&#39;t use PKCE flow Supported oAuthClientType : - **Public** - **Confidential** - **audiences** : List of target client IDs who is intended to receive the token. e.g [&#34;eaaa65618fe24293b00a61454182b435&#34;, &#34;40073ee9bc3446d3a051a71b48509a5d&#34;] - **baseUri** : A base URI of the application. It is used for making sure the token is intended to be used by the client. e.g https://example.net/platform - **clientPermissions** : Contains the client&#39;s permissions - **deletable** : The flag to identify whether client is deletable (optional). default value: true - **clientPlatform**: available client platform (optional). default value: &#34;&#34; - Playstation - Xbox - Steam - Epic - IOS - GooglePlay - Nintendo - Oculus - **twoFactorEnabled**: The flag to indicate whether 2FA validation is enable for this client. default value: false - **oauthAccessTokenExpiration**: a configurable expiration time for **access_token**, default value: 0 (mean fetch value from environment variable) - **oauthRefreshTokenExpiration**: a configurable expiration time for **refresh_token**, default value: 0 (mean fetch value from environment variable) - **oauthAccessTokenExpirationTimeUnit**: a configurable expiration time unit for **access_token**, default value: SECONDS - **oauthRefreshTokenExpirationTimeUnit**: a configurable expiration time unit for **refresh_token**, default value: SECONDS
   */
  createClient_v3(data) {
    const params = {};
    const url = "/iam/v3/admin/namespaces/{namespace}/clients".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.post(url, data, { params });
    return import_sdk3.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, ClientV3Response, "ClientV3Response");
  }
  /**
   * Updates multiple OAuth 2.0 clients. Specify only the fields you want to update in the request payload, e.g. {&#34;ClientName&#34;:&#34;E-commerce&#34;, &#34;BaseUri&#34;:&#34;https://example.net&#34;} **Note for Multi Tenant Mode (Confidential Client):** Only Super admin can set permission with resource &amp; action. Studio admin &amp; game admin need set permission with permission module. action code: 10302 **Fields Description:** - **clientName** : The client name. It should not be empty if the field exists in the body. e.g E-commerce - **namespace** : The namespace where the client lives. e.g sample-game - **redirectUri** : Contains the redirect URI used in OAuth callback. It should not be empty if the field exists in the body. e.g https://example.net/platform - **audiences** : List of target client IDs who is intended to receive the token. e.g [&#34;eaaa65618fe24293b00a61454182b435&#34;, &#34;40073ee9bc3446d3a051a71b48509a5d&#34;] - **baseUri** : A base URI of the application. It is used in the audience checking for making sure the token is used by the right resource server. Required if the application type is a server. e.g https://example.net/platform - **clientPermissions** : Contains the client&#39;s permissions - **deletable** : The flag to identify whether client is deletable (optional). e.g. true - **clientPlatform** : available client platform (optional). default value: &#34;&#34;. - Playstation - Xbox - Steam - Epic - IOS - GooglePlay - Nintendo - Oculus - **twoFactorEnabled**: The flag to indicate whether 2FA validation is enable for this client. default value: false - **oauthAccessTokenExpiration**: a configurable expiration time for **access_token**, default value: 0 (mean fetch value from environment variable) - **oauthRefreshTokenExpiration**: a configurable expiration time for **refresh_token**, default value: 0 (mean fetch value from environment variable) - **oauthAccessTokenExpirationTimeUnit**: a configurable expiration time unit for **access_token**, will use previous value if not specified - **oauthRefreshTokenExpirationTimeUnit**: a configurable expiration time unit for **refresh_token**, will use previous value if not specified - **skipLoginQueue**: a flag to indicate whether this client should be exempted from login queue or not
   */
  updateClient_v3(data) {
    const params = {};
    const url = "/iam/v3/admin/namespaces/{namespace}/clients".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.put(url, data, { params });
    return import_sdk3.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, import_zod17.z.unknown(), "z.unknown()");
  }
  /**
   * Update Client Secret
   */
  updateSecret_ByClientId_v3(clientId, data) {
    const params = {};
    const url = "/iam/v3/admin/namespaces/{namespace}/{clientId}/secret".replace("{namespace}", this.namespace).replace("{clientId}", clientId);
    const resultPromise = this.axiosInstance.put(url, data, { params });
    return import_sdk3.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, import_zod17.z.unknown(), "z.unknown()");
  }
  /**
   * action code : 10310
   */
  deleteClient_ByClientId_v3(clientId) {
    const params = {};
    const url = "/iam/v3/admin/namespaces/{namespace}/clients/{clientId}".replace("{namespace}", this.namespace).replace("{clientId}", clientId);
    const resultPromise = this.axiosInstance.delete(url, { params });
    return import_sdk3.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, import_zod17.z.unknown(), "z.unknown()");
  }
  /**
   * action code: 10309
   */
  getClient_ByClientId_v3(clientId) {
    const params = {};
    const url = "/iam/v3/admin/namespaces/{namespace}/clients/{clientId}".replace("{namespace}", this.namespace).replace("{clientId}", clientId);
    const resultPromise = this.axiosInstance.get(url, { params });
    return import_sdk3.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, ClientV3Response, "ClientV3Response");
  }
  /**
   * Updates an OAuth 2.0 client. Specify only the fields you want to update in the request payload, e.g. {&#34;ClientName&#34;:&#34;E-commerce&#34;, &#34;BaseUri&#34;:&#34;https://example.net&#34;} **Note for Multi Tenant Mode (Confidential Client):** Only Super admin can set permission with resource &amp; action. Studio admin &amp; game admin need set permission with permission module. action code: 10302 **Fields Description:** - **clientName** : The client name. It should not be empty if the field exists in the body. e.g E-commerce - **namespace** : The namespace where the client lives. e.g sample-game - **redirectUri** : Contains the redirect URI used in OAuth callback. It should not be empty if the field exists in the body. e.g https://example.net/platform - **audiences** : List of target client IDs who is intended to receive the token. e.g [&#34;eaaa65618fe24293b00a61454182b435&#34;, &#34;40073ee9bc3446d3a051a71b48509a5d&#34;] - **baseUri** : A base URI of the application. It is used in the audience checking for making sure the token is used by the right resource server. Required if the application type is a server. e.g https://example.net/platform - **clientPermissions** : Contains the client&#39;s permissions - **deletable** : The flag to identify whether client is deletable (optional). e.g. true - **clientPlatform** : available client platform (optional). default value: &#34;&#34;. - Playstation - Xbox - Steam - Epic - IOS - GooglePlay - Nintendo - Oculus - **twoFactorEnabled**: The flag to indicate whether 2FA validation is enable for this client. default value: false - **oauthAccessTokenExpiration**: a configurable expiration time for **access_token**, default value: 0 (mean fetch value from environment variable) - **oauthRefreshTokenExpiration**: a configurable expiration time for **refresh_token**, default value: 0 (mean fetch value from environment variable) - **oauthAccessTokenExpirationTimeUnit**: a configurable expiration time unit for **access_token**, will use previous value if not specified - **oauthRefreshTokenExpirationTimeUnit**: a configurable expiration time unit for **refresh_token**, will use previous value if not specified - **skipLoginQueue**: a flag to indicate whether this client should be exempted from login queue or not
   */
  patchClient_ByClientId_v3(clientId, data) {
    const params = {};
    const url = "/iam/v3/admin/namespaces/{namespace}/clients/{clientId}".replace("{namespace}", this.namespace).replace("{clientId}", clientId);
    const resultPromise = this.axiosInstance.patch(url, data, { params });
    return import_sdk3.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, ClientV3Response, "ClientV3Response");
  }
  /**
   * **Note for Multi Tenant Mode:** This is for super admin only. action code: 10303
   */
  updatePermission_ByClientId_v3(clientId, data) {
    const params = {};
    const url = "/iam/v3/admin/namespaces/{namespace}/clients/{clientId}/permissions".replace("{namespace}", this.namespace).replace("{clientId}", clientId);
    const resultPromise = this.axiosInstance.post(url, data, { params });
    return import_sdk3.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, import_zod17.z.unknown(), "z.unknown()");
  }
  /**
   * **Note for Multi Tenant Mode:** This is for super admin only. action code: 10307
   */
  updatePermission_ByClientId_ByNS_v3(clientId, data) {
    const params = {};
    const url = "/iam/v3/admin/namespaces/{namespace}/clients/{clientId}/permissions".replace("{namespace}", this.namespace).replace("{clientId}", clientId);
    const resultPromise = this.axiosInstance.put(url, data, { params });
    return import_sdk3.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, import_zod17.z.unknown(), "z.unknown()");
  }
  /**
   * **Note for Multi Tenant Mode:** This is for super admin only. action code : 10304
   */
  deletePermission_ByClientId_ByResource_ByAction_v3(clientId, resource, action) {
    const params = {};
    const url = "/iam/v3/admin/namespaces/{namespace}/clients/{clientId}/permissions/{resource}/{action}".replace("{namespace}", this.namespace).replace("{clientId}", clientId).replace("{resource}", resource).replace("{action}", String(action));
    const resultPromise = this.axiosInstance.delete(url, { params });
    return import_sdk3.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, import_zod17.z.unknown(), "z.unknown()");
  }
};

// src/generated-admin/ClientsAdminApi.ts
function ClientsAdminApi(sdk, args) {
  const sdkAssembly = sdk.assembly();
  const namespace = args?.coreConfig?.namespace ?? sdkAssembly.coreConfig.namespace;
  const useSchemaValidation = args?.coreConfig?.useSchemaValidation ?? sdkAssembly.coreConfig.useSchemaValidation;
  let axiosInstance = sdkAssembly.axiosInstance;
  const requestConfigOverrides = args?.axiosConfig?.request;
  const baseURLOverride = args?.coreConfig?.baseURL;
  const interceptorsOverride = args?.axiosConfig?.interceptors ?? [];
  if (requestConfigOverrides || baseURLOverride || interceptorsOverride.length > 0) {
    const requestConfig = import_sdk4.ApiUtils.mergeAxiosConfigs(sdkAssembly.axiosInstance.defaults, {
      ...baseURLOverride ? { baseURL: baseURLOverride } : {},
      ...requestConfigOverrides
    });
    axiosInstance = import_sdk4.Network.create(requestConfig);
    for (const interceptor of interceptorsOverride) {
      if (interceptor.type === "request") {
        axiosInstance.interceptors.request.use(interceptor.onRequest, interceptor.onError);
      }
      if (interceptor.type === "response") {
        axiosInstance.interceptors.response.use(interceptor.onSuccess, interceptor.onError);
      }
    }
  }
  async function getClients_v3(queryParams) {
    const $ = new ClientsAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getClients_v3(queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function createClient_v3(data) {
    const $ = new ClientsAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.createClient_v3(data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function updateClient_v3(data) {
    const $ = new ClientsAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.updateClient_v3(data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function updateSecret_ByClientId_v3(clientId, data) {
    const $ = new ClientsAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.updateSecret_ByClientId_v3(clientId, data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function deleteClient_ByClientId_v3(clientId) {
    const $ = new ClientsAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.deleteClient_ByClientId_v3(clientId);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getClient_ByClientId_v3(clientId) {
    const $ = new ClientsAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getClient_ByClientId_v3(clientId);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function patchClient_ByClientId_v3(clientId, data) {
    const $ = new ClientsAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.patchClient_ByClientId_v3(clientId, data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function updatePermission_ByClientId_v3(clientId, data) {
    const $ = new ClientsAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.updatePermission_ByClientId_v3(clientId, data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function updatePermission_ByClientId_ByNS_v3(clientId, data) {
    const $ = new ClientsAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.updatePermission_ByClientId_ByNS_v3(clientId, data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function deletePermission_ByClientId_ByResource_ByAction_v3(clientId, resource, action) {
    const $ = new ClientsAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.deletePermission_ByClientId_ByResource_ByAction_v3(clientId, resource, action);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  return {
    /**
     * action code: 10308
     */
    getClients_v3,
    /**
     * Add a new OAuth 2.0 client A new client automatically granted with these scopes: commerce, account, analytics, publishing, social. **Note for Multi Tenant Mode (Confidential Client):** Only Super admin can set permission with resource &amp; action. Studio admin &amp; game admin need set permission with permission module. action code: 10301 **Fields Description:** - **clientId** : The client ID. e.g f815e5c44f364993961be3b3f26a7bf4 - **clientName** : The client name. e.g E-commerce - **secret** : The client&#39;s secret. It&#39;s empty if the client&#39;s type is a public client. Otherwise, the client secret is required - **namespace** : The namespace where the client lives. e.g sample-game - **redirectUri** : Contains the redirect URI used in OAuth callback. e.g https://example.net/platform - **oauthClientType** : The OAuth 2.0 client type. The client type determines whether the authorization needs Proof Of Key Exchange or not. A public client type doesn&#39;t have a client secret and should use PKCE flow. A confidential client type has a client secret and don&#39;t use PKCE flow Supported oAuthClientType : - **Public** - **Confidential** - **audiences** : List of target client IDs who is intended to receive the token. e.g [&#34;eaaa65618fe24293b00a61454182b435&#34;, &#34;40073ee9bc3446d3a051a71b48509a5d&#34;] - **baseUri** : A base URI of the application. It is used for making sure the token is intended to be used by the client. e.g https://example.net/platform - **clientPermissions** : Contains the client&#39;s permissions - **deletable** : The flag to identify whether client is deletable (optional). default value: true - **clientPlatform**: available client platform (optional). default value: &#34;&#34; - Playstation - Xbox - Steam - Epic - IOS - GooglePlay - Nintendo - Oculus - **twoFactorEnabled**: The flag to indicate whether 2FA validation is enable for this client. default value: false - **oauthAccessTokenExpiration**: a configurable expiration time for **access_token**, default value: 0 (mean fetch value from environment variable) - **oauthRefreshTokenExpiration**: a configurable expiration time for **refresh_token**, default value: 0 (mean fetch value from environment variable) - **oauthAccessTokenExpirationTimeUnit**: a configurable expiration time unit for **access_token**, default value: SECONDS - **oauthRefreshTokenExpirationTimeUnit**: a configurable expiration time unit for **refresh_token**, default value: SECONDS
     */
    createClient_v3,
    /**
     * Updates multiple OAuth 2.0 clients. Specify only the fields you want to update in the request payload, e.g. {&#34;ClientName&#34;:&#34;E-commerce&#34;, &#34;BaseUri&#34;:&#34;https://example.net&#34;} **Note for Multi Tenant Mode (Confidential Client):** Only Super admin can set permission with resource &amp; action. Studio admin &amp; game admin need set permission with permission module. action code: 10302 **Fields Description:** - **clientName** : The client name. It should not be empty if the field exists in the body. e.g E-commerce - **namespace** : The namespace where the client lives. e.g sample-game - **redirectUri** : Contains the redirect URI used in OAuth callback. It should not be empty if the field exists in the body. e.g https://example.net/platform - **audiences** : List of target client IDs who is intended to receive the token. e.g [&#34;eaaa65618fe24293b00a61454182b435&#34;, &#34;40073ee9bc3446d3a051a71b48509a5d&#34;] - **baseUri** : A base URI of the application. It is used in the audience checking for making sure the token is used by the right resource server. Required if the application type is a server. e.g https://example.net/platform - **clientPermissions** : Contains the client&#39;s permissions - **deletable** : The flag to identify whether client is deletable (optional). e.g. true - **clientPlatform** : available client platform (optional). default value: &#34;&#34;. - Playstation - Xbox - Steam - Epic - IOS - GooglePlay - Nintendo - Oculus - **twoFactorEnabled**: The flag to indicate whether 2FA validation is enable for this client. default value: false - **oauthAccessTokenExpiration**: a configurable expiration time for **access_token**, default value: 0 (mean fetch value from environment variable) - **oauthRefreshTokenExpiration**: a configurable expiration time for **refresh_token**, default value: 0 (mean fetch value from environment variable) - **oauthAccessTokenExpirationTimeUnit**: a configurable expiration time unit for **access_token**, will use previous value if not specified - **oauthRefreshTokenExpirationTimeUnit**: a configurable expiration time unit for **refresh_token**, will use previous value if not specified - **skipLoginQueue**: a flag to indicate whether this client should be exempted from login queue or not
     */
    updateClient_v3,
    /**
     * Update Client Secret
     */
    updateSecret_ByClientId_v3,
    /**
     * action code : 10310
     */
    deleteClient_ByClientId_v3,
    /**
     * action code: 10309
     */
    getClient_ByClientId_v3,
    /**
     * Updates an OAuth 2.0 client. Specify only the fields you want to update in the request payload, e.g. {&#34;ClientName&#34;:&#34;E-commerce&#34;, &#34;BaseUri&#34;:&#34;https://example.net&#34;} **Note for Multi Tenant Mode (Confidential Client):** Only Super admin can set permission with resource &amp; action. Studio admin &amp; game admin need set permission with permission module. action code: 10302 **Fields Description:** - **clientName** : The client name. It should not be empty if the field exists in the body. e.g E-commerce - **namespace** : The namespace where the client lives. e.g sample-game - **redirectUri** : Contains the redirect URI used in OAuth callback. It should not be empty if the field exists in the body. e.g https://example.net/platform - **audiences** : List of target client IDs who is intended to receive the token. e.g [&#34;eaaa65618fe24293b00a61454182b435&#34;, &#34;40073ee9bc3446d3a051a71b48509a5d&#34;] - **baseUri** : A base URI of the application. It is used in the audience checking for making sure the token is used by the right resource server. Required if the application type is a server. e.g https://example.net/platform - **clientPermissions** : Contains the client&#39;s permissions - **deletable** : The flag to identify whether client is deletable (optional). e.g. true - **clientPlatform** : available client platform (optional). default value: &#34;&#34;. - Playstation - Xbox - Steam - Epic - IOS - GooglePlay - Nintendo - Oculus - **twoFactorEnabled**: The flag to indicate whether 2FA validation is enable for this client. default value: false - **oauthAccessTokenExpiration**: a configurable expiration time for **access_token**, default value: 0 (mean fetch value from environment variable) - **oauthRefreshTokenExpiration**: a configurable expiration time for **refresh_token**, default value: 0 (mean fetch value from environment variable) - **oauthAccessTokenExpirationTimeUnit**: a configurable expiration time unit for **access_token**, will use previous value if not specified - **oauthRefreshTokenExpirationTimeUnit**: a configurable expiration time unit for **refresh_token**, will use previous value if not specified - **skipLoginQueue**: a flag to indicate whether this client should be exempted from login queue or not
     */
    patchClient_ByClientId_v3,
    /**
     * **Note for Multi Tenant Mode:** This is for super admin only. action code: 10303
     */
    updatePermission_ByClientId_v3,
    /**
     * **Note for Multi Tenant Mode:** This is for super admin only. action code: 10307
     */
    updatePermission_ByClientId_ByNS_v3,
    /**
     * **Note for Multi Tenant Mode:** This is for super admin only. action code : 10304
     */
    deletePermission_ByClientId_ByResource_ByAction_v3
  };
}

// src/generated-admin/queries/ClientsAdmin.query.ts
var Key_ClientsAdmin = /* @__PURE__ */ ((Key_ClientsAdmin2) => {
  Key_ClientsAdmin2["Clients_v3"] = "Iam.ClientsAdmin.Clients_v3";
  Key_ClientsAdmin2["Client_v3"] = "Iam.ClientsAdmin.Client_v3";
  Key_ClientsAdmin2["Secret_ByClientId_v3"] = "Iam.ClientsAdmin.Secret_ByClientId_v3";
  Key_ClientsAdmin2["Client_ByClientId_v3"] = "Iam.ClientsAdmin.Client_ByClientId_v3";
  Key_ClientsAdmin2["Permission_ByClientId_v3"] = "Iam.ClientsAdmin.Permission_ByClientId_v3";
  Key_ClientsAdmin2["Permission_ByClientId_ByNS_v3"] = "Iam.ClientsAdmin.Permission_ByClientId_ByNS_v3";
  Key_ClientsAdmin2["Permission_ByClientId_ByResource_ByAction_v3"] = "Iam.ClientsAdmin.Permission_ByClientId_ByResource_ByAction_v3";
  return Key_ClientsAdmin2;
})(Key_ClientsAdmin || {});
var useClientsAdminApi_GetClients_v3 = (sdk, input, options, callback) => {
  const queryFn = (sdk2, input2) => async () => {
    const response = await ClientsAdminApi(sdk2, { coreConfig: input2.coreConfig, axiosConfig: input2.axiosConfig }).getClients_v3(
      input2.queryParams
    );
    callback && callback(response);
    return response.data;
  };
  return (0, import_react_query2.useQuery)({
    queryKey: ["Iam.ClientsAdmin.Clients_v3" /* Clients_v3 */, input],
    queryFn: queryFn(sdk, input),
    ...options
  });
};
var useClientsAdminApi_CreateClientMutation_v3 = (sdk, options, callback) => {
  const mutationFn = async (input) => {
    const response = await ClientsAdminApi(sdk, { coreConfig: input.coreConfig, axiosConfig: input.axiosConfig }).createClient_v3(
      input.data
    );
    callback && callback(response.data);
    return response.data;
  };
  return (0, import_react_query2.useMutation)({
    mutationKey: ["Iam.ClientsAdmin.Client_v3" /* Client_v3 */],
    mutationFn,
    ...options
  });
};
var useClientsAdminApi_UpdateClientMutation_v3 = (sdk, options, callback) => {
  const mutationFn = async (input) => {
    const response = await ClientsAdminApi(sdk, { coreConfig: input.coreConfig, axiosConfig: input.axiosConfig }).updateClient_v3(
      input.data
    );
    callback && callback(response.data);
    return response.data;
  };
  return (0, import_react_query2.useMutation)({
    mutationKey: ["Iam.ClientsAdmin.Client_v3" /* Client_v3 */],
    mutationFn,
    ...options
  });
};
var useClientsAdminApi_UpdateSecret_ByClientIdMutation_v3 = (sdk, options, callback) => {
  const mutationFn = async (input) => {
    const response = await ClientsAdminApi(sdk, {
      coreConfig: input.coreConfig,
      axiosConfig: input.axiosConfig
    }).updateSecret_ByClientId_v3(input.clientId, input.data);
    callback && callback(response.data);
    return response.data;
  };
  return (0, import_react_query2.useMutation)({
    mutationKey: ["Iam.ClientsAdmin.Secret_ByClientId_v3" /* Secret_ByClientId_v3 */],
    mutationFn,
    ...options
  });
};
var useClientsAdminApi_DeleteClient_ByClientIdMutation_v3 = (sdk, options, callback) => {
  const mutationFn = async (input) => {
    const response = await ClientsAdminApi(sdk, {
      coreConfig: input.coreConfig,
      axiosConfig: input.axiosConfig
    }).deleteClient_ByClientId_v3(input.clientId);
    callback && callback(response.data);
    return response.data;
  };
  return (0, import_react_query2.useMutation)({
    mutationKey: ["Iam.ClientsAdmin.Client_ByClientId_v3" /* Client_ByClientId_v3 */],
    mutationFn,
    ...options
  });
};
var useClientsAdminApi_GetClient_ByClientId_v3 = (sdk, input, options, callback) => {
  const queryFn = (sdk2, input2) => async () => {
    const response = await ClientsAdminApi(sdk2, { coreConfig: input2.coreConfig, axiosConfig: input2.axiosConfig }).getClient_ByClientId_v3(
      input2.clientId
    );
    callback && callback(response);
    return response.data;
  };
  return (0, import_react_query2.useQuery)({
    queryKey: ["Iam.ClientsAdmin.Client_ByClientId_v3" /* Client_ByClientId_v3 */, input],
    queryFn: queryFn(sdk, input),
    ...options
  });
};
var useClientsAdminApi_PatchClient_ByClientIdMutation_v3 = (sdk, options, callback) => {
  const mutationFn = async (input) => {
    const response = await ClientsAdminApi(sdk, { coreConfig: input.coreConfig, axiosConfig: input.axiosConfig }).patchClient_ByClientId_v3(
      input.clientId,
      input.data
    );
    callback && callback(response.data);
    return response.data;
  };
  return (0, import_react_query2.useMutation)({
    mutationKey: ["Iam.ClientsAdmin.Client_ByClientId_v3" /* Client_ByClientId_v3 */],
    mutationFn,
    ...options
  });
};
var useClientsAdminApi_UpdatePermission_ByClientIdMutation_v3 = (sdk, options, callback) => {
  const mutationFn = async (input) => {
    const response = await ClientsAdminApi(sdk, {
      coreConfig: input.coreConfig,
      axiosConfig: input.axiosConfig
    }).updatePermission_ByClientId_v3(input.clientId, input.data);
    callback && callback(response.data);
    return response.data;
  };
  return (0, import_react_query2.useMutation)({
    mutationKey: ["Iam.ClientsAdmin.Permission_ByClientId_v3" /* Permission_ByClientId_v3 */],
    mutationFn,
    ...options
  });
};
var useClientsAdminApi_UpdatePermission_ByClientId_ByNSMutation_v3 = (sdk, options, callback) => {
  const mutationFn = async (input) => {
    const response = await ClientsAdminApi(sdk, {
      coreConfig: input.coreConfig,
      axiosConfig: input.axiosConfig
    }).updatePermission_ByClientId_ByNS_v3(input.clientId, input.data);
    callback && callback(response.data);
    return response.data;
  };
  return (0, import_react_query2.useMutation)({
    mutationKey: ["Iam.ClientsAdmin.Permission_ByClientId_ByNS_v3" /* Permission_ByClientId_ByNS_v3 */],
    mutationFn,
    ...options
  });
};
var useClientsAdminApi_DeletePermission_ByClientId_ByResource_ByActionMutation_v3 = (sdk, options, callback) => {
  const mutationFn = async (input) => {
    const response = await ClientsAdminApi(sdk, {
      coreConfig: input.coreConfig,
      axiosConfig: input.axiosConfig
    }).deletePermission_ByClientId_ByResource_ByAction_v3(input.clientId, input.resource, input.action);
    callback && callback(response.data);
    return response.data;
  };
  return (0, import_react_query2.useMutation)({
    mutationKey: ["Iam.ClientsAdmin.Permission_ByClientId_ByResource_ByAction_v3" /* Permission_ByClientId_ByResource_ByAction_v3 */],
    mutationFn,
    ...options
  });
};

// src/generated-admin/queries/ClientsConfigV3Admin.query.ts
var import_react_query3 = require("@tanstack/react-query");

// src/generated-admin/ClientsConfigV3AdminApi.ts
var import_sdk6 = require("@accelbyte/sdk");

// src/generated-admin/endpoints/ClientsConfigV3Admin$.ts
var import_sdk5 = require("@accelbyte/sdk");
var import_zod26 = require("zod");

// src/generated-definitions/ListClientPermissionSet.ts
var import_zod21 = require("zod");

// src/generated-definitions/ClientPermissionSet.ts
var import_zod20 = require("zod");

// src/generated-definitions/PermissionGroup.ts
var import_zod19 = require("zod");

// src/generated-definitions/AllowedPermission.ts
var import_zod18 = require("zod");
var AllowedPermission = import_zod18.z.object({ allowedActions: import_zod18.z.array(import_zod18.z.number().int()), resource: import_zod18.z.string() });

// src/generated-definitions/PermissionGroup.ts
var PermissionGroup = import_zod19.z.object({ group: import_zod19.z.string(), groupId: import_zod19.z.string(), permissions: import_zod19.z.array(AllowedPermission) });

// src/generated-definitions/ClientPermissionSet.ts
var ClientPermissionSet = import_zod20.z.object({
  docLink: import_zod20.z.string(),
  groups: import_zod20.z.array(PermissionGroup),
  module: import_zod20.z.string(),
  moduleId: import_zod20.z.string()
});

// src/generated-definitions/ListClientPermissionSet.ts
var ListClientPermissionSet = import_zod21.z.object({ clientPermissions: import_zod21.z.array(ClientPermissionSet) });

// src/generated-definitions/ListTemplatesResponse.ts
var import_zod25 = require("zod");

// src/generated-definitions/ClientTemplate.ts
var import_zod24 = require("zod");

// src/generated-definitions/DefaultFieldValue.ts
var import_zod23 = require("zod");

// src/generated-definitions/DefaultFieldValueValue.ts
var import_zod22 = require("zod");
var DefaultFieldValueValue = import_zod22.z.any();

// src/generated-definitions/DefaultFieldValue.ts
var DefaultFieldValue = import_zod23.z.object({ field: import_zod23.z.string(), value: DefaultFieldValueValue });

// src/generated-definitions/ClientTemplate.ts
var ClientTemplate = import_zod24.z.object({
  basicRequiredPermissions: import_zod24.z.array(ClientModulePermission),
  defaultValues: import_zod24.z.array(DefaultFieldValue),
  description: import_zod24.z.string(),
  id: import_zod24.z.string(),
  requiredFields: import_zod24.z.array(import_zod24.z.string()),
  type: import_zod24.z.string()
});

// src/generated-definitions/ListTemplatesResponse.ts
var ListTemplatesResponse = import_zod25.z.object({ clientTemplates: import_zod25.z.array(ClientTemplate) });

// src/generated-admin/endpoints/ClientsConfigV3Admin$.ts
var ClientsConfigV3Admin$ = class {
  // @ts-ignore
  // prettier-ignore
  constructor(axiosInstance, namespace, useSchemaValidation = true) {
    this.axiosInstance = axiosInstance;
    this.namespace = namespace;
    this.useSchemaValidation = useSchemaValidation;
  }
  /**
   * List client templates
   */
  getClientConfigTemplates_v3() {
    const params = {};
    const url = "/iam/v3/admin/clientConfig/templates";
    const resultPromise = this.axiosInstance.get(url, { params });
    return import_sdk5.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, ListTemplatesResponse, "ListTemplatesResponse");
  }
  /**
   * Delete Client config permissions by module and group.
   */
  deleteClientConfigPermission_v3(data, queryParams) {
    const params = { ...queryParams };
    const url = "/iam/v3/admin/clientConfig/permissions";
    const resultPromise = this.axiosInstance.delete(url, { data, params });
    return import_sdk5.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, import_zod26.z.unknown(), "z.unknown()");
  }
  /**
   * List Client available permissions
   */
  getClientConfigPermissions_v3(queryParams) {
    const params = { ...queryParams };
    const url = "/iam/v3/admin/clientConfig/permissions";
    const resultPromise = this.axiosInstance.get(url, { params });
    return import_sdk5.Validate.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      ListClientPermissionSet,
      "ListClientPermissionSet"
    );
  }
  /**
   * Update Client available permissions, if module or group not exists, it will auto create.
   */
  updateClientConfigPermission_v3(data, queryParams) {
    const params = { ...queryParams };
    const url = "/iam/v3/admin/clientConfig/permissions";
    const resultPromise = this.axiosInstance.put(url, data, { params });
    return import_sdk5.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, import_zod26.z.unknown(), "z.unknown()");
  }
};

// src/generated-admin/ClientsConfigV3AdminApi.ts
function ClientsConfigV3AdminApi(sdk, args) {
  const sdkAssembly = sdk.assembly();
  const namespace = args?.coreConfig?.namespace ?? sdkAssembly.coreConfig.namespace;
  const useSchemaValidation = args?.coreConfig?.useSchemaValidation ?? sdkAssembly.coreConfig.useSchemaValidation;
  let axiosInstance = sdkAssembly.axiosInstance;
  const requestConfigOverrides = args?.axiosConfig?.request;
  const baseURLOverride = args?.coreConfig?.baseURL;
  const interceptorsOverride = args?.axiosConfig?.interceptors ?? [];
  if (requestConfigOverrides || baseURLOverride || interceptorsOverride.length > 0) {
    const requestConfig = import_sdk6.ApiUtils.mergeAxiosConfigs(sdkAssembly.axiosInstance.defaults, {
      ...baseURLOverride ? { baseURL: baseURLOverride } : {},
      ...requestConfigOverrides
    });
    axiosInstance = import_sdk6.Network.create(requestConfig);
    for (const interceptor of interceptorsOverride) {
      if (interceptor.type === "request") {
        axiosInstance.interceptors.request.use(interceptor.onRequest, interceptor.onError);
      }
      if (interceptor.type === "response") {
        axiosInstance.interceptors.response.use(interceptor.onSuccess, interceptor.onError);
      }
    }
  }
  async function getClientConfigTemplates_v3() {
    const $ = new ClientsConfigV3Admin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getClientConfigTemplates_v3();
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function deleteClientConfigPermission_v3(data, queryParams) {
    const $ = new ClientsConfigV3Admin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.deleteClientConfigPermission_v3(data, queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getClientConfigPermissions_v3(queryParams) {
    const $ = new ClientsConfigV3Admin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getClientConfigPermissions_v3(queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function updateClientConfigPermission_v3(data, queryParams) {
    const $ = new ClientsConfigV3Admin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.updateClientConfigPermission_v3(data, queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  return {
    /**
     * List client templates
     */
    getClientConfigTemplates_v3,
    /**
     * Delete Client config permissions by module and group.
     */
    deleteClientConfigPermission_v3,
    /**
     * List Client available permissions
     */
    getClientConfigPermissions_v3,
    /**
     * Update Client available permissions, if module or group not exists, it will auto create.
     */
    updateClientConfigPermission_v3
  };
}

// src/generated-admin/queries/ClientsConfigV3Admin.query.ts
var Key_ClientsConfigV3Admin = /* @__PURE__ */ ((Key_ClientsConfigV3Admin2) => {
  Key_ClientsConfigV3Admin2["ClientConfigTemplates_v3"] = "Iam.ClientsConfigV3Admin.ClientConfigTemplates_v3";
  Key_ClientsConfigV3Admin2["ClientConfigPermission_v3"] = "Iam.ClientsConfigV3Admin.ClientConfigPermission_v3";
  Key_ClientsConfigV3Admin2["ClientConfigPermissions_v3"] = "Iam.ClientsConfigV3Admin.ClientConfigPermissions_v3";
  return Key_ClientsConfigV3Admin2;
})(Key_ClientsConfigV3Admin || {});
var useClientsConfigV3AdminApi_GetClientConfigTemplates_v3 = (sdk, input, options, callback) => {
  const queryFn = (sdk2, input2) => async () => {
    const response = await ClientsConfigV3AdminApi(sdk2, {
      coreConfig: input2.coreConfig,
      axiosConfig: input2.axiosConfig
    }).getClientConfigTemplates_v3();
    callback && callback(response);
    return response.data;
  };
  return (0, import_react_query3.useQuery)({
    queryKey: ["Iam.ClientsConfigV3Admin.ClientConfigTemplates_v3" /* ClientConfigTemplates_v3 */, input],
    queryFn: queryFn(sdk, input),
    ...options
  });
};
var useClientsConfigV3AdminApi_DeleteClientConfigPermissionMutation_v3 = (sdk, options, callback) => {
  const mutationFn = async (input) => {
    const response = await ClientsConfigV3AdminApi(sdk, {
      coreConfig: input.coreConfig,
      axiosConfig: input.axiosConfig
    }).deleteClientConfigPermission_v3(input.data, input.queryParams);
    callback && callback(response.data);
    return response.data;
  };
  return (0, import_react_query3.useMutation)({
    mutationKey: ["Iam.ClientsConfigV3Admin.ClientConfigPermission_v3" /* ClientConfigPermission_v3 */],
    mutationFn,
    ...options
  });
};
var useClientsConfigV3AdminApi_GetClientConfigPermissions_v3 = (sdk, input, options, callback) => {
  const queryFn = (sdk2, input2) => async () => {
    const response = await ClientsConfigV3AdminApi(sdk2, {
      coreConfig: input2.coreConfig,
      axiosConfig: input2.axiosConfig
    }).getClientConfigPermissions_v3(input2.queryParams);
    callback && callback(response);
    return response.data;
  };
  return (0, import_react_query3.useQuery)({
    queryKey: ["Iam.ClientsConfigV3Admin.ClientConfigPermissions_v3" /* ClientConfigPermissions_v3 */, input],
    queryFn: queryFn(sdk, input),
    ...options
  });
};
var useClientsConfigV3AdminApi_UpdateClientConfigPermissionMutation_v3 = (sdk, options, callback) => {
  const mutationFn = async (input) => {
    const response = await ClientsConfigV3AdminApi(sdk, {
      coreConfig: input.coreConfig,
      axiosConfig: input.axiosConfig
    }).updateClientConfigPermission_v3(input.data, input.queryParams);
    callback && callback(response.data);
    return response.data;
  };
  return (0, import_react_query3.useMutation)({
    mutationKey: ["Iam.ClientsConfigV3Admin.ClientConfigPermission_v3" /* ClientConfigPermission_v3 */],
    mutationFn,
    ...options
  });
};

// src/generated-admin/queries/ConfigAdmin.query.ts
var import_react_query4 = require("@tanstack/react-query");

// src/generated-admin/ConfigAdminApi.ts
var import_sdk8 = require("@accelbyte/sdk");

// src/generated-admin/endpoints/ConfigAdmin$.ts
var import_sdk7 = require("@accelbyte/sdk");

// src/generated-definitions/ConfigValueResponseV3.ts
var import_zod27 = require("zod");
var ConfigValueResponseV3 = import_zod27.z.object({ result: import_zod27.z.record(import_zod27.z.any()) });

// src/generated-admin/endpoints/ConfigAdmin$.ts
var ConfigAdmin$ = class {
  // @ts-ignore
  // prettier-ignore
  constructor(axiosInstance, namespace, useSchemaValidation = true) {
    this.axiosInstance = axiosInstance;
    this.namespace = namespace;
    this.useSchemaValidation = useSchemaValidation;
  }
  /**
   * This endpoint return the value of config key. The namespace should be publisher namespace or studio namespace. **Supported config key:** * uniqueDisplayNameEnabled * usernameDisabled * mandatoryEmailVerificationEnabled
   */
  getConfig_ByConfigKey_v3(configKey) {
    const params = {};
    const url = "/iam/v3/admin/namespaces/{namespace}/config/{configKey}".replace("{namespace}", this.namespace).replace("{configKey}", configKey);
    const resultPromise = this.axiosInstance.get(url, { params });
    return import_sdk7.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, ConfigValueResponseV3, "ConfigValueResponseV3");
  }
};

// src/generated-admin/ConfigAdminApi.ts
function ConfigAdminApi(sdk, args) {
  const sdkAssembly = sdk.assembly();
  const namespace = args?.coreConfig?.namespace ?? sdkAssembly.coreConfig.namespace;
  const useSchemaValidation = args?.coreConfig?.useSchemaValidation ?? sdkAssembly.coreConfig.useSchemaValidation;
  let axiosInstance = sdkAssembly.axiosInstance;
  const requestConfigOverrides = args?.axiosConfig?.request;
  const baseURLOverride = args?.coreConfig?.baseURL;
  const interceptorsOverride = args?.axiosConfig?.interceptors ?? [];
  if (requestConfigOverrides || baseURLOverride || interceptorsOverride.length > 0) {
    const requestConfig = import_sdk8.ApiUtils.mergeAxiosConfigs(sdkAssembly.axiosInstance.defaults, {
      ...baseURLOverride ? { baseURL: baseURLOverride } : {},
      ...requestConfigOverrides
    });
    axiosInstance = import_sdk8.Network.create(requestConfig);
    for (const interceptor of interceptorsOverride) {
      if (interceptor.type === "request") {
        axiosInstance.interceptors.request.use(interceptor.onRequest, interceptor.onError);
      }
      if (interceptor.type === "response") {
        axiosInstance.interceptors.response.use(interceptor.onSuccess, interceptor.onError);
      }
    }
  }
  async function getConfig_ByConfigKey_v3(configKey) {
    const $ = new ConfigAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getConfig_ByConfigKey_v3(configKey);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  return {
    /**
     * This endpoint return the value of config key. The namespace should be publisher namespace or studio namespace. **Supported config key:** * uniqueDisplayNameEnabled * usernameDisabled * mandatoryEmailVerificationEnabled
     */
    getConfig_ByConfigKey_v3
  };
}

// src/generated-admin/queries/ConfigAdmin.query.ts
var Key_ConfigAdmin = /* @__PURE__ */ ((Key_ConfigAdmin2) => {
  Key_ConfigAdmin2["Config_ByConfigKey_v3"] = "Iam.ConfigAdmin.Config_ByConfigKey_v3";
  return Key_ConfigAdmin2;
})(Key_ConfigAdmin || {});
var useConfigAdminApi_GetConfig_ByConfigKey_v3 = (sdk, input, options, callback) => {
  const queryFn = (sdk2, input2) => async () => {
    const response = await ConfigAdminApi(sdk2, { coreConfig: input2.coreConfig, axiosConfig: input2.axiosConfig }).getConfig_ByConfigKey_v3(
      input2.configKey
    );
    callback && callback(response);
    return response.data;
  };
  return (0, import_react_query4.useQuery)({
    queryKey: ["Iam.ConfigAdmin.Config_ByConfigKey_v3" /* Config_ByConfigKey_v3 */, input],
    queryFn: queryFn(sdk, input),
    ...options
  });
};

// src/generated-admin/queries/CountryAdmin.query.ts
var import_react_query5 = require("@tanstack/react-query");

// src/generated-admin/CountryAdminApi.ts
var import_sdk10 = require("@accelbyte/sdk");

// src/generated-admin/endpoints/CountryAdmin$.ts
var import_sdk9 = require("@accelbyte/sdk");
var import_zod31 = require("zod");

// src/generated-definitions/CountryBlacklistResponse.ts
var import_zod28 = require("zod");
var CountryBlacklistResponse = import_zod28.z.object({ blacklist: import_zod28.z.array(import_zod28.z.string()) });

// src/generated-definitions/CountryResponseArray.ts
var import_zod30 = require("zod");

// src/generated-definitions/CountryResponse.ts
var import_zod29 = require("zod");
var CountryResponse = import_zod29.z.object({ code: import_zod29.z.string(), name: import_zod29.z.string() });

// src/generated-definitions/CountryResponseArray.ts
var CountryResponseArray = import_zod30.z.array(CountryResponse);

// src/generated-admin/endpoints/CountryAdmin$.ts
var CountryAdmin$ = class {
  // @ts-ignore
  // prettier-ignore
  constructor(axiosInstance, namespace, useSchemaValidation = true) {
    this.axiosInstance = axiosInstance;
    this.namespace = namespace;
    this.useSchemaValidation = useSchemaValidation;
  }
  /**
   * Admin get country list
   */
  getCountries_v3(queryParams) {
    const params = { filterBlacklist: true, ...queryParams };
    const url = "/iam/v3/admin/namespaces/{namespace}/countries".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.get(url, { params });
    return import_sdk9.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, CountryResponseArray, "CountryResponseArray");
  }
  /**
   * Admin get country blacklist
   */
  getCountriesBlacklist_v3() {
    const params = {};
    const url = "/iam/v3/admin/namespaces/{namespace}/countries/blacklist".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.get(url, { params });
    return import_sdk9.Validate.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      CountryBlacklistResponse,
      "CountryBlacklistResponse"
    );
  }
  /**
   * Admin update country blacklist
   */
  updateCountryBlacklist_v3(data) {
    const params = {};
    const url = "/iam/v3/admin/namespaces/{namespace}/countries/blacklist".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.post(url, data, { params });
    return import_sdk9.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, import_zod31.z.unknown(), "z.unknown()");
  }
};

// src/generated-admin/CountryAdminApi.ts
function CountryAdminApi(sdk, args) {
  const sdkAssembly = sdk.assembly();
  const namespace = args?.coreConfig?.namespace ?? sdkAssembly.coreConfig.namespace;
  const useSchemaValidation = args?.coreConfig?.useSchemaValidation ?? sdkAssembly.coreConfig.useSchemaValidation;
  let axiosInstance = sdkAssembly.axiosInstance;
  const requestConfigOverrides = args?.axiosConfig?.request;
  const baseURLOverride = args?.coreConfig?.baseURL;
  const interceptorsOverride = args?.axiosConfig?.interceptors ?? [];
  if (requestConfigOverrides || baseURLOverride || interceptorsOverride.length > 0) {
    const requestConfig = import_sdk10.ApiUtils.mergeAxiosConfigs(sdkAssembly.axiosInstance.defaults, {
      ...baseURLOverride ? { baseURL: baseURLOverride } : {},
      ...requestConfigOverrides
    });
    axiosInstance = import_sdk10.Network.create(requestConfig);
    for (const interceptor of interceptorsOverride) {
      if (interceptor.type === "request") {
        axiosInstance.interceptors.request.use(interceptor.onRequest, interceptor.onError);
      }
      if (interceptor.type === "response") {
        axiosInstance.interceptors.response.use(interceptor.onSuccess, interceptor.onError);
      }
    }
  }
  async function getCountries_v3(queryParams) {
    const $ = new CountryAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getCountries_v3(queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getCountriesBlacklist_v3() {
    const $ = new CountryAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getCountriesBlacklist_v3();
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function updateCountryBlacklist_v3(data) {
    const $ = new CountryAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.updateCountryBlacklist_v3(data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  return {
    /**
     * Admin get country list
     */
    getCountries_v3,
    /**
     * Admin get country blacklist
     */
    getCountriesBlacklist_v3,
    /**
     * Admin update country blacklist
     */
    updateCountryBlacklist_v3
  };
}

// src/generated-admin/queries/CountryAdmin.query.ts
var Key_CountryAdmin = /* @__PURE__ */ ((Key_CountryAdmin2) => {
  Key_CountryAdmin2["Countries_v3"] = "Iam.CountryAdmin.Countries_v3";
  Key_CountryAdmin2["CountriesBlacklist_v3"] = "Iam.CountryAdmin.CountriesBlacklist_v3";
  Key_CountryAdmin2["CountryBlacklist_v3"] = "Iam.CountryAdmin.CountryBlacklist_v3";
  return Key_CountryAdmin2;
})(Key_CountryAdmin || {});
var useCountryAdminApi_GetCountries_v3 = (sdk, input, options, callback) => {
  const queryFn = (sdk2, input2) => async () => {
    const response = await CountryAdminApi(sdk2, { coreConfig: input2.coreConfig, axiosConfig: input2.axiosConfig }).getCountries_v3(
      input2.queryParams
    );
    callback && callback(response);
    return response.data;
  };
  return (0, import_react_query5.useQuery)({
    queryKey: ["Iam.CountryAdmin.Countries_v3" /* Countries_v3 */, input],
    queryFn: queryFn(sdk, input),
    ...options
  });
};
var useCountryAdminApi_GetCountriesBlacklist_v3 = (sdk, input, options, callback) => {
  const queryFn = (sdk2, input2) => async () => {
    const response = await CountryAdminApi(sdk2, { coreConfig: input2.coreConfig, axiosConfig: input2.axiosConfig }).getCountriesBlacklist_v3();
    callback && callback(response);
    return response.data;
  };
  return (0, import_react_query5.useQuery)({
    queryKey: ["Iam.CountryAdmin.CountriesBlacklist_v3" /* CountriesBlacklist_v3 */, input],
    queryFn: queryFn(sdk, input),
    ...options
  });
};
var useCountryAdminApi_UpdateCountryBlacklistMutation_v3 = (sdk, options, callback) => {
  const mutationFn = async (input) => {
    const response = await CountryAdminApi(sdk, { coreConfig: input.coreConfig, axiosConfig: input.axiosConfig }).updateCountryBlacklist_v3(
      input.data
    );
    callback && callback(response.data);
    return response.data;
  };
  return (0, import_react_query5.useMutation)({
    mutationKey: ["Iam.CountryAdmin.CountryBlacklist_v3" /* CountryBlacklist_v3 */],
    mutationFn,
    ...options
  });
};

// src/generated-admin/queries/DevicesV4Admin.query.ts
var import_react_query6 = require("@tanstack/react-query");

// src/generated-admin/DevicesV4AdminApi.ts
var import_sdk12 = require("@accelbyte/sdk");

// src/generated-admin/endpoints/DevicesV4Admin$.ts
var import_sdk11 = require("@accelbyte/sdk");
var import_zod43 = require("zod");

// src/generated-definitions/DeviceBanResponseV4.ts
var import_zod32 = require("zod");
var DeviceBanResponseV4 = import_zod32.z.object({
  bannedAt: import_zod32.z.number().int(),
  bannedBy: import_zod32.z.string(),
  comment: import_zod32.z.string(),
  deviceId: import_zod32.z.string(),
  deviceType: import_zod32.z.string(),
  disabledAt: import_zod32.z.number().int(),
  enabled: import_zod32.z.boolean(),
  endDate: import_zod32.z.number().int(),
  id: import_zod32.z.string(),
  namespace: import_zod32.z.string(),
  reason: import_zod32.z.string(),
  targetNamespace: import_zod32.z.string()
});

// src/generated-definitions/DeviceBannedResponseV4.ts
var import_zod34 = require("zod");

// src/generated-definitions/Pagination.ts
var import_zod33 = require("zod");
var Pagination = import_zod33.z.object({ First: import_zod33.z.string(), Last: import_zod33.z.string(), Next: import_zod33.z.string(), Previous: import_zod33.z.string() });

// src/generated-definitions/DeviceBannedResponseV4.ts
var DeviceBannedResponseV4 = import_zod34.z.object({ data: import_zod34.z.array(DeviceBanResponseV4), paging: Pagination });

// src/generated-definitions/DeviceBansResponseV4.ts
var import_zod35 = require("zod");
var DeviceBansResponseV4 = import_zod35.z.object({ data: import_zod35.z.array(DeviceBanResponseV4) });

// src/generated-definitions/DeviceIdDecryptResponseV4.ts
var import_zod36 = require("zod");
var DeviceIdDecryptResponseV4 = import_zod36.z.object({ deviceId: import_zod36.z.string() });

// src/generated-definitions/DeviceTypesResponseV4.ts
var import_zod38 = require("zod");

// src/generated-definitions/DeviceTypeResponseV4.ts
var import_zod37 = require("zod");
var DeviceTypeResponseV4 = import_zod37.z.object({ deviceType: import_zod37.z.string() });

// src/generated-definitions/DeviceTypesResponseV4.ts
var DeviceTypesResponseV4 = import_zod38.z.object({ data: import_zod38.z.array(DeviceTypeResponseV4) });

// src/generated-definitions/DeviceUsersResponseV4.ts
var import_zod40 = require("zod");

// src/generated-definitions/DeviceUserResponseV4.ts
var import_zod39 = require("zod");
var DeviceUserResponseV4 = import_zod39.z.object({
  ext: import_zod39.z.record(import_zod39.z.any()).nullish(),
  ip: import_zod39.z.string(),
  lastLoginTime: import_zod39.z.number().int(),
  namespace: import_zod39.z.string(),
  userId: import_zod39.z.string()
});

// src/generated-definitions/DeviceUsersResponseV4.ts
var DeviceUsersResponseV4 = import_zod40.z.object({ users: import_zod40.z.array(DeviceUserResponseV4) });

// src/generated-definitions/DevicesResponseV4.ts
var import_zod42 = require("zod");

// src/generated-definitions/DeviceResponseV4.ts
var import_zod41 = require("zod");
var DeviceResponseV4 = import_zod41.z.object({
  ban: DeviceBanResponseV4.nullish(),
  deviceId: import_zod41.z.string(),
  deviceType: import_zod41.z.string(),
  ext: import_zod41.z.record(import_zod41.z.any()).nullish(),
  ip: import_zod41.z.string(),
  lastLoginTime: import_zod41.z.number().int()
});

// src/generated-definitions/DevicesResponseV4.ts
var DevicesResponseV4 = import_zod42.z.object({ devices: import_zod42.z.array(DeviceResponseV4) });

// src/generated-admin/endpoints/DevicesV4Admin$.ts
var DevicesV4Admin$ = class {
  // @ts-ignore
  // prettier-ignore
  constructor(axiosInstance, namespace, useSchemaValidation = true) {
    this.axiosInstance = axiosInstance;
    this.namespace = namespace;
    this.useSchemaValidation = useSchemaValidation;
  }
  /**
   * This is the endpoint for an admin to get devices a user ever used to login
   */
  getDevices_v4(queryParams) {
    const params = { ...queryParams };
    const url = "/iam/v4/admin/namespaces/{namespace}/devices".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.get(url, { params });
    return import_sdk11.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, DevicesResponseV4, "DevicesResponseV4");
  }
  /**
   * This is the endpoint for an admin to get device bans of user
   */
  getDevicesBans_v4(queryParams) {
    const params = { ...queryParams };
    const url = "/iam/v4/admin/namespaces/{namespace}/devices/bans".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.get(url, { params });
    return import_sdk11.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, DeviceBansResponseV4, "DeviceBansResponseV4");
  }
  /**
   * This is the endpoint for an admin to ban a device
   */
  createDeviceBan_v4(data) {
    const params = {};
    const url = "/iam/v4/admin/namespaces/{namespace}/devices/bans".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.post(url, data, { params });
    return import_sdk11.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, import_zod43.z.unknown(), "z.unknown()");
  }
  /**
   * This is the endpoint for an admin to get device types
   */
  getDevicesTypes_v4() {
    const params = {};
    const url = "/iam/v4/admin/namespaces/{namespace}/devices/types".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.get(url, { params });
    return import_sdk11.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, DeviceTypesResponseV4, "DeviceTypesResponseV4");
  }
  /**
   * This is the endpoint for an admin to get banned devices
   */
  getDevicesBanned_v4(queryParams) {
    const params = { ...queryParams };
    const url = "/iam/v4/admin/namespaces/{namespace}/devices/banned".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.get(url, { params });
    return import_sdk11.Validate.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      DeviceBannedResponseV4,
      "DeviceBannedResponseV4"
    );
  }
  /**
   * This is the endpoint for an admin to generate device report
   */
  getDevicesReport_v4(queryParams) {
    const params = { ...queryParams };
    const url = "/iam/v4/admin/namespaces/{namespace}/devices/report".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.get(url, { params });
    return import_sdk11.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, import_zod43.z.unknown(), "z.unknown()");
  }
  /**
   * This is the endpoint for an admin to get device ban config
   */
  getDeviceBan_ByBanId_v4(banId) {
    const params = {};
    const url = "/iam/v4/admin/namespaces/{namespace}/devices/bans/{banId}".replace("{namespace}", this.namespace).replace("{banId}", banId);
    const resultPromise = this.axiosInstance.get(url, { params });
    return import_sdk11.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, DeviceBanResponseV4, "DeviceBanResponseV4");
  }
  /**
   * This is the endpoint for an admin to update a device ban config
   */
  updateDeviceBan_ByBanId_v4(banId, data) {
    const params = {};
    const url = "/iam/v4/admin/namespaces/{namespace}/devices/bans/{banId}".replace("{namespace}", this.namespace).replace("{banId}", banId);
    const resultPromise = this.axiosInstance.put(url, data, { params });
    return import_sdk11.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, import_zod43.z.unknown(), "z.unknown()");
  }
  /**
   * This is the endpoint for an admin to get device ban list
   */
  getBans_ByDeviceId_v4(deviceId) {
    const params = {};
    const url = "/iam/v4/admin/namespaces/{namespace}/devices/{deviceId}/bans".replace("{namespace}", this.namespace).replace("{deviceId}", deviceId);
    const resultPromise = this.axiosInstance.get(url, { params });
    return import_sdk11.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, DeviceBansResponseV4, "DeviceBansResponseV4");
  }
  /**
   * This is the endpoint for an admin to unban device
   */
  updateUnban_ByDeviceId_v4(deviceId) {
    const params = {};
    const url = "/iam/v4/admin/namespaces/{namespace}/devices/{deviceId}/unban".replace("{namespace}", this.namespace).replace("{deviceId}", deviceId);
    const resultPromise = this.axiosInstance.put(url, null, { params });
    return import_sdk11.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, import_zod43.z.unknown(), "z.unknown()");
  }
  /**
   * This is the endpoint for an admin to get users that ever login on the device
   */
  getUsers_ByDeviceId_v4(deviceId) {
    const params = {};
    const url = "/iam/v4/admin/namespaces/{namespace}/devices/{deviceId}/users".replace("{namespace}", this.namespace).replace("{deviceId}", deviceId);
    const resultPromise = this.axiosInstance.get(url, { params });
    return import_sdk11.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, DeviceUsersResponseV4, "DeviceUsersResponseV4");
  }
  /**
   * @deprecated
   * This is the endpoint for an admin to decrypt device id
   */
  getDecrypt_ByDeviceId_v4(deviceId) {
    const params = {};
    const url = "/iam/v4/admin/namespaces/{namespace}/devices/{deviceId}/decrypt".replace("{namespace}", this.namespace).replace("{deviceId}", deviceId);
    const resultPromise = this.axiosInstance.get(url, { params });
    return import_sdk11.Validate.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      DeviceIdDecryptResponseV4,
      "DeviceIdDecryptResponseV4"
    );
  }
};

// src/generated-admin/DevicesV4AdminApi.ts
function DevicesV4AdminApi(sdk, args) {
  const sdkAssembly = sdk.assembly();
  const namespace = args?.coreConfig?.namespace ?? sdkAssembly.coreConfig.namespace;
  const useSchemaValidation = args?.coreConfig?.useSchemaValidation ?? sdkAssembly.coreConfig.useSchemaValidation;
  let axiosInstance = sdkAssembly.axiosInstance;
  const requestConfigOverrides = args?.axiosConfig?.request;
  const baseURLOverride = args?.coreConfig?.baseURL;
  const interceptorsOverride = args?.axiosConfig?.interceptors ?? [];
  if (requestConfigOverrides || baseURLOverride || interceptorsOverride.length > 0) {
    const requestConfig = import_sdk12.ApiUtils.mergeAxiosConfigs(sdkAssembly.axiosInstance.defaults, {
      ...baseURLOverride ? { baseURL: baseURLOverride } : {},
      ...requestConfigOverrides
    });
    axiosInstance = import_sdk12.Network.create(requestConfig);
    for (const interceptor of interceptorsOverride) {
      if (interceptor.type === "request") {
        axiosInstance.interceptors.request.use(interceptor.onRequest, interceptor.onError);
      }
      if (interceptor.type === "response") {
        axiosInstance.interceptors.response.use(interceptor.onSuccess, interceptor.onError);
      }
    }
  }
  async function getDevices_v4(queryParams) {
    const $ = new DevicesV4Admin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getDevices_v4(queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getDevicesBans_v4(queryParams) {
    const $ = new DevicesV4Admin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getDevicesBans_v4(queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function createDeviceBan_v4(data) {
    const $ = new DevicesV4Admin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.createDeviceBan_v4(data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getDevicesTypes_v4() {
    const $ = new DevicesV4Admin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getDevicesTypes_v4();
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getDevicesBanned_v4(queryParams) {
    const $ = new DevicesV4Admin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getDevicesBanned_v4(queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getDevicesReport_v4(queryParams) {
    const $ = new DevicesV4Admin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getDevicesReport_v4(queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getDeviceBan_ByBanId_v4(banId) {
    const $ = new DevicesV4Admin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getDeviceBan_ByBanId_v4(banId);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function updateDeviceBan_ByBanId_v4(banId, data) {
    const $ = new DevicesV4Admin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.updateDeviceBan_ByBanId_v4(banId, data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getBans_ByDeviceId_v4(deviceId) {
    const $ = new DevicesV4Admin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getBans_ByDeviceId_v4(deviceId);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function updateUnban_ByDeviceId_v4(deviceId) {
    const $ = new DevicesV4Admin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.updateUnban_ByDeviceId_v4(deviceId);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getUsers_ByDeviceId_v4(deviceId) {
    const $ = new DevicesV4Admin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getUsers_ByDeviceId_v4(deviceId);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getDecrypt_ByDeviceId_v4(deviceId) {
    const $ = new DevicesV4Admin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getDecrypt_ByDeviceId_v4(deviceId);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  return {
    /**
     * This is the endpoint for an admin to get devices a user ever used to login
     */
    getDevices_v4,
    /**
     * This is the endpoint for an admin to get device bans of user
     */
    getDevicesBans_v4,
    /**
     * This is the endpoint for an admin to ban a device
     */
    createDeviceBan_v4,
    /**
     * This is the endpoint for an admin to get device types
     */
    getDevicesTypes_v4,
    /**
     * This is the endpoint for an admin to get banned devices
     */
    getDevicesBanned_v4,
    /**
     * This is the endpoint for an admin to generate device report
     */
    getDevicesReport_v4,
    /**
     * This is the endpoint for an admin to get device ban config
     */
    getDeviceBan_ByBanId_v4,
    /**
     * This is the endpoint for an admin to update a device ban config
     */
    updateDeviceBan_ByBanId_v4,
    /**
     * This is the endpoint for an admin to get device ban list
     */
    getBans_ByDeviceId_v4,
    /**
     * This is the endpoint for an admin to unban device
     */
    updateUnban_ByDeviceId_v4,
    /**
     * This is the endpoint for an admin to get users that ever login on the device
     */
    getUsers_ByDeviceId_v4,
    /**
     * @deprecated
     * This is the endpoint for an admin to decrypt device id
     */
    getDecrypt_ByDeviceId_v4
  };
}

// src/generated-admin/queries/DevicesV4Admin.query.ts
var Key_DevicesV4Admin = /* @__PURE__ */ ((Key_DevicesV4Admin2) => {
  Key_DevicesV4Admin2["Devices_v4"] = "Iam.DevicesV4Admin.Devices_v4";
  Key_DevicesV4Admin2["DevicesBans_v4"] = "Iam.DevicesV4Admin.DevicesBans_v4";
  Key_DevicesV4Admin2["DeviceBan_v4"] = "Iam.DevicesV4Admin.DeviceBan_v4";
  Key_DevicesV4Admin2["DevicesTypes_v4"] = "Iam.DevicesV4Admin.DevicesTypes_v4";
  Key_DevicesV4Admin2["DevicesBanned_v4"] = "Iam.DevicesV4Admin.DevicesBanned_v4";
  Key_DevicesV4Admin2["DevicesReport_v4"] = "Iam.DevicesV4Admin.DevicesReport_v4";
  Key_DevicesV4Admin2["DeviceBan_ByBanId_v4"] = "Iam.DevicesV4Admin.DeviceBan_ByBanId_v4";
  Key_DevicesV4Admin2["Bans_ByDeviceId_v4"] = "Iam.DevicesV4Admin.Bans_ByDeviceId_v4";
  Key_DevicesV4Admin2["Unban_ByDeviceId_v4"] = "Iam.DevicesV4Admin.Unban_ByDeviceId_v4";
  Key_DevicesV4Admin2["Users_ByDeviceId_v4"] = "Iam.DevicesV4Admin.Users_ByDeviceId_v4";
  Key_DevicesV4Admin2["Decrypt_ByDeviceId_v4"] = "Iam.DevicesV4Admin.Decrypt_ByDeviceId_v4";
  return Key_DevicesV4Admin2;
})(Key_DevicesV4Admin || {});
var useDevicesV4AdminApi_GetDevices_v4 = (sdk, input, options, callback) => {
  const queryFn = (sdk2, input2) => async () => {
    const response = await DevicesV4AdminApi(sdk2, { coreConfig: input2.coreConfig, axiosConfig: input2.axiosConfig }).getDevices_v4(
      input2.queryParams
    );
    callback && callback(response);
    return response.data;
  };
  return (0, import_react_query6.useQuery)({
    queryKey: ["Iam.DevicesV4Admin.Devices_v4" /* Devices_v4 */, input],
    queryFn: queryFn(sdk, input),
    ...options
  });
};
var useDevicesV4AdminApi_GetDevicesBans_v4 = (sdk, input, options, callback) => {
  const queryFn = (sdk2, input2) => async () => {
    const response = await DevicesV4AdminApi(sdk2, { coreConfig: input2.coreConfig, axiosConfig: input2.axiosConfig }).getDevicesBans_v4(
      input2.queryParams
    );
    callback && callback(response);
    return response.data;
  };
  return (0, import_react_query6.useQuery)({
    queryKey: ["Iam.DevicesV4Admin.DevicesBans_v4" /* DevicesBans_v4 */, input],
    queryFn: queryFn(sdk, input),
    ...options
  });
};
var useDevicesV4AdminApi_CreateDeviceBanMutation_v4 = (sdk, options, callback) => {
  const mutationFn = async (input) => {
    const response = await DevicesV4AdminApi(sdk, { coreConfig: input.coreConfig, axiosConfig: input.axiosConfig }).createDeviceBan_v4(
      input.data
    );
    callback && callback(response.data);
    return response.data;
  };
  return (0, import_react_query6.useMutation)({
    mutationKey: ["Iam.DevicesV4Admin.DeviceBan_v4" /* DeviceBan_v4 */],
    mutationFn,
    ...options
  });
};
var useDevicesV4AdminApi_GetDevicesTypes_v4 = (sdk, input, options, callback) => {
  const queryFn = (sdk2, input2) => async () => {
    const response = await DevicesV4AdminApi(sdk2, { coreConfig: input2.coreConfig, axiosConfig: input2.axiosConfig }).getDevicesTypes_v4();
    callback && callback(response);
    return response.data;
  };
  return (0, import_react_query6.useQuery)({
    queryKey: ["Iam.DevicesV4Admin.DevicesTypes_v4" /* DevicesTypes_v4 */, input],
    queryFn: queryFn(sdk, input),
    ...options
  });
};
var useDevicesV4AdminApi_GetDevicesBanned_v4 = (sdk, input, options, callback) => {
  const queryFn = (sdk2, input2) => async () => {
    const response = await DevicesV4AdminApi(sdk2, { coreConfig: input2.coreConfig, axiosConfig: input2.axiosConfig }).getDevicesBanned_v4(
      input2.queryParams
    );
    callback && callback(response);
    return response.data;
  };
  return (0, import_react_query6.useQuery)({
    queryKey: ["Iam.DevicesV4Admin.DevicesBanned_v4" /* DevicesBanned_v4 */, input],
    queryFn: queryFn(sdk, input),
    ...options
  });
};
var useDevicesV4AdminApi_GetDevicesReport_v4 = (sdk, input, options, callback) => {
  const queryFn = (sdk2, input2) => async () => {
    const response = await DevicesV4AdminApi(sdk2, { coreConfig: input2.coreConfig, axiosConfig: input2.axiosConfig }).getDevicesReport_v4(
      input2.queryParams
    );
    callback && callback(response);
    return response.data;
  };
  return (0, import_react_query6.useQuery)({
    queryKey: ["Iam.DevicesV4Admin.DevicesReport_v4" /* DevicesReport_v4 */, input],
    queryFn: queryFn(sdk, input),
    ...options
  });
};
var useDevicesV4AdminApi_GetDeviceBan_ByBanId_v4 = (sdk, input, options, callback) => {
  const queryFn = (sdk2, input2) => async () => {
    const response = await DevicesV4AdminApi(sdk2, { coreConfig: input2.coreConfig, axiosConfig: input2.axiosConfig }).getDeviceBan_ByBanId_v4(
      input2.banId
    );
    callback && callback(response);
    return response.data;
  };
  return (0, import_react_query6.useQuery)({
    queryKey: ["Iam.DevicesV4Admin.DeviceBan_ByBanId_v4" /* DeviceBan_ByBanId_v4 */, input],
    queryFn: queryFn(sdk, input),
    ...options
  });
};
var useDevicesV4AdminApi_UpdateDeviceBan_ByBanIdMutation_v4 = (sdk, options, callback) => {
  const mutationFn = async (input) => {
    const response = await DevicesV4AdminApi(sdk, {
      coreConfig: input.coreConfig,
      axiosConfig: input.axiosConfig
    }).updateDeviceBan_ByBanId_v4(input.banId, input.data);
    callback && callback(response.data);
    return response.data;
  };
  return (0, import_react_query6.useMutation)({
    mutationKey: ["Iam.DevicesV4Admin.DeviceBan_ByBanId_v4" /* DeviceBan_ByBanId_v4 */],
    mutationFn,
    ...options
  });
};
var useDevicesV4AdminApi_GetBans_ByDeviceId_v4 = (sdk, input, options, callback) => {
  const queryFn = (sdk2, input2) => async () => {
    const response = await DevicesV4AdminApi(sdk2, { coreConfig: input2.coreConfig, axiosConfig: input2.axiosConfig }).getBans_ByDeviceId_v4(
      input2.deviceId
    );
    callback && callback(response);
    return response.data;
  };
  return (0, import_react_query6.useQuery)({
    queryKey: ["Iam.DevicesV4Admin.Bans_ByDeviceId_v4" /* Bans_ByDeviceId_v4 */, input],
    queryFn: queryFn(sdk, input),
    ...options
  });
};
var useDevicesV4AdminApi_UpdateUnban_ByDeviceIdMutation_v4 = (sdk, options, callback) => {
  const mutationFn = async (input) => {
    const response = await DevicesV4AdminApi(sdk, {
      coreConfig: input.coreConfig,
      axiosConfig: input.axiosConfig
    }).updateUnban_ByDeviceId_v4(input.deviceId);
    callback && callback(response.data);
    return response.data;
  };
  return (0, import_react_query6.useMutation)({
    mutationKey: ["Iam.DevicesV4Admin.Unban_ByDeviceId_v4" /* Unban_ByDeviceId_v4 */],
    mutationFn,
    ...options
  });
};
var useDevicesV4AdminApi_GetUsers_ByDeviceId_v4 = (sdk, input, options, callback) => {
  const queryFn = (sdk2, input2) => async () => {
    const response = await DevicesV4AdminApi(sdk2, { coreConfig: input2.coreConfig, axiosConfig: input2.axiosConfig }).getUsers_ByDeviceId_v4(
      input2.deviceId
    );
    callback && callback(response);
    return response.data;
  };
  return (0, import_react_query6.useQuery)({
    queryKey: ["Iam.DevicesV4Admin.Users_ByDeviceId_v4" /* Users_ByDeviceId_v4 */, input],
    queryFn: queryFn(sdk, input),
    ...options
  });
};
var useDevicesV4AdminApi_GetDecrypt_ByDeviceId_v4 = (sdk, input, options, callback) => {
  const queryFn = (sdk2, input2) => async () => {
    const response = await DevicesV4AdminApi(sdk2, {
      coreConfig: input2.coreConfig,
      axiosConfig: input2.axiosConfig
    }).getDecrypt_ByDeviceId_v4(input2.deviceId);
    callback && callback(response);
    return response.data;
  };
  return (0, import_react_query6.useQuery)({
    queryKey: ["Iam.DevicesV4Admin.Decrypt_ByDeviceId_v4" /* Decrypt_ByDeviceId_v4 */, input],
    queryFn: queryFn(sdk, input),
    ...options
  });
};

// src/generated-admin/queries/InputValidationsAdmin.query.ts
var import_react_query7 = require("@tanstack/react-query");

// src/generated-admin/InputValidationsAdminApi.ts
var import_sdk14 = require("@accelbyte/sdk");

// src/generated-admin/endpoints/InputValidationsAdmin$.ts
var import_sdk13 = require("@accelbyte/sdk");
var import_zod49 = require("zod");

// src/generated-definitions/InputValidationsResponse.ts
var import_zod48 = require("zod");

// src/generated-definitions/InputValidationData.ts
var import_zod47 = require("zod");

// src/generated-definitions/ValidationDetail.ts
var import_zod46 = require("zod");

// src/generated-definitions/AvatarConfig.ts
var import_zod44 = require("zod");
var AvatarConfig = import_zod44.z.object({ allowedPrefixes: import_zod44.z.array(import_zod44.z.string()), preferRegex: import_zod44.z.boolean(), regex: import_zod44.z.string() });

// src/generated-definitions/InputValidationDescription.ts
var import_zod45 = require("zod");
var InputValidationDescription = import_zod45.z.object({ language: import_zod45.z.string(), message: import_zod45.z.array(import_zod45.z.string()) });

// src/generated-definitions/ValidationDetail.ts
var ValidationDetail = import_zod46.z.object({
  allowAllSpecialCharacters: import_zod46.z.boolean(),
  allowDigit: import_zod46.z.boolean(),
  allowLetter: import_zod46.z.boolean(),
  allowSpace: import_zod46.z.boolean(),
  allowUnicode: import_zod46.z.boolean(),
  avatarConfig: AvatarConfig.nullish(),
  blockedWord: import_zod46.z.array(import_zod46.z.string()),
  description: import_zod46.z.array(InputValidationDescription),
  isCustomRegex: import_zod46.z.boolean(),
  letterCase: import_zod46.z.string(),
  maxLength: import_zod46.z.number().int(),
  maxRepeatingAlphaNum: import_zod46.z.number().int(),
  maxRepeatingSpecialCharacter: import_zod46.z.number().int(),
  minCharType: import_zod46.z.number().int(),
  minLength: import_zod46.z.number().int(),
  profanityFilter: import_zod46.z.string().nullish(),
  regex: import_zod46.z.string(),
  specialCharacterLocation: import_zod46.z.string(),
  specialCharacters: import_zod46.z.array(import_zod46.z.string())
});

// src/generated-definitions/InputValidationData.ts
var InputValidationData = import_zod47.z.object({ field: import_zod47.z.string(), validation: ValidationDetail });

// src/generated-definitions/InputValidationsResponse.ts
var InputValidationsResponse = import_zod48.z.object({ data: import_zod48.z.array(InputValidationData), version: import_zod48.z.number().int() });

// src/generated-admin/endpoints/InputValidationsAdmin$.ts
var InputValidationsAdmin$ = class {
  // @ts-ignore
  // prettier-ignore
  constructor(axiosInstance, namespace, useSchemaValidation = true) {
    this.axiosInstance = axiosInstance;
    this.namespace = namespace;
    this.useSchemaValidation = useSchemaValidation;
  }
  /**
   * This endpoint is to get list of input validation configuration. &lt;code&gt;regex&lt;/code&gt; parameter will be returned if &lt;code&gt;isCustomRegex&lt;/code&gt; is true. Otherwise, it will be empty.
   */
  getInputValidations_v3() {
    const params = {};
    const url = "/iam/v3/admin/inputValidations";
    const resultPromise = this.axiosInstance.get(url, { params });
    return import_sdk13.Validate.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      InputValidationsResponse,
      "InputValidationsResponse"
    );
  }
  /**
   * This endpoint is used to update input validation configuration. Supported &lt;code&gt;field&lt;/code&gt;: - displayName - password - username - email - avatar If &lt;code&gt;isCustomRegex&lt;/code&gt; is set to true, &lt;code&gt;regex&lt;/code&gt; parameter will be used as input validation and the other parameters will be ignored. Otherwise, &lt;code&gt;regex&lt;/code&gt; parameter will be ignored and regex for input validation will be generated based on the combination of the other parameters. If &lt;code&gt;allowUnicode&lt;/code&gt; is set to true, unicode regex pattern will be use as the input validation and the other parameters will be ignored. Supported &lt;code&gt;letterCase&lt;/code&gt;: - lowercase - uppercase - mixed: uppercase and lowercase - any: uppercase and/or lowercase flexible special character non words with &lt;code&gt;allowAllSpecialCharacters&lt;/code&gt; if &lt;code&gt;allowAllSpecialCharacters&lt;/code&gt; is set to true &lt;code&gt;specialCharacters&lt;/code&gt; will forced to empty. Supported &lt;code&gt;specialCharacterLocation&lt;/code&gt;: - anywhere - middle If &lt;code&gt;specialCharacters&lt;/code&gt; is empty, &lt;code&gt;specialCharacterLocation&lt;/code&gt; and &lt;code&gt;maxRepeatingSpecialCharacter&lt;/code&gt; will be ignored. &lt;code&gt;minCharType&lt;/code&gt; is used to identify how many required criteria in the regex. The supported criteria are number, letter, special character, and letter case. If set to 0 or 1 means all criteria are optional. It can be set as much as the number of criteria enabled. If &lt;code&gt;blockedWord&lt;/code&gt; is set by admin, any input from user which contain kind of blocked word(s) will be blocked for create/upgrade/update account If &lt;code&gt;avatarConfig&lt;/code&gt; is set, will use this config and skip all the other validation conditions
   */
  updateInputValidation_v3(data) {
    const params = {};
    const url = "/iam/v3/admin/inputValidations";
    const resultPromise = this.axiosInstance.put(url, data, { params });
    return import_sdk13.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, import_zod49.z.unknown(), "z.unknown()");
  }
  /**
   * This endpoint is used to reset input validation to the default input validation configurations
   */
  deleteInputValidation_ByField_v3(field) {
    const params = {};
    const url = "/iam/v3/admin/inputValidations/{field}".replace("{field}", field);
    const resultPromise = this.axiosInstance.delete(url, { params });
    return import_sdk13.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, import_zod49.z.unknown(), "z.unknown()");
  }
};

// src/generated-admin/InputValidationsAdminApi.ts
function InputValidationsAdminApi(sdk, args) {
  const sdkAssembly = sdk.assembly();
  const namespace = args?.coreConfig?.namespace ?? sdkAssembly.coreConfig.namespace;
  const useSchemaValidation = args?.coreConfig?.useSchemaValidation ?? sdkAssembly.coreConfig.useSchemaValidation;
  let axiosInstance = sdkAssembly.axiosInstance;
  const requestConfigOverrides = args?.axiosConfig?.request;
  const baseURLOverride = args?.coreConfig?.baseURL;
  const interceptorsOverride = args?.axiosConfig?.interceptors ?? [];
  if (requestConfigOverrides || baseURLOverride || interceptorsOverride.length > 0) {
    const requestConfig = import_sdk14.ApiUtils.mergeAxiosConfigs(sdkAssembly.axiosInstance.defaults, {
      ...baseURLOverride ? { baseURL: baseURLOverride } : {},
      ...requestConfigOverrides
    });
    axiosInstance = import_sdk14.Network.create(requestConfig);
    for (const interceptor of interceptorsOverride) {
      if (interceptor.type === "request") {
        axiosInstance.interceptors.request.use(interceptor.onRequest, interceptor.onError);
      }
      if (interceptor.type === "response") {
        axiosInstance.interceptors.response.use(interceptor.onSuccess, interceptor.onError);
      }
    }
  }
  async function getInputValidations_v3() {
    const $ = new InputValidationsAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getInputValidations_v3();
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function updateInputValidation_v3(data) {
    const $ = new InputValidationsAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.updateInputValidation_v3(data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function deleteInputValidation_ByField_v3(field) {
    const $ = new InputValidationsAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.deleteInputValidation_ByField_v3(field);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  return {
    /**
     * This endpoint is to get list of input validation configuration. &lt;code&gt;regex&lt;/code&gt; parameter will be returned if &lt;code&gt;isCustomRegex&lt;/code&gt; is true. Otherwise, it will be empty.
     */
    getInputValidations_v3,
    /**
     * This endpoint is used to update input validation configuration. Supported &lt;code&gt;field&lt;/code&gt;: - displayName - password - username - email - avatar If &lt;code&gt;isCustomRegex&lt;/code&gt; is set to true, &lt;code&gt;regex&lt;/code&gt; parameter will be used as input validation and the other parameters will be ignored. Otherwise, &lt;code&gt;regex&lt;/code&gt; parameter will be ignored and regex for input validation will be generated based on the combination of the other parameters. If &lt;code&gt;allowUnicode&lt;/code&gt; is set to true, unicode regex pattern will be use as the input validation and the other parameters will be ignored. Supported &lt;code&gt;letterCase&lt;/code&gt;: - lowercase - uppercase - mixed: uppercase and lowercase - any: uppercase and/or lowercase flexible special character non words with &lt;code&gt;allowAllSpecialCharacters&lt;/code&gt; if &lt;code&gt;allowAllSpecialCharacters&lt;/code&gt; is set to true &lt;code&gt;specialCharacters&lt;/code&gt; will forced to empty. Supported &lt;code&gt;specialCharacterLocation&lt;/code&gt;: - anywhere - middle If &lt;code&gt;specialCharacters&lt;/code&gt; is empty, &lt;code&gt;specialCharacterLocation&lt;/code&gt; and &lt;code&gt;maxRepeatingSpecialCharacter&lt;/code&gt; will be ignored. &lt;code&gt;minCharType&lt;/code&gt; is used to identify how many required criteria in the regex. The supported criteria are number, letter, special character, and letter case. If set to 0 or 1 means all criteria are optional. It can be set as much as the number of criteria enabled. If &lt;code&gt;blockedWord&lt;/code&gt; is set by admin, any input from user which contain kind of blocked word(s) will be blocked for create/upgrade/update account If &lt;code&gt;avatarConfig&lt;/code&gt; is set, will use this config and skip all the other validation conditions
     */
    updateInputValidation_v3,
    /**
     * This endpoint is used to reset input validation to the default input validation configurations
     */
    deleteInputValidation_ByField_v3
  };
}

// src/generated-admin/queries/InputValidationsAdmin.query.ts
var Key_InputValidationsAdmin = /* @__PURE__ */ ((Key_InputValidationsAdmin2) => {
  Key_InputValidationsAdmin2["InputValidations_v3"] = "Iam.InputValidationsAdmin.InputValidations_v3";
  Key_InputValidationsAdmin2["InputValidation_v3"] = "Iam.InputValidationsAdmin.InputValidation_v3";
  Key_InputValidationsAdmin2["InputValidation_ByField_v3"] = "Iam.InputValidationsAdmin.InputValidation_ByField_v3";
  return Key_InputValidationsAdmin2;
})(Key_InputValidationsAdmin || {});
var useInputValidationsAdminApi_GetInputValidations_v3 = (sdk, input, options, callback) => {
  const queryFn = (sdk2, input2) => async () => {
    const response = await InputValidationsAdminApi(sdk2, {
      coreConfig: input2.coreConfig,
      axiosConfig: input2.axiosConfig
    }).getInputValidations_v3();
    callback && callback(response);
    return response.data;
  };
  return (0, import_react_query7.useQuery)({
    queryKey: ["Iam.InputValidationsAdmin.InputValidations_v3" /* InputValidations_v3 */, input],
    queryFn: queryFn(sdk, input),
    ...options
  });
};
var useInputValidationsAdminApi_UpdateInputValidationMutation_v3 = (sdk, options, callback) => {
  const mutationFn = async (input) => {
    const response = await InputValidationsAdminApi(sdk, {
      coreConfig: input.coreConfig,
      axiosConfig: input.axiosConfig
    }).updateInputValidation_v3(input.data);
    callback && callback(response.data);
    return response.data;
  };
  return (0, import_react_query7.useMutation)({
    mutationKey: ["Iam.InputValidationsAdmin.InputValidation_v3" /* InputValidation_v3 */],
    mutationFn,
    ...options
  });
};
var useInputValidationsAdminApi_DeleteInputValidation_ByFieldMutation_v3 = (sdk, options, callback) => {
  const mutationFn = async (input) => {
    const response = await InputValidationsAdminApi(sdk, {
      coreConfig: input.coreConfig,
      axiosConfig: input.axiosConfig
    }).deleteInputValidation_ByField_v3(input.field);
    callback && callback(response.data);
    return response.data;
  };
  return (0, import_react_query7.useMutation)({
    mutationKey: ["Iam.InputValidationsAdmin.InputValidation_ByField_v3" /* InputValidation_ByField_v3 */],
    mutationFn,
    ...options
  });
};

// src/generated-admin/queries/LoginAllowlistAdmin.query.ts
var import_react_query8 = require("@tanstack/react-query");

// src/generated-admin/LoginAllowlistAdminApi.ts
var import_sdk16 = require("@accelbyte/sdk");

// src/generated-admin/endpoints/LoginAllowlistAdmin$.ts
var import_sdk15 = require("@accelbyte/sdk");

// src/generated-definitions/LoginAllowlistResponse.ts
var import_zod50 = require("zod");
var LoginAllowlistResponse = import_zod50.z.object({ active: import_zod50.z.boolean(), namespace: import_zod50.z.string(), roleIds: import_zod50.z.array(import_zod50.z.string()) });

// src/generated-admin/endpoints/LoginAllowlistAdmin$.ts
var LoginAllowlistAdmin$ = class {
  // @ts-ignore
  // prettier-ignore
  constructor(axiosInstance, namespace, useSchemaValidation = true) {
    this.axiosInstance = axiosInstance;
    this.namespace = namespace;
    this.useSchemaValidation = useSchemaValidation;
  }
  /**
   * This endpoint return login allowlist configuration from specific namespace.
   */
  getLoginAllowlist_v3() {
    const params = {};
    const url = "/iam/v3/admin/namespaces/{namespace}/loginAllowlist".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.get(url, { params });
    return import_sdk15.Validate.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      LoginAllowlistResponse,
      "LoginAllowlistResponse"
    );
  }
  /**
   * This endpoint update login allowlist configuration from specific game namespace. roleIds: are list of role that allowed to login Note: only accept game namespace
   */
  updateLoginAllowlist_v3(data) {
    const params = {};
    const url = "/iam/v3/admin/namespaces/{namespace}/loginAllowlist".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.put(url, data, { params });
    return import_sdk15.Validate.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      LoginAllowlistResponse,
      "LoginAllowlistResponse"
    );
  }
};

// src/generated-admin/LoginAllowlistAdminApi.ts
function LoginAllowlistAdminApi(sdk, args) {
  const sdkAssembly = sdk.assembly();
  const namespace = args?.coreConfig?.namespace ?? sdkAssembly.coreConfig.namespace;
  const useSchemaValidation = args?.coreConfig?.useSchemaValidation ?? sdkAssembly.coreConfig.useSchemaValidation;
  let axiosInstance = sdkAssembly.axiosInstance;
  const requestConfigOverrides = args?.axiosConfig?.request;
  const baseURLOverride = args?.coreConfig?.baseURL;
  const interceptorsOverride = args?.axiosConfig?.interceptors ?? [];
  if (requestConfigOverrides || baseURLOverride || interceptorsOverride.length > 0) {
    const requestConfig = import_sdk16.ApiUtils.mergeAxiosConfigs(sdkAssembly.axiosInstance.defaults, {
      ...baseURLOverride ? { baseURL: baseURLOverride } : {},
      ...requestConfigOverrides
    });
    axiosInstance = import_sdk16.Network.create(requestConfig);
    for (const interceptor of interceptorsOverride) {
      if (interceptor.type === "request") {
        axiosInstance.interceptors.request.use(interceptor.onRequest, interceptor.onError);
      }
      if (interceptor.type === "response") {
        axiosInstance.interceptors.response.use(interceptor.onSuccess, interceptor.onError);
      }
    }
  }
  async function getLoginAllowlist_v3() {
    const $ = new LoginAllowlistAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getLoginAllowlist_v3();
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function updateLoginAllowlist_v3(data) {
    const $ = new LoginAllowlistAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.updateLoginAllowlist_v3(data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  return {
    /**
     * This endpoint return login allowlist configuration from specific namespace.
     */
    getLoginAllowlist_v3,
    /**
     * This endpoint update login allowlist configuration from specific game namespace. roleIds: are list of role that allowed to login Note: only accept game namespace
     */
    updateLoginAllowlist_v3
  };
}

// src/generated-admin/queries/LoginAllowlistAdmin.query.ts
var Key_LoginAllowlistAdmin = /* @__PURE__ */ ((Key_LoginAllowlistAdmin2) => {
  Key_LoginAllowlistAdmin2["LoginAllowlist_v3"] = "Iam.LoginAllowlistAdmin.LoginAllowlist_v3";
  return Key_LoginAllowlistAdmin2;
})(Key_LoginAllowlistAdmin || {});
var useLoginAllowlistAdminApi_GetLoginAllowlist_v3 = (sdk, input, options, callback) => {
  const queryFn = (sdk2, input2) => async () => {
    const response = await LoginAllowlistAdminApi(sdk2, {
      coreConfig: input2.coreConfig,
      axiosConfig: input2.axiosConfig
    }).getLoginAllowlist_v3();
    callback && callback(response);
    return response.data;
  };
  return (0, import_react_query8.useQuery)({
    queryKey: ["Iam.LoginAllowlistAdmin.LoginAllowlist_v3" /* LoginAllowlist_v3 */, input],
    queryFn: queryFn(sdk, input),
    ...options
  });
};
var useLoginAllowlistAdminApi_UpdateLoginAllowlistMutation_v3 = (sdk, options, callback) => {
  const mutationFn = async (input) => {
    const response = await LoginAllowlistAdminApi(sdk, {
      coreConfig: input.coreConfig,
      axiosConfig: input.axiosConfig
    }).updateLoginAllowlist_v3(input.data);
    callback && callback(response.data);
    return response.data;
  };
  return (0, import_react_query8.useMutation)({
    mutationKey: ["Iam.LoginAllowlistAdmin.LoginAllowlist_v3" /* LoginAllowlist_v3 */],
    mutationFn,
    ...options
  });
};

// src/generated-admin/queries/OAuth20Admin.query.ts
var import_react_query9 = require("@tanstack/react-query");

// src/generated-admin/OAuth20AdminApi.ts
var import_sdk18 = require("@accelbyte/sdk");

// src/generated-admin/endpoints/OAuth20Admin$.ts
var import_sdk17 = require("@accelbyte/sdk");
var import_zod52 = require("zod");

// src/generated-definitions/TokenThirdPartyResponse.ts
var import_zod51 = require("zod");
var TokenThirdPartyResponse = import_zod51.z.object({
  platformUserId: import_zod51.z.string().nullish(),
  platform_token: import_zod51.z.string(),
  platform_token_expires_at: import_zod51.z.number().int().nullish(),
  sand_box_id: import_zod51.z.string().nullish()
});

// src/generated-admin/endpoints/OAuth20Admin$.ts
var OAuth20Admin$ = class {
  // @ts-ignore
  // prettier-ignore
  constructor(axiosInstance, namespace, useSchemaValidation = true) {
    this.axiosInstance = axiosInstance;
    this.namespace = namespace;
    this.useSchemaValidation = useSchemaValidation;
  }
  /**
   * This endpoint revokes all access tokens and refresh tokens a user has prior the revocation time. This endpoint requires authorized requests header with valid access token. It is a convenient feature for the developer (or admin) who wanted to revokes all user&#39;s access tokens and refresh tokens generated before some period of time. action code : 10707
   */
  updateRevokeOauth_ByUserId_v3(userId, queryParams) {
    const params = { ...queryParams };
    const url = "/iam/v3/oauth/admin/namespaces/{namespace}/users/{userId}/revoke".replace("{namespace}", this.namespace).replace("{userId}", userId);
    const resultPromise = this.axiosInstance.post(url, null, { params });
    return import_sdk17.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, import_zod52.z.unknown(), "z.unknown()");
  }
  /**
   * Admin Retrieve User Third Party Platform Token This endpoint used for retrieving third party platform token for user that login using third party, if user have not link requested platform in game namespace, will try to retrieving third party platform token from publisher namespace. Passing platform group name or it&#39;s member will return same access token that can be used across the platform members. If platformUserId provided, IAM will prefer to get platform token by platform user id. Notes: The third party platform and platform group covered for this is: - (psn) ps4web - (psn) ps4 - (psn) ps5 - epicgames - twitch - awscognito - amazon - eaorigin - snapchat - twitch - live
   */
  getPlatformTokenOauth_ByUserId_ByPlatformId_v3(userId, platformId, queryParams) {
    const params = { ...queryParams };
    const url = "/iam/v3/oauth/admin/namespaces/{namespace}/users/{userId}/platforms/{platformId}/platformToken".replace("{namespace}", this.namespace).replace("{userId}", userId).replace("{platformId}", platformId);
    const resultPromise = this.axiosInstance.get(url, { params });
    return import_sdk17.Validate.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      TokenThirdPartyResponse,
      "TokenThirdPartyResponse"
    );
  }
};

// src/generated-admin/OAuth20AdminApi.ts
function OAuth20AdminApi(sdk, args) {
  const sdkAssembly = sdk.assembly();
  const namespace = args?.coreConfig?.namespace ?? sdkAssembly.coreConfig.namespace;
  const useSchemaValidation = args?.coreConfig?.useSchemaValidation ?? sdkAssembly.coreConfig.useSchemaValidation;
  let axiosInstance = sdkAssembly.axiosInstance;
  const requestConfigOverrides = args?.axiosConfig?.request;
  const baseURLOverride = args?.coreConfig?.baseURL;
  const interceptorsOverride = args?.axiosConfig?.interceptors ?? [];
  if (requestConfigOverrides || baseURLOverride || interceptorsOverride.length > 0) {
    const requestConfig = import_sdk18.ApiUtils.mergeAxiosConfigs(sdkAssembly.axiosInstance.defaults, {
      ...baseURLOverride ? { baseURL: baseURLOverride } : {},
      ...requestConfigOverrides
    });
    axiosInstance = import_sdk18.Network.create(requestConfig);
    for (const interceptor of interceptorsOverride) {
      if (interceptor.type === "request") {
        axiosInstance.interceptors.request.use(interceptor.onRequest, interceptor.onError);
      }
      if (interceptor.type === "response") {
        axiosInstance.interceptors.response.use(interceptor.onSuccess, interceptor.onError);
      }
    }
  }
  async function updateRevokeOauth_ByUserId_v3(userId, queryParams) {
    const $ = new OAuth20Admin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.updateRevokeOauth_ByUserId_v3(userId, queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getPlatformTokenOauth_ByUserId_ByPlatformId_v3(userId, platformId, queryParams) {
    const $ = new OAuth20Admin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getPlatformTokenOauth_ByUserId_ByPlatformId_v3(userId, platformId, queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  return {
    /**
     * This endpoint revokes all access tokens and refresh tokens a user has prior the revocation time. This endpoint requires authorized requests header with valid access token. It is a convenient feature for the developer (or admin) who wanted to revokes all user&#39;s access tokens and refresh tokens generated before some period of time. action code : 10707
     */
    updateRevokeOauth_ByUserId_v3,
    /**
     * Admin Retrieve User Third Party Platform Token This endpoint used for retrieving third party platform token for user that login using third party, if user have not link requested platform in game namespace, will try to retrieving third party platform token from publisher namespace. Passing platform group name or it&#39;s member will return same access token that can be used across the platform members. If platformUserId provided, IAM will prefer to get platform token by platform user id. Notes: The third party platform and platform group covered for this is: - (psn) ps4web - (psn) ps4 - (psn) ps5 - epicgames - twitch - awscognito - amazon - eaorigin - snapchat - twitch - live
     */
    getPlatformTokenOauth_ByUserId_ByPlatformId_v3
  };
}

// src/generated-admin/queries/OAuth20Admin.query.ts
var Key_OAuth20Admin = /* @__PURE__ */ ((Key_OAuth20Admin2) => {
  Key_OAuth20Admin2["RevokeOauth_ByUserId_v3"] = "Iam.OAuth20Admin.RevokeOauth_ByUserId_v3";
  Key_OAuth20Admin2["PlatformTokenOauth_ByUserId_ByPlatformId_v3"] = "Iam.OAuth20Admin.PlatformTokenOauth_ByUserId_ByPlatformId_v3";
  return Key_OAuth20Admin2;
})(Key_OAuth20Admin || {});
var useOAuth20AdminApi_UpdateRevokeOauth_ByUserIdMutation_v3 = (sdk, options, callback) => {
  const mutationFn = async (input) => {
    const response = await OAuth20AdminApi(sdk, {
      coreConfig: input.coreConfig,
      axiosConfig: input.axiosConfig
    }).updateRevokeOauth_ByUserId_v3(input.userId, input.queryParams);
    callback && callback(response.data);
    return response.data;
  };
  return (0, import_react_query9.useMutation)({
    mutationKey: ["Iam.OAuth20Admin.RevokeOauth_ByUserId_v3" /* RevokeOauth_ByUserId_v3 */],
    mutationFn,
    ...options
  });
};
var useOAuth20AdminApi_GetPlatformTokenOauth_ByUserId_ByPlatformId_v3 = (sdk, input, options, callback) => {
  const queryFn = (sdk2, input2) => async () => {
    const response = await OAuth20AdminApi(sdk2, {
      coreConfig: input2.coreConfig,
      axiosConfig: input2.axiosConfig
    }).getPlatformTokenOauth_ByUserId_ByPlatformId_v3(input2.userId, input2.platformId, input2.queryParams);
    callback && callback(response);
    return response.data;
  };
  return (0, import_react_query9.useQuery)({
    queryKey: ["Iam.OAuth20Admin.PlatformTokenOauth_ByUserId_ByPlatformId_v3" /* PlatformTokenOauth_ByUserId_ByPlatformId_v3 */, input],
    queryFn: queryFn(sdk, input),
    ...options
  });
};

// src/generated-admin/queries/OverrideRoleConfigV3Admin.query.ts
var import_react_query10 = require("@tanstack/react-query");

// src/generated-admin/OverrideRoleConfigV3AdminApi.ts
var import_sdk20 = require("@accelbyte/sdk");

// src/generated-admin/endpoints/OverrideRoleConfigV3Admin$.ts
var import_sdk19 = require("@accelbyte/sdk");

// src/generated-definitions/RoleOverrideResponse.ts
var import_zod55 = require("zod");

// src/generated-definitions/OverrideRolePermission.ts
var import_zod53 = require("zod");
var OverrideRolePermission = import_zod53.z.object({ actions: import_zod53.z.array(import_zod53.z.number().int()), resource: import_zod53.z.string() });

// src/generated-definitions/ReplaceRolePermission.ts
var import_zod54 = require("zod");
var ReplaceRolePermission = import_zod54.z.object({ replacement: OverrideRolePermission, target: import_zod54.z.string() });

// src/generated-definitions/RoleOverrideResponse.ts
var RoleOverrideResponse = import_zod55.z.object({
  active: import_zod55.z.boolean(),
  additions: import_zod55.z.array(OverrideRolePermission),
  createdAt: import_zod55.z.string().nullish(),
  exclusions: import_zod55.z.array(OverrideRolePermission),
  identity: import_zod55.z.string(),
  namespace: import_zod55.z.string(),
  overrides: import_zod55.z.array(OverrideRolePermission),
  replacements: import_zod55.z.array(ReplaceRolePermission),
  updatedAt: import_zod55.z.string().nullish()
});

// src/generated-definitions/RoleOverrideSourceResponse.ts
var import_zod56 = require("zod");
var RoleOverrideSourceResponse = import_zod56.z.object({ permissions: import_zod56.z.array(OverrideRolePermission) });

// src/generated-definitions/RolePermissionResponseV3.ts
var import_zod58 = require("zod");

// src/generated-definitions/Permission.ts
var import_zod57 = require("zod");
var Permission = import_zod57.z.object({ action: import_zod57.z.number().int(), resource: import_zod57.z.string() });

// src/generated-definitions/RolePermissionResponseV3.ts
var RolePermissionResponseV3 = import_zod58.z.object({ permissions: import_zod58.z.array(Permission) });

// src/generated-admin/endpoints/OverrideRoleConfigV3Admin$.ts
var OverrideRoleConfigV3Admin$ = class {
  // @ts-ignore
  // prettier-ignore
  constructor(axiosInstance, namespace, useSchemaValidation = true) {
    this.axiosInstance = axiosInstance;
    this.namespace = namespace;
    this.useSchemaValidation = useSchemaValidation;
  }
  /**
   * Get role override config. This API has upsert behavior, if there is no config yet, it will create a new one with inactive status.
   */
  getRoleoverride_v3(queryParams) {
    const params = { ...queryParams };
    const url = "/iam/v3/admin/namespaces/{namespace}/roleoverride".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.get(url, { params });
    return import_sdk19.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, RoleOverrideResponse, "RoleOverrideResponse");
  }
  /**
   * This API is for updating role override config. Note: This API has upsert behavior, if there is no config yet, it will create a new one first.
   */
  patchRoleoverride_v3(data, queryParams) {
    const params = { ...queryParams };
    const url = "/iam/v3/admin/namespaces/{namespace}/roleoverride".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.patch(url, data, { params });
    return import_sdk19.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, RoleOverrideResponse, "RoleOverrideResponse");
  }
  /**
   * Get role source permission set.
   */
  getRoleoverrideSource_v3(queryParams) {
    const params = { ...queryParams };
    const url = "/iam/v3/admin/namespaces/{namespace}/roleoverride/source".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.get(url, { params });
    return import_sdk19.Validate.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      RoleOverrideSourceResponse,
      "RoleOverrideSourceResponse"
    );
  }
  /**
   * Enable or disable the target role override feature in path namespace. Note: This API has upsert behavior, if there is no config yet, it will create a new one first.
   */
  patchRoleoverrideStatus_v3(data, queryParams) {
    const params = { ...queryParams };
    const url = "/iam/v3/admin/namespaces/{namespace}/roleoverride/status".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.patch(url, data, { params });
    return import_sdk19.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, RoleOverrideResponse, "RoleOverrideResponse");
  }
  /**
   * Get role namespace permission set.
   */
  getPermissions_ByRoleId_v3(roleId) {
    const params = {};
    const url = "/iam/v3/admin/namespaces/{namespace}/roleoverride/{roleId}/permissions".replace("{namespace}", this.namespace).replace("{roleId}", roleId);
    const resultPromise = this.axiosInstance.get(url, { params });
    return import_sdk19.Validate.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      RolePermissionResponseV3,
      "RolePermissionResponseV3"
    );
  }
};

// src/generated-admin/OverrideRoleConfigV3AdminApi.ts
function OverrideRoleConfigV3AdminApi(sdk, args) {
  const sdkAssembly = sdk.assembly();
  const namespace = args?.coreConfig?.namespace ?? sdkAssembly.coreConfig.namespace;
  const useSchemaValidation = args?.coreConfig?.useSchemaValidation ?? sdkAssembly.coreConfig.useSchemaValidation;
  let axiosInstance = sdkAssembly.axiosInstance;
  const requestConfigOverrides = args?.axiosConfig?.request;
  const baseURLOverride = args?.coreConfig?.baseURL;
  const interceptorsOverride = args?.axiosConfig?.interceptors ?? [];
  if (requestConfigOverrides || baseURLOverride || interceptorsOverride.length > 0) {
    const requestConfig = import_sdk20.ApiUtils.mergeAxiosConfigs(sdkAssembly.axiosInstance.defaults, {
      ...baseURLOverride ? { baseURL: baseURLOverride } : {},
      ...requestConfigOverrides
    });
    axiosInstance = import_sdk20.Network.create(requestConfig);
    for (const interceptor of interceptorsOverride) {
      if (interceptor.type === "request") {
        axiosInstance.interceptors.request.use(interceptor.onRequest, interceptor.onError);
      }
      if (interceptor.type === "response") {
        axiosInstance.interceptors.response.use(interceptor.onSuccess, interceptor.onError);
      }
    }
  }
  async function getRoleoverride_v3(queryParams) {
    const $ = new OverrideRoleConfigV3Admin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getRoleoverride_v3(queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function patchRoleoverride_v3(data, queryParams) {
    const $ = new OverrideRoleConfigV3Admin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.patchRoleoverride_v3(data, queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getRoleoverrideSource_v3(queryParams) {
    const $ = new OverrideRoleConfigV3Admin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getRoleoverrideSource_v3(queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function patchRoleoverrideStatus_v3(data, queryParams) {
    const $ = new OverrideRoleConfigV3Admin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.patchRoleoverrideStatus_v3(data, queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getPermissions_ByRoleId_v3(roleId) {
    const $ = new OverrideRoleConfigV3Admin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getPermissions_ByRoleId_v3(roleId);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  return {
    /**
     * Get role override config. This API has upsert behavior, if there is no config yet, it will create a new one with inactive status.
     */
    getRoleoverride_v3,
    /**
     * This API is for updating role override config. Note: This API has upsert behavior, if there is no config yet, it will create a new one first.
     */
    patchRoleoverride_v3,
    /**
     * Get role source permission set.
     */
    getRoleoverrideSource_v3,
    /**
     * Enable or disable the target role override feature in path namespace. Note: This API has upsert behavior, if there is no config yet, it will create a new one first.
     */
    patchRoleoverrideStatus_v3,
    /**
     * Get role namespace permission set.
     */
    getPermissions_ByRoleId_v3
  };
}

// src/generated-admin/queries/OverrideRoleConfigV3Admin.query.ts
var Key_OverrideRoleConfigV3Admin = /* @__PURE__ */ ((Key_OverrideRoleConfigV3Admin2) => {
  Key_OverrideRoleConfigV3Admin2["Roleoverride_v3"] = "Iam.OverrideRoleConfigV3Admin.Roleoverride_v3";
  Key_OverrideRoleConfigV3Admin2["RoleoverrideSource_v3"] = "Iam.OverrideRoleConfigV3Admin.RoleoverrideSource_v3";
  Key_OverrideRoleConfigV3Admin2["RoleoverrideStatus_v3"] = "Iam.OverrideRoleConfigV3Admin.RoleoverrideStatus_v3";
  Key_OverrideRoleConfigV3Admin2["Permissions_ByRoleId_v3"] = "Iam.OverrideRoleConfigV3Admin.Permissions_ByRoleId_v3";
  return Key_OverrideRoleConfigV3Admin2;
})(Key_OverrideRoleConfigV3Admin || {});
var useOverrideRoleConfigV3AdminApi_GetRoleoverride_v3 = (sdk, input, options, callback) => {
  const queryFn = (sdk2, input2) => async () => {
    const response = await OverrideRoleConfigV3AdminApi(sdk2, {
      coreConfig: input2.coreConfig,
      axiosConfig: input2.axiosConfig
    }).getRoleoverride_v3(input2.queryParams);
    callback && callback(response);
    return response.data;
  };
  return (0, import_react_query10.useQuery)({
    queryKey: ["Iam.OverrideRoleConfigV3Admin.Roleoverride_v3" /* Roleoverride_v3 */, input],
    queryFn: queryFn(sdk, input),
    ...options
  });
};
var useOverrideRoleConfigV3AdminApi_PatchRoleoverrideMutation_v3 = (sdk, options, callback) => {
  const mutationFn = async (input) => {
    const response = await OverrideRoleConfigV3AdminApi(sdk, {
      coreConfig: input.coreConfig,
      axiosConfig: input.axiosConfig
    }).patchRoleoverride_v3(input.data, input.queryParams);
    callback && callback(response.data);
    return response.data;
  };
  return (0, import_react_query10.useMutation)({
    mutationKey: ["Iam.OverrideRoleConfigV3Admin.Roleoverride_v3" /* Roleoverride_v3 */],
    mutationFn,
    ...options
  });
};
var useOverrideRoleConfigV3AdminApi_GetRoleoverrideSource_v3 = (sdk, input, options, callback) => {
  const queryFn = (sdk2, input2) => async () => {
    const response = await OverrideRoleConfigV3AdminApi(sdk2, {
      coreConfig: input2.coreConfig,
      axiosConfig: input2.axiosConfig
    }).getRoleoverrideSource_v3(input2.queryParams);
    callback && callback(response);
    return response.data;
  };
  return (0, import_react_query10.useQuery)({
    queryKey: ["Iam.OverrideRoleConfigV3Admin.RoleoverrideSource_v3" /* RoleoverrideSource_v3 */, input],
    queryFn: queryFn(sdk, input),
    ...options
  });
};
var useOverrideRoleConfigV3AdminApi_PatchRoleoverrideStatusMutation_v3 = (sdk, options, callback) => {
  const mutationFn = async (input) => {
    const response = await OverrideRoleConfigV3AdminApi(sdk, {
      coreConfig: input.coreConfig,
      axiosConfig: input.axiosConfig
    }).patchRoleoverrideStatus_v3(input.data, input.queryParams);
    callback && callback(response.data);
    return response.data;
  };
  return (0, import_react_query10.useMutation)({
    mutationKey: ["Iam.OverrideRoleConfigV3Admin.RoleoverrideStatus_v3" /* RoleoverrideStatus_v3 */],
    mutationFn,
    ...options
  });
};
var useOverrideRoleConfigV3AdminApi_GetPermissions_ByRoleId_v3 = (sdk, input, options, callback) => {
  const queryFn = (sdk2, input2) => async () => {
    const response = await OverrideRoleConfigV3AdminApi(sdk2, {
      coreConfig: input2.coreConfig,
      axiosConfig: input2.axiosConfig
    }).getPermissions_ByRoleId_v3(input2.roleId);
    callback && callback(response);
    return response.data;
  };
  return (0, import_react_query10.useQuery)({
    queryKey: ["Iam.OverrideRoleConfigV3Admin.Permissions_ByRoleId_v3" /* Permissions_ByRoleId_v3 */, input],
    queryFn: queryFn(sdk, input),
    ...options
  });
};

// src/generated-admin/queries/ProfileUpdateStrategyAdmin.query.ts
var import_react_query11 = require("@tanstack/react-query");

// src/generated-admin/ProfileUpdateStrategyAdminApi.ts
var import_sdk22 = require("@accelbyte/sdk");

// src/generated-admin/endpoints/ProfileUpdateStrategyAdmin$.ts
var import_sdk21 = require("@accelbyte/sdk");

// src/generated-definitions/GetProfileUpdateStrategyConfigResponse.ts
var import_zod61 = require("zod");

// src/generated-definitions/SimpleProfileUpdateStrategyConfigs.ts
var import_zod60 = require("zod");

// src/generated-definitions/ProfileUpdateConfig.ts
var import_zod59 = require("zod");
var ProfileUpdateConfig = import_zod59.z.object({ minimumAllowedInterval: import_zod59.z.number().int().nullish() });

// src/generated-definitions/SimpleProfileUpdateStrategyConfigs.ts
var SimpleProfileUpdateStrategyConfigs = import_zod60.z.object({
  config: ProfileUpdateConfig.nullish(),
  createdAt: import_zod60.z.string(),
  field: import_zod60.z.string(),
  type: import_zod60.z.string(),
  updatedAt: import_zod60.z.string()
});

// src/generated-definitions/GetProfileUpdateStrategyConfigResponse.ts
var GetProfileUpdateStrategyConfigResponse = import_zod61.z.object({ data: import_zod61.z.array(SimpleProfileUpdateStrategyConfigs) });

// src/generated-admin/endpoints/ProfileUpdateStrategyAdmin$.ts
var ProfileUpdateStrategyAdmin$ = class {
  // @ts-ignore
  // prettier-ignore
  constructor(axiosInstance, namespace, useSchemaValidation = true) {
    this.axiosInstance = axiosInstance;
    this.namespace = namespace;
    this.useSchemaValidation = useSchemaValidation;
  }
  /**
   * This API is for admin to get profile update strategy by namespace and field. Note: If the config is not found, this API will return a config with unlimited.
   */
  getProfileUpdateStrategies_v3(queryParams) {
    const params = { ...queryParams };
    const url = "/iam/v3/admin/namespaces/{namespace}/profileUpdateStrategies".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.get(url, { params });
    return import_sdk21.Validate.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      GetProfileUpdateStrategyConfigResponse,
      "GetProfileUpdateStrategyConfigResponse"
    );
  }
  /**
   * This API includes upsert behavior. Note: 1. field &#39;config&#39;&#39; in request body will only work when type is limited
   */
  updateProfileUpdateStrategy_v3(data, queryParams) {
    const params = { ...queryParams };
    const url = "/iam/v3/admin/namespaces/{namespace}/profileUpdateStrategies".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.put(url, data, { params });
    return import_sdk21.Validate.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      SimpleProfileUpdateStrategyConfigs,
      "SimpleProfileUpdateStrategyConfigs"
    );
  }
};

// src/generated-admin/ProfileUpdateStrategyAdminApi.ts
function ProfileUpdateStrategyAdminApi(sdk, args) {
  const sdkAssembly = sdk.assembly();
  const namespace = args?.coreConfig?.namespace ?? sdkAssembly.coreConfig.namespace;
  const useSchemaValidation = args?.coreConfig?.useSchemaValidation ?? sdkAssembly.coreConfig.useSchemaValidation;
  let axiosInstance = sdkAssembly.axiosInstance;
  const requestConfigOverrides = args?.axiosConfig?.request;
  const baseURLOverride = args?.coreConfig?.baseURL;
  const interceptorsOverride = args?.axiosConfig?.interceptors ?? [];
  if (requestConfigOverrides || baseURLOverride || interceptorsOverride.length > 0) {
    const requestConfig = import_sdk22.ApiUtils.mergeAxiosConfigs(sdkAssembly.axiosInstance.defaults, {
      ...baseURLOverride ? { baseURL: baseURLOverride } : {},
      ...requestConfigOverrides
    });
    axiosInstance = import_sdk22.Network.create(requestConfig);
    for (const interceptor of interceptorsOverride) {
      if (interceptor.type === "request") {
        axiosInstance.interceptors.request.use(interceptor.onRequest, interceptor.onError);
      }
      if (interceptor.type === "response") {
        axiosInstance.interceptors.response.use(interceptor.onSuccess, interceptor.onError);
      }
    }
  }
  async function getProfileUpdateStrategies_v3(queryParams) {
    const $ = new ProfileUpdateStrategyAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getProfileUpdateStrategies_v3(queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function updateProfileUpdateStrategy_v3(data, queryParams) {
    const $ = new ProfileUpdateStrategyAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.updateProfileUpdateStrategy_v3(data, queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  return {
    /**
     * This API is for admin to get profile update strategy by namespace and field. Note: If the config is not found, this API will return a config with unlimited.
     */
    getProfileUpdateStrategies_v3,
    /**
     * This API includes upsert behavior. Note: 1. field &#39;config&#39;&#39; in request body will only work when type is limited
     */
    updateProfileUpdateStrategy_v3
  };
}

// src/generated-admin/queries/ProfileUpdateStrategyAdmin.query.ts
var Key_ProfileUpdateStrategyAdmin = /* @__PURE__ */ ((Key_ProfileUpdateStrategyAdmin2) => {
  Key_ProfileUpdateStrategyAdmin2["ProfileUpdateStrategies_v3"] = "Iam.ProfileUpdateStrategyAdmin.ProfileUpdateStrategies_v3";
  Key_ProfileUpdateStrategyAdmin2["ProfileUpdateStrategy_v3"] = "Iam.ProfileUpdateStrategyAdmin.ProfileUpdateStrategy_v3";
  return Key_ProfileUpdateStrategyAdmin2;
})(Key_ProfileUpdateStrategyAdmin || {});
var useProfileUpdateStrategyAdminApi_GetProfileUpdateStrategies_v3 = (sdk, input, options, callback) => {
  const queryFn = (sdk2, input2) => async () => {
    const response = await ProfileUpdateStrategyAdminApi(sdk2, {
      coreConfig: input2.coreConfig,
      axiosConfig: input2.axiosConfig
    }).getProfileUpdateStrategies_v3(input2.queryParams);
    callback && callback(response);
    return response.data;
  };
  return (0, import_react_query11.useQuery)({
    queryKey: ["Iam.ProfileUpdateStrategyAdmin.ProfileUpdateStrategies_v3" /* ProfileUpdateStrategies_v3 */, input],
    queryFn: queryFn(sdk, input),
    ...options
  });
};
var useProfileUpdateStrategyAdminApi_UpdateProfileUpdateStrategyMutation_v3 = (sdk, options, callback) => {
  const mutationFn = async (input) => {
    const response = await ProfileUpdateStrategyAdminApi(sdk, {
      coreConfig: input.coreConfig,
      axiosConfig: input.axiosConfig
    }).updateProfileUpdateStrategy_v3(input.data, input.queryParams);
    callback && callback(response.data);
    return response.data;
  };
  return (0, import_react_query11.useMutation)({
    mutationKey: ["Iam.ProfileUpdateStrategyAdmin.ProfileUpdateStrategy_v3" /* ProfileUpdateStrategy_v3 */],
    mutationFn,
    ...options
  });
};

// src/generated-admin/queries/RolesAdmin.query.ts
var import_react_query12 = require("@tanstack/react-query");

// src/generated-admin/RolesAdminApi.ts
var import_sdk24 = require("@accelbyte/sdk");

// src/generated-admin/endpoints/RolesAdmin$.ts
var import_sdk23 = require("@accelbyte/sdk");
var import_zod75 = require("zod");

// src/generated-definitions/AssignedUserV4Response.ts
var import_zod62 = require("zod");
var AssignedUserV4Response = import_zod62.z.object({
  assignedNamespaces: import_zod62.z.array(import_zod62.z.string()),
  displayName: import_zod62.z.string(),
  email: import_zod62.z.string(),
  roleId: import_zod62.z.string(),
  userId: import_zod62.z.string()
});

// src/generated-definitions/ListAssignedUsersV4Response.ts
var import_zod63 = require("zod");
var ListAssignedUsersV4Response = import_zod63.z.object({ data: import_zod63.z.array(AssignedUserV4Response), paging: PaginationV3 });

// src/generated-definitions/ListRoleV4Response.ts
var import_zod65 = require("zod");

// src/generated-definitions/RoleV4Response.ts
var import_zod64 = require("zod");
var RoleV4Response = import_zod64.z.object({
  adminRole: import_zod64.z.boolean(),
  isWildcard: import_zod64.z.boolean(),
  permissions: import_zod64.z.array(PermissionV3),
  roleId: import_zod64.z.string(),
  roleName: import_zod64.z.string()
});

// src/generated-definitions/ListRoleV4Response.ts
var ListRoleV4Response = import_zod65.z.object({ data: import_zod65.z.array(RoleV4Response), paging: PaginationV3 });

// src/generated-definitions/RoleAdminStatusResponseV3.ts
var import_zod66 = require("zod");
var RoleAdminStatusResponseV3 = import_zod66.z.object({ adminRole: import_zod66.z.boolean() });

// src/generated-definitions/RoleManagersResponsesV3.ts
var import_zod68 = require("zod");

// src/generated-definitions/RoleManagerV3.ts
var import_zod67 = require("zod");
var RoleManagerV3 = import_zod67.z.object({ displayName: import_zod67.z.string(), namespace: import_zod67.z.string(), userId: import_zod67.z.string() });

// src/generated-definitions/RoleManagersResponsesV3.ts
var RoleManagersResponsesV3 = import_zod68.z.object({ data: import_zod68.z.array(RoleManagerV3), paging: PaginationV3 });

// src/generated-definitions/RoleMembersResponseV3.ts
var import_zod70 = require("zod");

// src/generated-definitions/RoleMemberV3.ts
var import_zod69 = require("zod");
var RoleMemberV3 = import_zod69.z.object({ displayName: import_zod69.z.string(), namespace: import_zod69.z.string(), userId: import_zod69.z.string() });

// src/generated-definitions/RoleMembersResponseV3.ts
var RoleMembersResponseV3 = import_zod70.z.object({ data: import_zod70.z.array(RoleMemberV3), paging: PaginationV3 });

// src/generated-definitions/RoleResponseV3.ts
var import_zod71 = require("zod");
var RoleResponseV3 = import_zod71.z.object({
  adminRole: import_zod71.z.boolean(),
  isWildcard: import_zod71.z.boolean(),
  permissions: import_zod71.z.array(PermissionV3),
  roleId: import_zod71.z.string(),
  roleName: import_zod71.z.string()
});

// src/generated-definitions/RoleResponseWithManagersAndPaginationV3.ts
var import_zod73 = require("zod");

// src/generated-definitions/RoleResponseWithManagersV3.ts
var import_zod72 = require("zod");
var RoleResponseWithManagersV3 = import_zod72.z.object({
  adminRole: import_zod72.z.boolean(),
  isWildcard: import_zod72.z.boolean(),
  managers: import_zod72.z.array(RoleManagerV3),
  permissions: import_zod72.z.array(PermissionV3),
  roleId: import_zod72.z.string(),
  roleName: import_zod72.z.string()
});

// src/generated-definitions/RoleResponseWithManagersAndPaginationV3.ts
var RoleResponseWithManagersAndPaginationV3 = import_zod73.z.object({ data: import_zod73.z.array(RoleResponseWithManagersV3), paging: PaginationV3 });

// src/generated-definitions/RoleV3.ts
var import_zod74 = require("zod");
var RoleV3 = import_zod74.z.object({
  adminRole: import_zod74.z.boolean(),
  isWildcard: import_zod74.z.boolean(),
  managers: import_zod74.z.array(RoleManagerV3),
  members: import_zod74.z.array(RoleMemberV3),
  permissions: import_zod74.z.array(PermissionV3),
  roleId: import_zod74.z.string(),
  roleName: import_zod74.z.string()
});

// src/generated-admin/endpoints/RolesAdmin$.ts
var RolesAdmin$ = class {
  // @ts-ignore
  // prettier-ignore
  constructor(axiosInstance, namespace, useSchemaValidation = true) {
    this.axiosInstance = axiosInstance;
    this.namespace = namespace;
    this.useSchemaValidation = useSchemaValidation;
  }
  /**
   * action code: 10414
   */
  getRoles_v3(queryParams) {
    const params = { ...queryParams };
    const url = "/iam/v3/admin/roles";
    const resultPromise = this.axiosInstance.get(url, { params });
    return import_sdk23.Validate.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      RoleResponseWithManagersAndPaginationV3,
      "RoleResponseWithManagersAndPaginationV3"
    );
  }
  /**
   * Create role request body: - roleName: specify role name, alphanumeric, cannot have special character (required) - permissions: specify the permission that this role have - managers: specify list of user that will act as the managers of this role - members: specify list of user that will act as the members of this role - adminRole: specify if role is for admin user (default false) - isWildcard: specify if role can be assigned to wildcard (*) namespace (default false) - deletable: specify if role can be deleted or not (default true) action code: 10401
   */
  createRole_v3(data) {
    const params = {};
    const url = "/iam/v3/admin/roles";
    const resultPromise = this.axiosInstance.post(url, data, { params });
    return import_sdk23.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, RoleV3, "RoleV3");
  }
  /**
   * action code: 10414
   */
  getRoles_v4(queryParams) {
    const params = { ...queryParams };
    const url = "/iam/v4/admin/roles";
    const resultPromise = this.axiosInstance.get(url, { params });
    return import_sdk23.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, ListRoleV4Response, "ListRoleV4Response");
  }
  /**
   * Create role request body: - roleName: specify role name, alphanumeric, cannot have special character (required) - adminRole: specify if role is for admin user (default false) - isWildcard: specify if role can be assigned to wildcard (*) namespace (default false) - deletable: specify if role can be deleted (default true) action code: 10401
   */
  createRole_v4(data) {
    const params = {};
    const url = "/iam/v4/admin/roles";
    const resultPromise = this.axiosInstance.post(url, data, { params });
    return import_sdk23.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, RoleV4Response, "RoleV4Response");
  }
  /**
   * action code: 10403
   */
  deleteRole_ByRoleId_v3(roleId) {
    const params = {};
    const url = "/iam/v3/admin/roles/{roleId}".replace("{roleId}", roleId);
    const resultPromise = this.axiosInstance.delete(url, { params });
    return import_sdk23.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, import_zod75.z.unknown(), "z.unknown()");
  }
  /**
   * action code: 10419
   */
  getRole_ByRoleId_v3(roleId) {
    const params = {};
    const url = "/iam/v3/admin/roles/{roleId}".replace("{roleId}", roleId);
    const resultPromise = this.axiosInstance.get(url, { params });
    return import_sdk23.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, RoleResponseV3, "RoleResponseV3");
  }
  /**
   * Update role request body: - roleName: specify role name, alphanumeric, cannot have special character (required) - isWildcard: specify if role can be assigned to wildcard (*) namespace (default false) - deletable: specify if role can be deleted or not (optional) action code: 10402
   */
  patchRole_ByRoleId_v3(roleId, data) {
    const params = {};
    const url = "/iam/v3/admin/roles/{roleId}".replace("{roleId}", roleId);
    const resultPromise = this.axiosInstance.patch(url, data, { params });
    return import_sdk23.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, RoleResponseV3, "RoleResponseV3");
  }
  /**
   * Removes role ID from user&#39;s Roles and NamespaceRoles before deleting the role. action code: 10403
   */
  deleteRole_ByRoleId_v4(roleId) {
    const params = {};
    const url = "/iam/v4/admin/roles/{roleId}".replace("{roleId}", roleId);
    const resultPromise = this.axiosInstance.delete(url, { params });
    return import_sdk23.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, import_zod75.z.unknown(), "z.unknown()");
  }
  /**
   * action code: 10419
   */
  getRole_ByRoleId_v4(roleId) {
    const params = {};
    const url = "/iam/v4/admin/roles/{roleId}".replace("{roleId}", roleId);
    const resultPromise = this.axiosInstance.get(url, { params });
    return import_sdk23.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, RoleV4Response, "RoleV4Response");
  }
  /**
   * Update role request body: - roleName: specify role name, alphanumeric, cannot have special character (required) - adminRole: specify if role is for admin user (default false) - isWildcard: specify if role can be assigned to wildcard (*) namespace (default false) - deletable: specify if role can be deleted (optional) action code: 10402
   */
  patchRole_ByRoleId_v4(roleId, data) {
    const params = {};
    const url = "/iam/v4/admin/roles/{roleId}".replace("{roleId}", roleId);
    const resultPromise = this.axiosInstance.patch(url, data, { params });
    return import_sdk23.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, RoleV4Response, "RoleV4Response");
  }
  /**
   * code: 10413
   */
  deleteAdmin_ByRoleId_v3(roleId) {
    const params = {};
    const url = "/iam/v3/admin/roles/{roleId}/admin".replace("{roleId}", roleId);
    const resultPromise = this.axiosInstance.delete(url, { params });
    return import_sdk23.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, import_zod75.z.unknown(), "z.unknown()");
  }
  /**
   * Admin roles has its members listed in the role. action code: 10420
   */
  getAdmin_ByRoleId_v3(roleId) {
    const params = {};
    const url = "/iam/v3/admin/roles/{roleId}/admin".replace("{roleId}", roleId);
    const resultPromise = this.axiosInstance.get(url, { params });
    return import_sdk23.Validate.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      RoleAdminStatusResponseV3,
      "RoleAdminStatusResponseV3"
    );
  }
  /**
   * Admin roles has its members listed in the role. Role can be set as admin role only when it has at least 1 manager. action code: 10412
   */
  updateAdmin_ByRoleId_v3(roleId) {
    const params = {};
    const url = "/iam/v3/admin/roles/{roleId}/admin".replace("{roleId}", roleId);
    const resultPromise = this.axiosInstance.post(url, null, { params });
    return import_sdk23.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, import_zod75.z.unknown(), "z.unknown()");
  }
  /**
   * Current implementation will revoke user from role in all assigned namespaces. Parameters: - userId: string (required) - namespace: string (user’s namespace) (required) action code: 10411
   */
  deleteUser_ByRoleId_v4(roleId, data) {
    const params = {};
    const url = "/iam/v4/admin/roles/{roleId}/users".replace("{roleId}", roleId);
    const resultPromise = this.axiosInstance.delete(url, { data, params });
    return import_sdk23.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, import_zod75.z.unknown(), "z.unknown()");
  }
  /**
   * Query all users that has the specified role. action code: 10416
   */
  getUsers_ByRoleId_v4(roleId, queryParams) {
    const params = { ...queryParams };
    const url = "/iam/v4/admin/roles/{roleId}/users".replace("{roleId}", roleId);
    const resultPromise = this.axiosInstance.get(url, { params });
    return import_sdk23.Validate.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      ListAssignedUsersV4Response,
      "ListAssignedUsersV4Response"
    );
  }
  /**
   * Parameters: - **userId**: string (required) - **namespace**: string (user’s namespace) (required) - **assignedNamespaces**: array of string (namespaces to be assigned on role) (required) action code: 10410
   */
  updateUser_ByRoleId_v4(roleId, data) {
    const params = {};
    const url = "/iam/v4/admin/roles/{roleId}/users".replace("{roleId}", roleId);
    const resultPromise = this.axiosInstance.post(url, data, { params });
    return import_sdk23.Validate.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      AssignedUserV4Response,
      "AssignedUserV4Response"
    );
  }
  /**
   * @deprecated
   * Admin roles has its members listed in the role. Role can only be assigned to other users by the role&#39;s manager. action code: 10411 Deprecate: Suggest to use this: AdminRevokeUserFromRoleV4
   */
  deleteMember_ByRoleId_v3(roleId, data) {
    const params = {};
    const url = "/iam/v3/admin/roles/{roleId}/members".replace("{roleId}", roleId);
    const resultPromise = this.axiosInstance.delete(url, { data, params });
    return import_sdk23.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, import_zod75.z.unknown(), "z.unknown()");
  }
  /**
   * Admin roles has its members listed in the role. action code: 10416
   */
  getMembers_ByRoleId_v3(roleId, queryParams) {
    const params = { ...queryParams };
    const url = "/iam/v3/admin/roles/{roleId}/members".replace("{roleId}", roleId);
    const resultPromise = this.axiosInstance.get(url, { params });
    return import_sdk23.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, RoleMembersResponseV3, "RoleMembersResponseV3");
  }
  /**
   * Admin roles has its members listed in the role. Role can only be assigned to other users by the role&#39;s manager. action code: 10410
   */
  updateMember_ByRoleId_v3(roleId, data) {
    const params = {};
    const url = "/iam/v3/admin/roles/{roleId}/members".replace("{roleId}", roleId);
    const resultPromise = this.axiosInstance.post(url, data, { params });
    return import_sdk23.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, import_zod75.z.unknown(), "z.unknown()");
  }
  /**
   * Role can only be assigned to other users by the role&#39;s manager. action code: 10409
   */
  deleteManager_ByRoleId_v3(roleId, data) {
    const params = {};
    const url = "/iam/v3/admin/roles/{roleId}/managers".replace("{roleId}", roleId);
    const resultPromise = this.axiosInstance.delete(url, { data, params });
    return import_sdk23.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, import_zod75.z.unknown(), "z.unknown()");
  }
  /**
   * Role can only be assigned to other users by the role&#39;s manager. action code: 10415
   */
  getManagers_ByRoleId_v3(roleId, queryParams) {
    const params = { ...queryParams };
    const url = "/iam/v3/admin/roles/{roleId}/managers".replace("{roleId}", roleId);
    const resultPromise = this.axiosInstance.get(url, { params });
    return import_sdk23.Validate.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      RoleManagersResponsesV3,
      "RoleManagersResponsesV3"
    );
  }
  /**
   * Role can only be assigned to other users by the role&#39;s manager. action code: 10408
   */
  updateManager_ByRoleId_v3(roleId, data) {
    const params = {};
    const url = "/iam/v3/admin/roles/{roleId}/managers".replace("{roleId}", roleId);
    const resultPromise = this.axiosInstance.post(url, data, { params });
    return import_sdk23.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, import_zod75.z.unknown(), "z.unknown()");
  }
  deletePermission_ByRoleId_v3(roleId, data) {
    const params = {};
    const url = "/iam/v3/admin/roles/{roleId}/permissions".replace("{roleId}", roleId);
    const resultPromise = this.axiosInstance.delete(url, { data, params });
    return import_sdk23.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, import_zod75.z.unknown(), "z.unknown()");
  }
  /**
   * This endpoint will ATTACH permission(s) into the role action code: 10404 Schedule contains cron string or date range (both are UTC, also in cron syntax) to indicate when a permission and action are in effect. Both schedule types accepts quartz compatible cron syntax e.g. * * * * * * *. In ranged schedule, first element will be start date, and second one will be end date If schedule is set, the scheduled action must be valid too, that is between 1 to 15, inclusive Syntax reference Fields: 1. Seconds: 0-59 * / , - 1. Minutes: 0-59 * / , - 1. Hours: 0-23 * / , - 1. Day of month: 1-31 * / , - L W 1. Month: 1-12 JAN-DEC * / , - 1. Day of week: 0-6 SUN-SAT * / , - L # 1. Year: 1970-2099 * / , - Special characters: 1. *: all values in the fields, e.g. * in seconds fields indicates every second 1. /: increments of ranges, e.g. 3-59/15 in the minute field indicate the third minute of the hour and every 15 minutes thereafter 1. ,: separate items of a list, e.g. MON,WED,FRI in day of week 1. -: range, e.g. 2010-2018 indicates every year between 2010 and 2018, inclusive 1. L: last, e.g. When used in the day-of-week field, it allows you to specify constructs such as &#34;the last Friday&#34; (5L) of a given month. In the day-of-month field, it specifies the last day of the month. 1. W: business day, e.g. if you were to specify 15W as the value for the day-of-month field, the meaning is: &#34;the nearest business day to the 15th of the month.&#34; 1. #: must be followed by a number between one and five. It allows you to specify constructs such as &#34;the second Friday&#34; of a given month.
   */
  updatePermission_ByRoleId_v3(roleId, data) {
    const params = {};
    const url = "/iam/v3/admin/roles/{roleId}/permissions".replace("{roleId}", roleId);
    const resultPromise = this.axiosInstance.post(url, data, { params });
    return import_sdk23.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, import_zod75.z.unknown(), "z.unknown()");
  }
  /**
   * This endpoint will REPLACE role&#39;s permissions with the ones defined in body action code: 10405 Schedule contains cron string or date range (both are UTC, also in cron syntax) to indicate when a permission and action are in effect. Both schedule types accepts quartz compatible cron syntax e.g. * * * * * * *. In ranged schedule, first element will be start date, and second one will be end date If schedule is set, the scheduled action must be valid too, that is between 1 to 15, inclusive Syntax reference Fields: 1. Seconds: 0-59 * / , - 1. Minutes: 0-59 * / , - 1. Hours: 0-23 * / , - 1. Day of month: 1-31 * / , - L W 1. Month: 1-12 JAN-DEC * / , - 1. Day of week: 0-6 SUN-SAT * / , - L # 1. Year: 1970-2099 * / , - Special characters: 1. *: all values in the fields, e.g. * in seconds fields indicates every second 1. /: increments of ranges, e.g. 3-59/15 in the minute field indicate the third minute of the hour and every 15 minutes thereafter 1. ,: separate items of a list, e.g. MON,WED,FRI in day of week 1. -: range, e.g. 2010-2018 indicates every year between 2010 and 2018, inclusive 1. L: last, e.g. When used in the day-of-week field, it allows you to specify constructs such as &#34;the last Friday&#34; (5L) of a given month. In the day-of-month field, it specifies the last day of the month. 1. W: business day, e.g. if you were to specify 15W as the value for the day-of-month field, the meaning is: &#34;the nearest business day to the 15th of the month.&#34; 1. #: must be followed by a number between one and five. It allows you to specify constructs such as &#34;the second Friday&#34; of a given month.
   */
  updatePermission_ByRoleId_admin_v3(roleId, data) {
    const params = {};
    const url = "/iam/v3/admin/roles/{roleId}/permissions".replace("{roleId}", roleId);
    const resultPromise = this.axiosInstance.put(url, data, { params });
    return import_sdk23.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, import_zod75.z.unknown(), "z.unknown()");
  }
  deletePermission_ByRoleId_v4(roleId, data) {
    const params = {};
    const url = "/iam/v4/admin/roles/{roleId}/permissions".replace("{roleId}", roleId);
    const resultPromise = this.axiosInstance.delete(url, { data, params });
    return import_sdk23.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, import_zod75.z.unknown(), "z.unknown()");
  }
  /**
   * This endpoint will ATTACH permission(s) into the role action code: 10404 Schedule contains cron string or date range (both are UTC, also in cron syntax) to indicate when a permission and action are in effect. Both schedule types accepts quartz compatible cron syntax e.g. * * * * * * *. In ranged schedule, first element will be start date, and second one will be end date If schedule is set, the scheduled action must be valid too, that is between 1 to 15, inclusive Syntax reference Fields: 1. Seconds: 0-59 * / , - 2. Minutes: 0-59 * / , - 3. Hours: 0-23 * / , - 4. Day of month: 1-31 * / , - L W 5. Month: 1-12 JAN-DEC * / , - 6. Day of week: 0-6 SUN-SAT * / , - L # 7. Year: 1970-2099 * / , - Special characters: 1. *: all values in the fields, e.g. * in seconds fields indicates every second 2. /: increments of ranges, e.g. 3-59/15 in the minute field indicate the third minute of the hour and every 15 minutes thereafter 3. ,: separate items of a list, e.g. MON,WED,FRI in day of week 4. -: range, e.g. 2010-2018 indicates every year between 2010 and 2018, inclusive 5. L: last, e.g. When used in the day-of-week field, it allows you to specify constructs such as &#34;the last Friday&#34; (5L) of a given month. In the day-of-month field, it specifies the last day of the month. 6. W: business day, e.g. if you were to specify 15W as the value for the day-of-month field, the meaning is: &#34;the nearest business day to the 15th of the month.&#34; 7. #: must be followed by a number between one and five. It allows you to specify constructs such as &#34;the second Friday&#34; of a given month.
   */
  updatePermission_ByRoleId_v4(roleId, data) {
    const params = {};
    const url = "/iam/v4/admin/roles/{roleId}/permissions".replace("{roleId}", roleId);
    const resultPromise = this.axiosInstance.post(url, data, { params });
    return import_sdk23.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, RoleV4Response, "RoleV4Response");
  }
  /**
   * This endpoint will REPLACE role&#39;s permissions with the ones defined in body action code: 10405 Schedule contains cron string or date range (both are UTC, also in cron syntax) to indicate when a permission and action are in effect. Both schedule types accepts quartz compatible cron syntax e.g. * * * * * * *. In ranged schedule, first element will be start date, and second one will be end date If schedule is set, the scheduled action must be valid too, that is between 1 to 15, inclusive Syntax reference Fields: 1. Seconds: 0-59 * / , - 2. Minutes: 0-59 * / , - 3. Hours: 0-23 * / , - 4. Day of month: 1-31 * / , - L W 5. Month: 1-12 JAN-DEC * / , - 6. Day of week: 0-6 SUN-SAT * / , - L # 7. Year: 1970-2099 * / , - Special characters: 1. *: all values in the fields, e.g. * in seconds fields indicates every second 2. /: increments of ranges, e.g. 3-59/15 in the minute field indicate the third minute of the hour and every 15 minutes thereafter 3. ,: separate items of a list, e.g. MON,WED,FRI in day of week 4. -: range, e.g. 2010-2018 indicates every year between 2010 and 2018, inclusive 5. L: last, e.g. When used in the day-of-week field, it allows you to specify constructs such as &#34;the last Friday&#34; (5L) of a given month. In the day-of-month field, it specifies the last day of the month. 6. W: business day, e.g. if you were to specify 15W as the value for the day-of-month field, the meaning is: &#34;the nearest business day to the 15th of the month.&#34; 7. #: must be followed by a number between one and five. It allows you to specify constructs such as &#34;the second Friday&#34; of a given month.
   */
  updatePermission_ByRoleId_admin_v4(roleId, data) {
    const params = {};
    const url = "/iam/v4/admin/roles/{roleId}/permissions".replace("{roleId}", roleId);
    const resultPromise = this.axiosInstance.put(url, data, { params });
    return import_sdk23.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, RoleV4Response, "RoleV4Response");
  }
  /**
   * action code: 10406
   */
  deletePermission_ByRoleId_ByResource_ByAction_v3(roleId, resource, action) {
    const params = {};
    const url = "/iam/v3/admin/roles/{roleId}/permissions/{resource}/{action}".replace("{roleId}", roleId).replace("{resource}", resource).replace("{action}", String(action));
    const resultPromise = this.axiosInstance.delete(url, { params });
    return import_sdk23.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, import_zod75.z.unknown(), "z.unknown()");
  }
};

// src/generated-admin/RolesAdminApi.ts
function RolesAdminApi(sdk, args) {
  const sdkAssembly = sdk.assembly();
  const namespace = args?.coreConfig?.namespace ?? sdkAssembly.coreConfig.namespace;
  const useSchemaValidation = args?.coreConfig?.useSchemaValidation ?? sdkAssembly.coreConfig.useSchemaValidation;
  let axiosInstance = sdkAssembly.axiosInstance;
  const requestConfigOverrides = args?.axiosConfig?.request;
  const baseURLOverride = args?.coreConfig?.baseURL;
  const interceptorsOverride = args?.axiosConfig?.interceptors ?? [];
  if (requestConfigOverrides || baseURLOverride || interceptorsOverride.length > 0) {
    const requestConfig = import_sdk24.ApiUtils.mergeAxiosConfigs(sdkAssembly.axiosInstance.defaults, {
      ...baseURLOverride ? { baseURL: baseURLOverride } : {},
      ...requestConfigOverrides
    });
    axiosInstance = import_sdk24.Network.create(requestConfig);
    for (const interceptor of interceptorsOverride) {
      if (interceptor.type === "request") {
        axiosInstance.interceptors.request.use(interceptor.onRequest, interceptor.onError);
      }
      if (interceptor.type === "response") {
        axiosInstance.interceptors.response.use(interceptor.onSuccess, interceptor.onError);
      }
    }
  }
  async function getRoles_v3(queryParams) {
    const $ = new RolesAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getRoles_v3(queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function createRole_v3(data) {
    const $ = new RolesAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.createRole_v3(data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getRoles_v4(queryParams) {
    const $ = new RolesAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getRoles_v4(queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function createRole_v4(data) {
    const $ = new RolesAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.createRole_v4(data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function deleteRole_ByRoleId_v3(roleId) {
    const $ = new RolesAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.deleteRole_ByRoleId_v3(roleId);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getRole_ByRoleId_v3(roleId) {
    const $ = new RolesAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getRole_ByRoleId_v3(roleId);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function patchRole_ByRoleId_v3(roleId, data) {
    const $ = new RolesAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.patchRole_ByRoleId_v3(roleId, data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function deleteRole_ByRoleId_v4(roleId) {
    const $ = new RolesAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.deleteRole_ByRoleId_v4(roleId);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getRole_ByRoleId_v4(roleId) {
    const $ = new RolesAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getRole_ByRoleId_v4(roleId);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function patchRole_ByRoleId_v4(roleId, data) {
    const $ = new RolesAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.patchRole_ByRoleId_v4(roleId, data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function deleteAdmin_ByRoleId_v3(roleId) {
    const $ = new RolesAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.deleteAdmin_ByRoleId_v3(roleId);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getAdmin_ByRoleId_v3(roleId) {
    const $ = new RolesAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getAdmin_ByRoleId_v3(roleId);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function updateAdmin_ByRoleId_v3(roleId) {
    const $ = new RolesAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.updateAdmin_ByRoleId_v3(roleId);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function deleteUser_ByRoleId_v4(roleId, data) {
    const $ = new RolesAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.deleteUser_ByRoleId_v4(roleId, data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getUsers_ByRoleId_v4(roleId, queryParams) {
    const $ = new RolesAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getUsers_ByRoleId_v4(roleId, queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function updateUser_ByRoleId_v4(roleId, data) {
    const $ = new RolesAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.updateUser_ByRoleId_v4(roleId, data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function deleteMember_ByRoleId_v3(roleId, data) {
    const $ = new RolesAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.deleteMember_ByRoleId_v3(roleId, data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getMembers_ByRoleId_v3(roleId, queryParams) {
    const $ = new RolesAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getMembers_ByRoleId_v3(roleId, queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function updateMember_ByRoleId_v3(roleId, data) {
    const $ = new RolesAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.updateMember_ByRoleId_v3(roleId, data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function deleteManager_ByRoleId_v3(roleId, data) {
    const $ = new RolesAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.deleteManager_ByRoleId_v3(roleId, data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getManagers_ByRoleId_v3(roleId, queryParams) {
    const $ = new RolesAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getManagers_ByRoleId_v3(roleId, queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function updateManager_ByRoleId_v3(roleId, data) {
    const $ = new RolesAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.updateManager_ByRoleId_v3(roleId, data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function deletePermission_ByRoleId_v3(roleId, data) {
    const $ = new RolesAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.deletePermission_ByRoleId_v3(roleId, data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function updatePermission_ByRoleId_v3(roleId, data) {
    const $ = new RolesAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.updatePermission_ByRoleId_v3(roleId, data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function updatePermission_ByRoleId_admin_v3(roleId, data) {
    const $ = new RolesAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.updatePermission_ByRoleId_admin_v3(roleId, data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function deletePermission_ByRoleId_v4(roleId, data) {
    const $ = new RolesAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.deletePermission_ByRoleId_v4(roleId, data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function updatePermission_ByRoleId_v4(roleId, data) {
    const $ = new RolesAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.updatePermission_ByRoleId_v4(roleId, data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function updatePermission_ByRoleId_admin_v4(roleId, data) {
    const $ = new RolesAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.updatePermission_ByRoleId_admin_v4(roleId, data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function deletePermission_ByRoleId_ByResource_ByAction_v3(roleId, resource, action) {
    const $ = new RolesAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.deletePermission_ByRoleId_ByResource_ByAction_v3(roleId, resource, action);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  return {
    /**
     * action code: 10414
     */
    getRoles_v3,
    /**
     * Create role request body: - roleName: specify role name, alphanumeric, cannot have special character (required) - permissions: specify the permission that this role have - managers: specify list of user that will act as the managers of this role - members: specify list of user that will act as the members of this role - adminRole: specify if role is for admin user (default false) - isWildcard: specify if role can be assigned to wildcard (*) namespace (default false) - deletable: specify if role can be deleted or not (default true) action code: 10401
     */
    createRole_v3,
    /**
     * action code: 10414
     */
    getRoles_v4,
    /**
     * Create role request body: - roleName: specify role name, alphanumeric, cannot have special character (required) - adminRole: specify if role is for admin user (default false) - isWildcard: specify if role can be assigned to wildcard (*) namespace (default false) - deletable: specify if role can be deleted (default true) action code: 10401
     */
    createRole_v4,
    /**
     * action code: 10403
     */
    deleteRole_ByRoleId_v3,
    /**
     * action code: 10419
     */
    getRole_ByRoleId_v3,
    /**
     * Update role request body: - roleName: specify role name, alphanumeric, cannot have special character (required) - isWildcard: specify if role can be assigned to wildcard (*) namespace (default false) - deletable: specify if role can be deleted or not (optional) action code: 10402
     */
    patchRole_ByRoleId_v3,
    /**
     * Removes role ID from user&#39;s Roles and NamespaceRoles before deleting the role. action code: 10403
     */
    deleteRole_ByRoleId_v4,
    /**
     * action code: 10419
     */
    getRole_ByRoleId_v4,
    /**
     * Update role request body: - roleName: specify role name, alphanumeric, cannot have special character (required) - adminRole: specify if role is for admin user (default false) - isWildcard: specify if role can be assigned to wildcard (*) namespace (default false) - deletable: specify if role can be deleted (optional) action code: 10402
     */
    patchRole_ByRoleId_v4,
    /**
     * code: 10413
     */
    deleteAdmin_ByRoleId_v3,
    /**
     * Admin roles has its members listed in the role. action code: 10420
     */
    getAdmin_ByRoleId_v3,
    /**
     * Admin roles has its members listed in the role. Role can be set as admin role only when it has at least 1 manager. action code: 10412
     */
    updateAdmin_ByRoleId_v3,
    /**
     * Current implementation will revoke user from role in all assigned namespaces. Parameters: - userId: string (required) - namespace: string (user’s namespace) (required) action code: 10411
     */
    deleteUser_ByRoleId_v4,
    /**
     * Query all users that has the specified role. action code: 10416
     */
    getUsers_ByRoleId_v4,
    /**
     * Parameters: - **userId**: string (required) - **namespace**: string (user’s namespace) (required) - **assignedNamespaces**: array of string (namespaces to be assigned on role) (required) action code: 10410
     */
    updateUser_ByRoleId_v4,
    /**
     * @deprecated
     * Admin roles has its members listed in the role. Role can only be assigned to other users by the role&#39;s manager. action code: 10411 Deprecate: Suggest to use this: AdminRevokeUserFromRoleV4
     */
    deleteMember_ByRoleId_v3,
    /**
     * Admin roles has its members listed in the role. action code: 10416
     */
    getMembers_ByRoleId_v3,
    /**
     * Admin roles has its members listed in the role. Role can only be assigned to other users by the role&#39;s manager. action code: 10410
     */
    updateMember_ByRoleId_v3,
    /**
     * Role can only be assigned to other users by the role&#39;s manager. action code: 10409
     */
    deleteManager_ByRoleId_v3,
    /**
     * Role can only be assigned to other users by the role&#39;s manager. action code: 10415
     */
    getManagers_ByRoleId_v3,
    /**
     * Role can only be assigned to other users by the role&#39;s manager. action code: 10408
     */
    updateManager_ByRoleId_v3,
    deletePermission_ByRoleId_v3,
    /**
     * This endpoint will ATTACH permission(s) into the role action code: 10404 Schedule contains cron string or date range (both are UTC, also in cron syntax) to indicate when a permission and action are in effect. Both schedule types accepts quartz compatible cron syntax e.g. * * * * * * *. In ranged schedule, first element will be start date, and second one will be end date If schedule is set, the scheduled action must be valid too, that is between 1 to 15, inclusive Syntax reference Fields: 1. Seconds: 0-59 * / , - 1. Minutes: 0-59 * / , - 1. Hours: 0-23 * / , - 1. Day of month: 1-31 * / , - L W 1. Month: 1-12 JAN-DEC * / , - 1. Day of week: 0-6 SUN-SAT * / , - L # 1. Year: 1970-2099 * / , - Special characters: 1. *: all values in the fields, e.g. * in seconds fields indicates every second 1. /: increments of ranges, e.g. 3-59/15 in the minute field indicate the third minute of the hour and every 15 minutes thereafter 1. ,: separate items of a list, e.g. MON,WED,FRI in day of week 1. -: range, e.g. 2010-2018 indicates every year between 2010 and 2018, inclusive 1. L: last, e.g. When used in the day-of-week field, it allows you to specify constructs such as &#34;the last Friday&#34; (5L) of a given month. In the day-of-month field, it specifies the last day of the month. 1. W: business day, e.g. if you were to specify 15W as the value for the day-of-month field, the meaning is: &#34;the nearest business day to the 15th of the month.&#34; 1. #: must be followed by a number between one and five. It allows you to specify constructs such as &#34;the second Friday&#34; of a given month.
     */
    updatePermission_ByRoleId_v3,
    /**
     * This endpoint will REPLACE role&#39;s permissions with the ones defined in body action code: 10405 Schedule contains cron string or date range (both are UTC, also in cron syntax) to indicate when a permission and action are in effect. Both schedule types accepts quartz compatible cron syntax e.g. * * * * * * *. In ranged schedule, first element will be start date, and second one will be end date If schedule is set, the scheduled action must be valid too, that is between 1 to 15, inclusive Syntax reference Fields: 1. Seconds: 0-59 * / , - 1. Minutes: 0-59 * / , - 1. Hours: 0-23 * / , - 1. Day of month: 1-31 * / , - L W 1. Month: 1-12 JAN-DEC * / , - 1. Day of week: 0-6 SUN-SAT * / , - L # 1. Year: 1970-2099 * / , - Special characters: 1. *: all values in the fields, e.g. * in seconds fields indicates every second 1. /: increments of ranges, e.g. 3-59/15 in the minute field indicate the third minute of the hour and every 15 minutes thereafter 1. ,: separate items of a list, e.g. MON,WED,FRI in day of week 1. -: range, e.g. 2010-2018 indicates every year between 2010 and 2018, inclusive 1. L: last, e.g. When used in the day-of-week field, it allows you to specify constructs such as &#34;the last Friday&#34; (5L) of a given month. In the day-of-month field, it specifies the last day of the month. 1. W: business day, e.g. if you were to specify 15W as the value for the day-of-month field, the meaning is: &#34;the nearest business day to the 15th of the month.&#34; 1. #: must be followed by a number between one and five. It allows you to specify constructs such as &#34;the second Friday&#34; of a given month.
     */
    updatePermission_ByRoleId_admin_v3,
    deletePermission_ByRoleId_v4,
    /**
     * This endpoint will ATTACH permission(s) into the role action code: 10404 Schedule contains cron string or date range (both are UTC, also in cron syntax) to indicate when a permission and action are in effect. Both schedule types accepts quartz compatible cron syntax e.g. * * * * * * *. In ranged schedule, first element will be start date, and second one will be end date If schedule is set, the scheduled action must be valid too, that is between 1 to 15, inclusive Syntax reference Fields: 1. Seconds: 0-59 * / , - 2. Minutes: 0-59 * / , - 3. Hours: 0-23 * / , - 4. Day of month: 1-31 * / , - L W 5. Month: 1-12 JAN-DEC * / , - 6. Day of week: 0-6 SUN-SAT * / , - L # 7. Year: 1970-2099 * / , - Special characters: 1. *: all values in the fields, e.g. * in seconds fields indicates every second 2. /: increments of ranges, e.g. 3-59/15 in the minute field indicate the third minute of the hour and every 15 minutes thereafter 3. ,: separate items of a list, e.g. MON,WED,FRI in day of week 4. -: range, e.g. 2010-2018 indicates every year between 2010 and 2018, inclusive 5. L: last, e.g. When used in the day-of-week field, it allows you to specify constructs such as &#34;the last Friday&#34; (5L) of a given month. In the day-of-month field, it specifies the last day of the month. 6. W: business day, e.g. if you were to specify 15W as the value for the day-of-month field, the meaning is: &#34;the nearest business day to the 15th of the month.&#34; 7. #: must be followed by a number between one and five. It allows you to specify constructs such as &#34;the second Friday&#34; of a given month.
     */
    updatePermission_ByRoleId_v4,
    /**
     * This endpoint will REPLACE role&#39;s permissions with the ones defined in body action code: 10405 Schedule contains cron string or date range (both are UTC, also in cron syntax) to indicate when a permission and action are in effect. Both schedule types accepts quartz compatible cron syntax e.g. * * * * * * *. In ranged schedule, first element will be start date, and second one will be end date If schedule is set, the scheduled action must be valid too, that is between 1 to 15, inclusive Syntax reference Fields: 1. Seconds: 0-59 * / , - 2. Minutes: 0-59 * / , - 3. Hours: 0-23 * / , - 4. Day of month: 1-31 * / , - L W 5. Month: 1-12 JAN-DEC * / , - 6. Day of week: 0-6 SUN-SAT * / , - L # 7. Year: 1970-2099 * / , - Special characters: 1. *: all values in the fields, e.g. * in seconds fields indicates every second 2. /: increments of ranges, e.g. 3-59/15 in the minute field indicate the third minute of the hour and every 15 minutes thereafter 3. ,: separate items of a list, e.g. MON,WED,FRI in day of week 4. -: range, e.g. 2010-2018 indicates every year between 2010 and 2018, inclusive 5. L: last, e.g. When used in the day-of-week field, it allows you to specify constructs such as &#34;the last Friday&#34; (5L) of a given month. In the day-of-month field, it specifies the last day of the month. 6. W: business day, e.g. if you were to specify 15W as the value for the day-of-month field, the meaning is: &#34;the nearest business day to the 15th of the month.&#34; 7. #: must be followed by a number between one and five. It allows you to specify constructs such as &#34;the second Friday&#34; of a given month.
     */
    updatePermission_ByRoleId_admin_v4,
    /**
     * action code: 10406
     */
    deletePermission_ByRoleId_ByResource_ByAction_v3
  };
}

// src/generated-admin/queries/RolesAdmin.query.ts
var Key_RolesAdmin = /* @__PURE__ */ ((Key_RolesAdmin2) => {
  Key_RolesAdmin2["Roles_v3"] = "Iam.RolesAdmin.Roles_v3";
  Key_RolesAdmin2["Role_v3"] = "Iam.RolesAdmin.Role_v3";
  Key_RolesAdmin2["Roles_v4"] = "Iam.RolesAdmin.Roles_v4";
  Key_RolesAdmin2["Role_v4"] = "Iam.RolesAdmin.Role_v4";
  Key_RolesAdmin2["Role_ByRoleId_v3"] = "Iam.RolesAdmin.Role_ByRoleId_v3";
  Key_RolesAdmin2["Role_ByRoleId_v4"] = "Iam.RolesAdmin.Role_ByRoleId_v4";
  Key_RolesAdmin2["Admin_ByRoleId_v3"] = "Iam.RolesAdmin.Admin_ByRoleId_v3";
  Key_RolesAdmin2["User_ByRoleId_v4"] = "Iam.RolesAdmin.User_ByRoleId_v4";
  Key_RolesAdmin2["Users_ByRoleId_v4"] = "Iam.RolesAdmin.Users_ByRoleId_v4";
  Key_RolesAdmin2["Member_ByRoleId_v3"] = "Iam.RolesAdmin.Member_ByRoleId_v3";
  Key_RolesAdmin2["Members_ByRoleId_v3"] = "Iam.RolesAdmin.Members_ByRoleId_v3";
  Key_RolesAdmin2["Manager_ByRoleId_v3"] = "Iam.RolesAdmin.Manager_ByRoleId_v3";
  Key_RolesAdmin2["Managers_ByRoleId_v3"] = "Iam.RolesAdmin.Managers_ByRoleId_v3";
  Key_RolesAdmin2["Permission_ByRoleId_v3"] = "Iam.RolesAdmin.Permission_ByRoleId_v3";
  Key_RolesAdmin2["Permission_ByRoleId_admin_v3"] = "Iam.RolesAdmin.Permission_ByRoleId_admin_v3";
  Key_RolesAdmin2["Permission_ByRoleId_v4"] = "Iam.RolesAdmin.Permission_ByRoleId_v4";
  Key_RolesAdmin2["Permission_ByRoleId_admin_v4"] = "Iam.RolesAdmin.Permission_ByRoleId_admin_v4";
  Key_RolesAdmin2["Permission_ByRoleId_ByResource_ByAction_v3"] = "Iam.RolesAdmin.Permission_ByRoleId_ByResource_ByAction_v3";
  return Key_RolesAdmin2;
})(Key_RolesAdmin || {});
var useRolesAdminApi_GetRoles_v3 = (sdk, input, options, callback) => {
  const queryFn = (sdk2, input2) => async () => {
    const response = await RolesAdminApi(sdk2, { coreConfig: input2.coreConfig, axiosConfig: input2.axiosConfig }).getRoles_v3(
      input2.queryParams
    );
    callback && callback(response);
    return response.data;
  };
  return (0, import_react_query12.useQuery)({
    queryKey: ["Iam.RolesAdmin.Roles_v3" /* Roles_v3 */, input],
    queryFn: queryFn(sdk, input),
    ...options
  });
};
var useRolesAdminApi_CreateRoleMutation_v3 = (sdk, options, callback) => {
  const mutationFn = async (input) => {
    const response = await RolesAdminApi(sdk, { coreConfig: input.coreConfig, axiosConfig: input.axiosConfig }).createRole_v3(input.data);
    callback && callback(response.data);
    return response.data;
  };
  return (0, import_react_query12.useMutation)({
    mutationKey: ["Iam.RolesAdmin.Role_v3" /* Role_v3 */],
    mutationFn,
    ...options
  });
};
var useRolesAdminApi_GetRoles_v4 = (sdk, input, options, callback) => {
  const queryFn = (sdk2, input2) => async () => {
    const response = await RolesAdminApi(sdk2, { coreConfig: input2.coreConfig, axiosConfig: input2.axiosConfig }).getRoles_v4(
      input2.queryParams
    );
    callback && callback(response);
    return response.data;
  };
  return (0, import_react_query12.useQuery)({
    queryKey: ["Iam.RolesAdmin.Roles_v4" /* Roles_v4 */, input],
    queryFn: queryFn(sdk, input),
    ...options
  });
};
var useRolesAdminApi_CreateRoleMutation_v4 = (sdk, options, callback) => {
  const mutationFn = async (input) => {
    const response = await RolesAdminApi(sdk, { coreConfig: input.coreConfig, axiosConfig: input.axiosConfig }).createRole_v4(input.data);
    callback && callback(response.data);
    return response.data;
  };
  return (0, import_react_query12.useMutation)({
    mutationKey: ["Iam.RolesAdmin.Role_v4" /* Role_v4 */],
    mutationFn,
    ...options
  });
};
var useRolesAdminApi_DeleteRole_ByRoleIdMutation_v3 = (sdk, options, callback) => {
  const mutationFn = async (input) => {
    const response = await RolesAdminApi(sdk, { coreConfig: input.coreConfig, axiosConfig: input.axiosConfig }).deleteRole_ByRoleId_v3(
      input.roleId
    );
    callback && callback(response.data);
    return response.data;
  };
  return (0, import_react_query12.useMutation)({
    mutationKey: ["Iam.RolesAdmin.Role_ByRoleId_v3" /* Role_ByRoleId_v3 */],
    mutationFn,
    ...options
  });
};
var useRolesAdminApi_GetRole_ByRoleId_v3 = (sdk, input, options, callback) => {
  const queryFn = (sdk2, input2) => async () => {
    const response = await RolesAdminApi(sdk2, { coreConfig: input2.coreConfig, axiosConfig: input2.axiosConfig }).getRole_ByRoleId_v3(
      input2.roleId
    );
    callback && callback(response);
    return response.data;
  };
  return (0, import_react_query12.useQuery)({
    queryKey: ["Iam.RolesAdmin.Role_ByRoleId_v3" /* Role_ByRoleId_v3 */, input],
    queryFn: queryFn(sdk, input),
    ...options
  });
};
var useRolesAdminApi_PatchRole_ByRoleIdMutation_v3 = (sdk, options, callback) => {
  const mutationFn = async (input) => {
    const response = await RolesAdminApi(sdk, { coreConfig: input.coreConfig, axiosConfig: input.axiosConfig }).patchRole_ByRoleId_v3(
      input.roleId,
      input.data
    );
    callback && callback(response.data);
    return response.data;
  };
  return (0, import_react_query12.useMutation)({
    mutationKey: ["Iam.RolesAdmin.Role_ByRoleId_v3" /* Role_ByRoleId_v3 */],
    mutationFn,
    ...options
  });
};
var useRolesAdminApi_DeleteRole_ByRoleIdMutation_v4 = (sdk, options, callback) => {
  const mutationFn = async (input) => {
    const response = await RolesAdminApi(sdk, { coreConfig: input.coreConfig, axiosConfig: input.axiosConfig }).deleteRole_ByRoleId_v4(
      input.roleId
    );
    callback && callback(response.data);
    return response.data;
  };
  return (0, import_react_query12.useMutation)({
    mutationKey: ["Iam.RolesAdmin.Role_ByRoleId_v4" /* Role_ByRoleId_v4 */],
    mutationFn,
    ...options
  });
};
var useRolesAdminApi_GetRole_ByRoleId_v4 = (sdk, input, options, callback) => {
  const queryFn = (sdk2, input2) => async () => {
    const response = await RolesAdminApi(sdk2, { coreConfig: input2.coreConfig, axiosConfig: input2.axiosConfig }).getRole_ByRoleId_v4(
      input2.roleId
    );
    callback && callback(response);
    return response.data;
  };
  return (0, import_react_query12.useQuery)({
    queryKey: ["Iam.RolesAdmin.Role_ByRoleId_v4" /* Role_ByRoleId_v4 */, input],
    queryFn: queryFn(sdk, input),
    ...options
  });
};
var useRolesAdminApi_PatchRole_ByRoleIdMutation_v4 = (sdk, options, callback) => {
  const mutationFn = async (input) => {
    const response = await RolesAdminApi(sdk, { coreConfig: input.coreConfig, axiosConfig: input.axiosConfig }).patchRole_ByRoleId_v4(
      input.roleId,
      input.data
    );
    callback && callback(response.data);
    return response.data;
  };
  return (0, import_react_query12.useMutation)({
    mutationKey: ["Iam.RolesAdmin.Role_ByRoleId_v4" /* Role_ByRoleId_v4 */],
    mutationFn,
    ...options
  });
};
var useRolesAdminApi_DeleteAdmin_ByRoleIdMutation_v3 = (sdk, options, callback) => {
  const mutationFn = async (input) => {
    const response = await RolesAdminApi(sdk, { coreConfig: input.coreConfig, axiosConfig: input.axiosConfig }).deleteAdmin_ByRoleId_v3(
      input.roleId
    );
    callback && callback(response.data);
    return response.data;
  };
  return (0, import_react_query12.useMutation)({
    mutationKey: ["Iam.RolesAdmin.Admin_ByRoleId_v3" /* Admin_ByRoleId_v3 */],
    mutationFn,
    ...options
  });
};
var useRolesAdminApi_GetAdmin_ByRoleId_v3 = (sdk, input, options, callback) => {
  const queryFn = (sdk2, input2) => async () => {
    const response = await RolesAdminApi(sdk2, { coreConfig: input2.coreConfig, axiosConfig: input2.axiosConfig }).getAdmin_ByRoleId_v3(
      input2.roleId
    );
    callback && callback(response);
    return response.data;
  };
  return (0, import_react_query12.useQuery)({
    queryKey: ["Iam.RolesAdmin.Admin_ByRoleId_v3" /* Admin_ByRoleId_v3 */, input],
    queryFn: queryFn(sdk, input),
    ...options
  });
};
var useRolesAdminApi_UpdateAdmin_ByRoleIdMutation_v3 = (sdk, options, callback) => {
  const mutationFn = async (input) => {
    const response = await RolesAdminApi(sdk, { coreConfig: input.coreConfig, axiosConfig: input.axiosConfig }).updateAdmin_ByRoleId_v3(
      input.roleId
    );
    callback && callback(response.data);
    return response.data;
  };
  return (0, import_react_query12.useMutation)({
    mutationKey: ["Iam.RolesAdmin.Admin_ByRoleId_v3" /* Admin_ByRoleId_v3 */],
    mutationFn,
    ...options
  });
};
var useRolesAdminApi_DeleteUser_ByRoleIdMutation_v4 = (sdk, options, callback) => {
  const mutationFn = async (input) => {
    const response = await RolesAdminApi(sdk, { coreConfig: input.coreConfig, axiosConfig: input.axiosConfig }).deleteUser_ByRoleId_v4(
      input.roleId,
      input.data
    );
    callback && callback(response.data);
    return response.data;
  };
  return (0, import_react_query12.useMutation)({
    mutationKey: ["Iam.RolesAdmin.User_ByRoleId_v4" /* User_ByRoleId_v4 */],
    mutationFn,
    ...options
  });
};
var useRolesAdminApi_GetUsers_ByRoleId_v4 = (sdk, input, options, callback) => {
  const queryFn = (sdk2, input2) => async () => {
    const response = await RolesAdminApi(sdk2, { coreConfig: input2.coreConfig, axiosConfig: input2.axiosConfig }).getUsers_ByRoleId_v4(
      input2.roleId,
      input2.queryParams
    );
    callback && callback(response);
    return response.data;
  };
  return (0, import_react_query12.useQuery)({
    queryKey: ["Iam.RolesAdmin.Users_ByRoleId_v4" /* Users_ByRoleId_v4 */, input],
    queryFn: queryFn(sdk, input),
    ...options
  });
};
var useRolesAdminApi_UpdateUser_ByRoleIdMutation_v4 = (sdk, options, callback) => {
  const mutationFn = async (input) => {
    const response = await RolesAdminApi(sdk, { coreConfig: input.coreConfig, axiosConfig: input.axiosConfig }).updateUser_ByRoleId_v4(
      input.roleId,
      input.data
    );
    callback && callback(response.data);
    return response.data;
  };
  return (0, import_react_query12.useMutation)({
    mutationKey: ["Iam.RolesAdmin.User_ByRoleId_v4" /* User_ByRoleId_v4 */],
    mutationFn,
    ...options
  });
};
var useRolesAdminApi_DeleteMember_ByRoleIdMutation_v3 = (sdk, options, callback) => {
  const mutationFn = async (input) => {
    const response = await RolesAdminApi(sdk, { coreConfig: input.coreConfig, axiosConfig: input.axiosConfig }).deleteMember_ByRoleId_v3(
      input.roleId,
      input.data
    );
    callback && callback(response.data);
    return response.data;
  };
  return (0, import_react_query12.useMutation)({
    mutationKey: ["Iam.RolesAdmin.Member_ByRoleId_v3" /* Member_ByRoleId_v3 */],
    mutationFn,
    ...options
  });
};
var useRolesAdminApi_GetMembers_ByRoleId_v3 = (sdk, input, options, callback) => {
  const queryFn = (sdk2, input2) => async () => {
    const response = await RolesAdminApi(sdk2, { coreConfig: input2.coreConfig, axiosConfig: input2.axiosConfig }).getMembers_ByRoleId_v3(
      input2.roleId,
      input2.queryParams
    );
    callback && callback(response);
    return response.data;
  };
  return (0, import_react_query12.useQuery)({
    queryKey: ["Iam.RolesAdmin.Members_ByRoleId_v3" /* Members_ByRoleId_v3 */, input],
    queryFn: queryFn(sdk, input),
    ...options
  });
};
var useRolesAdminApi_UpdateMember_ByRoleIdMutation_v3 = (sdk, options, callback) => {
  const mutationFn = async (input) => {
    const response = await RolesAdminApi(sdk, { coreConfig: input.coreConfig, axiosConfig: input.axiosConfig }).updateMember_ByRoleId_v3(
      input.roleId,
      input.data
    );
    callback && callback(response.data);
    return response.data;
  };
  return (0, import_react_query12.useMutation)({
    mutationKey: ["Iam.RolesAdmin.Member_ByRoleId_v3" /* Member_ByRoleId_v3 */],
    mutationFn,
    ...options
  });
};
var useRolesAdminApi_DeleteManager_ByRoleIdMutation_v3 = (sdk, options, callback) => {
  const mutationFn = async (input) => {
    const response = await RolesAdminApi(sdk, { coreConfig: input.coreConfig, axiosConfig: input.axiosConfig }).deleteManager_ByRoleId_v3(
      input.roleId,
      input.data
    );
    callback && callback(response.data);
    return response.data;
  };
  return (0, import_react_query12.useMutation)({
    mutationKey: ["Iam.RolesAdmin.Manager_ByRoleId_v3" /* Manager_ByRoleId_v3 */],
    mutationFn,
    ...options
  });
};
var useRolesAdminApi_GetManagers_ByRoleId_v3 = (sdk, input, options, callback) => {
  const queryFn = (sdk2, input2) => async () => {
    const response = await RolesAdminApi(sdk2, { coreConfig: input2.coreConfig, axiosConfig: input2.axiosConfig }).getManagers_ByRoleId_v3(
      input2.roleId,
      input2.queryParams
    );
    callback && callback(response);
    return response.data;
  };
  return (0, import_react_query12.useQuery)({
    queryKey: ["Iam.RolesAdmin.Managers_ByRoleId_v3" /* Managers_ByRoleId_v3 */, input],
    queryFn: queryFn(sdk, input),
    ...options
  });
};
var useRolesAdminApi_UpdateManager_ByRoleIdMutation_v3 = (sdk, options, callback) => {
  const mutationFn = async (input) => {
    const response = await RolesAdminApi(sdk, { coreConfig: input.coreConfig, axiosConfig: input.axiosConfig }).updateManager_ByRoleId_v3(
      input.roleId,
      input.data
    );
    callback && callback(response.data);
    return response.data;
  };
  return (0, import_react_query12.useMutation)({
    mutationKey: ["Iam.RolesAdmin.Manager_ByRoleId_v3" /* Manager_ByRoleId_v3 */],
    mutationFn,
    ...options
  });
};
var useRolesAdminApi_DeletePermission_ByRoleIdMutation_v3 = (sdk, options, callback) => {
  const mutationFn = async (input) => {
    const response = await RolesAdminApi(sdk, {
      coreConfig: input.coreConfig,
      axiosConfig: input.axiosConfig
    }).deletePermission_ByRoleId_v3(input.roleId, input.data);
    callback && callback(response.data);
    return response.data;
  };
  return (0, import_react_query12.useMutation)({
    mutationKey: ["Iam.RolesAdmin.Permission_ByRoleId_v3" /* Permission_ByRoleId_v3 */],
    mutationFn,
    ...options
  });
};
var useRolesAdminApi_UpdatePermission_ByRoleIdMutation_v3 = (sdk, options, callback) => {
  const mutationFn = async (input) => {
    const response = await RolesAdminApi(sdk, {
      coreConfig: input.coreConfig,
      axiosConfig: input.axiosConfig
    }).updatePermission_ByRoleId_v3(input.roleId, input.data);
    callback && callback(response.data);
    return response.data;
  };
  return (0, import_react_query12.useMutation)({
    mutationKey: ["Iam.RolesAdmin.Permission_ByRoleId_v3" /* Permission_ByRoleId_v3 */],
    mutationFn,
    ...options
  });
};
var useRolesAdminApi_UpdatePermission_ByRoleId_adminMutation_v3 = (sdk, options, callback) => {
  const mutationFn = async (input) => {
    const response = await RolesAdminApi(sdk, {
      coreConfig: input.coreConfig,
      axiosConfig: input.axiosConfig
    }).updatePermission_ByRoleId_admin_v3(input.roleId, input.data);
    callback && callback(response.data);
    return response.data;
  };
  return (0, import_react_query12.useMutation)({
    mutationKey: ["Iam.RolesAdmin.Permission_ByRoleId_admin_v3" /* Permission_ByRoleId_admin_v3 */],
    mutationFn,
    ...options
  });
};
var useRolesAdminApi_DeletePermission_ByRoleIdMutation_v4 = (sdk, options, callback) => {
  const mutationFn = async (input) => {
    const response = await RolesAdminApi(sdk, {
      coreConfig: input.coreConfig,
      axiosConfig: input.axiosConfig
    }).deletePermission_ByRoleId_v4(input.roleId, input.data);
    callback && callback(response.data);
    return response.data;
  };
  return (0, import_react_query12.useMutation)({
    mutationKey: ["Iam.RolesAdmin.Permission_ByRoleId_v4" /* Permission_ByRoleId_v4 */],
    mutationFn,
    ...options
  });
};
var useRolesAdminApi_UpdatePermission_ByRoleIdMutation_v4 = (sdk, options, callback) => {
  const mutationFn = async (input) => {
    const response = await RolesAdminApi(sdk, {
      coreConfig: input.coreConfig,
      axiosConfig: input.axiosConfig
    }).updatePermission_ByRoleId_v4(input.roleId, input.data);
    callback && callback(response.data);
    return response.data;
  };
  return (0, import_react_query12.useMutation)({
    mutationKey: ["Iam.RolesAdmin.Permission_ByRoleId_v4" /* Permission_ByRoleId_v4 */],
    mutationFn,
    ...options
  });
};
var useRolesAdminApi_UpdatePermission_ByRoleId_adminMutation_v4 = (sdk, options, callback) => {
  const mutationFn = async (input) => {
    const response = await RolesAdminApi(sdk, {
      coreConfig: input.coreConfig,
      axiosConfig: input.axiosConfig
    }).updatePermission_ByRoleId_admin_v4(input.roleId, input.data);
    callback && callback(response.data);
    return response.data;
  };
  return (0, import_react_query12.useMutation)({
    mutationKey: ["Iam.RolesAdmin.Permission_ByRoleId_admin_v4" /* Permission_ByRoleId_admin_v4 */],
    mutationFn,
    ...options
  });
};
var useRolesAdminApi_DeletePermission_ByRoleId_ByResource_ByActionMutation_v3 = (sdk, options, callback) => {
  const mutationFn = async (input) => {
    const response = await RolesAdminApi(sdk, {
      coreConfig: input.coreConfig,
      axiosConfig: input.axiosConfig
    }).deletePermission_ByRoleId_ByResource_ByAction_v3(input.roleId, input.resource, input.action);
    callback && callback(response.data);
    return response.data;
  };
  return (0, import_react_query12.useMutation)({
    mutationKey: ["Iam.RolesAdmin.Permission_ByRoleId_ByResource_ByAction_v3" /* Permission_ByRoleId_ByResource_ByAction_v3 */],
    mutationFn,
    ...options
  });
};

// src/generated-admin/queries/SsoCredentialAdmin.query.ts
var import_react_query13 = require("@tanstack/react-query");

// src/generated-admin/SsoCredentialAdminApi.ts
var import_sdk26 = require("@accelbyte/sdk");

// src/generated-admin/endpoints/SsoCredentialAdmin$.ts
var import_sdk25 = require("@accelbyte/sdk");
var import_zod78 = require("zod");

// src/generated-definitions/SsoPlatformCredentialResponse.ts
var import_zod76 = require("zod");
var SsoPlatformCredentialResponse = import_zod76.z.object({
  acsUrl: import_zod76.z.string(),
  appId: import_zod76.z.string(),
  federationMetadataUrl: import_zod76.z.string(),
  isActive: import_zod76.z.boolean(),
  namespace: import_zod76.z.string(),
  platformId: import_zod76.z.string(),
  redirectUri: import_zod76.z.string(),
  secret: import_zod76.z.string(),
  ssoUrl: import_zod76.z.string(),
  truncatedApiKey: import_zod76.z.string()
});

// src/generated-definitions/SsoPlatformCredentialResponseArray.ts
var import_zod77 = require("zod");
var SsoPlatformCredentialResponseArray = import_zod77.z.array(SsoPlatformCredentialResponse);

// src/generated-admin/endpoints/SsoCredentialAdmin$.ts
var SsoCredentialAdmin$ = class {
  // @ts-ignore
  // prettier-ignore
  constructor(axiosInstance, namespace, useSchemaValidation = true) {
    this.axiosInstance = axiosInstance;
    this.namespace = namespace;
    this.useSchemaValidation = useSchemaValidation;
  }
  /**
   * This is the API to Get All Active SSO Platform Credential.
   */
  getPlatformsSso_v3(queryParams) {
    const params = { ...queryParams };
    const url = "/iam/v3/admin/namespaces/{namespace}/platforms/sso".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.get(url, { params });
    return import_sdk25.Validate.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      SsoPlatformCredentialResponseArray,
      "SsoPlatformCredentialResponseArray"
    );
  }
  /**
   * This is the API to Delete SSO Platform Credential.
   */
  deleteSso_ByPlatformId_v3(platformId) {
    const params = {};
    const url = "/iam/v3/admin/namespaces/{namespace}/platforms/{platformId}/sso".replace("{namespace}", this.namespace).replace("{platformId}", platformId);
    const resultPromise = this.axiosInstance.delete(url, { params });
    return import_sdk25.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, import_zod78.z.unknown(), "z.unknown()");
  }
  /**
   * This is the API to Get SSO Platform Credential.
   */
  getSso_ByPlatformId_v3(platformId) {
    const params = {};
    const url = "/iam/v3/admin/namespaces/{namespace}/platforms/{platformId}/sso".replace("{namespace}", this.namespace).replace("{platformId}", platformId);
    const resultPromise = this.axiosInstance.get(url, { params });
    return import_sdk25.Validate.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      SsoPlatformCredentialResponse,
      "SsoPlatformCredentialResponse"
    );
  }
  /**
   * This is the API to Delete SSO Platform Credential.
   */
  patchSso_ByPlatformId_v3(platformId, data) {
    const params = {};
    const url = "/iam/v3/admin/namespaces/{namespace}/platforms/{platformId}/sso".replace("{namespace}", this.namespace).replace("{platformId}", platformId);
    const resultPromise = this.axiosInstance.patch(url, data, { params });
    return import_sdk25.Validate.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      SsoPlatformCredentialResponse,
      "SsoPlatformCredentialResponse"
    );
  }
  /**
   * This is the API to Add SSO Platform Credential. ## Supported platforms: - **discourse** the ssoUrl of the discourse is the discourse forum url. example: https://forum.example.com - **azure with SAML** **appId** is an application identifier in IdP, in azure it&#39;s called EntityID **acsUrl** is an endpoint on the service provider where the identity provider will redirect to with its authentication response. example: /iam/v3/sso/saml/azuresaml/authenticate **federationMetadataUrl** is an endpoint on the Identity Provider(IdP) to get IdP federation metadata for service provider to build trust relationship
   */
  createSso_ByPlatformId_v3(platformId, data) {
    const params = {};
    const url = "/iam/v3/admin/namespaces/{namespace}/platforms/{platformId}/sso".replace("{namespace}", this.namespace).replace("{platformId}", platformId);
    const resultPromise = this.axiosInstance.post(url, data, { params });
    return import_sdk25.Validate.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      SsoPlatformCredentialResponse,
      "SsoPlatformCredentialResponse"
    );
  }
};

// src/generated-admin/SsoCredentialAdminApi.ts
function SsoCredentialAdminApi(sdk, args) {
  const sdkAssembly = sdk.assembly();
  const namespace = args?.coreConfig?.namespace ?? sdkAssembly.coreConfig.namespace;
  const useSchemaValidation = args?.coreConfig?.useSchemaValidation ?? sdkAssembly.coreConfig.useSchemaValidation;
  let axiosInstance = sdkAssembly.axiosInstance;
  const requestConfigOverrides = args?.axiosConfig?.request;
  const baseURLOverride = args?.coreConfig?.baseURL;
  const interceptorsOverride = args?.axiosConfig?.interceptors ?? [];
  if (requestConfigOverrides || baseURLOverride || interceptorsOverride.length > 0) {
    const requestConfig = import_sdk26.ApiUtils.mergeAxiosConfigs(sdkAssembly.axiosInstance.defaults, {
      ...baseURLOverride ? { baseURL: baseURLOverride } : {},
      ...requestConfigOverrides
    });
    axiosInstance = import_sdk26.Network.create(requestConfig);
    for (const interceptor of interceptorsOverride) {
      if (interceptor.type === "request") {
        axiosInstance.interceptors.request.use(interceptor.onRequest, interceptor.onError);
      }
      if (interceptor.type === "response") {
        axiosInstance.interceptors.response.use(interceptor.onSuccess, interceptor.onError);
      }
    }
  }
  async function getPlatformsSso_v3(queryParams) {
    const $ = new SsoCredentialAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getPlatformsSso_v3(queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function deleteSso_ByPlatformId_v3(platformId) {
    const $ = new SsoCredentialAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.deleteSso_ByPlatformId_v3(platformId);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getSso_ByPlatformId_v3(platformId) {
    const $ = new SsoCredentialAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getSso_ByPlatformId_v3(platformId);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function patchSso_ByPlatformId_v3(platformId, data) {
    const $ = new SsoCredentialAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.patchSso_ByPlatformId_v3(platformId, data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function createSso_ByPlatformId_v3(platformId, data) {
    const $ = new SsoCredentialAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.createSso_ByPlatformId_v3(platformId, data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  return {
    /**
     * This is the API to Get All Active SSO Platform Credential.
     */
    getPlatformsSso_v3,
    /**
     * This is the API to Delete SSO Platform Credential.
     */
    deleteSso_ByPlatformId_v3,
    /**
     * This is the API to Get SSO Platform Credential.
     */
    getSso_ByPlatformId_v3,
    /**
     * This is the API to Delete SSO Platform Credential.
     */
    patchSso_ByPlatformId_v3,
    /**
     * This is the API to Add SSO Platform Credential. ## Supported platforms: - **discourse** the ssoUrl of the discourse is the discourse forum url. example: https://forum.example.com - **azure with SAML** **appId** is an application identifier in IdP, in azure it&#39;s called EntityID **acsUrl** is an endpoint on the service provider where the identity provider will redirect to with its authentication response. example: /iam/v3/sso/saml/azuresaml/authenticate **federationMetadataUrl** is an endpoint on the Identity Provider(IdP) to get IdP federation metadata for service provider to build trust relationship
     */
    createSso_ByPlatformId_v3
  };
}

// src/generated-admin/queries/SsoCredentialAdmin.query.ts
var Key_SsoCredentialAdmin = /* @__PURE__ */ ((Key_SsoCredentialAdmin2) => {
  Key_SsoCredentialAdmin2["PlatformsSso_v3"] = "Iam.SsoCredentialAdmin.PlatformsSso_v3";
  Key_SsoCredentialAdmin2["Sso_ByPlatformId_v3"] = "Iam.SsoCredentialAdmin.Sso_ByPlatformId_v3";
  return Key_SsoCredentialAdmin2;
})(Key_SsoCredentialAdmin || {});
var useSsoCredentialAdminApi_GetPlatformsSso_v3 = (sdk, input, options, callback) => {
  const queryFn = (sdk2, input2) => async () => {
    const response = await SsoCredentialAdminApi(sdk2, { coreConfig: input2.coreConfig, axiosConfig: input2.axiosConfig }).getPlatformsSso_v3(
      input2.queryParams
    );
    callback && callback(response);
    return response.data;
  };
  return (0, import_react_query13.useQuery)({
    queryKey: ["Iam.SsoCredentialAdmin.PlatformsSso_v3" /* PlatformsSso_v3 */, input],
    queryFn: queryFn(sdk, input),
    ...options
  });
};
var useSsoCredentialAdminApi_DeleteSso_ByPlatformIdMutation_v3 = (sdk, options, callback) => {
  const mutationFn = async (input) => {
    const response = await SsoCredentialAdminApi(sdk, {
      coreConfig: input.coreConfig,
      axiosConfig: input.axiosConfig
    }).deleteSso_ByPlatformId_v3(input.platformId);
    callback && callback(response.data);
    return response.data;
  };
  return (0, import_react_query13.useMutation)({
    mutationKey: ["Iam.SsoCredentialAdmin.Sso_ByPlatformId_v3" /* Sso_ByPlatformId_v3 */],
    mutationFn,
    ...options
  });
};
var useSsoCredentialAdminApi_GetSso_ByPlatformId_v3 = (sdk, input, options, callback) => {
  const queryFn = (sdk2, input2) => async () => {
    const response = await SsoCredentialAdminApi(sdk2, {
      coreConfig: input2.coreConfig,
      axiosConfig: input2.axiosConfig
    }).getSso_ByPlatformId_v3(input2.platformId);
    callback && callback(response);
    return response.data;
  };
  return (0, import_react_query13.useQuery)({
    queryKey: ["Iam.SsoCredentialAdmin.Sso_ByPlatformId_v3" /* Sso_ByPlatformId_v3 */, input],
    queryFn: queryFn(sdk, input),
    ...options
  });
};
var useSsoCredentialAdminApi_PatchSso_ByPlatformIdMutation_v3 = (sdk, options, callback) => {
  const mutationFn = async (input) => {
    const response = await SsoCredentialAdminApi(sdk, {
      coreConfig: input.coreConfig,
      axiosConfig: input.axiosConfig
    }).patchSso_ByPlatformId_v3(input.platformId, input.data);
    callback && callback(response.data);
    return response.data;
  };
  return (0, import_react_query13.useMutation)({
    mutationKey: ["Iam.SsoCredentialAdmin.Sso_ByPlatformId_v3" /* Sso_ByPlatformId_v3 */],
    mutationFn,
    ...options
  });
};
var useSsoCredentialAdminApi_CreateSso_ByPlatformIdMutation_v3 = (sdk, options, callback) => {
  const mutationFn = async (input) => {
    const response = await SsoCredentialAdminApi(sdk, {
      coreConfig: input.coreConfig,
      axiosConfig: input.axiosConfig
    }).createSso_ByPlatformId_v3(input.platformId, input.data);
    callback && callback(response.data);
    return response.data;
  };
  return (0, import_react_query13.useMutation)({
    mutationKey: ["Iam.SsoCredentialAdmin.Sso_ByPlatformId_v3" /* Sso_ByPlatformId_v3 */],
    mutationFn,
    ...options
  });
};

// src/generated-admin/queries/ThirdPartyCredentialAdmin.query.ts
var import_react_query14 = require("@tanstack/react-query");

// src/generated-admin/ThirdPartyCredentialAdminApi.ts
var import_sdk28 = require("@accelbyte/sdk");

// src/generated-admin/endpoints/ThirdPartyCredentialAdmin$.ts
var import_sdk27 = require("@accelbyte/sdk");
var import_zod85 = require("zod");

// src/generated-definitions/CheckAvailabilityResponse.ts
var import_zod79 = require("zod");
var CheckAvailabilityResponse = import_zod79.z.object({ Accessible: import_zod79.z.boolean(), PlatformErrorMessage: import_zod79.z.record(import_zod79.z.string()) });

// src/generated-definitions/PlatformDomainResponse.ts
var import_zod81 = require("zod");

// src/generated-definitions/RegisteredDomain.ts
var import_zod80 = require("zod");
var RegisteredDomain = import_zod80.z.object({
  affectedClientIDs: import_zod80.z.array(import_zod80.z.string()),
  domain: import_zod80.z.string(),
  namespaces: import_zod80.z.array(import_zod80.z.string()),
  roleId: import_zod80.z.string()
});

// src/generated-definitions/PlatformDomainResponse.ts
var PlatformDomainResponse = import_zod81.z.object({ registeredDomains: import_zod81.z.array(RegisteredDomain) });

// src/generated-definitions/ThirdPartyLoginPlatformCredentialResponse.ts
var import_zod83 = require("zod");

// src/generated-definitions/NetflixCertificates.ts
var import_zod82 = require("zod");
var NetflixCertificates = import_zod82.z.object({
  encryptedPrivateKey: import_zod82.z.string(),
  encryptedPrivateKeyName: import_zod82.z.string(),
  publicCertificate: import_zod82.z.string(),
  publicCertificateName: import_zod82.z.string(),
  rootCertificate: import_zod82.z.string(),
  rootCertificateName: import_zod82.z.string()
});

// src/generated-definitions/ThirdPartyLoginPlatformCredentialResponse.ts
var ThirdPartyLoginPlatformCredentialResponse = import_zod83.z.object({
  ACSURL: import_zod83.z.string(),
  AWSCognitoRegion: import_zod83.z.string(),
  AWSCognitoUserPool: import_zod83.z.string(),
  AllowedClients: import_zod83.z.array(import_zod83.z.string()).nullish(),
  AppId: import_zod83.z.string(),
  AuthorizationEndpoint: import_zod83.z.string().nullish(),
  ClientId: import_zod83.z.string(),
  EnableServerLicenseValidation: import_zod83.z.boolean(),
  Environment: import_zod83.z.string(),
  FederationMetadataURL: import_zod83.z.string(),
  GenericOauthFlow: import_zod83.z.boolean(),
  IncludePUID: import_zod83.z.boolean().nullish(),
  IsActive: import_zod83.z.boolean(),
  Issuer: import_zod83.z.string(),
  JWKSEndpoint: import_zod83.z.string(),
  KeyID: import_zod83.z.string(),
  LogoURL: import_zod83.z.string().nullish(),
  Namespace: import_zod83.z.string(),
  NetflixCertificates: NetflixCertificates.nullish(),
  OrganizationId: import_zod83.z.string(),
  PlatformId: import_zod83.z.string(),
  PlatformName: import_zod83.z.string(),
  RedirectUri: import_zod83.z.string(),
  Secret: import_zod83.z.string(),
  TeamID: import_zod83.z.string(),
  TokenAuthenticationType: import_zod83.z.string(),
  TokenClaimsMapping: import_zod83.z.record(import_zod83.z.string()).nullish(),
  TokenEndpoint: import_zod83.z.string().nullish(),
  UserInfoEndpoint: import_zod83.z.string().nullish(),
  UserInfoHTTPMethod: import_zod83.z.string().nullish(),
  registeredDomains: import_zod83.z.array(RegisteredDomain).nullish(),
  scopes: import_zod83.z.array(import_zod83.z.string()).nullish()
});

// src/generated-definitions/ThirdPartyLoginPlatformCredentialResponseArray.ts
var import_zod84 = require("zod");
var ThirdPartyLoginPlatformCredentialResponseArray = import_zod84.z.array(ThirdPartyLoginPlatformCredentialResponse);

// src/generated-admin/endpoints/ThirdPartyCredentialAdmin$.ts
var ThirdPartyCredentialAdmin$ = class {
  // @ts-ignore
  // prettier-ignore
  constructor(axiosInstance, namespace, useSchemaValidation = true) {
    this.axiosInstance = axiosInstance;
    this.namespace = namespace;
    this.useSchemaValidation = useSchemaValidation;
  }
  /**
   * This is the API to check specific 3rd party platform availability. Passing platform group name or it&#39;s member will return same platform availability data Supported third party platform and platform group: - PSN group(psn) - ps4web - ps4 - ps5
   */
  getAvailability_ByPlatformId_v3(platformId) {
    const params = {};
    const url = "/iam/v3/admin/platforms/{platformId}/availability".replace("{platformId}", platformId);
    const resultPromise = this.axiosInstance.get(url, { params });
    return import_sdk27.Validate.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      CheckAvailabilityResponse,
      "CheckAvailabilityResponse"
    );
  }
  /**
   * This is the API to Get All Active 3rd Platform Credential.
   */
  getPlatformsAllClients_v3() {
    const params = {};
    const url = "/iam/v3/admin/namespaces/{namespace}/platforms/all/clients".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.get(url, { params });
    return import_sdk27.Validate.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      ThirdPartyLoginPlatformCredentialResponseArray,
      "ThirdPartyLoginPlatformCredentialResponseArray"
    );
  }
  /**
   * This is the API to Get All Active 3rd Platform Credential.
   */
  getPlatformsAllClientsActive_v3() {
    const params = {};
    const url = "/iam/v3/admin/namespaces/{namespace}/platforms/all/clients/active".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.get(url, { params });
    return import_sdk27.Validate.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      ThirdPartyLoginPlatformCredentialResponseArray,
      "ThirdPartyLoginPlatformCredentialResponseArray"
    );
  }
  /**
   * This is the API to Delete 3rd Platform Credential.
   */
  deleteClient_ByPlatformId_v3(platformId) {
    const params = {};
    const url = "/iam/v3/admin/namespaces/{namespace}/platforms/{platformId}/clients".replace("{namespace}", this.namespace).replace("{platformId}", platformId);
    const resultPromise = this.axiosInstance.delete(url, { params });
    return import_sdk27.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, import_zod85.z.unknown(), "z.unknown()");
  }
  /**
   * This is the API to Get 3rd Platform Credential.
   */
  getClients_ByPlatformId_v3(platformId) {
    const params = {};
    const url = "/iam/v3/admin/namespaces/{namespace}/platforms/{platformId}/clients".replace("{namespace}", this.namespace).replace("{platformId}", platformId);
    const resultPromise = this.axiosInstance.get(url, { params });
    return import_sdk27.Validate.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      ThirdPartyLoginPlatformCredentialResponse,
      "ThirdPartyLoginPlatformCredentialResponse"
    );
  }
  /**
   * This is the API to Add 3rd Platform Credential. - The secret for **apple** is base64 encoded private key. - No secret for **awscognito**, we only need to configure AWS Cognito Region and User Pool - The secret for **discord** is client secret of the twitch client id. - The secret for **epicgames** is client secret of the epicgames client id. - The secret for **facebook** is client secret of the facebook client id. - The secret for **google** is client secret of the google OAuth client. - No secret for **nintendo**, we only need to configure app id of the game - No secret for **netflix**, we configure the Root, Public, Private Key certificate pem file and target environment; value: [sandbox, production] - The secret for **oculus** is app secret of the oculus app. - The secret for **ps4, ps5, and ps4web** is client secret of the psn web server. - The secret for **steam** is the Steam Web API Key. - The secret for **steamopenid** is the Steam Web API Key. - The secret for **twitch** is client secret of the twitch client. - The secret for **live** is the Relying Party Private Key in base64 encode PEM format. - The secret for **xblwebapi** is client secret of the xbl client. If generic oauth flow is set to true: - Current supported value for TokenAuthenticationType is **code, idToken and bearerToken** - &lt;code&gt;TokenClaimsMapping&lt;/code&gt; is used to extract user info from idToken claims or user info endpoint response accessed using bearerToken. Its a JSON format with key should be &lt;code&gt;name&lt;/code&gt;, &lt;code&gt;email&lt;/code&gt; and &lt;code&gt;avatarUrl&lt;/code&gt; since IAM will look up for these key when extracting user info.**default claims keys : userIdentity/sub, name, email and avatarUrl/picture**
   */
  patchClient_ByPlatformId_v3(platformId, data) {
    const params = {};
    const url = "/iam/v3/admin/namespaces/{namespace}/platforms/{platformId}/clients".replace("{namespace}", this.namespace).replace("{platformId}", platformId);
    const resultPromise = this.axiosInstance.patch(url, data, { params });
    return import_sdk27.Validate.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      ThirdPartyLoginPlatformCredentialResponse,
      "ThirdPartyLoginPlatformCredentialResponse"
    );
  }
  /**
   * This is the API to Add 3rd Platform Credential. - The secret for **apple** is base64 encoded private key. - No secret for **awscognito**, we only need to configure AWS Cognito Region and User Pool - The secret for **discord** is client secret of the twitch client id. - The secret for **epicgames** is client secret of the epicgames client id. - The secret for **facebook** is client secret of the facebook client id. - The secret for **google** is client secret of the google OAuth client. - No secret for **nintendo**, we only need to configure app id of the game - No secret for **netflix**, we configure the Root, Public, Private Key certificate pem file and target environment; value: [sandbox, production] - The secret for **oculus** is app secret of the oculus app. - The secret for **ps4, ps5, and ps4web** is client secret of the psn web server. - The secret for **steam** is the Steam Web API Key. - The secret for **steamopenid** is the Steam Web API Key. - The secret for **twitch** is client secret of the twitch client. - The secret for **live** is the Relying Party Private Key in base64 encode PEM format. - The secret for **xblwebapi** is client secret of the xbl client. If generic oauth flow is set to true: - Current supported value for TokenAuthenticationType are **code, idToken and bearerToken** - &lt;code&gt;TokenClaimsMapping&lt;/code&gt; is used to extract user info from idToken claims or user info endpoint response accessed using bearerToken. Its a JSON format with key should be &lt;code&gt;name&lt;/code&gt;, &lt;code&gt;email&lt;/code&gt; and &lt;code&gt;avatarUrl&lt;/code&gt; since IAM will look up for these key when extracting user info. **default claims keys : userIdentity/sub, name, email and avatarUrl/picture**
   */
  createClient_ByPlatformId_v3(platformId, data) {
    const params = {};
    const url = "/iam/v3/admin/namespaces/{namespace}/platforms/{platformId}/clients".replace("{namespace}", this.namespace).replace("{platformId}", platformId);
    const resultPromise = this.axiosInstance.post(url, data, { params });
    return import_sdk27.Validate.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      ThirdPartyLoginPlatformCredentialResponse,
      "ThirdPartyLoginPlatformCredentialResponse"
    );
  }
  /**
   * This is the API to unregister 3rd Platform domain.
   */
  deleteClientDomain_ByPlatformId_v3(platformId, data) {
    const params = {};
    const url = "/iam/v3/admin/namespaces/{namespace}/platforms/{platformId}/clients/domain".replace("{namespace}", this.namespace).replace("{platformId}", platformId);
    const resultPromise = this.axiosInstance.delete(url, { data, params });
    return import_sdk27.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, import_zod85.z.unknown(), "z.unknown()");
  }
  /**
   * This is the API to set 3rd Platform domain.
   */
  updateClientDomain_ByPlatformId_v3(platformId, data) {
    const params = {};
    const url = "/iam/v3/admin/namespaces/{namespace}/platforms/{platformId}/clients/domain".replace("{namespace}", this.namespace).replace("{platformId}", platformId);
    const resultPromise = this.axiosInstance.put(url, data, { params });
    return import_sdk27.Validate.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      PlatformDomainResponse,
      "PlatformDomainResponse"
    );
  }
};

// src/generated-admin/ThirdPartyCredentialAdminApi.ts
function ThirdPartyCredentialAdminApi(sdk, args) {
  const sdkAssembly = sdk.assembly();
  const namespace = args?.coreConfig?.namespace ?? sdkAssembly.coreConfig.namespace;
  const useSchemaValidation = args?.coreConfig?.useSchemaValidation ?? sdkAssembly.coreConfig.useSchemaValidation;
  let axiosInstance = sdkAssembly.axiosInstance;
  const requestConfigOverrides = args?.axiosConfig?.request;
  const baseURLOverride = args?.coreConfig?.baseURL;
  const interceptorsOverride = args?.axiosConfig?.interceptors ?? [];
  if (requestConfigOverrides || baseURLOverride || interceptorsOverride.length > 0) {
    const requestConfig = import_sdk28.ApiUtils.mergeAxiosConfigs(sdkAssembly.axiosInstance.defaults, {
      ...baseURLOverride ? { baseURL: baseURLOverride } : {},
      ...requestConfigOverrides
    });
    axiosInstance = import_sdk28.Network.create(requestConfig);
    for (const interceptor of interceptorsOverride) {
      if (interceptor.type === "request") {
        axiosInstance.interceptors.request.use(interceptor.onRequest, interceptor.onError);
      }
      if (interceptor.type === "response") {
        axiosInstance.interceptors.response.use(interceptor.onSuccess, interceptor.onError);
      }
    }
  }
  async function getAvailability_ByPlatformId_v3(platformId) {
    const $ = new ThirdPartyCredentialAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getAvailability_ByPlatformId_v3(platformId);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getPlatformsAllClients_v3() {
    const $ = new ThirdPartyCredentialAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getPlatformsAllClients_v3();
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getPlatformsAllClientsActive_v3() {
    const $ = new ThirdPartyCredentialAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getPlatformsAllClientsActive_v3();
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function deleteClient_ByPlatformId_v3(platformId) {
    const $ = new ThirdPartyCredentialAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.deleteClient_ByPlatformId_v3(platformId);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getClients_ByPlatformId_v3(platformId) {
    const $ = new ThirdPartyCredentialAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getClients_ByPlatformId_v3(platformId);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function patchClient_ByPlatformId_v3(platformId, data) {
    const $ = new ThirdPartyCredentialAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.patchClient_ByPlatformId_v3(platformId, data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function createClient_ByPlatformId_v3(platformId, data) {
    const $ = new ThirdPartyCredentialAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.createClient_ByPlatformId_v3(platformId, data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function deleteClientDomain_ByPlatformId_v3(platformId, data) {
    const $ = new ThirdPartyCredentialAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.deleteClientDomain_ByPlatformId_v3(platformId, data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function updateClientDomain_ByPlatformId_v3(platformId, data) {
    const $ = new ThirdPartyCredentialAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.updateClientDomain_ByPlatformId_v3(platformId, data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  return {
    /**
     * This is the API to check specific 3rd party platform availability. Passing platform group name or it&#39;s member will return same platform availability data Supported third party platform and platform group: - PSN group(psn) - ps4web - ps4 - ps5
     */
    getAvailability_ByPlatformId_v3,
    /**
     * This is the API to Get All Active 3rd Platform Credential.
     */
    getPlatformsAllClients_v3,
    /**
     * This is the API to Get All Active 3rd Platform Credential.
     */
    getPlatformsAllClientsActive_v3,
    /**
     * This is the API to Delete 3rd Platform Credential.
     */
    deleteClient_ByPlatformId_v3,
    /**
     * This is the API to Get 3rd Platform Credential.
     */
    getClients_ByPlatformId_v3,
    /**
     * This is the API to Add 3rd Platform Credential. - The secret for **apple** is base64 encoded private key. - No secret for **awscognito**, we only need to configure AWS Cognito Region and User Pool - The secret for **discord** is client secret of the twitch client id. - The secret for **epicgames** is client secret of the epicgames client id. - The secret for **facebook** is client secret of the facebook client id. - The secret for **google** is client secret of the google OAuth client. - No secret for **nintendo**, we only need to configure app id of the game - No secret for **netflix**, we configure the Root, Public, Private Key certificate pem file and target environment; value: [sandbox, production] - The secret for **oculus** is app secret of the oculus app. - The secret for **ps4, ps5, and ps4web** is client secret of the psn web server. - The secret for **steam** is the Steam Web API Key. - The secret for **steamopenid** is the Steam Web API Key. - The secret for **twitch** is client secret of the twitch client. - The secret for **live** is the Relying Party Private Key in base64 encode PEM format. - The secret for **xblwebapi** is client secret of the xbl client. If generic oauth flow is set to true: - Current supported value for TokenAuthenticationType is **code, idToken and bearerToken** - &lt;code&gt;TokenClaimsMapping&lt;/code&gt; is used to extract user info from idToken claims or user info endpoint response accessed using bearerToken. Its a JSON format with key should be &lt;code&gt;name&lt;/code&gt;, &lt;code&gt;email&lt;/code&gt; and &lt;code&gt;avatarUrl&lt;/code&gt; since IAM will look up for these key when extracting user info.**default claims keys : userIdentity/sub, name, email and avatarUrl/picture**
     */
    patchClient_ByPlatformId_v3,
    /**
     * This is the API to Add 3rd Platform Credential. - The secret for **apple** is base64 encoded private key. - No secret for **awscognito**, we only need to configure AWS Cognito Region and User Pool - The secret for **discord** is client secret of the twitch client id. - The secret for **epicgames** is client secret of the epicgames client id. - The secret for **facebook** is client secret of the facebook client id. - The secret for **google** is client secret of the google OAuth client. - No secret for **nintendo**, we only need to configure app id of the game - No secret for **netflix**, we configure the Root, Public, Private Key certificate pem file and target environment; value: [sandbox, production] - The secret for **oculus** is app secret of the oculus app. - The secret for **ps4, ps5, and ps4web** is client secret of the psn web server. - The secret for **steam** is the Steam Web API Key. - The secret for **steamopenid** is the Steam Web API Key. - The secret for **twitch** is client secret of the twitch client. - The secret for **live** is the Relying Party Private Key in base64 encode PEM format. - The secret for **xblwebapi** is client secret of the xbl client. If generic oauth flow is set to true: - Current supported value for TokenAuthenticationType are **code, idToken and bearerToken** - &lt;code&gt;TokenClaimsMapping&lt;/code&gt; is used to extract user info from idToken claims or user info endpoint response accessed using bearerToken. Its a JSON format with key should be &lt;code&gt;name&lt;/code&gt;, &lt;code&gt;email&lt;/code&gt; and &lt;code&gt;avatarUrl&lt;/code&gt; since IAM will look up for these key when extracting user info. **default claims keys : userIdentity/sub, name, email and avatarUrl/picture**
     */
    createClient_ByPlatformId_v3,
    /**
     * This is the API to unregister 3rd Platform domain.
     */
    deleteClientDomain_ByPlatformId_v3,
    /**
     * This is the API to set 3rd Platform domain.
     */
    updateClientDomain_ByPlatformId_v3
  };
}

// src/generated-admin/queries/ThirdPartyCredentialAdmin.query.ts
var Key_ThirdPartyCredentialAdmin = /* @__PURE__ */ ((Key_ThirdPartyCredentialAdmin2) => {
  Key_ThirdPartyCredentialAdmin2["Availability_ByPlatformId_v3"] = "Iam.ThirdPartyCredentialAdmin.Availability_ByPlatformId_v3";
  Key_ThirdPartyCredentialAdmin2["PlatformsAllClients_v3"] = "Iam.ThirdPartyCredentialAdmin.PlatformsAllClients_v3";
  Key_ThirdPartyCredentialAdmin2["PlatformsAllClientsActive_v3"] = "Iam.ThirdPartyCredentialAdmin.PlatformsAllClientsActive_v3";
  Key_ThirdPartyCredentialAdmin2["Client_ByPlatformId_v3"] = "Iam.ThirdPartyCredentialAdmin.Client_ByPlatformId_v3";
  Key_ThirdPartyCredentialAdmin2["Clients_ByPlatformId_v3"] = "Iam.ThirdPartyCredentialAdmin.Clients_ByPlatformId_v3";
  Key_ThirdPartyCredentialAdmin2["ClientDomain_ByPlatformId_v3"] = "Iam.ThirdPartyCredentialAdmin.ClientDomain_ByPlatformId_v3";
  return Key_ThirdPartyCredentialAdmin2;
})(Key_ThirdPartyCredentialAdmin || {});
var useThirdPartyCredentialAdminApi_GetAvailability_ByPlatformId_v3 = (sdk, input, options, callback) => {
  const queryFn = (sdk2, input2) => async () => {
    const response = await ThirdPartyCredentialAdminApi(sdk2, {
      coreConfig: input2.coreConfig,
      axiosConfig: input2.axiosConfig
    }).getAvailability_ByPlatformId_v3(input2.platformId);
    callback && callback(response);
    return response.data;
  };
  return (0, import_react_query14.useQuery)({
    queryKey: ["Iam.ThirdPartyCredentialAdmin.Availability_ByPlatformId_v3" /* Availability_ByPlatformId_v3 */, input],
    queryFn: queryFn(sdk, input),
    ...options
  });
};
var useThirdPartyCredentialAdminApi_GetPlatformsAllClients_v3 = (sdk, input, options, callback) => {
  const queryFn = (sdk2, input2) => async () => {
    const response = await ThirdPartyCredentialAdminApi(sdk2, {
      coreConfig: input2.coreConfig,
      axiosConfig: input2.axiosConfig
    }).getPlatformsAllClients_v3();
    callback && callback(response);
    return response.data;
  };
  return (0, import_react_query14.useQuery)({
    queryKey: ["Iam.ThirdPartyCredentialAdmin.PlatformsAllClients_v3" /* PlatformsAllClients_v3 */, input],
    queryFn: queryFn(sdk, input),
    ...options
  });
};
var useThirdPartyCredentialAdminApi_GetPlatformsAllClientsActive_v3 = (sdk, input, options, callback) => {
  const queryFn = (sdk2, input2) => async () => {
    const response = await ThirdPartyCredentialAdminApi(sdk2, {
      coreConfig: input2.coreConfig,
      axiosConfig: input2.axiosConfig
    }).getPlatformsAllClientsActive_v3();
    callback && callback(response);
    return response.data;
  };
  return (0, import_react_query14.useQuery)({
    queryKey: ["Iam.ThirdPartyCredentialAdmin.PlatformsAllClientsActive_v3" /* PlatformsAllClientsActive_v3 */, input],
    queryFn: queryFn(sdk, input),
    ...options
  });
};
var useThirdPartyCredentialAdminApi_DeleteClient_ByPlatformIdMutation_v3 = (sdk, options, callback) => {
  const mutationFn = async (input) => {
    const response = await ThirdPartyCredentialAdminApi(sdk, {
      coreConfig: input.coreConfig,
      axiosConfig: input.axiosConfig
    }).deleteClient_ByPlatformId_v3(input.platformId);
    callback && callback(response.data);
    return response.data;
  };
  return (0, import_react_query14.useMutation)({
    mutationKey: ["Iam.ThirdPartyCredentialAdmin.Client_ByPlatformId_v3" /* Client_ByPlatformId_v3 */],
    mutationFn,
    ...options
  });
};
var useThirdPartyCredentialAdminApi_GetClients_ByPlatformId_v3 = (sdk, input, options, callback) => {
  const queryFn = (sdk2, input2) => async () => {
    const response = await ThirdPartyCredentialAdminApi(sdk2, {
      coreConfig: input2.coreConfig,
      axiosConfig: input2.axiosConfig
    }).getClients_ByPlatformId_v3(input2.platformId);
    callback && callback(response);
    return response.data;
  };
  return (0, import_react_query14.useQuery)({
    queryKey: ["Iam.ThirdPartyCredentialAdmin.Clients_ByPlatformId_v3" /* Clients_ByPlatformId_v3 */, input],
    queryFn: queryFn(sdk, input),
    ...options
  });
};
var useThirdPartyCredentialAdminApi_PatchClient_ByPlatformIdMutation_v3 = (sdk, options, callback) => {
  const mutationFn = async (input) => {
    const response = await ThirdPartyCredentialAdminApi(sdk, {
      coreConfig: input.coreConfig,
      axiosConfig: input.axiosConfig
    }).patchClient_ByPlatformId_v3(input.platformId, input.data);
    callback && callback(response.data);
    return response.data;
  };
  return (0, import_react_query14.useMutation)({
    mutationKey: ["Iam.ThirdPartyCredentialAdmin.Client_ByPlatformId_v3" /* Client_ByPlatformId_v3 */],
    mutationFn,
    ...options
  });
};
var useThirdPartyCredentialAdminApi_CreateClient_ByPlatformIdMutation_v3 = (sdk, options, callback) => {
  const mutationFn = async (input) => {
    const response = await ThirdPartyCredentialAdminApi(sdk, {
      coreConfig: input.coreConfig,
      axiosConfig: input.axiosConfig
    }).createClient_ByPlatformId_v3(input.platformId, input.data);
    callback && callback(response.data);
    return response.data;
  };
  return (0, import_react_query14.useMutation)({
    mutationKey: ["Iam.ThirdPartyCredentialAdmin.Client_ByPlatformId_v3" /* Client_ByPlatformId_v3 */],
    mutationFn,
    ...options
  });
};
var useThirdPartyCredentialAdminApi_DeleteClientDomain_ByPlatformIdMutation_v3 = (sdk, options, callback) => {
  const mutationFn = async (input) => {
    const response = await ThirdPartyCredentialAdminApi(sdk, {
      coreConfig: input.coreConfig,
      axiosConfig: input.axiosConfig
    }).deleteClientDomain_ByPlatformId_v3(input.platformId, input.data);
    callback && callback(response.data);
    return response.data;
  };
  return (0, import_react_query14.useMutation)({
    mutationKey: ["Iam.ThirdPartyCredentialAdmin.ClientDomain_ByPlatformId_v3" /* ClientDomain_ByPlatformId_v3 */],
    mutationFn,
    ...options
  });
};
var useThirdPartyCredentialAdminApi_UpdateClientDomain_ByPlatformIdMutation_v3 = (sdk, options, callback) => {
  const mutationFn = async (input) => {
    const response = await ThirdPartyCredentialAdminApi(sdk, {
      coreConfig: input.coreConfig,
      axiosConfig: input.axiosConfig
    }).updateClientDomain_ByPlatformId_v3(input.platformId, input.data);
    callback && callback(response.data);
    return response.data;
  };
  return (0, import_react_query14.useMutation)({
    mutationKey: ["Iam.ThirdPartyCredentialAdmin.ClientDomain_ByPlatformId_v3" /* ClientDomain_ByPlatformId_v3 */],
    mutationFn,
    ...options
  });
};

// src/generated-admin/queries/UsersAdmin.query.ts
var import_react_query15 = require("@tanstack/react-query");

// src/generated-admin/UsersAdminApi.ts
var import_sdk30 = require("@accelbyte/sdk");

// src/generated-admin/endpoints/UsersAdmin$.ts
var import_sdk29 = require("@accelbyte/sdk");
var import_zod139 = require("zod");

// src/generated-definitions/AgeRestrictionResponse.ts
var import_zod86 = require("zod");
var AgeRestrictionResponse = import_zod86.z.object({ AgeRestriction: import_zod86.z.number().int(), Enable: import_zod86.z.boolean() });

// src/generated-definitions/AgeRestrictionResponseV3.ts
var import_zod87 = require("zod");
var AgeRestrictionResponseV3 = import_zod87.z.object({ ageRestriction: import_zod87.z.number().int(), enable: import_zod87.z.boolean() });

// src/generated-definitions/Country.ts
var import_zod88 = require("zod");
var Country = import_zod88.z.object({ AgeRestriction: import_zod88.z.number().int(), CountryCode: import_zod88.z.string(), CountryName: import_zod88.z.string(), Enable: import_zod88.z.boolean() });

// src/generated-definitions/CountryAgeRestrictionArray.ts
var import_zod90 = require("zod");

// src/generated-definitions/CountryAgeRestriction.ts
var import_zod89 = require("zod");
var CountryAgeRestriction = import_zod89.z.object({
  AgeRestriction: import_zod89.z.number().int(),
  CountryCode: import_zod89.z.string(),
  CountryName: import_zod89.z.string(),
  Enable: import_zod89.z.boolean()
});

// src/generated-definitions/CountryAgeRestrictionArray.ts
var CountryAgeRestrictionArray = import_zod90.z.array(CountryAgeRestriction);

// src/generated-definitions/CountryV3Response.ts
var import_zod91 = require("zod");
var CountryV3Response = import_zod91.z.object({
  ageRestriction: import_zod91.z.number().int(),
  countryCode: import_zod91.z.string(),
  countryName: import_zod91.z.string(),
  enable: import_zod91.z.boolean()
});

// src/generated-definitions/CountryV3ResponseArray.ts
var import_zod92 = require("zod");
var CountryV3ResponseArray = import_zod92.z.array(CountryV3Response);

// src/generated-definitions/CreateJusticeUserResponse.ts
var import_zod93 = require("zod");
var CreateJusticeUserResponse = import_zod93.z.object({ namespace: import_zod93.z.string(), userId: import_zod93.z.string() });

// src/generated-definitions/DistinctPlatformResponseV3.ts
var import_zod96 = require("zod");

// src/generated-definitions/DistinctLinkedPlatformV3.ts
var import_zod95 = require("zod");

// src/generated-definitions/SimpleUserPlatformInfoV3.ts
var import_zod94 = require("zod");
var SimpleUserPlatformInfoV3 = import_zod94.z.object({
  displayName: import_zod94.z.string().nullish(),
  linkedAt: import_zod94.z.string(),
  namespace: import_zod94.z.string(),
  originNamespace: import_zod94.z.string(),
  platformId: import_zod94.z.string().nullish()
});

// src/generated-definitions/DistinctLinkedPlatformV3.ts
var DistinctLinkedPlatformV3 = import_zod95.z.object({
  details: import_zod95.z.array(SimpleUserPlatformInfoV3).nullish(),
  linkedAt: import_zod95.z.string(),
  logoURL: import_zod95.z.string().nullish(),
  platformDisplayName: import_zod95.z.string().nullish(),
  platformGroup: import_zod95.z.string(),
  platformName: import_zod95.z.string(),
  platformUserId: import_zod95.z.string().nullish(),
  status: import_zod95.z.string()
});

// src/generated-definitions/DistinctPlatformResponseV3.ts
var DistinctPlatformResponseV3 = import_zod96.z.object({ platforms: import_zod96.z.array(DistinctLinkedPlatformV3) });

// src/generated-definitions/GetUserBanSummaryV3.ts
var import_zod98 = require("zod");

// src/generated-definitions/UserBanWithStatus.ts
var import_zod97 = require("zod");
var UserBanWithStatus = import_zod97.z.object({
  active: import_zod97.z.boolean(),
  ban: import_zod97.z.string(),
  banId: import_zod97.z.string(),
  bannedBy: BannedByV3,
  comment: import_zod97.z.string(),
  createdAt: import_zod97.z.string(),
  disabledDate: import_zod97.z.string(),
  enabled: import_zod97.z.boolean(),
  endDate: import_zod97.z.string(),
  namespace: import_zod97.z.string(),
  reason: import_zod97.z.string(),
  userId: import_zod97.z.string()
});

// src/generated-definitions/GetUserBanSummaryV3.ts
var GetUserBanSummaryV3 = import_zod98.z.object({
  activeCount: import_zod98.z.number().int(),
  data: import_zod98.z.array(UserBanWithStatus),
  inactiveCount: import_zod98.z.number().int(),
  totalCount: import_zod98.z.number().int()
});

// src/generated-definitions/GetUserMappingArray.ts
var import_zod100 = require("zod");

// src/generated-definitions/GetUserMapping.ts
var import_zod99 = require("zod");
var GetUserMapping = import_zod99.z.object({ Namespace: import_zod99.z.string(), UserId: import_zod99.z.string() });

// src/generated-definitions/GetUserMappingArray.ts
var GetUserMappingArray = import_zod100.z.array(GetUserMapping);

// src/generated-definitions/GetUserMappingV3.ts
var import_zod101 = require("zod");
var GetUserMappingV3 = import_zod101.z.object({ namespace: import_zod101.z.string(), userId: import_zod101.z.string() });

// src/generated-definitions/GetUsersResponseWithPaginationV3.ts
var import_zod107 = require("zod");

// src/generated-definitions/UserResponseV3.ts
var import_zod106 = require("zod");

// src/generated-definitions/NamespaceRole.ts
var import_zod102 = require("zod");
var NamespaceRole = import_zod102.z.object({ namespace: import_zod102.z.string(), roleId: import_zod102.z.string() });

// src/generated-definitions/UserActiveBanResponseV3.ts
var import_zod103 = require("zod");
var UserActiveBanResponseV3 = import_zod103.z.object({ ban: import_zod103.z.string(), banId: import_zod103.z.string(), endDate: import_zod103.z.string(), targetedNamespace: import_zod103.z.string() });

// src/generated-definitions/UserPermissionsResponseV3.ts
var import_zod104 = require("zod");
var UserPermissionsResponseV3 = import_zod104.z.object({
  action: import_zod104.z.number().int(),
  resource: import_zod104.z.string(),
  schedAction: import_zod104.z.number().int().nullish(),
  schedCron: import_zod104.z.string().nullish(),
  schedRange: import_zod104.z.array(import_zod104.z.string()).nullish()
});

// src/generated-definitions/UserPlatformInfo.ts
var import_zod105 = require("zod");
var UserPlatformInfo = import_zod105.z.object({
  platformAvatarUrl: import_zod105.z.string().nullish(),
  platformDisplayName: import_zod105.z.string().nullish(),
  platformGroup: import_zod105.z.string().nullish(),
  platformId: import_zod105.z.string(),
  platformUserId: import_zod105.z.string().nullish()
});

// src/generated-definitions/UserResponseV3.ts
var UserResponseV3 = import_zod106.z.object({
  authType: import_zod106.z.string(),
  avatarUrl: import_zod106.z.string().nullish(),
  bans: import_zod106.z.array(UserActiveBanResponseV3),
  country: import_zod106.z.string(),
  createdAt: import_zod106.z.string(),
  dateOfBirth: import_zod106.z.string().nullish(),
  deletionDate: import_zod106.z.string().nullish(),
  deletionStatus: import_zod106.z.boolean(),
  displayName: import_zod106.z.string(),
  emailAddress: import_zod106.z.string(),
  emailVerified: import_zod106.z.boolean(),
  enabled: import_zod106.z.boolean(),
  lastDateOfBirthChangedTime: import_zod106.z.string(),
  lastEnabledChangedTime: import_zod106.z.string(),
  namespace: import_zod106.z.string(),
  namespaceRoles: import_zod106.z.array(NamespaceRole),
  newEmailAddress: import_zod106.z.string().nullish(),
  oldEmailAddress: import_zod106.z.string().nullish(),
  permissions: import_zod106.z.array(UserPermissionsResponseV3),
  phoneNumber: import_zod106.z.string().nullish(),
  phoneVerified: import_zod106.z.boolean(),
  platformAvatarUrl: import_zod106.z.string().nullish(),
  platformDisplayName: import_zod106.z.string().nullish(),
  platformId: import_zod106.z.string().nullish(),
  platformInfos: import_zod106.z.array(UserPlatformInfo).nullish(),
  platformUserId: import_zod106.z.string().nullish(),
  roles: import_zod106.z.array(import_zod106.z.string()),
  skipLoginQueue: import_zod106.z.boolean().nullish(),
  testAccount: import_zod106.z.boolean().nullish(),
  uniqueDisplayName: import_zod106.z.string().nullish(),
  userId: import_zod106.z.string(),
  userName: import_zod106.z.string().nullish()
});

// src/generated-definitions/GetUsersResponseWithPaginationV3.ts
var GetUsersResponseWithPaginationV3 = import_zod107.z.object({ data: import_zod107.z.array(UserResponseV3), paging: PaginationV3 });

// src/generated-definitions/InviteUserResponseV3.ts
var import_zod109 = require("zod");

// src/generated-definitions/UserInvitationV3.ts
var import_zod108 = require("zod");
var UserInvitationV3 = import_zod108.z.object({
  additionalData: import_zod108.z.string().nullish(),
  email: import_zod108.z.string(),
  expiredAt: import_zod108.z.string(),
  id: import_zod108.z.string().nullish(),
  isNewStudio: import_zod108.z.boolean().nullish(),
  namespace: import_zod108.z.string().nullish(),
  namespaceDisplayName: import_zod108.z.string().nullish(),
  roles: import_zod108.z.array(NamespaceRole),
  studioNamespace: import_zod108.z.string().nullish()
});

// src/generated-definitions/InviteUserResponseV3.ts
var InviteUserResponseV3 = import_zod109.z.object({ data: import_zod109.z.array(UserInvitationV3) });

// src/generated-definitions/LinkingHistoryResponseWithPaginationV3.ts
var import_zod110 = require("zod");
var LinkingHistoryResponseWithPaginationV3 = import_zod110.z.object({
  data: import_zod110.z.array(import_zod110.z.string()),
  paging: PaginationV3,
  totalData: import_zod110.z.number().int()
});

// src/generated-definitions/ListBulkUserPlatformsResponse.ts
var import_zod112 = require("zod");

// src/generated-definitions/UserWithPlatformInfo.ts
var import_zod111 = require("zod");
var UserWithPlatformInfo = import_zod111.z.object({
  avatarUrl: import_zod111.z.string().nullish(),
  displayName: import_zod111.z.string().nullish(),
  platformInfos: import_zod111.z.array(UserPlatformInfo),
  uniqueDisplayName: import_zod111.z.string().nullish(),
  userId: import_zod111.z.string(),
  username: import_zod111.z.string().nullish(),
  xuid: import_zod111.z.string().nullish()
});

// src/generated-definitions/ListBulkUserPlatformsResponse.ts
var ListBulkUserPlatformsResponse = import_zod112.z.object({ data: import_zod112.z.array(UserWithPlatformInfo) });

// src/generated-definitions/ListUserInformationResult.ts
var import_zod114 = require("zod");

// src/generated-definitions/UserInfoResponse.ts
var import_zod113 = require("zod");
var UserInfoResponse = import_zod113.z.object({
  displayName: import_zod113.z.string(),
  emailAddress: import_zod113.z.string(),
  namespace: import_zod113.z.string(),
  uniqueDisplayName: import_zod113.z.string().nullish(),
  userId: import_zod113.z.string()
});

// src/generated-definitions/ListUserInformationResult.ts
var ListUserInformationResult = import_zod114.z.object({ data: import_zod114.z.array(UserInfoResponse) });

// src/generated-definitions/ListUserResponseV3.ts
var import_zod115 = require("zod");
var ListUserResponseV3 = import_zod115.z.object({ data: import_zod115.z.array(UserResponseV3) });

// src/generated-definitions/ListUsersWithPlatformAccountsResponse.ts
var import_zod118 = require("zod");

// src/generated-definitions/UserWithPlatformAccounts.ts
var import_zod117 = require("zod");

// src/generated-definitions/PlatformAccount.ts
var import_zod116 = require("zod");
var PlatformAccount = import_zod116.z.object({ namespace: import_zod116.z.string(), platformId: import_zod116.z.string().nullish(), platformUserId: import_zod116.z.string() });

// src/generated-definitions/UserWithPlatformAccounts.ts
var UserWithPlatformAccounts = import_zod117.z.object({ linkedPlatforms: import_zod117.z.array(PlatformAccount), namespace: import_zod117.z.string(), userId: import_zod117.z.string() });

// src/generated-definitions/ListUsersWithPlatformAccountsResponse.ts
var ListUsersWithPlatformAccountsResponse = import_zod118.z.object({
  data: import_zod118.z.array(UserWithPlatformAccounts),
  paging: PaginationV3,
  totalData: import_zod118.z.number().int()
});

// src/generated-definitions/LoginHistoriesResponse.ts
var import_zod120 = require("zod");

// src/generated-definitions/UserLoginHistoryResponse.ts
var import_zod119 = require("zod");
var UserLoginHistoryResponse = import_zod119.z.object({
  ApplicationName: import_zod119.z.string(),
  City: import_zod119.z.string(),
  Country: import_zod119.z.string(),
  DeviceId: import_zod119.z.string(),
  State: import_zod119.z.string(),
  Timestamp: import_zod119.z.number().int(),
  deviceName: import_zod119.z.string()
});

// src/generated-definitions/LoginHistoriesResponse.ts
var LoginHistoriesResponse = import_zod120.z.object({ Data: import_zod120.z.array(UserLoginHistoryResponse), Paging: Pagination });

// src/generated-definitions/SearchUsersByPlatformIdResponse.ts
var import_zod123 = require("zod");

// src/generated-definitions/UserSearchByPlatformIdResult.ts
var import_zod122 = require("zod");

// src/generated-definitions/UserLinkedPlatform.ts
var import_zod121 = require("zod");
var UserLinkedPlatform = import_zod121.z.object({
  DisplayName: import_zod121.z.string().nullish(),
  EmailAddress: import_zod121.z.string().nullish(),
  LinkedAt: import_zod121.z.string(),
  Namespace: import_zod121.z.string(),
  OriginNamespace: import_zod121.z.string(),
  PlatformId: import_zod121.z.string().nullish(),
  PlatformUserId: import_zod121.z.string().nullish(),
  UserId: import_zod121.z.string(),
  XUID: import_zod121.z.string().nullish()
});

// src/generated-definitions/UserSearchByPlatformIdResult.ts
var UserSearchByPlatformIdResult = import_zod122.z.object({
  DisplayName: import_zod122.z.string(),
  EmailAddress: import_zod122.z.string(),
  LinkedPlatforms: import_zod122.z.array(UserLinkedPlatform),
  PhoneNumber: import_zod122.z.string(),
  UserId: import_zod122.z.string()
});

// src/generated-definitions/SearchUsersByPlatformIdResponse.ts
var SearchUsersByPlatformIdResponse = import_zod123.z.object({ Data: import_zod123.z.array(UserSearchByPlatformIdResult), Paging: Pagination });

// src/generated-definitions/SearchUsersResponseWithPaginationV3.ts
var import_zod124 = require("zod");
var SearchUsersResponseWithPaginationV3 = import_zod124.z.object({
  data: import_zod124.z.array(UserResponseV3),
  paging: PaginationV3,
  totalData: import_zod124.z.number().int()
});

// src/generated-definitions/TokenThirdPartyLinkStatusResponse.ts
var import_zod125 = require("zod");
var TokenThirdPartyLinkStatusResponse = import_zod125.z.object({
  linked: import_zod125.z.boolean(),
  platformToken: import_zod125.z.string().nullish(),
  sandboxId: import_zod125.z.string().nullish()
});

// src/generated-definitions/UserBanResponse.ts
var import_zod127 = require("zod");

// src/generated-definitions/BannedBy.ts
var import_zod126 = require("zod");
var BannedBy = import_zod126.z.object({ DisplayName: import_zod126.z.string(), userId: import_zod126.z.string() });

// src/generated-definitions/UserBanResponse.ts
var UserBanResponse = import_zod127.z.object({
  Ban: import_zod127.z.string(),
  BanId: import_zod127.z.string(),
  BannedBy,
  Comment: import_zod127.z.string(),
  CreatedAt: import_zod127.z.string(),
  DisabledDate: import_zod127.z.string().nullish(),
  Enabled: import_zod127.z.boolean(),
  EndDate: import_zod127.z.string(),
  Namespace: import_zod127.z.string(),
  Reason: import_zod127.z.string(),
  UserId: import_zod127.z.string()
});

// src/generated-definitions/UserBanResponseArray.ts
var import_zod128 = require("zod");
var UserBanResponseArray = import_zod128.z.array(UserBanResponse);

// src/generated-definitions/UserDeletionStatusResponse.ts
var import_zod129 = require("zod");
var UserDeletionStatusResponse = import_zod129.z.object({ deletionStatus: import_zod129.z.boolean() });

// src/generated-definitions/UserLinkedPlatformsResponseV3.ts
var import_zod131 = require("zod");

// src/generated-definitions/UserLinkedPlatformV3.ts
var import_zod130 = require("zod");
var UserLinkedPlatformV3 = import_zod130.z.object({
  accountGroup: import_zod130.z.string(),
  displayName: import_zod130.z.string().nullish(),
  emailAddress: import_zod130.z.string().nullish(),
  linkedAt: import_zod130.z.string(),
  namespace: import_zod130.z.string(),
  originNamespace: import_zod130.z.string(),
  platformId: import_zod130.z.string().nullish(),
  platformUserId: import_zod130.z.string().nullish(),
  userId: import_zod130.z.string(),
  xuid: import_zod130.z.string().nullish()
});

// src/generated-definitions/UserLinkedPlatformsResponseV3.ts
var UserLinkedPlatformsResponseV3 = import_zod131.z.object({ data: import_zod131.z.array(UserLinkedPlatformV3), paging: PaginationV3 });

// src/generated-definitions/UserPlatformLinkHistories.ts
var import_zod133 = require("zod");

// src/generated-definitions/UserPlatformLinkHistory.ts
var import_zod132 = require("zod");
var UserPlatformLinkHistory = import_zod132.z.object({
  action: import_zod132.z.string(),
  actor: import_zod132.z.string(),
  actorType: import_zod132.z.string(),
  createdAt: import_zod132.z.number().int(),
  namespace: import_zod132.z.string(),
  platform: import_zod132.z.string(),
  platformDisplayName: import_zod132.z.string(),
  platformId: import_zod132.z.string(),
  platformUserId: import_zod132.z.string(),
  publisherUserId: import_zod132.z.string()
});

// src/generated-definitions/UserPlatformLinkHistories.ts
var UserPlatformLinkHistories = import_zod133.z.object({ data: import_zod133.z.array(UserPlatformLinkHistory) });

// src/generated-definitions/UserPlatformMetadata.ts
var import_zod134 = require("zod");
var UserPlatformMetadata = import_zod134.z.object({
  metadata: import_zod134.z.record(import_zod134.z.any()),
  namespace: import_zod134.z.string(),
  platformUserId: import_zod134.z.string(),
  userId: import_zod134.z.string()
});

// src/generated-definitions/UserPlatforms.ts
var import_zod135 = require("zod");
var UserPlatforms = import_zod135.z.object({ userIdPlatforms: import_zod135.z.array(UserPlatformInfo) });

// src/generated-definitions/UserResponse.ts
var import_zod137 = require("zod");

// src/generated-definitions/UserActiveBanResponse.ts
var import_zod136 = require("zod");
var UserActiveBanResponse = import_zod136.z.object({ Ban: import_zod136.z.string(), BanId: import_zod136.z.string(), EndDate: import_zod136.z.string() });

// src/generated-definitions/UserResponse.ts
var UserResponse = import_zod137.z.object({
  AuthType: import_zod137.z.string(),
  AvatarUrl: import_zod137.z.string().nullish(),
  Bans: import_zod137.z.array(UserActiveBanResponse),
  Country: import_zod137.z.string(),
  CreatedAt: import_zod137.z.string(),
  DateOfBirth: import_zod137.z.string(),
  DeletionStatus: import_zod137.z.boolean(),
  DisplayName: import_zod137.z.string(),
  EmailAddress: import_zod137.z.string().nullish(),
  EmailVerified: import_zod137.z.boolean(),
  Enabled: import_zod137.z.boolean(),
  LastDateOfBirthChangedTime: import_zod137.z.string(),
  LastEnabledChangedTime: import_zod137.z.string(),
  LoginId: import_zod137.z.string(),
  Namespace: import_zod137.z.string(),
  NamespaceRoles: import_zod137.z.array(NamespaceRole),
  NewEmailAddress: import_zod137.z.string().nullish(),
  OldEmailAddress: import_zod137.z.string(),
  Permissions: import_zod137.z.array(Permission),
  PhoneNumber: import_zod137.z.string().nullish(),
  PhoneVerified: import_zod137.z.boolean(),
  PlatformId: import_zod137.z.string().nullish(),
  PlatformUserId: import_zod137.z.string().nullish(),
  Roles: import_zod137.z.array(import_zod137.z.string()),
  UserId: import_zod137.z.string(),
  Username: import_zod137.z.string().nullish(),
  XUID: import_zod137.z.string().nullish(),
  uniqueDisplayName: import_zod137.z.string().nullish()
});

// src/generated-definitions/VerificationCodeResponse.ts
var import_zod138 = require("zod");
var VerificationCodeResponse = import_zod138.z.object({
  accountRegistration: import_zod138.z.string(),
  accountUpgrade: import_zod138.z.string(),
  passwordReset: import_zod138.z.string(),
  updateEmail: import_zod138.z.string()
});

// src/generated-admin/endpoints/UsersAdmin$.ts
var UsersAdmin$ = class {
  // @ts-ignore
  // prettier-ignore
  constructor(axiosInstance, namespace, useSchemaValidation = true) {
    this.axiosInstance = axiosInstance;
    this.namespace = namespace;
    this.useSchemaValidation = useSchemaValidation;
  }
  /**
   * Get my user data action code : 10147
   */
  getUsersMe_v3() {
    const params = {};
    const url = "/iam/v3/admin/users/me";
    const resultPromise = this.axiosInstance.get(url, { params });
    return import_sdk29.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, UserResponseV3, "UserResponseV3");
  }
  /**
   * @deprecated
   * ## The endpoint is going to be deprecated **Endpoint migration guide** - **Substitute endpoint: _/iam/v3/admin/namespaces/{namespace}/users/search [GET]_**
   */
  getUsers_v2(queryParams) {
    const params = { ...queryParams };
    const url = "/iam/v2/admin/namespaces/{namespace}/users".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.get(url, { params });
    return import_sdk29.Validate.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      SearchUsersByPlatformIdResponse,
      "SearchUsersByPlatformIdResponse"
    );
  }
  /**
   * This endpoint search user who owns the given email address action code : 10132
   */
  getUsers_v3(queryParams) {
    const params = { ...queryParams };
    const url = "/iam/v3/admin/namespaces/{namespace}/users".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.get(url, { params });
    return import_sdk29.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, UserResponseV3, "UserResponseV3");
  }
  /**
   * This endpoint support to bulk update users based on given data. ------ Supported fields: * skipLoginQueue
   */
  updateUser_v3(data) {
    const params = {};
    const url = "/iam/v3/admin/namespaces/{namespace}/users".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.put(url, data, { params });
    return import_sdk29.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, import_zod139.z.unknown(), "z.unknown()");
  }
  /**
   * List all users that has admin role (role that has admin_role attribute set to true). Endpoint behavior : - if query parameter is defined, endpoint will search users whose email address and display name match with the query - if roleId parameter is defined, endpoint will search users that have the defined roleId - if startDate and endDate parameters is defined, endpoint will search users which created on the certain date range - if startDate parameter is defined, endpoint will search users that created start from the defined date - if endDate parameter is defined, endpoint will search users that created until the defined date In multi tenant mode : - if super admin search in super admin namespace, the result will be all admin users - if super admin search in game studio namespace, the result will be all admin users under the game studio namespace - if studio admin search in their studio namespace, the result will be all admin user in the game studio namespace The endpoint will return all admin from all namespace when called from publisher namespace. When not called from publisher namespace, the endpoint will return all admin from the path namespace.
   */
  getAdmins_v3(queryParams) {
    const params = { ...queryParams };
    const url = "/iam/v3/admin/namespaces/{namespace}/admins".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.get(url, { params });
    return import_sdk29.Validate.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      GetUsersResponseWithPaginationV3,
      "GetUsersResponseWithPaginationV3"
    );
  }
  /**
   * This endpoint returns user bans of userIDs specified in the payload action code : 10127
   */
  fetchUserBan_v3(data, queryParams) {
    const params = { ...queryParams };
    const url = "/iam/v3/admin/namespaces/{namespace}/users/bans".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.post(url, data, { params });
    return import_sdk29.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, GetUserBanV3Response, "GetUserBanV3Response");
  }
  /**
   * List User By User ID This endpoint intended to list user information from the given list of userID and namespace
   */
  createUserBulk_v3(data) {
    const params = {};
    const url = "/iam/v3/admin/namespaces/{namespace}/users/bulk".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.post(url, data, { params });
    return import_sdk29.Validate.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      ListUserInformationResult,
      "ListUserInformationResult"
    );
  }
  /**
   * Use this endpoint to invite admin or non-admin user and assign role to them. The role must be scoped to namespace based on the **{namespace}** value in path parameter. An admin user can only assign role to namespaces that the admin user has the required permission. Role is optional, if not specified then it will only assign User role The invited admin will also assigned with &#34;User&#34; role by default.
   */
  createUserInvite_v3(data) {
    const params = {};
    const url = "/iam/v3/admin/namespaces/{namespace}/users/invite".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.post(url, data, { params });
    return import_sdk29.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, InviteUserResponseV3, "InviteUserResponseV3");
  }
  /**
   * Endpoint behavior : - by default this endpoint searches all users on the specified namespace - if query parameter is defined, endpoint will search users whose email address, display name, username, or third party partially match with the query - if startDate and endDate parameters is defined, endpoint will search users which created on the certain date range - if query, startDate and endDate parameters are defined, endpoint will search users whose email address and display name match and created on the certain date range - if startDate parameter is defined, endpoint will search users that created start from the defined date - if endDate parameter is defined, endpoint will search users that created until the defined date - if platformId parameter is defined and by parameter is using thirdparty, endpoint will search users based on the platformId they have linked to - if platformBy parameter is defined and by parameter is using thirdparty, endpoint will search users based on the platformUserId or platformDisplayName they have linked to, example value: platformUserId or platformDisplayName - if limit is not defined, The default limit is 100 In multi tenant mode : - if super admin search in super admin namespace, the result will be all game admin user - if super admin search in game studio namespace, the result will be all game admin user and players under the game studio namespace - if super admin search in game namespace, the result will be all game admin users and players under the game namespace - if game admin search in their game studio namespace, the result will be all game admin user in the studio namespace - if game admin search in their game namespace, the result will be all player in the game namespace action code : 10133
   */
  getUsersSearch_v3(queryParams) {
    const params = { ...queryParams };
    const url = "/iam/v3/admin/namespaces/{namespace}/users/search".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.get(url, { params });
    return import_sdk29.Validate.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      SearchUsersResponseWithPaginationV3,
      "SearchUsersResponseWithPaginationV3"
    );
  }
  /**
   * @deprecated
   * ## The endpoint is going to be deprecated **Endpoint migration guide** - **Substitute endpoint: _/iam/v3/admin/namespaces/{namespace}/users/{userId} [GET]_**
   */
  getUser_ByUserId_v2(userId) {
    const params = {};
    const url = "/iam/v2/admin/namespaces/{namespace}/users/{userId}".replace("{namespace}", this.namespace).replace("{userId}", userId);
    const resultPromise = this.axiosInstance.get(url, { params });
    return import_sdk29.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, UserResponse, "UserResponse");
  }
  /**
   * @deprecated
   * ## The endpoint is going to be deprecated **Endpoint migration guide** - **Substitute endpoint: _/iam/v3/admin/namespaces/{namespace}/users/{userId} [PATCH]_** This Endpoint support update user based on given data. **Single request can update single field or multi fields.** Supported field {Country, DisplayName, LanguageTag} Country use ISO3166-1 alpha-2 two letter, e.g. US. **Several case of updating email address** - User want to update email address of which have been verified, NewEmailAddress response field will be filled with new email address. - User want to update email address of which have not been verified, {LoginId, OldEmailAddress, EmailAddress} response field will be filled with new email address. - User want to update email address of which have been verified and updated before, {LoginId, OldEmailAddress, EmailAddress} response field will be filled with verified email before. NewEmailAddress response field will be filled with newest email address.
   */
  patchUser_ByUserId_v2(userId, data) {
    const params = {};
    const url = "/iam/v2/admin/namespaces/{namespace}/users/{userId}".replace("{namespace}", this.namespace).replace("{userId}", userId);
    const resultPromise = this.axiosInstance.patch(url, data, { params });
    return import_sdk29.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, UserResponse, "UserResponse");
  }
  /**
   * Admin Get User By User Id
   */
  getUser_ByUserId_v3(userId) {
    const params = {};
    const url = "/iam/v3/admin/namespaces/{namespace}/users/{userId}".replace("{namespace}", this.namespace).replace("{userId}", userId);
    const resultPromise = this.axiosInstance.get(url, { params });
    return import_sdk29.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, UserResponseV3, "UserResponseV3");
  }
  /**
   * This Endpoint support update user based on given data. **Single request can update single field or multi fields.** Supported field {country, displayName, languageTag, dateOfBirth, avatarUrl, userName} Country use ISO3166-1 alpha-2 two letter, e.g. US. Date of Birth format : YYYY-MM-DD, e.g. 2019-04-29. **Response body logic when user updating email address:** - User want to update email address of which have been verified, NewEmailAddress response field will be filled with new email address. - User want to update email address of which have not been verified, {LoginId, OldEmailAddress, EmailAddress} response field will be filled with new email address. - User want to update email address of which have been verified and updated before, {LoginId, OldEmailAddress, EmailAddress} response field will be filled with verified email before. NewEmailAddress response field will be filled with newest email address. action code : 10103
   */
  patchUser_ByUserId_v3(userId, data) {
    const params = {};
    const url = "/iam/v3/admin/namespaces/{namespace}/users/{userId}".replace("{namespace}", this.namespace).replace("{userId}", userId);
    const resultPromise = this.axiosInstance.patch(url, data, { params });
    return import_sdk29.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, UserResponseV3, "UserResponseV3");
  }
  /**
   * @deprecated
   * ## The endpoint is going to be deprecated **Endpoint migration guide** - **Substitute endpoint: _/iam/v3/admin/namespaces/{namespace}/agerestrictions [GET]_** - **Note:** difference in V3 response, format difference: Pascal case =&gt; Camel case
   */
  getAgerestrictions_v2() {
    const params = {};
    const url = "/iam/v2/admin/namespaces/{namespace}/agerestrictions".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.get(url, { params });
    return import_sdk29.Validate.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      AgeRestrictionResponse,
      "AgeRestrictionResponse"
    );
  }
  /**
   * @deprecated
   * ## The endpoint is going to be deprecated **Endpoint migration guide** - **Substitute endpoint: _/iam/v3/admin/namespaces/{namespace}/agerestrictions [PATCH]_**
   */
  patchAgerestriction_v2(data) {
    const params = {};
    const url = "/iam/v2/admin/namespaces/{namespace}/agerestrictions".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.patch(url, data, { params });
    return import_sdk29.Validate.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      AgeRestrictionResponse,
      "AgeRestrictionResponse"
    );
  }
  /**
   * action code: 10138
   */
  getAgerestrictions_v3() {
    const params = {};
    const url = "/iam/v3/admin/namespaces/{namespace}/agerestrictions".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.get(url, { params });
    return import_sdk29.Validate.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      AgeRestrictionResponseV3,
      "AgeRestrictionResponseV3"
    );
  }
  /**
   * action code: 10122
   */
  patchAgerestriction_v3(data) {
    const params = {};
    const url = "/iam/v3/admin/namespaces/{namespace}/agerestrictions".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.patch(url, data, { params });
    return import_sdk29.Validate.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      AgeRestrictionResponseV3,
      "AgeRestrictionResponseV3"
    );
  }
  /**
   * This endpoint search user by the list of email addresses action code : 10132
   */
  fetchUserSearchBulk_v3(data) {
    const params = {};
    const url = "/iam/v3/admin/namespaces/{namespace}/users/search/bulk".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.post(url, data, { params });
    return import_sdk29.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, ListUserResponseV3, "ListUserResponseV3");
  }
  /**
   * @deprecated
   * ## The endpoint is going to be deprecated **Endpoint migration guide** - **Substitute endpoint: _/iam/v3/admin/namespaces/{namespace}/users/{userId}/bans [POST]_**
   */
  createBan_ByUserId_v2(userId, data) {
    const params = {};
    const url = "/iam/v2/admin/namespaces/{namespace}/users/{userId}/ban".replace("{namespace}", this.namespace).replace("{userId}", userId);
    const resultPromise = this.axiosInstance.post(url, data, { params });
    return import_sdk29.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, UserBanResponse, "UserBanResponse");
  }
  /**
   * @deprecated
   * ## The endpoint is going to be deprecated **Endpoint migration guide** - **Substitute endpoint: _/iam/v3/admin/namespaces/{namespace}/users/{userId}/bans [GET]_**
   */
  getBans_ByUserId_v2(userId, queryParams) {
    const params = { ...queryParams };
    const url = "/iam/v2/admin/namespaces/{namespace}/users/{userId}/bans".replace("{namespace}", this.namespace).replace("{userId}", userId);
    const resultPromise = this.axiosInstance.get(url, { params });
    return import_sdk29.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, UserBanResponseArray, "UserBanResponseArray");
  }
  /**
   * This endpoint retrieve the first page of the data if after and before parameters is empty action code : 10126
   */
  getBans_ByUserId_v3(userId, queryParams) {
    const params = { ...queryParams };
    const url = "/iam/v3/admin/namespaces/{namespace}/users/{userId}/bans".replace("{namespace}", this.namespace).replace("{userId}", userId);
    const resultPromise = this.axiosInstance.get(url, { params });
    return import_sdk29.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, GetUserBanV3Response, "GetUserBanV3Response");
  }
  /**
   * Bans a user with specific type of ban. Ban types and reason can be queried. action code : 10141
   */
  createBan_ByUserId_v3(userId, data) {
    const params = {};
    const url = "/iam/v3/admin/namespaces/{namespace}/users/{userId}/bans".replace("{namespace}", this.namespace).replace("{userId}", userId);
    const resultPromise = this.axiosInstance.post(url, data, { params });
    return import_sdk29.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, UserBanResponseV3, "UserBanResponseV3");
  }
  /**
   * if limit is not defined, The default limit is 100
   */
  getUsersLinkhistories_v3(queryParams) {
    const params = { ...queryParams };
    const url = "/iam/v3/admin/namespaces/{namespace}/users/linkhistories".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.get(url, { params });
    return import_sdk29.Validate.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      LinkingHistoryResponseWithPaginationV3,
      "LinkingHistoryResponseWithPaginationV3"
    );
  }
  /**
   * @deprecated
   * ## The endpoint is going to be deprecated **Endpoint migration guide** - **Substitute endpoint: _/iam/v3/admin/namespaces/{namespace}/users/{userId}/roles [PATCH]_**
   */
  updateRole_ByUserId_v2(userId, data) {
    const params = {};
    const url = "/iam/v2/admin/namespaces/{namespace}/users/{userId}/roles".replace("{namespace}", this.namespace).replace("{userId}", userId);
    const resultPromise = this.axiosInstance.post(url, data, { params });
    return import_sdk29.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, import_zod139.z.unknown(), "z.unknown()");
  }
  /**
   * @deprecated
   * ## The endpoint is going to be deprecated **Endpoint migration guide** - **Substitute endpoint: _/iam/v3/admin/namespaces/{namespace}/users/{userId}/roles [PATCH]_**
   */
  updateRole_ByUserId_ByNS_v2(userId, data) {
    const params = {};
    const url = "/iam/v2/admin/namespaces/{namespace}/users/{userId}/roles".replace("{namespace}", this.namespace).replace("{userId}", userId);
    const resultPromise = this.axiosInstance.put(url, data, { params });
    return import_sdk29.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, import_zod139.z.unknown(), "z.unknown()");
  }
  /**
   * This endpoint search admin users which have the roleId Notes : this endpoint only accept admin role. Admin Role is role which have admin status and members. Use endpoint [GET] /roles/{roleId}/admin to check the role status action code : 10140
   */
  getUsers_ByRoleId_v3(roleId, queryParams) {
    const params = { ...queryParams };
    const url = "/iam/v3/admin/namespaces/{namespace}/roles/{roleId}/users".replace("{namespace}", this.namespace).replace("{roleId}", roleId);
    const resultPromise = this.axiosInstance.get(url, { params });
    return import_sdk29.Validate.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      GetUsersResponseWithPaginationV3,
      "GetUsersResponseWithPaginationV3"
    );
  }
  /**
   * **[WARNING] This endpoint is only for testing purpose.** This endpoint get active user verification code. There are some scenarios of getting verification codes, all of them will be returned on this endpoint: - After account registration - After reset password request - After headless account upgrade - After update email request This API only accept publisher/studio namespace and userId. Action code: 10146
   */
  getCodes_ByUserId_v3(userId) {
    const params = {};
    const url = "/iam/v3/admin/namespaces/{namespace}/users/{userId}/codes".replace("{namespace}", this.namespace).replace("{userId}", userId);
    const resultPromise = this.axiosInstance.get(url, { params });
    return import_sdk29.Validate.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      VerificationCodeResponse,
      "VerificationCodeResponse"
    );
  }
  /**
   * Delete User Roles
   */
  deleteRole_ByUserId_v3(userId, data) {
    const params = {};
    const url = "/iam/v3/admin/namespaces/{namespace}/users/{userId}/roles".replace("{namespace}", this.namespace).replace("{userId}", userId);
    const resultPromise = this.axiosInstance.delete(url, { data, params });
    return import_sdk29.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, import_zod139.z.unknown(), "z.unknown()");
  }
  /**
   * User&#39;s roles will be replaced with roles from request body. An admin user can only assign role with **namespace** (in request body) if the admin user has required permission which is same as the required permission of endpoint: [AdminAddUserRoleV4].
   */
  patchRole_ByUserId_v3(userId, data) {
    const params = {};
    const url = "/iam/v3/admin/namespaces/{namespace}/users/{userId}/roles".replace("{namespace}", this.namespace).replace("{userId}", userId);
    const resultPromise = this.axiosInstance.patch(url, data, { params });
    return import_sdk29.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, import_zod139.z.unknown(), "z.unknown()");
  }
  /**
   * Notes: - This endpoint bulk get users&#39; basic info by userId, max allowed 100 at a time - If namespace is game, will search by game user Id, other wise will search by publisher namespace
   */
  fetchUserBulkPlatform_v3(data) {
    const params = {};
    const url = "/iam/v3/admin/namespaces/{namespace}/users/bulk/platforms".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.post(url, data, { params });
    return import_sdk29.Validate.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      ListBulkUserPlatformsResponse,
      "ListBulkUserPlatformsResponse"
    );
  }
  /**
   * @deprecated
   * ## The endpoint is going to be deprecated **Endpoint migration guide** - **Substitute endpoint: _/iam/v3/admin/namespaces/{namespace}/users/{userId}/status [PATCH]_**
   */
  updateEnable_ByUserId_v2(userId) {
    const params = {};
    const url = "/iam/v2/admin/namespaces/{namespace}/users/{userId}/enable".replace("{namespace}", this.namespace).replace("{userId}", userId);
    const resultPromise = this.axiosInstance.put(url, null, { params });
    return import_sdk29.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, import_zod139.z.unknown(), "z.unknown()");
  }
  /**
   * This endpoint disable or enable user account. Set the enable status on the request body to true to enable user account or set to false to disable it. Disable user for **Account Disable** purpose fill the reason with: - **AdminDeactivateAccount** : if your disable account request comes from admin Enable user ignore field &#39;reason&#39; in the request body. action code : 10143
   */
  patchStatus_ByUserId_v3(userId, data) {
    const params = {};
    const url = "/iam/v3/admin/namespaces/{namespace}/users/{userId}/status".replace("{namespace}", this.namespace).replace("{userId}", userId);
    const resultPromise = this.axiosInstance.patch(url, data, { params });
    return import_sdk29.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, import_zod139.z.unknown(), "z.unknown()");
  }
  /**
   * This endpoint force verify user Note: - namespace: only accept publisher/studio namespace - userId: only accept publisher/studio userId action code: 10118
   */
  updateVerify_ByUserId_v3(userId) {
    const params = {};
    const url = "/iam/v3/admin/namespaces/{namespace}/users/{userId}/verify".replace("{namespace}", this.namespace).replace("{userId}", userId);
    const resultPromise = this.axiosInstance.put(url, null, { params });
    return import_sdk29.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, import_zod139.z.unknown(), "z.unknown()");
  }
  /**
   * @deprecated
   * ## The endpoint is going to be deprecated **Endpoint migration guide** - **Substitute endpoint: _/iam/v3/admin/namespaces/{namespace}/users/{userId}/status [PATCH]_** For **Deletion Account** purpose fill the reason with: - **DeactivateAccount** : if your deletion request comes from user - **AdminDeactivateAccount** : if your deletion request comes from admin
   */
  updateDisable_ByUserId_v2(userId, data) {
    const params = {};
    const url = "/iam/v2/admin/namespaces/{namespace}/users/{userId}/disable".replace("{namespace}", this.namespace).replace("{userId}", userId);
    const resultPromise = this.axiosInstance.put(url, data, { params });
    return import_sdk29.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, import_zod139.z.unknown(), "z.unknown()");
  }
  /**
   * @deprecated
   * ## The endpoint is going to be deprecated **Endpoint migration guide** - **Substitute endpoint: _/iam/v3/admin/namespaces/{namespace}/agerestrictions/countries/{countryCode} [PATCH]_**
   */
  patchCountry_ByCountryCode_v2(countryCode, data) {
    const params = {};
    const url = "/iam/v2/admin/namespaces/{namespace}/countries/{countryCode}".replace("{namespace}", this.namespace).replace("{countryCode}", countryCode);
    const resultPromise = this.axiosInstance.patch(url, data, { params });
    return import_sdk29.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, Country, "Country");
  }
  /**
   * @deprecated
   * ## The endpoint is going to be deprecated **Endpoint migration guide** - **Substitute endpoint: _/iam/v3/admin/namespaces/{namespace}/users/{userId}/password [PUT]_**
   */
  updatePassword_ByUserId_v2(userId, data) {
    const params = {};
    const url = "/iam/v2/admin/namespaces/{namespace}/users/{userId}/password".replace("{namespace}", this.namespace).replace("{userId}", userId);
    const resultPromise = this.axiosInstance.put(url, data, { params });
    return import_sdk29.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, import_zod139.z.unknown(), "z.unknown()");
  }
  /**
   * Update User Password
   */
  updatePassword_ByUserId_v3(userId, data) {
    const params = {};
    const url = "/iam/v3/admin/namespaces/{namespace}/users/{userId}/password".replace("{namespace}", this.namespace).replace("{userId}", userId);
    const resultPromise = this.axiosInstance.put(url, data, { params });
    return import_sdk29.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, import_zod139.z.unknown(), "z.unknown()");
  }
  /**
   * **This endpoint requires publisher namespace.** Returns list of users ID and namespace with their Justice platform account, under a namespace. If user doesn&#39;t have Justice platform account, the linkedPlatforms will be empty array.&#39;
   */
  getUsersPlatformsJustice_v3(queryParams) {
    const params = { ...queryParams };
    const url = "/iam/v3/admin/namespaces/{namespace}/users/platforms/justice".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.get(url, { params });
    return import_sdk29.Validate.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      ListUsersWithPlatformAccountsResponse,
      "ListUsersWithPlatformAccountsResponse"
    );
  }
  /**
   * Gets platform accounts that are already linked with user account. Action code : 10128 **Supported Platforms:** - Steam group (steamnetwork): - steam - steamopenid - PSN group (psn): - ps4web - ps4 - ps5 - XBOX group(xbox): - live - xblweb - Oculus group (oculusgroup): - oculus - oculusweb - Google group (google): - google - googleplaygames: - epicgames - facebook - twitch - discord - android - ios - apple - device - nintendo - awscognito - amazon - netflix - snapchat - _oidc platform id_ Note: - You can use either platform id or platform group as **platformId** parameter. - **Nintendo platform user id**: NSA ID need to be appended with Environment ID using colon as separator. e.g kmzwa8awaa:dd1 ## Justice Platform Account The permission ’ADMIN:NAMESPACE:{namespace}:JUSTICE:USER:{userId}’ [READ] is required in order to read the UserID who linked with the user.
   */
  getPlatforms_ByUserId_v3(userId, queryParams) {
    const params = { ...queryParams };
    const url = "/iam/v3/admin/namespaces/{namespace}/users/{userId}/platforms".replace("{namespace}", this.namespace).replace("{userId}", userId);
    const resultPromise = this.axiosInstance.get(url, { params });
    return import_sdk29.Validate.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      UserLinkedPlatformsResponseV3,
      "UserLinkedPlatformsResponseV3"
    );
  }
  /**
   * @deprecated
   * ## The endpoint is going to be deprecated **Endpoint migration guide** - **Substitute endpoint: _/iam/v3/admin/namespaces/{namespace}/agerestrictions/countries [GET]_**
   */
  getCountriesAgerestrictions_v2() {
    const params = {};
    const url = "/iam/v2/admin/namespaces/{namespace}/countries/agerestrictions".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.get(url, { params });
    return import_sdk29.Validate.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      CountryAgeRestrictionArray,
      "CountryAgeRestrictionArray"
    );
  }
  /**
   * action code : 10139
   */
  getAgerestrictionsCountries_v3() {
    const params = {};
    const url = "/iam/v3/admin/namespaces/{namespace}/agerestrictions/countries".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.get(url, { params });
    return import_sdk29.Validate.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      CountryV3ResponseArray,
      "CountryV3ResponseArray"
    );
  }
  /**
   * Will verify account and consume code if validateOnly is set false in request body Redeems a verification code sent to a user to verify the user&#39;s contact address is correct Available ContactType : **email** or **phone**
   */
  updateCodeVerify_ByUserId_v3(userId, data) {
    const params = {};
    const url = "/iam/v3/admin/namespaces/{namespace}/users/{userId}/code/verify".replace("{namespace}", this.namespace).replace("{userId}", userId);
    const resultPromise = this.axiosInstance.post(url, data, { params });
    return import_sdk29.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, import_zod139.z.unknown(), "z.unknown()");
  }
  /**
   * [WARNING] This endpoint is deleting user data from database directly by skipping GDPR flow
   */
  deleteInformation_ByUserId_v3(userId) {
    const params = {};
    const url = "/iam/v3/admin/namespaces/{namespace}/users/{userId}/information".replace("{namespace}", this.namespace).replace("{userId}", userId);
    const resultPromise = this.axiosInstance.delete(url, { params });
    return import_sdk29.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, import_zod139.z.unknown(), "z.unknown()");
  }
  /**
   * Delete User Permission
   */
  deletePermission_ByUserId_v3(userId, data) {
    const params = {};
    const url = "/iam/v3/admin/namespaces/{namespace}/users/{userId}/permissions".replace("{namespace}", this.namespace).replace("{userId}", userId);
    const resultPromise = this.axiosInstance.delete(url, { data, params });
    return import_sdk29.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, import_zod139.z.unknown(), "z.unknown()");
  }
  /**
   * This endpoint will APPEND user&#39;s permissions with the ones defined in body Schedule contains cron string or date range (both are UTC, also in cron syntax) to indicate when a permission and action are in effect. Both schedule types accepts quartz compatible cron syntax e.g. * * * * * * *. In ranged schedule, first element will be start date, and second one will be end date If schedule is set, the scheduled action must be valid too, that is between 1 to 15, inclusive Syntax reference Fields: 1. Seconds: 0-59 * / , - 1. Minutes: 0-59 * / , - 1. Hours: 0-23 * / , - 1. Day of month: 1-31 * / , - L W 1. Month: 1-12 JAN-DEC * / , - 1. Day of week: 0-6 SUN-SAT * / , - L # 1. Year: 1970-2099 * / , - Special characters: 1. *: all values in the fields, e.g. * in seconds fields indicates every second 1. /: increments of ranges, e.g. 3-59/15 in the minute field indicate the third minute of the hour and every 15 minutes thereafter 1. ,: separate items of a list, e.g. MON,WED,FRI in day of week 1. -: range, e.g. 2010-2018 indicates every year between 2010 and 2018, inclusive 1. L: last, e.g. When used in the day-of-week field, it allows you to specify constructs such as &#34;the last Friday&#34; (5L) of a given month. In the day-of-month field, it specifies the last day of the month. 1. W: business day, e.g. if you were to specify 15W as the value for the day-of-month field, the meaning is: &#34;the nearest business day to the 15th of the month.&#34; 1. #: must be followed by a number between one and five. It allows you to specify constructs such as &#34;the second Friday&#34; of a given month.
   */
  createPermission_ByUserId_v3(userId, data) {
    const params = {};
    const url = "/iam/v3/admin/namespaces/{namespace}/users/{userId}/permissions".replace("{namespace}", this.namespace).replace("{userId}", userId);
    const resultPromise = this.axiosInstance.post(url, data, { params });
    return import_sdk29.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, import_zod139.z.unknown(), "z.unknown()");
  }
  /**
   * This endpoint will REPLACE user&#39;s permissions with the ones defined in body Schedule contains cron string or date range (both are UTC, also in cron syntax) to indicate when a permission and action are in effect. Both schedule types accepts quartz compatible cron syntax e.g. * * * * * * *. In ranged schedule, first element will be start date, and second one will be end date If schedule is set, the scheduled action must be valid too, that is between 1 to 15, inclusive Syntax reference Fields: 1. Seconds: 0-59 * / , - 2. Minutes: 0-59 * / , - 3. Hours: 0-23 * / , - 4. Day of month: 1-31 * / , - L W 5. Month: 1-12 JAN-DEC * / , - 6. Day of week: 0-6 SUN-SAT * / , - L # 7. Year: 1970-2099 * / , - Special characters: 1. *: all values in the fields, e.g. * in seconds fields indicates every second 2. /: increments of ranges, e.g. 3-59/15 in the minute field indicate the third minute of the hour and every 15 minutes thereafter 3. ,: separate items of a list, e.g. MON,WED,FRI in day of week 4. -: range, e.g. 2010-2018 indicates every year between 2010 and 2018, inclusive 5. L: last, e.g. When used in the day-of-week field, it allows you to specify constructs such as &#34;the last Friday&#34; (5L) of a given month. In the day-of-month field, it specifies the last day of the month. 6. W: business day, e.g. if you were to specify 15W as the value for the day-of-month field, the meaning is: &#34;the nearest business day to the 15th of the month.&#34; 7. #: must be followed by a number between one and five. It allows you to specify constructs such as &#34;the second Friday&#34; of a given month.
   */
  updatePermission_ByUserId_v3(userId, data) {
    const params = {};
    const url = "/iam/v3/admin/namespaces/{namespace}/users/{userId}/permissions".replace("{namespace}", this.namespace).replace("{userId}", userId);
    const resultPromise = this.axiosInstance.put(url, data, { params });
    return import_sdk29.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, import_zod139.z.unknown(), "z.unknown()");
  }
  /**
   * Set ban status for a single user for a specific ban. Retrieve user ban and choose the ban ID. Set the form parameter to true/false to enable or disable the ban. action code : 10142&#39;
   */
  patchBan_ByUserId_ByBanId_v3(userId, banId, data) {
    const params = {};
    const url = "/iam/v3/admin/namespaces/{namespace}/users/{userId}/bans/{banId}".replace("{namespace}", this.namespace).replace("{userId}", userId).replace("{banId}", banId);
    const resultPromise = this.axiosInstance.patch(url, data, { params });
    return import_sdk29.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, UserBanResponseV3, "UserBanResponseV3");
  }
  /**
   * This endpoint get user&#39;s bans summary&#39;
   */
  getBansSummary_ByUserId_v3(userId) {
    const params = {};
    const url = "/iam/v3/admin/namespaces/{namespace}/users/{userId}/bans/summary".replace("{namespace}", this.namespace).replace("{userId}", userId);
    const resultPromise = this.axiosInstance.get(url, { params });
    return import_sdk29.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, GetUserBanSummaryV3, "GetUserBanSummaryV3");
  }
  /**
   * The verification code is sent to email address. Available contexts for use : - **UserAccountRegistration** a context type used for verifying email address in user account registration. It returns 409 if the email address already verified. **_It is the default context if the Context field is empty_** - **UpdateEmailAddress** a context type used for verify user before updating email address.(Without email address verified checking) - **upgradeHeadlessAccount** The context is intended to be used whenever the email address wanted to be automatically verified on upgrading a headless account. If this context used, IAM rejects the request if the email address is already used by others by returning HTTP Status Code 409. action code: 10116
   */
  updateCodeRequest_ByUserId_v3(userId, data) {
    const params = {};
    const url = "/iam/v3/admin/namespaces/{namespace}/users/{userId}/code/request".replace("{namespace}", this.namespace).replace("{userId}", userId);
    const resultPromise = this.axiosInstance.post(url, data, { params });
    return import_sdk29.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, import_zod139.z.unknown(), "z.unknown()");
  }
  /**
   * Admin List User ID By Platform User ID This endpoint intended to list game user ID from the given namespace This endpoint return list of user ID by given platform ID and list of platform user ID Supported platform: - steam - steamopenid - ps4web - ps4 - ps5 - live - xblweb - oculus - oculusweb - facebook - google - googleplaygames - twitch - discord - android - ios - apple - device - justice - epicgames - nintendo - awscognito - netflix - snapchat - oidc platform id Note: **nintendo platform user ID**: NSA ID need to be appended with Environment ID using colon as separator. e.g kmzwa8awaa:dd1
   */
  fetchUser_ByPlatformId_v3(platformId, data, queryParams) {
    const params = { ...queryParams };
    const url = "/iam/v3/admin/namespaces/{namespace}/platforms/{platformId}/users".replace("{namespace}", this.namespace).replace("{platformId}", platformId);
    const resultPromise = this.axiosInstance.post(url, data, { params });
    return import_sdk29.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, UserPlatforms, "UserPlatforms");
  }
  /**
   * Force linking platform account to user User Account. This endpoint intended for admin to forcefully link account to user. By default, these cases are not allowed - The platform account current is linked by another account - The target account ever linked this platform&#39;s another account
   */
  updatePlatformLink_ByUserId_v3(userId, data, queryParams) {
    const params = { skipConflict: true, ...queryParams };
    const url = "/iam/v3/admin/namespaces/{namespace}/users/{userId}/platforms/link".replace("{namespace}", this.namespace).replace("{userId}", userId);
    const resultPromise = this.axiosInstance.post(url, data, { params });
    return import_sdk29.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, import_zod139.z.unknown(), "z.unknown()");
  }
  /**
   * This endpoint removes role from user action code: 10110
   */
  deleteRole_ByUserId_ByRoleId_v3(userId, roleId) {
    const params = {};
    const url = "/iam/v3/admin/namespaces/{namespace}/users/{userId}/roles/{roleId}".replace("{namespace}", this.namespace).replace("{userId}", userId).replace("{roleId}", roleId);
    const resultPromise = this.axiosInstance.delete(url, { params });
    return import_sdk29.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, import_zod139.z.unknown(), "z.unknown()");
  }
  /**
   * action code: 10109
   */
  updateRole_ByUserId_ByRoleId_v3(userId, roleId) {
    const params = {};
    const url = "/iam/v3/admin/namespaces/{namespace}/users/{userId}/roles/{roleId}".replace("{namespace}", this.namespace).replace("{userId}", userId).replace("{roleId}", roleId);
    const resultPromise = this.axiosInstance.post(url, null, { params });
    return import_sdk29.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, import_zod139.z.unknown(), "z.unknown()");
  }
  /**
   * action code : 10145
   */
  getDeletionStatus_ByUserId_v3(userId) {
    const params = {};
    const url = "/iam/v3/admin/namespaces/{namespace}/users/{userId}/deletion/status".replace("{namespace}", this.namespace).replace("{userId}", userId);
    const resultPromise = this.axiosInstance.get(url, { params });
    return import_sdk29.Validate.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      UserDeletionStatusResponse,
      "UserDeletionStatusResponse"
    );
  }
  /**
   * action code : 10144
   */
  patchDeletionStatus_ByUserId_v3(userId, data) {
    const params = {};
    const url = "/iam/v3/admin/namespaces/{namespace}/users/{userId}/deletion/status".replace("{namespace}", this.namespace).replace("{userId}", userId);
    const resultPromise = this.axiosInstance.patch(url, data, { params });
    return import_sdk29.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, import_zod139.z.unknown(), "z.unknown()");
  }
  /**
   * Notes for this endpoint: This endpoint retrieve the first page of the data if &lt;code&gt;after&lt;/code&gt; and &lt;code&gt;before&lt;/code&gt; parameters is empty. - The maximum value of the limit is 100 and the minimum value of the limit is 1. - This endpoint retrieve the next page of the data if we provide &lt;code&gt;after&lt;/code&gt; parameters with valid Unix timestamp. - This endpoint retrieve the previous page of the data if we provide &lt;code&gt;before&lt;/code&gt; parameter with valid data Unix timestamp.&#34;
   */
  getLoginsHistories_ByUserId_v3(userId, queryParams) {
    const params = { ...queryParams };
    const url = "/iam/v3/admin/namespaces/{namespace}/users/{userId}/logins/histories".replace("{namespace}", this.namespace).replace("{userId}", userId);
    const resultPromise = this.axiosInstance.get(url, { params });
    return import_sdk29.Validate.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      LoginHistoriesResponse,
      "LoginHistoriesResponse"
    );
  }
  /**
   * This endpoint ONLY accept **Client Token** This endpoint is utilized for specific scenarios where **email notifications are disabled** The user&#39;s email will be marked as verified Note: - emailAddress or password field are optional - request body can&#39;t be empty action code : 10103
   */
  patchTrustlyIdentity_ByUserId_v3(userId, data) {
    const params = {};
    const url = "/iam/v3/admin/namespaces/{namespace}/users/{userId}/trustly/identity".replace("{namespace}", this.namespace).replace("{userId}", userId);
    const resultPromise = this.axiosInstance.patch(url, data, { params });
    return import_sdk29.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, import_zod139.z.unknown(), "z.unknown()");
  }
  /**
   * This endpoint retrieves platform accounts linked to user. It will query all linked platform accounts and result will be distinct &amp; grouped, same platform we will pick oldest linked one.
   */
  getDistinctPlatforms_ByUserId_v3(userId) {
    const params = {};
    const url = "/iam/v3/admin/namespaces/{namespace}/users/{userId}/distinctPlatforms".replace("{namespace}", this.namespace).replace("{userId}", userId);
    const resultPromise = this.axiosInstance.get(url, { params });
    return import_sdk29.Validate.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      DistinctPlatformResponseV3,
      "DistinctPlatformResponseV3"
    );
  }
  /**
   * This endpoint gets list justice platform account by providing publisher namespace and publisher userID
   */
  getPlatformsJustice_ByUserId_v3(userId) {
    const params = {};
    const url = "/iam/v3/admin/namespaces/{namespace}/users/{userId}/platforms/justice".replace("{namespace}", this.namespace).replace("{userId}", userId);
    const resultPromise = this.axiosInstance.get(url, { params });
    return import_sdk29.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, GetUserMappingArray, "GetUserMappingArray");
  }
  /**
   * This endpoint only retrieves 3rd party platform accounts linked to user. It will query platform accounts and result will be distinct &amp; grouped, same platform we will pick oldest linked one. ------ Supported status: - LINKED - RESTRICTIVELY_UNLINKED - UNLINKED - ALL
   */
  getPlatformsDistinct_ByUserId_v3(userId, queryParams) {
    const params = { ...queryParams };
    const url = "/iam/v3/admin/namespaces/{namespace}/users/{userId}/platforms/distinct".replace("{namespace}", this.namespace).replace("{userId}", userId);
    const resultPromise = this.axiosInstance.get(url, { params });
    return import_sdk29.Validate.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      DistinctPlatformResponseV3,
      "DistinctPlatformResponseV3"
    );
  }
  /**
   * If validateOnly is set false, will upgrade headless account with verification code The endpoint upgrades a headless account by linking the headless account with the email address and the password. By upgrading the headless account into a full account, the user could use the email address and password for using Justice IAM. The endpoint is a shortcut for upgrading a headless account and verifying the email address in one call. In order to get a verification code for the endpoint, please check the send verification code endpoint. This endpoint also have an ability to update user data (if the user data field is specified) right after the upgrade account process is done. Supported user data fields : - displayName - dateOfBirth : format YYYY-MM-DD, e.g. 2019-04-29 - country : format ISO3166-1 alpha-2 two letter, e.g. US action code : 10124
   */
  updateHeadlesCodeVerify_ByUserId_v3(userId, data) {
    const params = {};
    const url = "/iam/v3/admin/namespaces/{namespace}/users/{userId}/headless/code/verify".replace("{namespace}", this.namespace).replace("{userId}", userId);
    const resultPromise = this.axiosInstance.post(url, data, { params });
    return import_sdk29.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, UserResponseV3, "UserResponseV3");
  }
  /**
   * @deprecated
   * ## Supported platforms: - **steam** - **steamopenid** - **facebook** - **google** - **googleplaygames** - **oculus** - **twitch** - **android** - **ios** - **apple** - **device** - **discord** - **awscognito** - **epicgames** - **nintendo** - **snapchat** Unlink user&#39;s account from a specific platform. &#39;justice&#39; platform might have multiple accounts from different namespaces linked. _platformNamespace_ need to be specified when the platform ID is &#39;justice&#39;. Unlink user&#39;s account from justice platform will enable password token grant and password update. If you want to unlink user&#39;s account in a game namespace, you have to specify _platformNamespace_ to that game namespace. action code : 10121
   */
  deletePlatform_ByUserId_ByPlatformId_v3(userId, platformId, data) {
    const params = {};
    const url = "/iam/v3/admin/namespaces/{namespace}/users/{userId}/platforms/{platformId}".replace("{namespace}", this.namespace).replace("{userId}", userId).replace("{platformId}", platformId);
    const resultPromise = this.axiosInstance.delete(url, { data, params });
    return import_sdk29.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, import_zod139.z.unknown(), "z.unknown()");
  }
  /**
   * action code: 10123
   */
  patchAgerestrictionCountry_ByCountryCode_v3(countryCode, data) {
    const params = {};
    const url = "/iam/v3/admin/namespaces/{namespace}/agerestrictions/countries/{countryCode}".replace("{namespace}", this.namespace).replace("{countryCode}", countryCode);
    const resultPromise = this.axiosInstance.patch(url, data, { params });
    return import_sdk29.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, CountryV3Response, "CountryV3Response");
  }
  /**
   * This API is for admin to get user&#39;s link history. **Supported Platforms:** - Steam group (steamnetwork): - steam - steamopenid - PSN group (psn): - ps4web - ps4 - ps5 - XBOX group(xbox): - live - xblweb - Oculus group (oculusgroup): - oculus - oculusweb - Google group (google): - google - googleplaygames: - epicgames - facebook - twitch - discord - android - ios - apple - device - nintendo - awscognito - amazon - netflix - snapchat - _oidc platform id_ Note: - You can use either platform id or platform group as **platformId** parameter. - **Nintendo platform user id**: NSA ID need to be appended with Environment ID using colon as separator. e.g kmzwa8awaa:dd1
   */
  getPlatformsLinkHistories_ByUserId_v3(userId, queryParams) {
    const params = { ...queryParams };
    const url = "/iam/v3/admin/namespaces/{namespace}/users/{userId}/platforms/link/histories".replace("{namespace}", this.namespace).replace("{userId}", userId);
    const resultPromise = this.axiosInstance.get(url, { params });
    return import_sdk29.Validate.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      UserPlatformLinkHistories,
      "UserPlatformLinkHistories"
    );
  }
  /**
   * Unlink user&#39;s account from third platform in all namespaces. Several platforms are grouped under account groups, you can use either platform ID or platform group as platformId path parameter. example: to unlink steam third party account, you can use steamnetwork / steam / steamopenid as platformId path parameter. **Supported Platforms:** - Steam group (steamnetwork): - steam - steamopenid - PSN group (psn): - ps4web - ps4 - ps5 - XBOX group(xbox): - live - xblweb - Oculus group (oculusgroup): - oculus - oculusweb - Google group (google): - google - googleplaygames: - epicgames - facebook - twitch - discord - android - ios - apple - device - nintendo - awscognito - amazon - netflix - snapchat - _oidc platform id_ Note: - You can use either platform id or platform group as **platformId** parameter. - **Nintendo platform user id**: NSA ID need to be appended with Environment ID using colon as separator. e.g kmzwa8awaa:dd1 Unlink platform account associated with a group: If user unlink platform account associated with a group, the API logic will unlink all of platform account under that group as well. example: if user unlink from ps4, the API logic will unlink ps5 and ps4web as well
   */
  deleteAll_ByUserId_ByPlatformId_v3(userId, platformId) {
    const params = {};
    const url = "/iam/v3/admin/namespaces/{namespace}/users/{userId}/platforms/{platformId}/all".replace("{namespace}", this.namespace).replace("{userId}", userId).replace("{platformId}", platformId);
    const resultPromise = this.axiosInstance.delete(url, { params });
    return import_sdk29.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, import_zod139.z.unknown(), "z.unknown()");
  }
  /**
   * @deprecated
   * ## The endpoint is going to be deprecated **Endpoint migration guide** - **Substitute endpoint: _/iam/v3/admin/namespaces/{namespace}/users/{userId}/platforms/{platformId} [DELETE]_** ## Supported platforms: - **steam** - **steamopenid** - **facebook** - **google** - **oculus** - **twitch** - **android** - **ios** - **device** - **discord** Delete link of user&#39;s account with platform. &#39;justice&#39; platform might have multiple accounts from different namespaces linked. platform_namespace need to be specified when the platform ID is &#39;justice&#39;. Delete link of justice platform will enable password token grant and password update.
   */
  deleteLink_ByUserId_ByPlatformId_v2(userId, platformId, data) {
    const params = {};
    const url = "/iam/v2/admin/namespaces/{namespace}/users/{userId}/platforms/{platformId}/link".replace("{namespace}", this.namespace).replace("{userId}", userId).replace("{platformId}", platformId);
    const resultPromise = this.axiosInstance.delete(url, { data, params });
    return import_sdk29.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, import_zod139.z.unknown(), "z.unknown()");
  }
  /**
   * **Prerequisite:** Platform client configuration need to be added to database for specific platformId. Namespace service URL need to be specified (refer to required environment variables). ## Supported platforms: - **steam**: The ticket’s value is the authentication code returned by Steam. - **steamopenid**: Steam&#39;s user authentication method using OpenID 2.0. The ticket&#39;s value is URL generated by Steam on web authentication - **facebook**: The ticket’s value is the authorization code returned by Facebook OAuth - **google**: The ticket’s value is the authorization code returned by Google OAuth - **googleplaygames**: The ticket’s value is the authorization code returned by Google play games OAuth - **oculus**: The ticket’s value is a string composed of Oculus&#39;s user ID and the nonce separated by a colon (:). - **twitch**: The ticket’s value is the authorization code returned by Twitch OAuth. - **android**: The ticket&#39;s value is the Android’s device ID - **ios**: The ticket&#39;s value is the iOS’s device ID. - **apple**: The ticket’s value is the authorization code returned by Apple OAuth. - **device**: Every device that does’nt run Android and iOS is categorized as a device platform. The ticket&#39;s value is the device’s ID. - **discord**: The ticket’s value is the authorization code returned by Discord OAuth. - **awscognito**: The ticket’s value is the aws cognito access token (JWT). - **epicgames**: The ticket’s value is an access-token obtained from Epicgames EOS Account Service. - **nintendo**: The ticket’s value is the authorization code(id_token) returned by Nintendo OAuth.
   */
  postLink_ByUserId_ByPlatformId_v3(userId, platformId, data) {
    const params = {};
    const url = "/iam/v3/admin/namespaces/{namespace}/users/{userId}/platforms/{platformId}/link".replace("{namespace}", this.namespace).replace("{userId}", userId).replace("{platformId}", platformId);
    const resultPromise = this.axiosInstance.post(url, import_sdk29.CodeGenUtil.getFormUrlEncodedData(data), {
      ...params,
      headers: { ...params.headers, "content-type": "application/x-www-form-urlencoded" }
    });
    return import_sdk29.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, import_zod139.z.unknown(), "z.unknown()");
  }
  /**
   * Get User By Platform User ID This endpoint return user information by given platform ID and platform user ID. Several platforms are grouped under account groups, you can use either platform ID or platform group as platformId path parameter. example: for steam network platform, you can use steamnetwork / steam / steamopenid as platformId path parameter. **Supported Platforms:** - Steam group (steamnetwork): - steam - steamopenid - PSN group (psn): - ps4web - ps4 - ps5 - XBOX group(xbox): - live - xblweb - Oculus group (oculusgroup): - oculus - oculusweb - Google group (google): - google - googleplaygames: - epicgames - facebook - twitch - discord - android - ios - apple - device - nintendo - awscognito - amazon - netflix - snapchat - _oidc platform id_ Note: - You can use either platform id or platform group as **platformId** parameter. - **Nintendo platform user id**: NSA ID need to be appended with Environment ID using colon as separator. e.g kmzwa8awaa:dd1
   */
  getUser_ByPlatformId_ByPlatformUserId_v3(platformId, platformUserId) {
    const params = {};
    const url = "/iam/v3/admin/namespaces/{namespace}/platforms/{platformId}/users/{platformUserId}".replace("{namespace}", this.namespace).replace("{platformId}", platformId).replace("{platformUserId}", platformUserId);
    const resultPromise = this.axiosInstance.get(url, { params });
    return import_sdk29.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, UserResponseV3, "UserResponseV3");
  }
  /**
   * Delete User Permission
   */
  deletePermission_ByUserId_ByResource_ByAction_v3(userId, resource, action) {
    const params = {};
    const url = "/iam/v3/admin/namespaces/{namespace}/users/{userId}/permissions/{resource}/{action}".replace("{namespace}", this.namespace).replace("{userId}", userId).replace("{resource}", resource).replace("{action}", String(action));
    const resultPromise = this.axiosInstance.delete(url, { params });
    return import_sdk29.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, import_zod139.z.unknown(), "z.unknown()");
  }
  /**
   * This endpoint gets user single platform account metadata. **Supported Platforms:** - Steam group (steamnetwork): - steam - steamopenid - PSN group (psn): - ps4web - ps4 - ps5 - XBOX group(xbox): - live - xblweb - Oculus group (oculusgroup): - oculus - oculusweb - Google group (google): - google - googleplaygames: - epicgames - facebook - twitch - discord - android - ios - apple - device - nintendo - awscognito - amazon - netflix - snapchat - _oidc platform id_ Note: - You can use either platform id or platform group as **platformId** parameter. - **Nintendo platform user id**: NSA ID need to be appended with Environment ID using colon as separator. e.g kmzwa8awaa:dd1
   */
  getMetadata_ByUserId_ByPlatformId_v3(userId, platformId, queryParams) {
    const params = { ...queryParams };
    const url = "/iam/v3/admin/namespaces/{namespace}/users/{userId}/platforms/{platformId}/metadata".replace("{namespace}", this.namespace).replace("{userId}", userId).replace("{platformId}", platformId);
    const resultPromise = this.axiosInstance.get(url, { params });
    return import_sdk29.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, UserPlatformMetadata, "UserPlatformMetadata");
  }
  /**
   * Admin get the link status of the third party platform token with user id. This endpoint is used for checking whether the third party user represented by third party token is linked with the corresponding user id. ## Supported platforms: - **steam**: The platform_token’s value is the authentication code returned by Steam. - **steamopenid**: Steam&#39;s user authentication method using OpenID 2.0. The platform_token&#39;s value is URL generated by Steam on web authentication - **facebook**: The platform_token’s value is the authorization code returned by Facebook OAuth - **google**: The platform_token’s value is the authorization code returned by Google OAuth - **googleplaygames**: The platform_token’s value is the authorization code returned by Google play games OAuth - **oculus**: The platform_token’s value is a string composed of Oculus&#39;s user ID and the nonce separated by a colon (:). - **twitch**: The platform_token’s value is the authorization code returned by Twitch OAuth. - **discord**: The platform_token’s value is the authorization code returned by Discord OAuth - **android**: The device_id is the Android’s device ID - **ios**: The device_id is the iOS’s device ID. - **apple**: The platform_token’s value is the authorization code returned by Apple OAuth.(We will use this code to generate APP token) - **device**: Every device that does’nt run Android and iOS is categorized as a device. The device_id is the device’s ID. - **justice**: The platform_token’s value is the designated user’s access token. - **epicgames**: The platform_token’s value is an access-token obtained from Epicgames EOS Account Service. - **ps4**: The platform_token’s value is the authorization code returned by Sony OAuth. - **ps5**: The platform_token’s value is the authorization code returned by Sony OAuth. - **nintendo**: The platform_token’s value is the authorization code(id_token) returned by Nintendo OAuth. - **awscognito**: The platform_token’s value is the aws cognito access token or id token (JWT). - **live**: The platform_token’s value is xbox XSTS token - **xblweb**: The platform_token’s value is code returned by xbox after login - **netflix**: The platform_token’s value is GAT (Gamer Access Token) returned by Netflix backend - **snapchat**: The platform_token’s value is the authorization code returned by Snapchat OAuth.
   */
  postLinkStatu_ByUserId_ByPlatformId_v3(userId, platformId, data) {
    const params = {};
    const url = "/iam/v3/admin/namespaces/{namespace}/users/{userId}/platforms/{platformId}/linkStatus".replace("{namespace}", this.namespace).replace("{userId}", userId).replace("{platformId}", platformId);
    const resultPromise = this.axiosInstance.post(url, import_sdk29.CodeGenUtil.getFormUrlEncodedData(data), {
      ...params,
      headers: { ...params.headers, "content-type": "application/x-www-form-urlencoded" }
    });
    return import_sdk29.Validate.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      TokenThirdPartyLinkStatusResponse,
      "TokenThirdPartyLinkStatusResponse"
    );
  }
  /**
   * This endpoint will support publisher access to game and game access to publisher If targetNamespace filled with publisher namespace then this endpoint will return its publisher user id and publisher namespace. If targetNamespace filled with game namespace then this endpoint will return its game user id and game namespace.
   */
  getPlatformJustice_ByUserId_ByTargetNamespace_v3(userId, targetNamespace) {
    const params = {};
    const url = "/iam/v3/admin/namespaces/{namespace}/users/{userId}/platforms/justice/{targetNamespace}".replace("{namespace}", this.namespace).replace("{userId}", userId).replace("{targetNamespace}", targetNamespace);
    const resultPromise = this.axiosInstance.get(url, { params });
    return import_sdk29.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, GetUserMappingV3, "GetUserMappingV3");
  }
  /**
   * Create Justice User from Publisher User information. It will check first if Justice User on target namespace already exist.
   */
  createPlatformJustice_ByUserId_ByTargetNamespace_v3(userId, targetNamespace) {
    const params = {};
    const url = "/iam/v3/admin/namespaces/{namespace}/users/{userId}/platforms/justice/{targetNamespace}".replace("{namespace}", this.namespace).replace("{userId}", userId).replace("{targetNamespace}", targetNamespace);
    const resultPromise = this.axiosInstance.post(url, null, { params });
    return import_sdk29.Validate.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      CreateJusticeUserResponse,
      "CreateJusticeUserResponse"
    );
  }
  /**
   * @deprecated
   * This API is for admin to delete user&#39;s linking history with target platform id. **Supported Platforms:** - Steam group (steamnetwork): - steam - steamopenid - PSN group (psn): - ps4web - ps4 - ps5 - XBOX group(xbox): - live - xblweb - Oculus group (oculusgroup): - oculus - oculusweb - Google group (google): - google - googleplaygames: - epicgames - facebook - twitch - discord - android - ios - apple - device - nintendo - awscognito - amazon - netflix - snapchat - _oidc platform id_ Note: - You can use either platform id or platform group as **platformId** parameter. - **Nintendo platform user id**: NSA ID need to be appended with Environment ID using colon as separator. e.g kmzwa8awaa:dd1 ---- **Substitute endpoint**: /v3/admin/namespaces/{namespace}/users/{userId}/platforms/{platformId}/link/restrictions
   */
  deleteLinkHistory_ByUserId_ByPlatformId_v3(userId, platformId) {
    const params = {};
    const url = "/iam/v3/admin/namespaces/{namespace}/users/{userId}/platforms/{platformId}/link/histories".replace("{namespace}", this.namespace).replace("{userId}", userId).replace("{platformId}", platformId);
    const resultPromise = this.axiosInstance.delete(url, { params });
    return import_sdk29.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, import_zod139.z.unknown(), "z.unknown()");
  }
  /**
   * This API is for admin to delete user&#39;s linking restriction with target platform id. **Supported Platforms:** - Steam group (steamnetwork): - steam - steamopenid - PSN group (psn): - ps4web - ps4 - ps5 - XBOX group(xbox): - live - xblweb - Oculus group (oculusgroup): - oculus - oculusweb - Google group (google): - google - googleplaygames: - epicgames - facebook - twitch - discord - android - ios - apple - device - nintendo - awscognito - amazon - netflix - snapchat - _oidc platform id_ Note: - You can use either platform id or platform group as **platformId** parameter. - **Nintendo platform user id**: NSA ID need to be appended with Environment ID using colon as separator. e.g kmzwa8awaa:dd1
   */
  deleteLinkRestriction_ByUserId_ByPlatformId_v3(userId, platformId) {
    const params = {};
    const url = "/iam/v3/admin/namespaces/{namespace}/users/{userId}/platforms/{platformId}/link/restrictions".replace("{namespace}", this.namespace).replace("{userId}", userId).replace("{platformId}", platformId);
    const resultPromise = this.axiosInstance.delete(url, { params });
    return import_sdk29.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, import_zod139.z.unknown(), "z.unknown()");
  }
};

// src/generated-admin/UsersAdminApi.ts
function UsersAdminApi(sdk, args) {
  const sdkAssembly = sdk.assembly();
  const namespace = args?.coreConfig?.namespace ?? sdkAssembly.coreConfig.namespace;
  const useSchemaValidation = args?.coreConfig?.useSchemaValidation ?? sdkAssembly.coreConfig.useSchemaValidation;
  let axiosInstance = sdkAssembly.axiosInstance;
  const requestConfigOverrides = args?.axiosConfig?.request;
  const baseURLOverride = args?.coreConfig?.baseURL;
  const interceptorsOverride = args?.axiosConfig?.interceptors ?? [];
  if (requestConfigOverrides || baseURLOverride || interceptorsOverride.length > 0) {
    const requestConfig = import_sdk30.ApiUtils.mergeAxiosConfigs(sdkAssembly.axiosInstance.defaults, {
      ...baseURLOverride ? { baseURL: baseURLOverride } : {},
      ...requestConfigOverrides
    });
    axiosInstance = import_sdk30.Network.create(requestConfig);
    for (const interceptor of interceptorsOverride) {
      if (interceptor.type === "request") {
        axiosInstance.interceptors.request.use(interceptor.onRequest, interceptor.onError);
      }
      if (interceptor.type === "response") {
        axiosInstance.interceptors.response.use(interceptor.onSuccess, interceptor.onError);
      }
    }
  }
  async function getUsersMe_v3() {
    const $ = new UsersAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getUsersMe_v3();
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getUsers_v2(queryParams) {
    const $ = new UsersAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getUsers_v2(queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getUsers_v3(queryParams) {
    const $ = new UsersAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getUsers_v3(queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function updateUser_v3(data) {
    const $ = new UsersAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.updateUser_v3(data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getAdmins_v3(queryParams) {
    const $ = new UsersAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getAdmins_v3(queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function fetchUserBan_v3(data, queryParams) {
    const $ = new UsersAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.fetchUserBan_v3(data, queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function createUserBulk_v3(data) {
    const $ = new UsersAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.createUserBulk_v3(data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function createUserInvite_v3(data) {
    const $ = new UsersAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.createUserInvite_v3(data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getUsersSearch_v3(queryParams) {
    const $ = new UsersAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getUsersSearch_v3(queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getUser_ByUserId_v2(userId) {
    const $ = new UsersAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getUser_ByUserId_v2(userId);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function patchUser_ByUserId_v2(userId, data) {
    const $ = new UsersAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.patchUser_ByUserId_v2(userId, data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getUser_ByUserId_v3(userId) {
    const $ = new UsersAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getUser_ByUserId_v3(userId);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function patchUser_ByUserId_v3(userId, data) {
    const $ = new UsersAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.patchUser_ByUserId_v3(userId, data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getAgerestrictions_v2() {
    const $ = new UsersAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getAgerestrictions_v2();
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function patchAgerestriction_v2(data) {
    const $ = new UsersAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.patchAgerestriction_v2(data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getAgerestrictions_v3() {
    const $ = new UsersAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getAgerestrictions_v3();
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function patchAgerestriction_v3(data) {
    const $ = new UsersAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.patchAgerestriction_v3(data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function fetchUserSearchBulk_v3(data) {
    const $ = new UsersAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.fetchUserSearchBulk_v3(data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function createBan_ByUserId_v2(userId, data) {
    const $ = new UsersAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.createBan_ByUserId_v2(userId, data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getBans_ByUserId_v2(userId, queryParams) {
    const $ = new UsersAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getBans_ByUserId_v2(userId, queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getBans_ByUserId_v3(userId, queryParams) {
    const $ = new UsersAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getBans_ByUserId_v3(userId, queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function createBan_ByUserId_v3(userId, data) {
    const $ = new UsersAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.createBan_ByUserId_v3(userId, data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getUsersLinkhistories_v3(queryParams) {
    const $ = new UsersAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getUsersLinkhistories_v3(queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function updateRole_ByUserId_v2(userId, data) {
    const $ = new UsersAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.updateRole_ByUserId_v2(userId, data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function updateRole_ByUserId_ByNS_v2(userId, data) {
    const $ = new UsersAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.updateRole_ByUserId_ByNS_v2(userId, data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getUsers_ByRoleId_v3(roleId, queryParams) {
    const $ = new UsersAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getUsers_ByRoleId_v3(roleId, queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getCodes_ByUserId_v3(userId) {
    const $ = new UsersAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getCodes_ByUserId_v3(userId);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function deleteRole_ByUserId_v3(userId, data) {
    const $ = new UsersAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.deleteRole_ByUserId_v3(userId, data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function patchRole_ByUserId_v3(userId, data) {
    const $ = new UsersAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.patchRole_ByUserId_v3(userId, data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function fetchUserBulkPlatform_v3(data) {
    const $ = new UsersAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.fetchUserBulkPlatform_v3(data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function updateEnable_ByUserId_v2(userId) {
    const $ = new UsersAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.updateEnable_ByUserId_v2(userId);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function patchStatus_ByUserId_v3(userId, data) {
    const $ = new UsersAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.patchStatus_ByUserId_v3(userId, data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function updateVerify_ByUserId_v3(userId) {
    const $ = new UsersAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.updateVerify_ByUserId_v3(userId);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function updateDisable_ByUserId_v2(userId, data) {
    const $ = new UsersAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.updateDisable_ByUserId_v2(userId, data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function patchCountry_ByCountryCode_v2(countryCode, data) {
    const $ = new UsersAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.patchCountry_ByCountryCode_v2(countryCode, data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function updatePassword_ByUserId_v2(userId, data) {
    const $ = new UsersAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.updatePassword_ByUserId_v2(userId, data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function updatePassword_ByUserId_v3(userId, data) {
    const $ = new UsersAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.updatePassword_ByUserId_v3(userId, data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getUsersPlatformsJustice_v3(queryParams) {
    const $ = new UsersAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getUsersPlatformsJustice_v3(queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getPlatforms_ByUserId_v3(userId, queryParams) {
    const $ = new UsersAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getPlatforms_ByUserId_v3(userId, queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getCountriesAgerestrictions_v2() {
    const $ = new UsersAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getCountriesAgerestrictions_v2();
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getAgerestrictionsCountries_v3() {
    const $ = new UsersAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getAgerestrictionsCountries_v3();
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function updateCodeVerify_ByUserId_v3(userId, data) {
    const $ = new UsersAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.updateCodeVerify_ByUserId_v3(userId, data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function deleteInformation_ByUserId_v3(userId) {
    const $ = new UsersAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.deleteInformation_ByUserId_v3(userId);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function deletePermission_ByUserId_v3(userId, data) {
    const $ = new UsersAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.deletePermission_ByUserId_v3(userId, data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function createPermission_ByUserId_v3(userId, data) {
    const $ = new UsersAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.createPermission_ByUserId_v3(userId, data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function updatePermission_ByUserId_v3(userId, data) {
    const $ = new UsersAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.updatePermission_ByUserId_v3(userId, data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function patchBan_ByUserId_ByBanId_v3(userId, banId, data) {
    const $ = new UsersAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.patchBan_ByUserId_ByBanId_v3(userId, banId, data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getBansSummary_ByUserId_v3(userId) {
    const $ = new UsersAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getBansSummary_ByUserId_v3(userId);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function updateCodeRequest_ByUserId_v3(userId, data) {
    const $ = new UsersAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.updateCodeRequest_ByUserId_v3(userId, data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function fetchUser_ByPlatformId_v3(platformId, data, queryParams) {
    const $ = new UsersAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.fetchUser_ByPlatformId_v3(platformId, data, queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function updatePlatformLink_ByUserId_v3(userId, data, queryParams) {
    const $ = new UsersAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.updatePlatformLink_ByUserId_v3(userId, data, queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function deleteRole_ByUserId_ByRoleId_v3(userId, roleId) {
    const $ = new UsersAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.deleteRole_ByUserId_ByRoleId_v3(userId, roleId);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function updateRole_ByUserId_ByRoleId_v3(userId, roleId) {
    const $ = new UsersAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.updateRole_ByUserId_ByRoleId_v3(userId, roleId);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getDeletionStatus_ByUserId_v3(userId) {
    const $ = new UsersAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getDeletionStatus_ByUserId_v3(userId);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function patchDeletionStatus_ByUserId_v3(userId, data) {
    const $ = new UsersAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.patchDeletionStatus_ByUserId_v3(userId, data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getLoginsHistories_ByUserId_v3(userId, queryParams) {
    const $ = new UsersAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getLoginsHistories_ByUserId_v3(userId, queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function patchTrustlyIdentity_ByUserId_v3(userId, data) {
    const $ = new UsersAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.patchTrustlyIdentity_ByUserId_v3(userId, data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getDistinctPlatforms_ByUserId_v3(userId) {
    const $ = new UsersAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getDistinctPlatforms_ByUserId_v3(userId);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getPlatformsJustice_ByUserId_v3(userId) {
    const $ = new UsersAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getPlatformsJustice_ByUserId_v3(userId);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getPlatformsDistinct_ByUserId_v3(userId, queryParams) {
    const $ = new UsersAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getPlatformsDistinct_ByUserId_v3(userId, queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function updateHeadlesCodeVerify_ByUserId_v3(userId, data) {
    const $ = new UsersAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.updateHeadlesCodeVerify_ByUserId_v3(userId, data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function deletePlatform_ByUserId_ByPlatformId_v3(userId, platformId, data) {
    const $ = new UsersAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.deletePlatform_ByUserId_ByPlatformId_v3(userId, platformId, data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function patchAgerestrictionCountry_ByCountryCode_v3(countryCode, data) {
    const $ = new UsersAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.patchAgerestrictionCountry_ByCountryCode_v3(countryCode, data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getPlatformsLinkHistories_ByUserId_v3(userId, queryParams) {
    const $ = new UsersAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getPlatformsLinkHistories_ByUserId_v3(userId, queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function deleteAll_ByUserId_ByPlatformId_v3(userId, platformId) {
    const $ = new UsersAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.deleteAll_ByUserId_ByPlatformId_v3(userId, platformId);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function deleteLink_ByUserId_ByPlatformId_v2(userId, platformId, data) {
    const $ = new UsersAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.deleteLink_ByUserId_ByPlatformId_v2(userId, platformId, data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function postLink_ByUserId_ByPlatformId_v3(userId, platformId, data) {
    const $ = new UsersAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.postLink_ByUserId_ByPlatformId_v3(userId, platformId, data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getUser_ByPlatformId_ByPlatformUserId_v3(platformId, platformUserId) {
    const $ = new UsersAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getUser_ByPlatformId_ByPlatformUserId_v3(platformId, platformUserId);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function deletePermission_ByUserId_ByResource_ByAction_v3(userId, resource, action) {
    const $ = new UsersAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.deletePermission_ByUserId_ByResource_ByAction_v3(userId, resource, action);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getMetadata_ByUserId_ByPlatformId_v3(userId, platformId, queryParams) {
    const $ = new UsersAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getMetadata_ByUserId_ByPlatformId_v3(userId, platformId, queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function postLinkStatu_ByUserId_ByPlatformId_v3(userId, platformId, data) {
    const $ = new UsersAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.postLinkStatu_ByUserId_ByPlatformId_v3(userId, platformId, data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getPlatformJustice_ByUserId_ByTargetNamespace_v3(userId, targetNamespace) {
    const $ = new UsersAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getPlatformJustice_ByUserId_ByTargetNamespace_v3(userId, targetNamespace);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function createPlatformJustice_ByUserId_ByTargetNamespace_v3(userId, targetNamespace) {
    const $ = new UsersAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.createPlatformJustice_ByUserId_ByTargetNamespace_v3(userId, targetNamespace);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function deleteLinkHistory_ByUserId_ByPlatformId_v3(userId, platformId) {
    const $ = new UsersAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.deleteLinkHistory_ByUserId_ByPlatformId_v3(userId, platformId);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function deleteLinkRestriction_ByUserId_ByPlatformId_v3(userId, platformId) {
    const $ = new UsersAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.deleteLinkRestriction_ByUserId_ByPlatformId_v3(userId, platformId);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  return {
    /**
     * Get my user data action code : 10147
     */
    getUsersMe_v3,
    /**
     * @deprecated
     * ## The endpoint is going to be deprecated **Endpoint migration guide** - **Substitute endpoint: _/iam/v3/admin/namespaces/{namespace}/users/search [GET]_**
     */
    getUsers_v2,
    /**
     * This endpoint search user who owns the given email address action code : 10132
     */
    getUsers_v3,
    /**
     * This endpoint support to bulk update users based on given data. ------ Supported fields: * skipLoginQueue
     */
    updateUser_v3,
    /**
     * List all users that has admin role (role that has admin_role attribute set to true). Endpoint behavior : - if query parameter is defined, endpoint will search users whose email address and display name match with the query - if roleId parameter is defined, endpoint will search users that have the defined roleId - if startDate and endDate parameters is defined, endpoint will search users which created on the certain date range - if startDate parameter is defined, endpoint will search users that created start from the defined date - if endDate parameter is defined, endpoint will search users that created until the defined date In multi tenant mode : - if super admin search in super admin namespace, the result will be all admin users - if super admin search in game studio namespace, the result will be all admin users under the game studio namespace - if studio admin search in their studio namespace, the result will be all admin user in the game studio namespace The endpoint will return all admin from all namespace when called from publisher namespace. When not called from publisher namespace, the endpoint will return all admin from the path namespace.
     */
    getAdmins_v3,
    /**
     * This endpoint returns user bans of userIDs specified in the payload action code : 10127
     */
    fetchUserBan_v3,
    /**
     * List User By User ID This endpoint intended to list user information from the given list of userID and namespace
     */
    createUserBulk_v3,
    /**
     * Use this endpoint to invite admin or non-admin user and assign role to them. The role must be scoped to namespace based on the **{namespace}** value in path parameter. An admin user can only assign role to namespaces that the admin user has the required permission. Role is optional, if not specified then it will only assign User role The invited admin will also assigned with &#34;User&#34; role by default.
     */
    createUserInvite_v3,
    /**
     * Endpoint behavior : - by default this endpoint searches all users on the specified namespace - if query parameter is defined, endpoint will search users whose email address, display name, username, or third party partially match with the query - if startDate and endDate parameters is defined, endpoint will search users which created on the certain date range - if query, startDate and endDate parameters are defined, endpoint will search users whose email address and display name match and created on the certain date range - if startDate parameter is defined, endpoint will search users that created start from the defined date - if endDate parameter is defined, endpoint will search users that created until the defined date - if platformId parameter is defined and by parameter is using thirdparty, endpoint will search users based on the platformId they have linked to - if platformBy parameter is defined and by parameter is using thirdparty, endpoint will search users based on the platformUserId or platformDisplayName they have linked to, example value: platformUserId or platformDisplayName - if limit is not defined, The default limit is 100 In multi tenant mode : - if super admin search in super admin namespace, the result will be all game admin user - if super admin search in game studio namespace, the result will be all game admin user and players under the game studio namespace - if super admin search in game namespace, the result will be all game admin users and players under the game namespace - if game admin search in their game studio namespace, the result will be all game admin user in the studio namespace - if game admin search in their game namespace, the result will be all player in the game namespace action code : 10133
     */
    getUsersSearch_v3,
    /**
     * @deprecated
     * ## The endpoint is going to be deprecated **Endpoint migration guide** - **Substitute endpoint: _/iam/v3/admin/namespaces/{namespace}/users/{userId} [GET]_**
     */
    getUser_ByUserId_v2,
    /**
     * @deprecated
     * ## The endpoint is going to be deprecated **Endpoint migration guide** - **Substitute endpoint: _/iam/v3/admin/namespaces/{namespace}/users/{userId} [PATCH]_** This Endpoint support update user based on given data. **Single request can update single field or multi fields.** Supported field {Country, DisplayName, LanguageTag} Country use ISO3166-1 alpha-2 two letter, e.g. US. **Several case of updating email address** - User want to update email address of which have been verified, NewEmailAddress response field will be filled with new email address. - User want to update email address of which have not been verified, {LoginId, OldEmailAddress, EmailAddress} response field will be filled with new email address. - User want to update email address of which have been verified and updated before, {LoginId, OldEmailAddress, EmailAddress} response field will be filled with verified email before. NewEmailAddress response field will be filled with newest email address.
     */
    patchUser_ByUserId_v2,
    /**
     * Admin Get User By User Id
     */
    getUser_ByUserId_v3,
    /**
     * This Endpoint support update user based on given data. **Single request can update single field or multi fields.** Supported field {country, displayName, languageTag, dateOfBirth, avatarUrl, userName} Country use ISO3166-1 alpha-2 two letter, e.g. US. Date of Birth format : YYYY-MM-DD, e.g. 2019-04-29. **Response body logic when user updating email address:** - User want to update email address of which have been verified, NewEmailAddress response field will be filled with new email address. - User want to update email address of which have not been verified, {LoginId, OldEmailAddress, EmailAddress} response field will be filled with new email address. - User want to update email address of which have been verified and updated before, {LoginId, OldEmailAddress, EmailAddress} response field will be filled with verified email before. NewEmailAddress response field will be filled with newest email address. action code : 10103
     */
    patchUser_ByUserId_v3,
    /**
     * @deprecated
     * ## The endpoint is going to be deprecated **Endpoint migration guide** - **Substitute endpoint: _/iam/v3/admin/namespaces/{namespace}/agerestrictions [GET]_** - **Note:** difference in V3 response, format difference: Pascal case =&gt; Camel case
     */
    getAgerestrictions_v2,
    /**
     * @deprecated
     * ## The endpoint is going to be deprecated **Endpoint migration guide** - **Substitute endpoint: _/iam/v3/admin/namespaces/{namespace}/agerestrictions [PATCH]_**
     */
    patchAgerestriction_v2,
    /**
     * action code: 10138
     */
    getAgerestrictions_v3,
    /**
     * action code: 10122
     */
    patchAgerestriction_v3,
    /**
     * This endpoint search user by the list of email addresses action code : 10132
     */
    fetchUserSearchBulk_v3,
    /**
     * @deprecated
     * ## The endpoint is going to be deprecated **Endpoint migration guide** - **Substitute endpoint: _/iam/v3/admin/namespaces/{namespace}/users/{userId}/bans [POST]_**
     */
    createBan_ByUserId_v2,
    /**
     * @deprecated
     * ## The endpoint is going to be deprecated **Endpoint migration guide** - **Substitute endpoint: _/iam/v3/admin/namespaces/{namespace}/users/{userId}/bans [GET]_**
     */
    getBans_ByUserId_v2,
    /**
     * This endpoint retrieve the first page of the data if after and before parameters is empty action code : 10126
     */
    getBans_ByUserId_v3,
    /**
     * Bans a user with specific type of ban. Ban types and reason can be queried. action code : 10141
     */
    createBan_ByUserId_v3,
    /**
     * if limit is not defined, The default limit is 100
     */
    getUsersLinkhistories_v3,
    /**
     * @deprecated
     * ## The endpoint is going to be deprecated **Endpoint migration guide** - **Substitute endpoint: _/iam/v3/admin/namespaces/{namespace}/users/{userId}/roles [PATCH]_**
     */
    updateRole_ByUserId_v2,
    /**
     * @deprecated
     * ## The endpoint is going to be deprecated **Endpoint migration guide** - **Substitute endpoint: _/iam/v3/admin/namespaces/{namespace}/users/{userId}/roles [PATCH]_**
     */
    updateRole_ByUserId_ByNS_v2,
    /**
     * This endpoint search admin users which have the roleId Notes : this endpoint only accept admin role. Admin Role is role which have admin status and members. Use endpoint [GET] /roles/{roleId}/admin to check the role status action code : 10140
     */
    getUsers_ByRoleId_v3,
    /**
     * **[WARNING] This endpoint is only for testing purpose.** This endpoint get active user verification code. There are some scenarios of getting verification codes, all of them will be returned on this endpoint: - After account registration - After reset password request - After headless account upgrade - After update email request This API only accept publisher/studio namespace and userId. Action code: 10146
     */
    getCodes_ByUserId_v3,
    /**
     * Delete User Roles
     */
    deleteRole_ByUserId_v3,
    /**
     * User&#39;s roles will be replaced with roles from request body. An admin user can only assign role with **namespace** (in request body) if the admin user has required permission which is same as the required permission of endpoint: [AdminAddUserRoleV4].
     */
    patchRole_ByUserId_v3,
    /**
     * Notes: - This endpoint bulk get users&#39; basic info by userId, max allowed 100 at a time - If namespace is game, will search by game user Id, other wise will search by publisher namespace
     */
    fetchUserBulkPlatform_v3,
    /**
     * @deprecated
     * ## The endpoint is going to be deprecated **Endpoint migration guide** - **Substitute endpoint: _/iam/v3/admin/namespaces/{namespace}/users/{userId}/status [PATCH]_**
     */
    updateEnable_ByUserId_v2,
    /**
     * This endpoint disable or enable user account. Set the enable status on the request body to true to enable user account or set to false to disable it. Disable user for **Account Disable** purpose fill the reason with: - **AdminDeactivateAccount** : if your disable account request comes from admin Enable user ignore field &#39;reason&#39; in the request body. action code : 10143
     */
    patchStatus_ByUserId_v3,
    /**
     * This endpoint force verify user Note: - namespace: only accept publisher/studio namespace - userId: only accept publisher/studio userId action code: 10118
     */
    updateVerify_ByUserId_v3,
    /**
     * @deprecated
     * ## The endpoint is going to be deprecated **Endpoint migration guide** - **Substitute endpoint: _/iam/v3/admin/namespaces/{namespace}/users/{userId}/status [PATCH]_** For **Deletion Account** purpose fill the reason with: - **DeactivateAccount** : if your deletion request comes from user - **AdminDeactivateAccount** : if your deletion request comes from admin
     */
    updateDisable_ByUserId_v2,
    /**
     * @deprecated
     * ## The endpoint is going to be deprecated **Endpoint migration guide** - **Substitute endpoint: _/iam/v3/admin/namespaces/{namespace}/agerestrictions/countries/{countryCode} [PATCH]_**
     */
    patchCountry_ByCountryCode_v2,
    /**
     * @deprecated
     * ## The endpoint is going to be deprecated **Endpoint migration guide** - **Substitute endpoint: _/iam/v3/admin/namespaces/{namespace}/users/{userId}/password [PUT]_**
     */
    updatePassword_ByUserId_v2,
    /**
     * Update User Password
     */
    updatePassword_ByUserId_v3,
    /**
     * **This endpoint requires publisher namespace.** Returns list of users ID and namespace with their Justice platform account, under a namespace. If user doesn&#39;t have Justice platform account, the linkedPlatforms will be empty array.&#39;
     */
    getUsersPlatformsJustice_v3,
    /**
     * Gets platform accounts that are already linked with user account. Action code : 10128 **Supported Platforms:** - Steam group (steamnetwork): - steam - steamopenid - PSN group (psn): - ps4web - ps4 - ps5 - XBOX group(xbox): - live - xblweb - Oculus group (oculusgroup): - oculus - oculusweb - Google group (google): - google - googleplaygames: - epicgames - facebook - twitch - discord - android - ios - apple - device - nintendo - awscognito - amazon - netflix - snapchat - _oidc platform id_ Note: - You can use either platform id or platform group as **platformId** parameter. - **Nintendo platform user id**: NSA ID need to be appended with Environment ID using colon as separator. e.g kmzwa8awaa:dd1 ## Justice Platform Account The permission ’ADMIN:NAMESPACE:{namespace}:JUSTICE:USER:{userId}’ [READ] is required in order to read the UserID who linked with the user.
     */
    getPlatforms_ByUserId_v3,
    /**
     * @deprecated
     * ## The endpoint is going to be deprecated **Endpoint migration guide** - **Substitute endpoint: _/iam/v3/admin/namespaces/{namespace}/agerestrictions/countries [GET]_**
     */
    getCountriesAgerestrictions_v2,
    /**
     * action code : 10139
     */
    getAgerestrictionsCountries_v3,
    /**
     * Will verify account and consume code if validateOnly is set false in request body Redeems a verification code sent to a user to verify the user&#39;s contact address is correct Available ContactType : **email** or **phone**
     */
    updateCodeVerify_ByUserId_v3,
    /**
     * [WARNING] This endpoint is deleting user data from database directly by skipping GDPR flow
     */
    deleteInformation_ByUserId_v3,
    /**
     * Delete User Permission
     */
    deletePermission_ByUserId_v3,
    /**
     * This endpoint will APPEND user&#39;s permissions with the ones defined in body Schedule contains cron string or date range (both are UTC, also in cron syntax) to indicate when a permission and action are in effect. Both schedule types accepts quartz compatible cron syntax e.g. * * * * * * *. In ranged schedule, first element will be start date, and second one will be end date If schedule is set, the scheduled action must be valid too, that is between 1 to 15, inclusive Syntax reference Fields: 1. Seconds: 0-59 * / , - 1. Minutes: 0-59 * / , - 1. Hours: 0-23 * / , - 1. Day of month: 1-31 * / , - L W 1. Month: 1-12 JAN-DEC * / , - 1. Day of week: 0-6 SUN-SAT * / , - L # 1. Year: 1970-2099 * / , - Special characters: 1. *: all values in the fields, e.g. * in seconds fields indicates every second 1. /: increments of ranges, e.g. 3-59/15 in the minute field indicate the third minute of the hour and every 15 minutes thereafter 1. ,: separate items of a list, e.g. MON,WED,FRI in day of week 1. -: range, e.g. 2010-2018 indicates every year between 2010 and 2018, inclusive 1. L: last, e.g. When used in the day-of-week field, it allows you to specify constructs such as &#34;the last Friday&#34; (5L) of a given month. In the day-of-month field, it specifies the last day of the month. 1. W: business day, e.g. if you were to specify 15W as the value for the day-of-month field, the meaning is: &#34;the nearest business day to the 15th of the month.&#34; 1. #: must be followed by a number between one and five. It allows you to specify constructs such as &#34;the second Friday&#34; of a given month.
     */
    createPermission_ByUserId_v3,
    /**
     * This endpoint will REPLACE user&#39;s permissions with the ones defined in body Schedule contains cron string or date range (both are UTC, also in cron syntax) to indicate when a permission and action are in effect. Both schedule types accepts quartz compatible cron syntax e.g. * * * * * * *. In ranged schedule, first element will be start date, and second one will be end date If schedule is set, the scheduled action must be valid too, that is between 1 to 15, inclusive Syntax reference Fields: 1. Seconds: 0-59 * / , - 2. Minutes: 0-59 * / , - 3. Hours: 0-23 * / , - 4. Day of month: 1-31 * / , - L W 5. Month: 1-12 JAN-DEC * / , - 6. Day of week: 0-6 SUN-SAT * / , - L # 7. Year: 1970-2099 * / , - Special characters: 1. *: all values in the fields, e.g. * in seconds fields indicates every second 2. /: increments of ranges, e.g. 3-59/15 in the minute field indicate the third minute of the hour and every 15 minutes thereafter 3. ,: separate items of a list, e.g. MON,WED,FRI in day of week 4. -: range, e.g. 2010-2018 indicates every year between 2010 and 2018, inclusive 5. L: last, e.g. When used in the day-of-week field, it allows you to specify constructs such as &#34;the last Friday&#34; (5L) of a given month. In the day-of-month field, it specifies the last day of the month. 6. W: business day, e.g. if you were to specify 15W as the value for the day-of-month field, the meaning is: &#34;the nearest business day to the 15th of the month.&#34; 7. #: must be followed by a number between one and five. It allows you to specify constructs such as &#34;the second Friday&#34; of a given month.
     */
    updatePermission_ByUserId_v3,
    /**
     * Set ban status for a single user for a specific ban. Retrieve user ban and choose the ban ID. Set the form parameter to true/false to enable or disable the ban. action code : 10142&#39;
     */
    patchBan_ByUserId_ByBanId_v3,
    /**
     * This endpoint get user&#39;s bans summary&#39;
     */
    getBansSummary_ByUserId_v3,
    /**
     * The verification code is sent to email address. Available contexts for use : - **UserAccountRegistration** a context type used for verifying email address in user account registration. It returns 409 if the email address already verified. **_It is the default context if the Context field is empty_** - **UpdateEmailAddress** a context type used for verify user before updating email address.(Without email address verified checking) - **upgradeHeadlessAccount** The context is intended to be used whenever the email address wanted to be automatically verified on upgrading a headless account. If this context used, IAM rejects the request if the email address is already used by others by returning HTTP Status Code 409. action code: 10116
     */
    updateCodeRequest_ByUserId_v3,
    /**
     * Admin List User ID By Platform User ID This endpoint intended to list game user ID from the given namespace This endpoint return list of user ID by given platform ID and list of platform user ID Supported platform: - steam - steamopenid - ps4web - ps4 - ps5 - live - xblweb - oculus - oculusweb - facebook - google - googleplaygames - twitch - discord - android - ios - apple - device - justice - epicgames - nintendo - awscognito - netflix - snapchat - oidc platform id Note: **nintendo platform user ID**: NSA ID need to be appended with Environment ID using colon as separator. e.g kmzwa8awaa:dd1
     */
    fetchUser_ByPlatformId_v3,
    /**
     * Force linking platform account to user User Account. This endpoint intended for admin to forcefully link account to user. By default, these cases are not allowed - The platform account current is linked by another account - The target account ever linked this platform&#39;s another account
     */
    updatePlatformLink_ByUserId_v3,
    /**
     * This endpoint removes role from user action code: 10110
     */
    deleteRole_ByUserId_ByRoleId_v3,
    /**
     * action code: 10109
     */
    updateRole_ByUserId_ByRoleId_v3,
    /**
     * action code : 10145
     */
    getDeletionStatus_ByUserId_v3,
    /**
     * action code : 10144
     */
    patchDeletionStatus_ByUserId_v3,
    /**
     * Notes for this endpoint: This endpoint retrieve the first page of the data if &lt;code&gt;after&lt;/code&gt; and &lt;code&gt;before&lt;/code&gt; parameters is empty. - The maximum value of the limit is 100 and the minimum value of the limit is 1. - This endpoint retrieve the next page of the data if we provide &lt;code&gt;after&lt;/code&gt; parameters with valid Unix timestamp. - This endpoint retrieve the previous page of the data if we provide &lt;code&gt;before&lt;/code&gt; parameter with valid data Unix timestamp.&#34;
     */
    getLoginsHistories_ByUserId_v3,
    /**
     * This endpoint ONLY accept **Client Token** This endpoint is utilized for specific scenarios where **email notifications are disabled** The user&#39;s email will be marked as verified Note: - emailAddress or password field are optional - request body can&#39;t be empty action code : 10103
     */
    patchTrustlyIdentity_ByUserId_v3,
    /**
     * This endpoint retrieves platform accounts linked to user. It will query all linked platform accounts and result will be distinct &amp; grouped, same platform we will pick oldest linked one.
     */
    getDistinctPlatforms_ByUserId_v3,
    /**
     * This endpoint gets list justice platform account by providing publisher namespace and publisher userID
     */
    getPlatformsJustice_ByUserId_v3,
    /**
     * This endpoint only retrieves 3rd party platform accounts linked to user. It will query platform accounts and result will be distinct &amp; grouped, same platform we will pick oldest linked one. ------ Supported status: - LINKED - RESTRICTIVELY_UNLINKED - UNLINKED - ALL
     */
    getPlatformsDistinct_ByUserId_v3,
    /**
     * If validateOnly is set false, will upgrade headless account with verification code The endpoint upgrades a headless account by linking the headless account with the email address and the password. By upgrading the headless account into a full account, the user could use the email address and password for using Justice IAM. The endpoint is a shortcut for upgrading a headless account and verifying the email address in one call. In order to get a verification code for the endpoint, please check the send verification code endpoint. This endpoint also have an ability to update user data (if the user data field is specified) right after the upgrade account process is done. Supported user data fields : - displayName - dateOfBirth : format YYYY-MM-DD, e.g. 2019-04-29 - country : format ISO3166-1 alpha-2 two letter, e.g. US action code : 10124
     */
    updateHeadlesCodeVerify_ByUserId_v3,
    /**
     * @deprecated
     * ## Supported platforms: - **steam** - **steamopenid** - **facebook** - **google** - **googleplaygames** - **oculus** - **twitch** - **android** - **ios** - **apple** - **device** - **discord** - **awscognito** - **epicgames** - **nintendo** - **snapchat** Unlink user&#39;s account from a specific platform. &#39;justice&#39; platform might have multiple accounts from different namespaces linked. _platformNamespace_ need to be specified when the platform ID is &#39;justice&#39;. Unlink user&#39;s account from justice platform will enable password token grant and password update. If you want to unlink user&#39;s account in a game namespace, you have to specify _platformNamespace_ to that game namespace. action code : 10121
     */
    deletePlatform_ByUserId_ByPlatformId_v3,
    /**
     * action code: 10123
     */
    patchAgerestrictionCountry_ByCountryCode_v3,
    /**
     * This API is for admin to get user&#39;s link history. **Supported Platforms:** - Steam group (steamnetwork): - steam - steamopenid - PSN group (psn): - ps4web - ps4 - ps5 - XBOX group(xbox): - live - xblweb - Oculus group (oculusgroup): - oculus - oculusweb - Google group (google): - google - googleplaygames: - epicgames - facebook - twitch - discord - android - ios - apple - device - nintendo - awscognito - amazon - netflix - snapchat - _oidc platform id_ Note: - You can use either platform id or platform group as **platformId** parameter. - **Nintendo platform user id**: NSA ID need to be appended with Environment ID using colon as separator. e.g kmzwa8awaa:dd1
     */
    getPlatformsLinkHistories_ByUserId_v3,
    /**
     * Unlink user&#39;s account from third platform in all namespaces. Several platforms are grouped under account groups, you can use either platform ID or platform group as platformId path parameter. example: to unlink steam third party account, you can use steamnetwork / steam / steamopenid as platformId path parameter. **Supported Platforms:** - Steam group (steamnetwork): - steam - steamopenid - PSN group (psn): - ps4web - ps4 - ps5 - XBOX group(xbox): - live - xblweb - Oculus group (oculusgroup): - oculus - oculusweb - Google group (google): - google - googleplaygames: - epicgames - facebook - twitch - discord - android - ios - apple - device - nintendo - awscognito - amazon - netflix - snapchat - _oidc platform id_ Note: - You can use either platform id or platform group as **platformId** parameter. - **Nintendo platform user id**: NSA ID need to be appended with Environment ID using colon as separator. e.g kmzwa8awaa:dd1 Unlink platform account associated with a group: If user unlink platform account associated with a group, the API logic will unlink all of platform account under that group as well. example: if user unlink from ps4, the API logic will unlink ps5 and ps4web as well
     */
    deleteAll_ByUserId_ByPlatformId_v3,
    /**
     * @deprecated
     * ## The endpoint is going to be deprecated **Endpoint migration guide** - **Substitute endpoint: _/iam/v3/admin/namespaces/{namespace}/users/{userId}/platforms/{platformId} [DELETE]_** ## Supported platforms: - **steam** - **steamopenid** - **facebook** - **google** - **oculus** - **twitch** - **android** - **ios** - **device** - **discord** Delete link of user&#39;s account with platform. &#39;justice&#39; platform might have multiple accounts from different namespaces linked. platform_namespace need to be specified when the platform ID is &#39;justice&#39;. Delete link of justice platform will enable password token grant and password update.
     */
    deleteLink_ByUserId_ByPlatformId_v2,
    /**
     * **Prerequisite:** Platform client configuration need to be added to database for specific platformId. Namespace service URL need to be specified (refer to required environment variables). ## Supported platforms: - **steam**: The ticket’s value is the authentication code returned by Steam. - **steamopenid**: Steam&#39;s user authentication method using OpenID 2.0. The ticket&#39;s value is URL generated by Steam on web authentication - **facebook**: The ticket’s value is the authorization code returned by Facebook OAuth - **google**: The ticket’s value is the authorization code returned by Google OAuth - **googleplaygames**: The ticket’s value is the authorization code returned by Google play games OAuth - **oculus**: The ticket’s value is a string composed of Oculus&#39;s user ID and the nonce separated by a colon (:). - **twitch**: The ticket’s value is the authorization code returned by Twitch OAuth. - **android**: The ticket&#39;s value is the Android’s device ID - **ios**: The ticket&#39;s value is the iOS’s device ID. - **apple**: The ticket’s value is the authorization code returned by Apple OAuth. - **device**: Every device that does’nt run Android and iOS is categorized as a device platform. The ticket&#39;s value is the device’s ID. - **discord**: The ticket’s value is the authorization code returned by Discord OAuth. - **awscognito**: The ticket’s value is the aws cognito access token (JWT). - **epicgames**: The ticket’s value is an access-token obtained from Epicgames EOS Account Service. - **nintendo**: The ticket’s value is the authorization code(id_token) returned by Nintendo OAuth.
     */
    postLink_ByUserId_ByPlatformId_v3,
    /**
     * Get User By Platform User ID This endpoint return user information by given platform ID and platform user ID. Several platforms are grouped under account groups, you can use either platform ID or platform group as platformId path parameter. example: for steam network platform, you can use steamnetwork / steam / steamopenid as platformId path parameter. **Supported Platforms:** - Steam group (steamnetwork): - steam - steamopenid - PSN group (psn): - ps4web - ps4 - ps5 - XBOX group(xbox): - live - xblweb - Oculus group (oculusgroup): - oculus - oculusweb - Google group (google): - google - googleplaygames: - epicgames - facebook - twitch - discord - android - ios - apple - device - nintendo - awscognito - amazon - netflix - snapchat - _oidc platform id_ Note: - You can use either platform id or platform group as **platformId** parameter. - **Nintendo platform user id**: NSA ID need to be appended with Environment ID using colon as separator. e.g kmzwa8awaa:dd1
     */
    getUser_ByPlatformId_ByPlatformUserId_v3,
    /**
     * Delete User Permission
     */
    deletePermission_ByUserId_ByResource_ByAction_v3,
    /**
     * This endpoint gets user single platform account metadata. **Supported Platforms:** - Steam group (steamnetwork): - steam - steamopenid - PSN group (psn): - ps4web - ps4 - ps5 - XBOX group(xbox): - live - xblweb - Oculus group (oculusgroup): - oculus - oculusweb - Google group (google): - google - googleplaygames: - epicgames - facebook - twitch - discord - android - ios - apple - device - nintendo - awscognito - amazon - netflix - snapchat - _oidc platform id_ Note: - You can use either platform id or platform group as **platformId** parameter. - **Nintendo platform user id**: NSA ID need to be appended with Environment ID using colon as separator. e.g kmzwa8awaa:dd1
     */
    getMetadata_ByUserId_ByPlatformId_v3,
    /**
     * Admin get the link status of the third party platform token with user id. This endpoint is used for checking whether the third party user represented by third party token is linked with the corresponding user id. ## Supported platforms: - **steam**: The platform_token’s value is the authentication code returned by Steam. - **steamopenid**: Steam&#39;s user authentication method using OpenID 2.0. The platform_token&#39;s value is URL generated by Steam on web authentication - **facebook**: The platform_token’s value is the authorization code returned by Facebook OAuth - **google**: The platform_token’s value is the authorization code returned by Google OAuth - **googleplaygames**: The platform_token’s value is the authorization code returned by Google play games OAuth - **oculus**: The platform_token’s value is a string composed of Oculus&#39;s user ID and the nonce separated by a colon (:). - **twitch**: The platform_token’s value is the authorization code returned by Twitch OAuth. - **discord**: The platform_token’s value is the authorization code returned by Discord OAuth - **android**: The device_id is the Android’s device ID - **ios**: The device_id is the iOS’s device ID. - **apple**: The platform_token’s value is the authorization code returned by Apple OAuth.(We will use this code to generate APP token) - **device**: Every device that does’nt run Android and iOS is categorized as a device. The device_id is the device’s ID. - **justice**: The platform_token’s value is the designated user’s access token. - **epicgames**: The platform_token’s value is an access-token obtained from Epicgames EOS Account Service. - **ps4**: The platform_token’s value is the authorization code returned by Sony OAuth. - **ps5**: The platform_token’s value is the authorization code returned by Sony OAuth. - **nintendo**: The platform_token’s value is the authorization code(id_token) returned by Nintendo OAuth. - **awscognito**: The platform_token’s value is the aws cognito access token or id token (JWT). - **live**: The platform_token’s value is xbox XSTS token - **xblweb**: The platform_token’s value is code returned by xbox after login - **netflix**: The platform_token’s value is GAT (Gamer Access Token) returned by Netflix backend - **snapchat**: The platform_token’s value is the authorization code returned by Snapchat OAuth.
     */
    postLinkStatu_ByUserId_ByPlatformId_v3,
    /**
     * This endpoint will support publisher access to game and game access to publisher If targetNamespace filled with publisher namespace then this endpoint will return its publisher user id and publisher namespace. If targetNamespace filled with game namespace then this endpoint will return its game user id and game namespace.
     */
    getPlatformJustice_ByUserId_ByTargetNamespace_v3,
    /**
     * Create Justice User from Publisher User information. It will check first if Justice User on target namespace already exist.
     */
    createPlatformJustice_ByUserId_ByTargetNamespace_v3,
    /**
     * @deprecated
     * This API is for admin to delete user&#39;s linking history with target platform id. **Supported Platforms:** - Steam group (steamnetwork): - steam - steamopenid - PSN group (psn): - ps4web - ps4 - ps5 - XBOX group(xbox): - live - xblweb - Oculus group (oculusgroup): - oculus - oculusweb - Google group (google): - google - googleplaygames: - epicgames - facebook - twitch - discord - android - ios - apple - device - nintendo - awscognito - amazon - netflix - snapchat - _oidc platform id_ Note: - You can use either platform id or platform group as **platformId** parameter. - **Nintendo platform user id**: NSA ID need to be appended with Environment ID using colon as separator. e.g kmzwa8awaa:dd1 ---- **Substitute endpoint**: /v3/admin/namespaces/{namespace}/users/{userId}/platforms/{platformId}/link/restrictions
     */
    deleteLinkHistory_ByUserId_ByPlatformId_v3,
    /**
     * This API is for admin to delete user&#39;s linking restriction with target platform id. **Supported Platforms:** - Steam group (steamnetwork): - steam - steamopenid - PSN group (psn): - ps4web - ps4 - ps5 - XBOX group(xbox): - live - xblweb - Oculus group (oculusgroup): - oculus - oculusweb - Google group (google): - google - googleplaygames: - epicgames - facebook - twitch - discord - android - ios - apple - device - nintendo - awscognito - amazon - netflix - snapchat - _oidc platform id_ Note: - You can use either platform id or platform group as **platformId** parameter. - **Nintendo platform user id**: NSA ID need to be appended with Environment ID using colon as separator. e.g kmzwa8awaa:dd1
     */
    deleteLinkRestriction_ByUserId_ByPlatformId_v3
  };
}

// src/generated-admin/queries/UsersAdmin.query.ts
var Key_UsersAdmin = /* @__PURE__ */ ((Key_UsersAdmin2) => {
  Key_UsersAdmin2["UsersMe_v3"] = "Iam.UsersAdmin.UsersMe_v3";
  Key_UsersAdmin2["Users_v2"] = "Iam.UsersAdmin.Users_v2";
  Key_UsersAdmin2["Users_v3"] = "Iam.UsersAdmin.Users_v3";
  Key_UsersAdmin2["User_v3"] = "Iam.UsersAdmin.User_v3";
  Key_UsersAdmin2["Admins_v3"] = "Iam.UsersAdmin.Admins_v3";
  Key_UsersAdmin2["UserBan_v3"] = "Iam.UsersAdmin.UserBan_v3";
  Key_UsersAdmin2["UserBulk_v3"] = "Iam.UsersAdmin.UserBulk_v3";
  Key_UsersAdmin2["UserInvite_v3"] = "Iam.UsersAdmin.UserInvite_v3";
  Key_UsersAdmin2["UsersSearch_v3"] = "Iam.UsersAdmin.UsersSearch_v3";
  Key_UsersAdmin2["User_ByUserId_v2"] = "Iam.UsersAdmin.User_ByUserId_v2";
  Key_UsersAdmin2["User_ByUserId_v3"] = "Iam.UsersAdmin.User_ByUserId_v3";
  Key_UsersAdmin2["Agerestrictions_v2"] = "Iam.UsersAdmin.Agerestrictions_v2";
  Key_UsersAdmin2["Agerestriction_v2"] = "Iam.UsersAdmin.Agerestriction_v2";
  Key_UsersAdmin2["Agerestrictions_v3"] = "Iam.UsersAdmin.Agerestrictions_v3";
  Key_UsersAdmin2["Agerestriction_v3"] = "Iam.UsersAdmin.Agerestriction_v3";
  Key_UsersAdmin2["UserSearchBulk_v3"] = "Iam.UsersAdmin.UserSearchBulk_v3";
  Key_UsersAdmin2["Ban_ByUserId_v2"] = "Iam.UsersAdmin.Ban_ByUserId_v2";
  Key_UsersAdmin2["Bans_ByUserId_v2"] = "Iam.UsersAdmin.Bans_ByUserId_v2";
  Key_UsersAdmin2["Bans_ByUserId_v3"] = "Iam.UsersAdmin.Bans_ByUserId_v3";
  Key_UsersAdmin2["Ban_ByUserId_v3"] = "Iam.UsersAdmin.Ban_ByUserId_v3";
  Key_UsersAdmin2["UsersLinkhistories_v3"] = "Iam.UsersAdmin.UsersLinkhistories_v3";
  Key_UsersAdmin2["Role_ByUserId_v2"] = "Iam.UsersAdmin.Role_ByUserId_v2";
  Key_UsersAdmin2["Role_ByUserId_ByNS_v2"] = "Iam.UsersAdmin.Role_ByUserId_ByNS_v2";
  Key_UsersAdmin2["Users_ByRoleId_v3"] = "Iam.UsersAdmin.Users_ByRoleId_v3";
  Key_UsersAdmin2["Codes_ByUserId_v3"] = "Iam.UsersAdmin.Codes_ByUserId_v3";
  Key_UsersAdmin2["Role_ByUserId_v3"] = "Iam.UsersAdmin.Role_ByUserId_v3";
  Key_UsersAdmin2["UserBulkPlatform_v3"] = "Iam.UsersAdmin.UserBulkPlatform_v3";
  Key_UsersAdmin2["Enable_ByUserId_v2"] = "Iam.UsersAdmin.Enable_ByUserId_v2";
  Key_UsersAdmin2["Status_ByUserId_v3"] = "Iam.UsersAdmin.Status_ByUserId_v3";
  Key_UsersAdmin2["Verify_ByUserId_v3"] = "Iam.UsersAdmin.Verify_ByUserId_v3";
  Key_UsersAdmin2["Disable_ByUserId_v2"] = "Iam.UsersAdmin.Disable_ByUserId_v2";
  Key_UsersAdmin2["Country_ByCountryCode_v2"] = "Iam.UsersAdmin.Country_ByCountryCode_v2";
  Key_UsersAdmin2["Password_ByUserId_v2"] = "Iam.UsersAdmin.Password_ByUserId_v2";
  Key_UsersAdmin2["Password_ByUserId_v3"] = "Iam.UsersAdmin.Password_ByUserId_v3";
  Key_UsersAdmin2["UsersPlatformsJustice_v3"] = "Iam.UsersAdmin.UsersPlatformsJustice_v3";
  Key_UsersAdmin2["Platforms_ByUserId_v3"] = "Iam.UsersAdmin.Platforms_ByUserId_v3";
  Key_UsersAdmin2["CountriesAgerestrictions_v2"] = "Iam.UsersAdmin.CountriesAgerestrictions_v2";
  Key_UsersAdmin2["AgerestrictionsCountries_v3"] = "Iam.UsersAdmin.AgerestrictionsCountries_v3";
  Key_UsersAdmin2["CodeVerify_ByUserId_v3"] = "Iam.UsersAdmin.CodeVerify_ByUserId_v3";
  Key_UsersAdmin2["Information_ByUserId_v3"] = "Iam.UsersAdmin.Information_ByUserId_v3";
  Key_UsersAdmin2["Permission_ByUserId_v3"] = "Iam.UsersAdmin.Permission_ByUserId_v3";
  Key_UsersAdmin2["Ban_ByUserId_ByBanId_v3"] = "Iam.UsersAdmin.Ban_ByUserId_ByBanId_v3";
  Key_UsersAdmin2["BansSummary_ByUserId_v3"] = "Iam.UsersAdmin.BansSummary_ByUserId_v3";
  Key_UsersAdmin2["CodeRequest_ByUserId_v3"] = "Iam.UsersAdmin.CodeRequest_ByUserId_v3";
  Key_UsersAdmin2["User_ByPlatformId_v3"] = "Iam.UsersAdmin.User_ByPlatformId_v3";
  Key_UsersAdmin2["PlatformLink_ByUserId_v3"] = "Iam.UsersAdmin.PlatformLink_ByUserId_v3";
  Key_UsersAdmin2["Role_ByUserId_ByRoleId_v3"] = "Iam.UsersAdmin.Role_ByUserId_ByRoleId_v3";
  Key_UsersAdmin2["DeletionStatus_ByUserId_v3"] = "Iam.UsersAdmin.DeletionStatus_ByUserId_v3";
  Key_UsersAdmin2["LoginsHistories_ByUserId_v3"] = "Iam.UsersAdmin.LoginsHistories_ByUserId_v3";
  Key_UsersAdmin2["TrustlyIdentity_ByUserId_v3"] = "Iam.UsersAdmin.TrustlyIdentity_ByUserId_v3";
  Key_UsersAdmin2["DistinctPlatforms_ByUserId_v3"] = "Iam.UsersAdmin.DistinctPlatforms_ByUserId_v3";
  Key_UsersAdmin2["PlatformsJustice_ByUserId_v3"] = "Iam.UsersAdmin.PlatformsJustice_ByUserId_v3";
  Key_UsersAdmin2["PlatformsDistinct_ByUserId_v3"] = "Iam.UsersAdmin.PlatformsDistinct_ByUserId_v3";
  Key_UsersAdmin2["HeadlesCodeVerify_ByUserId_v3"] = "Iam.UsersAdmin.HeadlesCodeVerify_ByUserId_v3";
  Key_UsersAdmin2["Platform_ByUserId_ByPlatformId_v3"] = "Iam.UsersAdmin.Platform_ByUserId_ByPlatformId_v3";
  Key_UsersAdmin2["AgerestrictionCountry_ByCountryCode_v3"] = "Iam.UsersAdmin.AgerestrictionCountry_ByCountryCode_v3";
  Key_UsersAdmin2["PlatformsLinkHistories_ByUserId_v3"] = "Iam.UsersAdmin.PlatformsLinkHistories_ByUserId_v3";
  Key_UsersAdmin2["All_ByUserId_ByPlatformId_v3"] = "Iam.UsersAdmin.All_ByUserId_ByPlatformId_v3";
  Key_UsersAdmin2["Link_ByUserId_ByPlatformId_v2"] = "Iam.UsersAdmin.Link_ByUserId_ByPlatformId_v2";
  Key_UsersAdmin2["Link_ByUserId_ByPlatformId_v3"] = "Iam.UsersAdmin.Link_ByUserId_ByPlatformId_v3";
  Key_UsersAdmin2["User_ByPlatformId_ByPlatformUserId_v3"] = "Iam.UsersAdmin.User_ByPlatformId_ByPlatformUserId_v3";
  Key_UsersAdmin2["Permission_ByUserId_ByResource_ByAction_v3"] = "Iam.UsersAdmin.Permission_ByUserId_ByResource_ByAction_v3";
  Key_UsersAdmin2["Metadata_ByUserId_ByPlatformId_v3"] = "Iam.UsersAdmin.Metadata_ByUserId_ByPlatformId_v3";
  Key_UsersAdmin2["LinkStatu_ByUserId_ByPlatformId_v3"] = "Iam.UsersAdmin.LinkStatu_ByUserId_ByPlatformId_v3";
  Key_UsersAdmin2["PlatformJustice_ByUserId_ByTargetNamespace_v3"] = "Iam.UsersAdmin.PlatformJustice_ByUserId_ByTargetNamespace_v3";
  Key_UsersAdmin2["LinkHistory_ByUserId_ByPlatformId_v3"] = "Iam.UsersAdmin.LinkHistory_ByUserId_ByPlatformId_v3";
  Key_UsersAdmin2["LinkRestriction_ByUserId_ByPlatformId_v3"] = "Iam.UsersAdmin.LinkRestriction_ByUserId_ByPlatformId_v3";
  return Key_UsersAdmin2;
})(Key_UsersAdmin || {});
var useUsersAdminApi_GetUsersMe_v3 = (sdk, input, options, callback) => {
  const queryFn = (sdk2, input2) => async () => {
    const response = await UsersAdminApi(sdk2, { coreConfig: input2.coreConfig, axiosConfig: input2.axiosConfig }).getUsersMe_v3();
    callback && callback(response);
    return response.data;
  };
  return (0, import_react_query15.useQuery)({
    queryKey: ["Iam.UsersAdmin.UsersMe_v3" /* UsersMe_v3 */, input],
    queryFn: queryFn(sdk, input),
    ...options
  });
};
var useUsersAdminApi_GetUsers_v2 = (sdk, input, options, callback) => {
  const queryFn = (sdk2, input2) => async () => {
    const response = await UsersAdminApi(sdk2, { coreConfig: input2.coreConfig, axiosConfig: input2.axiosConfig }).getUsers_v2(
      input2.queryParams
    );
    callback && callback(response);
    return response.data;
  };
  return (0, import_react_query15.useQuery)({
    queryKey: ["Iam.UsersAdmin.Users_v2" /* Users_v2 */, input],
    queryFn: queryFn(sdk, input),
    ...options
  });
};
var useUsersAdminApi_GetUsers_v3 = (sdk, input, options, callback) => {
  const queryFn = (sdk2, input2) => async () => {
    const response = await UsersAdminApi(sdk2, { coreConfig: input2.coreConfig, axiosConfig: input2.axiosConfig }).getUsers_v3(
      input2.queryParams
    );
    callback && callback(response);
    return response.data;
  };
  return (0, import_react_query15.useQuery)({
    queryKey: ["Iam.UsersAdmin.Users_v3" /* Users_v3 */, input],
    queryFn: queryFn(sdk, input),
    ...options
  });
};
var useUsersAdminApi_UpdateUserMutation_v3 = (sdk, options, callback) => {
  const mutationFn = async (input) => {
    const response = await UsersAdminApi(sdk, { coreConfig: input.coreConfig, axiosConfig: input.axiosConfig }).updateUser_v3(input.data);
    callback && callback(response.data);
    return response.data;
  };
  return (0, import_react_query15.useMutation)({
    mutationKey: ["Iam.UsersAdmin.User_v3" /* User_v3 */],
    mutationFn,
    ...options
  });
};
var useUsersAdminApi_GetAdmins_v3 = (sdk, input, options, callback) => {
  const queryFn = (sdk2, input2) => async () => {
    const response = await UsersAdminApi(sdk2, { coreConfig: input2.coreConfig, axiosConfig: input2.axiosConfig }).getAdmins_v3(
      input2.queryParams
    );
    callback && callback(response);
    return response.data;
  };
  return (0, import_react_query15.useQuery)({
    queryKey: ["Iam.UsersAdmin.Admins_v3" /* Admins_v3 */, input],
    queryFn: queryFn(sdk, input),
    ...options
  });
};
var useUsersAdminApi_FetchUserBan_v3 = (sdk, input, options, callback) => {
  const queryFn = (sdk2, input2) => async () => {
    const response = await UsersAdminApi(sdk2, { coreConfig: input2.coreConfig, axiosConfig: input2.axiosConfig }).fetchUserBan_v3(
      input2.data,
      input2.queryParams
    );
    callback && callback(response);
    return response.data;
  };
  return (0, import_react_query15.useQuery)({
    queryKey: ["Iam.UsersAdmin.UserBan_v3" /* UserBan_v3 */, input],
    queryFn: queryFn(sdk, input),
    ...options
  });
};
var useUsersAdminApi_CreateUserBulkMutation_v3 = (sdk, options, callback) => {
  const mutationFn = async (input) => {
    const response = await UsersAdminApi(sdk, { coreConfig: input.coreConfig, axiosConfig: input.axiosConfig }).createUserBulk_v3(
      input.data
    );
    callback && callback(response.data);
    return response.data;
  };
  return (0, import_react_query15.useMutation)({
    mutationKey: ["Iam.UsersAdmin.UserBulk_v3" /* UserBulk_v3 */],
    mutationFn,
    ...options
  });
};
var useUsersAdminApi_CreateUserInviteMutation_v3 = (sdk, options, callback) => {
  const mutationFn = async (input) => {
    const response = await UsersAdminApi(sdk, { coreConfig: input.coreConfig, axiosConfig: input.axiosConfig }).createUserInvite_v3(
      input.data
    );
    callback && callback(response.data);
    return response.data;
  };
  return (0, import_react_query15.useMutation)({
    mutationKey: ["Iam.UsersAdmin.UserInvite_v3" /* UserInvite_v3 */],
    mutationFn,
    ...options
  });
};
var useUsersAdminApi_GetUsersSearch_v3 = (sdk, input, options, callback) => {
  const queryFn = (sdk2, input2) => async () => {
    const response = await UsersAdminApi(sdk2, { coreConfig: input2.coreConfig, axiosConfig: input2.axiosConfig }).getUsersSearch_v3(
      input2.queryParams
    );
    callback && callback(response);
    return response.data;
  };
  return (0, import_react_query15.useQuery)({
    queryKey: ["Iam.UsersAdmin.UsersSearch_v3" /* UsersSearch_v3 */, input],
    queryFn: queryFn(sdk, input),
    ...options
  });
};
var useUsersAdminApi_GetUser_ByUserId_v2 = (sdk, input, options, callback) => {
  const queryFn = (sdk2, input2) => async () => {
    const response = await UsersAdminApi(sdk2, { coreConfig: input2.coreConfig, axiosConfig: input2.axiosConfig }).getUser_ByUserId_v2(
      input2.userId
    );
    callback && callback(response);
    return response.data;
  };
  return (0, import_react_query15.useQuery)({
    queryKey: ["Iam.UsersAdmin.User_ByUserId_v2" /* User_ByUserId_v2 */, input],
    queryFn: queryFn(sdk, input),
    ...options
  });
};
var useUsersAdminApi_PatchUser_ByUserIdMutation_v2 = (sdk, options, callback) => {
  const mutationFn = async (input) => {
    const response = await UsersAdminApi(sdk, { coreConfig: input.coreConfig, axiosConfig: input.axiosConfig }).patchUser_ByUserId_v2(
      input.userId,
      input.data
    );
    callback && callback(response.data);
    return response.data;
  };
  return (0, import_react_query15.useMutation)({
    mutationKey: ["Iam.UsersAdmin.User_ByUserId_v2" /* User_ByUserId_v2 */],
    mutationFn,
    ...options
  });
};
var useUsersAdminApi_GetUser_ByUserId_v3 = (sdk, input, options, callback) => {
  const queryFn = (sdk2, input2) => async () => {
    const response = await UsersAdminApi(sdk2, { coreConfig: input2.coreConfig, axiosConfig: input2.axiosConfig }).getUser_ByUserId_v3(
      input2.userId
    );
    callback && callback(response);
    return response.data;
  };
  return (0, import_react_query15.useQuery)({
    queryKey: ["Iam.UsersAdmin.User_ByUserId_v3" /* User_ByUserId_v3 */, input],
    queryFn: queryFn(sdk, input),
    ...options
  });
};
var useUsersAdminApi_PatchUser_ByUserIdMutation_v3 = (sdk, options, callback) => {
  const mutationFn = async (input) => {
    const response = await UsersAdminApi(sdk, { coreConfig: input.coreConfig, axiosConfig: input.axiosConfig }).patchUser_ByUserId_v3(
      input.userId,
      input.data
    );
    callback && callback(response.data);
    return response.data;
  };
  return (0, import_react_query15.useMutation)({
    mutationKey: ["Iam.UsersAdmin.User_ByUserId_v3" /* User_ByUserId_v3 */],
    mutationFn,
    ...options
  });
};
var useUsersAdminApi_GetAgerestrictions_v2 = (sdk, input, options, callback) => {
  const queryFn = (sdk2, input2) => async () => {
    const response = await UsersAdminApi(sdk2, { coreConfig: input2.coreConfig, axiosConfig: input2.axiosConfig }).getAgerestrictions_v2();
    callback && callback(response);
    return response.data;
  };
  return (0, import_react_query15.useQuery)({
    queryKey: ["Iam.UsersAdmin.Agerestrictions_v2" /* Agerestrictions_v2 */, input],
    queryFn: queryFn(sdk, input),
    ...options
  });
};
var useUsersAdminApi_PatchAgerestrictionMutation_v2 = (sdk, options, callback) => {
  const mutationFn = async (input) => {
    const response = await UsersAdminApi(sdk, { coreConfig: input.coreConfig, axiosConfig: input.axiosConfig }).patchAgerestriction_v2(
      input.data
    );
    callback && callback(response.data);
    return response.data;
  };
  return (0, import_react_query15.useMutation)({
    mutationKey: ["Iam.UsersAdmin.Agerestriction_v2" /* Agerestriction_v2 */],
    mutationFn,
    ...options
  });
};
var useUsersAdminApi_GetAgerestrictions_v3 = (sdk, input, options, callback) => {
  const queryFn = (sdk2, input2) => async () => {
    const response = await UsersAdminApi(sdk2, { coreConfig: input2.coreConfig, axiosConfig: input2.axiosConfig }).getAgerestrictions_v3();
    callback && callback(response);
    return response.data;
  };
  return (0, import_react_query15.useQuery)({
    queryKey: ["Iam.UsersAdmin.Agerestrictions_v3" /* Agerestrictions_v3 */, input],
    queryFn: queryFn(sdk, input),
    ...options
  });
};
var useUsersAdminApi_PatchAgerestrictionMutation_v3 = (sdk, options, callback) => {
  const mutationFn = async (input) => {
    const response = await UsersAdminApi(sdk, { coreConfig: input.coreConfig, axiosConfig: input.axiosConfig }).patchAgerestriction_v3(
      input.data
    );
    callback && callback(response.data);
    return response.data;
  };
  return (0, import_react_query15.useMutation)({
    mutationKey: ["Iam.UsersAdmin.Agerestriction_v3" /* Agerestriction_v3 */],
    mutationFn,
    ...options
  });
};
var useUsersAdminApi_FetchUserSearchBulk_v3 = (sdk, input, options, callback) => {
  const queryFn = (sdk2, input2) => async () => {
    const response = await UsersAdminApi(sdk2, { coreConfig: input2.coreConfig, axiosConfig: input2.axiosConfig }).fetchUserSearchBulk_v3(
      input2.data
    );
    callback && callback(response);
    return response.data;
  };
  return (0, import_react_query15.useQuery)({
    queryKey: ["Iam.UsersAdmin.UserSearchBulk_v3" /* UserSearchBulk_v3 */, input],
    queryFn: queryFn(sdk, input),
    ...options
  });
};
var useUsersAdminApi_CreateBan_ByUserIdMutation_v2 = (sdk, options, callback) => {
  const mutationFn = async (input) => {
    const response = await UsersAdminApi(sdk, { coreConfig: input.coreConfig, axiosConfig: input.axiosConfig }).createBan_ByUserId_v2(
      input.userId,
      input.data
    );
    callback && callback(response.data);
    return response.data;
  };
  return (0, import_react_query15.useMutation)({
    mutationKey: ["Iam.UsersAdmin.Ban_ByUserId_v2" /* Ban_ByUserId_v2 */],
    mutationFn,
    ...options
  });
};
var useUsersAdminApi_GetBans_ByUserId_v2 = (sdk, input, options, callback) => {
  const queryFn = (sdk2, input2) => async () => {
    const response = await UsersAdminApi(sdk2, { coreConfig: input2.coreConfig, axiosConfig: input2.axiosConfig }).getBans_ByUserId_v2(
      input2.userId,
      input2.queryParams
    );
    callback && callback(response);
    return response.data;
  };
  return (0, import_react_query15.useQuery)({
    queryKey: ["Iam.UsersAdmin.Bans_ByUserId_v2" /* Bans_ByUserId_v2 */, input],
    queryFn: queryFn(sdk, input),
    ...options
  });
};
var useUsersAdminApi_GetBans_ByUserId_v3 = (sdk, input, options, callback) => {
  const queryFn = (sdk2, input2) => async () => {
    const response = await UsersAdminApi(sdk2, { coreConfig: input2.coreConfig, axiosConfig: input2.axiosConfig }).getBans_ByUserId_v3(
      input2.userId,
      input2.queryParams
    );
    callback && callback(response);
    return response.data;
  };
  return (0, import_react_query15.useQuery)({
    queryKey: ["Iam.UsersAdmin.Bans_ByUserId_v3" /* Bans_ByUserId_v3 */, input],
    queryFn: queryFn(sdk, input),
    ...options
  });
};
var useUsersAdminApi_CreateBan_ByUserIdMutation_v3 = (sdk, options, callback) => {
  const mutationFn = async (input) => {
    const response = await UsersAdminApi(sdk, { coreConfig: input.coreConfig, axiosConfig: input.axiosConfig }).createBan_ByUserId_v3(
      input.userId,
      input.data
    );
    callback && callback(response.data);
    return response.data;
  };
  return (0, import_react_query15.useMutation)({
    mutationKey: ["Iam.UsersAdmin.Ban_ByUserId_v3" /* Ban_ByUserId_v3 */],
    mutationFn,
    ...options
  });
};
var useUsersAdminApi_GetUsersLinkhistories_v3 = (sdk, input, options, callback) => {
  const queryFn = (sdk2, input2) => async () => {
    const response = await UsersAdminApi(sdk2, { coreConfig: input2.coreConfig, axiosConfig: input2.axiosConfig }).getUsersLinkhistories_v3(
      input2.queryParams
    );
    callback && callback(response);
    return response.data;
  };
  return (0, import_react_query15.useQuery)({
    queryKey: ["Iam.UsersAdmin.UsersLinkhistories_v3" /* UsersLinkhistories_v3 */, input],
    queryFn: queryFn(sdk, input),
    ...options
  });
};
var useUsersAdminApi_UpdateRole_ByUserIdMutation_v2 = (sdk, options, callback) => {
  const mutationFn = async (input) => {
    const response = await UsersAdminApi(sdk, { coreConfig: input.coreConfig, axiosConfig: input.axiosConfig }).updateRole_ByUserId_v2(
      input.userId,
      input.data
    );
    callback && callback(response.data);
    return response.data;
  };
  return (0, import_react_query15.useMutation)({
    mutationKey: ["Iam.UsersAdmin.Role_ByUserId_v2" /* Role_ByUserId_v2 */],
    mutationFn,
    ...options
  });
};
var useUsersAdminApi_UpdateRole_ByUserId_ByNSMutation_v2 = (sdk, options, callback) => {
  const mutationFn = async (input) => {
    const response = await UsersAdminApi(sdk, { coreConfig: input.coreConfig, axiosConfig: input.axiosConfig }).updateRole_ByUserId_ByNS_v2(
      input.userId,
      input.data
    );
    callback && callback(response.data);
    return response.data;
  };
  return (0, import_react_query15.useMutation)({
    mutationKey: ["Iam.UsersAdmin.Role_ByUserId_ByNS_v2" /* Role_ByUserId_ByNS_v2 */],
    mutationFn,
    ...options
  });
};
var useUsersAdminApi_GetUsers_ByRoleId_v3 = (sdk, input, options, callback) => {
  const queryFn = (sdk2, input2) => async () => {
    const response = await UsersAdminApi(sdk2, { coreConfig: input2.coreConfig, axiosConfig: input2.axiosConfig }).getUsers_ByRoleId_v3(
      input2.roleId,
      input2.queryParams
    );
    callback && callback(response);
    return response.data;
  };
  return (0, import_react_query15.useQuery)({
    queryKey: ["Iam.UsersAdmin.Users_ByRoleId_v3" /* Users_ByRoleId_v3 */, input],
    queryFn: queryFn(sdk, input),
    ...options
  });
};
var useUsersAdminApi_GetCodes_ByUserId_v3 = (sdk, input, options, callback) => {
  const queryFn = (sdk2, input2) => async () => {
    const response = await UsersAdminApi(sdk2, { coreConfig: input2.coreConfig, axiosConfig: input2.axiosConfig }).getCodes_ByUserId_v3(
      input2.userId
    );
    callback && callback(response);
    return response.data;
  };
  return (0, import_react_query15.useQuery)({
    queryKey: ["Iam.UsersAdmin.Codes_ByUserId_v3" /* Codes_ByUserId_v3 */, input],
    queryFn: queryFn(sdk, input),
    ...options
  });
};
var useUsersAdminApi_DeleteRole_ByUserIdMutation_v3 = (sdk, options, callback) => {
  const mutationFn = async (input) => {
    const response = await UsersAdminApi(sdk, { coreConfig: input.coreConfig, axiosConfig: input.axiosConfig }).deleteRole_ByUserId_v3(
      input.userId,
      input.data
    );
    callback && callback(response.data);
    return response.data;
  };
  return (0, import_react_query15.useMutation)({
    mutationKey: ["Iam.UsersAdmin.Role_ByUserId_v3" /* Role_ByUserId_v3 */],
    mutationFn,
    ...options
  });
};
var useUsersAdminApi_PatchRole_ByUserIdMutation_v3 = (sdk, options, callback) => {
  const mutationFn = async (input) => {
    const response = await UsersAdminApi(sdk, { coreConfig: input.coreConfig, axiosConfig: input.axiosConfig }).patchRole_ByUserId_v3(
      input.userId,
      input.data
    );
    callback && callback(response.data);
    return response.data;
  };
  return (0, import_react_query15.useMutation)({
    mutationKey: ["Iam.UsersAdmin.Role_ByUserId_v3" /* Role_ByUserId_v3 */],
    mutationFn,
    ...options
  });
};
var useUsersAdminApi_FetchUserBulkPlatform_v3 = (sdk, input, options, callback) => {
  const queryFn = (sdk2, input2) => async () => {
    const response = await UsersAdminApi(sdk2, { coreConfig: input2.coreConfig, axiosConfig: input2.axiosConfig }).fetchUserBulkPlatform_v3(
      input2.data
    );
    callback && callback(response);
    return response.data;
  };
  return (0, import_react_query15.useQuery)({
    queryKey: ["Iam.UsersAdmin.UserBulkPlatform_v3" /* UserBulkPlatform_v3 */, input],
    queryFn: queryFn(sdk, input),
    ...options
  });
};
var useUsersAdminApi_UpdateEnable_ByUserIdMutation_v2 = (sdk, options, callback) => {
  const mutationFn = async (input) => {
    const response = await UsersAdminApi(sdk, { coreConfig: input.coreConfig, axiosConfig: input.axiosConfig }).updateEnable_ByUserId_v2(
      input.userId
    );
    callback && callback(response.data);
    return response.data;
  };
  return (0, import_react_query15.useMutation)({
    mutationKey: ["Iam.UsersAdmin.Enable_ByUserId_v2" /* Enable_ByUserId_v2 */],
    mutationFn,
    ...options
  });
};
var useUsersAdminApi_PatchStatus_ByUserIdMutation_v3 = (sdk, options, callback) => {
  const mutationFn = async (input) => {
    const response = await UsersAdminApi(sdk, { coreConfig: input.coreConfig, axiosConfig: input.axiosConfig }).patchStatus_ByUserId_v3(
      input.userId,
      input.data
    );
    callback && callback(response.data);
    return response.data;
  };
  return (0, import_react_query15.useMutation)({
    mutationKey: ["Iam.UsersAdmin.Status_ByUserId_v3" /* Status_ByUserId_v3 */],
    mutationFn,
    ...options
  });
};
var useUsersAdminApi_UpdateVerify_ByUserIdMutation_v3 = (sdk, options, callback) => {
  const mutationFn = async (input) => {
    const response = await UsersAdminApi(sdk, { coreConfig: input.coreConfig, axiosConfig: input.axiosConfig }).updateVerify_ByUserId_v3(
      input.userId
    );
    callback && callback(response.data);
    return response.data;
  };
  return (0, import_react_query15.useMutation)({
    mutationKey: ["Iam.UsersAdmin.Verify_ByUserId_v3" /* Verify_ByUserId_v3 */],
    mutationFn,
    ...options
  });
};
var useUsersAdminApi_UpdateDisable_ByUserIdMutation_v2 = (sdk, options, callback) => {
  const mutationFn = async (input) => {
    const response = await UsersAdminApi(sdk, { coreConfig: input.coreConfig, axiosConfig: input.axiosConfig }).updateDisable_ByUserId_v2(
      input.userId,
      input.data
    );
    callback && callback(response.data);
    return response.data;
  };
  return (0, import_react_query15.useMutation)({
    mutationKey: ["Iam.UsersAdmin.Disable_ByUserId_v2" /* Disable_ByUserId_v2 */],
    mutationFn,
    ...options
  });
};
var useUsersAdminApi_PatchCountry_ByCountryCodeMutation_v2 = (sdk, options, callback) => {
  const mutationFn = async (input) => {
    const response = await UsersAdminApi(sdk, {
      coreConfig: input.coreConfig,
      axiosConfig: input.axiosConfig
    }).patchCountry_ByCountryCode_v2(input.countryCode, input.data);
    callback && callback(response.data);
    return response.data;
  };
  return (0, import_react_query15.useMutation)({
    mutationKey: ["Iam.UsersAdmin.Country_ByCountryCode_v2" /* Country_ByCountryCode_v2 */],
    mutationFn,
    ...options
  });
};
var useUsersAdminApi_UpdatePassword_ByUserIdMutation_v2 = (sdk, options, callback) => {
  const mutationFn = async (input) => {
    const response = await UsersAdminApi(sdk, { coreConfig: input.coreConfig, axiosConfig: input.axiosConfig }).updatePassword_ByUserId_v2(
      input.userId,
      input.data
    );
    callback && callback(response.data);
    return response.data;
  };
  return (0, import_react_query15.useMutation)({
    mutationKey: ["Iam.UsersAdmin.Password_ByUserId_v2" /* Password_ByUserId_v2 */],
    mutationFn,
    ...options
  });
};
var useUsersAdminApi_UpdatePassword_ByUserIdMutation_v3 = (sdk, options, callback) => {
  const mutationFn = async (input) => {
    const response = await UsersAdminApi(sdk, { coreConfig: input.coreConfig, axiosConfig: input.axiosConfig }).updatePassword_ByUserId_v3(
      input.userId,
      input.data
    );
    callback && callback(response.data);
    return response.data;
  };
  return (0, import_react_query15.useMutation)({
    mutationKey: ["Iam.UsersAdmin.Password_ByUserId_v3" /* Password_ByUserId_v3 */],
    mutationFn,
    ...options
  });
};
var useUsersAdminApi_GetUsersPlatformsJustice_v3 = (sdk, input, options, callback) => {
  const queryFn = (sdk2, input2) => async () => {
    const response = await UsersAdminApi(sdk2, { coreConfig: input2.coreConfig, axiosConfig: input2.axiosConfig }).getUsersPlatformsJustice_v3(
      input2.queryParams
    );
    callback && callback(response);
    return response.data;
  };
  return (0, import_react_query15.useQuery)({
    queryKey: ["Iam.UsersAdmin.UsersPlatformsJustice_v3" /* UsersPlatformsJustice_v3 */, input],
    queryFn: queryFn(sdk, input),
    ...options
  });
};
var useUsersAdminApi_GetPlatforms_ByUserId_v3 = (sdk, input, options, callback) => {
  const queryFn = (sdk2, input2) => async () => {
    const response = await UsersAdminApi(sdk2, { coreConfig: input2.coreConfig, axiosConfig: input2.axiosConfig }).getPlatforms_ByUserId_v3(
      input2.userId,
      input2.queryParams
    );
    callback && callback(response);
    return response.data;
  };
  return (0, import_react_query15.useQuery)({
    queryKey: ["Iam.UsersAdmin.Platforms_ByUserId_v3" /* Platforms_ByUserId_v3 */, input],
    queryFn: queryFn(sdk, input),
    ...options
  });
};
var useUsersAdminApi_GetCountriesAgerestrictions_v2 = (sdk, input, options, callback) => {
  const queryFn = (sdk2, input2) => async () => {
    const response = await UsersAdminApi(sdk2, {
      coreConfig: input2.coreConfig,
      axiosConfig: input2.axiosConfig
    }).getCountriesAgerestrictions_v2();
    callback && callback(response);
    return response.data;
  };
  return (0, import_react_query15.useQuery)({
    queryKey: ["Iam.UsersAdmin.CountriesAgerestrictions_v2" /* CountriesAgerestrictions_v2 */, input],
    queryFn: queryFn(sdk, input),
    ...options
  });
};
var useUsersAdminApi_GetAgerestrictionsCountries_v3 = (sdk, input, options, callback) => {
  const queryFn = (sdk2, input2) => async () => {
    const response = await UsersAdminApi(sdk2, {
      coreConfig: input2.coreConfig,
      axiosConfig: input2.axiosConfig
    }).getAgerestrictionsCountries_v3();
    callback && callback(response);
    return response.data;
  };
  return (0, import_react_query15.useQuery)({
    queryKey: ["Iam.UsersAdmin.AgerestrictionsCountries_v3" /* AgerestrictionsCountries_v3 */, input],
    queryFn: queryFn(sdk, input),
    ...options
  });
};
var useUsersAdminApi_UpdateCodeVerify_ByUserIdMutation_v3 = (sdk, options, callback) => {
  const mutationFn = async (input) => {
    const response = await UsersAdminApi(sdk, {
      coreConfig: input.coreConfig,
      axiosConfig: input.axiosConfig
    }).updateCodeVerify_ByUserId_v3(input.userId, input.data);
    callback && callback(response.data);
    return response.data;
  };
  return (0, import_react_query15.useMutation)({
    mutationKey: ["Iam.UsersAdmin.CodeVerify_ByUserId_v3" /* CodeVerify_ByUserId_v3 */],
    mutationFn,
    ...options
  });
};
var useUsersAdminApi_DeleteInformation_ByUserIdMutation_v3 = (sdk, options, callback) => {
  const mutationFn = async (input) => {
    const response = await UsersAdminApi(sdk, {
      coreConfig: input.coreConfig,
      axiosConfig: input.axiosConfig
    }).deleteInformation_ByUserId_v3(input.userId);
    callback && callback(response.data);
    return response.data;
  };
  return (0, import_react_query15.useMutation)({
    mutationKey: ["Iam.UsersAdmin.Information_ByUserId_v3" /* Information_ByUserId_v3 */],
    mutationFn,
    ...options
  });
};
var useUsersAdminApi_DeletePermission_ByUserIdMutation_v3 = (sdk, options, callback) => {
  const mutationFn = async (input) => {
    const response = await UsersAdminApi(sdk, {
      coreConfig: input.coreConfig,
      axiosConfig: input.axiosConfig
    }).deletePermission_ByUserId_v3(input.userId, input.data);
    callback && callback(response.data);
    return response.data;
  };
  return (0, import_react_query15.useMutation)({
    mutationKey: ["Iam.UsersAdmin.Permission_ByUserId_v3" /* Permission_ByUserId_v3 */],
    mutationFn,
    ...options
  });
};
var useUsersAdminApi_CreatePermission_ByUserIdMutation_v3 = (sdk, options, callback) => {
  const mutationFn = async (input) => {
    const response = await UsersAdminApi(sdk, {
      coreConfig: input.coreConfig,
      axiosConfig: input.axiosConfig
    }).createPermission_ByUserId_v3(input.userId, input.data);
    callback && callback(response.data);
    return response.data;
  };
  return (0, import_react_query15.useMutation)({
    mutationKey: ["Iam.UsersAdmin.Permission_ByUserId_v3" /* Permission_ByUserId_v3 */],
    mutationFn,
    ...options
  });
};
var useUsersAdminApi_UpdatePermission_ByUserIdMutation_v3 = (sdk, options, callback) => {
  const mutationFn = async (input) => {
    const response = await UsersAdminApi(sdk, {
      coreConfig: input.coreConfig,
      axiosConfig: input.axiosConfig
    }).updatePermission_ByUserId_v3(input.userId, input.data);
    callback && callback(response.data);
    return response.data;
  };
  return (0, import_react_query15.useMutation)({
    mutationKey: ["Iam.UsersAdmin.Permission_ByUserId_v3" /* Permission_ByUserId_v3 */],
    mutationFn,
    ...options
  });
};
var useUsersAdminApi_PatchBan_ByUserId_ByBanIdMutation_v3 = (sdk, options, callback) => {
  const mutationFn = async (input) => {
    const response = await UsersAdminApi(sdk, {
      coreConfig: input.coreConfig,
      axiosConfig: input.axiosConfig
    }).patchBan_ByUserId_ByBanId_v3(input.userId, input.banId, input.data);
    callback && callback(response.data);
    return response.data;
  };
  return (0, import_react_query15.useMutation)({
    mutationKey: ["Iam.UsersAdmin.Ban_ByUserId_ByBanId_v3" /* Ban_ByUserId_ByBanId_v3 */],
    mutationFn,
    ...options
  });
};
var useUsersAdminApi_GetBansSummary_ByUserId_v3 = (sdk, input, options, callback) => {
  const queryFn = (sdk2, input2) => async () => {
    const response = await UsersAdminApi(sdk2, { coreConfig: input2.coreConfig, axiosConfig: input2.axiosConfig }).getBansSummary_ByUserId_v3(
      input2.userId
    );
    callback && callback(response);
    return response.data;
  };
  return (0, import_react_query15.useQuery)({
    queryKey: ["Iam.UsersAdmin.BansSummary_ByUserId_v3" /* BansSummary_ByUserId_v3 */, input],
    queryFn: queryFn(sdk, input),
    ...options
  });
};
var useUsersAdminApi_UpdateCodeRequest_ByUserIdMutation_v3 = (sdk, options, callback) => {
  const mutationFn = async (input) => {
    const response = await UsersAdminApi(sdk, {
      coreConfig: input.coreConfig,
      axiosConfig: input.axiosConfig
    }).updateCodeRequest_ByUserId_v3(input.userId, input.data);
    callback && callback(response.data);
    return response.data;
  };
  return (0, import_react_query15.useMutation)({
    mutationKey: ["Iam.UsersAdmin.CodeRequest_ByUserId_v3" /* CodeRequest_ByUserId_v3 */],
    mutationFn,
    ...options
  });
};
var useUsersAdminApi_FetchUser_ByPlatformId_v3 = (sdk, input, options, callback) => {
  const queryFn = (sdk2, input2) => async () => {
    const response = await UsersAdminApi(sdk2, { coreConfig: input2.coreConfig, axiosConfig: input2.axiosConfig }).fetchUser_ByPlatformId_v3(
      input2.platformId,
      input2.data,
      input2.queryParams
    );
    callback && callback(response);
    return response.data;
  };
  return (0, import_react_query15.useQuery)({
    queryKey: ["Iam.UsersAdmin.User_ByPlatformId_v3" /* User_ByPlatformId_v3 */, input],
    queryFn: queryFn(sdk, input),
    ...options
  });
};
var useUsersAdminApi_UpdatePlatformLink_ByUserIdMutation_v3 = (sdk, options, callback) => {
  const mutationFn = async (input) => {
    const response = await UsersAdminApi(sdk, {
      coreConfig: input.coreConfig,
      axiosConfig: input.axiosConfig
    }).updatePlatformLink_ByUserId_v3(input.userId, input.data, input.queryParams);
    callback && callback(response.data);
    return response.data;
  };
  return (0, import_react_query15.useMutation)({
    mutationKey: ["Iam.UsersAdmin.PlatformLink_ByUserId_v3" /* PlatformLink_ByUserId_v3 */],
    mutationFn,
    ...options
  });
};
var useUsersAdminApi_DeleteRole_ByUserId_ByRoleIdMutation_v3 = (sdk, options, callback) => {
  const mutationFn = async (input) => {
    const response = await UsersAdminApi(sdk, {
      coreConfig: input.coreConfig,
      axiosConfig: input.axiosConfig
    }).deleteRole_ByUserId_ByRoleId_v3(input.userId, input.roleId);
    callback && callback(response.data);
    return response.data;
  };
  return (0, import_react_query15.useMutation)({
    mutationKey: ["Iam.UsersAdmin.Role_ByUserId_ByRoleId_v3" /* Role_ByUserId_ByRoleId_v3 */],
    mutationFn,
    ...options
  });
};
var useUsersAdminApi_UpdateRole_ByUserId_ByRoleIdMutation_v3 = (sdk, options, callback) => {
  const mutationFn = async (input) => {
    const response = await UsersAdminApi(sdk, {
      coreConfig: input.coreConfig,
      axiosConfig: input.axiosConfig
    }).updateRole_ByUserId_ByRoleId_v3(input.userId, input.roleId);
    callback && callback(response.data);
    return response.data;
  };
  return (0, import_react_query15.useMutation)({
    mutationKey: ["Iam.UsersAdmin.Role_ByUserId_ByRoleId_v3" /* Role_ByUserId_ByRoleId_v3 */],
    mutationFn,
    ...options
  });
};
var useUsersAdminApi_GetDeletionStatus_ByUserId_v3 = (sdk, input, options, callback) => {
  const queryFn = (sdk2, input2) => async () => {
    const response = await UsersAdminApi(sdk2, {
      coreConfig: input2.coreConfig,
      axiosConfig: input2.axiosConfig
    }).getDeletionStatus_ByUserId_v3(input2.userId);
    callback && callback(response);
    return response.data;
  };
  return (0, import_react_query15.useQuery)({
    queryKey: ["Iam.UsersAdmin.DeletionStatus_ByUserId_v3" /* DeletionStatus_ByUserId_v3 */, input],
    queryFn: queryFn(sdk, input),
    ...options
  });
};
var useUsersAdminApi_PatchDeletionStatus_ByUserIdMutation_v3 = (sdk, options, callback) => {
  const mutationFn = async (input) => {
    const response = await UsersAdminApi(sdk, {
      coreConfig: input.coreConfig,
      axiosConfig: input.axiosConfig
    }).patchDeletionStatus_ByUserId_v3(input.userId, input.data);
    callback && callback(response.data);
    return response.data;
  };
  return (0, import_react_query15.useMutation)({
    mutationKey: ["Iam.UsersAdmin.DeletionStatus_ByUserId_v3" /* DeletionStatus_ByUserId_v3 */],
    mutationFn,
    ...options
  });
};
var useUsersAdminApi_GetLoginsHistories_ByUserId_v3 = (sdk, input, options, callback) => {
  const queryFn = (sdk2, input2) => async () => {
    const response = await UsersAdminApi(sdk2, {
      coreConfig: input2.coreConfig,
      axiosConfig: input2.axiosConfig
    }).getLoginsHistories_ByUserId_v3(input2.userId, input2.queryParams);
    callback && callback(response);
    return response.data;
  };
  return (0, import_react_query15.useQuery)({
    queryKey: ["Iam.UsersAdmin.LoginsHistories_ByUserId_v3" /* LoginsHistories_ByUserId_v3 */, input],
    queryFn: queryFn(sdk, input),
    ...options
  });
};
var useUsersAdminApi_PatchTrustlyIdentity_ByUserIdMutation_v3 = (sdk, options, callback) => {
  const mutationFn = async (input) => {
    const response = await UsersAdminApi(sdk, {
      coreConfig: input.coreConfig,
      axiosConfig: input.axiosConfig
    }).patchTrustlyIdentity_ByUserId_v3(input.userId, input.data);
    callback && callback(response.data);
    return response.data;
  };
  return (0, import_react_query15.useMutation)({
    mutationKey: ["Iam.UsersAdmin.TrustlyIdentity_ByUserId_v3" /* TrustlyIdentity_ByUserId_v3 */],
    mutationFn,
    ...options
  });
};
var useUsersAdminApi_GetDistinctPlatforms_ByUserId_v3 = (sdk, input, options, callback) => {
  const queryFn = (sdk2, input2) => async () => {
    const response = await UsersAdminApi(sdk2, {
      coreConfig: input2.coreConfig,
      axiosConfig: input2.axiosConfig
    }).getDistinctPlatforms_ByUserId_v3(input2.userId);
    callback && callback(response);
    return response.data;
  };
  return (0, import_react_query15.useQuery)({
    queryKey: ["Iam.UsersAdmin.DistinctPlatforms_ByUserId_v3" /* DistinctPlatforms_ByUserId_v3 */, input],
    queryFn: queryFn(sdk, input),
    ...options
  });
};
var useUsersAdminApi_GetPlatformsJustice_ByUserId_v3 = (sdk, input, options, callback) => {
  const queryFn = (sdk2, input2) => async () => {
    const response = await UsersAdminApi(sdk2, {
      coreConfig: input2.coreConfig,
      axiosConfig: input2.axiosConfig
    }).getPlatformsJustice_ByUserId_v3(input2.userId);
    callback && callback(response);
    return response.data;
  };
  return (0, import_react_query15.useQuery)({
    queryKey: ["Iam.UsersAdmin.PlatformsJustice_ByUserId_v3" /* PlatformsJustice_ByUserId_v3 */, input],
    queryFn: queryFn(sdk, input),
    ...options
  });
};
var useUsersAdminApi_GetPlatformsDistinct_ByUserId_v3 = (sdk, input, options, callback) => {
  const queryFn = (sdk2, input2) => async () => {
    const response = await UsersAdminApi(sdk2, {
      coreConfig: input2.coreConfig,
      axiosConfig: input2.axiosConfig
    }).getPlatformsDistinct_ByUserId_v3(input2.userId, input2.queryParams);
    callback && callback(response);
    return response.data;
  };
  return (0, import_react_query15.useQuery)({
    queryKey: ["Iam.UsersAdmin.PlatformsDistinct_ByUserId_v3" /* PlatformsDistinct_ByUserId_v3 */, input],
    queryFn: queryFn(sdk, input),
    ...options
  });
};
var useUsersAdminApi_UpdateHeadlesCodeVerify_ByUserIdMutation_v3 = (sdk, options, callback) => {
  const mutationFn = async (input) => {
    const response = await UsersAdminApi(sdk, {
      coreConfig: input.coreConfig,
      axiosConfig: input.axiosConfig
    }).updateHeadlesCodeVerify_ByUserId_v3(input.userId, input.data);
    callback && callback(response.data);
    return response.data;
  };
  return (0, import_react_query15.useMutation)({
    mutationKey: ["Iam.UsersAdmin.HeadlesCodeVerify_ByUserId_v3" /* HeadlesCodeVerify_ByUserId_v3 */],
    mutationFn,
    ...options
  });
};
var useUsersAdminApi_DeletePlatform_ByUserId_ByPlatformIdMutation_v3 = (sdk, options, callback) => {
  const mutationFn = async (input) => {
    const response = await UsersAdminApi(sdk, {
      coreConfig: input.coreConfig,
      axiosConfig: input.axiosConfig
    }).deletePlatform_ByUserId_ByPlatformId_v3(input.userId, input.platformId, input.data);
    callback && callback(response.data);
    return response.data;
  };
  return (0, import_react_query15.useMutation)({
    mutationKey: ["Iam.UsersAdmin.Platform_ByUserId_ByPlatformId_v3" /* Platform_ByUserId_ByPlatformId_v3 */],
    mutationFn,
    ...options
  });
};
var useUsersAdminApi_PatchAgerestrictionCountry_ByCountryCodeMutation_v3 = (sdk, options, callback) => {
  const mutationFn = async (input) => {
    const response = await UsersAdminApi(sdk, {
      coreConfig: input.coreConfig,
      axiosConfig: input.axiosConfig
    }).patchAgerestrictionCountry_ByCountryCode_v3(input.countryCode, input.data);
    callback && callback(response.data);
    return response.data;
  };
  return (0, import_react_query15.useMutation)({
    mutationKey: ["Iam.UsersAdmin.AgerestrictionCountry_ByCountryCode_v3" /* AgerestrictionCountry_ByCountryCode_v3 */],
    mutationFn,
    ...options
  });
};
var useUsersAdminApi_GetPlatformsLinkHistories_ByUserId_v3 = (sdk, input, options, callback) => {
  const queryFn = (sdk2, input2) => async () => {
    const response = await UsersAdminApi(sdk2, {
      coreConfig: input2.coreConfig,
      axiosConfig: input2.axiosConfig
    }).getPlatformsLinkHistories_ByUserId_v3(input2.userId, input2.queryParams);
    callback && callback(response);
    return response.data;
  };
  return (0, import_react_query15.useQuery)({
    queryKey: ["Iam.UsersAdmin.PlatformsLinkHistories_ByUserId_v3" /* PlatformsLinkHistories_ByUserId_v3 */, input],
    queryFn: queryFn(sdk, input),
    ...options
  });
};
var useUsersAdminApi_DeleteAll_ByUserId_ByPlatformIdMutation_v3 = (sdk, options, callback) => {
  const mutationFn = async (input) => {
    const response = await UsersAdminApi(sdk, {
      coreConfig: input.coreConfig,
      axiosConfig: input.axiosConfig
    }).deleteAll_ByUserId_ByPlatformId_v3(input.userId, input.platformId);
    callback && callback(response.data);
    return response.data;
  };
  return (0, import_react_query15.useMutation)({
    mutationKey: ["Iam.UsersAdmin.All_ByUserId_ByPlatformId_v3" /* All_ByUserId_ByPlatformId_v3 */],
    mutationFn,
    ...options
  });
};
var useUsersAdminApi_DeleteLink_ByUserId_ByPlatformIdMutation_v2 = (sdk, options, callback) => {
  const mutationFn = async (input) => {
    const response = await UsersAdminApi(sdk, {
      coreConfig: input.coreConfig,
      axiosConfig: input.axiosConfig
    }).deleteLink_ByUserId_ByPlatformId_v2(input.userId, input.platformId, input.data);
    callback && callback(response.data);
    return response.data;
  };
  return (0, import_react_query15.useMutation)({
    mutationKey: ["Iam.UsersAdmin.Link_ByUserId_ByPlatformId_v2" /* Link_ByUserId_ByPlatformId_v2 */],
    mutationFn,
    ...options
  });
};
var useUsersAdminApi_PostLink_ByUserId_ByPlatformIdMutation_v3 = (sdk, options, callback) => {
  const mutationFn = async (input) => {
    const response = await UsersAdminApi(sdk, {
      coreConfig: input.coreConfig,
      axiosConfig: input.axiosConfig
    }).postLink_ByUserId_ByPlatformId_v3(input.userId, input.platformId, input.data);
    callback && callback(response.data);
    return response.data;
  };
  return (0, import_react_query15.useMutation)({
    mutationKey: ["Iam.UsersAdmin.Link_ByUserId_ByPlatformId_v3" /* Link_ByUserId_ByPlatformId_v3 */],
    mutationFn,
    ...options
  });
};
var useUsersAdminApi_GetUser_ByPlatformId_ByPlatformUserId_v3 = (sdk, input, options, callback) => {
  const queryFn = (sdk2, input2) => async () => {
    const response = await UsersAdminApi(sdk2, {
      coreConfig: input2.coreConfig,
      axiosConfig: input2.axiosConfig
    }).getUser_ByPlatformId_ByPlatformUserId_v3(input2.platformId, input2.platformUserId);
    callback && callback(response);
    return response.data;
  };
  return (0, import_react_query15.useQuery)({
    queryKey: ["Iam.UsersAdmin.User_ByPlatformId_ByPlatformUserId_v3" /* User_ByPlatformId_ByPlatformUserId_v3 */, input],
    queryFn: queryFn(sdk, input),
    ...options
  });
};
var useUsersAdminApi_DeletePermission_ByUserId_ByResource_ByActionMutation_v3 = (sdk, options, callback) => {
  const mutationFn = async (input) => {
    const response = await UsersAdminApi(sdk, {
      coreConfig: input.coreConfig,
      axiosConfig: input.axiosConfig
    }).deletePermission_ByUserId_ByResource_ByAction_v3(input.userId, input.resource, input.action);
    callback && callback(response.data);
    return response.data;
  };
  return (0, import_react_query15.useMutation)({
    mutationKey: ["Iam.UsersAdmin.Permission_ByUserId_ByResource_ByAction_v3" /* Permission_ByUserId_ByResource_ByAction_v3 */],
    mutationFn,
    ...options
  });
};
var useUsersAdminApi_GetMetadata_ByUserId_ByPlatformId_v3 = (sdk, input, options, callback) => {
  const queryFn = (sdk2, input2) => async () => {
    const response = await UsersAdminApi(sdk2, {
      coreConfig: input2.coreConfig,
      axiosConfig: input2.axiosConfig
    }).getMetadata_ByUserId_ByPlatformId_v3(input2.userId, input2.platformId, input2.queryParams);
    callback && callback(response);
    return response.data;
  };
  return (0, import_react_query15.useQuery)({
    queryKey: ["Iam.UsersAdmin.Metadata_ByUserId_ByPlatformId_v3" /* Metadata_ByUserId_ByPlatformId_v3 */, input],
    queryFn: queryFn(sdk, input),
    ...options
  });
};
var useUsersAdminApi_PostLinkStatu_ByUserId_ByPlatformIdMutation_v3 = (sdk, options, callback) => {
  const mutationFn = async (input) => {
    const response = await UsersAdminApi(sdk, {
      coreConfig: input.coreConfig,
      axiosConfig: input.axiosConfig
    }).postLinkStatu_ByUserId_ByPlatformId_v3(input.userId, input.platformId, input.data);
    callback && callback(response.data);
    return response.data;
  };
  return (0, import_react_query15.useMutation)({
    mutationKey: ["Iam.UsersAdmin.LinkStatu_ByUserId_ByPlatformId_v3" /* LinkStatu_ByUserId_ByPlatformId_v3 */],
    mutationFn,
    ...options
  });
};
var useUsersAdminApi_GetPlatformJustice_ByUserId_ByTargetNamespace_v3 = (sdk, input, options, callback) => {
  const queryFn = (sdk2, input2) => async () => {
    const response = await UsersAdminApi(sdk2, {
      coreConfig: input2.coreConfig,
      axiosConfig: input2.axiosConfig
    }).getPlatformJustice_ByUserId_ByTargetNamespace_v3(input2.userId, input2.targetNamespace);
    callback && callback(response);
    return response.data;
  };
  return (0, import_react_query15.useQuery)({
    queryKey: ["Iam.UsersAdmin.PlatformJustice_ByUserId_ByTargetNamespace_v3" /* PlatformJustice_ByUserId_ByTargetNamespace_v3 */, input],
    queryFn: queryFn(sdk, input),
    ...options
  });
};
var useUsersAdminApi_CreatePlatformJustice_ByUserId_ByTargetNamespaceMutation_v3 = (sdk, options, callback) => {
  const mutationFn = async (input) => {
    const response = await UsersAdminApi(sdk, {
      coreConfig: input.coreConfig,
      axiosConfig: input.axiosConfig
    }).createPlatformJustice_ByUserId_ByTargetNamespace_v3(input.userId, input.targetNamespace);
    callback && callback(response.data);
    return response.data;
  };
  return (0, import_react_query15.useMutation)({
    mutationKey: ["Iam.UsersAdmin.PlatformJustice_ByUserId_ByTargetNamespace_v3" /* PlatformJustice_ByUserId_ByTargetNamespace_v3 */],
    mutationFn,
    ...options
  });
};
var useUsersAdminApi_DeleteLinkHistory_ByUserId_ByPlatformIdMutation_v3 = (sdk, options, callback) => {
  const mutationFn = async (input) => {
    const response = await UsersAdminApi(sdk, {
      coreConfig: input.coreConfig,
      axiosConfig: input.axiosConfig
    }).deleteLinkHistory_ByUserId_ByPlatformId_v3(input.userId, input.platformId);
    callback && callback(response.data);
    return response.data;
  };
  return (0, import_react_query15.useMutation)({
    mutationKey: ["Iam.UsersAdmin.LinkHistory_ByUserId_ByPlatformId_v3" /* LinkHistory_ByUserId_ByPlatformId_v3 */],
    mutationFn,
    ...options
  });
};
var useUsersAdminApi_DeleteLinkRestriction_ByUserId_ByPlatformIdMutation_v3 = (sdk, options, callback) => {
  const mutationFn = async (input) => {
    const response = await UsersAdminApi(sdk, {
      coreConfig: input.coreConfig,
      axiosConfig: input.axiosConfig
    }).deleteLinkRestriction_ByUserId_ByPlatformId_v3(input.userId, input.platformId);
    callback && callback(response.data);
    return response.data;
  };
  return (0, import_react_query15.useMutation)({
    mutationKey: ["Iam.UsersAdmin.LinkRestriction_ByUserId_ByPlatformId_v3" /* LinkRestriction_ByUserId_ByPlatformId_v3 */],
    mutationFn,
    ...options
  });
};

// src/generated-admin/queries/UsersV4Admin.query.ts
var import_react_query16 = require("@tanstack/react-query");

// src/generated-admin/UsersV4AdminApi.ts
var import_sdk32 = require("@accelbyte/sdk");

// src/generated-admin/endpoints/UsersV4Admin$.ts
var import_sdk31 = require("@accelbyte/sdk");
var import_zod156 = require("zod");

// src/generated-definitions/AuthenticatorKeyResponseV4.ts
var import_zod140 = require("zod");
var AuthenticatorKeyResponseV4 = import_zod140.z.object({ secretKey: import_zod140.z.string(), uri: import_zod140.z.string() });

// src/generated-definitions/BackupCodesResponseV4.ts
var import_zod141 = require("zod");
var BackupCodesResponseV4 = import_zod141.z.object({
  generatedAt: import_zod141.z.number().int(),
  invalidCodes: import_zod141.z.array(import_zod141.z.string()).nullish(),
  validCodes: import_zod141.z.array(import_zod141.z.string()).nullish()
});

// src/generated-definitions/CreateTestUsersResponseV4.ts
var import_zod143 = require("zod");

// src/generated-definitions/CreateTestUserResponseV4.ts
var import_zod142 = require("zod");
var CreateTestUserResponseV4 = import_zod142.z.object({
  authType: import_zod142.z.string(),
  country: import_zod142.z.string(),
  dateOfBirth: import_zod142.z.string(),
  displayName: import_zod142.z.string(),
  emailAddress: import_zod142.z.string(),
  namespace: import_zod142.z.string(),
  password: import_zod142.z.string(),
  uniqueDisplayName: import_zod142.z.string().nullish(),
  userId: import_zod142.z.string(),
  username: import_zod142.z.string(),
  verified: import_zod142.z.boolean()
});

// src/generated-definitions/CreateTestUsersResponseV4.ts
var CreateTestUsersResponseV4 = import_zod143.z.object({ data: import_zod143.z.array(CreateTestUserResponseV4) });

// src/generated-definitions/CreateUserResponseV4.ts
var import_zod144 = require("zod");
var CreateUserResponseV4 = import_zod144.z.object({
  authType: import_zod144.z.string(),
  country: import_zod144.z.string(),
  dateOfBirth: import_zod144.z.string(),
  displayName: import_zod144.z.string(),
  emailAddress: import_zod144.z.string(),
  namespace: import_zod144.z.string(),
  uniqueDisplayName: import_zod144.z.string().nullish(),
  userId: import_zod144.z.string(),
  username: import_zod144.z.string()
});

// src/generated-definitions/EnabledFactorsResponseV4.ts
var import_zod145 = require("zod");
var EnabledFactorsResponseV4 = import_zod145.z.object({
  default: import_zod145.z.string(),
  enabled: import_zod145.z.array(import_zod145.z.string()),
  remainingBackupCodeCount: import_zod145.z.number().int().nullish()
});

// src/generated-definitions/InvitationHistoryResponse.ts
var import_zod146 = require("zod");
var InvitationHistoryResponse = import_zod146.z.object({
  accepted: import_zod146.z.boolean(),
  createdAt: import_zod146.z.string(),
  inviter: import_zod146.z.string(),
  namespace: import_zod146.z.string(),
  updatedAt: import_zod146.z.string()
});

// src/generated-definitions/ListInvitationHistoriesV4Response.ts
var import_zod147 = require("zod");
var ListInvitationHistoriesV4Response = import_zod147.z.object({ data: import_zod147.z.array(InvitationHistoryResponse), paging: PaginationV3 });

// src/generated-definitions/ListUserRolesV4Response.ts
var import_zod149 = require("zod");

// src/generated-definitions/UserRolesV4Response.ts
var import_zod148 = require("zod");
var UserRolesV4Response = import_zod148.z.object({ assignedNamespaces: import_zod148.z.array(import_zod148.z.string()), roleId: import_zod148.z.string(), roleName: import_zod148.z.string() });

// src/generated-definitions/ListUserRolesV4Response.ts
var ListUserRolesV4Response = import_zod149.z.object({ data: import_zod149.z.array(UserRolesV4Response), paging: PaginationV3 });

// src/generated-definitions/ListValidUserIdResponseV4.ts
var import_zod151 = require("zod");

// src/generated-definitions/ValidUserIdResponseV4.ts
var import_zod150 = require("zod");
var ValidUserIdResponseV4 = import_zod150.z.object({ exists: import_zod150.z.boolean(), userId: import_zod150.z.string() });

// src/generated-definitions/ListValidUserIdResponseV4.ts
var ListValidUserIdResponseV4 = import_zod151.z.object({ data: import_zod151.z.array(ValidUserIdResponseV4) });

// src/generated-definitions/NamespaceInvitationHistoryUserV4Response.ts
var import_zod153 = require("zod");

// src/generated-definitions/UserInvitationHistory.ts
var import_zod152 = require("zod");
var UserInvitationHistory = import_zod152.z.object({ accepted: import_zod152.z.boolean(), invitee: import_zod152.z.string(), updatedAt: import_zod152.z.string() });

// src/generated-definitions/NamespaceInvitationHistoryUserV4Response.ts
var NamespaceInvitationHistoryUserV4Response = import_zod153.z.object({ data: import_zod153.z.array(UserInvitationHistory), paging: PaginationV3 });

// src/generated-definitions/UserMfaStatusResponseV4.ts
var import_zod154 = require("zod");
var UserMfaStatusResponseV4 = import_zod154.z.object({
  defaultFactor: import_zod154.z.string().nullish(),
  enabled: import_zod154.z.boolean(),
  enabledFactors: import_zod154.z.array(import_zod154.z.string()).nullish()
});

// src/generated-definitions/UserMfaTokenResponseV4.ts
var import_zod155 = require("zod");
var UserMfaTokenResponseV4 = import_zod155.z.object({ mfaToken: import_zod155.z.string() });

// src/generated-admin/endpoints/UsersV4Admin$.ts
var UsersV4Admin$ = class {
  // @ts-ignore
  // prettier-ignore
  constructor(axiosInstance, namespace, useSchemaValidation = true) {
    this.axiosInstance = axiosInstance;
    this.namespace = namespace;
    this.useSchemaValidation = useSchemaValidation;
  }
  /**
   * This Endpoint support update user based on given data. **Single request can update single field or multi fields.** Supported field {country, displayName, languageTag, dateOfBirth, avatarUrl, userName} Country use ISO3166-1 alpha-2 two letter, e.g. US. Date of Birth format : YYYY-MM-DD, e.g. 2019-04-29. action code : 10103
   */
  patchUserMe_v4(data) {
    const params = {};
    const url = "/iam/v4/admin/users/me";
    const resultPromise = this.axiosInstance.patch(url, data, { params });
    return import_sdk31.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, UserResponseV3, "UserResponseV3");
  }
  /**
   * Use this endpoint to invite admin or non-admin user and assign role to them. The role must be scoped to namespace. An admin user can only assign role with **assignedNamespaces** if the admin user has required permission which is same as the required permission of endpoint: [AdminAddUserRoleV4]. Detail request body : - **emailAddresses** is required, List of email addresses that will be invited - **isAdmin** is required, true if user is admin, false if user is not admin - **namespace** is optional. Only works on multi tenant mode, if not specified then it will be assigned Publisher namespace, if specified, it will become that studio/publisher where user is invited to. - **roleId** is optional, if not specified then it will only assign User role. - **assignedNamespaces** is optional, List of namespaces which the Role will be assigned to the user, only works when Role is not empty. The invited admin will also assigned with &#34;User&#34; role by default.
   */
  createUserInvite_v4(data) {
    const params = {};
    const url = "/iam/v4/admin/users/invite";
    const resultPromise = this.axiosInstance.post(url, data, { params });
    return import_sdk31.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, InviteUserResponseV3, "InviteUserResponseV3");
  }
  /**
   * @deprecated
   * Use this endpoint to invite admin or non-admin user and assign role to them. The role must be scoped to namespace. An admin user can only assign role with **assignedNamespaces** if the admin user has required permission which is same as the required permission of endpoint: [AdminAddUserRoleV4]. Detail request body : - Email Address is required, List of email addresses that will be invited - isAdmin is required, true if user is admin, false if user is not admin - Namespace is optional. Only works on multi tenant mode, if not specified then it will be assigned Publisher namespace, if specified, it will become that studio/publisher where user is invited to. - Role is optional, if not specified then it will only assign User role. - Assigned Namespaces is optional, List of namespaces which the Role will be assigned to the user, only works when Role is not empty. The invited admin will also assigned with &#34;User&#34; role by default. Substitute endpoint: /iam/v4/admin/users/invite
   */
  createUserUserInvite_v4(data) {
    const params = {};
    const url = "/iam/v4/admin/users/users/invite";
    const resultPromise = this.axiosInstance.post(url, data, { params });
    return import_sdk31.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, InviteUserResponseV3, "InviteUserResponseV3");
  }
  /**
   * This endpoint is to list all Invitation Histories for new studio namespace in multi tenant mode. It will return error if the service multi tenant mode is set to false. Accepted Query: - namespace - offset - limit
   */
  getInvitationHistories_v4(queryParams) {
    const params = { ...queryParams };
    const url = "/iam/v4/admin/invitationHistories";
    const resultPromise = this.axiosInstance.get(url, { params });
    return import_sdk31.Validate.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      ListInvitationHistoriesV4Response,
      "ListInvitationHistoriesV4Response"
    );
  }
  /**
   * This endpoint is used to get user enabled factors.
   */
  getUsersMeMfaFactor_v4() {
    const params = {};
    const url = "/iam/v4/admin/users/me/mfa/factor";
    const resultPromise = this.axiosInstance.get(url, { params });
    return import_sdk31.Validate.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      EnabledFactorsResponseV4,
      "EnabledFactorsResponseV4"
    );
  }
  /**
   * This endpoint is used to make 2FA factor default.
   */
  postUserMeMfaFactor_v4(data) {
    const params = {};
    const url = "/iam/v4/admin/users/me/mfa/factor";
    const resultPromise = this.axiosInstance.post(url, import_sdk31.CodeGenUtil.getFormUrlEncodedData(data), {
      ...params,
      headers: { ...params.headers, "content-type": "application/x-www-form-urlencoded" }
    });
    return import_sdk31.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, import_zod156.z.unknown(), "z.unknown()");
  }
  /**
   * This endpoint will get user&#39;s&#39; MFA status.
   */
  getUsersMeMfaStatus_v4() {
    const params = {};
    const url = "/iam/v4/admin/users/me/mfa/status";
    const resultPromise = this.axiosInstance.get(url, { params });
    return import_sdk31.Validate.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      UserMfaStatusResponseV4,
      "UserMfaStatusResponseV4"
    );
  }
  /**
   * @deprecated
   * This endpoint will get user&#39;s&#39; MFA status. ------------ **Substitute endpoint**: /iam/v4/admin/users/me/mfa/status [GET]
   */
  createUserMeMfaStatus_v4() {
    const params = {};
    const url = "/iam/v4/admin/users/me/mfa/status";
    const resultPromise = this.axiosInstance.post(url, null, { params });
    return import_sdk31.Validate.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      UserMfaStatusResponseV4,
      "UserMfaStatusResponseV4"
    );
  }
  /**
   * @deprecated
   * This endpoint is used to get 8-digits backup codes. Each code is a one-time code and will be deleted once used.
   */
  getUsersMeMfaBackupCode_v4() {
    const params = {};
    const url = "/iam/v4/admin/users/me/mfa/backupCode";
    const resultPromise = this.axiosInstance.get(url, { params });
    return import_sdk31.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, BackupCodesResponseV4, "BackupCodesResponseV4");
  }
  /**
   * @deprecated
   * This endpoint is used to generate 8-digits backup codes. Each code is a one-time code and will be deleted once used.
   */
  createUserMeMfaBackupCode_v4() {
    const params = {};
    const url = "/iam/v4/admin/users/me/mfa/backupCode";
    const resultPromise = this.axiosInstance.post(url, null, { params });
    return import_sdk31.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, BackupCodesResponseV4, "BackupCodesResponseV4");
  }
  /**
   * This endpoint is used to send email code. -------------- Supported actions: * ChangePassword * DisableMFAEmail
   */
  postUserMeMfaEmailCode_v4(data) {
    const params = {};
    const url = "/iam/v4/admin/users/me/mfa/email/code";
    const resultPromise = this.axiosInstance.post(url, import_sdk31.CodeGenUtil.getFormUrlEncodedData(data), {
      ...params,
      headers: { ...params.headers, "content-type": "application/x-www-form-urlencoded" }
    });
    return import_sdk31.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, import_zod156.z.unknown(), "z.unknown()");
  }
  /**
   * This endpoint is used to get 8-digits backup codes. Each code is a one-time code and will be deleted once used.
   */
  getUsersMeMfaBackupCodes_v4(queryParams) {
    const params = { ...queryParams };
    const url = "/iam/v4/admin/users/me/mfa/backupCodes";
    const resultPromise = this.axiosInstance.get(url, { params });
    return import_sdk31.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, import_zod156.z.unknown(), "z.unknown()");
  }
  /**
   * This endpoint is used to generate 8-digits backup codes. Each code is a one-time code and will be deleted once used.
   */
  createUserMeMfaBackupCode_admin_v4(queryParams) {
    const params = { ...queryParams };
    const url = "/iam/v4/admin/users/me/mfa/backupCodes";
    const resultPromise = this.axiosInstance.post(url, null, { params });
    return import_sdk31.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, import_zod156.z.unknown(), "z.unknown()");
  }
  /**
   * This endpoint is used to enable 2FA email.
   */
  postUserMeMfaEmailEnable_v4(data) {
    const params = {};
    const url = "/iam/v4/admin/users/me/mfa/email/enable";
    const resultPromise = this.axiosInstance.post(url, import_sdk31.CodeGenUtil.getFormUrlEncodedData(data), {
      ...params,
      headers: { ...params.headers, "content-type": "application/x-www-form-urlencoded" }
    });
    return import_sdk31.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, import_zod156.z.unknown(), "z.unknown()");
  }
  /**
   * This endpoint is used to disable 2FA email. ------ **Note**: **mfaToken** is required when all the following are enabled: - The environment variable **SENSITIVE_MFA_AUTH_ENABLED** is true - The **Two-Factor Authentication** is enabled in the IAM client where user logs in - Users already enabled the MFA
   */
  createUserMeMfaEmailDisable_v4(data) {
    const params = {};
    const url = "/iam/v4/admin/users/me/mfa/email/disable";
    const resultPromise = this.axiosInstance.post(url, data, { params });
    return import_sdk31.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, import_zod156.z.unknown(), "z.unknown()");
  }
  /**
   * Create a new user with unique email address and username. **Required attributes:** - authType: possible value is EMAILPASSWD - emailAddress: Please refer to the rule from /v3/public/inputValidations API. - username: Please refer to the rule from /v3/public/inputValidations API. - password: Please refer to the rule from /v3/public/inputValidations API. - country: ISO3166-1 alpha-2 two letter, e.g. US. - dateOfBirth: YYYY-MM-DD, e.g. 1990-01-01. valid values are between 1905-01-01 until current date. - uniqueDisplayName: required when uniqueDisplayNameEnabled/UNIQUE_DISPLAY_NAME_ENABLED is true, please refer to the rule from /v3/public/inputValidations API. **Not required attributes:** - displayName: Please refer to the rule from /v3/public/inputValidations API. This endpoint support accepting agreements for the created user. Supply the accepted agreements in acceptedPolicies attribute.
   */
  createUser_v4(data) {
    const params = {};
    const url = "/iam/v4/admin/namespaces/{namespace}/users".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.post(url, data, { params });
    return import_sdk31.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, CreateUserResponseV4, "CreateUserResponseV4");
  }
  /**
   * This endpoint will verify user&#39;s&#39; MFA code and generate a MFA token.
   */
  postUserMeMfaChallengeVerify_v4(data) {
    const params = {};
    const url = "/iam/v4/admin/users/me/mfa/challenge/verify";
    const resultPromise = this.axiosInstance.post(url, import_sdk31.CodeGenUtil.getFormUrlEncodedData(data), {
      ...params,
      headers: { ...params.headers, "content-type": "application/x-www-form-urlencoded" }
    });
    return import_sdk31.Validate.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      UserMfaTokenResponseV4,
      "UserMfaTokenResponseV4"
    );
  }
  /**
   * This endpoint is used to generate a secret key for 3rd-party authenticator app. A QR code URI is also returned so that frontend can generate QR code image.
   */
  createUserMeMfaAuthenticatorKey_v4() {
    const params = {};
    const url = "/iam/v4/admin/users/me/mfa/authenticator/key";
    const resultPromise = this.axiosInstance.post(url, null, { params });
    return import_sdk31.Validate.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      AuthenticatorKeyResponseV4,
      "AuthenticatorKeyResponseV4"
    );
  }
  /**
   * @deprecated
   * This endpoint is used to enable 2FA backup codes.
   */
  createUserMeMfaBackupCodeEnable_v4() {
    const params = {};
    const url = "/iam/v4/admin/users/me/mfa/backupCode/enable";
    const resultPromise = this.axiosInstance.post(url, null, { params });
    return import_sdk31.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, BackupCodesResponseV4, "BackupCodesResponseV4");
  }
  /**
   * This endpoint is used to disable 2FA backup codes. ------ **Note**: **mfaToken** is required when all the following are enabled: - The environment variable **SENSITIVE_MFA_AUTH_ENABLED** is true - The **Two-Factor Authentication** is enabled in the IAM client where user logs in - Users already enabled the MFA
   */
  deleteUserMeMfaBackupCodeDisable_v4(data) {
    const params = {};
    const url = "/iam/v4/admin/users/me/mfa/backupCode/disable";
    const resultPromise = this.axiosInstance.delete(url, { data, params });
    return import_sdk31.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, import_zod156.z.unknown(), "z.unknown()");
  }
  /**
   * This endpoint is used to enable 2FA backup codes.
   */
  createUserMeMfaBackupCodeEnable_admin_v4(queryParams) {
    const params = { ...queryParams };
    const url = "/iam/v4/admin/users/me/mfa/backupCodes/enable";
    const resultPromise = this.axiosInstance.post(url, null, { params });
    return import_sdk31.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, import_zod156.z.unknown(), "z.unknown()");
  }
  /**
   * @deprecated
   * This endpoint is used to download backup codes.
   */
  getUsersMeMfaBackupCodeDownload_v4() {
    const params = {};
    const url = "/iam/v4/admin/users/me/mfa/backupCode/download";
    const resultPromise = this.axiosInstance.get(url, { params });
    return import_sdk31.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, import_zod156.z.unknown(), "z.unknown()");
  }
  /**
   * Create test users and not send verification code email. Note: - count : Enter the number of test users you want to create in the count field. The maximum value of the user count is 100. - userInfo(optional) : - country: you can specify country for the test user. Country use ISO3166-1 alpha-2 two letter, e.g. US
   */
  createTestUser_v4(data) {
    const params = {};
    const url = "/iam/v4/admin/namespaces/{namespace}/test_users".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.post(url, data, { params });
    return import_sdk31.Validate.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      CreateTestUsersResponseV4,
      "CreateTestUsersResponseV4"
    );
  }
  /**
   * This endpoint is used to enable 2FA authenticator. ---------- Prerequisites: - Generate the secret key/QR code uri by **_/iam/v4/admin/users/me/mfa/authenticator/key_** - Consume the secret key/QR code by an authenticator app - Get the code from the authenticator app
   */
  postUserMeMfaAuthenticatorEnable_v4(data) {
    const params = {};
    const url = "/iam/v4/admin/users/me/mfa/authenticator/enable";
    const resultPromise = this.axiosInstance.post(url, import_sdk31.CodeGenUtil.getFormUrlEncodedData(data), {
      ...params,
      headers: { ...params.headers, "content-type": "application/x-www-form-urlencoded" }
    });
    return import_sdk31.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, import_zod156.z.unknown(), "z.unknown()");
  }
  /**
   * This endpoint is used to disable 2FA authenticator. ------ **Note**: **mfaToken** is required when all the following are enabled: - The environment variable **SENSITIVE_MFA_AUTH_ENABLED** is true - The **Two-Factor Authentication** is enabled in the IAM client where user logs in - Users already enabled the MFA
   */
  deleteUserMeMfaAuthenticatorDisable_v4(data) {
    const params = {};
    const url = "/iam/v4/admin/users/me/mfa/authenticator/disable";
    const resultPromise = this.axiosInstance.delete(url, { data, params });
    return import_sdk31.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, import_zod156.z.unknown(), "z.unknown()");
  }
  /**
   * This Endpoint support update user based on given data. **Single request can update single field or multi fields.** Supported field {country, displayName, languageTag, dateOfBirth, avatarUrl, userName} Country use ISO3166-1 alpha-2 two letter, e.g. US. Date of Birth format : YYYY-MM-DD, e.g. 2019-04-29. **Response body logic when user updating email address:** - User want to update email address of which have been verified, newEmailAddress response field will be filled with new email address. - User want to update email address of which have not been verified, { oldEmailAddress, emailAddress} response field will be filled with new email address. - User want to update email address of which have been verified and updated before, { oldEmailAddress, emailAddress} response field will be filled with verified email before. newEmailAddress response field will be filled with newest email address. action code : 10103
   */
  updateUser_ByUserId_v4(userId, data) {
    const params = {};
    const url = "/iam/v4/admin/namespaces/{namespace}/users/{userId}".replace("{namespace}", this.namespace).replace("{userId}", userId);
    const resultPromise = this.axiosInstance.put(url, data, { params });
    return import_sdk31.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, UserResponseV3, "UserResponseV3");
  }
  /**
   * This endpoint is to Invitation Historiy for specific new studio namespace in multi tenant mode. It will return error if the service multi tenant mode is set to false.
   */
  getInvitationHistories_ByNS_v4() {
    const params = {};
    const url = "/iam/v4/admin/namespaces/{namespace}/invitationHistories".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.get(url, { params });
    return import_sdk31.Validate.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      InvitationHistoryResponse,
      "InvitationHistoryResponse"
    );
  }
  /**
   * Use this endpoint to check if userID exists or not Maximum number of userID to be checked is 50
   */
  fetchUserBulkValidate_v4(data) {
    const params = {};
    const url = "/iam/v4/admin/namespaces/{namespace}/users/bulk/validate".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.post(url, data, { params });
    return import_sdk31.Validate.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      ListValidUserIdResponseV4,
      "ListValidUserIdResponseV4"
    );
  }
  /**
   * This is the endpoint for an admin to update a user email address. This endpoint need a valid user token from an admin to verify its identity (email) before updating a user.
   */
  updateEmail_ByUserId_v4(userId, data) {
    const params = {};
    const url = "/iam/v4/admin/namespaces/{namespace}/users/{userId}/email".replace("{namespace}", this.namespace).replace("{userId}", userId);
    const resultPromise = this.axiosInstance.put(url, data, { params });
    return import_sdk31.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, import_zod156.z.unknown(), "z.unknown()");
  }
  /**
   * Remove a role from user&#39;s roles.
   */
  deleteRole_ByUserId_v4(userId, data) {
    const params = {};
    const url = "/iam/v4/admin/namespaces/{namespace}/users/{userId}/roles".replace("{namespace}", this.namespace).replace("{userId}", userId);
    const resultPromise = this.axiosInstance.delete(url, { data, params });
    return import_sdk31.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, import_zod156.z.unknown(), "z.unknown()");
  }
  /**
   * List roles assigned to a user
   */
  getRoles_ByUserId_v4(userId) {
    const params = {};
    const url = "/iam/v4/admin/namespaces/{namespace}/users/{userId}/roles".replace("{namespace}", this.namespace).replace("{userId}", userId);
    const resultPromise = this.axiosInstance.get(url, { params });
    return import_sdk31.Validate.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      ListUserRolesV4Response,
      "ListUserRolesV4Response"
    );
  }
  /**
   * New role will be appended to user&#39;s current roles. An admin user can only assign role with **assignedNamespaces** if the admin user has required permission which is same as the required permission of this endpoint.
   */
  updateRole_ByUserId_v4(userId, data) {
    const params = {};
    const url = "/iam/v4/admin/namespaces/{namespace}/users/{userId}/roles".replace("{namespace}", this.namespace).replace("{userId}", userId);
    const resultPromise = this.axiosInstance.post(url, data, { params });
    return import_sdk31.Validate.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      ListUserRolesV4Response,
      "ListUserRolesV4Response"
    );
  }
  /**
   * User&#39;s roles will be replaced with roles from request body. An admin user can only assign role with **assignedNamespaces** if the admin user has required permission which is same as the required permission of this endpoint.
   */
  updateRole_ByUserId_ByNS_v4(userId, data) {
    const params = {};
    const url = "/iam/v4/admin/namespaces/{namespace}/users/{userId}/roles".replace("{namespace}", this.namespace).replace("{userId}", userId);
    const resultPromise = this.axiosInstance.put(url, data, { params });
    return import_sdk31.Validate.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      ListUserRolesV4Response,
      "ListUserRolesV4Response"
    );
  }
  /**
   * This endpoint is used to change users account type - set **testAccount** to &lt;code&gt;true&lt;/code&gt; to mark user as test account type - set **testAccount** to &lt;code&gt;false&lt;/code&gt; to mark user as default account type
   */
  patchUserBulkAccountType_v4(data) {
    const params = {};
    const url = "/iam/v4/admin/namespaces/{namespace}/users/bulk/accountType".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.patch(url, data, { params });
    return import_sdk31.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, import_zod156.z.unknown(), "z.unknown()");
  }
  /**
   * This endpoint is to Get list of users Invitation History for specific new studio namespace in multi tenant mode. It will return error if the service multi tenant mode is set to false. Accepted Query: - offset - limit
   */
  getInvitationHistoriesUsers_v4(queryParams) {
    const params = { ...queryParams };
    const url = "/iam/v4/admin/namespaces/{namespace}/invitationHistories/users".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.get(url, { params });
    return import_sdk31.Validate.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      NamespaceInvitationHistoryUserV4Response,
      "NamespaceInvitationHistoryUserV4Response"
    );
  }
  /**
   * **This endpoint is used to get user&#39;s 2FA status.**
   */
  getMfaStatus_ByUserId_v4(userId) {
    const params = {};
    const url = "/iam/v4/admin/namespaces/{namespace}/users/{userId}/mfa/status".replace("{namespace}", this.namespace).replace("{userId}", userId);
    const resultPromise = this.axiosInstance.get(url, { params });
    return import_sdk31.Validate.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      UserMfaStatusResponseV4,
      "UserMfaStatusResponseV4"
    );
  }
  /**
   * This endpoint is used to disable user 2FA. ----------- **Note**: if the factor is not specified, will disable all 2FA methods.
   */
  deleteMfaDisable_ByUserId_v4(userId, data) {
    const params = {};
    const url = "/iam/v4/admin/namespaces/{namespace}/users/{userId}/mfa/disable".replace("{namespace}", this.namespace).replace("{userId}", userId);
    const resultPromise = this.axiosInstance.delete(url, { data, params });
    return import_sdk31.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, import_zod156.z.unknown(), "z.unknown()");
  }
};

// src/generated-admin/UsersV4AdminApi.ts
function UsersV4AdminApi(sdk, args) {
  const sdkAssembly = sdk.assembly();
  const namespace = args?.coreConfig?.namespace ?? sdkAssembly.coreConfig.namespace;
  const useSchemaValidation = args?.coreConfig?.useSchemaValidation ?? sdkAssembly.coreConfig.useSchemaValidation;
  let axiosInstance = sdkAssembly.axiosInstance;
  const requestConfigOverrides = args?.axiosConfig?.request;
  const baseURLOverride = args?.coreConfig?.baseURL;
  const interceptorsOverride = args?.axiosConfig?.interceptors ?? [];
  if (requestConfigOverrides || baseURLOverride || interceptorsOverride.length > 0) {
    const requestConfig = import_sdk32.ApiUtils.mergeAxiosConfigs(sdkAssembly.axiosInstance.defaults, {
      ...baseURLOverride ? { baseURL: baseURLOverride } : {},
      ...requestConfigOverrides
    });
    axiosInstance = import_sdk32.Network.create(requestConfig);
    for (const interceptor of interceptorsOverride) {
      if (interceptor.type === "request") {
        axiosInstance.interceptors.request.use(interceptor.onRequest, interceptor.onError);
      }
      if (interceptor.type === "response") {
        axiosInstance.interceptors.response.use(interceptor.onSuccess, interceptor.onError);
      }
    }
  }
  async function patchUserMe_v4(data) {
    const $ = new UsersV4Admin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.patchUserMe_v4(data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function createUserInvite_v4(data) {
    const $ = new UsersV4Admin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.createUserInvite_v4(data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function createUserUserInvite_v4(data) {
    const $ = new UsersV4Admin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.createUserUserInvite_v4(data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getInvitationHistories_v4(queryParams) {
    const $ = new UsersV4Admin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getInvitationHistories_v4(queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getUsersMeMfaFactor_v4() {
    const $ = new UsersV4Admin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getUsersMeMfaFactor_v4();
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function postUserMeMfaFactor_v4(data) {
    const $ = new UsersV4Admin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.postUserMeMfaFactor_v4(data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getUsersMeMfaStatus_v4() {
    const $ = new UsersV4Admin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getUsersMeMfaStatus_v4();
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function createUserMeMfaStatus_v4() {
    const $ = new UsersV4Admin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.createUserMeMfaStatus_v4();
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getUsersMeMfaBackupCode_v4() {
    const $ = new UsersV4Admin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getUsersMeMfaBackupCode_v4();
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function createUserMeMfaBackupCode_v4() {
    const $ = new UsersV4Admin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.createUserMeMfaBackupCode_v4();
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function postUserMeMfaEmailCode_v4(data) {
    const $ = new UsersV4Admin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.postUserMeMfaEmailCode_v4(data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getUsersMeMfaBackupCodes_v4(queryParams) {
    const $ = new UsersV4Admin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getUsersMeMfaBackupCodes_v4(queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function createUserMeMfaBackupCode_admin_v4(queryParams) {
    const $ = new UsersV4Admin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.createUserMeMfaBackupCode_admin_v4(queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function postUserMeMfaEmailEnable_v4(data) {
    const $ = new UsersV4Admin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.postUserMeMfaEmailEnable_v4(data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function createUserMeMfaEmailDisable_v4(data) {
    const $ = new UsersV4Admin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.createUserMeMfaEmailDisable_v4(data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function createUser_v4(data) {
    const $ = new UsersV4Admin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.createUser_v4(data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function postUserMeMfaChallengeVerify_v4(data) {
    const $ = new UsersV4Admin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.postUserMeMfaChallengeVerify_v4(data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function createUserMeMfaAuthenticatorKey_v4() {
    const $ = new UsersV4Admin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.createUserMeMfaAuthenticatorKey_v4();
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function createUserMeMfaBackupCodeEnable_v4() {
    const $ = new UsersV4Admin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.createUserMeMfaBackupCodeEnable_v4();
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function deleteUserMeMfaBackupCodeDisable_v4(data) {
    const $ = new UsersV4Admin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.deleteUserMeMfaBackupCodeDisable_v4(data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function createUserMeMfaBackupCodeEnable_admin_v4(queryParams) {
    const $ = new UsersV4Admin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.createUserMeMfaBackupCodeEnable_admin_v4(queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getUsersMeMfaBackupCodeDownload_v4() {
    const $ = new UsersV4Admin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getUsersMeMfaBackupCodeDownload_v4();
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function createTestUser_v4(data) {
    const $ = new UsersV4Admin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.createTestUser_v4(data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function postUserMeMfaAuthenticatorEnable_v4(data) {
    const $ = new UsersV4Admin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.postUserMeMfaAuthenticatorEnable_v4(data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function deleteUserMeMfaAuthenticatorDisable_v4(data) {
    const $ = new UsersV4Admin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.deleteUserMeMfaAuthenticatorDisable_v4(data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function updateUser_ByUserId_v4(userId, data) {
    const $ = new UsersV4Admin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.updateUser_ByUserId_v4(userId, data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getInvitationHistories_ByNS_v4() {
    const $ = new UsersV4Admin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getInvitationHistories_ByNS_v4();
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function fetchUserBulkValidate_v4(data) {
    const $ = new UsersV4Admin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.fetchUserBulkValidate_v4(data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function updateEmail_ByUserId_v4(userId, data) {
    const $ = new UsersV4Admin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.updateEmail_ByUserId_v4(userId, data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function deleteRole_ByUserId_v4(userId, data) {
    const $ = new UsersV4Admin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.deleteRole_ByUserId_v4(userId, data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getRoles_ByUserId_v4(userId) {
    const $ = new UsersV4Admin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getRoles_ByUserId_v4(userId);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function updateRole_ByUserId_v4(userId, data) {
    const $ = new UsersV4Admin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.updateRole_ByUserId_v4(userId, data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function updateRole_ByUserId_ByNS_v4(userId, data) {
    const $ = new UsersV4Admin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.updateRole_ByUserId_ByNS_v4(userId, data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function patchUserBulkAccountType_v4(data) {
    const $ = new UsersV4Admin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.patchUserBulkAccountType_v4(data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getInvitationHistoriesUsers_v4(queryParams) {
    const $ = new UsersV4Admin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getInvitationHistoriesUsers_v4(queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getMfaStatus_ByUserId_v4(userId) {
    const $ = new UsersV4Admin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getMfaStatus_ByUserId_v4(userId);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function deleteMfaDisable_ByUserId_v4(userId, data) {
    const $ = new UsersV4Admin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.deleteMfaDisable_ByUserId_v4(userId, data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  return {
    /**
     * This Endpoint support update user based on given data. **Single request can update single field or multi fields.** Supported field {country, displayName, languageTag, dateOfBirth, avatarUrl, userName} Country use ISO3166-1 alpha-2 two letter, e.g. US. Date of Birth format : YYYY-MM-DD, e.g. 2019-04-29. action code : 10103
     */
    patchUserMe_v4,
    /**
     * Use this endpoint to invite admin or non-admin user and assign role to them. The role must be scoped to namespace. An admin user can only assign role with **assignedNamespaces** if the admin user has required permission which is same as the required permission of endpoint: [AdminAddUserRoleV4]. Detail request body : - **emailAddresses** is required, List of email addresses that will be invited - **isAdmin** is required, true if user is admin, false if user is not admin - **namespace** is optional. Only works on multi tenant mode, if not specified then it will be assigned Publisher namespace, if specified, it will become that studio/publisher where user is invited to. - **roleId** is optional, if not specified then it will only assign User role. - **assignedNamespaces** is optional, List of namespaces which the Role will be assigned to the user, only works when Role is not empty. The invited admin will also assigned with &#34;User&#34; role by default.
     */
    createUserInvite_v4,
    /**
     * @deprecated
     * Use this endpoint to invite admin or non-admin user and assign role to them. The role must be scoped to namespace. An admin user can only assign role with **assignedNamespaces** if the admin user has required permission which is same as the required permission of endpoint: [AdminAddUserRoleV4]. Detail request body : - Email Address is required, List of email addresses that will be invited - isAdmin is required, true if user is admin, false if user is not admin - Namespace is optional. Only works on multi tenant mode, if not specified then it will be assigned Publisher namespace, if specified, it will become that studio/publisher where user is invited to. - Role is optional, if not specified then it will only assign User role. - Assigned Namespaces is optional, List of namespaces which the Role will be assigned to the user, only works when Role is not empty. The invited admin will also assigned with &#34;User&#34; role by default. Substitute endpoint: /iam/v4/admin/users/invite
     */
    createUserUserInvite_v4,
    /**
     * This endpoint is to list all Invitation Histories for new studio namespace in multi tenant mode. It will return error if the service multi tenant mode is set to false. Accepted Query: - namespace - offset - limit
     */
    getInvitationHistories_v4,
    /**
     * This endpoint is used to get user enabled factors.
     */
    getUsersMeMfaFactor_v4,
    /**
     * This endpoint is used to make 2FA factor default.
     */
    postUserMeMfaFactor_v4,
    /**
     * This endpoint will get user&#39;s&#39; MFA status.
     */
    getUsersMeMfaStatus_v4,
    /**
     * @deprecated
     * This endpoint will get user&#39;s&#39; MFA status. ------------ **Substitute endpoint**: /iam/v4/admin/users/me/mfa/status [GET]
     */
    createUserMeMfaStatus_v4,
    /**
     * @deprecated
     * This endpoint is used to get 8-digits backup codes. Each code is a one-time code and will be deleted once used.
     */
    getUsersMeMfaBackupCode_v4,
    /**
     * @deprecated
     * This endpoint is used to generate 8-digits backup codes. Each code is a one-time code and will be deleted once used.
     */
    createUserMeMfaBackupCode_v4,
    /**
     * This endpoint is used to send email code. -------------- Supported actions: * ChangePassword * DisableMFAEmail
     */
    postUserMeMfaEmailCode_v4,
    /**
     * This endpoint is used to get 8-digits backup codes. Each code is a one-time code and will be deleted once used.
     */
    getUsersMeMfaBackupCodes_v4,
    /**
     * This endpoint is used to generate 8-digits backup codes. Each code is a one-time code and will be deleted once used.
     */
    createUserMeMfaBackupCode_admin_v4,
    /**
     * This endpoint is used to enable 2FA email.
     */
    postUserMeMfaEmailEnable_v4,
    /**
     * This endpoint is used to disable 2FA email. ------ **Note**: **mfaToken** is required when all the following are enabled: - The environment variable **SENSITIVE_MFA_AUTH_ENABLED** is true - The **Two-Factor Authentication** is enabled in the IAM client where user logs in - Users already enabled the MFA
     */
    createUserMeMfaEmailDisable_v4,
    /**
     * Create a new user with unique email address and username. **Required attributes:** - authType: possible value is EMAILPASSWD - emailAddress: Please refer to the rule from /v3/public/inputValidations API. - username: Please refer to the rule from /v3/public/inputValidations API. - password: Please refer to the rule from /v3/public/inputValidations API. - country: ISO3166-1 alpha-2 two letter, e.g. US. - dateOfBirth: YYYY-MM-DD, e.g. 1990-01-01. valid values are between 1905-01-01 until current date. - uniqueDisplayName: required when uniqueDisplayNameEnabled/UNIQUE_DISPLAY_NAME_ENABLED is true, please refer to the rule from /v3/public/inputValidations API. **Not required attributes:** - displayName: Please refer to the rule from /v3/public/inputValidations API. This endpoint support accepting agreements for the created user. Supply the accepted agreements in acceptedPolicies attribute.
     */
    createUser_v4,
    /**
     * This endpoint will verify user&#39;s&#39; MFA code and generate a MFA token.
     */
    postUserMeMfaChallengeVerify_v4,
    /**
     * This endpoint is used to generate a secret key for 3rd-party authenticator app. A QR code URI is also returned so that frontend can generate QR code image.
     */
    createUserMeMfaAuthenticatorKey_v4,
    /**
     * @deprecated
     * This endpoint is used to enable 2FA backup codes.
     */
    createUserMeMfaBackupCodeEnable_v4,
    /**
     * This endpoint is used to disable 2FA backup codes. ------ **Note**: **mfaToken** is required when all the following are enabled: - The environment variable **SENSITIVE_MFA_AUTH_ENABLED** is true - The **Two-Factor Authentication** is enabled in the IAM client where user logs in - Users already enabled the MFA
     */
    deleteUserMeMfaBackupCodeDisable_v4,
    /**
     * This endpoint is used to enable 2FA backup codes.
     */
    createUserMeMfaBackupCodeEnable_admin_v4,
    /**
     * @deprecated
     * This endpoint is used to download backup codes.
     */
    getUsersMeMfaBackupCodeDownload_v4,
    /**
     * Create test users and not send verification code email. Note: - count : Enter the number of test users you want to create in the count field. The maximum value of the user count is 100. - userInfo(optional) : - country: you can specify country for the test user. Country use ISO3166-1 alpha-2 two letter, e.g. US
     */
    createTestUser_v4,
    /**
     * This endpoint is used to enable 2FA authenticator. ---------- Prerequisites: - Generate the secret key/QR code uri by **_/iam/v4/admin/users/me/mfa/authenticator/key_** - Consume the secret key/QR code by an authenticator app - Get the code from the authenticator app
     */
    postUserMeMfaAuthenticatorEnable_v4,
    /**
     * This endpoint is used to disable 2FA authenticator. ------ **Note**: **mfaToken** is required when all the following are enabled: - The environment variable **SENSITIVE_MFA_AUTH_ENABLED** is true - The **Two-Factor Authentication** is enabled in the IAM client where user logs in - Users already enabled the MFA
     */
    deleteUserMeMfaAuthenticatorDisable_v4,
    /**
     * This Endpoint support update user based on given data. **Single request can update single field or multi fields.** Supported field {country, displayName, languageTag, dateOfBirth, avatarUrl, userName} Country use ISO3166-1 alpha-2 two letter, e.g. US. Date of Birth format : YYYY-MM-DD, e.g. 2019-04-29. **Response body logic when user updating email address:** - User want to update email address of which have been verified, newEmailAddress response field will be filled with new email address. - User want to update email address of which have not been verified, { oldEmailAddress, emailAddress} response field will be filled with new email address. - User want to update email address of which have been verified and updated before, { oldEmailAddress, emailAddress} response field will be filled with verified email before. newEmailAddress response field will be filled with newest email address. action code : 10103
     */
    updateUser_ByUserId_v4,
    /**
     * This endpoint is to Invitation Historiy for specific new studio namespace in multi tenant mode. It will return error if the service multi tenant mode is set to false.
     */
    getInvitationHistories_ByNS_v4,
    /**
     * Use this endpoint to check if userID exists or not Maximum number of userID to be checked is 50
     */
    fetchUserBulkValidate_v4,
    /**
     * This is the endpoint for an admin to update a user email address. This endpoint need a valid user token from an admin to verify its identity (email) before updating a user.
     */
    updateEmail_ByUserId_v4,
    /**
     * Remove a role from user&#39;s roles.
     */
    deleteRole_ByUserId_v4,
    /**
     * List roles assigned to a user
     */
    getRoles_ByUserId_v4,
    /**
     * New role will be appended to user&#39;s current roles. An admin user can only assign role with **assignedNamespaces** if the admin user has required permission which is same as the required permission of this endpoint.
     */
    updateRole_ByUserId_v4,
    /**
     * User&#39;s roles will be replaced with roles from request body. An admin user can only assign role with **assignedNamespaces** if the admin user has required permission which is same as the required permission of this endpoint.
     */
    updateRole_ByUserId_ByNS_v4,
    /**
     * This endpoint is used to change users account type - set **testAccount** to &lt;code&gt;true&lt;/code&gt; to mark user as test account type - set **testAccount** to &lt;code&gt;false&lt;/code&gt; to mark user as default account type
     */
    patchUserBulkAccountType_v4,
    /**
     * This endpoint is to Get list of users Invitation History for specific new studio namespace in multi tenant mode. It will return error if the service multi tenant mode is set to false. Accepted Query: - offset - limit
     */
    getInvitationHistoriesUsers_v4,
    /**
     * **This endpoint is used to get user&#39;s 2FA status.**
     */
    getMfaStatus_ByUserId_v4,
    /**
     * This endpoint is used to disable user 2FA. ----------- **Note**: if the factor is not specified, will disable all 2FA methods.
     */
    deleteMfaDisable_ByUserId_v4
  };
}

// src/generated-admin/queries/UsersV4Admin.query.ts
var Key_UsersV4Admin = /* @__PURE__ */ ((Key_UsersV4Admin2) => {
  Key_UsersV4Admin2["UserMe_v4"] = "Iam.UsersV4Admin.UserMe_v4";
  Key_UsersV4Admin2["UserInvite_v4"] = "Iam.UsersV4Admin.UserInvite_v4";
  Key_UsersV4Admin2["UserUserInvite_v4"] = "Iam.UsersV4Admin.UserUserInvite_v4";
  Key_UsersV4Admin2["InvitationHistories_v4"] = "Iam.UsersV4Admin.InvitationHistories_v4";
  Key_UsersV4Admin2["UsersMeMfaFactor_v4"] = "Iam.UsersV4Admin.UsersMeMfaFactor_v4";
  Key_UsersV4Admin2["UserMeMfaFactor_v4"] = "Iam.UsersV4Admin.UserMeMfaFactor_v4";
  Key_UsersV4Admin2["UsersMeMfaStatus_v4"] = "Iam.UsersV4Admin.UsersMeMfaStatus_v4";
  Key_UsersV4Admin2["UserMeMfaStatus_v4"] = "Iam.UsersV4Admin.UserMeMfaStatus_v4";
  Key_UsersV4Admin2["UsersMeMfaBackupCode_v4"] = "Iam.UsersV4Admin.UsersMeMfaBackupCode_v4";
  Key_UsersV4Admin2["UserMeMfaBackupCode_v4"] = "Iam.UsersV4Admin.UserMeMfaBackupCode_v4";
  Key_UsersV4Admin2["UserMeMfaEmailCode_v4"] = "Iam.UsersV4Admin.UserMeMfaEmailCode_v4";
  Key_UsersV4Admin2["UsersMeMfaBackupCodes_v4"] = "Iam.UsersV4Admin.UsersMeMfaBackupCodes_v4";
  Key_UsersV4Admin2["UserMeMfaBackupCode_admin_v4"] = "Iam.UsersV4Admin.UserMeMfaBackupCode_admin_v4";
  Key_UsersV4Admin2["UserMeMfaEmailEnable_v4"] = "Iam.UsersV4Admin.UserMeMfaEmailEnable_v4";
  Key_UsersV4Admin2["UserMeMfaEmailDisable_v4"] = "Iam.UsersV4Admin.UserMeMfaEmailDisable_v4";
  Key_UsersV4Admin2["User_v4"] = "Iam.UsersV4Admin.User_v4";
  Key_UsersV4Admin2["UserMeMfaChallengeVerify_v4"] = "Iam.UsersV4Admin.UserMeMfaChallengeVerify_v4";
  Key_UsersV4Admin2["UserMeMfaAuthenticatorKey_v4"] = "Iam.UsersV4Admin.UserMeMfaAuthenticatorKey_v4";
  Key_UsersV4Admin2["UserMeMfaBackupCodeEnable_v4"] = "Iam.UsersV4Admin.UserMeMfaBackupCodeEnable_v4";
  Key_UsersV4Admin2["UserMeMfaBackupCodeDisable_v4"] = "Iam.UsersV4Admin.UserMeMfaBackupCodeDisable_v4";
  Key_UsersV4Admin2["UserMeMfaBackupCodeEnable_admin_v4"] = "Iam.UsersV4Admin.UserMeMfaBackupCodeEnable_admin_v4";
  Key_UsersV4Admin2["UsersMeMfaBackupCodeDownload_v4"] = "Iam.UsersV4Admin.UsersMeMfaBackupCodeDownload_v4";
  Key_UsersV4Admin2["TestUser_v4"] = "Iam.UsersV4Admin.TestUser_v4";
  Key_UsersV4Admin2["UserMeMfaAuthenticatorEnable_v4"] = "Iam.UsersV4Admin.UserMeMfaAuthenticatorEnable_v4";
  Key_UsersV4Admin2["UserMeMfaAuthenticatorDisable_v4"] = "Iam.UsersV4Admin.UserMeMfaAuthenticatorDisable_v4";
  Key_UsersV4Admin2["User_ByUserId_v4"] = "Iam.UsersV4Admin.User_ByUserId_v4";
  Key_UsersV4Admin2["InvitationHistories_ByNS_v4"] = "Iam.UsersV4Admin.InvitationHistories_ByNS_v4";
  Key_UsersV4Admin2["UserBulkValidate_v4"] = "Iam.UsersV4Admin.UserBulkValidate_v4";
  Key_UsersV4Admin2["Email_ByUserId_v4"] = "Iam.UsersV4Admin.Email_ByUserId_v4";
  Key_UsersV4Admin2["Role_ByUserId_v4"] = "Iam.UsersV4Admin.Role_ByUserId_v4";
  Key_UsersV4Admin2["Roles_ByUserId_v4"] = "Iam.UsersV4Admin.Roles_ByUserId_v4";
  Key_UsersV4Admin2["Role_ByUserId_ByNS_v4"] = "Iam.UsersV4Admin.Role_ByUserId_ByNS_v4";
  Key_UsersV4Admin2["UserBulkAccountType_v4"] = "Iam.UsersV4Admin.UserBulkAccountType_v4";
  Key_UsersV4Admin2["InvitationHistoriesUsers_v4"] = "Iam.UsersV4Admin.InvitationHistoriesUsers_v4";
  Key_UsersV4Admin2["MfaStatus_ByUserId_v4"] = "Iam.UsersV4Admin.MfaStatus_ByUserId_v4";
  Key_UsersV4Admin2["MfaDisable_ByUserId_v4"] = "Iam.UsersV4Admin.MfaDisable_ByUserId_v4";
  return Key_UsersV4Admin2;
})(Key_UsersV4Admin || {});
var useUsersV4AdminApi_PatchUserMeMutation_v4 = (sdk, options, callback) => {
  const mutationFn = async (input) => {
    const response = await UsersV4AdminApi(sdk, { coreConfig: input.coreConfig, axiosConfig: input.axiosConfig }).patchUserMe_v4(input.data);
    callback && callback(response.data);
    return response.data;
  };
  return (0, import_react_query16.useMutation)({
    mutationKey: ["Iam.UsersV4Admin.UserMe_v4" /* UserMe_v4 */],
    mutationFn,
    ...options
  });
};
var useUsersV4AdminApi_CreateUserInviteMutation_v4 = (sdk, options, callback) => {
  const mutationFn = async (input) => {
    const response = await UsersV4AdminApi(sdk, { coreConfig: input.coreConfig, axiosConfig: input.axiosConfig }).createUserInvite_v4(
      input.data
    );
    callback && callback(response.data);
    return response.data;
  };
  return (0, import_react_query16.useMutation)({
    mutationKey: ["Iam.UsersV4Admin.UserInvite_v4" /* UserInvite_v4 */],
    mutationFn,
    ...options
  });
};
var useUsersV4AdminApi_CreateUserUserInviteMutation_v4 = (sdk, options, callback) => {
  const mutationFn = async (input) => {
    const response = await UsersV4AdminApi(sdk, { coreConfig: input.coreConfig, axiosConfig: input.axiosConfig }).createUserUserInvite_v4(
      input.data
    );
    callback && callback(response.data);
    return response.data;
  };
  return (0, import_react_query16.useMutation)({
    mutationKey: ["Iam.UsersV4Admin.UserUserInvite_v4" /* UserUserInvite_v4 */],
    mutationFn,
    ...options
  });
};
var useUsersV4AdminApi_GetInvitationHistories_v4 = (sdk, input, options, callback) => {
  const queryFn = (sdk2, input2) => async () => {
    const response = await UsersV4AdminApi(sdk2, { coreConfig: input2.coreConfig, axiosConfig: input2.axiosConfig }).getInvitationHistories_v4(
      input2.queryParams
    );
    callback && callback(response);
    return response.data;
  };
  return (0, import_react_query16.useQuery)({
    queryKey: ["Iam.UsersV4Admin.InvitationHistories_v4" /* InvitationHistories_v4 */, input],
    queryFn: queryFn(sdk, input),
    ...options
  });
};
var useUsersV4AdminApi_GetUsersMeMfaFactor_v4 = (sdk, input, options, callback) => {
  const queryFn = (sdk2, input2) => async () => {
    const response = await UsersV4AdminApi(sdk2, { coreConfig: input2.coreConfig, axiosConfig: input2.axiosConfig }).getUsersMeMfaFactor_v4();
    callback && callback(response);
    return response.data;
  };
  return (0, import_react_query16.useQuery)({
    queryKey: ["Iam.UsersV4Admin.UsersMeMfaFactor_v4" /* UsersMeMfaFactor_v4 */, input],
    queryFn: queryFn(sdk, input),
    ...options
  });
};
var useUsersV4AdminApi_PostUserMeMfaFactorMutation_v4 = (sdk, options, callback) => {
  const mutationFn = async (input) => {
    const response = await UsersV4AdminApi(sdk, { coreConfig: input.coreConfig, axiosConfig: input.axiosConfig }).postUserMeMfaFactor_v4(
      input.data
    );
    callback && callback(response.data);
    return response.data;
  };
  return (0, import_react_query16.useMutation)({
    mutationKey: ["Iam.UsersV4Admin.UserMeMfaFactor_v4" /* UserMeMfaFactor_v4 */],
    mutationFn,
    ...options
  });
};
var useUsersV4AdminApi_GetUsersMeMfaStatus_v4 = (sdk, input, options, callback) => {
  const queryFn = (sdk2, input2) => async () => {
    const response = await UsersV4AdminApi(sdk2, { coreConfig: input2.coreConfig, axiosConfig: input2.axiosConfig }).getUsersMeMfaStatus_v4();
    callback && callback(response);
    return response.data;
  };
  return (0, import_react_query16.useQuery)({
    queryKey: ["Iam.UsersV4Admin.UsersMeMfaStatus_v4" /* UsersMeMfaStatus_v4 */, input],
    queryFn: queryFn(sdk, input),
    ...options
  });
};
var useUsersV4AdminApi_CreateUserMeMfaStatusMutation_v4 = (sdk, options, callback) => {
  const mutationFn = async (input) => {
    const response = await UsersV4AdminApi(sdk, { coreConfig: input.coreConfig, axiosConfig: input.axiosConfig }).createUserMeMfaStatus_v4();
    callback && callback(response.data);
    return response.data;
  };
  return (0, import_react_query16.useMutation)({
    mutationKey: ["Iam.UsersV4Admin.UserMeMfaStatus_v4" /* UserMeMfaStatus_v4 */],
    mutationFn,
    ...options
  });
};
var useUsersV4AdminApi_GetUsersMeMfaBackupCode_v4 = (sdk, input, options, callback) => {
  const queryFn = (sdk2, input2) => async () => {
    const response = await UsersV4AdminApi(sdk2, {
      coreConfig: input2.coreConfig,
      axiosConfig: input2.axiosConfig
    }).getUsersMeMfaBackupCode_v4();
    callback && callback(response);
    return response.data;
  };
  return (0, import_react_query16.useQuery)({
    queryKey: ["Iam.UsersV4Admin.UsersMeMfaBackupCode_v4" /* UsersMeMfaBackupCode_v4 */, input],
    queryFn: queryFn(sdk, input),
    ...options
  });
};
var useUsersV4AdminApi_CreateUserMeMfaBackupCodeMutation_v4 = (sdk, options, callback) => {
  const mutationFn = async (input) => {
    const response = await UsersV4AdminApi(sdk, {
      coreConfig: input.coreConfig,
      axiosConfig: input.axiosConfig
    }).createUserMeMfaBackupCode_v4();
    callback && callback(response.data);
    return response.data;
  };
  return (0, import_react_query16.useMutation)({
    mutationKey: ["Iam.UsersV4Admin.UserMeMfaBackupCode_v4" /* UserMeMfaBackupCode_v4 */],
    mutationFn,
    ...options
  });
};
var useUsersV4AdminApi_PostUserMeMfaEmailCodeMutation_v4 = (sdk, options, callback) => {
  const mutationFn = async (input) => {
    const response = await UsersV4AdminApi(sdk, { coreConfig: input.coreConfig, axiosConfig: input.axiosConfig }).postUserMeMfaEmailCode_v4(
      input.data
    );
    callback && callback(response.data);
    return response.data;
  };
  return (0, import_react_query16.useMutation)({
    mutationKey: ["Iam.UsersV4Admin.UserMeMfaEmailCode_v4" /* UserMeMfaEmailCode_v4 */],
    mutationFn,
    ...options
  });
};
var useUsersV4AdminApi_GetUsersMeMfaBackupCodes_v4 = (sdk, input, options, callback) => {
  const queryFn = (sdk2, input2) => async () => {
    const response = await UsersV4AdminApi(sdk2, {
      coreConfig: input2.coreConfig,
      axiosConfig: input2.axiosConfig
    }).getUsersMeMfaBackupCodes_v4(input2.queryParams);
    callback && callback(response);
    return response.data;
  };
  return (0, import_react_query16.useQuery)({
    queryKey: ["Iam.UsersV4Admin.UsersMeMfaBackupCodes_v4" /* UsersMeMfaBackupCodes_v4 */, input],
    queryFn: queryFn(sdk, input),
    ...options
  });
};
var useUsersV4AdminApi_CreateUserMeMfaBackupCode_adminMutation_v4 = (sdk, options, callback) => {
  const mutationFn = async (input) => {
    const response = await UsersV4AdminApi(sdk, {
      coreConfig: input.coreConfig,
      axiosConfig: input.axiosConfig
    }).createUserMeMfaBackupCode_admin_v4(input.queryParams);
    callback && callback(response.data);
    return response.data;
  };
  return (0, import_react_query16.useMutation)({
    mutationKey: ["Iam.UsersV4Admin.UserMeMfaBackupCode_admin_v4" /* UserMeMfaBackupCode_admin_v4 */],
    mutationFn,
    ...options
  });
};
var useUsersV4AdminApi_PostUserMeMfaEmailEnableMutation_v4 = (sdk, options, callback) => {
  const mutationFn = async (input) => {
    const response = await UsersV4AdminApi(sdk, {
      coreConfig: input.coreConfig,
      axiosConfig: input.axiosConfig
    }).postUserMeMfaEmailEnable_v4(input.data);
    callback && callback(response.data);
    return response.data;
  };
  return (0, import_react_query16.useMutation)({
    mutationKey: ["Iam.UsersV4Admin.UserMeMfaEmailEnable_v4" /* UserMeMfaEmailEnable_v4 */],
    mutationFn,
    ...options
  });
};
var useUsersV4AdminApi_CreateUserMeMfaEmailDisableMutation_v4 = (sdk, options, callback) => {
  const mutationFn = async (input) => {
    const response = await UsersV4AdminApi(sdk, {
      coreConfig: input.coreConfig,
      axiosConfig: input.axiosConfig
    }).createUserMeMfaEmailDisable_v4(input.data);
    callback && callback(response.data);
    return response.data;
  };
  return (0, import_react_query16.useMutation)({
    mutationKey: ["Iam.UsersV4Admin.UserMeMfaEmailDisable_v4" /* UserMeMfaEmailDisable_v4 */],
    mutationFn,
    ...options
  });
};
var useUsersV4AdminApi_CreateUserMutation_v4 = (sdk, options, callback) => {
  const mutationFn = async (input) => {
    const response = await UsersV4AdminApi(sdk, { coreConfig: input.coreConfig, axiosConfig: input.axiosConfig }).createUser_v4(input.data);
    callback && callback(response.data);
    return response.data;
  };
  return (0, import_react_query16.useMutation)({
    mutationKey: ["Iam.UsersV4Admin.User_v4" /* User_v4 */],
    mutationFn,
    ...options
  });
};
var useUsersV4AdminApi_PostUserMeMfaChallengeVerifyMutation_v4 = (sdk, options, callback) => {
  const mutationFn = async (input) => {
    const response = await UsersV4AdminApi(sdk, {
      coreConfig: input.coreConfig,
      axiosConfig: input.axiosConfig
    }).postUserMeMfaChallengeVerify_v4(input.data);
    callback && callback(response.data);
    return response.data;
  };
  return (0, import_react_query16.useMutation)({
    mutationKey: ["Iam.UsersV4Admin.UserMeMfaChallengeVerify_v4" /* UserMeMfaChallengeVerify_v4 */],
    mutationFn,
    ...options
  });
};
var useUsersV4AdminApi_CreateUserMeMfaAuthenticatorKeyMutation_v4 = (sdk, options, callback) => {
  const mutationFn = async (input) => {
    const response = await UsersV4AdminApi(sdk, {
      coreConfig: input.coreConfig,
      axiosConfig: input.axiosConfig
    }).createUserMeMfaAuthenticatorKey_v4();
    callback && callback(response.data);
    return response.data;
  };
  return (0, import_react_query16.useMutation)({
    mutationKey: ["Iam.UsersV4Admin.UserMeMfaAuthenticatorKey_v4" /* UserMeMfaAuthenticatorKey_v4 */],
    mutationFn,
    ...options
  });
};
var useUsersV4AdminApi_CreateUserMeMfaBackupCodeEnableMutation_v4 = (sdk, options, callback) => {
  const mutationFn = async (input) => {
    const response = await UsersV4AdminApi(sdk, {
      coreConfig: input.coreConfig,
      axiosConfig: input.axiosConfig
    }).createUserMeMfaBackupCodeEnable_v4();
    callback && callback(response.data);
    return response.data;
  };
  return (0, import_react_query16.useMutation)({
    mutationKey: ["Iam.UsersV4Admin.UserMeMfaBackupCodeEnable_v4" /* UserMeMfaBackupCodeEnable_v4 */],
    mutationFn,
    ...options
  });
};
var useUsersV4AdminApi_DeleteUserMeMfaBackupCodeDisableMutation_v4 = (sdk, options, callback) => {
  const mutationFn = async (input) => {
    const response = await UsersV4AdminApi(sdk, {
      coreConfig: input.coreConfig,
      axiosConfig: input.axiosConfig
    }).deleteUserMeMfaBackupCodeDisable_v4(input.data);
    callback && callback(response.data);
    return response.data;
  };
  return (0, import_react_query16.useMutation)({
    mutationKey: ["Iam.UsersV4Admin.UserMeMfaBackupCodeDisable_v4" /* UserMeMfaBackupCodeDisable_v4 */],
    mutationFn,
    ...options
  });
};
var useUsersV4AdminApi_CreateUserMeMfaBackupCodeEnable_adminMutation_v4 = (sdk, options, callback) => {
  const mutationFn = async (input) => {
    const response = await UsersV4AdminApi(sdk, {
      coreConfig: input.coreConfig,
      axiosConfig: input.axiosConfig
    }).createUserMeMfaBackupCodeEnable_admin_v4(input.queryParams);
    callback && callback(response.data);
    return response.data;
  };
  return (0, import_react_query16.useMutation)({
    mutationKey: ["Iam.UsersV4Admin.UserMeMfaBackupCodeEnable_admin_v4" /* UserMeMfaBackupCodeEnable_admin_v4 */],
    mutationFn,
    ...options
  });
};
var useUsersV4AdminApi_GetUsersMeMfaBackupCodeDownload_v4 = (sdk, input, options, callback) => {
  const queryFn = (sdk2, input2) => async () => {
    const response = await UsersV4AdminApi(sdk2, {
      coreConfig: input2.coreConfig,
      axiosConfig: input2.axiosConfig
    }).getUsersMeMfaBackupCodeDownload_v4();
    callback && callback(response);
    return response.data;
  };
  return (0, import_react_query16.useQuery)({
    queryKey: ["Iam.UsersV4Admin.UsersMeMfaBackupCodeDownload_v4" /* UsersMeMfaBackupCodeDownload_v4 */, input],
    queryFn: queryFn(sdk, input),
    ...options
  });
};
var useUsersV4AdminApi_CreateTestUserMutation_v4 = (sdk, options, callback) => {
  const mutationFn = async (input) => {
    const response = await UsersV4AdminApi(sdk, { coreConfig: input.coreConfig, axiosConfig: input.axiosConfig }).createTestUser_v4(
      input.data
    );
    callback && callback(response.data);
    return response.data;
  };
  return (0, import_react_query16.useMutation)({
    mutationKey: ["Iam.UsersV4Admin.TestUser_v4" /* TestUser_v4 */],
    mutationFn,
    ...options
  });
};
var useUsersV4AdminApi_PostUserMeMfaAuthenticatorEnableMutation_v4 = (sdk, options, callback) => {
  const mutationFn = async (input) => {
    const response = await UsersV4AdminApi(sdk, {
      coreConfig: input.coreConfig,
      axiosConfig: input.axiosConfig
    }).postUserMeMfaAuthenticatorEnable_v4(input.data);
    callback && callback(response.data);
    return response.data;
  };
  return (0, import_react_query16.useMutation)({
    mutationKey: ["Iam.UsersV4Admin.UserMeMfaAuthenticatorEnable_v4" /* UserMeMfaAuthenticatorEnable_v4 */],
    mutationFn,
    ...options
  });
};
var useUsersV4AdminApi_DeleteUserMeMfaAuthenticatorDisableMutation_v4 = (sdk, options, callback) => {
  const mutationFn = async (input) => {
    const response = await UsersV4AdminApi(sdk, {
      coreConfig: input.coreConfig,
      axiosConfig: input.axiosConfig
    }).deleteUserMeMfaAuthenticatorDisable_v4(input.data);
    callback && callback(response.data);
    return response.data;
  };
  return (0, import_react_query16.useMutation)({
    mutationKey: ["Iam.UsersV4Admin.UserMeMfaAuthenticatorDisable_v4" /* UserMeMfaAuthenticatorDisable_v4 */],
    mutationFn,
    ...options
  });
};
var useUsersV4AdminApi_UpdateUser_ByUserIdMutation_v4 = (sdk, options, callback) => {
  const mutationFn = async (input) => {
    const response = await UsersV4AdminApi(sdk, { coreConfig: input.coreConfig, axiosConfig: input.axiosConfig }).updateUser_ByUserId_v4(
      input.userId,
      input.data
    );
    callback && callback(response.data);
    return response.data;
  };
  return (0, import_react_query16.useMutation)({
    mutationKey: ["Iam.UsersV4Admin.User_ByUserId_v4" /* User_ByUserId_v4 */],
    mutationFn,
    ...options
  });
};
var useUsersV4AdminApi_GetInvitationHistories_ByNS_v4 = (sdk, input, options, callback) => {
  const queryFn = (sdk2, input2) => async () => {
    const response = await UsersV4AdminApi(sdk2, {
      coreConfig: input2.coreConfig,
      axiosConfig: input2.axiosConfig
    }).getInvitationHistories_ByNS_v4();
    callback && callback(response);
    return response.data;
  };
  return (0, import_react_query16.useQuery)({
    queryKey: ["Iam.UsersV4Admin.InvitationHistories_ByNS_v4" /* InvitationHistories_ByNS_v4 */, input],
    queryFn: queryFn(sdk, input),
    ...options
  });
};
var useUsersV4AdminApi_FetchUserBulkValidate_v4 = (sdk, input, options, callback) => {
  const queryFn = (sdk2, input2) => async () => {
    const response = await UsersV4AdminApi(sdk2, { coreConfig: input2.coreConfig, axiosConfig: input2.axiosConfig }).fetchUserBulkValidate_v4(
      input2.data
    );
    callback && callback(response);
    return response.data;
  };
  return (0, import_react_query16.useQuery)({
    queryKey: ["Iam.UsersV4Admin.UserBulkValidate_v4" /* UserBulkValidate_v4 */, input],
    queryFn: queryFn(sdk, input),
    ...options
  });
};
var useUsersV4AdminApi_UpdateEmail_ByUserIdMutation_v4 = (sdk, options, callback) => {
  const mutationFn = async (input) => {
    const response = await UsersV4AdminApi(sdk, { coreConfig: input.coreConfig, axiosConfig: input.axiosConfig }).updateEmail_ByUserId_v4(
      input.userId,
      input.data
    );
    callback && callback(response.data);
    return response.data;
  };
  return (0, import_react_query16.useMutation)({
    mutationKey: ["Iam.UsersV4Admin.Email_ByUserId_v4" /* Email_ByUserId_v4 */],
    mutationFn,
    ...options
  });
};
var useUsersV4AdminApi_DeleteRole_ByUserIdMutation_v4 = (sdk, options, callback) => {
  const mutationFn = async (input) => {
    const response = await UsersV4AdminApi(sdk, { coreConfig: input.coreConfig, axiosConfig: input.axiosConfig }).deleteRole_ByUserId_v4(
      input.userId,
      input.data
    );
    callback && callback(response.data);
    return response.data;
  };
  return (0, import_react_query16.useMutation)({
    mutationKey: ["Iam.UsersV4Admin.Role_ByUserId_v4" /* Role_ByUserId_v4 */],
    mutationFn,
    ...options
  });
};
var useUsersV4AdminApi_GetRoles_ByUserId_v4 = (sdk, input, options, callback) => {
  const queryFn = (sdk2, input2) => async () => {
    const response = await UsersV4AdminApi(sdk2, { coreConfig: input2.coreConfig, axiosConfig: input2.axiosConfig }).getRoles_ByUserId_v4(
      input2.userId
    );
    callback && callback(response);
    return response.data;
  };
  return (0, import_react_query16.useQuery)({
    queryKey: ["Iam.UsersV4Admin.Roles_ByUserId_v4" /* Roles_ByUserId_v4 */, input],
    queryFn: queryFn(sdk, input),
    ...options
  });
};
var useUsersV4AdminApi_UpdateRole_ByUserIdMutation_v4 = (sdk, options, callback) => {
  const mutationFn = async (input) => {
    const response = await UsersV4AdminApi(sdk, { coreConfig: input.coreConfig, axiosConfig: input.axiosConfig }).updateRole_ByUserId_v4(
      input.userId,
      input.data
    );
    callback && callback(response.data);
    return response.data;
  };
  return (0, import_react_query16.useMutation)({
    mutationKey: ["Iam.UsersV4Admin.Role_ByUserId_v4" /* Role_ByUserId_v4 */],
    mutationFn,
    ...options
  });
};
var useUsersV4AdminApi_UpdateRole_ByUserId_ByNSMutation_v4 = (sdk, options, callback) => {
  const mutationFn = async (input) => {
    const response = await UsersV4AdminApi(sdk, {
      coreConfig: input.coreConfig,
      axiosConfig: input.axiosConfig
    }).updateRole_ByUserId_ByNS_v4(input.userId, input.data);
    callback && callback(response.data);
    return response.data;
  };
  return (0, import_react_query16.useMutation)({
    mutationKey: ["Iam.UsersV4Admin.Role_ByUserId_ByNS_v4" /* Role_ByUserId_ByNS_v4 */],
    mutationFn,
    ...options
  });
};
var useUsersV4AdminApi_PatchUserBulkAccountTypeMutation_v4 = (sdk, options, callback) => {
  const mutationFn = async (input) => {
    const response = await UsersV4AdminApi(sdk, {
      coreConfig: input.coreConfig,
      axiosConfig: input.axiosConfig
    }).patchUserBulkAccountType_v4(input.data);
    callback && callback(response.data);
    return response.data;
  };
  return (0, import_react_query16.useMutation)({
    mutationKey: ["Iam.UsersV4Admin.UserBulkAccountType_v4" /* UserBulkAccountType_v4 */],
    mutationFn,
    ...options
  });
};
var useUsersV4AdminApi_GetInvitationHistoriesUsers_v4 = (sdk, input, options, callback) => {
  const queryFn = (sdk2, input2) => async () => {
    const response = await UsersV4AdminApi(sdk2, {
      coreConfig: input2.coreConfig,
      axiosConfig: input2.axiosConfig
    }).getInvitationHistoriesUsers_v4(input2.queryParams);
    callback && callback(response);
    return response.data;
  };
  return (0, import_react_query16.useQuery)({
    queryKey: ["Iam.UsersV4Admin.InvitationHistoriesUsers_v4" /* InvitationHistoriesUsers_v4 */, input],
    queryFn: queryFn(sdk, input),
    ...options
  });
};
var useUsersV4AdminApi_GetMfaStatus_ByUserId_v4 = (sdk, input, options, callback) => {
  const queryFn = (sdk2, input2) => async () => {
    const response = await UsersV4AdminApi(sdk2, { coreConfig: input2.coreConfig, axiosConfig: input2.axiosConfig }).getMfaStatus_ByUserId_v4(
      input2.userId
    );
    callback && callback(response);
    return response.data;
  };
  return (0, import_react_query16.useQuery)({
    queryKey: ["Iam.UsersV4Admin.MfaStatus_ByUserId_v4" /* MfaStatus_ByUserId_v4 */, input],
    queryFn: queryFn(sdk, input),
    ...options
  });
};
var useUsersV4AdminApi_DeleteMfaDisable_ByUserIdMutation_v4 = (sdk, options, callback) => {
  const mutationFn = async (input) => {
    const response = await UsersV4AdminApi(sdk, {
      coreConfig: input.coreConfig,
      axiosConfig: input.axiosConfig
    }).deleteMfaDisable_ByUserId_v4(input.userId, input.data);
    callback && callback(response.data);
    return response.data;
  };
  return (0, import_react_query16.useMutation)({
    mutationKey: ["Iam.UsersV4Admin.MfaDisable_ByUserId_v4" /* MfaDisable_ByUserId_v4 */],
    mutationFn,
    ...options
  });
};

// src/generated-public/queries/Bans.query.ts
var import_react_query17 = require("@tanstack/react-query");

// src/generated-public/BansApi.ts
var import_sdk34 = require("@accelbyte/sdk");

// src/generated-public/endpoints/Bans$.ts
var import_sdk33 = require("@accelbyte/sdk");

// src/generated-definitions/BanReasons.ts
var import_zod158 = require("zod");

// src/generated-definitions/BanReason.ts
var import_zod157 = require("zod");
var BanReason = import_zod157.z.object({ Description: import_zod157.z.string(), Reason: import_zod157.z.string() });

// src/generated-definitions/BanReasons.ts
var BanReasons = import_zod158.z.object({ Reasons: import_zod158.z.array(BanReason) });

// src/generated-definitions/Bans.ts
var import_zod160 = require("zod");

// src/generated-definitions/Ban.ts
var import_zod159 = require("zod");
var Ban = import_zod159.z.object({ Ban: import_zod159.z.string(), Description: import_zod159.z.string() });

// src/generated-definitions/Bans.ts
var Bans = import_zod160.z.object({ Bans: import_zod160.z.array(Ban) });

// src/generated-public/endpoints/Bans$.ts
var Bans$ = class {
  // @ts-ignore
  // prettier-ignore
  constructor(axiosInstance, namespace, useSchemaValidation = true) {
    this.axiosInstance = axiosInstance;
    this.namespace = namespace;
    this.useSchemaValidation = useSchemaValidation;
  }
  /**
   * @deprecated
   * ## The endpoint is going to be deprecated ### Endpoint migration guide - **Substitute endpoint: _/iam/v3/admin/bans [GET]_**
   */
  getBans() {
    const params = {};
    const url = "/iam/bans";
    const resultPromise = this.axiosInstance.get(url, { params });
    return import_sdk33.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, Bans, "Bans");
  }
  /**
   * @deprecated
   * ## The endpoint is going to be deprecated ### Endpoint migration guide - **Substitute endpoint: _/iam/v3/admin/bans/reasons [GET]_**
   */
  getBansReasons() {
    const params = {};
    const url = "/iam/bans/reasons";
    const resultPromise = this.axiosInstance.get(url, { params });
    return import_sdk33.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, BanReasons, "BanReasons");
  }
};

// src/generated-public/BansApi.ts
function BansApi(sdk, args) {
  const sdkAssembly = sdk.assembly();
  const namespace = args?.coreConfig?.namespace ?? sdkAssembly.coreConfig.namespace;
  const useSchemaValidation = args?.coreConfig?.useSchemaValidation ?? sdkAssembly.coreConfig.useSchemaValidation;
  let axiosInstance = sdkAssembly.axiosInstance;
  const requestConfigOverrides = args?.axiosConfig?.request;
  const baseURLOverride = args?.coreConfig?.baseURL;
  const interceptorsOverride = args?.axiosConfig?.interceptors ?? [];
  if (requestConfigOverrides || baseURLOverride || interceptorsOverride.length > 0) {
    const requestConfig = import_sdk34.ApiUtils.mergeAxiosConfigs(sdkAssembly.axiosInstance.defaults, {
      ...baseURLOverride ? { baseURL: baseURLOverride } : {},
      ...requestConfigOverrides
    });
    axiosInstance = import_sdk34.Network.create(requestConfig);
    for (const interceptor of interceptorsOverride) {
      if (interceptor.type === "request") {
        axiosInstance.interceptors.request.use(interceptor.onRequest, interceptor.onError);
      }
      if (interceptor.type === "response") {
        axiosInstance.interceptors.response.use(interceptor.onSuccess, interceptor.onError);
      }
    }
  }
  async function getBans() {
    const $ = new Bans$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getBans();
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getBansReasons() {
    const $ = new Bans$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getBansReasons();
    if (resp.error) throw resp.error;
    return resp.response;
  }
  return {
    /**
     * @deprecated
     * ## The endpoint is going to be deprecated ### Endpoint migration guide - **Substitute endpoint: _/iam/v3/admin/bans [GET]_**
     */
    getBans,
    /**
     * @deprecated
     * ## The endpoint is going to be deprecated ### Endpoint migration guide - **Substitute endpoint: _/iam/v3/admin/bans/reasons [GET]_**
     */
    getBansReasons
  };
}

// src/generated-public/queries/Bans.query.ts
var Key_Bans = /* @__PURE__ */ ((Key_Bans2) => {
  Key_Bans2["Bans"] = "Iam.Bans.Bans";
  Key_Bans2["BansReasons"] = "Iam.Bans.BansReasons";
  return Key_Bans2;
})(Key_Bans || {});
var useBansApi_GetBans = (sdk, input, options, callback) => {
  const queryFn = (sdk2, input2) => async () => {
    const response = await BansApi(sdk2, { coreConfig: input2.coreConfig, axiosConfig: input2.axiosConfig }).getBans();
    callback && callback(response);
    return response.data;
  };
  return (0, import_react_query17.useQuery)({
    queryKey: ["Iam.Bans.Bans" /* Bans */, input],
    queryFn: queryFn(sdk, input),
    ...options
  });
};
var useBansApi_GetBansReasons = (sdk, input, options, callback) => {
  const queryFn = (sdk2, input2) => async () => {
    const response = await BansApi(sdk2, { coreConfig: input2.coreConfig, axiosConfig: input2.axiosConfig }).getBansReasons();
    callback && callback(response);
    return response.data;
  };
  return (0, import_react_query17.useQuery)({
    queryKey: ["Iam.Bans.BansReasons" /* BansReasons */, input],
    queryFn: queryFn(sdk, input),
    ...options
  });
};

// src/generated-public/queries/Clients.query.ts
var import_react_query18 = require("@tanstack/react-query");

// src/generated-public/ClientsApi.ts
var import_sdk36 = require("@accelbyte/sdk");

// src/generated-public/endpoints/Clients$.ts
var import_sdk35 = require("@accelbyte/sdk");
var import_zod164 = require("zod");

// src/generated-definitions/ClientCreationResponse.ts
var import_zod161 = require("zod");
var ClientCreationResponse = import_zod161.z.object({
  ClientId: import_zod161.z.string(),
  ClientName: import_zod161.z.string(),
  ClientPermissions: import_zod161.z.array(Permission),
  Namespace: import_zod161.z.string(),
  RedirectUri: import_zod161.z.string(),
  TwoFactorEnabled: import_zod161.z.boolean()
});

// src/generated-definitions/ClientResponse.ts
var import_zod162 = require("zod");
var ClientResponse = import_zod162.z.object({
  ClientId: import_zod162.z.string(),
  ClientName: import_zod162.z.string(),
  ClientPermissions: import_zod162.z.array(Permission),
  CreatedAt: import_zod162.z.string(),
  Namespace: import_zod162.z.string(),
  RedirectUri: import_zod162.z.string(),
  TwoFactorEnabled: import_zod162.z.boolean(),
  modulePermissions: import_zod162.z.array(ClientModulePermission).nullish()
});

// src/generated-definitions/ClientResponseArray.ts
var import_zod163 = require("zod");
var ClientResponseArray = import_zod163.z.array(ClientResponse);

// src/generated-public/endpoints/Clients$.ts
var Clients$ = class {
  // @ts-ignore
  // prettier-ignore
  constructor(axiosInstance, namespace, useSchemaValidation = true) {
    this.axiosInstance = axiosInstance;
    this.namespace = namespace;
    this.useSchemaValidation = useSchemaValidation;
  }
  /**
   * @deprecated
   * ## The endpoint is going to be deprecated **Endpoint migration guide** - **Substitute endpoint: _/iam/v3/admin/namespaces/{namespace}/clients [GET]_**
   */
  getClients() {
    const params = {};
    const url = "/iam/clients";
    const resultPromise = this.axiosInstance.get(url, { params });
    return import_sdk35.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, ClientResponseArray, "ClientResponseArray");
  }
  /**
   * @deprecated
   * ## The endpoint is going to be deprecated **Endpoint migration guide** - **Substitute endpoint: _/iam/v3/admin/namespaces/{namespace}/clients [POST]_**
   */
  createClient(data) {
    const params = {};
    const url = "/iam/clients";
    const resultPromise = this.axiosInstance.post(url, data, { params });
    return import_sdk35.Validate.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      ClientCreationResponse,
      "ClientCreationResponse"
    );
  }
  /**
   * @deprecated
   * ## The endpoint is going to be deprecated **Endpoint migration guide** - **Substitute endpoint: _/iam/v3/admin/namespaces/{namespace}/clients/{clientId} [DELETE]_**
   */
  deleteClient_ByClientId(clientId) {
    const params = {};
    const url = "/iam/clients/{clientId}".replace("{clientId}", clientId);
    const resultPromise = this.axiosInstance.delete(url, { params });
    return import_sdk35.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, import_zod164.z.unknown(), "z.unknown()");
  }
  /**
   * @deprecated
   * ## The endpoint is going to be deprecated **Endpoint migration guide** - **Substitute endpoint: _/iam/v3/admin/namespaces/{namespace}/clients/{clientId} [GET]_**
   */
  getClient_ByClientId(clientId) {
    const params = {};
    const url = "/iam/clients/{clientId}".replace("{clientId}", clientId);
    const resultPromise = this.axiosInstance.get(url, { params });
    return import_sdk35.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, ClientResponse, "ClientResponse");
  }
  /**
   * @deprecated
   * ## The endpoint is going to be deprecated **Endpoint migration guide** - **Substitute endpoint: _/iam/v3/admin/namespaces/{namespace}/clients/{clientId} [PATCH]_**
   */
  updateClient_ByClientId(clientId, data) {
    const params = {};
    const url = "/iam/clients/{clientId}".replace("{clientId}", clientId);
    const resultPromise = this.axiosInstance.put(url, data, { params });
    return import_sdk35.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, ClientResponse, "ClientResponse");
  }
  /**
   * @deprecated
   * ## The endpoint is going to be deprecated **Endpoint migration guide** - **Substitute endpoint: _/iam/v3/admin/namespaces/{namespace}/{clientId}/secret [PUT]_**
   */
  updateSecret_ByClientId(clientId, data) {
    const params = {};
    const url = "/iam/clients/{clientId}/secret".replace("{clientId}", clientId);
    const resultPromise = this.axiosInstance.put(url, data, { params });
    return import_sdk35.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, import_zod164.z.unknown(), "z.unknown()");
  }
  /**
   * @deprecated
   * ## The endpoint is going to be deprecated **Endpoint migration guide** - **Substitute endpoint: _/iam/v3/admin/namespaces/{namespace}/clients [GET]_**
   */
  getClients_ByNS() {
    const params = {};
    const url = "/iam/namespaces/{namespace}/clients".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.get(url, { params });
    return import_sdk35.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, ClientResponseArray, "ClientResponseArray");
  }
  /**
   * @deprecated
   * ## The endpoint is going to be deprecated **Endpoint migration guide** - **Substitute endpoint: _/v3/admin/namespaces/{namespace}/clients [POST]_**
   */
  createClient_ByNS(data) {
    const params = {};
    const url = "/iam/namespaces/{namespace}/clients".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.post(url, data, { params });
    return import_sdk35.Validate.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      ClientCreationResponse,
      "ClientCreationResponse"
    );
  }
  /**
   * @deprecated
   * ## The endpoint is going to be deprecated **Endpoint migration guide** - **Substitute endpoint: _iam/v3/admin/namespaces/{namespace}/clients/{clientId}/permissions [PUT]_**
   */
  updateClientpermission_ByClientId(clientId, data) {
    const params = {};
    const url = "/iam/clients/{clientId}/clientpermissions".replace("{clientId}", clientId);
    const resultPromise = this.axiosInstance.post(url, data, { params });
    return import_sdk35.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, import_zod164.z.unknown(), "z.unknown()");
  }
  /**
   * @deprecated
   * ## The endpoint is going to be deprecated **Endpoint migration guide** - **Substitute endpoint: _/iam/v3/admin/namespaces/{namespace}/clients/{clientId} [DELETE]_**
   */
  deleteClient_ByClientId_ByNS(clientId) {
    const params = {};
    const url = "/iam/namespaces/{namespace}/clients/{clientId}".replace("{namespace}", this.namespace).replace("{clientId}", clientId);
    const resultPromise = this.axiosInstance.delete(url, { params });
    return import_sdk35.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, import_zod164.z.unknown(), "z.unknown()");
  }
  /**
   * @deprecated
   * ## The endpoint is going to be deprecated **Endpoint migration guide** - **Substitute endpoint: _/iam/v3/admin/namespaces/{namespace}/clients/{clientId}/permissions/{resource}/{action} [DELETE]_**
   */
  deleteClientpermission_ByClientId_ByResource_ByAction(clientId, resource, action) {
    const params = {};
    const url = "/iam/clients/{clientId}/clientpermissions/{resource}/{action}".replace("{clientId}", clientId).replace("{resource}", resource).replace("{action}", String(action));
    const resultPromise = this.axiosInstance.delete(url, { params });
    return import_sdk35.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, import_zod164.z.unknown(), "z.unknown()");
  }
  /**
   * @deprecated
   * ## The endpoint is going to be deprecated **Endpoint migration guide** - **Substitute endpoint: _/iam/v3/admin/namespaces/{namespace}/clients/{clientId}/permissions [POST]_**
   */
  updateClientpermission_ByClientId_ByResource_ByAction(clientId, resource, action) {
    const params = {};
    const url = "/iam/clients/{clientId}/clientpermissions/{resource}/{action}".replace("{clientId}", clientId).replace("{resource}", resource).replace("{action}", String(action));
    const resultPromise = this.axiosInstance.post(url, null, { params });
    return import_sdk35.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, import_zod164.z.unknown(), "z.unknown()");
  }
};

// src/generated-public/ClientsApi.ts
function ClientsApi(sdk, args) {
  const sdkAssembly = sdk.assembly();
  const namespace = args?.coreConfig?.namespace ?? sdkAssembly.coreConfig.namespace;
  const useSchemaValidation = args?.coreConfig?.useSchemaValidation ?? sdkAssembly.coreConfig.useSchemaValidation;
  let axiosInstance = sdkAssembly.axiosInstance;
  const requestConfigOverrides = args?.axiosConfig?.request;
  const baseURLOverride = args?.coreConfig?.baseURL;
  const interceptorsOverride = args?.axiosConfig?.interceptors ?? [];
  if (requestConfigOverrides || baseURLOverride || interceptorsOverride.length > 0) {
    const requestConfig = import_sdk36.ApiUtils.mergeAxiosConfigs(sdkAssembly.axiosInstance.defaults, {
      ...baseURLOverride ? { baseURL: baseURLOverride } : {},
      ...requestConfigOverrides
    });
    axiosInstance = import_sdk36.Network.create(requestConfig);
    for (const interceptor of interceptorsOverride) {
      if (interceptor.type === "request") {
        axiosInstance.interceptors.request.use(interceptor.onRequest, interceptor.onError);
      }
      if (interceptor.type === "response") {
        axiosInstance.interceptors.response.use(interceptor.onSuccess, interceptor.onError);
      }
    }
  }
  async function getClients() {
    const $ = new Clients$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getClients();
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function createClient(data) {
    const $ = new Clients$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.createClient(data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function deleteClient_ByClientId(clientId) {
    const $ = new Clients$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.deleteClient_ByClientId(clientId);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getClient_ByClientId(clientId) {
    const $ = new Clients$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getClient_ByClientId(clientId);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function updateClient_ByClientId(clientId, data) {
    const $ = new Clients$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.updateClient_ByClientId(clientId, data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function updateSecret_ByClientId(clientId, data) {
    const $ = new Clients$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.updateSecret_ByClientId(clientId, data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getClients_ByNS() {
    const $ = new Clients$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getClients_ByNS();
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function createClient_ByNS(data) {
    const $ = new Clients$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.createClient_ByNS(data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function updateClientpermission_ByClientId(clientId, data) {
    const $ = new Clients$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.updateClientpermission_ByClientId(clientId, data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function deleteClient_ByClientId_ByNS(clientId) {
    const $ = new Clients$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.deleteClient_ByClientId_ByNS(clientId);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function deleteClientpermission_ByClientId_ByResource_ByAction(clientId, resource, action) {
    const $ = new Clients$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.deleteClientpermission_ByClientId_ByResource_ByAction(clientId, resource, action);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function updateClientpermission_ByClientId_ByResource_ByAction(clientId, resource, action) {
    const $ = new Clients$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.updateClientpermission_ByClientId_ByResource_ByAction(clientId, resource, action);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  return {
    /**
     * @deprecated
     * ## The endpoint is going to be deprecated **Endpoint migration guide** - **Substitute endpoint: _/iam/v3/admin/namespaces/{namespace}/clients [GET]_**
     */
    getClients,
    /**
     * @deprecated
     * ## The endpoint is going to be deprecated **Endpoint migration guide** - **Substitute endpoint: _/iam/v3/admin/namespaces/{namespace}/clients [POST]_**
     */
    createClient,
    /**
     * @deprecated
     * ## The endpoint is going to be deprecated **Endpoint migration guide** - **Substitute endpoint: _/iam/v3/admin/namespaces/{namespace}/clients/{clientId} [DELETE]_**
     */
    deleteClient_ByClientId,
    /**
     * @deprecated
     * ## The endpoint is going to be deprecated **Endpoint migration guide** - **Substitute endpoint: _/iam/v3/admin/namespaces/{namespace}/clients/{clientId} [GET]_**
     */
    getClient_ByClientId,
    /**
     * @deprecated
     * ## The endpoint is going to be deprecated **Endpoint migration guide** - **Substitute endpoint: _/iam/v3/admin/namespaces/{namespace}/clients/{clientId} [PATCH]_**
     */
    updateClient_ByClientId,
    /**
     * @deprecated
     * ## The endpoint is going to be deprecated **Endpoint migration guide** - **Substitute endpoint: _/iam/v3/admin/namespaces/{namespace}/{clientId}/secret [PUT]_**
     */
    updateSecret_ByClientId,
    /**
     * @deprecated
     * ## The endpoint is going to be deprecated **Endpoint migration guide** - **Substitute endpoint: _/iam/v3/admin/namespaces/{namespace}/clients [GET]_**
     */
    getClients_ByNS,
    /**
     * @deprecated
     * ## The endpoint is going to be deprecated **Endpoint migration guide** - **Substitute endpoint: _/v3/admin/namespaces/{namespace}/clients [POST]_**
     */
    createClient_ByNS,
    /**
     * @deprecated
     * ## The endpoint is going to be deprecated **Endpoint migration guide** - **Substitute endpoint: _iam/v3/admin/namespaces/{namespace}/clients/{clientId}/permissions [PUT]_**
     */
    updateClientpermission_ByClientId,
    /**
     * @deprecated
     * ## The endpoint is going to be deprecated **Endpoint migration guide** - **Substitute endpoint: _/iam/v3/admin/namespaces/{namespace}/clients/{clientId} [DELETE]_**
     */
    deleteClient_ByClientId_ByNS,
    /**
     * @deprecated
     * ## The endpoint is going to be deprecated **Endpoint migration guide** - **Substitute endpoint: _/iam/v3/admin/namespaces/{namespace}/clients/{clientId}/permissions/{resource}/{action} [DELETE]_**
     */
    deleteClientpermission_ByClientId_ByResource_ByAction,
    /**
     * @deprecated
     * ## The endpoint is going to be deprecated **Endpoint migration guide** - **Substitute endpoint: _/iam/v3/admin/namespaces/{namespace}/clients/{clientId}/permissions [POST]_**
     */
    updateClientpermission_ByClientId_ByResource_ByAction
  };
}

// src/generated-public/queries/Clients.query.ts
var Key_Clients = /* @__PURE__ */ ((Key_Clients2) => {
  Key_Clients2["Clients"] = "Iam.Clients.Clients";
  Key_Clients2["Client"] = "Iam.Clients.Client";
  Key_Clients2["Client_ByClientId"] = "Iam.Clients.Client_ByClientId";
  Key_Clients2["Secret_ByClientId"] = "Iam.Clients.Secret_ByClientId";
  Key_Clients2["Clients_ByNS"] = "Iam.Clients.Clients_ByNS";
  Key_Clients2["Client_ByNS"] = "Iam.Clients.Client_ByNS";
  Key_Clients2["Clientpermission_ByClientId"] = "Iam.Clients.Clientpermission_ByClientId";
  Key_Clients2["Client_ByClientId_ByNS"] = "Iam.Clients.Client_ByClientId_ByNS";
  Key_Clients2["Clientpermission_ByClientId_ByResource_ByAction"] = "Iam.Clients.Clientpermission_ByClientId_ByResource_ByAction";
  return Key_Clients2;
})(Key_Clients || {});
var useClientsApi_GetClients = (sdk, input, options, callback) => {
  const queryFn = (sdk2, input2) => async () => {
    const response = await ClientsApi(sdk2, { coreConfig: input2.coreConfig, axiosConfig: input2.axiosConfig }).getClients();
    callback && callback(response);
    return response.data;
  };
  return (0, import_react_query18.useQuery)({
    queryKey: ["Iam.Clients.Clients" /* Clients */, input],
    queryFn: queryFn(sdk, input),
    ...options
  });
};
var useClientsApi_CreateClientMutation = (sdk, options, callback) => {
  const mutationFn = async (input) => {
    const response = await ClientsApi(sdk, { coreConfig: input.coreConfig, axiosConfig: input.axiosConfig }).createClient(input.data);
    callback && callback(response.data);
    return response.data;
  };
  return (0, import_react_query18.useMutation)({
    mutationKey: ["Iam.Clients.Client" /* Client */],
    mutationFn,
    ...options
  });
};
var useClientsApi_DeleteClient_ByClientIdMutation = (sdk, options, callback) => {
  const mutationFn = async (input) => {
    const response = await ClientsApi(sdk, { coreConfig: input.coreConfig, axiosConfig: input.axiosConfig }).deleteClient_ByClientId(
      input.clientId
    );
    callback && callback(response.data);
    return response.data;
  };
  return (0, import_react_query18.useMutation)({
    mutationKey: ["Iam.Clients.Client_ByClientId" /* Client_ByClientId */],
    mutationFn,
    ...options
  });
};
var useClientsApi_GetClient_ByClientId = (sdk, input, options, callback) => {
  const queryFn = (sdk2, input2) => async () => {
    const response = await ClientsApi(sdk2, { coreConfig: input2.coreConfig, axiosConfig: input2.axiosConfig }).getClient_ByClientId(
      input2.clientId
    );
    callback && callback(response);
    return response.data;
  };
  return (0, import_react_query18.useQuery)({
    queryKey: ["Iam.Clients.Client_ByClientId" /* Client_ByClientId */, input],
    queryFn: queryFn(sdk, input),
    ...options
  });
};
var useClientsApi_UpdateClient_ByClientIdMutation = (sdk, options, callback) => {
  const mutationFn = async (input) => {
    const response = await ClientsApi(sdk, { coreConfig: input.coreConfig, axiosConfig: input.axiosConfig }).updateClient_ByClientId(
      input.clientId,
      input.data
    );
    callback && callback(response.data);
    return response.data;
  };
  return (0, import_react_query18.useMutation)({
    mutationKey: ["Iam.Clients.Client_ByClientId" /* Client_ByClientId */],
    mutationFn,
    ...options
  });
};
var useClientsApi_UpdateSecret_ByClientIdMutation = (sdk, options, callback) => {
  const mutationFn = async (input) => {
    const response = await ClientsApi(sdk, { coreConfig: input.coreConfig, axiosConfig: input.axiosConfig }).updateSecret_ByClientId(
      input.clientId,
      input.data
    );
    callback && callback(response.data);
    return response.data;
  };
  return (0, import_react_query18.useMutation)({
    mutationKey: ["Iam.Clients.Secret_ByClientId" /* Secret_ByClientId */],
    mutationFn,
    ...options
  });
};
var useClientsApi_GetClients_ByNS = (sdk, input, options, callback) => {
  const queryFn = (sdk2, input2) => async () => {
    const response = await ClientsApi(sdk2, { coreConfig: input2.coreConfig, axiosConfig: input2.axiosConfig }).getClients_ByNS();
    callback && callback(response);
    return response.data;
  };
  return (0, import_react_query18.useQuery)({
    queryKey: ["Iam.Clients.Clients_ByNS" /* Clients_ByNS */, input],
    queryFn: queryFn(sdk, input),
    ...options
  });
};
var useClientsApi_CreateClient_ByNSMutation = (sdk, options, callback) => {
  const mutationFn = async (input) => {
    const response = await ClientsApi(sdk, { coreConfig: input.coreConfig, axiosConfig: input.axiosConfig }).createClient_ByNS(input.data);
    callback && callback(response.data);
    return response.data;
  };
  return (0, import_react_query18.useMutation)({
    mutationKey: ["Iam.Clients.Client_ByNS" /* Client_ByNS */],
    mutationFn,
    ...options
  });
};
var useClientsApi_UpdateClientpermission_ByClientIdMutation = (sdk, options, callback) => {
  const mutationFn = async (input) => {
    const response = await ClientsApi(sdk, {
      coreConfig: input.coreConfig,
      axiosConfig: input.axiosConfig
    }).updateClientpermission_ByClientId(input.clientId, input.data);
    callback && callback(response.data);
    return response.data;
  };
  return (0, import_react_query18.useMutation)({
    mutationKey: ["Iam.Clients.Clientpermission_ByClientId" /* Clientpermission_ByClientId */],
    mutationFn,
    ...options
  });
};
var useClientsApi_DeleteClient_ByClientId_ByNSMutation = (sdk, options, callback) => {
  const mutationFn = async (input) => {
    const response = await ClientsApi(sdk, { coreConfig: input.coreConfig, axiosConfig: input.axiosConfig }).deleteClient_ByClientId_ByNS(
      input.clientId
    );
    callback && callback(response.data);
    return response.data;
  };
  return (0, import_react_query18.useMutation)({
    mutationKey: ["Iam.Clients.Client_ByClientId_ByNS" /* Client_ByClientId_ByNS */],
    mutationFn,
    ...options
  });
};
var useClientsApi_DeleteClientpermission_ByClientId_ByResource_ByActionMutation = (sdk, options, callback) => {
  const mutationFn = async (input) => {
    const response = await ClientsApi(sdk, {
      coreConfig: input.coreConfig,
      axiosConfig: input.axiosConfig
    }).deleteClientpermission_ByClientId_ByResource_ByAction(input.clientId, input.resource, input.action);
    callback && callback(response.data);
    return response.data;
  };
  return (0, import_react_query18.useMutation)({
    mutationKey: ["Iam.Clients.Clientpermission_ByClientId_ByResource_ByAction" /* Clientpermission_ByClientId_ByResource_ByAction */],
    mutationFn,
    ...options
  });
};
var useClientsApi_UpdateClientpermission_ByClientId_ByResource_ByActionMutation = (sdk, options, callback) => {
  const mutationFn = async (input) => {
    const response = await ClientsApi(sdk, {
      coreConfig: input.coreConfig,
      axiosConfig: input.axiosConfig
    }).updateClientpermission_ByClientId_ByResource_ByAction(input.clientId, input.resource, input.action);
    callback && callback(response.data);
    return response.data;
  };
  return (0, import_react_query18.useMutation)({
    mutationKey: ["Iam.Clients.Clientpermission_ByClientId_ByResource_ByAction" /* Clientpermission_ByClientId_ByResource_ByAction */],
    mutationFn,
    ...options
  });
};

// src/generated-public/queries/Config.query.ts
var import_react_query19 = require("@tanstack/react-query");

// src/generated-public/ConfigApi.ts
var import_sdk38 = require("@accelbyte/sdk");

// src/generated-public/endpoints/Config$.ts
var import_sdk37 = require("@accelbyte/sdk");
var Config$ = class {
  // @ts-ignore
  // prettier-ignore
  constructor(axiosInstance, namespace, useSchemaValidation = true) {
    this.axiosInstance = axiosInstance;
    this.namespace = namespace;
    this.useSchemaValidation = useSchemaValidation;
  }
  /**
   * This endpoint return the value of config key. The namespace should be publisher namespace or studio namespace. Note: this endpoint does not need any authorization. **Supported config key:** * uniqueDisplayNameEnabled * usernameDisabled * mandatoryEmailVerificationEnabled
   */
  getConfig_ByConfigKey_v3(configKey) {
    const params = {};
    const url = "/iam/v3/public/namespaces/{namespace}/config/{configKey}".replace("{namespace}", this.namespace).replace("{configKey}", configKey);
    const resultPromise = this.axiosInstance.get(url, { params });
    return import_sdk37.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, ConfigValueResponseV3, "ConfigValueResponseV3");
  }
};

// src/generated-public/ConfigApi.ts
function ConfigApi(sdk, args) {
  const sdkAssembly = sdk.assembly();
  const namespace = args?.coreConfig?.namespace ?? sdkAssembly.coreConfig.namespace;
  const useSchemaValidation = args?.coreConfig?.useSchemaValidation ?? sdkAssembly.coreConfig.useSchemaValidation;
  let axiosInstance = sdkAssembly.axiosInstance;
  const requestConfigOverrides = args?.axiosConfig?.request;
  const baseURLOverride = args?.coreConfig?.baseURL;
  const interceptorsOverride = args?.axiosConfig?.interceptors ?? [];
  if (requestConfigOverrides || baseURLOverride || interceptorsOverride.length > 0) {
    const requestConfig = import_sdk38.ApiUtils.mergeAxiosConfigs(sdkAssembly.axiosInstance.defaults, {
      ...baseURLOverride ? { baseURL: baseURLOverride } : {},
      ...requestConfigOverrides
    });
    axiosInstance = import_sdk38.Network.create(requestConfig);
    for (const interceptor of interceptorsOverride) {
      if (interceptor.type === "request") {
        axiosInstance.interceptors.request.use(interceptor.onRequest, interceptor.onError);
      }
      if (interceptor.type === "response") {
        axiosInstance.interceptors.response.use(interceptor.onSuccess, interceptor.onError);
      }
    }
  }
  async function getConfig_ByConfigKey_v3(configKey) {
    const $ = new Config$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getConfig_ByConfigKey_v3(configKey);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  return {
    /**
     * This endpoint return the value of config key. The namespace should be publisher namespace or studio namespace. Note: this endpoint does not need any authorization. **Supported config key:** * uniqueDisplayNameEnabled * usernameDisabled * mandatoryEmailVerificationEnabled
     */
    getConfig_ByConfigKey_v3
  };
}

// src/generated-public/queries/Config.query.ts
var Key_Config = /* @__PURE__ */ ((Key_Config2) => {
  Key_Config2["Config_ByConfigKey_v3"] = "Iam.Config.Config_ByConfigKey_v3";
  return Key_Config2;
})(Key_Config || {});
var useConfigApi_GetConfig_ByConfigKey_v3 = (sdk, input, options, callback) => {
  const queryFn = (sdk2, input2) => async () => {
    const response = await ConfigApi(sdk2, { coreConfig: input2.coreConfig, axiosConfig: input2.axiosConfig }).getConfig_ByConfigKey_v3(
      input2.configKey
    );
    callback && callback(response);
    return response.data;
  };
  return (0, import_react_query19.useQuery)({
    queryKey: ["Iam.Config.Config_ByConfigKey_v3" /* Config_ByConfigKey_v3 */, input],
    queryFn: queryFn(sdk, input),
    ...options
  });
};

// src/generated-public/queries/Country.query.ts
var import_react_query20 = require("@tanstack/react-query");

// src/generated-public/CountryApi.ts
var import_sdk40 = require("@accelbyte/sdk");

// src/generated-public/endpoints/Country$.ts
var import_sdk39 = require("@accelbyte/sdk");
var Country$ = class {
  // @ts-ignore
  // prettier-ignore
  constructor(axiosInstance, namespace, useSchemaValidation = true) {
    this.axiosInstance = axiosInstance;
    this.namespace = namespace;
    this.useSchemaValidation = useSchemaValidation;
  }
  /**
   * Public get country list, will filter out countries in black list
   */
  getCountries_v3() {
    const params = {};
    const url = "/iam/v3/public/namespaces/{namespace}/countries".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.get(url, { params });
    return import_sdk39.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, CountryResponseArray, "CountryResponseArray");
  }
};

// src/generated-public/CountryApi.ts
function CountryApi(sdk, args) {
  const sdkAssembly = sdk.assembly();
  const namespace = args?.coreConfig?.namespace ?? sdkAssembly.coreConfig.namespace;
  const useSchemaValidation = args?.coreConfig?.useSchemaValidation ?? sdkAssembly.coreConfig.useSchemaValidation;
  let axiosInstance = sdkAssembly.axiosInstance;
  const requestConfigOverrides = args?.axiosConfig?.request;
  const baseURLOverride = args?.coreConfig?.baseURL;
  const interceptorsOverride = args?.axiosConfig?.interceptors ?? [];
  if (requestConfigOverrides || baseURLOverride || interceptorsOverride.length > 0) {
    const requestConfig = import_sdk40.ApiUtils.mergeAxiosConfigs(sdkAssembly.axiosInstance.defaults, {
      ...baseURLOverride ? { baseURL: baseURLOverride } : {},
      ...requestConfigOverrides
    });
    axiosInstance = import_sdk40.Network.create(requestConfig);
    for (const interceptor of interceptorsOverride) {
      if (interceptor.type === "request") {
        axiosInstance.interceptors.request.use(interceptor.onRequest, interceptor.onError);
      }
      if (interceptor.type === "response") {
        axiosInstance.interceptors.response.use(interceptor.onSuccess, interceptor.onError);
      }
    }
  }
  async function getCountries_v3() {
    const $ = new Country$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getCountries_v3();
    if (resp.error) throw resp.error;
    return resp.response;
  }
  return {
    /**
     * Public get country list, will filter out countries in black list
     */
    getCountries_v3
  };
}

// src/generated-public/queries/Country.query.ts
var Key_Country = /* @__PURE__ */ ((Key_Country2) => {
  Key_Country2["Countries_v3"] = "Iam.Country.Countries_v3";
  return Key_Country2;
})(Key_Country || {});
var useCountryApi_GetCountries_v3 = (sdk, input, options, callback) => {
  const queryFn = (sdk2, input2) => async () => {
    const response = await CountryApi(sdk2, { coreConfig: input2.coreConfig, axiosConfig: input2.axiosConfig }).getCountries_v3();
    callback && callback(response);
    return response.data;
  };
  return (0, import_react_query20.useQuery)({
    queryKey: ["Iam.Country.Countries_v3" /* Countries_v3 */, input],
    queryFn: queryFn(sdk, input),
    ...options
  });
};

// src/generated-public/queries/InputValidations.query.ts
var import_react_query21 = require("@tanstack/react-query");

// src/generated-public/InputValidationsApi.ts
var import_sdk42 = require("@accelbyte/sdk");

// src/generated-public/endpoints/InputValidations$.ts
var import_sdk41 = require("@accelbyte/sdk");

// src/generated-definitions/InputValidationConfigVersion.ts
var import_zod165 = require("zod");
var InputValidationConfigVersion = import_zod165.z.object({
  allowAllSpecialCharacters: import_zod165.z.boolean(),
  allowDigit: import_zod165.z.boolean(),
  allowLetter: import_zod165.z.boolean(),
  allowSpace: import_zod165.z.boolean(),
  allowUnicode: import_zod165.z.boolean(),
  avatarConfig: AvatarConfig.nullish(),
  blockedWord: import_zod165.z.array(import_zod165.z.string()),
  isCustomRegex: import_zod165.z.boolean(),
  letterCase: import_zod165.z.string(),
  maxLength: import_zod165.z.number().int(),
  maxRepeatingAlphaNum: import_zod165.z.number().int(),
  maxRepeatingSpecialCharacter: import_zod165.z.number().int(),
  minCharType: import_zod165.z.number().int(),
  minLength: import_zod165.z.number().int(),
  profanityFilter: import_zod165.z.string().nullish(),
  regex: import_zod165.z.string(),
  specialCharacterLocation: import_zod165.z.string(),
  specialCharacters: import_zod165.z.array(import_zod165.z.string()),
  version: import_zod165.z.number().int()
});

// src/generated-definitions/InputValidationsPublicResponse.ts
var import_zod168 = require("zod");

// src/generated-definitions/InputValidationDataPublic.ts
var import_zod167 = require("zod");

// src/generated-definitions/ValidationDetailPublic.ts
var import_zod166 = require("zod");
var ValidationDetailPublic = import_zod166.z.object({
  allowAllSpecialCharacters: import_zod166.z.boolean(),
  allowDigit: import_zod166.z.boolean(),
  allowLetter: import_zod166.z.boolean(),
  allowSpace: import_zod166.z.boolean(),
  allowUnicode: import_zod166.z.boolean(),
  avatarConfig: AvatarConfig.nullish(),
  blockedWord: import_zod166.z.array(import_zod166.z.string()),
  description: InputValidationDescription,
  isCustomRegex: import_zod166.z.boolean(),
  letterCase: import_zod166.z.string(),
  maxLength: import_zod166.z.number().int(),
  maxRepeatingAlphaNum: import_zod166.z.number().int(),
  maxRepeatingSpecialCharacter: import_zod166.z.number().int(),
  minCharType: import_zod166.z.number().int(),
  minLength: import_zod166.z.number().int(),
  profanityFilter: import_zod166.z.string().nullish(),
  regex: import_zod166.z.string(),
  specialCharacterLocation: import_zod166.z.string(),
  specialCharacters: import_zod166.z.array(import_zod166.z.string())
});

// src/generated-definitions/InputValidationDataPublic.ts
var InputValidationDataPublic = import_zod167.z.object({ field: import_zod167.z.string(), validation: ValidationDetailPublic });

// src/generated-definitions/InputValidationsPublicResponse.ts
var InputValidationsPublicResponse = import_zod168.z.object({ data: import_zod168.z.array(InputValidationDataPublic), version: import_zod168.z.number().int() });

// src/generated-public/endpoints/InputValidations$.ts
var InputValidations$ = class {
  // @ts-ignore
  // prettier-ignore
  constructor(axiosInstance, namespace, useSchemaValidation = true) {
    this.axiosInstance = axiosInstance;
    this.namespace = namespace;
    this.useSchemaValidation = useSchemaValidation;
  }
  /**
   * No role required This endpoint is to get list of input validation configuration. &lt;code&gt;regex&lt;/code&gt; parameter will be returned if &lt;code&gt;isCustomRegex&lt;/code&gt; is true. Otherwise, it will be empty.
   */
  getInputValidations_v3(queryParams) {
    const params = { defaultOnEmpty: true, ...queryParams };
    const url = "/iam/v3/public/inputValidations";
    const resultPromise = this.axiosInstance.get(url, { params });
    return import_sdk41.Validate.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      InputValidationsPublicResponse,
      "InputValidationsPublicResponse"
    );
  }
  /**
   * This endpoint is to get input validation configuration by field.
   */
  getInputValidation_ByField_v3(field) {
    const params = {};
    const url = "/iam/v3/public/inputValidations/{field}".replace("{field}", field);
    const resultPromise = this.axiosInstance.get(url, { params });
    return import_sdk41.Validate.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      InputValidationConfigVersion,
      "InputValidationConfigVersion"
    );
  }
};

// src/generated-public/InputValidationsApi.ts
function InputValidationsApi(sdk, args) {
  const sdkAssembly = sdk.assembly();
  const namespace = args?.coreConfig?.namespace ?? sdkAssembly.coreConfig.namespace;
  const useSchemaValidation = args?.coreConfig?.useSchemaValidation ?? sdkAssembly.coreConfig.useSchemaValidation;
  let axiosInstance = sdkAssembly.axiosInstance;
  const requestConfigOverrides = args?.axiosConfig?.request;
  const baseURLOverride = args?.coreConfig?.baseURL;
  const interceptorsOverride = args?.axiosConfig?.interceptors ?? [];
  if (requestConfigOverrides || baseURLOverride || interceptorsOverride.length > 0) {
    const requestConfig = import_sdk42.ApiUtils.mergeAxiosConfigs(sdkAssembly.axiosInstance.defaults, {
      ...baseURLOverride ? { baseURL: baseURLOverride } : {},
      ...requestConfigOverrides
    });
    axiosInstance = import_sdk42.Network.create(requestConfig);
    for (const interceptor of interceptorsOverride) {
      if (interceptor.type === "request") {
        axiosInstance.interceptors.request.use(interceptor.onRequest, interceptor.onError);
      }
      if (interceptor.type === "response") {
        axiosInstance.interceptors.response.use(interceptor.onSuccess, interceptor.onError);
      }
    }
  }
  async function getInputValidations_v3(queryParams) {
    const $ = new InputValidations$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getInputValidations_v3(queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getInputValidation_ByField_v3(field) {
    const $ = new InputValidations$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getInputValidation_ByField_v3(field);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  return {
    /**
     * No role required This endpoint is to get list of input validation configuration. &lt;code&gt;regex&lt;/code&gt; parameter will be returned if &lt;code&gt;isCustomRegex&lt;/code&gt; is true. Otherwise, it will be empty.
     */
    getInputValidations_v3,
    /**
     * This endpoint is to get input validation configuration by field.
     */
    getInputValidation_ByField_v3
  };
}

// src/generated-public/queries/InputValidations.query.ts
var Key_InputValidations = /* @__PURE__ */ ((Key_InputValidations2) => {
  Key_InputValidations2["InputValidations_v3"] = "Iam.InputValidations.InputValidations_v3";
  Key_InputValidations2["InputValidation_ByField_v3"] = "Iam.InputValidations.InputValidation_ByField_v3";
  return Key_InputValidations2;
})(Key_InputValidations || {});
var useInputValidationsApi_GetInputValidations_v3 = (sdk, input, options, callback) => {
  const queryFn = (sdk2, input2) => async () => {
    const response = await InputValidationsApi(sdk2, {
      coreConfig: input2.coreConfig,
      axiosConfig: input2.axiosConfig
    }).getInputValidations_v3(input2.queryParams);
    callback && callback(response);
    return response.data;
  };
  return (0, import_react_query21.useQuery)({
    queryKey: ["Iam.InputValidations.InputValidations_v3" /* InputValidations_v3 */, input],
    queryFn: queryFn(sdk, input),
    ...options
  });
};
var useInputValidationsApi_GetInputValidation_ByField_v3 = (sdk, input, options, callback) => {
  const queryFn = (sdk2, input2) => async () => {
    const response = await InputValidationsApi(sdk2, {
      coreConfig: input2.coreConfig,
      axiosConfig: input2.axiosConfig
    }).getInputValidation_ByField_v3(input2.field);
    callback && callback(response);
    return response.data;
  };
  return (0, import_react_query21.useQuery)({
    queryKey: ["Iam.InputValidations.InputValidation_ByField_v3" /* InputValidation_ByField_v3 */, input],
    queryFn: queryFn(sdk, input),
    ...options
  });
};

// src/generated-public/queries/OAuth.query.ts
var import_react_query22 = require("@tanstack/react-query");

// src/generated-public/OAuthApi.ts
var import_sdk44 = require("@accelbyte/sdk");

// src/generated-public/endpoints/OAuth$.ts
var import_sdk43 = require("@accelbyte/sdk");
var import_zod176 = require("zod");

// src/generated-definitions/JwkSet.ts
var import_zod170 = require("zod");

// src/generated-definitions/JwkKey.ts
var import_zod169 = require("zod");
var JwkKey = import_zod169.z.object({
  alg: import_zod169.z.string().nullish(),
  e: import_zod169.z.string().nullish(),
  kid: import_zod169.z.string().nullish(),
  kty: import_zod169.z.string(),
  n: import_zod169.z.string().nullish(),
  use: import_zod169.z.string().nullish()
});

// src/generated-definitions/JwkSet.ts
var JwkSet = import_zod170.z.object({ keys: import_zod170.z.array(JwkKey) });

// src/generated-definitions/RevocationList.ts
var import_zod173 = require("zod");

// src/generated-definitions/FilterJson.ts
var import_zod171 = require("zod");
var FilterJson = import_zod171.z.object({ bits: import_zod171.z.array(import_zod171.z.number().int()), k: import_zod171.z.number().int(), m: import_zod171.z.number().int() });

// src/generated-definitions/UserRevocationListRecord.ts
var import_zod172 = require("zod");
var UserRevocationListRecord = import_zod172.z.object({ id: import_zod172.z.string(), revoked_at: import_zod172.z.string() });

// src/generated-definitions/RevocationList.ts
var RevocationList = import_zod173.z.object({ revoked_tokens: FilterJson, revoked_users: import_zod173.z.array(UserRevocationListRecord) });

// src/generated-definitions/TokenResponse.ts
var import_zod175 = require("zod");

// src/generated-definitions/JwtBanV3.ts
var import_zod174 = require("zod");
var JwtBanV3 = import_zod174.z.object({
  ban: import_zod174.z.string(),
  disabledDate: import_zod174.z.string().nullish(),
  enabled: import_zod174.z.boolean(),
  endDate: import_zod174.z.string(),
  targetedNamespace: import_zod174.z.string()
});

// src/generated-definitions/TokenResponse.ts
var TokenResponse = import_zod175.z.object({
  access_token: import_zod175.z.string(),
  bans: import_zod175.z.array(JwtBanV3),
  device_id: import_zod175.z.string().nullish(),
  display_name: import_zod175.z.string(),
  expires_in: import_zod175.z.number().int(),
  is_comply: import_zod175.z.boolean().nullish(),
  jflgs: import_zod175.z.number().int().nullish(),
  namespace: import_zod175.z.string(),
  namespace_roles: import_zod175.z.array(NamespaceRole),
  permissions: import_zod175.z.array(Permission),
  platform_id: import_zod175.z.string().nullish(),
  platform_user_id: import_zod175.z.string().nullish(),
  refresh_expires_in: import_zod175.z.number().int().nullish(),
  refresh_token: import_zod175.z.string(),
  roles: import_zod175.z.array(import_zod175.z.string()),
  token_type: import_zod175.z.string(),
  user_id: import_zod175.z.string()
});

// src/generated-public/endpoints/OAuth$.ts
var OAuth$ = class {
  // @ts-ignore
  // prettier-ignore
  constructor(axiosInstance, namespace, useSchemaValidation = true) {
    this.axiosInstance = axiosInstance;
    this.namespace = namespace;
    this.useSchemaValidation = useSchemaValidation;
  }
  /**
   * @deprecated
   * ## The endpoint is going to be deprecated This endpoint serves public keys for verifying JWT access tokens generated by this service. When a client application wants to verify a JWT token, it needs to get the &#39;kid&#39; value found in the JWT token header and use it to look up the corresponding public key from a set returned by this endpoint. The client application can then use that public key to verify the JWT. A client application might cache the keys so it doesn&#39;t need to do request every time it needs to verify a JWT token. If a client application caches the keys and a key with the same &#39;kid&#39; cannot be found in the cache, it should then try to refresh the keys by making a request to this endpoint again. Please refer to the RFC for more information about JWK (JSON Web Key): https://tools.ietf.org/html/rfc7517 ### Endpoint migration guide - **Substitute endpoint: _/iam/v3/oauth/jwks [GET]_**
   */
  getOauthJwks() {
    const params = {};
    const url = "/iam/oauth/jwks";
    const resultPromise = this.axiosInstance.get(url, { params });
    return import_sdk43.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, JwkSet, "JwkSet");
  }
  /**
   * @deprecated
   * ## The endpoint is going to be deprecated ### Endpoint migration guide - **Substitute endpoint: /iam/v3/oauth/token [POST]** - **Note: difference in V3 response:** format difference（Pascal case =&gt; Camel case): permissions field from Action =&gt; action, Resource =&gt; resource This endpoint requires all requests to have &lt;code&gt;Authorization&lt;/code&gt; header set with &lt;code&gt;Basic&lt;/code&gt; access authentication constructed from client id and client secret. This endpoint supports different **grant types**: 1. Grant Type == &lt;code&gt;client_credentials&lt;/code&gt;: This endpoint will check the client credentials provided through Authorization header. 2. Grant Type == &lt;code&gt;password&lt;/code&gt;: The grant type to use for authenticating a user, whether it&#39;s by email / username and password combination or through platform. 3. Grant Type == &lt;code&gt;refresh_token&lt;/code&gt;: Used to get a new access token for a valid refresh token. 4. Grant Type == &lt;code&gt;authorization_code&lt;/code&gt;: It generates the user token by given the authorization code which generated in &#34;/authorize&#34; API response. It should also pass in the redirect_uri, which should be the same as generating the authorization code request. For platform authentication, use grant type &lt;code&gt;password&lt;/code&gt;. The &lt;code&gt;username&lt;/code&gt; field would be in form of &lt;code&gt;platform:&lt;platform type&gt;&lt;/code&gt;, for example &lt;code&gt;platform:steam&lt;/code&gt; for Steam. For the &lt;code&gt;password&lt;/code&gt; field, set it to the authentication/authorization ticket or token obtainable through the respective platform SDK after authenticated the user to the platform. Supported platforms: - **steam** - use &lt;code&gt;platform:steam&lt;/code&gt; as the username and use the authentication ticket obtained from Steam through the Steam SDK as the password. - **ps4** - use &lt;code&gt;platform:ps4&lt;/code&gt; as the username and use the authorization code obtained from the PlayStation Network through a player PS4 unit as the password. - **live** - use &lt;code&gt;platform:live&lt;/code&gt; as the username and use token obtained from Xbox Secure Token Service (XSTS) as the password. - **oculus** - use &lt;code&gt;platform:oculus&lt;/code&gt; as the username and use the &lt;code&gt;user_id:nonce&lt;/code&gt; as password obtained from Oculus through the Oculus SDK. The access token and refresh token are in form of JWT token. An access token JWT contains data which structure is similar to the Response Class below, but without OAuth-related data. To verify a token, use the public keys obtained from the &lt;code&gt;/jwks&lt;/code&gt; endpoint below. ## Access Token Content Following is the access token’s content: - **namespace**. It is the namespace the token was generated from. - **display_name**. The display name of the sub. It is empty if the token is generated from the client credential - **roles**. The sub’s roles. It is empty if the token is generated from the client credential - **namespace_roles**. The sub’s roles scoped to namespace. Improvement from roles, which make the role scoped to specific namespace instead of global to publisher namespace - **permissions**. The sub or aud’ permissions - **bans**. The sub’s list of bans. It is used by the IAM client for validating the token. - **jflgs**. It stands for Justice Flags. It is a special flag used for storing additional status information regarding the sub. It is implemented as a bit mask. Following explains what each bit represents: - 1: Email Address Verified - 2: Phone Number Verified - 4: Anonymous - **aud**. The aud is the client ID. - **iat**. The time the token issues at. It is in Epoch time format - **exp**. The time the token expires. It is in Epoch time format - **sub**. The UserID. The sub is omitted if the token is generated from client credential ## Bans The JWT contains user&#39;s active bans with its expiry date. List of ban types can be obtained from /bans. ## Track Login History This endpoint will track login history to detect suspicious login activity, please provide &#34;device_id&#34; (alphanumeric) in request header parameter otherwise we will set to &#34;unknown&#34;. Align with General Data Protection Regulation in Europe, user login history will be kept within 28 days by default&#34;
   */
  postOauthToken(data) {
    const params = {};
    const url = "/iam/oauth/token";
    const resultPromise = this.axiosInstance.post(url, import_sdk43.CodeGenUtil.getFormUrlEncodedData(data), {
      ...params,
      headers: { ...params.headers, "content-type": "application/x-www-form-urlencoded" }
    });
    return import_sdk43.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, TokenResponse, "TokenResponse");
  }
  /**
   * @deprecated
   * ## The endpoint is going to be deprecated This endpoint requires all requests to have Authorization header set with Basic access authentication constructed from client id and client secret. ### Endpoint migration guide - **Substitute endpoint: _/iam/v3/oauth/verify [POST]_** - **Note: difference in V3 response:** 1. format difference（Pascal case =&gt; Camel case): permissions field from Action =&gt; action, Resource =&gt; resource
   */
  postOauthVerify(data) {
    const params = {};
    const url = "/iam/oauth/verify";
    const resultPromise = this.axiosInstance.post(url, import_sdk43.CodeGenUtil.getFormUrlEncodedData(data), {
      ...params,
      headers: { ...params.headers, "content-type": "application/x-www-form-urlencoded" }
    });
    return import_sdk43.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, TokenResponse, "TokenResponse");
  }
  /**
   * @deprecated
   * ## The endpoint is going to be deprecated The endpoint supports two response types: ### 1. Response Type == &#34;code&#34;: The endpoint returns an authorization code that will be used by the IAM client to exchange for an access token. It supports two different headers, the basic and the bearer header. Each behaves differently. - **The basic header** The basic header’s value is the base64 of the client ID and client secret. It is used by the developer whenever the developer authorizes a user on a same namespace. - **The bearer header** The bearer header’s value is an access token. It is used by the developer whenever the developer authorizes a user on a different namespace. The endpoint validates user’s entitlement on the designated namespace for making sure the user is authorized for a designated namespace. Following are the responses returned by the endpoint: - **Authorize success**: redirects to the given URL with the following information: ?code={authorization code}&amp;state={state} - **Authorize failure**: redirects to the given URL with the following information:?error=access_denied&amp;error_description=... ### 2. Response Type == &#34;token&#34; (Implicit) is deprecated. ### Endpoint migration guide - **Substitute endpoint (for: basic header style)**: _/iam/v3/oauth/authorize [GET]_ - **Substitute endpoint (for: bearer header style)**: step1: /iam/v3/namespace/{namespace}/token/request [POST] =&gt; get code step2: /iam/v3/token/exchange [POST] =&gt; get token by step1&#39;s code - **Note:** 1. V3 is standard OAuth2 flow and support PKCE 2. Will not support implicit flow in v3.
   */
  postOauthAuthorize(data) {
    const params = {};
    const url = "/iam/oauth/authorize";
    const resultPromise = this.axiosInstance.post(url, import_sdk43.CodeGenUtil.getFormUrlEncodedData(data), {
      ...params,
      headers: { ...params.headers, "content-type": "application/x-www-form-urlencoded" }
    });
    return import_sdk43.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, import_zod176.z.unknown(), "z.unknown()");
  }
  /**
   * @deprecated
   * ## The endpoint is going to be deprecated This endpoint revokes a user. This endpoint requires all requests to have Authorization header set with Bearer access authentication with valid access token. When other clients know that the userID has been revoked and the token is issued before the revocation, forcing a new token will contain banned permissions. ### Endpoint migration guide - **Substitute endpoint: _/iam/v3/oauth/admin/namespaces/{namespace}/users/{userId}/revoke [POST]_**
   */
  postOauthRevokeUser(data) {
    const params = {};
    const url = "/iam/oauth/revoke/user";
    const resultPromise = this.axiosInstance.post(url, import_sdk43.CodeGenUtil.getFormUrlEncodedData(data), {
      ...params,
      headers: { ...params.headers, "content-type": "application/x-www-form-urlencoded" }
    });
    return import_sdk43.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, import_zod176.z.unknown(), "z.unknown()");
  }
  /**
   * @deprecated
   * ## The endpoint is going to be deprecated Revokes a token. This endpoint requires all requests to have Authorization header set with Basic access authentication constructed from client id and client secret or Bearer access authentication with valid access token. ### Endpoint migration guide - **Substitute endpoint: _/v3/oauth/revoke [POST]_**
   */
  postOauthRevokeToken(data) {
    const params = {};
    const url = "/iam/oauth/revoke/token";
    const resultPromise = this.axiosInstance.post(url, import_sdk43.CodeGenUtil.getFormUrlEncodedData(data), {
      ...params,
      headers: { ...params.headers, "content-type": "application/x-www-form-urlencoded" }
    });
    return import_sdk43.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, import_zod176.z.unknown(), "z.unknown()");
  }
  /**
   * @deprecated
   * ## The endpoint is going to be deprecated This endpoint will return a list of revoked users and revoked tokens. List of revoked tokens in bloom filter format. This endpoint requires all requests to have Authorization header set with Basic access authentication constructed from client id and client secret. The bloom filter uses MurmurHash3 algorithm for hashing the values ### Endpoint migration guide - **Substitute endpoint: _/iam/v3/oauth/revocationlist [GET]_**
   */
  getOauthRevocationlist() {
    const params = {};
    const url = "/iam/oauth/revocationlist";
    const resultPromise = this.axiosInstance.get(url, { params });
    return import_sdk43.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, RevocationList, "RevocationList");
  }
  /**
   * @deprecated
   * ## The endpoint is going to be deprecated This endpoint requires all requests to have authorization header set with bearer token. The endpoint revokes all access tokens and refresh tokens a user has prior the revocation time. It is a convenient feature for the developer (or admin) who wanted to revokes all user&#39;s access tokens and refresh tokens generated before some period of time. ### Endpoint migration guide - **Substitute endpoint: _/iam/v3/oauth/admin/namespaces/{namespace}/users/{userId}/revoke [POST]_**
   */
  updateRevokeOauth_ByUserId(userId) {
    const params = {};
    const url = "/iam/oauth/namespaces/{namespace}/users/{userId}/revoke".replace("{namespace}", this.namespace).replace("{userId}", userId);
    const resultPromise = this.axiosInstance.post(url, null, { params });
    return import_sdk43.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, import_zod176.z.unknown(), "z.unknown()");
  }
  /**
   * @deprecated
   * ## The endpoint is going to be deprecated This endpoint requires all requests to have Authorization header set with Basic access authentication constructed from client id and client secret. For publisher-game namespace schema : Specify only either platform_token or device_id. Device token grant should be requested along with device_id parameter against game namespace. Another 3rd party platform token grant should be requested along with platform_token parameter against publisher namespace. Supported platforms: - **steamopenid**: Steam&#39;s user authentication method using OpenID 2.0. The expected value of the platform token is the URL generated by Steam on web authentication The JWT contains user&#39;s active bans with its expiry date. List of ban types can be obtained from /iam/bans.. ### Endpoint migration guide - **Substitute endpoint: _/iam/v3/oauth/platforms/{platformId}/token [POST]_**
   */
  postTokenOauth_ByPlatformId(platformId, data) {
    const params = {};
    const url = "/iam/oauth/namespaces/{namespace}/platforms/{platformId}/token".replace("{namespace}", this.namespace).replace("{platformId}", platformId);
    const resultPromise = this.axiosInstance.post(url, import_sdk43.CodeGenUtil.getFormUrlEncodedData(data), {
      ...params,
      headers: { ...params.headers, "content-type": "application/x-www-form-urlencoded" }
    });
    return import_sdk43.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, TokenResponse, "TokenResponse");
  }
};

// src/generated-public/OAuthApi.ts
function OAuthApi(sdk, args) {
  const sdkAssembly = sdk.assembly();
  const namespace = args?.coreConfig?.namespace ?? sdkAssembly.coreConfig.namespace;
  const useSchemaValidation = args?.coreConfig?.useSchemaValidation ?? sdkAssembly.coreConfig.useSchemaValidation;
  let axiosInstance = sdkAssembly.axiosInstance;
  const requestConfigOverrides = args?.axiosConfig?.request;
  const baseURLOverride = args?.coreConfig?.baseURL;
  const interceptorsOverride = args?.axiosConfig?.interceptors ?? [];
  if (requestConfigOverrides || baseURLOverride || interceptorsOverride.length > 0) {
    const requestConfig = import_sdk44.ApiUtils.mergeAxiosConfigs(sdkAssembly.axiosInstance.defaults, {
      ...baseURLOverride ? { baseURL: baseURLOverride } : {},
      ...requestConfigOverrides
    });
    axiosInstance = import_sdk44.Network.create(requestConfig);
    for (const interceptor of interceptorsOverride) {
      if (interceptor.type === "request") {
        axiosInstance.interceptors.request.use(interceptor.onRequest, interceptor.onError);
      }
      if (interceptor.type === "response") {
        axiosInstance.interceptors.response.use(interceptor.onSuccess, interceptor.onError);
      }
    }
  }
  async function getOauthJwks() {
    const $ = new OAuth$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getOauthJwks();
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function postOauthToken(data) {
    const $ = new OAuth$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.postOauthToken(data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function postOauthVerify(data) {
    const $ = new OAuth$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.postOauthVerify(data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function postOauthAuthorize(data) {
    const $ = new OAuth$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.postOauthAuthorize(data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function postOauthRevokeUser(data) {
    const $ = new OAuth$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.postOauthRevokeUser(data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function postOauthRevokeToken(data) {
    const $ = new OAuth$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.postOauthRevokeToken(data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getOauthRevocationlist() {
    const $ = new OAuth$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getOauthRevocationlist();
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function updateRevokeOauth_ByUserId(userId) {
    const $ = new OAuth$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.updateRevokeOauth_ByUserId(userId);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function postTokenOauth_ByPlatformId(platformId, data) {
    const $ = new OAuth$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.postTokenOauth_ByPlatformId(platformId, data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  return {
    /**
     * @deprecated
     * ## The endpoint is going to be deprecated This endpoint serves public keys for verifying JWT access tokens generated by this service. When a client application wants to verify a JWT token, it needs to get the &#39;kid&#39; value found in the JWT token header and use it to look up the corresponding public key from a set returned by this endpoint. The client application can then use that public key to verify the JWT. A client application might cache the keys so it doesn&#39;t need to do request every time it needs to verify a JWT token. If a client application caches the keys and a key with the same &#39;kid&#39; cannot be found in the cache, it should then try to refresh the keys by making a request to this endpoint again. Please refer to the RFC for more information about JWK (JSON Web Key): https://tools.ietf.org/html/rfc7517 ### Endpoint migration guide - **Substitute endpoint: _/iam/v3/oauth/jwks [GET]_**
     */
    getOauthJwks,
    /**
     * @deprecated
     * ## The endpoint is going to be deprecated ### Endpoint migration guide - **Substitute endpoint: /iam/v3/oauth/token [POST]** - **Note: difference in V3 response:** format difference（Pascal case =&gt; Camel case): permissions field from Action =&gt; action, Resource =&gt; resource This endpoint requires all requests to have &lt;code&gt;Authorization&lt;/code&gt; header set with &lt;code&gt;Basic&lt;/code&gt; access authentication constructed from client id and client secret. This endpoint supports different **grant types**: 1. Grant Type == &lt;code&gt;client_credentials&lt;/code&gt;: This endpoint will check the client credentials provided through Authorization header. 2. Grant Type == &lt;code&gt;password&lt;/code&gt;: The grant type to use for authenticating a user, whether it&#39;s by email / username and password combination or through platform. 3. Grant Type == &lt;code&gt;refresh_token&lt;/code&gt;: Used to get a new access token for a valid refresh token. 4. Grant Type == &lt;code&gt;authorization_code&lt;/code&gt;: It generates the user token by given the authorization code which generated in &#34;/authorize&#34; API response. It should also pass in the redirect_uri, which should be the same as generating the authorization code request. For platform authentication, use grant type &lt;code&gt;password&lt;/code&gt;. The &lt;code&gt;username&lt;/code&gt; field would be in form of &lt;code&gt;platform:&lt;platform type&gt;&lt;/code&gt;, for example &lt;code&gt;platform:steam&lt;/code&gt; for Steam. For the &lt;code&gt;password&lt;/code&gt; field, set it to the authentication/authorization ticket or token obtainable through the respective platform SDK after authenticated the user to the platform. Supported platforms: - **steam** - use &lt;code&gt;platform:steam&lt;/code&gt; as the username and use the authentication ticket obtained from Steam through the Steam SDK as the password. - **ps4** - use &lt;code&gt;platform:ps4&lt;/code&gt; as the username and use the authorization code obtained from the PlayStation Network through a player PS4 unit as the password. - **live** - use &lt;code&gt;platform:live&lt;/code&gt; as the username and use token obtained from Xbox Secure Token Service (XSTS) as the password. - **oculus** - use &lt;code&gt;platform:oculus&lt;/code&gt; as the username and use the &lt;code&gt;user_id:nonce&lt;/code&gt; as password obtained from Oculus through the Oculus SDK. The access token and refresh token are in form of JWT token. An access token JWT contains data which structure is similar to the Response Class below, but without OAuth-related data. To verify a token, use the public keys obtained from the &lt;code&gt;/jwks&lt;/code&gt; endpoint below. ## Access Token Content Following is the access token’s content: - **namespace**. It is the namespace the token was generated from. - **display_name**. The display name of the sub. It is empty if the token is generated from the client credential - **roles**. The sub’s roles. It is empty if the token is generated from the client credential - **namespace_roles**. The sub’s roles scoped to namespace. Improvement from roles, which make the role scoped to specific namespace instead of global to publisher namespace - **permissions**. The sub or aud’ permissions - **bans**. The sub’s list of bans. It is used by the IAM client for validating the token. - **jflgs**. It stands for Justice Flags. It is a special flag used for storing additional status information regarding the sub. It is implemented as a bit mask. Following explains what each bit represents: - 1: Email Address Verified - 2: Phone Number Verified - 4: Anonymous - **aud**. The aud is the client ID. - **iat**. The time the token issues at. It is in Epoch time format - **exp**. The time the token expires. It is in Epoch time format - **sub**. The UserID. The sub is omitted if the token is generated from client credential ## Bans The JWT contains user&#39;s active bans with its expiry date. List of ban types can be obtained from /bans. ## Track Login History This endpoint will track login history to detect suspicious login activity, please provide &#34;device_id&#34; (alphanumeric) in request header parameter otherwise we will set to &#34;unknown&#34;. Align with General Data Protection Regulation in Europe, user login history will be kept within 28 days by default&#34;
     */
    postOauthToken,
    /**
     * @deprecated
     * ## The endpoint is going to be deprecated This endpoint requires all requests to have Authorization header set with Basic access authentication constructed from client id and client secret. ### Endpoint migration guide - **Substitute endpoint: _/iam/v3/oauth/verify [POST]_** - **Note: difference in V3 response:** 1. format difference（Pascal case =&gt; Camel case): permissions field from Action =&gt; action, Resource =&gt; resource
     */
    postOauthVerify,
    /**
     * @deprecated
     * ## The endpoint is going to be deprecated The endpoint supports two response types: ### 1. Response Type == &#34;code&#34;: The endpoint returns an authorization code that will be used by the IAM client to exchange for an access token. It supports two different headers, the basic and the bearer header. Each behaves differently. - **The basic header** The basic header’s value is the base64 of the client ID and client secret. It is used by the developer whenever the developer authorizes a user on a same namespace. - **The bearer header** The bearer header’s value is an access token. It is used by the developer whenever the developer authorizes a user on a different namespace. The endpoint validates user’s entitlement on the designated namespace for making sure the user is authorized for a designated namespace. Following are the responses returned by the endpoint: - **Authorize success**: redirects to the given URL with the following information: ?code={authorization code}&amp;state={state} - **Authorize failure**: redirects to the given URL with the following information:?error=access_denied&amp;error_description=... ### 2. Response Type == &#34;token&#34; (Implicit) is deprecated. ### Endpoint migration guide - **Substitute endpoint (for: basic header style)**: _/iam/v3/oauth/authorize [GET]_ - **Substitute endpoint (for: bearer header style)**: step1: /iam/v3/namespace/{namespace}/token/request [POST] =&gt; get code step2: /iam/v3/token/exchange [POST] =&gt; get token by step1&#39;s code - **Note:** 1. V3 is standard OAuth2 flow and support PKCE 2. Will not support implicit flow in v3.
     */
    postOauthAuthorize,
    /**
     * @deprecated
     * ## The endpoint is going to be deprecated This endpoint revokes a user. This endpoint requires all requests to have Authorization header set with Bearer access authentication with valid access token. When other clients know that the userID has been revoked and the token is issued before the revocation, forcing a new token will contain banned permissions. ### Endpoint migration guide - **Substitute endpoint: _/iam/v3/oauth/admin/namespaces/{namespace}/users/{userId}/revoke [POST]_**
     */
    postOauthRevokeUser,
    /**
     * @deprecated
     * ## The endpoint is going to be deprecated Revokes a token. This endpoint requires all requests to have Authorization header set with Basic access authentication constructed from client id and client secret or Bearer access authentication with valid access token. ### Endpoint migration guide - **Substitute endpoint: _/v3/oauth/revoke [POST]_**
     */
    postOauthRevokeToken,
    /**
     * @deprecated
     * ## The endpoint is going to be deprecated This endpoint will return a list of revoked users and revoked tokens. List of revoked tokens in bloom filter format. This endpoint requires all requests to have Authorization header set with Basic access authentication constructed from client id and client secret. The bloom filter uses MurmurHash3 algorithm for hashing the values ### Endpoint migration guide - **Substitute endpoint: _/iam/v3/oauth/revocationlist [GET]_**
     */
    getOauthRevocationlist,
    /**
     * @deprecated
     * ## The endpoint is going to be deprecated This endpoint requires all requests to have authorization header set with bearer token. The endpoint revokes all access tokens and refresh tokens a user has prior the revocation time. It is a convenient feature for the developer (or admin) who wanted to revokes all user&#39;s access tokens and refresh tokens generated before some period of time. ### Endpoint migration guide - **Substitute endpoint: _/iam/v3/oauth/admin/namespaces/{namespace}/users/{userId}/revoke [POST]_**
     */
    updateRevokeOauth_ByUserId,
    /**
     * @deprecated
     * ## The endpoint is going to be deprecated This endpoint requires all requests to have Authorization header set with Basic access authentication constructed from client id and client secret. For publisher-game namespace schema : Specify only either platform_token or device_id. Device token grant should be requested along with device_id parameter against game namespace. Another 3rd party platform token grant should be requested along with platform_token parameter against publisher namespace. Supported platforms: - **steamopenid**: Steam&#39;s user authentication method using OpenID 2.0. The expected value of the platform token is the URL generated by Steam on web authentication The JWT contains user&#39;s active bans with its expiry date. List of ban types can be obtained from /iam/bans.. ### Endpoint migration guide - **Substitute endpoint: _/iam/v3/oauth/platforms/{platformId}/token [POST]_**
     */
    postTokenOauth_ByPlatformId
  };
}

// src/generated-public/queries/OAuth.query.ts
var Key_OAuth = /* @__PURE__ */ ((Key_OAuth2) => {
  Key_OAuth2["OauthJwks"] = "Iam.OAuth.OauthJwks";
  Key_OAuth2["OauthToken"] = "Iam.OAuth.OauthToken";
  Key_OAuth2["OauthVerify"] = "Iam.OAuth.OauthVerify";
  Key_OAuth2["OauthAuthorize"] = "Iam.OAuth.OauthAuthorize";
  Key_OAuth2["OauthRevokeUser"] = "Iam.OAuth.OauthRevokeUser";
  Key_OAuth2["OauthRevokeToken"] = "Iam.OAuth.OauthRevokeToken";
  Key_OAuth2["OauthRevocationlist"] = "Iam.OAuth.OauthRevocationlist";
  Key_OAuth2["RevokeOauth_ByUserId"] = "Iam.OAuth.RevokeOauth_ByUserId";
  Key_OAuth2["TokenOauth_ByPlatformId"] = "Iam.OAuth.TokenOauth_ByPlatformId";
  return Key_OAuth2;
})(Key_OAuth || {});
var useOAuthApi_GetOauthJwks = (sdk, input, options, callback) => {
  const queryFn = (sdk2, input2) => async () => {
    const response = await OAuthApi(sdk2, { coreConfig: input2.coreConfig, axiosConfig: input2.axiosConfig }).getOauthJwks();
    callback && callback(response);
    return response.data;
  };
  return (0, import_react_query22.useQuery)({
    queryKey: ["Iam.OAuth.OauthJwks" /* OauthJwks */, input],
    queryFn: queryFn(sdk, input),
    ...options
  });
};
var useOAuthApi_PostOauthTokenMutation = (sdk, options, callback) => {
  const mutationFn = async (input) => {
    const response = await OAuthApi(sdk, { coreConfig: input.coreConfig, axiosConfig: input.axiosConfig }).postOauthToken(input.data);
    callback && callback(response.data);
    return response.data;
  };
  return (0, import_react_query22.useMutation)({
    mutationKey: ["Iam.OAuth.OauthToken" /* OauthToken */],
    mutationFn,
    ...options
  });
};
var useOAuthApi_PostOauthVerifyMutation = (sdk, options, callback) => {
  const mutationFn = async (input) => {
    const response = await OAuthApi(sdk, { coreConfig: input.coreConfig, axiosConfig: input.axiosConfig }).postOauthVerify(input.data);
    callback && callback(response.data);
    return response.data;
  };
  return (0, import_react_query22.useMutation)({
    mutationKey: ["Iam.OAuth.OauthVerify" /* OauthVerify */],
    mutationFn,
    ...options
  });
};
var useOAuthApi_PostOauthAuthorizeMutation = (sdk, options, callback) => {
  const mutationFn = async (input) => {
    const response = await OAuthApi(sdk, { coreConfig: input.coreConfig, axiosConfig: input.axiosConfig }).postOauthAuthorize(input.data);
    callback && callback(response.data);
    return response.data;
  };
  return (0, import_react_query22.useMutation)({
    mutationKey: ["Iam.OAuth.OauthAuthorize" /* OauthAuthorize */],
    mutationFn,
    ...options
  });
};
var useOAuthApi_PostOauthRevokeUserMutation = (sdk, options, callback) => {
  const mutationFn = async (input) => {
    const response = await OAuthApi(sdk, { coreConfig: input.coreConfig, axiosConfig: input.axiosConfig }).postOauthRevokeUser(input.data);
    callback && callback(response.data);
    return response.data;
  };
  return (0, import_react_query22.useMutation)({
    mutationKey: ["Iam.OAuth.OauthRevokeUser" /* OauthRevokeUser */],
    mutationFn,
    ...options
  });
};
var useOAuthApi_PostOauthRevokeTokenMutation = (sdk, options, callback) => {
  const mutationFn = async (input) => {
    const response = await OAuthApi(sdk, { coreConfig: input.coreConfig, axiosConfig: input.axiosConfig }).postOauthRevokeToken(input.data);
    callback && callback(response.data);
    return response.data;
  };
  return (0, import_react_query22.useMutation)({
    mutationKey: ["Iam.OAuth.OauthRevokeToken" /* OauthRevokeToken */],
    mutationFn,
    ...options
  });
};
var useOAuthApi_GetOauthRevocationlist = (sdk, input, options, callback) => {
  const queryFn = (sdk2, input2) => async () => {
    const response = await OAuthApi(sdk2, { coreConfig: input2.coreConfig, axiosConfig: input2.axiosConfig }).getOauthRevocationlist();
    callback && callback(response);
    return response.data;
  };
  return (0, import_react_query22.useQuery)({
    queryKey: ["Iam.OAuth.OauthRevocationlist" /* OauthRevocationlist */, input],
    queryFn: queryFn(sdk, input),
    ...options
  });
};
var useOAuthApi_UpdateRevokeOauth_ByUserIdMutation = (sdk, options, callback) => {
  const mutationFn = async (input) => {
    const response = await OAuthApi(sdk, { coreConfig: input.coreConfig, axiosConfig: input.axiosConfig }).updateRevokeOauth_ByUserId(
      input.userId
    );
    callback && callback(response.data);
    return response.data;
  };
  return (0, import_react_query22.useMutation)({
    mutationKey: ["Iam.OAuth.RevokeOauth_ByUserId" /* RevokeOauth_ByUserId */],
    mutationFn,
    ...options
  });
};
var useOAuthApi_PostTokenOauth_ByPlatformIdMutation = (sdk, options, callback) => {
  const mutationFn = async (input) => {
    const response = await OAuthApi(sdk, { coreConfig: input.coreConfig, axiosConfig: input.axiosConfig }).postTokenOauth_ByPlatformId(
      input.platformId,
      input.data
    );
    callback && callback(response.data);
    return response.data;
  };
  return (0, import_react_query22.useMutation)({
    mutationKey: ["Iam.OAuth.TokenOauth_ByPlatformId" /* TokenOauth_ByPlatformId */],
    mutationFn,
    ...options
  });
};

// src/generated-public/queries/OAuth20.query.ts
var import_react_query23 = require("@tanstack/react-query");

// src/generated-public/OAuth20Api.ts
var import_sdk46 = require("@accelbyte/sdk");

// src/generated-public/endpoints/OAuth20$.ts
var import_sdk45 = require("@accelbyte/sdk");
var import_zod180 = require("zod");

// src/generated-definitions/TokenIntrospectResponse.ts
var import_zod177 = require("zod");
var TokenIntrospectResponse = import_zod177.z.object({
  active: import_zod177.z.boolean(),
  aud: import_zod177.z.string().nullish(),
  client_id: import_zod177.z.string().nullish(),
  exp: import_zod177.z.number().int().nullish(),
  iat: import_zod177.z.number().int().nullish(),
  scope: import_zod177.z.string().nullish(),
  sub: import_zod177.z.string().nullish()
});

// src/generated-definitions/TokenResponseV3.ts
var import_zod178 = require("zod");
var TokenResponseV3 = import_zod178.z.object({
  access_token: import_zod178.z.string(),
  bans: import_zod178.z.array(JwtBanV3).nullish(),
  display_name: import_zod178.z.string().nullish(),
  expires_in: import_zod178.z.number().int(),
  is_comply: import_zod178.z.boolean().nullish(),
  jflgs: import_zod178.z.number().int().nullish(),
  namespace: import_zod178.z.string(),
  namespace_roles: import_zod178.z.array(NamespaceRole).nullish(),
  permissions: import_zod178.z.array(PermissionV3),
  platform_id: import_zod178.z.string().nullish(),
  platform_user_id: import_zod178.z.string().nullish(),
  refresh_expires_in: import_zod178.z.number().int().nullish(),
  refresh_token: import_zod178.z.string().nullish(),
  roles: import_zod178.z.array(import_zod178.z.string()).nullish(),
  scope: import_zod178.z.string(),
  simultaneous_platform_id: import_zod178.z.string().nullish(),
  simultaneous_platform_user_id: import_zod178.z.string().nullish(),
  token_type: import_zod178.z.string(),
  unique_display_name: import_zod178.z.string().nullish(),
  user_id: import_zod178.z.string().nullish(),
  xuid: import_zod178.z.string().nullish()
});

// src/generated-definitions/TokenWithDeviceCookieResponseV3.ts
var import_zod179 = require("zod");
var TokenWithDeviceCookieResponseV3 = import_zod179.z.object({
  access_token: import_zod179.z.string(),
  auth_trust_id: import_zod179.z.string().nullish(),
  bans: import_zod179.z.array(JwtBanV3).nullish(),
  display_name: import_zod179.z.string().nullish(),
  expires_in: import_zod179.z.number().int(),
  is_comply: import_zod179.z.boolean().nullish(),
  jflgs: import_zod179.z.number().int().nullish(),
  namespace: import_zod179.z.string(),
  namespace_roles: import_zod179.z.array(NamespaceRole).nullish(),
  permissions: import_zod179.z.array(PermissionV3),
  platform_id: import_zod179.z.string().nullish(),
  platform_user_id: import_zod179.z.string().nullish(),
  refresh_expires_in: import_zod179.z.number().int().nullish(),
  refresh_token: import_zod179.z.string().nullish(),
  roles: import_zod179.z.array(import_zod179.z.string()).nullish(),
  scope: import_zod179.z.string(),
  simultaneous_platform_id: import_zod179.z.string().nullish(),
  simultaneous_platform_user_id: import_zod179.z.string().nullish(),
  token_type: import_zod179.z.string(),
  unique_display_name: import_zod179.z.string().nullish(),
  user_id: import_zod179.z.string().nullish(),
  xuid: import_zod179.z.string().nullish()
});

// src/generated-public/endpoints/OAuth20$.ts
var OAuth20$ = class {
  // @ts-ignore
  // prettier-ignore
  constructor(axiosInstance, namespace, useSchemaValidation = true) {
    this.axiosInstance = axiosInstance;
    this.namespace = namespace;
    this.useSchemaValidation = useSchemaValidation;
  }
  /**
   * This endpoint serves public keys for verifying JWT access tokens generated by this service. When a client application wants to verify a JWT token, it needs to get the &#39;kid&#39; value found in the JWT token header and use it to look up the corresponding public key from a set returned by this endpoint. The client application can then use that public key to verify the JWT. A client application might cache the keys so it doesn&#39;t need to do request every time it needs to verify a JWT token. If a client application caches the keys and a key with the same &#39;kid&#39; cannot be found in the cache, it should then try to refresh the keys by making a request to this endpoint again. Please refer to the RFC for more information about JWK (JSON Web Key): https://tools.ietf.org/html/rfc7517 action code : 10709
   */
  getOauthJwks_v3() {
    const params = {};
    const url = "/iam/v3/oauth/jwks";
    const resultPromise = this.axiosInstance.get(url, { params });
    return import_sdk45.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, JwkSet, "JwkSet");
  }
  /**
   * This endpoint supports grant type: 1. Grant Type == &lt;code&gt;authorization_code&lt;/code&gt;: It generates the user token by given the authorization code which generated in &#34;/iam/v3/authenticate&#34; API response. It should also pass in the redirect_uri, which should be the same as generating the authorization code request. 2. Grant Type == &lt;code&gt;password&lt;/code&gt;: The grant type to use for authenticating a user, whether it&#39;s by email / username and password combination or through platform. 3. Grant Type == &lt;code&gt;refresh_token&lt;/code&gt;: Used to get a new access token for a valid refresh token. 4. Grant Type == &lt;code&gt;client_credentials&lt;/code&gt;: It generates a token by checking the client credentials provided through Authorization header. 5. Grant Type == &lt;code&gt;urn:ietf:params:oauth:grant-type:extend_client_credentials&lt;/code&gt;: It generates a token by checking the client credentials provided through Authorization header. It only allows publisher/studio namespace client. In generated token: 1. There wil be no roles, namespace_roles &amp; permission. 2. The scope will be fixed as &#39;extend&#39;. 3. There will have a new field &#39;extend_namespace&#39;, the value is from token request body. ## Access Token Content Following is the access token’s content: - **namespace**. It is the namespace the token was generated from. - **display_name**. The display name of the sub. It is empty if the token is generated from the client credential - **roles**. The sub’s roles. It is empty if the token is generated from the client credential - **namespace_roles**. The sub’s roles scoped to namespace. Improvement from roles, which make the role scoped to specific namespace instead of global to publisher namespace - **permissions**. The sub or aud’ permissions - **bans**. The sub’s list of bans. It is used by the IAM client for validating the token. - **jflgs**. It stands for Justice Flags. It is a special flag used for storing additional status information regarding the sub. It is implemented as a bit mask. Following explains what each bit represents: - 1: Email Address Verified - 2: Phone Number Verified - 4: Anonymous - 8: Suspicious Login - **aud**. The aud is the targeted resource server. - **iat**. The time the token issues at. It is in Epoch time format - **exp**. The time the token expires. It is in Epoch time format - **client_id**. The UserID. The sub is omitted if the token is generated from client credential - **scope**. The scope of the access request, expressed as a list of space-delimited, case-sensitive strings ## Bans The JWT contains user&#39;s active bans with its expiry date. List of ban types can be obtained from /bans. ## Device Cookie Validation _**For grant type &#34;password&#34; only**_ Device Cookie is used to protect the user account from brute force login attack, &lt;a target=&#34;_blank&#34; href=&#34;https://owasp.org/www-community/Slow_Down_Online_Guessing_Attacks_with_Device_Cookies&#34;&gt;more detail from OWASP&lt;a&gt;. This endpoint will read device cookie from request header **Auth-Trust-Id**. If device cookie not found, it will generate a new one and set it into response body **auth_trust_id** when successfully login. ## Track Login History This endpoint will track login history to detect suspicious login activity, please provide **Device-Id** (alphanumeric) in request header parameter otherwise it will set to &#34;unknown&#34;. Align with General Data Protection Regulation in Europe, user login history will be kept within 28 days by default&#34; ## 2FA remember device To remember device for 2FA, should provide cookie: device_token or header: Device-Token ## Response note If it is a user token request and user hasn&#39;t accepted required legal policy, the field &lt;code&gt;is_comply&lt;/code&gt; will be false in response and responsed token will have no permission. action code: 10703
   */
  postOauthToken_v3(data) {
    const params = {};
    const url = "/iam/v3/oauth/token";
    const resultPromise = this.axiosInstance.post(url, import_sdk45.CodeGenUtil.getFormUrlEncodedData(data), {
      ...params,
      headers: { ...params.headers, "content-type": "application/x-www-form-urlencoded" }
    });
    return import_sdk45.Validate.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      TokenWithDeviceCookieResponseV3,
      "TokenWithDeviceCookieResponseV3"
    );
  }
  /**
   * This endpoint revokes a token. This endpoint requires authorized requests header with Basic Authentication from client that establish the token. action code: 10706
   */
  postOauthRevoke_v3(data) {
    const params = {};
    const url = "/iam/v3/oauth/revoke";
    const resultPromise = this.axiosInstance.post(url, import_sdk45.CodeGenUtil.getFormUrlEncodedData(data), {
      ...params,
      headers: { ...params.headers, "content-type": "application/x-www-form-urlencoded" }
    });
    return import_sdk45.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, import_zod180.z.unknown(), "z.unknown()");
  }
  /**
   * This endpoint requires all requests to have Authorization header set with Basic access authentication constructed from client id and client secret.
   */
  postOauthVerify_v3(data) {
    const params = {};
    const url = "/iam/v3/oauth/verify";
    const resultPromise = this.axiosInstance.post(url, import_sdk45.CodeGenUtil.getFormUrlEncodedData(data), {
      ...params,
      headers: { ...params.headers, "content-type": "application/x-www-form-urlencoded" }
    });
    return import_sdk45.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, TokenResponseV3, "TokenResponseV3");
  }
  /**
   * Send 2FA code This endpoint is used for sending 2FA code.
   */
  postOauthMfaCode_v3(data) {
    const params = {};
    const url = "/iam/v3/oauth/mfa/code";
    const resultPromise = this.axiosInstance.post(url, import_sdk45.CodeGenUtil.getFormUrlEncodedData(data), {
      ...params,
      headers: { ...params.headers, "content-type": "application/x-www-form-urlencoded" }
    });
    return import_sdk45.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, import_zod180.z.unknown(), "z.unknown()");
  }
  /**
   * Initializes OAuth2.0 authorization code flow The endpoint stores authorization request and redirects to login page with the authorization request id. The user can then do the authentication on the login page. The user will be redirected back to the requesting client with authorization code if successfully authenticated. Only authorization code flow supported by this endpoint, implicit flow is not supported. - **Authorize success**: redirects to login page with the following information: ?request_id={authorization_request_id} - **Authorize failure**: redirects to the given redirect uri with the following information: ?error={error_code}&amp;error_description={error description} For Public Client case, it&#39;s mandatory to fill **code_challenge** to avoid authorization code interception attack. Please refer to the RFC for more information about Proof Key for Code Exchange(PKCE): https://datatracker.ietf.org/doc/html/rfc7636 Following are the error code based on the specification: - invalid_request: The request is missing a required parameter, includes an invalid parameter value, includes a parameter more than once, or is otherwise malformed. - server_error: The authorization server encountered an unexpected condition that prevented it from fulfilling the request. - unauthorized_client: The client is not authorized to request a token using this method. - access_denied: The resource owner or authorization server denied the request. - invalid_scope: The requested scope is invalid, unknown, or malformed. - unsupported_response_type: The authorization server does not support obtaining a token using this method. - temporarily_unavailable: The authorization server is currently unable to handle the request due to a temporary overloading or maintenance of the server. Please refer to the RFC for more information about authorization code flow: https://tools.ietf.org/html/rfc6749#section-4.1 action code: 10701
   */
  getOauthAuthorize_v3(queryParams) {
    const params = {
      code_challenge_method: "plain",
      createHeadless: true,
      scope: "commerce account social publishing analytics",
      ...queryParams
    };
    const url = "/iam/v3/oauth/authorize";
    const resultPromise = this.axiosInstance.get(url, { params });
    return import_sdk45.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, import_zod180.z.unknown(), "z.unknown()");
  }
  /**
   * This endpoint returns information about an access token intended to be used by resource servers or other internal servers. This endpoint requires authorized requests header with valid basic or bearer token. action code : 10705
   */
  postOauthIntrospect_v3(data) {
    const params = {};
    const url = "/iam/v3/oauth/introspect";
    const resultPromise = this.axiosInstance.post(url, import_sdk45.CodeGenUtil.getFormUrlEncodedData(data), {
      ...params,
      headers: { ...params.headers, "content-type": "application/x-www-form-urlencoded" }
    });
    return import_sdk45.Validate.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      TokenIntrospectResponse,
      "TokenIntrospectResponse"
    );
  }
  /**
   * Verify 2FA code This endpoint is used for verifying 2FA code. ## 2FA remember device To remember device for 2FA, should provide cookie: device_token or header: Device-Token
   */
  postOauthMfaVerify_v3(data) {
    const params = {};
    const url = "/iam/v3/oauth/mfa/verify";
    const resultPromise = this.axiosInstance.post(url, import_sdk45.CodeGenUtil.getFormUrlEncodedData(data), {
      ...params,
      headers: { ...params.headers, "content-type": "application/x-www-form-urlencoded" }
    });
    return import_sdk45.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, TokenResponseV3, "TokenResponseV3");
  }
  /**
   * This endpoint will return a list of revoked users and revoked tokens. List of revoked tokens in bloom filter format. This endpoint requires all requests to have Authorization header set with Basic access authentication constructed from client id and client secret. The bloom filter uses MurmurHash3 algorithm for hashing the values action code : 10708
   */
  getOauthRevocationlist_v3() {
    const params = {};
    const url = "/iam/v3/oauth/revocationlist";
    const resultPromise = this.axiosInstance.get(url, { params });
    return import_sdk45.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, RevocationList, "RevocationList");
  }
  /**
   * Change 2FA method This endpoint is used for change 2FA method. Only enabled methods are accepted. Supported methods: - authenticator - backupCode - email
   */
  postOauthMfaFactorChange_v3(data) {
    const params = {};
    const url = "/iam/v3/oauth/mfa/factor/change";
    const resultPromise = this.axiosInstance.post(url, import_sdk45.CodeGenUtil.getFormUrlEncodedData(data), {
      ...params,
      headers: { ...params.headers, "content-type": "application/x-www-form-urlencoded" }
    });
    return import_sdk45.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, import_zod180.z.unknown(), "z.unknown()");
  }
  /**
   * # This endpoint is in ALPHA, avoid using this endpoint fow now, reach out to AB support for inquiries Simultaneous login flow. The primary goals of this project are to entitle players to authenticate on a native PC platform(Steam/Epic) and the PlayStation platform, link their accounts, and provide support for platform sync with a valid 3rd platform access token. ## Given a valid native ticket and empty simultaneous ticket, these cases will be failed - Native ticket&#39;s account is not linked AGS account yet - Native ticket&#39;s account is linked AGS account, but AGS account is not linked simultaneous platform yet - Native ticket&#39;s account is linked AGS account, AGS account is linked simultaneous platform but there is no available simultaneous token.(only if this platform is expected to store the platform token) ## Given a valid native ticket and empty simultaneous ticket, this case will be success - Native ticket&#39;s account already linked AGS account, this AGS account already linked simultaneous platform. There is valid simultaneous token.(this is required only when this simultaneous is expected to cache platform token) ## Given a valid native ticket token and valid simultaneous ticket, these cases will be failed #### Native ticket&#39;s account is already linked with AGS account - Native linked AGS account is linked this simultaneous platform but is different with simultaneous ticket&#39;s account - Native linked AGS account is not linked with simultaneous but has a linking history with simultaneous platform and it is different with simultaneous ticket&#39;s account #### Native ticket&#39;s account is not linked with AGS account and Simultaneous ticket&#39;s account is already linked wth AGS account - Simultaneous linked AGS account is linked this native platform but is different with native ticket&#39;s account - Simultaneous linked AGS account is not linked with native but has a linking history with native platform and it is different with native ticket&#39;s account ## Given a valid native ticket and valid simultaneous ticket, these cases will be success - Native ticket&#39;s account &amp; Simultaneous ticket&#39;s account are both not linked to AGS account yet - Native ticket&#39;s account &amp; Simultaneous ticket&#39;s account are already linked to same AGS account
   */
  postOauthSimultaneousLogin_v3(data) {
    const params = {};
    const url = "/iam/v3/oauth/simultaneousLogin";
    const resultPromise = this.axiosInstance.post(url, import_sdk45.CodeGenUtil.getFormUrlEncodedData(data), {
      ...params,
      headers: { ...params.headers, "content-type": "application/x-www-form-urlencoded" }
    });
    return import_sdk45.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, TokenResponseV3, "TokenResponseV3");
  }
  /**
   * Platform token grant specifically used for performing token grant using platform, e.g. Steam, Justice, etc. The endpoint automatically create an account if the account associated with the platform is not exists yet. This endpoint requires all requests to have Authorization header set with Basic access authentication constructed from client id and client secret. For publisher-game namespace schema : Specify only either platform_token or device_id. Device token grant should be requested along with device_id parameter against game namespace. Another 3rd party platform token grant should be requested along with platform_token parameter against publisher namespace. ## 2FA remember device To remember device for 2FA, should provide cookie: device_token or header: Device-Token ## Supported platforms: - **steam**: The platform_token’s value is the binary ticket returned by Steam. If this ticket was generated by Steam GetAuthTicketForWebApi with version &gt;= 1.57, then platform token should use this style: &lt;code&gt;{identity}:{ticket}&lt;/code&gt;, the &lt;code&gt;{identity}&lt;/code&gt; was the parameter to call GetAuthTicketForWebApi when the ticket was created. Note: Do not contain &lt;code&gt;:&lt;/code&gt; in this &lt;code&gt;{identity}&lt;/code&gt;. - **steamopenid**: Steam&#39;s user authentication method using OpenID 2.0. The platform_token&#39;s value is URL generated by Steam on web authentication - **facebook**: The platform_token’s value is the authorization code returned by Facebook OAuth - **google**: The platform_token’s value is the authorization code or idToken returned by Google OAuth - **googleplaygames**: The platform_token’s value is the authorization code or idToken returned by Google play games OAuth - **oculus**: The platform_token’s value is a string composed of Oculus&#39;s user ID and the nonce separated by a colon (:). - **twitch**: The platform_token’s value is the authorization code returned by Twitch OAuth. - **discord**: The platform_token’s value is the authorization code returned by Discord OAuth - **android**: The device_id is the Android’s device ID - **ios**: The device_id is the iOS’s device ID. - **apple**: The platform_token’s value is the authorization code or idToken returned by Apple OAuth.(We will use this code to generate APP token) - **device**: Every device that does’nt run Android and iOS is categorized as a device. The device_id is the device’s ID. - **justice**: The platform_token’s value is the designated user’s access token. - **epicgames**: The platform_token’s value is an access-token or authorization code obtained from Epicgames EOS Account Service. - **ps4**: The platform_token’s value is the authorization code returned by Sony OAuth. - **ps5**: The platform_token’s value is the authorization code returned by Sony OAuth. - **nintendo**: The platform_token’s value is the id_token returned by Nintendo OAuth. - **awscognito**: The platform_token’s value is the aws cognito access token or id token (JWT). - **live**: The platform_token’s value is xbox XSTS token - **xblweb**: The platform_token’s value is code returned by xbox after login - **netflix**: The platform_token’s value is GAT (Gamer Access Token) returned by Netflix backend - **snapchat**: The platform_token’s value is the authorization code returned by Snapchat OAuth. - **for specific generic oauth (OIDC)**: The platform_token’s value should be the same type as created OIDC auth type whether it is auth code, idToken or bearerToken. ## Account Group Several platforms are grouped under account groups. The accounts on these platforms have the same platform user id. Login using one of these platform will returns the same IAM user. Following is the current registered account grouping: - Steam group(steamnetwork): - steam - steamopenid - PSN group(psn) - ps4web - ps4 - ps5 - XBOX group(xbox) - live - xblweb - Oculus group(oculusgroup) - oculus - oculusweb ## Access Token Content Following is the access token’s content: - **namespace**. It is the namespace the token was generated from. - **display_name**. The display name of the sub. It is empty if the token is generated from the client credential - **roles**. The sub’s roles. It is empty if the token is generated from the client credential - **namespace_roles**. The sub’s roles scoped to namespace. Improvement from roles, which make the role scoped to specific namespace instead of global to publisher namespace - **permissions**. The sub or aud’ permissions - **bans**. The sub’s list of bans. It is used by the IAM client for validating the token. - **jflgs**. It stands for Justice Flags. It is a special flag used for storing additional status information regarding the sub. It is implemented as a bit mask. Following explains what each bit represents: - 1: Email Address Verified - 2: Phone Number Verified - 4: Anonymous - 8: Suspicious Login - **aud**. The aud is the client ID. - **iat**. The time the token issues at. It is in Epoch time format - **exp**. The time the token expires. It is in Epoch time format - **sub**. The UserID. The sub is omitted if the token is generated from client credential ## Bans The JWT contains user&#39;s active bans with its expiry date. List of ban types can be obtained from /bans. action code : 10704
   */
  postTokenOauth_ByPlatformId_v3(platformId, data) {
    const params = {};
    const url = "/iam/v3/oauth/platforms/{platformId}/token".replace("{platformId}", platformId);
    const resultPromise = this.axiosInstance.post(url, import_sdk45.CodeGenUtil.getFormUrlEncodedData(data), {
      ...params,
      headers: { ...params.headers, "content-type": "application/x-www-form-urlencoded" }
    });
    return import_sdk45.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, TokenResponse, "TokenResponse");
  }
  /**
   * Generate url to request auth code from third party platform ## Supported platforms: - **steamopenid**This endpoint redirects to steam login page, then redirect back to platform authenticate endpoint after successfully authenticating user steam. - **xblweb**This endpoint redirects to xbox login page, then redirect back to platform authenticate endpoint after successfully authenticating xbox user. - **ps4web**This endpoint redirects to psn login page, then redirect back to platform authenticate endpoint after successfully authenticating psn user. - **epicgames**This endpoint redirects to Epicgames OAuth login page. then redirect to platform authenticate endpoint after successfully authenticating an Epicgames credential - **twitch**This endpoint redirects to twitch login page, then redirect back to platform authenticate endpoint after successfully authenticating twitch user. - **azure**This endpoint redirects to azure login page, then redirect back to platform authenticate(saml) endpoint after successfully authenticating azure user. - **facebook**This endpoint redirects to facebook login page, then redirect back to platform authenticate endpoint after successfully authenticating facebook user. - **google**This endpoint redirects to google login page, then redirect back to platform authenticate endpoint after successfully authenticating google user. - **snapchat**This endpoint redirects to snapchat login page, then redirect back to platform authenticate endpoint after successfully authenticating snapchat user. - **discord**This endpoint redirects to discord login page, then redirect back to platform authenticate endpoint after successfully authenticating discord user. - **amazon**This endpoint redirects to amazon login page, then redirect back to platform authenticate endpoint after successfully authenticating amazon user. - **oculusweb**This endpoint redirects to oculus login page, then redirect back to Login Website page after successfully authenticating oculus user. action code : 10702&#39;
   */
  getAuthorizeOauth_ByPlatformId_v3(platformId, queryParams) {
    const params = { ...queryParams };
    const url = "/iam/v3/oauth/platforms/{platformId}/authorize".replace("{platformId}", platformId);
    const resultPromise = this.axiosInstance.get(url, { params });
    return import_sdk45.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, import_zod180.z.unknown(), "z.unknown()");
  }
  /**
   * Retrieve User Third Party Platform Token This endpoint used for retrieving third party platform token for user that login using third party, if user have not link requested platform in game namespace, will try to retrieving third party platform token from publisher namespace. Passing platform group name or it&#39;s member will return same access token that can be used across the platform members. The third party platform and platform group covered for this is: - (psn) ps4web - (psn) ps4 - (psn) ps5 - epicgames - twitch - awscognito - &lt;amazon/li&gt; - eaorigin - snapchat - twitch - live **Authentication:** The _**userId**_ parameter should match the one in the access token.
   */
  getPlatformTokenOauth_ByUserId_ByPlatformId_v3(userId, platformId) {
    const params = {};
    const url = "/iam/v3/oauth/namespaces/{namespace}/users/{userId}/platforms/{platformId}/platformToken".replace("{namespace}", this.namespace).replace("{userId}", userId).replace("{platformId}", platformId);
    const resultPromise = this.axiosInstance.get(url, { params });
    return import_sdk45.Validate.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      TokenThirdPartyResponse,
      "TokenThirdPartyResponse"
    );
  }
};

// src/generated-public/OAuth20Api.ts
function OAuth20Api(sdk, args) {
  const sdkAssembly = sdk.assembly();
  const namespace = args?.coreConfig?.namespace ?? sdkAssembly.coreConfig.namespace;
  const useSchemaValidation = args?.coreConfig?.useSchemaValidation ?? sdkAssembly.coreConfig.useSchemaValidation;
  let axiosInstance = sdkAssembly.axiosInstance;
  const requestConfigOverrides = args?.axiosConfig?.request;
  const baseURLOverride = args?.coreConfig?.baseURL;
  const interceptorsOverride = args?.axiosConfig?.interceptors ?? [];
  if (requestConfigOverrides || baseURLOverride || interceptorsOverride.length > 0) {
    const requestConfig = import_sdk46.ApiUtils.mergeAxiosConfigs(sdkAssembly.axiosInstance.defaults, {
      ...baseURLOverride ? { baseURL: baseURLOverride } : {},
      ...requestConfigOverrides
    });
    axiosInstance = import_sdk46.Network.create(requestConfig);
    for (const interceptor of interceptorsOverride) {
      if (interceptor.type === "request") {
        axiosInstance.interceptors.request.use(interceptor.onRequest, interceptor.onError);
      }
      if (interceptor.type === "response") {
        axiosInstance.interceptors.response.use(interceptor.onSuccess, interceptor.onError);
      }
    }
  }
  async function getOauthJwks_v3() {
    const $ = new OAuth20$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getOauthJwks_v3();
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function postOauthToken_v3(data) {
    const $ = new OAuth20$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.postOauthToken_v3(data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function postOauthRevoke_v3(data) {
    const $ = new OAuth20$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.postOauthRevoke_v3(data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function postOauthVerify_v3(data) {
    const $ = new OAuth20$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.postOauthVerify_v3(data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function postOauthMfaCode_v3(data) {
    const $ = new OAuth20$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.postOauthMfaCode_v3(data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getOauthAuthorize_v3(queryParams) {
    const $ = new OAuth20$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getOauthAuthorize_v3(queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function postOauthIntrospect_v3(data) {
    const $ = new OAuth20$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.postOauthIntrospect_v3(data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function postOauthMfaVerify_v3(data) {
    const $ = new OAuth20$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.postOauthMfaVerify_v3(data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getOauthRevocationlist_v3() {
    const $ = new OAuth20$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getOauthRevocationlist_v3();
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function postOauthMfaFactorChange_v3(data) {
    const $ = new OAuth20$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.postOauthMfaFactorChange_v3(data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function postOauthSimultaneousLogin_v3(data) {
    const $ = new OAuth20$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.postOauthSimultaneousLogin_v3(data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function postTokenOauth_ByPlatformId_v3(platformId, data) {
    const $ = new OAuth20$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.postTokenOauth_ByPlatformId_v3(platformId, data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getAuthorizeOauth_ByPlatformId_v3(platformId, queryParams) {
    const $ = new OAuth20$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getAuthorizeOauth_ByPlatformId_v3(platformId, queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getPlatformTokenOauth_ByUserId_ByPlatformId_v3(userId, platformId) {
    const $ = new OAuth20$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getPlatformTokenOauth_ByUserId_ByPlatformId_v3(userId, platformId);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  return {
    /**
     * This endpoint serves public keys for verifying JWT access tokens generated by this service. When a client application wants to verify a JWT token, it needs to get the &#39;kid&#39; value found in the JWT token header and use it to look up the corresponding public key from a set returned by this endpoint. The client application can then use that public key to verify the JWT. A client application might cache the keys so it doesn&#39;t need to do request every time it needs to verify a JWT token. If a client application caches the keys and a key with the same &#39;kid&#39; cannot be found in the cache, it should then try to refresh the keys by making a request to this endpoint again. Please refer to the RFC for more information about JWK (JSON Web Key): https://tools.ietf.org/html/rfc7517 action code : 10709
     */
    getOauthJwks_v3,
    /**
     * This endpoint supports grant type: 1. Grant Type == &lt;code&gt;authorization_code&lt;/code&gt;: It generates the user token by given the authorization code which generated in &#34;/iam/v3/authenticate&#34; API response. It should also pass in the redirect_uri, which should be the same as generating the authorization code request. 2. Grant Type == &lt;code&gt;password&lt;/code&gt;: The grant type to use for authenticating a user, whether it&#39;s by email / username and password combination or through platform. 3. Grant Type == &lt;code&gt;refresh_token&lt;/code&gt;: Used to get a new access token for a valid refresh token. 4. Grant Type == &lt;code&gt;client_credentials&lt;/code&gt;: It generates a token by checking the client credentials provided through Authorization header. 5. Grant Type == &lt;code&gt;urn:ietf:params:oauth:grant-type:extend_client_credentials&lt;/code&gt;: It generates a token by checking the client credentials provided through Authorization header. It only allows publisher/studio namespace client. In generated token: 1. There wil be no roles, namespace_roles &amp; permission. 2. The scope will be fixed as &#39;extend&#39;. 3. There will have a new field &#39;extend_namespace&#39;, the value is from token request body. ## Access Token Content Following is the access token’s content: - **namespace**. It is the namespace the token was generated from. - **display_name**. The display name of the sub. It is empty if the token is generated from the client credential - **roles**. The sub’s roles. It is empty if the token is generated from the client credential - **namespace_roles**. The sub’s roles scoped to namespace. Improvement from roles, which make the role scoped to specific namespace instead of global to publisher namespace - **permissions**. The sub or aud’ permissions - **bans**. The sub’s list of bans. It is used by the IAM client for validating the token. - **jflgs**. It stands for Justice Flags. It is a special flag used for storing additional status information regarding the sub. It is implemented as a bit mask. Following explains what each bit represents: - 1: Email Address Verified - 2: Phone Number Verified - 4: Anonymous - 8: Suspicious Login - **aud**. The aud is the targeted resource server. - **iat**. The time the token issues at. It is in Epoch time format - **exp**. The time the token expires. It is in Epoch time format - **client_id**. The UserID. The sub is omitted if the token is generated from client credential - **scope**. The scope of the access request, expressed as a list of space-delimited, case-sensitive strings ## Bans The JWT contains user&#39;s active bans with its expiry date. List of ban types can be obtained from /bans. ## Device Cookie Validation _**For grant type &#34;password&#34; only**_ Device Cookie is used to protect the user account from brute force login attack, &lt;a target=&#34;_blank&#34; href=&#34;https://owasp.org/www-community/Slow_Down_Online_Guessing_Attacks_with_Device_Cookies&#34;&gt;more detail from OWASP&lt;a&gt;. This endpoint will read device cookie from request header **Auth-Trust-Id**. If device cookie not found, it will generate a new one and set it into response body **auth_trust_id** when successfully login. ## Track Login History This endpoint will track login history to detect suspicious login activity, please provide **Device-Id** (alphanumeric) in request header parameter otherwise it will set to &#34;unknown&#34;. Align with General Data Protection Regulation in Europe, user login history will be kept within 28 days by default&#34; ## 2FA remember device To remember device for 2FA, should provide cookie: device_token or header: Device-Token ## Response note If it is a user token request and user hasn&#39;t accepted required legal policy, the field &lt;code&gt;is_comply&lt;/code&gt; will be false in response and responsed token will have no permission. action code: 10703
     */
    postOauthToken_v3,
    /**
     * This endpoint revokes a token. This endpoint requires authorized requests header with Basic Authentication from client that establish the token. action code: 10706
     */
    postOauthRevoke_v3,
    /**
     * This endpoint requires all requests to have Authorization header set with Basic access authentication constructed from client id and client secret.
     */
    postOauthVerify_v3,
    /**
     * Send 2FA code This endpoint is used for sending 2FA code.
     */
    postOauthMfaCode_v3,
    /**
     * Initializes OAuth2.0 authorization code flow The endpoint stores authorization request and redirects to login page with the authorization request id. The user can then do the authentication on the login page. The user will be redirected back to the requesting client with authorization code if successfully authenticated. Only authorization code flow supported by this endpoint, implicit flow is not supported. - **Authorize success**: redirects to login page with the following information: ?request_id={authorization_request_id} - **Authorize failure**: redirects to the given redirect uri with the following information: ?error={error_code}&amp;error_description={error description} For Public Client case, it&#39;s mandatory to fill **code_challenge** to avoid authorization code interception attack. Please refer to the RFC for more information about Proof Key for Code Exchange(PKCE): https://datatracker.ietf.org/doc/html/rfc7636 Following are the error code based on the specification: - invalid_request: The request is missing a required parameter, includes an invalid parameter value, includes a parameter more than once, or is otherwise malformed. - server_error: The authorization server encountered an unexpected condition that prevented it from fulfilling the request. - unauthorized_client: The client is not authorized to request a token using this method. - access_denied: The resource owner or authorization server denied the request. - invalid_scope: The requested scope is invalid, unknown, or malformed. - unsupported_response_type: The authorization server does not support obtaining a token using this method. - temporarily_unavailable: The authorization server is currently unable to handle the request due to a temporary overloading or maintenance of the server. Please refer to the RFC for more information about authorization code flow: https://tools.ietf.org/html/rfc6749#section-4.1 action code: 10701
     */
    getOauthAuthorize_v3,
    /**
     * This endpoint returns information about an access token intended to be used by resource servers or other internal servers. This endpoint requires authorized requests header with valid basic or bearer token. action code : 10705
     */
    postOauthIntrospect_v3,
    /**
     * Verify 2FA code This endpoint is used for verifying 2FA code. ## 2FA remember device To remember device for 2FA, should provide cookie: device_token or header: Device-Token
     */
    postOauthMfaVerify_v3,
    /**
     * This endpoint will return a list of revoked users and revoked tokens. List of revoked tokens in bloom filter format. This endpoint requires all requests to have Authorization header set with Basic access authentication constructed from client id and client secret. The bloom filter uses MurmurHash3 algorithm for hashing the values action code : 10708
     */
    getOauthRevocationlist_v3,
    /**
     * Change 2FA method This endpoint is used for change 2FA method. Only enabled methods are accepted. Supported methods: - authenticator - backupCode - email
     */
    postOauthMfaFactorChange_v3,
    /**
     * # This endpoint is in ALPHA, avoid using this endpoint fow now, reach out to AB support for inquiries Simultaneous login flow. The primary goals of this project are to entitle players to authenticate on a native PC platform(Steam/Epic) and the PlayStation platform, link their accounts, and provide support for platform sync with a valid 3rd platform access token. ## Given a valid native ticket and empty simultaneous ticket, these cases will be failed - Native ticket&#39;s account is not linked AGS account yet - Native ticket&#39;s account is linked AGS account, but AGS account is not linked simultaneous platform yet - Native ticket&#39;s account is linked AGS account, AGS account is linked simultaneous platform but there is no available simultaneous token.(only if this platform is expected to store the platform token) ## Given a valid native ticket and empty simultaneous ticket, this case will be success - Native ticket&#39;s account already linked AGS account, this AGS account already linked simultaneous platform. There is valid simultaneous token.(this is required only when this simultaneous is expected to cache platform token) ## Given a valid native ticket token and valid simultaneous ticket, these cases will be failed #### Native ticket&#39;s account is already linked with AGS account - Native linked AGS account is linked this simultaneous platform but is different with simultaneous ticket&#39;s account - Native linked AGS account is not linked with simultaneous but has a linking history with simultaneous platform and it is different with simultaneous ticket&#39;s account #### Native ticket&#39;s account is not linked with AGS account and Simultaneous ticket&#39;s account is already linked wth AGS account - Simultaneous linked AGS account is linked this native platform but is different with native ticket&#39;s account - Simultaneous linked AGS account is not linked with native but has a linking history with native platform and it is different with native ticket&#39;s account ## Given a valid native ticket and valid simultaneous ticket, these cases will be success - Native ticket&#39;s account &amp; Simultaneous ticket&#39;s account are both not linked to AGS account yet - Native ticket&#39;s account &amp; Simultaneous ticket&#39;s account are already linked to same AGS account
     */
    postOauthSimultaneousLogin_v3,
    /**
     * Platform token grant specifically used for performing token grant using platform, e.g. Steam, Justice, etc. The endpoint automatically create an account if the account associated with the platform is not exists yet. This endpoint requires all requests to have Authorization header set with Basic access authentication constructed from client id and client secret. For publisher-game namespace schema : Specify only either platform_token or device_id. Device token grant should be requested along with device_id parameter against game namespace. Another 3rd party platform token grant should be requested along with platform_token parameter against publisher namespace. ## 2FA remember device To remember device for 2FA, should provide cookie: device_token or header: Device-Token ## Supported platforms: - **steam**: The platform_token’s value is the binary ticket returned by Steam. If this ticket was generated by Steam GetAuthTicketForWebApi with version &gt;= 1.57, then platform token should use this style: &lt;code&gt;{identity}:{ticket}&lt;/code&gt;, the &lt;code&gt;{identity}&lt;/code&gt; was the parameter to call GetAuthTicketForWebApi when the ticket was created. Note: Do not contain &lt;code&gt;:&lt;/code&gt; in this &lt;code&gt;{identity}&lt;/code&gt;. - **steamopenid**: Steam&#39;s user authentication method using OpenID 2.0. The platform_token&#39;s value is URL generated by Steam on web authentication - **facebook**: The platform_token’s value is the authorization code returned by Facebook OAuth - **google**: The platform_token’s value is the authorization code or idToken returned by Google OAuth - **googleplaygames**: The platform_token’s value is the authorization code or idToken returned by Google play games OAuth - **oculus**: The platform_token’s value is a string composed of Oculus&#39;s user ID and the nonce separated by a colon (:). - **twitch**: The platform_token’s value is the authorization code returned by Twitch OAuth. - **discord**: The platform_token’s value is the authorization code returned by Discord OAuth - **android**: The device_id is the Android’s device ID - **ios**: The device_id is the iOS’s device ID. - **apple**: The platform_token’s value is the authorization code or idToken returned by Apple OAuth.(We will use this code to generate APP token) - **device**: Every device that does’nt run Android and iOS is categorized as a device. The device_id is the device’s ID. - **justice**: The platform_token’s value is the designated user’s access token. - **epicgames**: The platform_token’s value is an access-token or authorization code obtained from Epicgames EOS Account Service. - **ps4**: The platform_token’s value is the authorization code returned by Sony OAuth. - **ps5**: The platform_token’s value is the authorization code returned by Sony OAuth. - **nintendo**: The platform_token’s value is the id_token returned by Nintendo OAuth. - **awscognito**: The platform_token’s value is the aws cognito access token or id token (JWT). - **live**: The platform_token’s value is xbox XSTS token - **xblweb**: The platform_token’s value is code returned by xbox after login - **netflix**: The platform_token’s value is GAT (Gamer Access Token) returned by Netflix backend - **snapchat**: The platform_token’s value is the authorization code returned by Snapchat OAuth. - **for specific generic oauth (OIDC)**: The platform_token’s value should be the same type as created OIDC auth type whether it is auth code, idToken or bearerToken. ## Account Group Several platforms are grouped under account groups. The accounts on these platforms have the same platform user id. Login using one of these platform will returns the same IAM user. Following is the current registered account grouping: - Steam group(steamnetwork): - steam - steamopenid - PSN group(psn) - ps4web - ps4 - ps5 - XBOX group(xbox) - live - xblweb - Oculus group(oculusgroup) - oculus - oculusweb ## Access Token Content Following is the access token’s content: - **namespace**. It is the namespace the token was generated from. - **display_name**. The display name of the sub. It is empty if the token is generated from the client credential - **roles**. The sub’s roles. It is empty if the token is generated from the client credential - **namespace_roles**. The sub’s roles scoped to namespace. Improvement from roles, which make the role scoped to specific namespace instead of global to publisher namespace - **permissions**. The sub or aud’ permissions - **bans**. The sub’s list of bans. It is used by the IAM client for validating the token. - **jflgs**. It stands for Justice Flags. It is a special flag used for storing additional status information regarding the sub. It is implemented as a bit mask. Following explains what each bit represents: - 1: Email Address Verified - 2: Phone Number Verified - 4: Anonymous - 8: Suspicious Login - **aud**. The aud is the client ID. - **iat**. The time the token issues at. It is in Epoch time format - **exp**. The time the token expires. It is in Epoch time format - **sub**. The UserID. The sub is omitted if the token is generated from client credential ## Bans The JWT contains user&#39;s active bans with its expiry date. List of ban types can be obtained from /bans. action code : 10704
     */
    postTokenOauth_ByPlatformId_v3,
    /**
     * Generate url to request auth code from third party platform ## Supported platforms: - **steamopenid**This endpoint redirects to steam login page, then redirect back to platform authenticate endpoint after successfully authenticating user steam. - **xblweb**This endpoint redirects to xbox login page, then redirect back to platform authenticate endpoint after successfully authenticating xbox user. - **ps4web**This endpoint redirects to psn login page, then redirect back to platform authenticate endpoint after successfully authenticating psn user. - **epicgames**This endpoint redirects to Epicgames OAuth login page. then redirect to platform authenticate endpoint after successfully authenticating an Epicgames credential - **twitch**This endpoint redirects to twitch login page, then redirect back to platform authenticate endpoint after successfully authenticating twitch user. - **azure**This endpoint redirects to azure login page, then redirect back to platform authenticate(saml) endpoint after successfully authenticating azure user. - **facebook**This endpoint redirects to facebook login page, then redirect back to platform authenticate endpoint after successfully authenticating facebook user. - **google**This endpoint redirects to google login page, then redirect back to platform authenticate endpoint after successfully authenticating google user. - **snapchat**This endpoint redirects to snapchat login page, then redirect back to platform authenticate endpoint after successfully authenticating snapchat user. - **discord**This endpoint redirects to discord login page, then redirect back to platform authenticate endpoint after successfully authenticating discord user. - **amazon**This endpoint redirects to amazon login page, then redirect back to platform authenticate endpoint after successfully authenticating amazon user. - **oculusweb**This endpoint redirects to oculus login page, then redirect back to Login Website page after successfully authenticating oculus user. action code : 10702&#39;
     */
    getAuthorizeOauth_ByPlatformId_v3,
    /**
     * Retrieve User Third Party Platform Token This endpoint used for retrieving third party platform token for user that login using third party, if user have not link requested platform in game namespace, will try to retrieving third party platform token from publisher namespace. Passing platform group name or it&#39;s member will return same access token that can be used across the platform members. The third party platform and platform group covered for this is: - (psn) ps4web - (psn) ps4 - (psn) ps5 - epicgames - twitch - awscognito - &lt;amazon/li&gt; - eaorigin - snapchat - twitch - live **Authentication:** The _**userId**_ parameter should match the one in the access token.
     */
    getPlatformTokenOauth_ByUserId_ByPlatformId_v3
  };
}

// src/generated-public/queries/OAuth20.query.ts
var Key_OAuth20 = /* @__PURE__ */ ((Key_OAuth202) => {
  Key_OAuth202["OauthJwks_v3"] = "Iam.OAuth20.OauthJwks_v3";
  Key_OAuth202["OauthToken_v3"] = "Iam.OAuth20.OauthToken_v3";
  Key_OAuth202["OauthRevoke_v3"] = "Iam.OAuth20.OauthRevoke_v3";
  Key_OAuth202["OauthVerify_v3"] = "Iam.OAuth20.OauthVerify_v3";
  Key_OAuth202["OauthMfaCode_v3"] = "Iam.OAuth20.OauthMfaCode_v3";
  Key_OAuth202["OauthAuthorize_v3"] = "Iam.OAuth20.OauthAuthorize_v3";
  Key_OAuth202["OauthIntrospect_v3"] = "Iam.OAuth20.OauthIntrospect_v3";
  Key_OAuth202["OauthMfaVerify_v3"] = "Iam.OAuth20.OauthMfaVerify_v3";
  Key_OAuth202["OauthRevocationlist_v3"] = "Iam.OAuth20.OauthRevocationlist_v3";
  Key_OAuth202["OauthMfaFactorChange_v3"] = "Iam.OAuth20.OauthMfaFactorChange_v3";
  Key_OAuth202["OauthSimultaneousLogin_v3"] = "Iam.OAuth20.OauthSimultaneousLogin_v3";
  Key_OAuth202["TokenOauth_ByPlatformId_v3"] = "Iam.OAuth20.TokenOauth_ByPlatformId_v3";
  Key_OAuth202["AuthorizeOauth_ByPlatformId_v3"] = "Iam.OAuth20.AuthorizeOauth_ByPlatformId_v3";
  Key_OAuth202["PlatformTokenOauth_ByUserId_ByPlatformId_v3"] = "Iam.OAuth20.PlatformTokenOauth_ByUserId_ByPlatformId_v3";
  return Key_OAuth202;
})(Key_OAuth20 || {});
var useOAuth20Api_GetOauthJwks_v3 = (sdk, input, options, callback) => {
  const queryFn = (sdk2, input2) => async () => {
    const response = await OAuth20Api(sdk2, { coreConfig: input2.coreConfig, axiosConfig: input2.axiosConfig }).getOauthJwks_v3();
    callback && callback(response);
    return response.data;
  };
  return (0, import_react_query23.useQuery)({
    queryKey: ["Iam.OAuth20.OauthJwks_v3" /* OauthJwks_v3 */, input],
    queryFn: queryFn(sdk, input),
    ...options
  });
};
var useOAuth20Api_PostOauthTokenMutation_v3 = (sdk, options, callback) => {
  const mutationFn = async (input) => {
    const response = await OAuth20Api(sdk, { coreConfig: input.coreConfig, axiosConfig: input.axiosConfig }).postOauthToken_v3(input.data);
    callback && callback(response.data);
    return response.data;
  };
  return (0, import_react_query23.useMutation)({
    mutationKey: ["Iam.OAuth20.OauthToken_v3" /* OauthToken_v3 */],
    mutationFn,
    ...options
  });
};
var useOAuth20Api_PostOauthRevokeMutation_v3 = (sdk, options, callback) => {
  const mutationFn = async (input) => {
    const response = await OAuth20Api(sdk, { coreConfig: input.coreConfig, axiosConfig: input.axiosConfig }).postOauthRevoke_v3(input.data);
    callback && callback(response.data);
    return response.data;
  };
  return (0, import_react_query23.useMutation)({
    mutationKey: ["Iam.OAuth20.OauthRevoke_v3" /* OauthRevoke_v3 */],
    mutationFn,
    ...options
  });
};
var useOAuth20Api_PostOauthVerifyMutation_v3 = (sdk, options, callback) => {
  const mutationFn = async (input) => {
    const response = await OAuth20Api(sdk, { coreConfig: input.coreConfig, axiosConfig: input.axiosConfig }).postOauthVerify_v3(input.data);
    callback && callback(response.data);
    return response.data;
  };
  return (0, import_react_query23.useMutation)({
    mutationKey: ["Iam.OAuth20.OauthVerify_v3" /* OauthVerify_v3 */],
    mutationFn,
    ...options
  });
};
var useOAuth20Api_PostOauthMfaCodeMutation_v3 = (sdk, options, callback) => {
  const mutationFn = async (input) => {
    const response = await OAuth20Api(sdk, { coreConfig: input.coreConfig, axiosConfig: input.axiosConfig }).postOauthMfaCode_v3(input.data);
    callback && callback(response.data);
    return response.data;
  };
  return (0, import_react_query23.useMutation)({
    mutationKey: ["Iam.OAuth20.OauthMfaCode_v3" /* OauthMfaCode_v3 */],
    mutationFn,
    ...options
  });
};
var useOAuth20Api_GetOauthAuthorize_v3 = (sdk, input, options, callback) => {
  const queryFn = (sdk2, input2) => async () => {
    const response = await OAuth20Api(sdk2, { coreConfig: input2.coreConfig, axiosConfig: input2.axiosConfig }).getOauthAuthorize_v3(
      input2.queryParams
    );
    callback && callback(response);
    return response.data;
  };
  return (0, import_react_query23.useQuery)({
    queryKey: ["Iam.OAuth20.OauthAuthorize_v3" /* OauthAuthorize_v3 */, input],
    queryFn: queryFn(sdk, input),
    ...options
  });
};
var useOAuth20Api_PostOauthIntrospectMutation_v3 = (sdk, options, callback) => {
  const mutationFn = async (input) => {
    const response = await OAuth20Api(sdk, { coreConfig: input.coreConfig, axiosConfig: input.axiosConfig }).postOauthIntrospect_v3(
      input.data
    );
    callback && callback(response.data);
    return response.data;
  };
  return (0, import_react_query23.useMutation)({
    mutationKey: ["Iam.OAuth20.OauthIntrospect_v3" /* OauthIntrospect_v3 */],
    mutationFn,
    ...options
  });
};
var useOAuth20Api_PostOauthMfaVerifyMutation_v3 = (sdk, options, callback) => {
  const mutationFn = async (input) => {
    const response = await OAuth20Api(sdk, { coreConfig: input.coreConfig, axiosConfig: input.axiosConfig }).postOauthMfaVerify_v3(
      input.data
    );
    callback && callback(response.data);
    return response.data;
  };
  return (0, import_react_query23.useMutation)({
    mutationKey: ["Iam.OAuth20.OauthMfaVerify_v3" /* OauthMfaVerify_v3 */],
    mutationFn,
    ...options
  });
};
var useOAuth20Api_GetOauthRevocationlist_v3 = (sdk, input, options, callback) => {
  const queryFn = (sdk2, input2) => async () => {
    const response = await OAuth20Api(sdk2, { coreConfig: input2.coreConfig, axiosConfig: input2.axiosConfig }).getOauthRevocationlist_v3();
    callback && callback(response);
    return response.data;
  };
  return (0, import_react_query23.useQuery)({
    queryKey: ["Iam.OAuth20.OauthRevocationlist_v3" /* OauthRevocationlist_v3 */, input],
    queryFn: queryFn(sdk, input),
    ...options
  });
};
var useOAuth20Api_PostOauthMfaFactorChangeMutation_v3 = (sdk, options, callback) => {
  const mutationFn = async (input) => {
    const response = await OAuth20Api(sdk, { coreConfig: input.coreConfig, axiosConfig: input.axiosConfig }).postOauthMfaFactorChange_v3(
      input.data
    );
    callback && callback(response.data);
    return response.data;
  };
  return (0, import_react_query23.useMutation)({
    mutationKey: ["Iam.OAuth20.OauthMfaFactorChange_v3" /* OauthMfaFactorChange_v3 */],
    mutationFn,
    ...options
  });
};
var useOAuth20Api_PostOauthSimultaneousLoginMutation_v3 = (sdk, options, callback) => {
  const mutationFn = async (input) => {
    const response = await OAuth20Api(sdk, { coreConfig: input.coreConfig, axiosConfig: input.axiosConfig }).postOauthSimultaneousLogin_v3(
      input.data
    );
    callback && callback(response.data);
    return response.data;
  };
  return (0, import_react_query23.useMutation)({
    mutationKey: ["Iam.OAuth20.OauthSimultaneousLogin_v3" /* OauthSimultaneousLogin_v3 */],
    mutationFn,
    ...options
  });
};
var useOAuth20Api_PostTokenOauth_ByPlatformIdMutation_v3 = (sdk, options, callback) => {
  const mutationFn = async (input) => {
    const response = await OAuth20Api(sdk, { coreConfig: input.coreConfig, axiosConfig: input.axiosConfig }).postTokenOauth_ByPlatformId_v3(
      input.platformId,
      input.data
    );
    callback && callback(response.data);
    return response.data;
  };
  return (0, import_react_query23.useMutation)({
    mutationKey: ["Iam.OAuth20.TokenOauth_ByPlatformId_v3" /* TokenOauth_ByPlatformId_v3 */],
    mutationFn,
    ...options
  });
};
var useOAuth20Api_GetAuthorizeOauth_ByPlatformId_v3 = (sdk, input, options, callback) => {
  const queryFn = (sdk2, input2) => async () => {
    const response = await OAuth20Api(sdk2, {
      coreConfig: input2.coreConfig,
      axiosConfig: input2.axiosConfig
    }).getAuthorizeOauth_ByPlatformId_v3(input2.platformId, input2.queryParams);
    callback && callback(response);
    return response.data;
  };
  return (0, import_react_query23.useQuery)({
    queryKey: ["Iam.OAuth20.AuthorizeOauth_ByPlatformId_v3" /* AuthorizeOauth_ByPlatformId_v3 */, input],
    queryFn: queryFn(sdk, input),
    ...options
  });
};
var useOAuth20Api_GetPlatformTokenOauth_ByUserId_ByPlatformId_v3 = (sdk, input, options, callback) => {
  const queryFn = (sdk2, input2) => async () => {
    const response = await OAuth20Api(sdk2, {
      coreConfig: input2.coreConfig,
      axiosConfig: input2.axiosConfig
    }).getPlatformTokenOauth_ByUserId_ByPlatformId_v3(input2.userId, input2.platformId);
    callback && callback(response);
    return response.data;
  };
  return (0, import_react_query23.useQuery)({
    queryKey: ["Iam.OAuth20.PlatformTokenOauth_ByUserId_ByPlatformId_v3" /* PlatformTokenOauth_ByUserId_ByPlatformId_v3 */, input],
    queryFn: queryFn(sdk, input),
    ...options
  });
};

// src/generated-public/queries/OAuth20Extension.query.ts
var import_react_query24 = require("@tanstack/react-query");

// src/generated-public/OAuth20ExtensionApi.ts
var import_sdk48 = require("@accelbyte/sdk");

// src/generated-public/endpoints/OAuth20Extension$.ts
var import_sdk47 = require("@accelbyte/sdk");
var import_zod186 = require("zod");

// src/generated-definitions/CountryLocationResponse.ts
var import_zod181 = require("zod");
var CountryLocationResponse = import_zod181.z.object({ city: import_zod181.z.string(), countryCode: import_zod181.z.string(), countryName: import_zod181.z.string(), state: import_zod181.z.string() });

// src/generated-definitions/OneTimeLinkingCodeResponse.ts
var import_zod182 = require("zod");
var OneTimeLinkingCodeResponse = import_zod182.z.object({ exp: import_zod182.z.number().int(), oneTimeLinkCode: import_zod182.z.string(), oneTimeLinkUrl: import_zod182.z.string() });

// src/generated-definitions/OneTimeLinkingCodeValidationResponse.ts
var import_zod183 = require("zod");
var OneTimeLinkingCodeValidationResponse = import_zod183.z.object({ expired: import_zod183.z.boolean(), valid: import_zod183.z.boolean() });

// src/generated-definitions/PlatformTokenRefreshResponseV3.ts
var import_zod184 = require("zod");
var PlatformTokenRefreshResponseV3 = import_zod184.z.object({
  avatarUrl: import_zod184.z.string().nullish(),
  country: import_zod184.z.string().nullish(),
  displayName: import_zod184.z.string().nullish(),
  platformTokenExpiresAt: import_zod184.z.number().int().nullish(),
  platformUserId: import_zod184.z.string().nullish()
});

// src/generated-definitions/TargetTokenCodeResponse.ts
var import_zod185 = require("zod");
var TargetTokenCodeResponse = import_zod185.z.object({ code: import_zod185.z.string() });

// src/generated-public/endpoints/OAuth20Extension$.ts
var OAuth20Extension$ = class {
  // @ts-ignore
  // prettier-ignore
  constructor(axiosInstance, namespace, useSchemaValidation = true) {
    this.axiosInstance = axiosInstance;
    this.namespace = namespace;
    this.useSchemaValidation = useSchemaValidation;
  }
  /**
   * This endpoint is used to remove **access_token**, **refresh_token** from cookie.
   */
  createLogout_v3() {
    const params = {};
    const url = "/iam/v3/logout";
    const resultPromise = this.axiosInstance.post(url, null, { params });
    return import_sdk47.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, import_zod186.z.unknown(), "z.unknown()");
  }
  /**
   * This endpoint is being used to authenticate a user account. It validates user&#39;s email / username and password. Deactivated or login-banned users are unable to login. Redirect URI and Client ID must be specified as a pair and only used to redirect to the specified redirect URI in case the requestId is no longer valid. ## Device Cookie Validation Device Cookie is used to protect the user account from brute force login attack, [more detail from OWASP](https://owasp.org/www-community/Slow_Down_Online_Guessing_Attacks_with_Device_Cookies). This endpoint will read device cookie from cookie **auth-trust-id**. If device cookie not found, it will generate a new one and set it into cookie when successfully authenticate. Action code: 10801
   */
  postAuthenticate_v3(data) {
    const params = {};
    const url = "/iam/v3/authenticate";
    const resultPromise = this.axiosInstance.post(url, import_sdk47.CodeGenUtil.getFormUrlEncodedData(data), {
      ...params,
      headers: { ...params.headers, "content-type": "application/x-www-form-urlencoded" }
    });
    return import_sdk47.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, import_zod186.z.unknown(), "z.unknown()");
  }
  /**
   * This endpoint is being used to create headless account after 3rd platform authenticated, and response token . The &#39;linkingToken&#39; in request body is received from &#34;/platforms/{platformId}/token&#34; when 3rd platform account is not linked to justice account yet.
   */
  postHeadlesToken_v3(data) {
    const params = {};
    const url = "/iam/v3/headless/token";
    const resultPromise = this.axiosInstance.post(url, import_sdk47.CodeGenUtil.getFormUrlEncodedData(data), {
      ...params,
      headers: { ...params.headers, "content-type": "application/x-www-form-urlencoded" }
    });
    return import_sdk47.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, TokenResponseV3, "TokenResponseV3");
  }
  /**
   * This endpoint is being used to generate target token. It requires basic header with ClientID and Secret, it should match the ClientID when call &lt;code&gt;/iam/v3/namespace/{namespace}/token/request&lt;/code&gt; The code should be generated from &lt;code&gt;/iam/v3/namespace/{namespace}/token/request&lt;/code&gt;.
   */
  postTokenExchange_v3(data) {
    const params = {};
    const url = "/iam/v3/token/exchange";
    const resultPromise = this.axiosInstance.post(url, import_sdk47.CodeGenUtil.getFormUrlEncodedData(data), {
      ...params,
      headers: { ...params.headers, "content-type": "application/x-www-form-urlencoded" }
    });
    return import_sdk47.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, TokenResponseV3, "TokenResponseV3");
  }
  /**
   * This endpoint get country location based on the request.
   */
  getLocationCountry_v3() {
    const params = {};
    const url = "/iam/v3/location/country";
    const resultPromise = this.axiosInstance.get(url, { params });
    return import_sdk47.Validate.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      CountryLocationResponse,
      "CountryLocationResponse"
    );
  }
  /**
   * This endpoint is being used to request the one time code [8 length] for headless account to link or upgrade to a full account. Should specify the target platform id and current user should already linked to this platform. Current user should be a headless account. ## Supported platforms: - **steam** - **steamopenid** - **facebook** - **google** - **googleplaygames** - **oculus** - **twitch** - **discord** - **android** - **ios** - **apple** - **device** - **justice** - **epicgames** - **ps4** - **ps5** - **nintendo** - **awscognito** - **live** - **xblweb** - **netflix** - **snapchat**
   */
  postLinkCodeRequest_v3(data) {
    const params = {};
    const url = "/iam/v3/link/code/request";
    const resultPromise = this.axiosInstance.post(url, import_sdk47.CodeGenUtil.getFormUrlEncodedData(data), {
      ...params,
      headers: { ...params.headers, "content-type": "application/x-www-form-urlencoded" }
    });
    return import_sdk47.Validate.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      OneTimeLinkingCodeResponse,
      "OneTimeLinkingCodeResponse"
    );
  }
  /**
   * This endpoint is being used to validate one time link code.
   */
  postLinkCodeValidate_v3(data) {
    const params = {};
    const url = "/iam/v3/link/code/validate";
    const resultPromise = this.axiosInstance.post(url, import_sdk47.CodeGenUtil.getFormUrlEncodedData(data), {
      ...params,
      headers: { ...params.headers, "content-type": "application/x-www-form-urlencoded" }
    });
    return import_sdk47.Validate.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      OneTimeLinkingCodeValidationResponse,
      "OneTimeLinkingCodeValidationResponse"
    );
  }
  /**
   * This endpoint is being used to generate user&#39;s token by one time link code. It require publisher ClientID It required a code which can be generated from &lt;code&gt;/iam/v3/link/code/request&lt;/code&gt;. This endpoint support creating transient token by utilizing **isTransient** param: **isTransient=true** will generate a transient token with a short Time Expiration and without a refresh token **isTransient=false** will consume the one-time code and generate the access token with a refresh token.
   */
  postLinkTokenExchange_v3(data) {
    const params = {};
    const url = "/iam/v3/link/token/exchange";
    const resultPromise = this.axiosInstance.post(url, import_sdk47.CodeGenUtil.getFormUrlEncodedData(data), {
      ...params,
      headers: { ...params.headers, "content-type": "application/x-www-form-urlencoded" }
    });
    return import_sdk47.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, TokenResponseV3, "TokenResponseV3");
  }
  /**
   * This endpoint is being used to authenticate a user account and perform platform link. It validates user&#39;s email / username and password. If user already enable 2FA, then invoke _/mfa/verify_ using **mfa_token** from this endpoint response. ## Device Cookie Validation Device Cookie is used to protect the user account from brute force login attack, [more detail from OWASP](https://owasp.org/www-community/Slow_Down_Online_Guessing_Attacks_with_Device_Cookies). This endpoint will read device cookie from cookie **auth-trust-id**. If device cookie not found, it will generate a new one and set it into cookie when successfully authenticate.
   */
  postAuthenticateWithLink_v3(data) {
    const params = {};
    const url = "/iam/v3/authenticateWithLink";
    const resultPromise = this.axiosInstance.post(url, import_sdk47.CodeGenUtil.getFormUrlEncodedData(data), {
      ...params,
      headers: { ...params.headers, "content-type": "application/x-www-form-urlencoded" }
    });
    return import_sdk47.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, TokenResponseV3, "TokenResponseV3");
  }
  /**
   * This endpoint is being used to request the code to exchange a new token. The target new token&#39;s clientId should NOT be same with current using one. Path namespace should be target namespace. Client ID should match the target namespace. The code in response can be consumed by &lt;code&gt;/iam/v3/token/exchange&lt;/code&gt;
   */
  postTokenRequest_v3(data, queryParams) {
    const params = { code_challenge_method: "plain", ...queryParams };
    const url = "/iam/v3/namespace/{namespace}/token/request".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.post(url, import_sdk47.CodeGenUtil.getFormUrlEncodedData(data), {
      ...params,
      headers: { ...params.headers, "content-type": "application/x-www-form-urlencoded" }
    });
    return import_sdk47.Validate.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      TargetTokenCodeResponse,
      "TargetTokenCodeResponse"
    );
  }
  /**
   * This endpoint authenticates user platform. It validates user to its respective platforms. Deactivated or login-banned users are unable to login. If already linked with justice account or match SSO condition, will redirect to client&#39;s redirect url with code. then invoke &#39;/iam/v3/oauth/token&#39; with grant_type=authorization_code If already not linked with justice account and not match SSO condition, will redirect to client&#39;s account linking page ## Supported platforms: - **steamopenid**Steam login page will redirects to this endpoint after login success as previously defined on openID request parameter &lt;code&gt;openid.return_to&lt;/code&gt; when request login to steam https://openid.net/specs/openid-authentication-2_0.html#anchor27 - **ps4web**PS4 login page will redirects to this endpoint after login success as previously defined on authorize request parameter &lt;code&gt;redirect_uri&lt;/code&gt; https://ps4.siedev.net/resources/documents/WebAPI/1/Auth_WebAPI-Reference/0002.html#0GetAccessTokenUsingAuthorizationCode - **xblweb**XBL login page will redirects to this endpoint after login success as previously defined on authorize request parameter &lt;code&gt;redirect_uri&lt;/code&gt; - **epicgames**Epicgames login page will redirects to this endpoint after login success or an error occurred. If error, it redirects to the login page. - **twitch**Twitch login page will redirects to this endpoint after login success as previously defined on authorize request parameter &lt;code&gt;redirect_uri&lt;/code&gt; - **facebook**Facebook login page will redirects to this endpoint after login success as previously defined on authorize request parameter &lt;code&gt;redirect_uri&lt;/code&gt; - **google**Google login page will redirects to this endpoint after login success as previously defined on authorize request parameter &lt;code&gt;redirect_uri&lt;/code&gt; - **snapchat**Snapchat login page will redirects to this endpoint after login success as previously defined on authorize request parameter &lt;code&gt;redirect_uri&lt;/code&gt; - **discord**Discord login page will redirects to this endpoint after login success as previously defined on authorize request parameter &lt;code&gt;redirect_uri&lt;/code&gt; action code : 10709
   */
  getAuthenticate_ByPlatformId_v3(platformId, queryParams) {
    const params = { ...queryParams };
    const url = "/iam/v3/platforms/{platformId}/authenticate".replace("{platformId}", platformId);
    const resultPromise = this.axiosInstance.get(url, { params });
    return import_sdk47.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, import_zod186.z.unknown(), "z.unknown()");
  }
  /**
   * This endpoint will validate the third party platform token, for some platforms will also refresh the token stored in IAM, it will not generate any event or AB access/refresh token. This endpoint can be used by game client to refresh third party token if game client got platform token not found error, for example got 404 platform token not found from IAP/DLC. ## Platforms will refresh stored token: - **twitch**: The platform_token’s value is the authorization code returned by Twitch OAuth. - **epicgames**: The platform_token’s value is an access-token or authorization code obtained from Epicgames EOS Account Service. - **ps4**: The platform_token’s value is the authorization code returned by Sony OAuth. - **ps5**: The platform_token’s value is the authorization code returned by Sony OAuth. - **amazon**: The platform_token’s value is authorization code. - **awscognito**: The platform_token’s value is the aws cognito access token or id token (JWT). - **live**: The platform_token’s value is xbox XSTS token - **snapchat**: The platform_token’s value is the authorization code returned by Snapchat OAuth. - **for specific generic oauth (OIDC)**: The platform_token’s value should be the same type as created OIDC auth type whether it is auth code, idToken or bearerToken.
   */
  postTokenVerify_ByPlatformId_v3(platformId, data) {
    const params = {};
    const url = "/iam/v3/platforms/{platformId}/token/verify".replace("{platformId}", platformId);
    const resultPromise = this.axiosInstance.post(url, import_sdk47.CodeGenUtil.getFormUrlEncodedData(data), {
      ...params,
      headers: { ...params.headers, "content-type": "application/x-www-form-urlencoded" }
    });
    return import_sdk47.Validate.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      PlatformTokenRefreshResponseV3,
      "PlatformTokenRefreshResponseV3"
    );
  }
};

// src/generated-public/OAuth20ExtensionApi.ts
function OAuth20ExtensionApi(sdk, args) {
  const sdkAssembly = sdk.assembly();
  const namespace = args?.coreConfig?.namespace ?? sdkAssembly.coreConfig.namespace;
  const useSchemaValidation = args?.coreConfig?.useSchemaValidation ?? sdkAssembly.coreConfig.useSchemaValidation;
  let axiosInstance = sdkAssembly.axiosInstance;
  const requestConfigOverrides = args?.axiosConfig?.request;
  const baseURLOverride = args?.coreConfig?.baseURL;
  const interceptorsOverride = args?.axiosConfig?.interceptors ?? [];
  if (requestConfigOverrides || baseURLOverride || interceptorsOverride.length > 0) {
    const requestConfig = import_sdk48.ApiUtils.mergeAxiosConfigs(sdkAssembly.axiosInstance.defaults, {
      ...baseURLOverride ? { baseURL: baseURLOverride } : {},
      ...requestConfigOverrides
    });
    axiosInstance = import_sdk48.Network.create(requestConfig);
    for (const interceptor of interceptorsOverride) {
      if (interceptor.type === "request") {
        axiosInstance.interceptors.request.use(interceptor.onRequest, interceptor.onError);
      }
      if (interceptor.type === "response") {
        axiosInstance.interceptors.response.use(interceptor.onSuccess, interceptor.onError);
      }
    }
  }
  async function createLogout_v3() {
    const $ = new OAuth20Extension$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.createLogout_v3();
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function postAuthenticate_v3(data) {
    const $ = new OAuth20Extension$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.postAuthenticate_v3(data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function postHeadlesToken_v3(data) {
    const $ = new OAuth20Extension$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.postHeadlesToken_v3(data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function postTokenExchange_v3(data) {
    const $ = new OAuth20Extension$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.postTokenExchange_v3(data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getLocationCountry_v3() {
    const $ = new OAuth20Extension$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getLocationCountry_v3();
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function postLinkCodeRequest_v3(data) {
    const $ = new OAuth20Extension$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.postLinkCodeRequest_v3(data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function postLinkCodeValidate_v3(data) {
    const $ = new OAuth20Extension$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.postLinkCodeValidate_v3(data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function postLinkTokenExchange_v3(data) {
    const $ = new OAuth20Extension$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.postLinkTokenExchange_v3(data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function postAuthenticateWithLink_v3(data) {
    const $ = new OAuth20Extension$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.postAuthenticateWithLink_v3(data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function postTokenRequest_v3(data, queryParams) {
    const $ = new OAuth20Extension$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.postTokenRequest_v3(data, queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getAuthenticate_ByPlatformId_v3(platformId, queryParams) {
    const $ = new OAuth20Extension$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getAuthenticate_ByPlatformId_v3(platformId, queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function postTokenVerify_ByPlatformId_v3(platformId, data) {
    const $ = new OAuth20Extension$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.postTokenVerify_ByPlatformId_v3(platformId, data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  return {
    /**
     * This endpoint is used to remove **access_token**, **refresh_token** from cookie.
     */
    createLogout_v3,
    /**
     * This endpoint is being used to authenticate a user account. It validates user&#39;s email / username and password. Deactivated or login-banned users are unable to login. Redirect URI and Client ID must be specified as a pair and only used to redirect to the specified redirect URI in case the requestId is no longer valid. ## Device Cookie Validation Device Cookie is used to protect the user account from brute force login attack, [more detail from OWASP](https://owasp.org/www-community/Slow_Down_Online_Guessing_Attacks_with_Device_Cookies). This endpoint will read device cookie from cookie **auth-trust-id**. If device cookie not found, it will generate a new one and set it into cookie when successfully authenticate. Action code: 10801
     */
    postAuthenticate_v3,
    /**
     * This endpoint is being used to create headless account after 3rd platform authenticated, and response token . The &#39;linkingToken&#39; in request body is received from &#34;/platforms/{platformId}/token&#34; when 3rd platform account is not linked to justice account yet.
     */
    postHeadlesToken_v3,
    /**
     * This endpoint is being used to generate target token. It requires basic header with ClientID and Secret, it should match the ClientID when call &lt;code&gt;/iam/v3/namespace/{namespace}/token/request&lt;/code&gt; The code should be generated from &lt;code&gt;/iam/v3/namespace/{namespace}/token/request&lt;/code&gt;.
     */
    postTokenExchange_v3,
    /**
     * This endpoint get country location based on the request.
     */
    getLocationCountry_v3,
    /**
     * This endpoint is being used to request the one time code [8 length] for headless account to link or upgrade to a full account. Should specify the target platform id and current user should already linked to this platform. Current user should be a headless account. ## Supported platforms: - **steam** - **steamopenid** - **facebook** - **google** - **googleplaygames** - **oculus** - **twitch** - **discord** - **android** - **ios** - **apple** - **device** - **justice** - **epicgames** - **ps4** - **ps5** - **nintendo** - **awscognito** - **live** - **xblweb** - **netflix** - **snapchat**
     */
    postLinkCodeRequest_v3,
    /**
     * This endpoint is being used to validate one time link code.
     */
    postLinkCodeValidate_v3,
    /**
     * This endpoint is being used to generate user&#39;s token by one time link code. It require publisher ClientID It required a code which can be generated from &lt;code&gt;/iam/v3/link/code/request&lt;/code&gt;. This endpoint support creating transient token by utilizing **isTransient** param: **isTransient=true** will generate a transient token with a short Time Expiration and without a refresh token **isTransient=false** will consume the one-time code and generate the access token with a refresh token.
     */
    postLinkTokenExchange_v3,
    /**
     * This endpoint is being used to authenticate a user account and perform platform link. It validates user&#39;s email / username and password. If user already enable 2FA, then invoke _/mfa/verify_ using **mfa_token** from this endpoint response. ## Device Cookie Validation Device Cookie is used to protect the user account from brute force login attack, [more detail from OWASP](https://owasp.org/www-community/Slow_Down_Online_Guessing_Attacks_with_Device_Cookies). This endpoint will read device cookie from cookie **auth-trust-id**. If device cookie not found, it will generate a new one and set it into cookie when successfully authenticate.
     */
    postAuthenticateWithLink_v3,
    /**
     * This endpoint is being used to request the code to exchange a new token. The target new token&#39;s clientId should NOT be same with current using one. Path namespace should be target namespace. Client ID should match the target namespace. The code in response can be consumed by &lt;code&gt;/iam/v3/token/exchange&lt;/code&gt;
     */
    postTokenRequest_v3,
    /**
     * This endpoint authenticates user platform. It validates user to its respective platforms. Deactivated or login-banned users are unable to login. If already linked with justice account or match SSO condition, will redirect to client&#39;s redirect url with code. then invoke &#39;/iam/v3/oauth/token&#39; with grant_type=authorization_code If already not linked with justice account and not match SSO condition, will redirect to client&#39;s account linking page ## Supported platforms: - **steamopenid**Steam login page will redirects to this endpoint after login success as previously defined on openID request parameter &lt;code&gt;openid.return_to&lt;/code&gt; when request login to steam https://openid.net/specs/openid-authentication-2_0.html#anchor27 - **ps4web**PS4 login page will redirects to this endpoint after login success as previously defined on authorize request parameter &lt;code&gt;redirect_uri&lt;/code&gt; https://ps4.siedev.net/resources/documents/WebAPI/1/Auth_WebAPI-Reference/0002.html#0GetAccessTokenUsingAuthorizationCode - **xblweb**XBL login page will redirects to this endpoint after login success as previously defined on authorize request parameter &lt;code&gt;redirect_uri&lt;/code&gt; - **epicgames**Epicgames login page will redirects to this endpoint after login success or an error occurred. If error, it redirects to the login page. - **twitch**Twitch login page will redirects to this endpoint after login success as previously defined on authorize request parameter &lt;code&gt;redirect_uri&lt;/code&gt; - **facebook**Facebook login page will redirects to this endpoint after login success as previously defined on authorize request parameter &lt;code&gt;redirect_uri&lt;/code&gt; - **google**Google login page will redirects to this endpoint after login success as previously defined on authorize request parameter &lt;code&gt;redirect_uri&lt;/code&gt; - **snapchat**Snapchat login page will redirects to this endpoint after login success as previously defined on authorize request parameter &lt;code&gt;redirect_uri&lt;/code&gt; - **discord**Discord login page will redirects to this endpoint after login success as previously defined on authorize request parameter &lt;code&gt;redirect_uri&lt;/code&gt; action code : 10709
     */
    getAuthenticate_ByPlatformId_v3,
    /**
     * This endpoint will validate the third party platform token, for some platforms will also refresh the token stored in IAM, it will not generate any event or AB access/refresh token. This endpoint can be used by game client to refresh third party token if game client got platform token not found error, for example got 404 platform token not found from IAP/DLC. ## Platforms will refresh stored token: - **twitch**: The platform_token’s value is the authorization code returned by Twitch OAuth. - **epicgames**: The platform_token’s value is an access-token or authorization code obtained from Epicgames EOS Account Service. - **ps4**: The platform_token’s value is the authorization code returned by Sony OAuth. - **ps5**: The platform_token’s value is the authorization code returned by Sony OAuth. - **amazon**: The platform_token’s value is authorization code. - **awscognito**: The platform_token’s value is the aws cognito access token or id token (JWT). - **live**: The platform_token’s value is xbox XSTS token - **snapchat**: The platform_token’s value is the authorization code returned by Snapchat OAuth. - **for specific generic oauth (OIDC)**: The platform_token’s value should be the same type as created OIDC auth type whether it is auth code, idToken or bearerToken.
     */
    postTokenVerify_ByPlatformId_v3
  };
}

// src/generated-public/queries/OAuth20Extension.query.ts
var Key_OAuth20Extension = /* @__PURE__ */ ((Key_OAuth20Extension2) => {
  Key_OAuth20Extension2["Logout_v3"] = "Iam.OAuth20Extension.Logout_v3";
  Key_OAuth20Extension2["Authenticate_v3"] = "Iam.OAuth20Extension.Authenticate_v3";
  Key_OAuth20Extension2["HeadlesToken_v3"] = "Iam.OAuth20Extension.HeadlesToken_v3";
  Key_OAuth20Extension2["TokenExchange_v3"] = "Iam.OAuth20Extension.TokenExchange_v3";
  Key_OAuth20Extension2["LocationCountry_v3"] = "Iam.OAuth20Extension.LocationCountry_v3";
  Key_OAuth20Extension2["LinkCodeRequest_v3"] = "Iam.OAuth20Extension.LinkCodeRequest_v3";
  Key_OAuth20Extension2["LinkCodeValidate_v3"] = "Iam.OAuth20Extension.LinkCodeValidate_v3";
  Key_OAuth20Extension2["LinkTokenExchange_v3"] = "Iam.OAuth20Extension.LinkTokenExchange_v3";
  Key_OAuth20Extension2["AuthenticateWithLink_v3"] = "Iam.OAuth20Extension.AuthenticateWithLink_v3";
  Key_OAuth20Extension2["TokenRequest_v3"] = "Iam.OAuth20Extension.TokenRequest_v3";
  Key_OAuth20Extension2["Authenticate_ByPlatformId_v3"] = "Iam.OAuth20Extension.Authenticate_ByPlatformId_v3";
  Key_OAuth20Extension2["TokenVerify_ByPlatformId_v3"] = "Iam.OAuth20Extension.TokenVerify_ByPlatformId_v3";
  return Key_OAuth20Extension2;
})(Key_OAuth20Extension || {});
var useOAuth20ExtensionApi_CreateLogoutMutation_v3 = (sdk, options, callback) => {
  const mutationFn = async (input) => {
    const response = await OAuth20ExtensionApi(sdk, { coreConfig: input.coreConfig, axiosConfig: input.axiosConfig }).createLogout_v3();
    callback && callback(response.data);
    return response.data;
  };
  return (0, import_react_query24.useMutation)({
    mutationKey: ["Iam.OAuth20Extension.Logout_v3" /* Logout_v3 */],
    mutationFn,
    ...options
  });
};
var useOAuth20ExtensionApi_PostAuthenticateMutation_v3 = (sdk, options, callback) => {
  const mutationFn = async (input) => {
    const response = await OAuth20ExtensionApi(sdk, { coreConfig: input.coreConfig, axiosConfig: input.axiosConfig }).postAuthenticate_v3(
      input.data
    );
    callback && callback(response.data);
    return response.data;
  };
  return (0, import_react_query24.useMutation)({
    mutationKey: ["Iam.OAuth20Extension.Authenticate_v3" /* Authenticate_v3 */],
    mutationFn,
    ...options
  });
};
var useOAuth20ExtensionApi_PostHeadlesTokenMutation_v3 = (sdk, options, callback) => {
  const mutationFn = async (input) => {
    const response = await OAuth20ExtensionApi(sdk, { coreConfig: input.coreConfig, axiosConfig: input.axiosConfig }).postHeadlesToken_v3(
      input.data
    );
    callback && callback(response.data);
    return response.data;
  };
  return (0, import_react_query24.useMutation)({
    mutationKey: ["Iam.OAuth20Extension.HeadlesToken_v3" /* HeadlesToken_v3 */],
    mutationFn,
    ...options
  });
};
var useOAuth20ExtensionApi_PostTokenExchangeMutation_v3 = (sdk, options, callback) => {
  const mutationFn = async (input) => {
    const response = await OAuth20ExtensionApi(sdk, { coreConfig: input.coreConfig, axiosConfig: input.axiosConfig }).postTokenExchange_v3(
      input.data
    );
    callback && callback(response.data);
    return response.data;
  };
  return (0, import_react_query24.useMutation)({
    mutationKey: ["Iam.OAuth20Extension.TokenExchange_v3" /* TokenExchange_v3 */],
    mutationFn,
    ...options
  });
};
var useOAuth20ExtensionApi_GetLocationCountry_v3 = (sdk, input, options, callback) => {
  const queryFn = (sdk2, input2) => async () => {
    const response = await OAuth20ExtensionApi(sdk2, {
      coreConfig: input2.coreConfig,
      axiosConfig: input2.axiosConfig
    }).getLocationCountry_v3();
    callback && callback(response);
    return response.data;
  };
  return (0, import_react_query24.useQuery)({
    queryKey: ["Iam.OAuth20Extension.LocationCountry_v3" /* LocationCountry_v3 */, input],
    queryFn: queryFn(sdk, input),
    ...options
  });
};
var useOAuth20ExtensionApi_PostLinkCodeRequestMutation_v3 = (sdk, options, callback) => {
  const mutationFn = async (input) => {
    const response = await OAuth20ExtensionApi(sdk, {
      coreConfig: input.coreConfig,
      axiosConfig: input.axiosConfig
    }).postLinkCodeRequest_v3(input.data);
    callback && callback(response.data);
    return response.data;
  };
  return (0, import_react_query24.useMutation)({
    mutationKey: ["Iam.OAuth20Extension.LinkCodeRequest_v3" /* LinkCodeRequest_v3 */],
    mutationFn,
    ...options
  });
};
var useOAuth20ExtensionApi_PostLinkCodeValidateMutation_v3 = (sdk, options, callback) => {
  const mutationFn = async (input) => {
    const response = await OAuth20ExtensionApi(sdk, {
      coreConfig: input.coreConfig,
      axiosConfig: input.axiosConfig
    }).postLinkCodeValidate_v3(input.data);
    callback && callback(response.data);
    return response.data;
  };
  return (0, import_react_query24.useMutation)({
    mutationKey: ["Iam.OAuth20Extension.LinkCodeValidate_v3" /* LinkCodeValidate_v3 */],
    mutationFn,
    ...options
  });
};
var useOAuth20ExtensionApi_PostLinkTokenExchangeMutation_v3 = (sdk, options, callback) => {
  const mutationFn = async (input) => {
    const response = await OAuth20ExtensionApi(sdk, {
      coreConfig: input.coreConfig,
      axiosConfig: input.axiosConfig
    }).postLinkTokenExchange_v3(input.data);
    callback && callback(response.data);
    return response.data;
  };
  return (0, import_react_query24.useMutation)({
    mutationKey: ["Iam.OAuth20Extension.LinkTokenExchange_v3" /* LinkTokenExchange_v3 */],
    mutationFn,
    ...options
  });
};
var useOAuth20ExtensionApi_PostAuthenticateWithLinkMutation_v3 = (sdk, options, callback) => {
  const mutationFn = async (input) => {
    const response = await OAuth20ExtensionApi(sdk, {
      coreConfig: input.coreConfig,
      axiosConfig: input.axiosConfig
    }).postAuthenticateWithLink_v3(input.data);
    callback && callback(response.data);
    return response.data;
  };
  return (0, import_react_query24.useMutation)({
    mutationKey: ["Iam.OAuth20Extension.AuthenticateWithLink_v3" /* AuthenticateWithLink_v3 */],
    mutationFn,
    ...options
  });
};
var useOAuth20ExtensionApi_PostTokenRequestMutation_v3 = (sdk, options, callback) => {
  const mutationFn = async (input) => {
    const response = await OAuth20ExtensionApi(sdk, { coreConfig: input.coreConfig, axiosConfig: input.axiosConfig }).postTokenRequest_v3(
      input.data,
      input.queryParams
    );
    callback && callback(response.data);
    return response.data;
  };
  return (0, import_react_query24.useMutation)({
    mutationKey: ["Iam.OAuth20Extension.TokenRequest_v3" /* TokenRequest_v3 */],
    mutationFn,
    ...options
  });
};
var useOAuth20ExtensionApi_GetAuthenticate_ByPlatformId_v3 = (sdk, input, options, callback) => {
  const queryFn = (sdk2, input2) => async () => {
    const response = await OAuth20ExtensionApi(sdk2, {
      coreConfig: input2.coreConfig,
      axiosConfig: input2.axiosConfig
    }).getAuthenticate_ByPlatformId_v3(input2.platformId, input2.queryParams);
    callback && callback(response);
    return response.data;
  };
  return (0, import_react_query24.useQuery)({
    queryKey: ["Iam.OAuth20Extension.Authenticate_ByPlatformId_v3" /* Authenticate_ByPlatformId_v3 */, input],
    queryFn: queryFn(sdk, input),
    ...options
  });
};
var useOAuth20ExtensionApi_PostTokenVerify_ByPlatformIdMutation_v3 = (sdk, options, callback) => {
  const mutationFn = async (input) => {
    const response = await OAuth20ExtensionApi(sdk, {
      coreConfig: input.coreConfig,
      axiosConfig: input.axiosConfig
    }).postTokenVerify_ByPlatformId_v3(input.platformId, input.data);
    callback && callback(response.data);
    return response.data;
  };
  return (0, import_react_query24.useMutation)({
    mutationKey: ["Iam.OAuth20Extension.TokenVerify_ByPlatformId_v3" /* TokenVerify_ByPlatformId_v3 */],
    mutationFn,
    ...options
  });
};

// src/generated-public/queries/OAuth20V4.query.ts
var import_react_query25 = require("@tanstack/react-query");

// src/generated-public/OAuth20V4Api.ts
var import_sdk50 = require("@accelbyte/sdk");

// src/generated-public/endpoints/OAuth20V4$.ts
var import_sdk49 = require("@accelbyte/sdk");
var import_zod187 = require("zod");
var OAuth20V4$ = class {
  // @ts-ignore
  // prettier-ignore
  constructor(axiosInstance, namespace, useSchemaValidation = true) {
    this.axiosInstance = axiosInstance;
    this.namespace = namespace;
    this.useSchemaValidation = useSchemaValidation;
  }
  /**
   * This endpoint supports grant type: 1. Grant Type == &lt;code&gt;authorization_code&lt;/code&gt;: It generates the user token by given the authorization code which generated in &#34;/iam/v3/authenticate&#34; API response. It should also pass in the redirect_uri, which should be the same as generating the authorization code request. 2. Grant Type == &lt;code&gt;password&lt;/code&gt;: The grant type to use for authenticating a user, whether it&#39;s by email / username and password combination or through platform. 3. Grant Type == &lt;code&gt;refresh_token&lt;/code&gt;: Used to get a new access token for a valid refresh token. 4. Grant Type == &lt;code&gt;client_credentials&lt;/code&gt;: It generates a token by checking the client credentials provided through Authorization header. 5. Grant Type == &lt;code&gt;urn:ietf:params:oauth:grant-type:extend_client_credentials&lt;/code&gt;: It generates a token by checking the client credentials provided through Authorization header. It only allows publisher/studio namespace client. In generated token: 1. There wil be no roles, namespace_roles &amp; permission. 2. The scope will be fixed as &#39;extend&#39;. 3. There will have a new field &#39;extend_namespace&#39;, the value is from token request body. 6. Grant Type == &lt;code&gt;urn:ietf:params:oauth:grant-type:login_queue_ticket&lt;/code&gt;: It generates a token by validating the login queue ticket against login queue service. ## Access Token Content Following is the access token’s content: - **namespace**. It is the namespace the token was generated from. - **display_name**. The display name of the sub. It is empty if the token is generated from the client credential - **roles**. The sub’s roles. It is empty if the token is generated from the client credential - **namespace_roles**. The sub’s roles scoped to namespace. Improvement from roles, which make the role scoped to specific namespace instead of global to publisher namespace - **permissions**. The sub or aud’ permissions - **bans**. The sub’s list of bans. It is used by the IAM client for validating the token. - **jflgs**. It stands for Justice Flags. It is a special flag used for storing additional status information regarding the sub. It is implemented as a bit mask. Following explains what each bit represents: - 1: Email Address Verified - 2: Phone Number Verified - 4: Anonymous - 8: Suspicious Login - **aud**. The aud is the targeted resource server. - **iat**. The time the token issues at. It is in Epoch time format - **exp**. The time the token expires. It is in Epoch time format - **client_id**. The UserID. The sub is omitted if the token is generated from client credential - **scope**. The scope of the access request, expressed as a list of space-delimited, case-sensitive strings ## Bans The JWT contains user&#39;s active bans with its expiry date. List of ban types can be obtained from /bans. ## Device Cookie Validation _**For grant type &#34;password&#34; only**_ Device Cookie is used to protect the user account from brute force login attack, &lt;a target=&#34;_blank&#34; href=&#34;https://owasp.org/www-community/Slow_Down_Online_Guessing_Attacks_with_Device_Cookies&#34;&gt;more detail from OWASP&lt;a&gt;. This endpoint will read device cookie from request header **Auth-Trust-Id**. If device cookie not found, it will generate a new one and set it into response body **auth_trust_id** when successfully login. ## Track Login History This endpoint will track login history to detect suspicious login activity, please provide **Device-Id** (alphanumeric) in request header parameter otherwise it will set to &#34;unknown&#34;. Align with General Data Protection Regulation in Europe, user login history will be kept within 28 days by default&#34; ## 2FA remember device To remember device for 2FA, should provide cookie: device_token or header: Device-Token ## Response note If it is a user token request and user hasn&#39;t accepted required legal policy, the field &lt;code&gt;is_comply&lt;/code&gt; will be false in response and responsed token will have no permission. action code: 10703
   *
   * #### Response type:
   * - `TokenWithDeviceCookieResponseV3`
   * - `LoginQueueTicketResponse`
   */
  postOauthToken_v4(data, queryParams) {
    const params = { code_challenge_method: "plain", ...queryParams };
    const url = "/iam/v4/oauth/token";
    const resultPromise = this.axiosInstance.post(url, import_sdk49.CodeGenUtil.getFormUrlEncodedData(data), {
      ...params,
      headers: { ...params.headers, "content-type": "application/x-www-form-urlencoded" }
    });
    return import_sdk49.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, import_zod187.z.unknown(), "z.unknown()");
  }
  /**
   * Verify 2FA code This endpoint is used for verifying 2FA code. ## 2FA remember device To remember device for 2FA, should provide cookie: device_token or header: Device-Token
   *
   * #### Response type:
   * - `TokenResponseV3`
   * - `LoginQueueTicketResponse`
   */
  postOauthMfaVerify_v4(data) {
    const params = {};
    const url = "/iam/v4/oauth/mfa/verify";
    const resultPromise = this.axiosInstance.post(url, import_sdk49.CodeGenUtil.getFormUrlEncodedData(data), {
      ...params,
      headers: { ...params.headers, "content-type": "application/x-www-form-urlencoded" }
    });
    return import_sdk49.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, import_zod187.z.unknown(), "z.unknown()");
  }
  /**
   * This endpoint is being used to create headless account after 3rd platform authenticated, and response token . The &#39;linkingToken&#39; in request body is received from &#34;/platforms/{platformId}/token&#34; when 3rd platform account is not linked to justice account yet.
   *
   * #### Response type:
   * - `TokenResponseV3`
   * - `LoginQueueTicketResponse`
   */
  postOauthHeadlesToken_v4(data) {
    const params = {};
    const url = "/iam/v4/oauth/headless/token";
    const resultPromise = this.axiosInstance.post(url, import_sdk49.CodeGenUtil.getFormUrlEncodedData(data), {
      ...params,
      headers: { ...params.headers, "content-type": "application/x-www-form-urlencoded" }
    });
    return import_sdk49.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, import_zod187.z.unknown(), "z.unknown()");
  }
  /**
   * This endpoint is being used to generate target token. It requires basic header with ClientID and Secret, it should match the ClientID when call &lt;code&gt;/iam/v3/namespace/{namespace}/token/request&lt;/code&gt; The code should be generated from &lt;code&gt;/iam/v3/namespace/{namespace}/token/request&lt;/code&gt;.
   *
   * #### Response type:
   * - `TokenResponseV3`
   * - `LoginQueueTicketResponse`
   */
  postOauthTokenExchange_v4(data) {
    const params = {};
    const url = "/iam/v4/oauth/token/exchange";
    const resultPromise = this.axiosInstance.post(url, import_sdk49.CodeGenUtil.getFormUrlEncodedData(data), {
      ...params,
      headers: { ...params.headers, "content-type": "application/x-www-form-urlencoded" }
    });
    return import_sdk49.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, import_zod187.z.unknown(), "z.unknown()");
  }
  /**
   * # This endpoint is in ALPHA, avoid using this endpoint fow now, reach out to AB support for inquiries Simultaneous login flow. The primary goals of this project are to entitle players to authenticate on a native PC platform(Steam/Epic) and the PlayStation platform, link their accounts, and provide support for platform sync with a valid 3rd platform access token. ## Given a valid native ticket and empty simultaneous ticket, these cases will be failed - Native ticket&#39;s account is not linked AGS account yet - Native ticket&#39;s account is linked AGS account, but AGS account is not linked simultaneous platform yet - Native ticket&#39;s account is linked AGS account, AGS account is linked simultaneous platform but there is no available simultaneous token.(only if this platform is expected to store the platform token) ## Given a valid native ticket and empty simultaneous ticket, this case will be success - Native ticket&#39;s account already linked AGS account, this AGS account already linked simultaneous platform. There is valid simultaneous token.(this is required only when this simultaneous is expected to cache platform token) ## Given a valid native ticket token and valid simultaneous ticket, these cases will be failed #### Native ticket&#39;s account is already linked with AGS account - Native linked AGS account is linked this simultaneous platform but is different with simultaneous ticket&#39;s account - Native linked AGS account is not linked with simultaneous but has a linking history with simultaneous platform and it is different with simultaneous ticket&#39;s account #### Native ticket&#39;s account is not linked with AGS account and Simultaneous ticket&#39;s account is already linked wth AGS account - Simultaneous linked AGS account is linked this native platform but is different with native ticket&#39;s account - Simultaneous linked AGS account is not linked with native but has a linking history with native platform and it is different with native ticket&#39;s account ## Given a valid native ticket and valid simultaneous ticket, these cases will be success - Native ticket&#39;s account &amp; Simultaneous ticket&#39;s account are both not linked to AGS account yet - Native ticket&#39;s account &amp; Simultaneous ticket&#39;s account are already linked to same AGS account
   *
   * #### Response type:
   * - `TokenResponseV3`
   * - `LoginQueueTicketResponse`
   */
  postOauthSimultaneousLogin_v4(data, queryParams) {
    const params = { code_challenge_method: "plain", ...queryParams };
    const url = "/iam/v4/oauth/simultaneousLogin";
    const resultPromise = this.axiosInstance.post(url, import_sdk49.CodeGenUtil.getFormUrlEncodedData(data), {
      ...params,
      headers: { ...params.headers, "content-type": "application/x-www-form-urlencoded" }
    });
    return import_sdk49.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, import_zod187.z.unknown(), "z.unknown()");
  }
  /**
   * This endpoint is being used to authenticate a user account and perform platform link. It validates user&#39;s email / username and password. If user already enable 2FA, then invoke _/mfa/verify_ using **mfa_token** from this endpoint response. ## Device Cookie Validation Device Cookie is used to protect the user account from brute force login attack, [more detail from OWASP](https://owasp.org/www-community/Slow_Down_Online_Guessing_Attacks_with_Device_Cookies). This endpoint will read device cookie from cookie **auth-trust-id**. If device cookie not found, it will generate a new one and set it into cookie when successfully authenticate.
   *
   * #### Response type:
   * - `TokenResponseV3`
   * - `LoginQueueTicketResponse`
   */
  postOauthAuthenticateWithLink_v4(data) {
    const params = {};
    const url = "/iam/v4/oauth/authenticateWithLink";
    const resultPromise = this.axiosInstance.post(url, import_sdk49.CodeGenUtil.getFormUrlEncodedData(data), {
      ...params,
      headers: { ...params.headers, "content-type": "application/x-www-form-urlencoded" }
    });
    return import_sdk49.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, import_zod187.z.unknown(), "z.unknown()");
  }
  /**
   * Platform token grant specifically used for performing token grant using platform, e.g. Steam, Justice, etc. The endpoint automatically create an account if the account associated with the platform is not exists yet. This endpoint requires all requests to have Authorization header set with Basic access authentication constructed from client id and client secret. For publisher-game namespace schema : Specify only either platform_token or device_id. Device token grant should be requested along with device_id parameter against game namespace. Another 3rd party platform token grant should be requested along with platform_token parameter against publisher namespace. ## 2FA remember device To remember device for 2FA, should provide cookie: device_token or header: Device-Token ## Supported platforms: - **steam**: The platform_token’s value is the binary ticket returned by Steam. If this ticket was generated by Steam GetAuthTicketForWebApi with version &gt;= 1.57, then platform token should use this style: &lt;code&gt;{identity}:{ticket}&lt;/code&gt;, the &lt;code&gt;{identity}&lt;/code&gt; was the parameter to call GetAuthTicketForWebApi when the ticket was created. Note: Do not contain &lt;code&gt;:&lt;/code&gt; in this &lt;code&gt;{identity}&lt;/code&gt;. - **steamopenid**: Steam&#39;s user authentication method using OpenID 2.0. The platform_token&#39;s value is URL generated by Steam on web authentication - **facebook**: The platform_token’s value is the authorization code returned by Facebook OAuth - **google**: The platform_token’s value is the authorization code or idToken returned by Google OAuth - **googleplaygames**: The platform_token’s value is the authorization code or idToken returned by Google play games OAuth - **oculus**: The platform_token’s value is a string composed of Oculus&#39;s user ID and the nonce separated by a colon (:). - **twitch**: The platform_token’s value is the authorization code returned by Twitch OAuth. - **discord**: The platform_token’s value is the authorization code returned by Discord OAuth - **android**: The device_id is the Android’s device ID - **ios**: The device_id is the iOS’s device ID. - **apple**: The platform_token’s value is the authorization code or idToken returned by Apple OAuth.(We will use this code to generate APP token) - **device**: Every device that does’nt run Android and iOS is categorized as a device. The device_id is the device’s ID. - **justice**: The platform_token’s value is the designated user’s access token. - **epicgames**: The platform_token’s value is an access-token or authorization code obtained from Epicgames EOS Account Service. - **ps4**: The platform_token’s value is the authorization code returned by Sony OAuth. - **ps5**: The platform_token’s value is the authorization code returned by Sony OAuth. - **nintendo**: The platform_token’s value is the id_token returned by Nintendo OAuth. - **awscognito**: The platform_token’s value is the aws cognito access token or id token (JWT). - **live**: The platform_token’s value is xbox XSTS token - **xblweb**: The platform_token’s value is code returned by xbox after login - **netflix**: The platform_token’s value is GAT (Gamer Access Token) returned by Netflix backend - **snapchat**: The platform_token’s value is the authorization code returned by Snapchat OAuth. - **for specific generic oauth (OIDC)**: The platform_token’s value should be the same type as created OIDC auth type whether it is auth code, idToken or bearerToken. ## Account Group Several platforms are grouped under account groups. The accounts on these platforms have the same platform user id. Login using one of these platform will returns the same IAM user. Following is the current registered account grouping: - Steam group(steamnetwork): - steam - steamopenid - PSN group(psn) - ps4web - ps4 - ps5 - XBOX group(xbox) - live - xblweb - Oculus group(oculusgroup) - oculus - oculusweb ## Access Token Content Following is the access token’s content: - **namespace**. It is the namespace the token was generated from. - **display_name**. The display name of the sub. It is empty if the token is generated from the client credential - **roles**. The sub’s roles. It is empty if the token is generated from the client credential - **namespace_roles**. The sub’s roles scoped to namespace. Improvement from roles, which make the role scoped to specific namespace instead of global to publisher namespace - **permissions**. The sub or aud’ permissions - **bans**. The sub’s list of bans. It is used by the IAM client for validating the token. - **jflgs**. It stands for Justice Flags. It is a special flag used for storing additional status information regarding the sub. It is implemented as a bit mask. Following explains what each bit represents: - 1: Email Address Verified - 2: Phone Number Verified - 4: Anonymous - 8: Suspicious Login - **aud**. The aud is the client ID. - **iat**. The time the token issues at. It is in Epoch time format - **exp**. The time the token expires. It is in Epoch time format - **sub**. The UserID. The sub is omitted if the token is generated from client credential ## Bans The JWT contains user&#39;s active bans with its expiry date. List of ban types can be obtained from /bans. action code : 10704
   *
   * #### Response type:
   * - `TokenResponseV3`
   * - `LoginQueueTicketResponse`
   */
  postTokenOauth_ByPlatformId_v4(platformId, data, queryParams) {
    const params = { code_challenge_method: "plain", ...queryParams };
    const url = "/iam/v4/oauth/platforms/{platformId}/token".replace("{platformId}", platformId);
    const resultPromise = this.axiosInstance.post(url, import_sdk49.CodeGenUtil.getFormUrlEncodedData(data), {
      ...params,
      headers: { ...params.headers, "content-type": "application/x-www-form-urlencoded" }
    });
    return import_sdk49.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, import_zod187.z.unknown(), "z.unknown()");
  }
};

// src/generated-public/OAuth20V4Api.ts
function OAuth20V4Api(sdk, args) {
  const sdkAssembly = sdk.assembly();
  const namespace = args?.coreConfig?.namespace ?? sdkAssembly.coreConfig.namespace;
  const useSchemaValidation = args?.coreConfig?.useSchemaValidation ?? sdkAssembly.coreConfig.useSchemaValidation;
  let axiosInstance = sdkAssembly.axiosInstance;
  const requestConfigOverrides = args?.axiosConfig?.request;
  const baseURLOverride = args?.coreConfig?.baseURL;
  const interceptorsOverride = args?.axiosConfig?.interceptors ?? [];
  if (requestConfigOverrides || baseURLOverride || interceptorsOverride.length > 0) {
    const requestConfig = import_sdk50.ApiUtils.mergeAxiosConfigs(sdkAssembly.axiosInstance.defaults, {
      ...baseURLOverride ? { baseURL: baseURLOverride } : {},
      ...requestConfigOverrides
    });
    axiosInstance = import_sdk50.Network.create(requestConfig);
    for (const interceptor of interceptorsOverride) {
      if (interceptor.type === "request") {
        axiosInstance.interceptors.request.use(interceptor.onRequest, interceptor.onError);
      }
      if (interceptor.type === "response") {
        axiosInstance.interceptors.response.use(interceptor.onSuccess, interceptor.onError);
      }
    }
  }
  async function postOauthToken_v4(data, queryParams) {
    const $ = new OAuth20V4$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.postOauthToken_v4(data, queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function postOauthMfaVerify_v4(data) {
    const $ = new OAuth20V4$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.postOauthMfaVerify_v4(data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function postOauthHeadlesToken_v4(data) {
    const $ = new OAuth20V4$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.postOauthHeadlesToken_v4(data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function postOauthTokenExchange_v4(data) {
    const $ = new OAuth20V4$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.postOauthTokenExchange_v4(data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function postOauthSimultaneousLogin_v4(data, queryParams) {
    const $ = new OAuth20V4$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.postOauthSimultaneousLogin_v4(data, queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function postOauthAuthenticateWithLink_v4(data) {
    const $ = new OAuth20V4$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.postOauthAuthenticateWithLink_v4(data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function postTokenOauth_ByPlatformId_v4(platformId, data, queryParams) {
    const $ = new OAuth20V4$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.postTokenOauth_ByPlatformId_v4(platformId, data, queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  return {
    /**
     * This endpoint supports grant type: 1. Grant Type == &lt;code&gt;authorization_code&lt;/code&gt;: It generates the user token by given the authorization code which generated in &#34;/iam/v3/authenticate&#34; API response. It should also pass in the redirect_uri, which should be the same as generating the authorization code request. 2. Grant Type == &lt;code&gt;password&lt;/code&gt;: The grant type to use for authenticating a user, whether it&#39;s by email / username and password combination or through platform. 3. Grant Type == &lt;code&gt;refresh_token&lt;/code&gt;: Used to get a new access token for a valid refresh token. 4. Grant Type == &lt;code&gt;client_credentials&lt;/code&gt;: It generates a token by checking the client credentials provided through Authorization header. 5. Grant Type == &lt;code&gt;urn:ietf:params:oauth:grant-type:extend_client_credentials&lt;/code&gt;: It generates a token by checking the client credentials provided through Authorization header. It only allows publisher/studio namespace client. In generated token: 1. There wil be no roles, namespace_roles &amp; permission. 2. The scope will be fixed as &#39;extend&#39;. 3. There will have a new field &#39;extend_namespace&#39;, the value is from token request body. 6. Grant Type == &lt;code&gt;urn:ietf:params:oauth:grant-type:login_queue_ticket&lt;/code&gt;: It generates a token by validating the login queue ticket against login queue service. ## Access Token Content Following is the access token’s content: - **namespace**. It is the namespace the token was generated from. - **display_name**. The display name of the sub. It is empty if the token is generated from the client credential - **roles**. The sub’s roles. It is empty if the token is generated from the client credential - **namespace_roles**. The sub’s roles scoped to namespace. Improvement from roles, which make the role scoped to specific namespace instead of global to publisher namespace - **permissions**. The sub or aud’ permissions - **bans**. The sub’s list of bans. It is used by the IAM client for validating the token. - **jflgs**. It stands for Justice Flags. It is a special flag used for storing additional status information regarding the sub. It is implemented as a bit mask. Following explains what each bit represents: - 1: Email Address Verified - 2: Phone Number Verified - 4: Anonymous - 8: Suspicious Login - **aud**. The aud is the targeted resource server. - **iat**. The time the token issues at. It is in Epoch time format - **exp**. The time the token expires. It is in Epoch time format - **client_id**. The UserID. The sub is omitted if the token is generated from client credential - **scope**. The scope of the access request, expressed as a list of space-delimited, case-sensitive strings ## Bans The JWT contains user&#39;s active bans with its expiry date. List of ban types can be obtained from /bans. ## Device Cookie Validation _**For grant type &#34;password&#34; only**_ Device Cookie is used to protect the user account from brute force login attack, &lt;a target=&#34;_blank&#34; href=&#34;https://owasp.org/www-community/Slow_Down_Online_Guessing_Attacks_with_Device_Cookies&#34;&gt;more detail from OWASP&lt;a&gt;. This endpoint will read device cookie from request header **Auth-Trust-Id**. If device cookie not found, it will generate a new one and set it into response body **auth_trust_id** when successfully login. ## Track Login History This endpoint will track login history to detect suspicious login activity, please provide **Device-Id** (alphanumeric) in request header parameter otherwise it will set to &#34;unknown&#34;. Align with General Data Protection Regulation in Europe, user login history will be kept within 28 days by default&#34; ## 2FA remember device To remember device for 2FA, should provide cookie: device_token or header: Device-Token ## Response note If it is a user token request and user hasn&#39;t accepted required legal policy, the field &lt;code&gt;is_comply&lt;/code&gt; will be false in response and responsed token will have no permission. action code: 10703
     *
     * #### Response type:
     * - `TokenWithDeviceCookieResponseV3`
     * - `LoginQueueTicketResponse`
     */
    postOauthToken_v4,
    /**
     * Verify 2FA code This endpoint is used for verifying 2FA code. ## 2FA remember device To remember device for 2FA, should provide cookie: device_token or header: Device-Token
     *
     * #### Response type:
     * - `TokenResponseV3`
     * - `LoginQueueTicketResponse`
     */
    postOauthMfaVerify_v4,
    /**
     * This endpoint is being used to create headless account after 3rd platform authenticated, and response token . The &#39;linkingToken&#39; in request body is received from &#34;/platforms/{platformId}/token&#34; when 3rd platform account is not linked to justice account yet.
     *
     * #### Response type:
     * - `TokenResponseV3`
     * - `LoginQueueTicketResponse`
     */
    postOauthHeadlesToken_v4,
    /**
     * This endpoint is being used to generate target token. It requires basic header with ClientID and Secret, it should match the ClientID when call &lt;code&gt;/iam/v3/namespace/{namespace}/token/request&lt;/code&gt; The code should be generated from &lt;code&gt;/iam/v3/namespace/{namespace}/token/request&lt;/code&gt;.
     *
     * #### Response type:
     * - `TokenResponseV3`
     * - `LoginQueueTicketResponse`
     */
    postOauthTokenExchange_v4,
    /**
     * # This endpoint is in ALPHA, avoid using this endpoint fow now, reach out to AB support for inquiries Simultaneous login flow. The primary goals of this project are to entitle players to authenticate on a native PC platform(Steam/Epic) and the PlayStation platform, link their accounts, and provide support for platform sync with a valid 3rd platform access token. ## Given a valid native ticket and empty simultaneous ticket, these cases will be failed - Native ticket&#39;s account is not linked AGS account yet - Native ticket&#39;s account is linked AGS account, but AGS account is not linked simultaneous platform yet - Native ticket&#39;s account is linked AGS account, AGS account is linked simultaneous platform but there is no available simultaneous token.(only if this platform is expected to store the platform token) ## Given a valid native ticket and empty simultaneous ticket, this case will be success - Native ticket&#39;s account already linked AGS account, this AGS account already linked simultaneous platform. There is valid simultaneous token.(this is required only when this simultaneous is expected to cache platform token) ## Given a valid native ticket token and valid simultaneous ticket, these cases will be failed #### Native ticket&#39;s account is already linked with AGS account - Native linked AGS account is linked this simultaneous platform but is different with simultaneous ticket&#39;s account - Native linked AGS account is not linked with simultaneous but has a linking history with simultaneous platform and it is different with simultaneous ticket&#39;s account #### Native ticket&#39;s account is not linked with AGS account and Simultaneous ticket&#39;s account is already linked wth AGS account - Simultaneous linked AGS account is linked this native platform but is different with native ticket&#39;s account - Simultaneous linked AGS account is not linked with native but has a linking history with native platform and it is different with native ticket&#39;s account ## Given a valid native ticket and valid simultaneous ticket, these cases will be success - Native ticket&#39;s account &amp; Simultaneous ticket&#39;s account are both not linked to AGS account yet - Native ticket&#39;s account &amp; Simultaneous ticket&#39;s account are already linked to same AGS account
     *
     * #### Response type:
     * - `TokenResponseV3`
     * - `LoginQueueTicketResponse`
     */
    postOauthSimultaneousLogin_v4,
    /**
     * This endpoint is being used to authenticate a user account and perform platform link. It validates user&#39;s email / username and password. If user already enable 2FA, then invoke _/mfa/verify_ using **mfa_token** from this endpoint response. ## Device Cookie Validation Device Cookie is used to protect the user account from brute force login attack, [more detail from OWASP](https://owasp.org/www-community/Slow_Down_Online_Guessing_Attacks_with_Device_Cookies). This endpoint will read device cookie from cookie **auth-trust-id**. If device cookie not found, it will generate a new one and set it into cookie when successfully authenticate.
     *
     * #### Response type:
     * - `TokenResponseV3`
     * - `LoginQueueTicketResponse`
     */
    postOauthAuthenticateWithLink_v4,
    /**
     * Platform token grant specifically used for performing token grant using platform, e.g. Steam, Justice, etc. The endpoint automatically create an account if the account associated with the platform is not exists yet. This endpoint requires all requests to have Authorization header set with Basic access authentication constructed from client id and client secret. For publisher-game namespace schema : Specify only either platform_token or device_id. Device token grant should be requested along with device_id parameter against game namespace. Another 3rd party platform token grant should be requested along with platform_token parameter against publisher namespace. ## 2FA remember device To remember device for 2FA, should provide cookie: device_token or header: Device-Token ## Supported platforms: - **steam**: The platform_token’s value is the binary ticket returned by Steam. If this ticket was generated by Steam GetAuthTicketForWebApi with version &gt;= 1.57, then platform token should use this style: &lt;code&gt;{identity}:{ticket}&lt;/code&gt;, the &lt;code&gt;{identity}&lt;/code&gt; was the parameter to call GetAuthTicketForWebApi when the ticket was created. Note: Do not contain &lt;code&gt;:&lt;/code&gt; in this &lt;code&gt;{identity}&lt;/code&gt;. - **steamopenid**: Steam&#39;s user authentication method using OpenID 2.0. The platform_token&#39;s value is URL generated by Steam on web authentication - **facebook**: The platform_token’s value is the authorization code returned by Facebook OAuth - **google**: The platform_token’s value is the authorization code or idToken returned by Google OAuth - **googleplaygames**: The platform_token’s value is the authorization code or idToken returned by Google play games OAuth - **oculus**: The platform_token’s value is a string composed of Oculus&#39;s user ID and the nonce separated by a colon (:). - **twitch**: The platform_token’s value is the authorization code returned by Twitch OAuth. - **discord**: The platform_token’s value is the authorization code returned by Discord OAuth - **android**: The device_id is the Android’s device ID - **ios**: The device_id is the iOS’s device ID. - **apple**: The platform_token’s value is the authorization code or idToken returned by Apple OAuth.(We will use this code to generate APP token) - **device**: Every device that does’nt run Android and iOS is categorized as a device. The device_id is the device’s ID. - **justice**: The platform_token’s value is the designated user’s access token. - **epicgames**: The platform_token’s value is an access-token or authorization code obtained from Epicgames EOS Account Service. - **ps4**: The platform_token’s value is the authorization code returned by Sony OAuth. - **ps5**: The platform_token’s value is the authorization code returned by Sony OAuth. - **nintendo**: The platform_token’s value is the id_token returned by Nintendo OAuth. - **awscognito**: The platform_token’s value is the aws cognito access token or id token (JWT). - **live**: The platform_token’s value is xbox XSTS token - **xblweb**: The platform_token’s value is code returned by xbox after login - **netflix**: The platform_token’s value is GAT (Gamer Access Token) returned by Netflix backend - **snapchat**: The platform_token’s value is the authorization code returned by Snapchat OAuth. - **for specific generic oauth (OIDC)**: The platform_token’s value should be the same type as created OIDC auth type whether it is auth code, idToken or bearerToken. ## Account Group Several platforms are grouped under account groups. The accounts on these platforms have the same platform user id. Login using one of these platform will returns the same IAM user. Following is the current registered account grouping: - Steam group(steamnetwork): - steam - steamopenid - PSN group(psn) - ps4web - ps4 - ps5 - XBOX group(xbox) - live - xblweb - Oculus group(oculusgroup) - oculus - oculusweb ## Access Token Content Following is the access token’s content: - **namespace**. It is the namespace the token was generated from. - **display_name**. The display name of the sub. It is empty if the token is generated from the client credential - **roles**. The sub’s roles. It is empty if the token is generated from the client credential - **namespace_roles**. The sub’s roles scoped to namespace. Improvement from roles, which make the role scoped to specific namespace instead of global to publisher namespace - **permissions**. The sub or aud’ permissions - **bans**. The sub’s list of bans. It is used by the IAM client for validating the token. - **jflgs**. It stands for Justice Flags. It is a special flag used for storing additional status information regarding the sub. It is implemented as a bit mask. Following explains what each bit represents: - 1: Email Address Verified - 2: Phone Number Verified - 4: Anonymous - 8: Suspicious Login - **aud**. The aud is the client ID. - **iat**. The time the token issues at. It is in Epoch time format - **exp**. The time the token expires. It is in Epoch time format - **sub**. The UserID. The sub is omitted if the token is generated from client credential ## Bans The JWT contains user&#39;s active bans with its expiry date. List of ban types can be obtained from /bans. action code : 10704
     *
     * #### Response type:
     * - `TokenResponseV3`
     * - `LoginQueueTicketResponse`
     */
    postTokenOauth_ByPlatformId_v4
  };
}

// src/generated-public/queries/OAuth20V4.query.ts
var Key_OAuth20V4 = /* @__PURE__ */ ((Key_OAuth20V42) => {
  Key_OAuth20V42["OauthToken_v4"] = "Iam.OAuth20V4.OauthToken_v4";
  Key_OAuth20V42["OauthMfaVerify_v4"] = "Iam.OAuth20V4.OauthMfaVerify_v4";
  Key_OAuth20V42["OauthHeadlesToken_v4"] = "Iam.OAuth20V4.OauthHeadlesToken_v4";
  Key_OAuth20V42["OauthTokenExchange_v4"] = "Iam.OAuth20V4.OauthTokenExchange_v4";
  Key_OAuth20V42["OauthSimultaneousLogin_v4"] = "Iam.OAuth20V4.OauthSimultaneousLogin_v4";
  Key_OAuth20V42["OauthAuthenticateWithLink_v4"] = "Iam.OAuth20V4.OauthAuthenticateWithLink_v4";
  Key_OAuth20V42["TokenOauth_ByPlatformId_v4"] = "Iam.OAuth20V4.TokenOauth_ByPlatformId_v4";
  return Key_OAuth20V42;
})(Key_OAuth20V4 || {});
var useOAuth20V4Api_PostOauthTokenMutation_v4 = (sdk, options, callback) => {
  const mutationFn = async (input) => {
    const response = await OAuth20V4Api(sdk, { coreConfig: input.coreConfig, axiosConfig: input.axiosConfig }).postOauthToken_v4(
      input.data,
      input.queryParams
    );
    callback && callback(response.data);
    return response.data;
  };
  return (0, import_react_query25.useMutation)({
    mutationKey: ["Iam.OAuth20V4.OauthToken_v4" /* OauthToken_v4 */],
    mutationFn,
    ...options
  });
};
var useOAuth20V4Api_PostOauthMfaVerifyMutation_v4 = (sdk, options, callback) => {
  const mutationFn = async (input) => {
    const response = await OAuth20V4Api(sdk, { coreConfig: input.coreConfig, axiosConfig: input.axiosConfig }).postOauthMfaVerify_v4(
      input.data
    );
    callback && callback(response.data);
    return response.data;
  };
  return (0, import_react_query25.useMutation)({
    mutationKey: ["Iam.OAuth20V4.OauthMfaVerify_v4" /* OauthMfaVerify_v4 */],
    mutationFn,
    ...options
  });
};
var useOAuth20V4Api_PostOauthHeadlesTokenMutation_v4 = (sdk, options, callback) => {
  const mutationFn = async (input) => {
    const response = await OAuth20V4Api(sdk, { coreConfig: input.coreConfig, axiosConfig: input.axiosConfig }).postOauthHeadlesToken_v4(
      input.data
    );
    callback && callback(response.data);
    return response.data;
  };
  return (0, import_react_query25.useMutation)({
    mutationKey: ["Iam.OAuth20V4.OauthHeadlesToken_v4" /* OauthHeadlesToken_v4 */],
    mutationFn,
    ...options
  });
};
var useOAuth20V4Api_PostOauthTokenExchangeMutation_v4 = (sdk, options, callback) => {
  const mutationFn = async (input) => {
    const response = await OAuth20V4Api(sdk, { coreConfig: input.coreConfig, axiosConfig: input.axiosConfig }).postOauthTokenExchange_v4(
      input.data
    );
    callback && callback(response.data);
    return response.data;
  };
  return (0, import_react_query25.useMutation)({
    mutationKey: ["Iam.OAuth20V4.OauthTokenExchange_v4" /* OauthTokenExchange_v4 */],
    mutationFn,
    ...options
  });
};
var useOAuth20V4Api_PostOauthSimultaneousLoginMutation_v4 = (sdk, options, callback) => {
  const mutationFn = async (input) => {
    const response = await OAuth20V4Api(sdk, {
      coreConfig: input.coreConfig,
      axiosConfig: input.axiosConfig
    }).postOauthSimultaneousLogin_v4(input.data, input.queryParams);
    callback && callback(response.data);
    return response.data;
  };
  return (0, import_react_query25.useMutation)({
    mutationKey: ["Iam.OAuth20V4.OauthSimultaneousLogin_v4" /* OauthSimultaneousLogin_v4 */],
    mutationFn,
    ...options
  });
};
var useOAuth20V4Api_PostOauthAuthenticateWithLinkMutation_v4 = (sdk, options, callback) => {
  const mutationFn = async (input) => {
    const response = await OAuth20V4Api(sdk, {
      coreConfig: input.coreConfig,
      axiosConfig: input.axiosConfig
    }).postOauthAuthenticateWithLink_v4(input.data);
    callback && callback(response.data);
    return response.data;
  };
  return (0, import_react_query25.useMutation)({
    mutationKey: ["Iam.OAuth20V4.OauthAuthenticateWithLink_v4" /* OauthAuthenticateWithLink_v4 */],
    mutationFn,
    ...options
  });
};
var useOAuth20V4Api_PostTokenOauth_ByPlatformIdMutation_v4 = (sdk, options, callback) => {
  const mutationFn = async (input) => {
    const response = await OAuth20V4Api(sdk, {
      coreConfig: input.coreConfig,
      axiosConfig: input.axiosConfig
    }).postTokenOauth_ByPlatformId_v4(input.platformId, input.data, input.queryParams);
    callback && callback(response.data);
    return response.data;
  };
  return (0, import_react_query25.useMutation)({
    mutationKey: ["Iam.OAuth20V4.TokenOauth_ByPlatformId_v4" /* TokenOauth_ByPlatformId_v4 */],
    mutationFn,
    ...options
  });
};

// src/generated-public/queries/ProfileUpdateStrategy.query.ts
var import_react_query26 = require("@tanstack/react-query");

// src/generated-public/ProfileUpdateStrategyApi.ts
var import_sdk52 = require("@accelbyte/sdk");

// src/generated-public/endpoints/ProfileUpdateStrategy$.ts
var import_sdk51 = require("@accelbyte/sdk");
var ProfileUpdateStrategy$ = class {
  // @ts-ignore
  // prettier-ignore
  constructor(axiosInstance, namespace, useSchemaValidation = true) {
    this.axiosInstance = axiosInstance;
    this.namespace = namespace;
    this.useSchemaValidation = useSchemaValidation;
  }
  /**
   * This API is for public user to get profile update strategy by namespace and field. Note: If the config is not found, this API will return a config with unlimited.
   */
  getProfileUpdateStrategies_v3(queryParams) {
    const params = { ...queryParams };
    const url = "/iam/v3/public/namespaces/{namespace}/profileUpdateStrategies".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.get(url, { params });
    return import_sdk51.Validate.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      GetProfileUpdateStrategyConfigResponse,
      "GetProfileUpdateStrategyConfigResponse"
    );
  }
};

// src/generated-public/ProfileUpdateStrategyApi.ts
function ProfileUpdateStrategyApi(sdk, args) {
  const sdkAssembly = sdk.assembly();
  const namespace = args?.coreConfig?.namespace ?? sdkAssembly.coreConfig.namespace;
  const useSchemaValidation = args?.coreConfig?.useSchemaValidation ?? sdkAssembly.coreConfig.useSchemaValidation;
  let axiosInstance = sdkAssembly.axiosInstance;
  const requestConfigOverrides = args?.axiosConfig?.request;
  const baseURLOverride = args?.coreConfig?.baseURL;
  const interceptorsOverride = args?.axiosConfig?.interceptors ?? [];
  if (requestConfigOverrides || baseURLOverride || interceptorsOverride.length > 0) {
    const requestConfig = import_sdk52.ApiUtils.mergeAxiosConfigs(sdkAssembly.axiosInstance.defaults, {
      ...baseURLOverride ? { baseURL: baseURLOverride } : {},
      ...requestConfigOverrides
    });
    axiosInstance = import_sdk52.Network.create(requestConfig);
    for (const interceptor of interceptorsOverride) {
      if (interceptor.type === "request") {
        axiosInstance.interceptors.request.use(interceptor.onRequest, interceptor.onError);
      }
      if (interceptor.type === "response") {
        axiosInstance.interceptors.response.use(interceptor.onSuccess, interceptor.onError);
      }
    }
  }
  async function getProfileUpdateStrategies_v3(queryParams) {
    const $ = new ProfileUpdateStrategy$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getProfileUpdateStrategies_v3(queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  return {
    /**
     * This API is for public user to get profile update strategy by namespace and field. Note: If the config is not found, this API will return a config with unlimited.
     */
    getProfileUpdateStrategies_v3
  };
}

// src/generated-public/queries/ProfileUpdateStrategy.query.ts
var Key_ProfileUpdateStrategy = /* @__PURE__ */ ((Key_ProfileUpdateStrategy2) => {
  Key_ProfileUpdateStrategy2["ProfileUpdateStrategies_v3"] = "Iam.ProfileUpdateStrategy.ProfileUpdateStrategies_v3";
  return Key_ProfileUpdateStrategy2;
})(Key_ProfileUpdateStrategy || {});
var useProfileUpdateStrategyApi_GetProfileUpdateStrategies_v3 = (sdk, input, options, callback) => {
  const queryFn = (sdk2, input2) => async () => {
    const response = await ProfileUpdateStrategyApi(sdk2, {
      coreConfig: input2.coreConfig,
      axiosConfig: input2.axiosConfig
    }).getProfileUpdateStrategies_v3(input2.queryParams);
    callback && callback(response);
    return response.data;
  };
  return (0, import_react_query26.useQuery)({
    queryKey: ["Iam.ProfileUpdateStrategy.ProfileUpdateStrategies_v3" /* ProfileUpdateStrategies_v3 */, input],
    queryFn: queryFn(sdk, input),
    ...options
  });
};

// src/generated-public/queries/Roles.query.ts
var import_react_query27 = require("@tanstack/react-query");

// src/generated-public/RolesApi.ts
var import_sdk54 = require("@accelbyte/sdk");

// src/generated-public/endpoints/Roles$.ts
var import_sdk53 = require("@accelbyte/sdk");
var import_zod198 = require("zod");

// src/generated-definitions/Role.ts
var import_zod190 = require("zod");

// src/generated-definitions/RoleManager.ts
var import_zod188 = require("zod");
var RoleManager = import_zod188.z.object({ DisplayName: import_zod188.z.string(), Namespace: import_zod188.z.string(), UserId: import_zod188.z.string() });

// src/generated-definitions/RoleMember.ts
var import_zod189 = require("zod");
var RoleMember = import_zod189.z.object({ DisplayName: import_zod189.z.string(), Namespace: import_zod189.z.string(), UserId: import_zod189.z.string() });

// src/generated-definitions/Role.ts
var Role = import_zod190.z.object({
  AdminRole: import_zod190.z.boolean(),
  Deletable: import_zod190.z.boolean(),
  IsWildcard: import_zod190.z.boolean(),
  Managers: import_zod190.z.array(RoleManager),
  Members: import_zod190.z.array(RoleMember),
  Permissions: import_zod190.z.array(Permission),
  RoleId: import_zod190.z.string(),
  RoleName: import_zod190.z.string()
});

// src/generated-definitions/RoleAdminStatusResponse.ts
var import_zod191 = require("zod");
var RoleAdminStatusResponse = import_zod191.z.object({ AdminRole: import_zod191.z.boolean() });

// src/generated-definitions/RoleManagersResponse.ts
var import_zod192 = require("zod");
var RoleManagersResponse = import_zod192.z.object({ Managers: import_zod192.z.array(RoleManager) });

// src/generated-definitions/RoleMembersResponse.ts
var import_zod193 = require("zod");
var RoleMembersResponse = import_zod193.z.object({ Members: import_zod193.z.array(RoleMember) });

// src/generated-definitions/RoleNamesResponseV3.ts
var import_zod194 = require("zod");
var RoleNamesResponseV3 = import_zod194.z.object({ data: import_zod194.z.array(import_zod194.z.string()), paging: PaginationV3 });

// src/generated-definitions/RoleResponse.ts
var import_zod195 = require("zod");
var RoleResponse = import_zod195.z.object({
  IsWildcard: import_zod195.z.boolean(),
  Permissions: import_zod195.z.array(Permission),
  RoleId: import_zod195.z.string(),
  RoleName: import_zod195.z.string()
});

// src/generated-definitions/RoleResponseWithManagersArray.ts
var import_zod197 = require("zod");

// src/generated-definitions/RoleResponseWithManagers.ts
var import_zod196 = require("zod");
var RoleResponseWithManagers = import_zod196.z.object({
  IsWildcard: import_zod196.z.boolean(),
  Managers: import_zod196.z.array(RoleManager),
  Permissions: import_zod196.z.array(Permission),
  RoleId: import_zod196.z.string(),
  RoleName: import_zod196.z.string()
});

// src/generated-definitions/RoleResponseWithManagersArray.ts
var RoleResponseWithManagersArray = import_zod197.z.array(RoleResponseWithManagers);

// src/generated-public/endpoints/Roles$.ts
var Roles$ = class {
  // @ts-ignore
  // prettier-ignore
  constructor(axiosInstance, namespace, useSchemaValidation = true) {
    this.axiosInstance = axiosInstance;
    this.namespace = namespace;
    this.useSchemaValidation = useSchemaValidation;
  }
  /**
   * @deprecated
   * ## The endpoint is going to be deprecated ### Endpoint migration guide - **Substitute endpoint: _/iam/v3/admin/roles [GET]_**
   */
  getRoles(queryParams) {
    const params = { ...queryParams };
    const url = "/iam/roles";
    const resultPromise = this.axiosInstance.get(url, { params });
    return import_sdk53.Validate.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      RoleResponseWithManagersArray,
      "RoleResponseWithManagersArray"
    );
  }
  /**
   * @deprecated
   * ## The endpoint is going to be deprecated Role can only be assigned to other users by the role&#39;s manager. If role is an administrator role (i.e. AdminRole == true), it will list out the role&#39;s members. Administrator role can be created only when at least 1 manager is specified. ### Endpoint migration guide - **Substitute endpoint: _/iam/v3/admin/roles [POST]_**
   */
  createRole(data) {
    const params = {};
    const url = "/iam/roles";
    const resultPromise = this.axiosInstance.post(url, data, { params });
    return import_sdk53.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, Role, "Role");
  }
  /**
   * @deprecated
   * ## The endpoint is going to be deprecated ### Endpoint migration guide - **Substitute endpoint: _/iam/v3/admin/roles/{roleId} [DELETE]_**
   */
  deleteRole_ByRoleId(roleId) {
    const params = {};
    const url = "/iam/roles/{roleId}".replace("{roleId}", roleId);
    const resultPromise = this.axiosInstance.delete(url, { params });
    return import_sdk53.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, import_zod198.z.unknown(), "z.unknown()");
  }
  /**
   * @deprecated
   * ## The endpoint is going to be deprecated ### Endpoint migration guide - **Substitute endpoint: _/iam/v3/admin/roles/{roleId} [GET]_**
   */
  getRole_ByRoleId(roleId) {
    const params = {};
    const url = "/iam/roles/{roleId}".replace("{roleId}", roleId);
    const resultPromise = this.axiosInstance.get(url, { params });
    return import_sdk53.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, RoleResponse, "RoleResponse");
  }
  /**
   * @deprecated
   * ## The endpoint is going to be deprecated ### Endpoint migration guide - **Substitute endpoint: _/iam/v3/admin/roles/{roleId} [PATCH]_**
   */
  updateRole_ByRoleId(roleId, data) {
    const params = {};
    const url = "/iam/roles/{roleId}".replace("{roleId}", roleId);
    const resultPromise = this.axiosInstance.put(url, data, { params });
    return import_sdk53.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, RoleResponse, "RoleResponse");
  }
  /**
   * This endpoint is used to get all non-admin role. action code: 10418
   */
  getRoles_v3(queryParams) {
    const params = { ...queryParams };
    const url = "/iam/v3/public/roles";
    const resultPromise = this.axiosInstance.get(url, { params });
    return import_sdk53.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, RoleNamesResponseV3, "RoleNamesResponseV3");
  }
  /**
   * @deprecated
   * ## The endpoint is going to be deprecated ### Endpoint migration guide - **Substitute endpoint: _/iam/v3/admin/roles/{roleId}/admin [DELETE]_**
   */
  deleteAdmin_ByRoleId(roleId) {
    const params = {};
    const url = "/iam/roles/{roleId}/admin".replace("{roleId}", roleId);
    const resultPromise = this.axiosInstance.delete(url, { params });
    return import_sdk53.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, import_zod198.z.unknown(), "z.unknown()");
  }
  /**
   * @deprecated
   * ## The endpoint is going to be deprecated Admin roles has its members listed in the role. ### Endpoint migration guide - **Substitute endpoint: _/iam/v3/admin/roles/{roleId}/admin [GET]_**
   */
  getAdmin_ByRoleId(roleId) {
    const params = {};
    const url = "/iam/roles/{roleId}/admin".replace("{roleId}", roleId);
    const resultPromise = this.axiosInstance.get(url, { params });
    return import_sdk53.Validate.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      RoleAdminStatusResponse,
      "RoleAdminStatusResponse"
    );
  }
  /**
   * @deprecated
   * ## The endpoint is going to be deprecated Admin roles has its members listed in the role. Role can be set as admin role only when it has at least 1 manager. ### Endpoint migration guide - **Substitute endpoint: _/iam/v3/admin/roles/{roleId}/admin [POST]_**
   */
  updateAdmin_ByRoleId(roleId) {
    const params = {};
    const url = "/iam/roles/{roleId}/admin".replace("{roleId}", roleId);
    const resultPromise = this.axiosInstance.post(url, null, { params });
    return import_sdk53.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, import_zod198.z.unknown(), "z.unknown()");
  }
  /**
   * @deprecated
   * ## The endpoint is going to be deprecated ### Endpoint migration guide - **Substitute endpoint: _/iam/v3/admin/roles/{roleId}/members [DELETE]_**
   */
  deleteMember_ByRoleId(roleId, data) {
    const params = {};
    const url = "/iam/roles/{roleId}/members".replace("{roleId}", roleId);
    const resultPromise = this.axiosInstance.delete(url, { data, params });
    return import_sdk53.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, import_zod198.z.unknown(), "z.unknown()");
  }
  /**
   * @deprecated
   * ## The endpoint is going to be deprecated ### Endpoint migration guide - **Substitute endpoint: _/iam/v3/admin/roles/{roleId}/members [GET]_**
   */
  getMembers_ByRoleId(roleId) {
    const params = {};
    const url = "/iam/roles/{roleId}/members".replace("{roleId}", roleId);
    const resultPromise = this.axiosInstance.get(url, { params });
    return import_sdk53.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, RoleMembersResponse, "RoleMembersResponse");
  }
  /**
   * @deprecated
   * ## The endpoint is going to be deprecated Admin roles has its members listed in the role. Role can only be assigned to other users by the role&#39;s manager. ### Endpoint migration guide - **Substitute endpoint: _/iam/v3/admin/roles/{roleId}/members [POST]_**
   */
  updateMember_ByRoleId(roleId, data) {
    const params = {};
    const url = "/iam/roles/{roleId}/members".replace("{roleId}", roleId);
    const resultPromise = this.axiosInstance.post(url, data, { params });
    return import_sdk53.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, import_zod198.z.unknown(), "z.unknown()");
  }
  /**
   * @deprecated
   * ## The endpoint is going to be deprecated ### Endpoint migration guide - **Substitute endpoint: _/iam/v3/admin/roles/{roleId}/managers [DELETE]_**
   */
  deleteManager_ByRoleId(roleId, data) {
    const params = {};
    const url = "/iam/roles/{roleId}/managers".replace("{roleId}", roleId);
    const resultPromise = this.axiosInstance.delete(url, { data, params });
    return import_sdk53.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, import_zod198.z.unknown(), "z.unknown()");
  }
  /**
   * @deprecated
   * ## The endpoint is going to be deprecated Role can only be assigned to other users by the role&#39;s manager. ### Endpoint migration guide - **Substitute endpoint: _/iam/v3/admin/roles/{roleId}/managers [GET]_**
   */
  getManagers_ByRoleId(roleId) {
    const params = {};
    const url = "/iam/roles/{roleId}/managers".replace("{roleId}", roleId);
    const resultPromise = this.axiosInstance.get(url, { params });
    return import_sdk53.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, RoleManagersResponse, "RoleManagersResponse");
  }
  /**
   * @deprecated
   * ## The endpoint is going to be deprecated Role can only be assigned to other users by the role&#39;s manager. ### Endpoint migration guide - **Substitute endpoint: _/iam/v3/admin/roles/{roleId}/managers [POST]_**
   */
  updateManager_ByRoleId(roleId, data) {
    const params = {};
    const url = "/iam/roles/{roleId}/managers".replace("{roleId}", roleId);
    const resultPromise = this.axiosInstance.post(url, data, { params });
    return import_sdk53.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, import_zod198.z.unknown(), "z.unknown()");
  }
  /**
   * This endpoint is used to get non-admin role based on specify roleId. action code : 10417
   */
  getRole_ByRoleId_v3(roleId) {
    const params = {};
    const url = "/iam/v3/public/roles/{roleId}".replace("{roleId}", roleId);
    const resultPromise = this.axiosInstance.get(url, { params });
    return import_sdk53.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, RoleResponse, "RoleResponse");
  }
  /**
   * @deprecated
   * ## The endpoint is going to be deprecated This endpoint will REPLACE role&#39;s permissions with the ones defined in body Schedule contains cron string or date range (both are UTC, also in cron syntax) to indicate when a permission and action are in effect. Both schedule types accepts quartz compatible cron syntax e.g. * * * * * * *. In ranged schedule, first element will be start date, and second one will be end date If schedule is set, the scheduled action must be valid too, that is between 1 to 15, inclusive Syntax reference Fields: 1. Seconds: 0-59 * / , - 2. Minutes: 0-59 * / , - 3. Hours: 0-23 * / , - 4. Day of month: 1-31 * / , - L W 5. Month: 1-12 JAN-DEC * / , - 6. Day of week: 0-6 SUN-SAT * / , - L # 7. Year: 1970-2099 * / , - Special characters: 1. \*: all values in the fields, e.g. \* in seconds fields indicates every second 2. /: increments of ranges, e.g. 3-59/15 in the minute field indicate the third minute of the hour and every 15 minutes thereafter 3. ,: separate items of a list, e.g. MON,WED,FRI in day of week 4. -: range, e.g. 2010-2018 indicates every year between 2010 and 2018, inclusive 5. L: last, e.g. When used in the day-of-week field, it allows you to specify constructs such as &#34;the last Friday&#34; (5L) of a given month. In the day-of-month field, it specifies the last day of the month. 6. W: business day, e.g. if you were to specify 15W as the value for the day-of-month field, the meaning is: &#34;the nearest business day to the 15th of the month.&#34; 7. #: must be followed by a number between one and five. It allows you to specify constructs such as &#34;the second Friday&#34; of a given month. ### Endpoint migration guide - **Substitute endpoint: _/iam/v3/admin/roles/{roleId}/permissions [POST]_**
   */
  updatePermission_ByRoleId(roleId, data) {
    const params = {};
    const url = "/iam/roles/{roleId}/permissions".replace("{roleId}", roleId);
    const resultPromise = this.axiosInstance.post(url, data, { params });
    return import_sdk53.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, import_zod198.z.unknown(), "z.unknown()");
  }
  /**
   * @deprecated
   * ## The endpoint is going to be deprecated ### Endpoint migration guide - **Substitute endpoint: _/iam/v3/admin/roles/{roleId}/permissions/{resource}/{action} [DELETE]_** - **Substitute endpoint: _/iam/v4/admin/roles/{roleId}/permissions [DELETE]_**
   */
  deletePermission_ByRoleId_ByResource_ByAction(roleId, resource, action) {
    const params = {};
    const url = "/iam/roles/{roleId}/permissions/{resource}/{action}".replace("{roleId}", roleId).replace("{resource}", resource).replace("{action}", String(action));
    const resultPromise = this.axiosInstance.delete(url, { params });
    return import_sdk53.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, import_zod198.z.unknown(), "z.unknown()");
  }
  /**
   * @deprecated
   * ## The endpoint is going to be deprecated This endpoint will update existing permission (bitwise OR the action) if found one with same resource, otherwise it will append a new permission Schedule contains cron string or date range (both are UTC, also in cron syntax) to indicate when a permission and action are in effect. Both schedule types accepts quartz compatible cron syntax e.g. * * * * * * *. In ranged schedule, first element will be start date, and second one will be end date If schedule is set, the scheduled action must be valid too, that is between 1 to 15, inclusive Syntax reference Fields: - Seconds: 0-59 * / , - - Minutes: 0-59 * / , - - Hours: 0-23 * / , - - Day of month: 1-31 * / , - L W - Month: 1-12 JAN-DEC * / , - - Day of week: 0-6 SUN-SAT * / , - L # - Year: 1970-2099 * / , - Special characters: - \**: all values in the fields, e.g. \* in seconds fields indicates every second - /: increments of ranges, e.g. 3-59/15 in the minute field indicate the third minute of the hour and every 15 minutes thereafter - ,: separate items of a list, e.g. MON,WED,FRI in day of week - -: range, e.g. 2010-2018 indicates every year between 2010 and 2018, inclusive - L: last, e.g. When used in the day-of-week field, it allows you to specify constructs such as &#34;the last Friday&#34; (5L) of a given month. In the day-of-month field, it specifies the last day of the month. - W: business day, e.g. if you were to specify 15W as the value for the day-of-month field, the meaning is: &#34;the nearest business day to the 15th of the month.&#34; - #: must be followed by a number between one and five. It allows you to specify constructs such as &#34;the second Friday&#34; of a given month. ### Endpoint migration guide - **Substitute endpoint(update): _/iam/v3/admin/roles/{roleId}/permissions [PUT]_** - **Substitute endpoint(create): _/iam/v3/admin/roles/{roleId}/permissions [POST]_**
   */
  updatePermission_ByRoleId_ByResource_ByAction(roleId, resource, action, data) {
    const params = {};
    const url = "/iam/roles/{roleId}/permissions/{resource}/{action}".replace("{roleId}", roleId).replace("{resource}", resource).replace("{action}", String(action));
    const resultPromise = this.axiosInstance.post(url, data, { params });
    return import_sdk53.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, import_zod198.z.unknown(), "z.unknown()");
  }
};

// src/generated-public/RolesApi.ts
function RolesApi(sdk, args) {
  const sdkAssembly = sdk.assembly();
  const namespace = args?.coreConfig?.namespace ?? sdkAssembly.coreConfig.namespace;
  const useSchemaValidation = args?.coreConfig?.useSchemaValidation ?? sdkAssembly.coreConfig.useSchemaValidation;
  let axiosInstance = sdkAssembly.axiosInstance;
  const requestConfigOverrides = args?.axiosConfig?.request;
  const baseURLOverride = args?.coreConfig?.baseURL;
  const interceptorsOverride = args?.axiosConfig?.interceptors ?? [];
  if (requestConfigOverrides || baseURLOverride || interceptorsOverride.length > 0) {
    const requestConfig = import_sdk54.ApiUtils.mergeAxiosConfigs(sdkAssembly.axiosInstance.defaults, {
      ...baseURLOverride ? { baseURL: baseURLOverride } : {},
      ...requestConfigOverrides
    });
    axiosInstance = import_sdk54.Network.create(requestConfig);
    for (const interceptor of interceptorsOverride) {
      if (interceptor.type === "request") {
        axiosInstance.interceptors.request.use(interceptor.onRequest, interceptor.onError);
      }
      if (interceptor.type === "response") {
        axiosInstance.interceptors.response.use(interceptor.onSuccess, interceptor.onError);
      }
    }
  }
  async function getRoles(queryParams) {
    const $ = new Roles$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getRoles(queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function createRole(data) {
    const $ = new Roles$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.createRole(data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function deleteRole_ByRoleId(roleId) {
    const $ = new Roles$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.deleteRole_ByRoleId(roleId);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getRole_ByRoleId(roleId) {
    const $ = new Roles$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getRole_ByRoleId(roleId);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function updateRole_ByRoleId(roleId, data) {
    const $ = new Roles$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.updateRole_ByRoleId(roleId, data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getRoles_v3(queryParams) {
    const $ = new Roles$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getRoles_v3(queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function deleteAdmin_ByRoleId(roleId) {
    const $ = new Roles$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.deleteAdmin_ByRoleId(roleId);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getAdmin_ByRoleId(roleId) {
    const $ = new Roles$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getAdmin_ByRoleId(roleId);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function updateAdmin_ByRoleId(roleId) {
    const $ = new Roles$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.updateAdmin_ByRoleId(roleId);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function deleteMember_ByRoleId(roleId, data) {
    const $ = new Roles$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.deleteMember_ByRoleId(roleId, data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getMembers_ByRoleId(roleId) {
    const $ = new Roles$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getMembers_ByRoleId(roleId);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function updateMember_ByRoleId(roleId, data) {
    const $ = new Roles$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.updateMember_ByRoleId(roleId, data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function deleteManager_ByRoleId(roleId, data) {
    const $ = new Roles$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.deleteManager_ByRoleId(roleId, data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getManagers_ByRoleId(roleId) {
    const $ = new Roles$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getManagers_ByRoleId(roleId);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function updateManager_ByRoleId(roleId, data) {
    const $ = new Roles$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.updateManager_ByRoleId(roleId, data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getRole_ByRoleId_v3(roleId) {
    const $ = new Roles$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getRole_ByRoleId_v3(roleId);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function updatePermission_ByRoleId(roleId, data) {
    const $ = new Roles$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.updatePermission_ByRoleId(roleId, data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function deletePermission_ByRoleId_ByResource_ByAction(roleId, resource, action) {
    const $ = new Roles$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.deletePermission_ByRoleId_ByResource_ByAction(roleId, resource, action);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function updatePermission_ByRoleId_ByResource_ByAction(roleId, resource, action, data) {
    const $ = new Roles$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.updatePermission_ByRoleId_ByResource_ByAction(roleId, resource, action, data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  return {
    /**
     * @deprecated
     * ## The endpoint is going to be deprecated ### Endpoint migration guide - **Substitute endpoint: _/iam/v3/admin/roles [GET]_**
     */
    getRoles,
    /**
     * @deprecated
     * ## The endpoint is going to be deprecated Role can only be assigned to other users by the role&#39;s manager. If role is an administrator role (i.e. AdminRole == true), it will list out the role&#39;s members. Administrator role can be created only when at least 1 manager is specified. ### Endpoint migration guide - **Substitute endpoint: _/iam/v3/admin/roles [POST]_**
     */
    createRole,
    /**
     * @deprecated
     * ## The endpoint is going to be deprecated ### Endpoint migration guide - **Substitute endpoint: _/iam/v3/admin/roles/{roleId} [DELETE]_**
     */
    deleteRole_ByRoleId,
    /**
     * @deprecated
     * ## The endpoint is going to be deprecated ### Endpoint migration guide - **Substitute endpoint: _/iam/v3/admin/roles/{roleId} [GET]_**
     */
    getRole_ByRoleId,
    /**
     * @deprecated
     * ## The endpoint is going to be deprecated ### Endpoint migration guide - **Substitute endpoint: _/iam/v3/admin/roles/{roleId} [PATCH]_**
     */
    updateRole_ByRoleId,
    /**
     * This endpoint is used to get all non-admin role. action code: 10418
     */
    getRoles_v3,
    /**
     * @deprecated
     * ## The endpoint is going to be deprecated ### Endpoint migration guide - **Substitute endpoint: _/iam/v3/admin/roles/{roleId}/admin [DELETE]_**
     */
    deleteAdmin_ByRoleId,
    /**
     * @deprecated
     * ## The endpoint is going to be deprecated Admin roles has its members listed in the role. ### Endpoint migration guide - **Substitute endpoint: _/iam/v3/admin/roles/{roleId}/admin [GET]_**
     */
    getAdmin_ByRoleId,
    /**
     * @deprecated
     * ## The endpoint is going to be deprecated Admin roles has its members listed in the role. Role can be set as admin role only when it has at least 1 manager. ### Endpoint migration guide - **Substitute endpoint: _/iam/v3/admin/roles/{roleId}/admin [POST]_**
     */
    updateAdmin_ByRoleId,
    /**
     * @deprecated
     * ## The endpoint is going to be deprecated ### Endpoint migration guide - **Substitute endpoint: _/iam/v3/admin/roles/{roleId}/members [DELETE]_**
     */
    deleteMember_ByRoleId,
    /**
     * @deprecated
     * ## The endpoint is going to be deprecated ### Endpoint migration guide - **Substitute endpoint: _/iam/v3/admin/roles/{roleId}/members [GET]_**
     */
    getMembers_ByRoleId,
    /**
     * @deprecated
     * ## The endpoint is going to be deprecated Admin roles has its members listed in the role. Role can only be assigned to other users by the role&#39;s manager. ### Endpoint migration guide - **Substitute endpoint: _/iam/v3/admin/roles/{roleId}/members [POST]_**
     */
    updateMember_ByRoleId,
    /**
     * @deprecated
     * ## The endpoint is going to be deprecated ### Endpoint migration guide - **Substitute endpoint: _/iam/v3/admin/roles/{roleId}/managers [DELETE]_**
     */
    deleteManager_ByRoleId,
    /**
     * @deprecated
     * ## The endpoint is going to be deprecated Role can only be assigned to other users by the role&#39;s manager. ### Endpoint migration guide - **Substitute endpoint: _/iam/v3/admin/roles/{roleId}/managers [GET]_**
     */
    getManagers_ByRoleId,
    /**
     * @deprecated
     * ## The endpoint is going to be deprecated Role can only be assigned to other users by the role&#39;s manager. ### Endpoint migration guide - **Substitute endpoint: _/iam/v3/admin/roles/{roleId}/managers [POST]_**
     */
    updateManager_ByRoleId,
    /**
     * This endpoint is used to get non-admin role based on specify roleId. action code : 10417
     */
    getRole_ByRoleId_v3,
    /**
     * @deprecated
     * ## The endpoint is going to be deprecated This endpoint will REPLACE role&#39;s permissions with the ones defined in body Schedule contains cron string or date range (both are UTC, also in cron syntax) to indicate when a permission and action are in effect. Both schedule types accepts quartz compatible cron syntax e.g. * * * * * * *. In ranged schedule, first element will be start date, and second one will be end date If schedule is set, the scheduled action must be valid too, that is between 1 to 15, inclusive Syntax reference Fields: 1. Seconds: 0-59 * / , - 2. Minutes: 0-59 * / , - 3. Hours: 0-23 * / , - 4. Day of month: 1-31 * / , - L W 5. Month: 1-12 JAN-DEC * / , - 6. Day of week: 0-6 SUN-SAT * / , - L # 7. Year: 1970-2099 * / , - Special characters: 1. \*: all values in the fields, e.g. \* in seconds fields indicates every second 2. /: increments of ranges, e.g. 3-59/15 in the minute field indicate the third minute of the hour and every 15 minutes thereafter 3. ,: separate items of a list, e.g. MON,WED,FRI in day of week 4. -: range, e.g. 2010-2018 indicates every year between 2010 and 2018, inclusive 5. L: last, e.g. When used in the day-of-week field, it allows you to specify constructs such as &#34;the last Friday&#34; (5L) of a given month. In the day-of-month field, it specifies the last day of the month. 6. W: business day, e.g. if you were to specify 15W as the value for the day-of-month field, the meaning is: &#34;the nearest business day to the 15th of the month.&#34; 7. #: must be followed by a number between one and five. It allows you to specify constructs such as &#34;the second Friday&#34; of a given month. ### Endpoint migration guide - **Substitute endpoint: _/iam/v3/admin/roles/{roleId}/permissions [POST]_**
     */
    updatePermission_ByRoleId,
    /**
     * @deprecated
     * ## The endpoint is going to be deprecated ### Endpoint migration guide - **Substitute endpoint: _/iam/v3/admin/roles/{roleId}/permissions/{resource}/{action} [DELETE]_** - **Substitute endpoint: _/iam/v4/admin/roles/{roleId}/permissions [DELETE]_**
     */
    deletePermission_ByRoleId_ByResource_ByAction,
    /**
     * @deprecated
     * ## The endpoint is going to be deprecated This endpoint will update existing permission (bitwise OR the action) if found one with same resource, otherwise it will append a new permission Schedule contains cron string or date range (both are UTC, also in cron syntax) to indicate when a permission and action are in effect. Both schedule types accepts quartz compatible cron syntax e.g. * * * * * * *. In ranged schedule, first element will be start date, and second one will be end date If schedule is set, the scheduled action must be valid too, that is between 1 to 15, inclusive Syntax reference Fields: - Seconds: 0-59 * / , - - Minutes: 0-59 * / , - - Hours: 0-23 * / , - - Day of month: 1-31 * / , - L W - Month: 1-12 JAN-DEC * / , - - Day of week: 0-6 SUN-SAT * / , - L # - Year: 1970-2099 * / , - Special characters: - \**: all values in the fields, e.g. \* in seconds fields indicates every second - /: increments of ranges, e.g. 3-59/15 in the minute field indicate the third minute of the hour and every 15 minutes thereafter - ,: separate items of a list, e.g. MON,WED,FRI in day of week - -: range, e.g. 2010-2018 indicates every year between 2010 and 2018, inclusive - L: last, e.g. When used in the day-of-week field, it allows you to specify constructs such as &#34;the last Friday&#34; (5L) of a given month. In the day-of-month field, it specifies the last day of the month. - W: business day, e.g. if you were to specify 15W as the value for the day-of-month field, the meaning is: &#34;the nearest business day to the 15th of the month.&#34; - #: must be followed by a number between one and five. It allows you to specify constructs such as &#34;the second Friday&#34; of a given month. ### Endpoint migration guide - **Substitute endpoint(update): _/iam/v3/admin/roles/{roleId}/permissions [PUT]_** - **Substitute endpoint(create): _/iam/v3/admin/roles/{roleId}/permissions [POST]_**
     */
    updatePermission_ByRoleId_ByResource_ByAction
  };
}

// src/generated-public/queries/Roles.query.ts
var Key_Roles = /* @__PURE__ */ ((Key_Roles2) => {
  Key_Roles2["Roles"] = "Iam.Roles.Roles";
  Key_Roles2["Role"] = "Iam.Roles.Role";
  Key_Roles2["Role_ByRoleId"] = "Iam.Roles.Role_ByRoleId";
  Key_Roles2["Roles_v3"] = "Iam.Roles.Roles_v3";
  Key_Roles2["Admin_ByRoleId"] = "Iam.Roles.Admin_ByRoleId";
  Key_Roles2["Member_ByRoleId"] = "Iam.Roles.Member_ByRoleId";
  Key_Roles2["Members_ByRoleId"] = "Iam.Roles.Members_ByRoleId";
  Key_Roles2["Manager_ByRoleId"] = "Iam.Roles.Manager_ByRoleId";
  Key_Roles2["Managers_ByRoleId"] = "Iam.Roles.Managers_ByRoleId";
  Key_Roles2["Role_ByRoleId_v3"] = "Iam.Roles.Role_ByRoleId_v3";
  Key_Roles2["Permission_ByRoleId"] = "Iam.Roles.Permission_ByRoleId";
  Key_Roles2["Permission_ByRoleId_ByResource_ByAction"] = "Iam.Roles.Permission_ByRoleId_ByResource_ByAction";
  return Key_Roles2;
})(Key_Roles || {});
var useRolesApi_GetRoles = (sdk, input, options, callback) => {
  const queryFn = (sdk2, input2) => async () => {
    const response = await RolesApi(sdk2, { coreConfig: input2.coreConfig, axiosConfig: input2.axiosConfig }).getRoles(input2.queryParams);
    callback && callback(response);
    return response.data;
  };
  return (0, import_react_query27.useQuery)({
    queryKey: ["Iam.Roles.Roles" /* Roles */, input],
    queryFn: queryFn(sdk, input),
    ...options
  });
};
var useRolesApi_CreateRoleMutation = (sdk, options, callback) => {
  const mutationFn = async (input) => {
    const response = await RolesApi(sdk, { coreConfig: input.coreConfig, axiosConfig: input.axiosConfig }).createRole(input.data);
    callback && callback(response.data);
    return response.data;
  };
  return (0, import_react_query27.useMutation)({
    mutationKey: ["Iam.Roles.Role" /* Role */],
    mutationFn,
    ...options
  });
};
var useRolesApi_DeleteRole_ByRoleIdMutation = (sdk, options, callback) => {
  const mutationFn = async (input) => {
    const response = await RolesApi(sdk, { coreConfig: input.coreConfig, axiosConfig: input.axiosConfig }).deleteRole_ByRoleId(input.roleId);
    callback && callback(response.data);
    return response.data;
  };
  return (0, import_react_query27.useMutation)({
    mutationKey: ["Iam.Roles.Role_ByRoleId" /* Role_ByRoleId */],
    mutationFn,
    ...options
  });
};
var useRolesApi_GetRole_ByRoleId = (sdk, input, options, callback) => {
  const queryFn = (sdk2, input2) => async () => {
    const response = await RolesApi(sdk2, { coreConfig: input2.coreConfig, axiosConfig: input2.axiosConfig }).getRole_ByRoleId(input2.roleId);
    callback && callback(response);
    return response.data;
  };
  return (0, import_react_query27.useQuery)({
    queryKey: ["Iam.Roles.Role_ByRoleId" /* Role_ByRoleId */, input],
    queryFn: queryFn(sdk, input),
    ...options
  });
};
var useRolesApi_UpdateRole_ByRoleIdMutation = (sdk, options, callback) => {
  const mutationFn = async (input) => {
    const response = await RolesApi(sdk, { coreConfig: input.coreConfig, axiosConfig: input.axiosConfig }).updateRole_ByRoleId(
      input.roleId,
      input.data
    );
    callback && callback(response.data);
    return response.data;
  };
  return (0, import_react_query27.useMutation)({
    mutationKey: ["Iam.Roles.Role_ByRoleId" /* Role_ByRoleId */],
    mutationFn,
    ...options
  });
};
var useRolesApi_GetRoles_v3 = (sdk, input, options, callback) => {
  const queryFn = (sdk2, input2) => async () => {
    const response = await RolesApi(sdk2, { coreConfig: input2.coreConfig, axiosConfig: input2.axiosConfig }).getRoles_v3(input2.queryParams);
    callback && callback(response);
    return response.data;
  };
  return (0, import_react_query27.useQuery)({
    queryKey: ["Iam.Roles.Roles_v3" /* Roles_v3 */, input],
    queryFn: queryFn(sdk, input),
    ...options
  });
};
var useRolesApi_DeleteAdmin_ByRoleIdMutation = (sdk, options, callback) => {
  const mutationFn = async (input) => {
    const response = await RolesApi(sdk, { coreConfig: input.coreConfig, axiosConfig: input.axiosConfig }).deleteAdmin_ByRoleId(
      input.roleId
    );
    callback && callback(response.data);
    return response.data;
  };
  return (0, import_react_query27.useMutation)({
    mutationKey: ["Iam.Roles.Admin_ByRoleId" /* Admin_ByRoleId */],
    mutationFn,
    ...options
  });
};
var useRolesApi_GetAdmin_ByRoleId = (sdk, input, options, callback) => {
  const queryFn = (sdk2, input2) => async () => {
    const response = await RolesApi(sdk2, { coreConfig: input2.coreConfig, axiosConfig: input2.axiosConfig }).getAdmin_ByRoleId(input2.roleId);
    callback && callback(response);
    return response.data;
  };
  return (0, import_react_query27.useQuery)({
    queryKey: ["Iam.Roles.Admin_ByRoleId" /* Admin_ByRoleId */, input],
    queryFn: queryFn(sdk, input),
    ...options
  });
};
var useRolesApi_UpdateAdmin_ByRoleIdMutation = (sdk, options, callback) => {
  const mutationFn = async (input) => {
    const response = await RolesApi(sdk, { coreConfig: input.coreConfig, axiosConfig: input.axiosConfig }).updateAdmin_ByRoleId(
      input.roleId
    );
    callback && callback(response.data);
    return response.data;
  };
  return (0, import_react_query27.useMutation)({
    mutationKey: ["Iam.Roles.Admin_ByRoleId" /* Admin_ByRoleId */],
    mutationFn,
    ...options
  });
};
var useRolesApi_DeleteMember_ByRoleIdMutation = (sdk, options, callback) => {
  const mutationFn = async (input) => {
    const response = await RolesApi(sdk, { coreConfig: input.coreConfig, axiosConfig: input.axiosConfig }).deleteMember_ByRoleId(
      input.roleId,
      input.data
    );
    callback && callback(response.data);
    return response.data;
  };
  return (0, import_react_query27.useMutation)({
    mutationKey: ["Iam.Roles.Member_ByRoleId" /* Member_ByRoleId */],
    mutationFn,
    ...options
  });
};
var useRolesApi_GetMembers_ByRoleId = (sdk, input, options, callback) => {
  const queryFn = (sdk2, input2) => async () => {
    const response = await RolesApi(sdk2, { coreConfig: input2.coreConfig, axiosConfig: input2.axiosConfig }).getMembers_ByRoleId(input2.roleId);
    callback && callback(response);
    return response.data;
  };
  return (0, import_react_query27.useQuery)({
    queryKey: ["Iam.Roles.Members_ByRoleId" /* Members_ByRoleId */, input],
    queryFn: queryFn(sdk, input),
    ...options
  });
};
var useRolesApi_UpdateMember_ByRoleIdMutation = (sdk, options, callback) => {
  const mutationFn = async (input) => {
    const response = await RolesApi(sdk, { coreConfig: input.coreConfig, axiosConfig: input.axiosConfig }).updateMember_ByRoleId(
      input.roleId,
      input.data
    );
    callback && callback(response.data);
    return response.data;
  };
  return (0, import_react_query27.useMutation)({
    mutationKey: ["Iam.Roles.Member_ByRoleId" /* Member_ByRoleId */],
    mutationFn,
    ...options
  });
};
var useRolesApi_DeleteManager_ByRoleIdMutation = (sdk, options, callback) => {
  const mutationFn = async (input) => {
    const response = await RolesApi(sdk, { coreConfig: input.coreConfig, axiosConfig: input.axiosConfig }).deleteManager_ByRoleId(
      input.roleId,
      input.data
    );
    callback && callback(response.data);
    return response.data;
  };
  return (0, import_react_query27.useMutation)({
    mutationKey: ["Iam.Roles.Manager_ByRoleId" /* Manager_ByRoleId */],
    mutationFn,
    ...options
  });
};
var useRolesApi_GetManagers_ByRoleId = (sdk, input, options, callback) => {
  const queryFn = (sdk2, input2) => async () => {
    const response = await RolesApi(sdk2, { coreConfig: input2.coreConfig, axiosConfig: input2.axiosConfig }).getManagers_ByRoleId(
      input2.roleId
    );
    callback && callback(response);
    return response.data;
  };
  return (0, import_react_query27.useQuery)({
    queryKey: ["Iam.Roles.Managers_ByRoleId" /* Managers_ByRoleId */, input],
    queryFn: queryFn(sdk, input),
    ...options
  });
};
var useRolesApi_UpdateManager_ByRoleIdMutation = (sdk, options, callback) => {
  const mutationFn = async (input) => {
    const response = await RolesApi(sdk, { coreConfig: input.coreConfig, axiosConfig: input.axiosConfig }).updateManager_ByRoleId(
      input.roleId,
      input.data
    );
    callback && callback(response.data);
    return response.data;
  };
  return (0, import_react_query27.useMutation)({
    mutationKey: ["Iam.Roles.Manager_ByRoleId" /* Manager_ByRoleId */],
    mutationFn,
    ...options
  });
};
var useRolesApi_GetRole_ByRoleId_v3 = (sdk, input, options, callback) => {
  const queryFn = (sdk2, input2) => async () => {
    const response = await RolesApi(sdk2, { coreConfig: input2.coreConfig, axiosConfig: input2.axiosConfig }).getRole_ByRoleId_v3(input2.roleId);
    callback && callback(response);
    return response.data;
  };
  return (0, import_react_query27.useQuery)({
    queryKey: ["Iam.Roles.Role_ByRoleId_v3" /* Role_ByRoleId_v3 */, input],
    queryFn: queryFn(sdk, input),
    ...options
  });
};
var useRolesApi_UpdatePermission_ByRoleIdMutation = (sdk, options, callback) => {
  const mutationFn = async (input) => {
    const response = await RolesApi(sdk, { coreConfig: input.coreConfig, axiosConfig: input.axiosConfig }).updatePermission_ByRoleId(
      input.roleId,
      input.data
    );
    callback && callback(response.data);
    return response.data;
  };
  return (0, import_react_query27.useMutation)({
    mutationKey: ["Iam.Roles.Permission_ByRoleId" /* Permission_ByRoleId */],
    mutationFn,
    ...options
  });
};
var useRolesApi_DeletePermission_ByRoleId_ByResource_ByActionMutation = (sdk, options, callback) => {
  const mutationFn = async (input) => {
    const response = await RolesApi(sdk, {
      coreConfig: input.coreConfig,
      axiosConfig: input.axiosConfig
    }).deletePermission_ByRoleId_ByResource_ByAction(input.roleId, input.resource, input.action);
    callback && callback(response.data);
    return response.data;
  };
  return (0, import_react_query27.useMutation)({
    mutationKey: ["Iam.Roles.Permission_ByRoleId_ByResource_ByAction" /* Permission_ByRoleId_ByResource_ByAction */],
    mutationFn,
    ...options
  });
};
var useRolesApi_UpdatePermission_ByRoleId_ByResource_ByActionMutation = (sdk, options, callback) => {
  const mutationFn = async (input) => {
    const response = await RolesApi(sdk, {
      coreConfig: input.coreConfig,
      axiosConfig: input.axiosConfig
    }).updatePermission_ByRoleId_ByResource_ByAction(input.roleId, input.resource, input.action, input.data);
    callback && callback(response.data);
    return response.data;
  };
  return (0, import_react_query27.useMutation)({
    mutationKey: ["Iam.Roles.Permission_ByRoleId_ByResource_ByAction" /* Permission_ByRoleId_ByResource_ByAction */],
    mutationFn,
    ...options
  });
};

// src/generated-public/queries/Sso.query.ts
var import_react_query28 = require("@tanstack/react-query");

// src/generated-public/SsoApi.ts
var import_sdk56 = require("@accelbyte/sdk");

// src/generated-public/endpoints/Sso$.ts
var import_sdk55 = require("@accelbyte/sdk");
var import_zod199 = require("zod");
var Sso$ = class {
  // @ts-ignore
  // prettier-ignore
  constructor(axiosInstance, namespace, useSchemaValidation = true) {
    this.axiosInstance = axiosInstance;
    this.namespace = namespace;
    this.useSchemaValidation = useSchemaValidation;
  }
  getSso_ByPlatformId_v3(platformId, queryParams) {
    const params = { ...queryParams };
    const url = "/iam/v3/sso/{platformId}".replace("{platformId}", platformId);
    const resultPromise = this.axiosInstance.get(url, { params });
    return import_sdk55.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, import_zod199.z.unknown(), "z.unknown()");
  }
  /**
   * Logout user&#39;s session on platform that logged in using SSO. Supported platforms: - discourse
   */
  createLogout_ByPlatformId_v3(platformId) {
    const params = {};
    const url = "/iam/v3/sso/{platformId}/logout".replace("{platformId}", platformId);
    const resultPromise = this.axiosInstance.post(url, null, { params });
    return import_sdk55.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, import_zod199.z.unknown(), "z.unknown()");
  }
};

// src/generated-public/SsoApi.ts
function SsoApi(sdk, args) {
  const sdkAssembly = sdk.assembly();
  const namespace = args?.coreConfig?.namespace ?? sdkAssembly.coreConfig.namespace;
  const useSchemaValidation = args?.coreConfig?.useSchemaValidation ?? sdkAssembly.coreConfig.useSchemaValidation;
  let axiosInstance = sdkAssembly.axiosInstance;
  const requestConfigOverrides = args?.axiosConfig?.request;
  const baseURLOverride = args?.coreConfig?.baseURL;
  const interceptorsOverride = args?.axiosConfig?.interceptors ?? [];
  if (requestConfigOverrides || baseURLOverride || interceptorsOverride.length > 0) {
    const requestConfig = import_sdk56.ApiUtils.mergeAxiosConfigs(sdkAssembly.axiosInstance.defaults, {
      ...baseURLOverride ? { baseURL: baseURLOverride } : {},
      ...requestConfigOverrides
    });
    axiosInstance = import_sdk56.Network.create(requestConfig);
    for (const interceptor of interceptorsOverride) {
      if (interceptor.type === "request") {
        axiosInstance.interceptors.request.use(interceptor.onRequest, interceptor.onError);
      }
      if (interceptor.type === "response") {
        axiosInstance.interceptors.response.use(interceptor.onSuccess, interceptor.onError);
      }
    }
  }
  async function getSso_ByPlatformId_v3(platformId, queryParams) {
    const $ = new Sso$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getSso_ByPlatformId_v3(platformId, queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function createLogout_ByPlatformId_v3(platformId) {
    const $ = new Sso$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.createLogout_ByPlatformId_v3(platformId);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  return {
    getSso_ByPlatformId_v3,
    /**
     * Logout user&#39;s session on platform that logged in using SSO. Supported platforms: - discourse
     */
    createLogout_ByPlatformId_v3
  };
}

// src/generated-public/queries/Sso.query.ts
var Key_Sso = /* @__PURE__ */ ((Key_Sso2) => {
  Key_Sso2["Sso_ByPlatformId_v3"] = "Iam.Sso.Sso_ByPlatformId_v3";
  Key_Sso2["Logout_ByPlatformId_v3"] = "Iam.Sso.Logout_ByPlatformId_v3";
  return Key_Sso2;
})(Key_Sso || {});
var useSsoApi_GetSso_ByPlatformId_v3 = (sdk, input, options, callback) => {
  const queryFn = (sdk2, input2) => async () => {
    const response = await SsoApi(sdk2, { coreConfig: input2.coreConfig, axiosConfig: input2.axiosConfig }).getSso_ByPlatformId_v3(
      input2.platformId,
      input2.queryParams
    );
    callback && callback(response);
    return response.data;
  };
  return (0, import_react_query28.useQuery)({
    queryKey: ["Iam.Sso.Sso_ByPlatformId_v3" /* Sso_ByPlatformId_v3 */, input],
    queryFn: queryFn(sdk, input),
    ...options
  });
};
var useSsoApi_CreateLogout_ByPlatformIdMutation_v3 = (sdk, options, callback) => {
  const mutationFn = async (input) => {
    const response = await SsoApi(sdk, { coreConfig: input.coreConfig, axiosConfig: input.axiosConfig }).createLogout_ByPlatformId_v3(
      input.platformId
    );
    callback && callback(response.data);
    return response.data;
  };
  return (0, import_react_query28.useMutation)({
    mutationKey: ["Iam.Sso.Logout_ByPlatformId_v3" /* Logout_ByPlatformId_v3 */],
    mutationFn,
    ...options
  });
};

// src/generated-public/queries/SsoSaml20.query.ts
var import_react_query29 = require("@tanstack/react-query");

// src/generated-public/SsoSaml20Api.ts
var import_sdk58 = require("@accelbyte/sdk");

// src/generated-public/endpoints/SsoSaml20$.ts
var import_sdk57 = require("@accelbyte/sdk");
var import_zod200 = require("zod");
var SsoSaml20$ = class {
  // @ts-ignore
  // prettier-ignore
  constructor(axiosInstance, namespace, useSchemaValidation = true) {
    this.axiosInstance = axiosInstance;
    this.namespace = namespace;
    this.useSchemaValidation = useSchemaValidation;
  }
  /**
   * This endpoint authenticates user platform for SAML protocol. It validates user to its respective platforms. Deactivated or login-banned users are unable to login. ## Supported platforms: - **azure** Microsoft login page will redirects to this endpoint after login success as previously defined on authentication request SAML
   */
  postAuthenticateSamlSso_ByPlatformId_v3(platformId, queryParams) {
    const params = { ...queryParams };
    const url = "/iam/v3/sso/saml/platforms/{platformId}/authenticate".replace("{platformId}", platformId);
    const resultPromise = this.axiosInstance.post(url, null, {
      ...params,
      headers: { ...params.headers, "content-type": "application/x-www-form-urlencoded" }
    });
    return import_sdk57.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, import_zod200.z.unknown(), "z.unknown()");
  }
};

// src/generated-public/SsoSaml20Api.ts
function SsoSaml20Api(sdk, args) {
  const sdkAssembly = sdk.assembly();
  const namespace = args?.coreConfig?.namespace ?? sdkAssembly.coreConfig.namespace;
  const useSchemaValidation = args?.coreConfig?.useSchemaValidation ?? sdkAssembly.coreConfig.useSchemaValidation;
  let axiosInstance = sdkAssembly.axiosInstance;
  const requestConfigOverrides = args?.axiosConfig?.request;
  const baseURLOverride = args?.coreConfig?.baseURL;
  const interceptorsOverride = args?.axiosConfig?.interceptors ?? [];
  if (requestConfigOverrides || baseURLOverride || interceptorsOverride.length > 0) {
    const requestConfig = import_sdk58.ApiUtils.mergeAxiosConfigs(sdkAssembly.axiosInstance.defaults, {
      ...baseURLOverride ? { baseURL: baseURLOverride } : {},
      ...requestConfigOverrides
    });
    axiosInstance = import_sdk58.Network.create(requestConfig);
    for (const interceptor of interceptorsOverride) {
      if (interceptor.type === "request") {
        axiosInstance.interceptors.request.use(interceptor.onRequest, interceptor.onError);
      }
      if (interceptor.type === "response") {
        axiosInstance.interceptors.response.use(interceptor.onSuccess, interceptor.onError);
      }
    }
  }
  async function postAuthenticateSamlSso_ByPlatformId_v3(platformId, queryParams) {
    const $ = new SsoSaml20$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.postAuthenticateSamlSso_ByPlatformId_v3(platformId, queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  return {
    /**
     * This endpoint authenticates user platform for SAML protocol. It validates user to its respective platforms. Deactivated or login-banned users are unable to login. ## Supported platforms: - **azure** Microsoft login page will redirects to this endpoint after login success as previously defined on authentication request SAML
     */
    postAuthenticateSamlSso_ByPlatformId_v3
  };
}

// src/generated-public/queries/SsoSaml20.query.ts
var Key_SsoSaml20 = /* @__PURE__ */ ((Key_SsoSaml202) => {
  Key_SsoSaml202["AuthenticateSamlSso_ByPlatformId_v3"] = "Iam.SsoSaml20.AuthenticateSamlSso_ByPlatformId_v3";
  return Key_SsoSaml202;
})(Key_SsoSaml20 || {});
var useSsoSaml20Api_PostAuthenticateSamlSso_ByPlatformIdMutation_v3 = (sdk, options, callback) => {
  const mutationFn = async (input) => {
    const response = await SsoSaml20Api(sdk, {
      coreConfig: input.coreConfig,
      axiosConfig: input.axiosConfig
    }).postAuthenticateSamlSso_ByPlatformId_v3(input.platformId, input.queryParams);
    callback && callback(response.data);
    return response.data;
  };
  return (0, import_react_query29.useMutation)({
    mutationKey: ["Iam.SsoSaml20.AuthenticateSamlSso_ByPlatformId_v3" /* AuthenticateSamlSso_ByPlatformId_v3 */],
    mutationFn,
    ...options
  });
};

// src/generated-public/queries/ThirdPartyCredential.query.ts
var import_react_query30 = require("@tanstack/react-query");

// src/generated-public/ThirdPartyCredentialApi.ts
var import_sdk60 = require("@accelbyte/sdk");

// src/generated-public/endpoints/ThirdPartyCredential$.ts
var import_sdk59 = require("@accelbyte/sdk");

// src/generated-definitions/PublicThirdPartyPlatformInfoArray.ts
var import_zod202 = require("zod");

// src/generated-definitions/PublicThirdPartyPlatformInfo.ts
var import_zod201 = require("zod");
var PublicThirdPartyPlatformInfo = import_zod201.z.object({
  AppId: import_zod201.z.string(),
  ClientId: import_zod201.z.string(),
  Environment: import_zod201.z.string(),
  IsActive: import_zod201.z.boolean(),
  LogoURL: import_zod201.z.string().nullish(),
  PlatformId: import_zod201.z.string(),
  PlatformName: import_zod201.z.string(),
  TokenAuthenticationType: import_zod201.z.string()
});

// src/generated-definitions/PublicThirdPartyPlatformInfoArray.ts
var PublicThirdPartyPlatformInfoArray = import_zod202.z.array(PublicThirdPartyPlatformInfo);

// src/generated-public/endpoints/ThirdPartyCredential$.ts
var ThirdPartyCredential$ = class {
  // @ts-ignore
  // prettier-ignore
  constructor(axiosInstance, namespace, useSchemaValidation = true) {
    this.axiosInstance = axiosInstance;
    this.namespace = namespace;
    this.useSchemaValidation = useSchemaValidation;
  }
  /**
   * This is the Public API to Get All Active OIDC Platform Credential By Client ID
   */
  getPlatformsClientsOidc_v3(queryParams) {
    const params = { ...queryParams };
    const url = "/iam/v3/public/namespaces/{namespace}/platforms/clients/oidc".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.get(url, { params });
    return import_sdk59.Validate.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      PublicThirdPartyPlatformInfoArray,
      "PublicThirdPartyPlatformInfoArray"
    );
  }
  /**
   * This is the Public API to Get All Active 3rd Platform Credential.
   */
  getPlatformsClientsActive_v3() {
    const params = {};
    const url = "/iam/v3/public/namespaces/{namespace}/platforms/clients/active".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.get(url, { params });
    return import_sdk59.Validate.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      PublicThirdPartyPlatformInfoArray,
      "PublicThirdPartyPlatformInfoArray"
    );
  }
};

// src/generated-public/ThirdPartyCredentialApi.ts
function ThirdPartyCredentialApi(sdk, args) {
  const sdkAssembly = sdk.assembly();
  const namespace = args?.coreConfig?.namespace ?? sdkAssembly.coreConfig.namespace;
  const useSchemaValidation = args?.coreConfig?.useSchemaValidation ?? sdkAssembly.coreConfig.useSchemaValidation;
  let axiosInstance = sdkAssembly.axiosInstance;
  const requestConfigOverrides = args?.axiosConfig?.request;
  const baseURLOverride = args?.coreConfig?.baseURL;
  const interceptorsOverride = args?.axiosConfig?.interceptors ?? [];
  if (requestConfigOverrides || baseURLOverride || interceptorsOverride.length > 0) {
    const requestConfig = import_sdk60.ApiUtils.mergeAxiosConfigs(sdkAssembly.axiosInstance.defaults, {
      ...baseURLOverride ? { baseURL: baseURLOverride } : {},
      ...requestConfigOverrides
    });
    axiosInstance = import_sdk60.Network.create(requestConfig);
    for (const interceptor of interceptorsOverride) {
      if (interceptor.type === "request") {
        axiosInstance.interceptors.request.use(interceptor.onRequest, interceptor.onError);
      }
      if (interceptor.type === "response") {
        axiosInstance.interceptors.response.use(interceptor.onSuccess, interceptor.onError);
      }
    }
  }
  async function getPlatformsClientsOidc_v3(queryParams) {
    const $ = new ThirdPartyCredential$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getPlatformsClientsOidc_v3(queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getPlatformsClientsActive_v3() {
    const $ = new ThirdPartyCredential$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getPlatformsClientsActive_v3();
    if (resp.error) throw resp.error;
    return resp.response;
  }
  return {
    /**
     * This is the Public API to Get All Active OIDC Platform Credential By Client ID
     */
    getPlatformsClientsOidc_v3,
    /**
     * This is the Public API to Get All Active 3rd Platform Credential.
     */
    getPlatformsClientsActive_v3
  };
}

// src/generated-public/queries/ThirdPartyCredential.query.ts
var Key_ThirdPartyCredential = /* @__PURE__ */ ((Key_ThirdPartyCredential2) => {
  Key_ThirdPartyCredential2["PlatformsClientsOidc_v3"] = "Iam.ThirdPartyCredential.PlatformsClientsOidc_v3";
  Key_ThirdPartyCredential2["PlatformsClientsActive_v3"] = "Iam.ThirdPartyCredential.PlatformsClientsActive_v3";
  return Key_ThirdPartyCredential2;
})(Key_ThirdPartyCredential || {});
var useThirdPartyCredentialApi_GetPlatformsClientsOidc_v3 = (sdk, input, options, callback) => {
  const queryFn = (sdk2, input2) => async () => {
    const response = await ThirdPartyCredentialApi(sdk2, {
      coreConfig: input2.coreConfig,
      axiosConfig: input2.axiosConfig
    }).getPlatformsClientsOidc_v3(input2.queryParams);
    callback && callback(response);
    return response.data;
  };
  return (0, import_react_query30.useQuery)({
    queryKey: ["Iam.ThirdPartyCredential.PlatformsClientsOidc_v3" /* PlatformsClientsOidc_v3 */, input],
    queryFn: queryFn(sdk, input),
    ...options
  });
};
var useThirdPartyCredentialApi_GetPlatformsClientsActive_v3 = (sdk, input, options, callback) => {
  const queryFn = (sdk2, input2) => async () => {
    const response = await ThirdPartyCredentialApi(sdk2, {
      coreConfig: input2.coreConfig,
      axiosConfig: input2.axiosConfig
    }).getPlatformsClientsActive_v3();
    callback && callback(response);
    return response.data;
  };
  return (0, import_react_query30.useQuery)({
    queryKey: ["Iam.ThirdPartyCredential.PlatformsClientsActive_v3" /* PlatformsClientsActive_v3 */, input],
    queryFn: queryFn(sdk, input),
    ...options
  });
};

// src/generated-public/queries/Users.query.ts
var import_react_query31 = require("@tanstack/react-query");

// src/generated-public/UsersApi.ts
var import_sdk62 = require("@accelbyte/sdk");

// src/generated-public/endpoints/Users$.ts
var import_sdk61 = require("@accelbyte/sdk");
var import_zod237 = require("zod");

// src/generated-definitions/GetAdminUsersResponse.ts
var import_zod203 = require("zod");
var GetAdminUsersResponse = import_zod203.z.object({ Data: import_zod203.z.array(UserResponse), Paging: Pagination });

// src/generated-definitions/GetLinkHeadlessAccountConflictResponse.ts
var import_zod205 = require("zod");

// src/generated-definitions/AccountProgressionInfo.ts
var import_zod204 = require("zod");
var AccountProgressionInfo = import_zod204.z.object({
  displayName: import_zod204.z.string().nullish(),
  email: import_zod204.z.string().nullish(),
  linkedGames: import_zod204.z.array(import_zod204.z.string()),
  userName: import_zod204.z.string().nullish()
});

// src/generated-definitions/GetLinkHeadlessAccountConflictResponse.ts
var GetLinkHeadlessAccountConflictResponse = import_zod205.z.object({
  currentAccount: AccountProgressionInfo.nullish(),
  headlessAccount: AccountProgressionInfo.nullish(),
  platformAlreadyLinked: import_zod205.z.boolean(),
  platformId: import_zod205.z.string(),
  platformLinkConflict: import_zod205.z.boolean()
});

// src/generated-definitions/GetPublisherUserResponse.ts
var import_zod206 = require("zod");
var GetPublisherUserResponse = import_zod206.z.object({ Namespace: import_zod206.z.string(), UserId: import_zod206.z.string() });

// src/generated-definitions/GetUserJusticePlatformAccountResponse.ts
var import_zod207 = require("zod");
var GetUserJusticePlatformAccountResponse = import_zod207.z.object({ DesignatedNamespace: import_zod207.z.string(), UserID: import_zod207.z.string() });

// src/generated-definitions/GetUserMappingV3Array.ts
var import_zod208 = require("zod");
var GetUserMappingV3Array = import_zod208.z.array(GetUserMappingV3);

// src/generated-definitions/LinkRequest.ts
var import_zod213 = require("zod");

// src/generated-definitions/ErrorResponseWithConflictedUserPlatformAccounts.ts
var import_zod212 = require("zod");

// src/generated-definitions/ConflictedUserPlatformAccounts.ts
var import_zod210 = require("zod");

// src/generated-definitions/UserWithLinkedPlatformAccounts.ts
var import_zod209 = require("zod");
var UserWithLinkedPlatformAccounts = import_zod209.z.object({
  displayName: import_zod209.z.string(),
  emailAddress: import_zod209.z.string(),
  linkedPlatforms: import_zod209.z.array(PlatformAccount),
  namespace: import_zod209.z.string(),
  uniqueDisplayName: import_zod209.z.string(),
  userId: import_zod209.z.string()
});

// src/generated-definitions/ConflictedUserPlatformAccounts.ts
var ConflictedUserPlatformAccounts = import_zod210.z.object({
  platformUserID: import_zod210.z.string(),
  publisherAccounts: import_zod210.z.array(UserWithLinkedPlatformAccounts)
});

// src/generated-definitions/PlatformLinkingHistory.ts
var import_zod211 = require("zod");
var PlatformLinkingHistory = import_zod211.z.object({ platformDisplayName: import_zod211.z.string(), platformID: import_zod211.z.string(), platformUserID: import_zod211.z.string() });

// src/generated-definitions/ErrorResponseWithConflictedUserPlatformAccounts.ts
var ErrorResponseWithConflictedUserPlatformAccounts = import_zod212.z.object({
  errorCode: import_zod212.z.number().int(),
  errorMessage: import_zod212.z.string(),
  messageVariables: ConflictedUserPlatformAccounts.nullish(),
  previousLinkedPlatformAccount: PlatformLinkingHistory.nullish()
});

// src/generated-definitions/LinkRequest.ts
var LinkRequest = import_zod213.z.object({
  client_id: import_zod213.z.string(),
  conflict_publisher_user_id: import_zod213.z.string().nullish(),
  conflict_user_linked_games: import_zod213.z.array(import_zod213.z.string()).nullish(),
  current_user_linked_games: import_zod213.z.array(import_zod213.z.string()).nullish(),
  error: ErrorResponseWithConflictedUserPlatformAccounts.nullish(),
  expiration: import_zod213.z.number().int().nullish(),
  namespace: import_zod213.z.string(),
  operation_name: import_zod213.z.string(),
  payload: import_zod213.z.record(import_zod213.z.any()),
  platformDisplayName: import_zod213.z.string().nullish(),
  platformID: import_zod213.z.string().nullish(),
  platform_user_id: import_zod213.z.string().nullish(),
  redirect_uri: import_zod213.z.string(),
  refreshToken: import_zod213.z.string().nullish(),
  request_id: import_zod213.z.string(),
  status: import_zod213.z.string(),
  userID: import_zod213.z.string().nullish()
});

// src/generated-definitions/ListBulkUserResponse.ts
var import_zod215 = require("zod");

// src/generated-definitions/UserBaseInfo.ts
var import_zod214 = require("zod");
var UserBaseInfo = import_zod214.z.object({
  avatarUrl: import_zod214.z.string(),
  displayName: import_zod214.z.string(),
  platformUserIds: import_zod214.z.record(import_zod214.z.string()),
  uniqueDisplayName: import_zod214.z.string().nullish(),
  userId: import_zod214.z.string(),
  username: import_zod214.z.string().nullish()
});

// src/generated-definitions/ListBulkUserResponse.ts
var ListBulkUserResponse = import_zod215.z.object({ data: import_zod215.z.array(UserBaseInfo) });

// src/generated-definitions/PublicUserInformationResponseV3.ts
var import_zod217 = require("zod");

// src/generated-definitions/PublicUserInformationV3.ts
var import_zod216 = require("zod");
var PublicUserInformationV3 = import_zod216.z.object({
  createdAt: import_zod216.z.string(),
  displayName: import_zod216.z.string(),
  namespace: import_zod216.z.string(),
  uniqueDisplayName: import_zod216.z.string().nullish(),
  userId: import_zod216.z.string(),
  userName: import_zod216.z.string(),
  userPlatformInfos: import_zod216.z.array(UserPlatformInfo).nullish()
});

// src/generated-definitions/PublicUserInformationResponseV3.ts
var PublicUserInformationResponseV3 = import_zod217.z.object({ data: import_zod217.z.array(PublicUserInformationV3), paging: PaginationV3 });

// src/generated-definitions/PublicUserResponse.ts
var import_zod218 = require("zod");
var PublicUserResponse = import_zod218.z.object({
  AuthType: import_zod218.z.string(),
  Bans: import_zod218.z.array(UserActiveBanResponse),
  CreatedAt: import_zod218.z.string(),
  DeletionStatus: import_zod218.z.boolean(),
  DisplayName: import_zod218.z.string(),
  EmailVerified: import_zod218.z.boolean(),
  Enabled: import_zod218.z.boolean(),
  LastEnabledChangedTime: import_zod218.z.string(),
  LoginId: import_zod218.z.string(),
  Namespace: import_zod218.z.string(),
  NamespaceRoles: import_zod218.z.array(NamespaceRole),
  Permissions: import_zod218.z.array(Permission),
  PhoneVerified: import_zod218.z.boolean(),
  PlatformId: import_zod218.z.string().nullish(),
  PlatformUserId: import_zod218.z.string().nullish(),
  Roles: import_zod218.z.array(import_zod218.z.string()),
  UserId: import_zod218.z.string(),
  Username: import_zod218.z.string().nullish(),
  XUID: import_zod218.z.string().nullish()
});

// src/generated-definitions/PublicUserResponseV3.ts
var import_zod219 = require("zod");
var PublicUserResponseV3 = import_zod219.z.object({
  authType: import_zod219.z.string(),
  avatarUrl: import_zod219.z.string().nullish(),
  bans: import_zod219.z.array(UserActiveBanResponseV3),
  createdAt: import_zod219.z.string(),
  deletionStatus: import_zod219.z.boolean(),
  displayName: import_zod219.z.string(),
  emailVerified: import_zod219.z.boolean(),
  enabled: import_zod219.z.boolean(),
  lastDateOfBirthChangedTime: import_zod219.z.string(),
  lastEnabledChangedTime: import_zod219.z.string(),
  namespace: import_zod219.z.string(),
  namespaceRoles: import_zod219.z.array(NamespaceRole),
  permissions: import_zod219.z.array(UserPermissionsResponseV3),
  phoneVerified: import_zod219.z.boolean(),
  platformId: import_zod219.z.string().nullish(),
  platformUserId: import_zod219.z.string().nullish(),
  roles: import_zod219.z.array(import_zod219.z.string()),
  uniqueDisplayName: import_zod219.z.string(),
  userId: import_zod219.z.string(),
  userName: import_zod219.z.string().nullish()
});

// src/generated-definitions/PublicUsersResponse.ts
var import_zod220 = require("zod");
var PublicUsersResponse = import_zod220.z.object({ Users: import_zod220.z.array(PublicUserResponse).nullish() });

// src/generated-definitions/SearchUsersResponse.ts
var import_zod222 = require("zod");

// src/generated-definitions/UserSearchResult.ts
var import_zod221 = require("zod");
var UserSearchResult = import_zod221.z.object({
  DisplayName: import_zod221.z.string(),
  EmailAddress: import_zod221.z.string(),
  LinkedPlatforms: import_zod221.z.array(UserLinkedPlatform),
  PhoneNumber: import_zod221.z.string(),
  UserId: import_zod221.z.string()
});

// src/generated-definitions/SearchUsersResponse.ts
var SearchUsersResponse = import_zod222.z.object({ Data: import_zod222.z.array(UserSearchResult) });

// src/generated-definitions/UserCreateResponse.ts
var import_zod223 = require("zod");
var UserCreateResponse = import_zod223.z.object({
  AuthType: import_zod223.z.string(),
  Country: import_zod223.z.string(),
  DateOfBirth: import_zod223.z.string(),
  DisplayName: import_zod223.z.string(),
  LoginId: import_zod223.z.string(),
  Namespace: import_zod223.z.string(),
  UserId: import_zod223.z.string()
});

// src/generated-definitions/UserCreateResponseV3.ts
var import_zod224 = require("zod");
var UserCreateResponseV3 = import_zod224.z.object({
  authType: import_zod224.z.string(),
  country: import_zod224.z.string(),
  dateOfBirth: import_zod224.z.string(),
  displayName: import_zod224.z.string(),
  emailAddress: import_zod224.z.string(),
  namespace: import_zod224.z.string(),
  uniqueDisplayName: import_zod224.z.string().nullish(),
  userId: import_zod224.z.string()
});

// src/generated-definitions/UserInformation.ts
var import_zod226 = require("zod");

// src/generated-definitions/PlatformUserInformation.ts
var import_zod225 = require("zod");
var PlatformUserInformation = import_zod225.z.object({
  DisplayName: import_zod225.z.string(),
  EmailAddress: import_zod225.z.string().nullish(),
  LinkedAt: import_zod225.z.string(),
  Namespace: import_zod225.z.string(),
  PlatformID: import_zod225.z.string(),
  PlatformUserID: import_zod225.z.string(),
  XUID: import_zod225.z.string().nullish()
});

// src/generated-definitions/UserInformation.ts
var UserInformation = import_zod226.z.object({
  Country: import_zod226.z.string(),
  DisplayName: import_zod226.z.string(),
  EmailAddresses: import_zod226.z.array(import_zod226.z.string()),
  LinkedPlatformAccounts: import_zod226.z.array(PlatformUserInformation),
  PhoneNumber: import_zod226.z.string(),
  Username: import_zod226.z.string(),
  XUID: import_zod226.z.string().nullish()
});

// src/generated-definitions/UserInformationV3.ts
var import_zod228 = require("zod");

// src/generated-definitions/PlatformUserInformationV3.ts
var import_zod227 = require("zod");
var PlatformUserInformationV3 = import_zod227.z.object({
  displayName: import_zod227.z.string().nullish(),
  emailAddress: import_zod227.z.string().nullish(),
  linkedAt: import_zod227.z.string(),
  namespace: import_zod227.z.string(),
  platformId: import_zod227.z.string(),
  platformUserId: import_zod227.z.string(),
  xboxUserId: import_zod227.z.string().nullish()
});

// src/generated-definitions/UserInformationV3.ts
var UserInformationV3 = import_zod228.z.object({
  country: import_zod228.z.string().nullish(),
  displayName: import_zod228.z.string().nullish(),
  emailAddresses: import_zod228.z.array(import_zod228.z.string()),
  phoneNumber: import_zod228.z.string().nullish(),
  platformUsers: import_zod228.z.array(PlatformUserInformationV3),
  uniqueDisplayName: import_zod228.z.string().nullish(),
  username: import_zod228.z.string().nullish(),
  xboxUserId: import_zod228.z.string().nullish()
});

// src/generated-definitions/UserInputValidationResponse.ts
var import_zod229 = require("zod");
var UserInputValidationResponse = import_zod229.z.object({ message: import_zod229.z.string().nullish(), valid: import_zod229.z.boolean() });

// src/generated-definitions/UserLinkedPlatformArray.ts
var import_zod230 = require("zod");
var UserLinkedPlatformArray = import_zod230.z.array(UserLinkedPlatform);

// src/generated-definitions/UserProfileUpdateAllowStatus.ts
var import_zod232 = require("zod");

// src/generated-definitions/FieldUpdateAllowStatus.ts
var import_zod231 = require("zod");
var FieldUpdateAllowStatus = import_zod231.z.object({
  field: import_zod231.z.string(),
  nextAvailableEditTime: import_zod231.z.number().int().nullish(),
  remainingTimeInSeconds: import_zod231.z.number().int().nullish(),
  type: import_zod231.z.string()
});

// src/generated-definitions/UserProfileUpdateAllowStatus.ts
var UserProfileUpdateAllowStatus = import_zod232.z.object({ status: import_zod232.z.array(FieldUpdateAllowStatus) });

// src/generated-definitions/UserResponseArray.ts
var import_zod233 = require("zod");
var UserResponseArray = import_zod233.z.array(UserResponse);

// src/generated-definitions/UsersPlatformInfosResponse.ts
var import_zod235 = require("zod");

// src/generated-definitions/UserPlatformInfos.ts
var import_zod234 = require("zod");
var UserPlatformInfos = import_zod234.z.object({
  avatarUrl: import_zod234.z.string().nullish(),
  displayName: import_zod234.z.string().nullish(),
  platformInfos: import_zod234.z.array(UserPlatformInfo),
  uniqueDisplayName: import_zod234.z.string().nullish(),
  userId: import_zod234.z.string()
});

// src/generated-definitions/UsersPlatformInfosResponse.ts
var UsersPlatformInfosResponse = import_zod235.z.object({ data: import_zod235.z.array(UserPlatformInfos) });

// src/generated-definitions/WebLinkingResponse.ts
var import_zod236 = require("zod");
var WebLinkingResponse = import_zod236.z.object({ state: import_zod236.z.string(), third_party_url: import_zod236.z.string() });

// src/generated-public/endpoints/Users$.ts
var Users$ = class {
  // @ts-ignore
  // prettier-ignore
  constructor(axiosInstance, namespace, useSchemaValidation = true) {
    this.axiosInstance = axiosInstance;
    this.namespace = namespace;
    this.useSchemaValidation = useSchemaValidation;
  }
  /**
   * Get my user data __Supported 3rd platforms:__ * __PSN(ps4web, ps4, ps5)__ * account id * display name * avatar * __Xbox(live, xblweb)__ * xuid or pxuid * display name * __Steam(steam, steamopenid)__ * steam id * display name * avatar * __EpicGames(epicgames)__ * epic account id * display name action code : 10147
   */
  getUsersMe_v3(queryParams) {
    const params = { ...queryParams };
    const url = "/iam/v3/public/users/me";
    const resultPromise = this.axiosInstance.get(url, { params });
    return import_sdk61.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, UserResponseV3, "UserResponseV3");
  }
  /**
   * @deprecated
   * ## The endpoint is going to be deprecated ### Endpoint migration guide - **Substitute endpoint: _/iam/v3/public/namespaces/{namespace}/users [POST]_** - **Substitute endpoint: _/iam/v4/public/namespaces/{namespace}/users [POST]_** - **Note:** 1. v3 &amp; v4 introduce optional verification code 2. format difference（Pascal case =&gt; Camel case) Available Authentication Types: 1. **EMAILPASSWD**: an authentication type used for new user registration through email. 2. **PHONEPASSWD**: an authentication type used for new user registration through phone number. Country use ISO3166-1 alpha-2 two letter, e.g. US.
   */
  createUser(data) {
    const params = {};
    const url = "/iam/namespaces/{namespace}/users".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.post(url, data, { params });
    return import_sdk61.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, UserCreateResponse, "UserCreateResponse");
  }
  /**
   * This API is for user to get self profile update allow status. Note: If the config is not found, this API will return a config with unlimited.
   */
  getUsersMeProfileStatus_v3() {
    const params = {};
    const url = "/iam/v3/public/users/me/profileStatus";
    const resultPromise = this.axiosInstance.get(url, { params });
    return import_sdk61.Validate.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      UserProfileUpdateAllowStatus,
      "UserProfileUpdateAllowStatus"
    );
  }
  /**
   * @deprecated
   * ## The endpoint is going to be deprecated ### Endpoint migration guide - **Substitute endpoint(Public): _/iam/v3/admin/namespaces/{namespace}/roles/{roleId}/users [GET]_** - **Note:** difference in V3 response, format difference: Pascal case =&gt; Camel case This endpoint search admin users which have the roleId Notes : this endpoint only accept admin role. Admin Role is role which have admin status and members. Use endpoint [GET] /roles/{roleId}/admin to check the role status
   */
  getUsersAdmin(queryParams) {
    const params = { ...queryParams };
    const url = "/iam/namespaces/{namespace}/users/admin".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.get(url, { params });
    return import_sdk61.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, GetAdminUsersResponse, "GetAdminUsersResponse");
  }
  getUsersVerifyLinkVerify_v3(queryParams) {
    const params = { ...queryParams };
    const url = "/iam/v3/public/users/verify_link/verify";
    const resultPromise = this.axiosInstance.get(url, { params });
    return import_sdk61.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, import_zod237.z.unknown(), "z.unknown()");
  }
  /**
   * @deprecated
   * ## The endpoint is going to be deprecated ### Endpoint migration guide - **Substitute endpoint: _/iam/v3/admin/namespaces/{namespace}/users/search [GET]_** Search all users that match the query on these fields: all login IDs (email address, phone number, and platform user id), userID, display name, and on the specified namespace. If the query is not defined, then it searches all users on the specified namespace.
   */
  getUsersSearch(queryParams) {
    const params = { ...queryParams };
    const url = "/iam/namespaces/{namespace}/users/search".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.get(url, { params });
    return import_sdk61.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, SearchUsersResponse, "SearchUsersResponse");
  }
  /**
   * @deprecated
   * ## The endpoint is going to be deprecated ### Endpoint migration guide - **Substitute endpoint: _/iam/v3/admin/namespaces/{namespace}/users/{userId}/information [DELETE]_**
   */
  deleteUser_ByUserId(userId) {
    const params = {};
    const url = "/iam/namespaces/{namespace}/users/{userId}".replace("{namespace}", this.namespace).replace("{userId}", userId);
    const resultPromise = this.axiosInstance.delete(url, { params });
    return import_sdk61.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, import_zod237.z.unknown(), "z.unknown()");
  }
  /**
   * @deprecated
   * ## The endpoint is going to be deprecated ### Endpoint migration guide - **Substitute endpoint(Public): _/iam/v3/public/namespaces/{namespace}/users/{userId} [GET]_** - **Substitute endpoint(Admin): _/iam/v3/admin/namespaces/{namespace}/users/{userId} [GET]_** - **Note:** format difference in response: Pascal case =&gt; Camel case
   */
  getUser_ByUserId(userId) {
    const params = {};
    const url = "/iam/namespaces/{namespace}/users/{userId}".replace("{namespace}", this.namespace).replace("{userId}", userId);
    const resultPromise = this.axiosInstance.get(url, { params });
    return import_sdk61.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, UserResponse, "UserResponse");
  }
  /**
   * @deprecated
   * ## The endpoint is going to be deprecated ### Endpoint migration guide - **Substitute endpoint([PUT]): _/iam/v3/public/namespaces/{namespace}/users/me [PUT]_** - **Substitute endpoint([PATCH]): _/iam/v3/public/namespaces/{namespace}/users/me [PATCH]_** - **Substitute endpoint([PATCH]): _/iam/v4/public/namespaces/{namespace}/users/me [PATCH]_** - **Note:** 1. Prefer [PATCH] if client support PATCH method 2. Difference in V3/v4 request body, format difference: Pascal case =&gt; Camel case This Endpoint support update user based on given data. **Single request can update single field or multi fields.** Supported field {Country, DisplayName, LanguageTag} Country use ISO3166-1 alpha-2 two letter, e.g. US. **Several case of updating email address** - User want to update email address of which have been verified, NewEmailAddress response field will be filled with new email address - User want to update email address of which have not been verified, {LoginId, OldEmailAddress, EmailAddress} response field will be filled with new email address. - User want to update email address of which have been verified and updated before, {LoginId, OldEmailAddress, EmailAddress} response field will be filled with verified email before. NewEmailAddress response field will be filled with newest email address.
   */
  updateUser_ByUserId(userId, data) {
    const params = {};
    const url = "/iam/namespaces/{namespace}/users/{userId}".replace("{namespace}", this.namespace).replace("{userId}", userId);
    const resultPromise = this.axiosInstance.put(url, data, { params });
    return import_sdk61.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, UserResponse, "UserResponse");
  }
  /**
   * @deprecated
   * ## The endpoint is going to be deprecated ### Endpoint migration guide - **Substitute endpoint: _/iam/v3/public/namespaces/{namespace}/users [GET]_**
   */
  getUsersByLoginId(queryParams) {
    const params = { ...queryParams };
    const url = "/iam/namespaces/{namespace}/users/byLoginId".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.get(url, { params });
    return import_sdk61.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, PublicUserResponse, "PublicUserResponse");
  }
  /**
   * @deprecated
   * ## The endpoint is going to be deprecated **Endpoint migration guide** - **Substitute endpoint: _/iam/v3/public/namespaces/{namespace}/users [POST]_** - **Substitute endpoint: _/iam/v4/public/namespaces/{namespace}/users [POST]_** - **Note:** 1. v3 &amp; v4 introduce optional verification code 2. format difference（Pascal case =&gt; Camel case) Available Authentication Types: 1. *EMAILPASSWD*: an authentication type used for new user registration through email. Country use ISO3166-1 alpha-2 two letter, e.g. US.
   */
  createUser_v2(data) {
    const params = {};
    const url = "/iam/v2/public/namespaces/{namespace}/users".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.post(url, data, { params });
    return import_sdk61.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, UserCreateResponse, "UserCreateResponse");
  }
  /**
   * This endpoint search all users on the specified namespace that match the query on these fields: display name, unique display name, username or by 3rd party display name. The query length should between 3-20, otherwise will not query the database. The default limit value is 20. ## Searching by 3rd party platform **Note: searching by 3rd party platform display name will use exact query, not fuzzy query.** Step when searching by 3rd party platform display name: 1. set __by__ to __thirdPartyPlatform__ 2. set __platformId__ to the _supported platform id_ 3. set __platformBy__ to __platformDisplayName__ **Supported Platforms:** - Steam group (steamnetwork): - steam - steamopenid - PSN group (psn): - ps4web - ps4 - ps5 - XBOX group(xbox): - live - xblweb - Oculus group (oculusgroup): - oculus - oculusweb - Google group (google): - google - googleplaygames: - epicgames - facebook - twitch - discord - android - ios - apple - device - nintendo - awscognito - amazon - netflix - snapchat - _oidc platform id_ Note: - You can use either platform id or platform group as **platformId** parameter. - **Nintendo platform user id**: NSA ID need to be appended with Environment ID using colon as separator. e.g kmzwa8awaa:dd1
   */
  getUsers_v3(queryParams) {
    const params = { ...queryParams };
    const url = "/iam/v3/public/namespaces/{namespace}/users".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.get(url, { params });
    return import_sdk61.Validate.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      PublicUserInformationResponseV3,
      "PublicUserInformationResponseV3"
    );
  }
  /**
   * Available Authentication Types: 1. **EMAILPASSWD**: an authentication type used for new user registration through email. **Note**: * **uniqueDisplayName**: this is required when uniqueDisplayNameEnabled/UNIQUE_DISPLAY_NAME_ENABLED is true. * **code**: this is required when mandatoryEmailVerificationEnabled config is true. please refer to the config from /iam/v3/public/namespaces/{namespace}/config/{configKey} [GET] API. Country use ISO3166-1 alpha-2 two letter, e.g. US. Date of Birth format : YYYY-MM-DD, e.g. 2019-04-29. This endpoint support accepting agreements for the created user. Supply the accepted agreements in acceptedPolicies attribute.
   */
  createUser_v3(data) {
    const params = {};
    const url = "/iam/v3/public/namespaces/{namespace}/users".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.post(url, data, { params });
    return import_sdk61.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, UserCreateResponseV3, "UserCreateResponseV3");
  }
  /**
   * The verification link is sent to email address It will not send request if user email is already verified
   */
  createUserMeVerifyLinkRequest_v3(data) {
    const params = {};
    const url = "/iam/v3/public/users/me/verify_link/request";
    const resultPromise = this.axiosInstance.post(url, data, { params });
    return import_sdk61.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, import_zod237.z.unknown(), "z.unknown()");
  }
  /**
   * @deprecated
   * ## The endpoint is going to be deprecated ### Endpoint migration guide - **Substitute endpoint: _/iam/v3/admin/namespaces/{namespace}/users/{userId}/bans [POST]_**
   */
  createBan_ByUserId(userId, data) {
    const params = {};
    const url = "/iam/namespaces/{namespace}/users/{userId}/ban".replace("{namespace}", this.namespace).replace("{userId}", userId);
    const resultPromise = this.axiosInstance.post(url, data, { params });
    return import_sdk61.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, UserBanResponse, "UserBanResponse");
  }
  /**
   * This Endpoint support update user based on given data. **Single request can update single field or multi fields.** Supported field {country, displayName, languageTag, dateOfBirth, avatarUrl, userName} Country use ISO3166-1 alpha-2 two letter, e.g. US. Date of Birth format : YYYY-MM-DD, e.g. 2019-04-29. **Response body logic when user updating email address:** - User want to update email address of which have been verified, newEmailAddress response field will be filled with new email address. - User want to update email address of which have not been verified, { oldEmailAddress, emailAddress} response field will be filled with new email address. - User want to update email address of which have been verified and updated before, { oldEmailAddress, emailAddress} response field will be filled with verified email before. newEmailAddress response field will be filled with newest email address. action code : 10103
   */
  patchUserMe_v3(data) {
    const params = {};
    const url = "/iam/v3/public/namespaces/{namespace}/users/me".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.patch(url, data, { params });
    return import_sdk61.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, UserResponseV3, "UserResponseV3");
  }
  /**
   * This Endpoint support update user based on given data. **Single request can update single field or multi fields.** Supported field {country, displayName, languageTag, dateOfBirth, avatarUrl, userName} Country use ISO3166-1 alpha-2 two letter, e.g. US. Date of Birth format : YYYY-MM-DD, e.g. 2019-04-29. **Response body logic when user updating email address:** - User want to update email address of which have been verified, newEmailAddress response field will be filled with new email address. - User want to update email address of which have not been verified, { oldEmailAddress, emailAddress} response field will be filled with new email address. - User want to update email address of which have been verified and updated before, { oldEmailAddress, emailAddress} response field will be filled with verified email before. newEmailAddress response field will be filled with newest email address. **Important notes:** This endpoint provides support for client that doesn&#39;t have PATCH support, i.e. UE4 before v4.23 released. If the client support PATCH method, use [PATCH] /iam/v3/public/namespaces/{namespace}/users/me instead action code : 10103
   */
  updateUserMe_v3(data) {
    const params = {};
    const url = "/iam/v3/public/namespaces/{namespace}/users/me".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.put(url, data, { params });
    return import_sdk61.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, UserResponseV3, "UserResponseV3");
  }
  /**
   * Note: 1. My account should be full account 2. My account not linked to request headless account&#39;s third platform. After client resolving the conflict, it will call endpoint &lt;code&gt;/iam/v3/public/users/me/headless/linkWithProgression [POST]&lt;/code&gt;
   */
  getUsersMeHeadlessLinkConflict_v3(queryParams) {
    const params = { ...queryParams };
    const url = "/iam/v3/public/users/me/headless/link/conflict";
    const resultPromise = this.axiosInstance.get(url, { params });
    return import_sdk61.Validate.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      GetLinkHeadlessAccountConflictResponse,
      "GetLinkHeadlessAccountConflictResponse"
    );
  }
  /**
   * @deprecated
   * ## The endpoint is going to be deprecated ### Endpoint migration guide - **Substitute endpoint: _/iam/v3/admin/namespaces/{namespace}/users/{userId}/bans [GET]_**
   */
  getBans_ByUserId(userId) {
    const params = {};
    const url = "/iam/namespaces/{namespace}/users/{userId}/bans".replace("{namespace}", this.namespace).replace("{userId}", userId);
    const resultPromise = this.axiosInstance.get(url, { params });
    return import_sdk61.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, UserBanResponseArray, "UserBanResponseArray");
  }
  /**
   * @deprecated
   * ## The endpoint is going to be deprecated ### Endpoint migration guide - **Substitute endpoint: _/iam/v3/public/namespaces/{namespace}/users/reset [POST]_**
   */
  createUserResetPassword(data) {
    const params = {};
    const url = "/iam/namespaces/{namespace}/users/resetPassword".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.post(url, data, { params });
    return import_sdk61.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, import_zod237.z.unknown(), "z.unknown()");
  }
  /**
   * @deprecated
   * ## The endpoint is going to be deprecated ### Endpoint migration guide - **Substitute endpoint: _/iam/v3/admin/namespaces/{namespace}/users/{userId}/roles [PATCH]_**
   */
  updateRole_ByUserId(userId, data) {
    const params = {};
    const url = "/iam/namespaces/{namespace}/users/{userId}/roles".replace("{namespace}", this.namespace).replace("{userId}", userId);
    const resultPromise = this.axiosInstance.post(url, data, { params });
    return import_sdk61.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, import_zod237.z.unknown(), "z.unknown()");
  }
  /**
   * @deprecated
   * ## The endpoint is going to be deprecated ### Endpoint migration guide - **Substitute endpoint: _/iam/v3/public/namespaces/{namespace}/users/forgot [POST]_** **Special note for publisher-game scenario:** Game Client should provide game namespace path parameter and Publisher Client should provide publisher namespace path parameter. The password reset code will be sent to the publisher account&#39;s email address.
   */
  createUserForgotPassword(data) {
    const params = {};
    const url = "/iam/namespaces/{namespace}/users/forgotPassword".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.post(url, data, { params });
    return import_sdk61.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, import_zod237.z.unknown(), "z.unknown()");
  }
  /**
   * @deprecated
   * ## The endpoint is going to be deprecated ### Endpoint migration guide - **Substitute endpoint(query by email list): _/iam/v3/public/namespaces/{namespace}/users/bulk/basic [POST]_** - **Substitute endpoint(query by user id list): _/iam/v3/admin/namespaces/{namespace}/users/search/bulk [POST]_**
   */
  getUsersListByLoginIds(queryParams) {
    const params = { ...queryParams };
    const url = "/iam/namespaces/{namespace}/users/listByLoginIds".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.get(url, { params });
    return import_sdk61.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, PublicUsersResponse, "PublicUsersResponse");
  }
  /**
   * @deprecated
   * ## The endpoint is going to be deprecated ### Endpoint migration guide - **Substitute endpoint: _/iam/v3/admin/namespaces/{namespace}/users/{userId}/status [PATCH]_**
   */
  updateEnable_ByUserId(userId) {
    const params = {};
    const url = "/iam/namespaces/{namespace}/users/{userId}/enable".replace("{namespace}", this.namespace).replace("{userId}", userId);
    const resultPromise = this.axiosInstance.put(url, null, { params });
    return import_sdk61.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, import_zod237.z.unknown(), "z.unknown()");
  }
  /**
   * action code: 10105
   */
  createUserReset_v3(data) {
    const params = {};
    const url = "/iam/v3/public/namespaces/{namespace}/users/reset".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.post(url, data, { params });
    return import_sdk61.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, import_zod237.z.unknown(), "z.unknown()");
  }
  /**
   * @deprecated
   * ## The endpoint is going to be deprecated ### Endpoint migration guide - **Substitute endpoint: _/iam/v3/admin/namespaces/{namespace}/users/{userId}/status [PATCH]_** For **Deletion Account** purpose fill the reason with: - **DeactivateAccount** : if your deletion request comes from user - **AdminDeactivateAccount** : if your deletion request comes from admin
   */
  updateDisable_ByUserId(userId, data) {
    const params = {};
    const url = "/iam/namespaces/{namespace}/users/{userId}/disable".replace("{namespace}", this.namespace).replace("{userId}", userId);
    const resultPromise = this.axiosInstance.put(url, data, { params });
    return import_sdk61.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, import_zod237.z.unknown(), "z.unknown()");
  }
  /**
   * @deprecated
   * ## The endpoint is going to be deprecated ### Endpoint migration guide - **Substitute endpoint(Public): _/iam/v3/public/namespaces/{namespace}/platforms/{platformId}/users/{platformUserId} [GET]_** - **Substitute endpoint(Admin): _/iam/v3/admin/namespaces/{namespace}/platforms/{platformId}/users/{platformUserId} [GET]_** - **Note:** 1. difference in V3 response, format difference: Pascal case =&gt; Camel case
   */
  getUsersByPlatformUserId(queryParams) {
    const params = { ...queryParams };
    const url = "/iam/namespaces/{namespace}/users/byPlatformUserID".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.get(url, { params });
    return import_sdk61.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, PublicUserResponse, "PublicUserResponse");
  }
  /**
   * **Special note for publisher-game scenario:** Game Client should provide game namespace path parameter and Publisher Client should provide publisher namespace path parameter. The password reset code will be sent to the publisher account&#39;s email address. action code : 10104
   */
  createUserForgot_v3(data) {
    const params = {};
    const url = "/iam/v3/public/namespaces/{namespace}/users/forgot".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.post(url, data, { params });
    return import_sdk61.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, import_zod237.z.unknown(), "z.unknown()");
  }
  /**
   * @deprecated
   *  ## The endpoint is going to be deprecated ### Endpoint migration guide - **Substitute endpoint: _/iam/v3/public/namespaces/{namespace}/users/me/password [PUT]_**
   */
  updatePassword_ByUserId(userId, data) {
    const params = {};
    const url = "/iam/namespaces/{namespace}/users/{userId}/password".replace("{namespace}", this.namespace).replace("{userId}", userId);
    const resultPromise = this.axiosInstance.put(url, data, { params });
    return import_sdk61.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, import_zod237.z.unknown(), "z.unknown()");
  }
  /**
   * @deprecated
   * ## The endpoint is going to be deprecated ### Endpoint migration guide - **Substitute endpoint: _/iam/v3/public/namespaces/{namespace}/users/me/platforms/{platformId} [POST]_** Access token from original namespace is needed as authorization header. Access token from designated account needed as form parameter to verify the ownership of that account. When platformID (device platfom ID) is specified, platform login method for that specific platform ID is removed. This means to protect account from second hand device usage.
   */
  postCrosslink_ByUserId(userId, data) {
    const params = {};
    const url = "/iam/namespaces/{namespace}/users/{userId}/crosslink".replace("{namespace}", this.namespace).replace("{userId}", userId);
    const resultPromise = this.axiosInstance.post(url, import_sdk61.CodeGenUtil.getFormUrlEncodedData(data), {
      ...params,
      headers: { ...params.headers, "content-type": "application/x-www-form-urlencoded" }
    });
    return import_sdk61.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, import_zod237.z.unknown(), "z.unknown()");
  }
  /**
   * @deprecated
   * ## The endpoint is going to be deprecated ### Endpoint migration guide - **Substitute endpoint: _/iam/v3/public/namespaces/{namespace}/users/{userId}/platforms [GET]_** - **Substitute endpoint: _/iam/v3/admin/namespaces/{namespace}/users/{userId}/platforms [GET]_** ## Justice Platform Account The permission ’ADMIN:NAMESPACE:{namespace}:JUSTICE:USER:{userId}’ [READ] is required in order to read the UserID who linked with the user.
   */
  getPlatforms_ByUserId(userId) {
    const params = {};
    const url = "/iam/namespaces/{namespace}/users/{userId}/platforms".replace("{namespace}", this.namespace).replace("{userId}", userId);
    const resultPromise = this.axiosInstance.get(url, { params });
    return import_sdk61.Validate.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      UserLinkedPlatformArray,
      "UserLinkedPlatformArray"
    );
  }
  /**
   * @deprecated
   * ## The endpoint is going to be deprecated ### Endpoint migration guide - **Substitute endpoint: _/iam/v3/public/namespaces/{namespace}/users/{userId}/publisher [GET]_** **Restriction:** Path Parameter *namespace* can be provided only with game namespace
   */
  getPublisher_ByUserId(userId) {
    const params = {};
    const url = "/iam/namespaces/{namespace}/users/{userId}/publisher".replace("{namespace}", this.namespace).replace("{userId}", userId);
    const resultPromise = this.axiosInstance.get(url, { params });
    return import_sdk61.Validate.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      GetPublisherUserResponse,
      "GetPublisherUserResponse"
    );
  }
  /**
   * @deprecated
   * ## The endpoint is going to be deprecated **Endpoint migration guide** - **Substitute endpoint(Public): _/iam/v3/public/namespaces/{namespace}/users/{userId} [GET]_** - **Substitute endpoint(Admin): _/iam/v3/admin/namespaces/{namespace}/users/{userId} [GET]_** - **Note:** format difference in response: Pascal case =&gt; Camel case
   */
  getUser_ByUserId_v2(userId) {
    const params = {};
    const url = "/iam/v2/public/namespaces/{namespace}/users/{userId}".replace("{namespace}", this.namespace).replace("{userId}", userId);
    const resultPromise = this.axiosInstance.get(url, { params });
    return import_sdk61.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, UserResponse, "UserResponse");
  }
  /**
   * @deprecated
   * ## The endpoint is going to be deprecated **Endpoint migration guide** - **Substitute endpoint([PUT]): _/iam/v3/public/namespaces/{namespace}/users/me [PUT]_** - **Substitute endpoint([PATCH]): _/iam/v3/public/namespaces/{namespace}/users/me [PATCH]_** - **Substitute endpoint([PATCH]): _/iam/v4/public/namespaces/{namespace}/users/me [PATCH]_** - **Note:** 1. Prefer [PATCH] if client support PATCH method 2. Difference in V3/v4 request body, format difference: Pascal case =&gt; Camel case This Endpoint support update user based on given data. **Single request can update single field or multi fields.** Supported field {Country, DisplayName, LanguageTag}
   */
  patchUser_ByUserId_v2(userId, data) {
    const params = {};
    const url = "/iam/v2/public/namespaces/{namespace}/users/{userId}".replace("{namespace}", this.namespace).replace("{userId}", userId);
    const resultPromise = this.axiosInstance.patch(url, data, { params });
    return import_sdk61.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, UserResponseArray, "UserResponseArray");
  }
  /**
   * @deprecated
   * This endpoint retrieve user attributes. action code: 10129 **Substitute endpoint:** /v4/public/namespaces/{namespace}/users/{userId} [READ]
   */
  getUser_ByUserId_v3(userId) {
    const params = {};
    const url = "/iam/v3/public/namespaces/{namespace}/users/{userId}".replace("{namespace}", this.namespace).replace("{userId}", userId);
    const resultPromise = this.axiosInstance.get(url, { params });
    return import_sdk61.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, PublicUserResponseV3, "PublicUserResponseV3");
  }
  /**
   * Note: 1. My account should be full account 2. My account not linked to headless account&#39;s third platform.
   */
  createUserMeHeadlesLinkWithProgression_v3(data) {
    const params = {};
    const url = "/iam/v3/public/users/me/headless/linkWithProgression";
    const resultPromise = this.axiosInstance.post(url, data, { params });
    return import_sdk61.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, import_zod237.z.unknown(), "z.unknown()");
  }
  /**
   * Note: 1. the max count of user ids in the request is 100 2. if platform id is not empty, the result will only contain the corresponding platform infos 3. if platform id is empty, the result will contain all the supported platform infos __Supported 3rd platforms:__ * __PSN(ps4web, ps4, ps5)__ * account id * display name * avatar * __Xbox(live, xblweb)__ * xuid or pxuid * display name * __Steam(steam, steamopenid)__ * steam id * display name * avatar * __EpicGames(epicgames)__ * epic account id * display name
   */
  createUserPlatform_v3(data) {
    const params = {};
    const url = "/iam/v3/public/namespaces/{namespace}/users/platforms".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.post(url, data, { params });
    return import_sdk61.Validate.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      UsersPlatformInfosResponse,
      "UsersPlatformInfosResponse"
    );
  }
  /**
   * @deprecated
   * ## The endpoint is going to be deprecated ### Endpoint migration guide - **Substitute endpoint: _/iam/v3/admin/namespaces/{namespace}/users/{userId}/information [DELETE]_**
   */
  deleteInformation_ByUserId(userId) {
    const params = {};
    const url = "/iam/namespaces/{namespace}/users/{userId}/information".replace("{namespace}", this.namespace).replace("{userId}", userId);
    const resultPromise = this.axiosInstance.delete(url, { params });
    return import_sdk61.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, import_zod237.z.unknown(), "z.unknown()");
  }
  /**
   * @deprecated
   * ## The endpoint is going to be deprecated ### Endpoint migration guide - **Substitute endpoint: _/iam/v3/public/namespaces/{namespace}/users/{userId}/information [GET]_**
   */
  getInformation_ByUserId(userId) {
    const params = {};
    const url = "/iam/namespaces/{namespace}/users/{userId}/information".replace("{namespace}", this.namespace).replace("{userId}", userId);
    const resultPromise = this.axiosInstance.get(url, { params });
    return import_sdk61.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, UserInformation, "UserInformation");
  }
  /**
   * @deprecated
   * ## The endpoint is going to be deprecated ### Endpoint migration guide - **Substitute endpoint: _/iam/v3/admin/namespaces/{namespace}/users/{userId}/permissions [POST]_** This endpoint will REPLACE user&#39;s permissions with the ones defined in body Schedule contains cron string or date range (both are UTC, also in cron syntax) to indicate when a permission and action are in effect. Both schedule types accepts quartz compatible cron syntax e.g. * * * * * * *. In ranged schedule, first element will be start date, and second one will be end date If schedule is set, the scheduled action must be valid too, that is between 1 to 15, inclusive Syntax reference Fields: 1. Seconds: 0-59 * / , - 2. Minutes: 0-59 * / , - 3. Hours: 0-23 * / , - 4. Day of month: 1-31 * / , - L W 5. Month: 1-12 JAN-DEC * / , - 6. Day of week: 0-6 SUN-SAT * / , - L # 7. Year: 1970-2099 * / , - Special characters: 1. *: all values in the fields, e.g. * in seconds fields indicates every second 2. /: increments of ranges, e.g. 3-59/15 in the minute field indicate the third minute of the hour and every 15 minutes thereafter 3. ,: separate items of a list, e.g. MON,WED,FRI in day of week 4. -: range, e.g. 2010-2018 indicates every year between 2010 and 2018, inclusive 5. L: last, e.g. When used in the day-of-week field, it allows you to specify constructs such as &#34;the last Friday&#34; (5L) of a given month. In the day-of-month field, it specifies the last day of the month. 6. W: business day, e.g. if you were to specify 15W as the value for the day-of-month field, the meaning is: &#34;the nearest business day to the 15th of the month.&#34; 7. #: must be followed by a number between one and five. It allows you to specify constructs such as &#34;the second Friday&#34; of a given month.
   */
  updatePermission_ByUserId(userId, data) {
    const params = {};
    const url = "/iam/namespaces/{namespace}/users/{userId}/permissions".replace("{namespace}", this.namespace).replace("{userId}", userId);
    const resultPromise = this.axiosInstance.post(url, data, { params });
    return import_sdk61.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, import_zod237.z.unknown(), "z.unknown()");
  }
  /**
   * Notes: - This endpoint bulk get users&#39; basic info by userId, max allowed 100 at a time - If namespace is game, will search by game user Id, other wise will search by publisher namespace - **Result will include displayName(if it exists)**
   */
  createUserBulkBasic_v3(data) {
    const params = {};
    const url = "/iam/v3/public/namespaces/{namespace}/users/bulk/basic".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.post(url, data, { params });
    return import_sdk61.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, ListBulkUserResponse, "ListBulkUserResponse");
  }
  /**
   * @deprecated
   * ## The endpoint is going to be deprecated ### Endpoint migration guide - **Substitute endpoint: _/iam/v3/public/namespaces/{namespace}/users/me/code/verify [POST]_** Redeems a verification code sent to a user to verify the user&#39;s contact address is correct Available ContactType : *email* or *phone*
   */
  updateVerification_ByUserId(userId, data) {
    const params = {};
    const url = "/iam/namespaces/{namespace}/users/{userId}/verification".replace("{namespace}", this.namespace).replace("{userId}", userId);
    const resultPromise = this.axiosInstance.post(url, data, { params });
    return import_sdk61.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, import_zod237.z.unknown(), "z.unknown()");
  }
  /**
   * Verify the registration code
   */
  createUserCodeVerify_v3(data) {
    const params = {};
    const url = "/iam/v3/public/namespaces/{namespace}/users/code/verify".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.post(url, data, { params });
    return import_sdk61.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, import_zod237.z.unknown(), "z.unknown()");
  }
  /**
   * action code: 10107
   */
  updateUserMePassword_v3(data) {
    const params = {};
    const url = "/iam/v3/public/namespaces/{namespace}/users/me/password".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.put(url, data, { params });
    return import_sdk61.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, import_zod237.z.unknown(), "z.unknown()");
  }
  /**
   * Check user&#39;s account availability. Available field : - displayName - uniqueDisplayName - username If request include access token with user ID data, that user ID will be excluded from availability check. For example, in case user update his emailAddress, he can use his own emailAddress to update his account. Response Code : - Account Available : 404 (not found) - Account Not Available : 204 (no content)
   */
  getUsersAvailability_v3(queryParams) {
    const params = { ...queryParams };
    const url = "/iam/v3/public/namespaces/{namespace}/users/availability".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.get(url, { params });
    return import_sdk61.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, import_zod237.z.unknown(), "z.unknown()");
  }
  /**
   * This endpoint will validate the request&#39;s email address. If it already been used, will response 409. If it is available, we will send a verification code to this email address. This code can be verified by this [endpoint](#operations-Users-PublicVerifyRegistrationCode).
   */
  createUserCodeRequest_v3(data) {
    const params = {};
    const url = "/iam/v3/public/namespaces/{namespace}/users/code/request".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.post(url, data, { params });
    return import_sdk61.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, import_zod237.z.unknown(), "z.unknown()");
  }
  /**
   * @deprecated
   * ## The endpoint is going to be deprecated ### Endpoint migration guide - **Substitute endpoint: _/iam/v3/admin/namespaces/{namespace}/users/{userId}/roles/{roleId} [DELETE]_**
   */
  deleteRole_ByUserId_ByRoleId(userId, roleId) {
    const params = {};
    const url = "/iam/namespaces/{namespace}/users/{userId}/roles/{roleId}".replace("{namespace}", this.namespace).replace("{userId}", userId).replace("{roleId}", roleId);
    const resultPromise = this.axiosInstance.delete(url, { params });
    return import_sdk61.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, import_zod237.z.unknown(), "z.unknown()");
  }
  /**
   * @deprecated
   * ## The endpoint is going to be deprecated ### Endpoint migration guide - **Substitute endpoint: _/iam/v3/admin/namespaces/{namespace}/users/{userId}/roles/{roleId} [POST]_**
   */
  updateRole_ByUserId_ByRoleId(userId, roleId) {
    const params = {};
    const url = "/iam/namespaces/{namespace}/users/{userId}/roles/{roleId}".replace("{namespace}", this.namespace).replace("{userId}", userId).replace("{roleId}", roleId);
    const resultPromise = this.axiosInstance.post(url, null, { params });
    return import_sdk61.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, import_zod237.z.unknown(), "z.unknown()");
  }
  /**
   * @deprecated
   * ## The endpoint is going to be deprecated **Endpoint migration guide** - **Substitute endpoint: _/iam/v3/public/namespaces/{namespace}/users/{userId}/bans [GET]_**
   */
  getBans_ByUserId_v2(userId, queryParams) {
    const params = { ...queryParams };
    const url = "/iam/v2/public/namespaces/{namespace}/users/{userId}/bans".replace("{namespace}", this.namespace).replace("{userId}", userId);
    const resultPromise = this.axiosInstance.get(url, { params });
    return import_sdk61.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, UserBanResponseArray, "UserBanResponseArray");
  }
  /**
   * @deprecated
   * ## The endpoint is going to be deprecated **Endpoint migration guide** - **Substitute endpoint: _/iam/v3/public/namespaces/{namespace}/users/reset [POST]_**
   */
  createUserResetPassword_v2(data) {
    const params = {};
    const url = "/iam/v2/public/namespaces/{namespace}/users/resetPassword".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.post(url, data, { params });
    return import_sdk61.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, import_zod237.z.unknown(), "z.unknown()");
  }
  /**
   * Notes: - This endpoint retrieve the first page of the data if after and before parameters is empty - **The pagination is not working yet** **Authentication:** The _**userId**_ parameter should match the one in the access token.
   */
  getBans_ByUserId_v3(userId, queryParams) {
    const params = { ...queryParams };
    const url = "/iam/v3/public/namespaces/{namespace}/users/{userId}/bans".replace("{namespace}", this.namespace).replace("{userId}", userId);
    const resultPromise = this.axiosInstance.get(url, { params });
    return import_sdk61.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, GetUserBanV3Response, "GetUserBanV3Response");
  }
  /**
   * @deprecated
   * ## The endpoint is going to be deprecated **Endpoint migration guide** - **Substitute endpoint: _/iam/v3/public/namespaces/{namespace}/users/forgot [POST]_** **Special note for publisher-game scenario:** Game Client should provide game namespace path parameter and Publisher Client should provide publisher namespace path parameter. The password reset code will be sent to the publisher account&#39;s email address.
   */
  createUserForgotPassword_v2(data) {
    const params = {};
    const url = "/iam/v2/public/namespaces/{namespace}/users/forgotPassword".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.post(url, data, { params });
    return import_sdk61.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, import_zod237.z.unknown(), "z.unknown()");
  }
  /**
   * Will consume code if validateOnly is set false Redeems a verification code sent to a user to verify the user&#39;s contact address is correct Available ContactType : **email** action code: 10107
   */
  createUserMeCodeVerify_v3(data) {
    const params = {};
    const url = "/iam/v3/public/namespaces/{namespace}/users/me/code/verify".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.post(url, data, { params });
    return import_sdk61.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, import_zod237.z.unknown(), "z.unknown()");
  }
  /**
   * @deprecated
   * ## The endpoint is going to be deprecated ### Endpoint migration guide - **Substitute endpoint: _/iam/v3/public/namespaces/{namespace}/users/{userId}/logins/histories [GET]_** - **Substitute endpoint: _/iam/v3/admin/namespaces/{namespace}/users/{userId}/logins/histories [GET]_** Notes for this endpoint: - This endpoint retrieve the first page of the data if &#39;after&#39; and &#39;before&#39; parameters is empty. - The maximum value of the limit is 100 and the minimum value of the limit is 1. - This endpoint retrieve the next page of the data if we provide &#39;after&#39; parameters with valid Unix timestamp. - This endpoint retrieve the previous page of the data if we provide &#39;before&#39; parameter with valid data Unix timestamp.
   */
  getLoginsHistories_ByUserId(userId, queryParams) {
    const params = { ...queryParams };
    const url = "/iam/namespaces/{namespace}/users/{userId}/logins/histories".replace("{namespace}", this.namespace).replace("{userId}", userId);
    const resultPromise = this.axiosInstance.get(url, { params });
    return import_sdk61.Validate.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      LoginHistoriesResponse,
      "LoginHistoriesResponse"
    );
  }
  /**
   * @deprecated
   * ## The endpoint is going to be deprecated ### Endpoint migration guide - **Substitute endpoint: _/iam/v3/public/namespaces/{namespace}/users/me/code/request [POST]_** The verification code is sent to either the phone number or email address. It depends on the LoginID&#39;s value. Available contexts for use : 1. **UserAccountRegistration** a context type used for verifying email address in user account registration. It returns 409 if the email address already verified. **_It is the default context if the Context field is empty_** 2. **UpdateEmailAddress** a context type used for verify user before updating email address.(Without email address verified checking) 3. **upgradeHeadlessAccount** The context is intended to be used whenever the email address wanted to be automatically verified on upgrading a headless account. If this context used, IAM rejects the request if the loginId field&#39;s value is already used by others by returning HTTP Status Code 409.
   */
  updateVerificationcode_ByUserId(userId, data) {
    const params = {};
    const url = "/iam/namespaces/{namespace}/users/{userId}/verificationcode".replace("{namespace}", this.namespace).replace("{userId}", userId);
    const resultPromise = this.axiosInstance.post(url, data, { params });
    return import_sdk61.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, import_zod237.z.unknown(), "z.unknown()");
  }
  /**
   * The verification code is sent to email address Available contexts for use : 1. **UserAccountRegistration** a context type used for verifying email address in user account registration. It returns 409 if the email address already verified. **_It is the default context if the Context field is empty_** 2. **UpdateEmailAddress** a context type used for verify user before updating email address.(Without email address verified checking) 3. **upgradeHeadlessAccount** The context is intended to be used whenever the email address wanted to be automatically verified on upgrading a headless account. If this context used, IAM rejects the request if the email address is already used by others by returning HTTP Status Code 409. action code: 10116
   */
  createUserMeCodeRequest_v3(data) {
    const params = {};
    const url = "/iam/v3/public/namespaces/{namespace}/users/me/code/request".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.post(url, data, { params });
    return import_sdk61.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, import_zod237.z.unknown(), "z.unknown()");
  }
  /**
   * Validate user&#39;s input. -------- **note:** - this endpoint will check the input validation and profanity filter service(if this is enabled) - the namespace should be publisher namespace
   */
  createUserInputValidation_v3(data) {
    const params = {};
    const url = "/iam/v3/public/namespaces/{namespace}/users/input/validation".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.post(url, data, { params });
    return import_sdk61.Validate.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      UserInputValidationResponse,
      "UserInputValidationResponse"
    );
  }
  /**
   * @deprecated
   * ## The endpoint is going to be deprecated **Endpoint migration guide** - **Substitute endpoint: _/iam/v3/public/namespaces/{namespace}/users/me/password [PUT]_**
   */
  updatePassword_ByUserId_v2(userId, data) {
    const params = {};
    const url = "/iam/v2/public/namespaces/{namespace}/users/{userId}/password".replace("{namespace}", this.namespace).replace("{userId}", userId);
    const resultPromise = this.axiosInstance.put(url, data, { params });
    return import_sdk61.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, import_zod237.z.unknown(), "z.unknown()");
  }
  /**
   * This endpoint is used to validate the user password. This endpoint validate the user password by specifying the userId and password. **Authentication:** The _**userId**_ parameter should match the one in the access token.
   */
  postValidate_ByUserId_v3(userId, data) {
    const params = {};
    const url = "/iam/v3/public/namespaces/{namespace}/users/{userId}/validate".replace("{namespace}", this.namespace).replace("{userId}", userId);
    const resultPromise = this.axiosInstance.post(url, import_sdk61.CodeGenUtil.getFormUrlEncodedData(data), {
      ...params,
      headers: { ...params.headers, "content-type": "application/x-www-form-urlencoded" }
    });
    return import_sdk61.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, import_zod237.z.unknown(), "z.unknown()");
  }
  /**
   * @deprecated
   * ## The endpoint is going to be deprecated ### Endpoint migration guide - **Substitute endpoint: _/iam/v3/admin/namespaces/{namespace}/users/{userId}/bans/{banId} [PATCH]_**
   */
  updateEnable_ByUserId_ByBanId(userId, banId) {
    const params = {};
    const url = "/iam/namespaces/{namespace}/users/{userId}/bans/{banId}/enable".replace("{namespace}", this.namespace).replace("{userId}", userId).replace("{banId}", banId);
    const resultPromise = this.axiosInstance.put(url, null, { params });
    return import_sdk61.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, UserBanResponse, "UserBanResponse");
  }
  /**
   * This endpoint retrieves platform accounts linked to user. **Supported Platforms:** - Steam group (steamnetwork): - steam - steamopenid - PSN group (psn): - ps4web - ps4 - ps5 - XBOX group(xbox): - live - xblweb - Oculus group (oculusgroup): - oculus - oculusweb - Google group (google): - google - googleplaygames: - epicgames - facebook - twitch - discord - android - ios - apple - device - nintendo - awscognito - amazon - netflix - snapchat - _oidc platform id_ Note: - You can use either platform id or platform group as **platformId** parameter. - **Nintendo platform user id**: NSA ID need to be appended with Environment ID using colon as separator. e.g kmzwa8awaa:dd1 **Authentication:** The _**userId**_ parameter should match the one in the access token. action code: 10128
   */
  getPlatforms_ByUserId_v3(userId, queryParams) {
    const params = { ...queryParams };
    const url = "/iam/v3/public/namespaces/{namespace}/users/{userId}/platforms".replace("{namespace}", this.namespace).replace("{userId}", userId);
    const resultPromise = this.axiosInstance.get(url, { params });
    return import_sdk61.Validate.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      UserLinkedPlatformsResponseV3,
      "UserLinkedPlatformsResponseV3"
    );
  }
  /**
   * **Restriction:** Path Parameter **namespace** can be provided only with game namespace
   */
  getPublisher_ByUserId_v3(userId) {
    const params = {};
    const url = "/iam/v3/public/namespaces/{namespace}/users/{userId}/publisher".replace("{namespace}", this.namespace).replace("{userId}", userId);
    const resultPromise = this.axiosInstance.get(url, { params });
    return import_sdk61.Validate.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      GetPublisherUserResponse,
      "GetPublisherUserResponse"
    );
  }
  /**
   * action code : 10124 if set NeedVerificationCode = true, IAM will send verification code into email user can use that verification code to verify user through /iam/v3/public/namespaces/{namespace}/users/me/code/verify
   */
  createUserMeHeadlesVerify_v3(data, queryParams) {
    const params = { ...queryParams };
    const url = "/iam/v3/public/namespaces/{namespace}/users/me/headless/verify".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.post(url, data, { params });
    return import_sdk61.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, UserResponseV3, "UserResponseV3");
  }
  /**
   * @deprecated
   * ## The endpoint is going to be deprecated ### Endpoint migration guide - **Substitute endpoint: _/iam/v3/admin/namespaces/{namespace}/users/{userId}/bans/{banId} [PATCH]_** **Notes for using IAM in publisher - game studio scenarios** The endpoint allows: - The admin user in publisher namespace disables user’s ban in publisher namespace. - The admin user in game namespace disables user’s ban in game namespace. - The admin user in publisher namespace disables user’s ban in publisher namespace. Other scenarios are not supported and will return 403: Forbidden.
   */
  updateDisable_ByUserId_ByBanId(userId, banId) {
    const params = {};
    const url = "/iam/namespaces/{namespace}/users/{userId}/bans/{banId}/disable".replace("{namespace}", this.namespace).replace("{userId}", userId).replace("{banId}", banId);
    const resultPromise = this.axiosInstance.put(url, null, { params });
    return import_sdk61.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, UserBanResponse, "UserBanResponse");
  }
  /**
   * This endpoint retrieves user info and linked platform accounts. **Authentication:** The _**userId**_ parameter should match the one in the access token.
   */
  getInformation_ByUserId_v3(userId) {
    const params = {};
    const url = "/iam/v3/public/namespaces/{namespace}/users/{userId}/information".replace("{namespace}", this.namespace).replace("{userId}", userId);
    const resultPromise = this.axiosInstance.get(url, { params });
    return import_sdk61.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, UserInformationV3, "UserInformationV3");
  }
  /**
   * @deprecated
   * ## The endpoint is going to be deprecated ### Endpoint migration guide - **Substitute endpoint: _/iam/v3/public/namespaces/{namespace}/users/me/headless/verify [POST]_**
   */
  updateUpgradeHeadlessAccount_ByUserId(userId, data) {
    const params = {};
    const url = "/iam/namespaces/{namespace}/users/{userId}/upgradeHeadlessAccount".replace("{namespace}", this.namespace).replace("{userId}", userId);
    const resultPromise = this.axiosInstance.post(url, data, { params });
    return import_sdk61.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, UserResponse, "UserResponse");
  }
  /**
   * Endpoint to validate user invitation. When not found, it could also means the invitation has expired.
   */
  getUserInvite_ByInvitationId_v3(invitationId) {
    const params = {};
    const url = "/iam/v3/public/namespaces/{namespace}/users/invite/{invitationId}".replace("{namespace}", this.namespace).replace("{invitationId}", invitationId);
    const resultPromise = this.axiosInstance.get(url, { params });
    return import_sdk61.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, UserInvitationV3, "UserInvitationV3");
  }
  /**
   * This endpoint create user from saved roles when creating invitation and submitted data. User will be able to login after completing submitting the data through this endpoint. Available Authentication Types: EMAILPASSWD: an authentication type used for new user registration through email. **Note**: * **uniqueDisplayName**: this is required when uniqueDisplayNameEnabled/UNIQUE_DISPLAY_NAME_ENABLED is true. Country use ISO3166-1 alpha-2 two letter, e.g. US. Date of Birth format : YYYY-MM-DD, e.g. 2019-04-29.
   */
  createUserInvite_ByInvitationId_v3(invitationId, data) {
    const params = {};
    const url = "/iam/v3/public/namespaces/{namespace}/users/invite/{invitationId}".replace("{namespace}", this.namespace).replace("{invitationId}", invitationId);
    const resultPromise = this.axiosInstance.post(url, data, { params });
    return import_sdk61.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, UserCreateResponseV3, "UserCreateResponseV3");
  }
  /**
   * @deprecated
   * List User ID By Platform User ID This endpoint intended to list game user ID from the given namespace This endpoint return list of user ID by given platform ID and list of platform user ID Supported platform: - steam - steamopenid - ps4web - ps4 - ps5 - live - xblweb - oculus - oculusweb - facebook - google - googleplaygames - twitch - discord - apple - device - justice - epicgames - nintendo - awscognito - netflix - snapchat - oidc platform id Note: **nintendo platform user ID**: NSA ID need to be appended with Environment ID using colon as separator. e.g kmzwa8awaa:dd1
   */
  createUser_ByPlatformId_v3(platformId, data, queryParams) {
    const params = { ...queryParams };
    const url = "/iam/v3/public/namespaces/{namespace}/platforms/{platformId}/users".replace("{namespace}", this.namespace).replace("{platformId}", platformId);
    const resultPromise = this.axiosInstance.post(url, data, { params });
    return import_sdk61.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, UserPlatforms, "UserPlatforms");
  }
  /**
   * It is going to be **DEPRECATED**. Update Platform Account relation to current User Account. Note: Game progression data (statistics, reward, etc) associated with previous User Account will not be transferred. If the data is tight to game user ID, the user will have the game progression data. **Authentication:** The _**userId**_ parameter should match the one in the access token.
   */
  createPlatformLink_ByUserId_v3(userId, data) {
    const params = {};
    const url = "/iam/v3/public/namespaces/{namespace}/users/{userId}/platforms/link".replace("{namespace}", this.namespace).replace("{userId}", userId);
    const resultPromise = this.axiosInstance.post(url, data, { params });
    return import_sdk61.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, import_zod237.z.unknown(), "z.unknown()");
  }
  /**
   * If validateOnly is set false, consume code and upgrade headless account and automatically verified the email address if it is succeeded The endpoint upgrades a headless account by linking the headless account with the email address and the password. By upgrading the headless account into a full account, the user could use the email address and password for using Justice IAM. The endpoint is a shortcut for upgrading a headless account and verifying the email address in one call. In order to get a verification code for the endpoint, please check the send verification code endpoint. This endpoint also have an ability to update user data (if the user data field is specified) right after the upgrade account process is done. Supported user data fields : - displayName - dateOfBirth : format YYYY-MM-DD, e.g. 2019-04-29 - country : format ISO3166-1 alpha-2 two letter, e.g. US action code : 10124
   */
  createUserMeHeadlesCodeVerify_v3(data) {
    const params = {};
    const url = "/iam/v3/public/namespaces/{namespace}/users/me/headless/code/verify".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.post(url, data, { params });
    return import_sdk61.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, UserResponseV3, "UserResponseV3");
  }
  /**
   * Notes for this endpoint: - This endpoint retrieve the first page of the data if &lt;code&gt;after&lt;/code&gt; and &lt;code&gt;before&lt;/code&gt; parameters is empty. - The maximum value of the limit is 100 and the minimum value of the limit is 1. - This endpoint retrieve the next page of the data if we provide &lt;code&gt;after&lt;/code&gt; parameters with valid Unix timestamp. - This endpoint retrieve the previous page of the data if we provide &lt;code&gt;before&lt;/code&gt; parameter with valid data Unix timestamp. **Authentication:** The _**userId**_ parameter should match the one in the access token.
   */
  getLoginsHistories_ByUserId_v3(userId, queryParams) {
    const params = { ...queryParams };
    const url = "/iam/v3/public/namespaces/{namespace}/users/{userId}/logins/histories".replace("{namespace}", this.namespace).replace("{userId}", userId);
    const resultPromise = this.axiosInstance.get(url, { params });
    return import_sdk61.Validate.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      LoginHistoriesResponse,
      "LoginHistoriesResponse"
    );
  }
  /**
   * @deprecated
   * ## Supported platforms: - **steam** - **steamopenid** - **facebook** - **google** - **googleplaygames** - **oculus** - **twitch** - **android** - **ios** - **apple** - **device** - **discord** - **awscognito** - **epicgames** - **nintendo** Unlink user&#39;s account from a specific platform. &#39;justice&#39; platform might have multiple accounts from different namespaces linked. _platformNamespace_ need to be specified when the platform ID is &#39;justice&#39;. Unlink user&#39;s account from justice platform will enable password token grant and password update. If you want to unlink user&#39;s account in a game namespace, you have to specify _platformNamespace_ to that game namespace. action code : 10121
   */
  deleteUserMePlatform_ByPlatformId_v3(platformId, data) {
    const params = {};
    const url = "/iam/v3/public/namespaces/{namespace}/users/me/platforms/{platformId}".replace("{namespace}", this.namespace).replace("{platformId}", platformId);
    const resultPromise = this.axiosInstance.delete(url, { data, params });
    return import_sdk61.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, import_zod237.z.unknown(), "z.unknown()");
  }
  /**
   * **Prerequisite:** Platform client configuration need to be added to database for specific platformId. Namespace service URL need to be specified (refer to required environment variables). ## Supported platforms: - **steam**: The ticket’s value is the binary ticket returned by Steam. - **steamopenid**: Steam&#39;s user authentication method using OpenID 2.0. The ticket&#39;s value is URL generated by Steam on web authentication - **facebook**: The ticket’s value is the authorization code returned by Facebook OAuth - **google**: The ticket’s value is the authorization code returned by Google OAuth - **googleplaygames**: The ticket’s value is the authorization code returned by Google play games OAuth - **oculus**: The ticket’s value is a string composed of Oculus&#39;s user ID and the nonce separated by a colon (:). - **twitch**: The ticket’s value is the authorization code returned by Twitch OAuth. - **android**: The ticket&#39;s value is the Android’s device ID - **ios**: The ticket&#39;s value is the iOS’s device ID. - **apple**: The ticket’s value is the authorization code returned by Apple OAuth. - **device**: Every device that doesn&#39;t run Android and iOS is categorized as a device platform. The ticket&#39;s value is the device’s ID. - **discord**: The ticket’s value is the authorization code returned by Discord OAuth. - **ps4web**: The ticket’s value is the authorization code returned by PSN OAuth. - **ps4**: The ticket’s value is the authorization code returned by PSN OAuth. - **ps5**: The ticket’s value is the authorization code returned by PSN OAuth. - **xblweb**: The ticket’s value is the authorization code returned by XBox Live OAuth. - **live**: The ticket’s value is the XSTS token. - **awscognito**: The ticket’s value is the aws cognito access token (JWT). - **epicgames**: The ticket’s value is an access-token or authorization code obtained from Epicgames EOS Account Service. - **nintendo**: The ticket’s value is the id_token returned by Nintendo OAuth. - **netflix**: The ticket’s value is GAT (Gamer Access Token) returned by Netflix backend. - **snapchat**: The ticket’s value is authorization code returned by Snapchat OAuth. - **for specific generic oauth (OIDC)**: The platform_token’s value should be the same type as created OIDC auth type whether it is auth code, idToken or bearerToken. action code : 10144
   */
  postUserMePlatform_ByPlatformId_v3(platformId, data) {
    const params = {};
    const url = "/iam/v3/public/namespaces/{namespace}/users/me/platforms/{platformId}".replace("{namespace}", this.namespace).replace("{platformId}", platformId);
    const resultPromise = this.axiosInstance.post(url, import_sdk61.CodeGenUtil.getFormUrlEncodedData(data), {
      ...params,
      headers: { ...params.headers, "content-type": "application/x-www-form-urlencoded" }
    });
    return import_sdk61.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, import_zod237.z.unknown(), "z.unknown()");
  }
  /**
   * @deprecated
   * ## The endpoint is going to be deprecated ### Endpoint migration guide - **Substitute endpoint: _/iam/v3/public/namespaces/{namespace}/users/me/platforms/{platformId} [POST]_** **Prerequisite:** Platform client configuration need to be added to database for specific platformId. Namespace service URL need to be specified (refer to required environment variables). ## Supported platforms: - **steam**: The ticket’s value is the authentication code returned by Steam. - **steamopenid**: Steam&#39;s user authentication method using OpenID 2.0. The ticket&#39;s value is URL generated by Steam on web authentication - **facebook**: The ticket’s value is the authorization code returned by Facebook OAuth - **google**: The ticket’s value is the authorization code returned by Google OAuth - **oculus**: The ticket’s value is a string composed of Oculus&#39;s user ID and the nonce separated by a colon (:). - **twitch**: The ticket’s value is the authorization code returned by Twitch OAuth. - **android**: The ticket&#39;s value is the Android’s device ID - **ios**: The ticket&#39;s value is the iOS’s device ID. - **apple**: The ticket’s value is the authorization code returned by Apple OAuth. - **device**: Every device that does’nt run Android and iOS is categorized as a device platform. The ticket&#39;s value is the device’s ID. - **discord**: The ticket’s value is the authorization code returned by Discord OAuth.
   */
  postLink_ByUserId_ByPlatformId(userId, platformId, data) {
    const params = {};
    const url = "/iam/namespaces/{namespace}/users/{userId}/platforms/{platformId}/link".replace("{namespace}", this.namespace).replace("{userId}", userId).replace("{platformId}", platformId);
    const resultPromise = this.axiosInstance.post(url, import_sdk61.CodeGenUtil.getFormUrlEncodedData(data), {
      ...params,
      headers: { ...params.headers, "content-type": "application/x-www-form-urlencoded" }
    });
    return import_sdk61.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, import_zod237.z.unknown(), "z.unknown()");
  }
  /**
   * @deprecated
   * ## The endpoint is going to be deprecated **Endpoint migration guide** - **Substitute endpoint: _/iam/v3/public/namespaces/{namespace}/users/{userId}/platforms/justice [GET]_** This endpoint gets list justice platform account by providing publisher namespace and publisher userID.
   */
  getPlatformsJustice_ByUserId_v2(userId) {
    const params = {};
    const url = "/iam/v2/public/namespaces/{namespace}/users/{userId}/platforms/justice".replace("{namespace}", this.namespace).replace("{userId}", userId);
    const resultPromise = this.axiosInstance.get(url, { params });
    return import_sdk61.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, GetUserMappingArray, "GetUserMappingArray");
  }
  /**
   * This endpoint retrieves platform accounts linked to user. It will query all linked platform accounts. The results will be distinct and grouped by platform, and for each platform, we will select the oldest linked one. **Authentication:** The _**userId**_ parameter should match the one in the access token.
   */
  getDistinctPlatforms_ByUserId_v3(userId) {
    const params = {};
    const url = "/iam/v3/public/namespaces/{namespace}/users/{userId}/distinctPlatforms".replace("{namespace}", this.namespace).replace("{userId}", userId);
    const resultPromise = this.axiosInstance.get(url, { params });
    return import_sdk61.Validate.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      DistinctPlatformResponseV3,
      "DistinctPlatformResponseV3"
    );
  }
  /**
   * This endpoint gets list justice platform account by providing publisher namespace and publisher userID. **Authentication:** The _**userId**_ parameter should match the one in the access token.
   */
  getPlatformsJustice_ByUserId_v3(userId) {
    const params = {};
    const url = "/iam/v3/public/namespaces/{namespace}/users/{userId}/platforms/justice".replace("{namespace}", this.namespace).replace("{userId}", userId);
    const resultPromise = this.axiosInstance.get(url, { params });
    return import_sdk61.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, GetUserMappingV3Array, "GetUserMappingV3Array");
  }
  /**
   * This endpoint is used to get linking status. This API need logged user and user can only request its own linking status.
   */
  getAsyncStatus_ByRequestId_v3(requestId) {
    const params = {};
    const url = "/iam/v3/public/namespaces/{namespace}/requests/{requestId}/async/status".replace("{namespace}", this.namespace).replace("{requestId}", requestId);
    const resultPromise = this.axiosInstance.get(url, { params });
    return import_sdk61.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, LinkRequest, "LinkRequest");
  }
  /**
   * @deprecated
   * ## The endpoint is going to be deprecated ### Endpoint migration guide - **Substitute endpoint: _/iam/v3/public/namespaces/{namespace}/users/me/platforms/{platformId} [DELETE]_** - **Substitute endpoint: _/iam/v3/public/namespaces/{namespace}/users/me/platforms/{platformId}/all [DELETE]_** ## Supported platforms: - **steam** - **steamopenid** - **facebook** - **google** - **oculus** - **twitch** - **android** - **ios** - **device** - **justice**: A user might have several &#39;justice’ platform on different namespaces. That’s why the platform_namespace need to be specified when the platform ID is ‘justice’. The platform_namespace is the designated user’s namespace. Unlink user&#39;s account with platform. &#39;justice&#39; platform might have multiple accounts from different namespaces linked. platform_namespace need to be specified when the platform ID is &#39;justice&#39;. Unlinking justice platform will enable password token grant and password update.
   */
  postUnlink_ByUserId_ByPlatformId(userId, platformId, data) {
    const params = {};
    const url = "/iam/namespaces/{namespace}/users/{userId}/platforms/{platformId}/unlink".replace("{namespace}", this.namespace).replace("{userId}", userId).replace("{platformId}", platformId);
    const resultPromise = this.axiosInstance.post(url, import_sdk61.CodeGenUtil.getFormUrlEncodedData(data), {
      ...params,
      headers: { ...params.headers, "content-type": "application/x-www-form-urlencoded" }
    });
    return import_sdk61.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, import_zod237.z.unknown(), "z.unknown()");
  }
  /**
   * Unlink user&#39;s account from third platform in all namespaces. Several platforms are grouped under account groups, you can use either platform ID or platform group as platformId path parameter. example: to unlink steam third party account, you can use steamnetwork / steam / steamopenid as platformId path parameter. **Supported Platforms:** - Steam group (steamnetwork): - steam - steamopenid - PSN group (psn): - ps4web - ps4 - ps5 - XBOX group(xbox): - live - xblweb - Oculus group (oculusgroup): - oculus - oculusweb - Google group (google): - google - googleplaygames: - epicgames - facebook - twitch - discord - android - ios - apple - device - nintendo - awscognito - amazon - netflix - snapchat - _oidc platform id_ Note: - You can use either platform id or platform group as **platformId** parameter. - **Nintendo platform user id**: NSA ID need to be appended with Environment ID using colon as separator. e.g kmzwa8awaa:dd1 Unlink platform account associated with a group: If user unlink platform account associated with a group, the API logic will unlink all of platform account under that group as well. example: if user unlink from ps4, the API logic will unlink ps5 and ps4web as well
   */
  deleteAllMeUser_ByPlatformId_v3(platformId) {
    const params = {};
    const url = "/iam/v3/public/namespaces/{namespace}/users/me/platforms/{platformId}/all".replace("{namespace}", this.namespace).replace("{platformId}", platformId);
    const resultPromise = this.axiosInstance.delete(url, { params });
    return import_sdk61.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, import_zod237.z.unknown(), "z.unknown()");
  }
  /**
   * @deprecated
   * ## The endpoint is going to be deprecated ### Endpoint migration guide - **Substitute endpoint: _/iam/v3/admin/namespaces/{namespace}/users/{userId}/permissions/{resource}/{action} [DELETE]_**
   */
  deletePermission_ByUserId_ByResource_ByAction(userId, resource, action) {
    const params = {};
    const url = "/iam/namespaces/{namespace}/users/{userId}/permissions/{resource}/{action}".replace("{namespace}", this.namespace).replace("{userId}", userId).replace("{resource}", resource).replace("{action}", String(action));
    const resultPromise = this.axiosInstance.delete(url, { params });
    return import_sdk61.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, import_zod237.z.unknown(), "z.unknown()");
  }
  /**
   * @deprecated
   * ## The endpoint is going to be deprecated ### Endpoint migration guide - **Substitute endpoint: _/iam/v3/admin/namespaces/{namespace}/users/{userId}/permissions [POST]_** This endpoint will update existing permission (bitwise OR the action) if found one with same resource, otherwise it will append a new permission Schedule contains cron string or date range (both are UTC, also in cron syntax) to indicate when a permission and action are in effect. Both schedule types accepts quartz compatible cron syntax e.g. * * * * * * *. In ranged schedule, first element will be start date, and second one will be end date If schedule is set, the scheduled action must be valid too, that is between 1 to 15, inclusive Syntax reference Fields: 1. Seconds: 0-59 * / , - 2. Minutes: 0-59 * / , - 3. Hours: 0-23 * / , - 4. Day of month: 1-31 * / , - L W 5. Month: 1-12 JAN-DEC * / , - 6. Day of week: 0-6 SUN-SAT * / , - L # 7. Year: 1970-2099 * / , - Special characters: 1. *: all values in the fields, e.g. * in seconds fields indicates every second 2. /: increments of ranges, e.g. 3-59/15 in the minute field indicate the third minute of the hour and every 15 minutes thereafter 3. ,: separate items of a list, e.g. MON,WED,FRI in day of week 4. -: range, e.g. 2010-2018 indicates every year between 2010 and 2018, inclusive 5. L: last, e.g. When used in the day-of-week field, it allows you to specify constructs such as &#34;the last Friday&#34; (5L) of a given month. In the day-of-month field, it specifies the last day of the month. 6. W: business day, e.g. if you were to specify 15W as the value for the day-of-month field, the meaning is: &#34;the nearest business day to the 15th of the month.&#34; 7. #: must be followed by a number between one and five. It allows you to specify constructs such as &#34;the second Friday&#34; of a given month.
   */
  updatePermission_ByUserId_ByResource_ByAction(userId, resource, action, data) {
    const params = {};
    const url = "/iam/namespaces/{namespace}/users/{userId}/permissions/{resource}/{action}".replace("{namespace}", this.namespace).replace("{userId}", userId).replace("{resource}", resource).replace("{action}", String(action));
    const resultPromise = this.axiosInstance.post(url, data, { params });
    return import_sdk61.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, import_zod237.z.unknown(), "z.unknown()");
  }
  /**
   * Force linking user account with platform. If this platform account was already linked to another user account, this endpoint will perform force linking and remove platform from that conflict user, not only from the current request namespace but also include all the enrolled namespaces. If current user have linked to this platform with another platform account (include once linked but it is unlinked now), it will not allow user to perform linking. ## Supported platforms: - **steam**: The platform_token’s value is the binary ticket returned by Steam. - **steamopenid**: Steam&#39;s user authentication method using OpenID 2.0. The platform_token&#39;s value is URL generated by Steam on web authentication - **facebook**: The platform_token’s value is the authorization code returned by Facebook OAuth - **google**: The platform_token’s value is the authorization code returned by Google OAuth - **googleplaygames**: The platform_token’s value is the authorization code returned by Google play games OAuth - **oculus**: The platform_token’s value is a string composed of Oculus&#39;s user ID and the nonce separated by a colon (:). - **twitch**: The platform_token’s value is the authorization code returned by Twitch OAuth. - **discord**: The platform_token’s value is the authorization code returned by Discord OAuth - **android**: The device_id is the Android’s device ID - **ios**: The device_id is the iOS’s device ID. - **apple**: The platform_token’s value is the authorization code returned by Apple OAuth.(We will use this code to generate APP token) - **device**: Every device that does’nt run Android and iOS is categorized as a device. The device_id is the device’s ID. - **justice**: The platform_token’s value is the designated user’s access token. - **epicgames**: The platform_token’s value is an access-token obtained from Epicgames EOS Account Service. - **ps4**: The platform_token’s value is the authorization code returned by Sony OAuth. - **ps5**: The platform_token’s value is the authorization code returned by Sony OAuth. - **nintendo**: The platform_token’s value is the id_token returned by Nintendo OAuth. - **awscognito**: The platform_token’s value is the aws cognito access token or id token (JWT). - **live**: The platform_token’s value is xbox XSTS token - **xblweb**: The platform_token’s value is code returned by xbox after login - **netflix**: The platform_token’s value is GAT (Gamer Access Token) returned by Netflix backend - **snapchat**: The platform_token’s value is the authorization code returned by Snapchat OAuth. - **for specific generic oauth (OIDC)**: The platform_token’s value should be the same type as created OIDC auth type whether it is auth code, idToken or bearerToken.
   */
  postForceMeUser_ByPlatformId_v3(platformId, data) {
    const params = {};
    const url = "/iam/v3/public/namespaces/{namespace}/users/me/platforms/{platformId}/force".replace("{namespace}", this.namespace).replace("{platformId}", platformId);
    const resultPromise = this.axiosInstance.post(url, import_sdk61.CodeGenUtil.getFormUrlEncodedData(data), {
      ...params,
      headers: { ...params.headers, "content-type": "application/x-www-form-urlencoded" }
    });
    return import_sdk61.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, import_zod237.z.unknown(), "z.unknown()");
  }
  /**
   * @deprecated
   * ## The endpoint is going to be deprecated **Endpoint migration guide** - **Substitute endpoint: _/iam/v3/public/namespaces/{namespace}/agerestrictions/countries/{countryCode} [GET]_**
   */
  getAgerestrictions_ByCountryCode_v2(countryCode) {
    const params = {};
    const url = "/iam/v2/public/namespaces/{namespace}/countries/{countryCode}/agerestrictions".replace("{namespace}", this.namespace).replace("{countryCode}", countryCode);
    const resultPromise = this.axiosInstance.get(url, { params });
    return import_sdk61.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, Country, "Country");
  }
  /**
   * Get age restriction by country code. It will always get by publisher namespace
   */
  getAgerestrictionCountry_ByCountryCode_v3(countryCode) {
    const params = {};
    const url = "/iam/v3/public/namespaces/{namespace}/agerestrictions/countries/{countryCode}".replace("{namespace}", this.namespace).replace("{countryCode}", countryCode);
    const resultPromise = this.axiosInstance.get(url, { params });
    return import_sdk61.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, CountryV3Response, "CountryV3Response");
  }
  /**
   * @deprecated
   * ## The endpoint is going to be deprecated ### Endpoint migration guide - **Substitute endpoint: _/iam/v3/admin/namespaces/{namespace}/users/{userId}/platforms/justice/{targetNamespace} [GET]_** This endpoint requires the client access token as the bearer token This endpoint will support publisher access to game and game access to publisher If targetNamespace filled with publisher namespace then this endpoint will return its publisher user id and publisher namespace. If targetNamespace filled with game namespace then this endpoint will return its game user id and game namespace. **Will create game user id if not exists.**
   */
  getPlatformJustice_ByUserId_ByTargetNamespace(userId, targetNamespace) {
    const params = {};
    const url = "/iam/namespaces/{namespace}/users/{userId}/platforms/justice/{targetNamespace}".replace("{namespace}", this.namespace).replace("{userId}", userId).replace("{targetNamespace}", targetNamespace);
    const resultPromise = this.axiosInstance.get(url, { params });
    return import_sdk61.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, GetUserMapping, "GetUserMapping");
  }
  /**
   * @deprecated
   * ## The endpoint is going to be deprecated ### Endpoint migration guide - **Substitute endpoint: _/iam/v3/admin/namespaces/{namespace}/users/{userId}/platforms/justice/{targetNamespace} [GET]_** This endpoint requires the client access token as the bearer token The endpoint returns user Justice platform account linked with the given user. If the user Justice platform account doesn&#39;t exist in the designated namespace, the endpoint is going to *create and return the new Justice platform account.* The newly user Justice platform account is going to be forced to perform token grant through the given user and can&#39;t perform password update ### Read Justice Platform Account UserID Without permission the UserID is going to be censored and replaced with “Redacted” text.
   */
  updatePlatformJustice_ByUserId_ByTargetNamespace(userId, targetNamespace) {
    const params = {};
    const url = "/iam/namespaces/{namespace}/users/{userId}/platforms/justice/{targetNamespace}".replace("{namespace}", this.namespace).replace("{userId}", userId).replace("{targetNamespace}", targetNamespace);
    const resultPromise = this.axiosInstance.post(url, null, { params });
    return import_sdk61.Validate.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      GetUserJusticePlatformAccountResponse,
      "GetUserJusticePlatformAccountResponse"
    );
  }
  /**
   * This endpoint is used to generate third party login page which will redirected to establish endpoint. Supported platforms: - ps4web - xblweb - steamopenid - epicgames - facebook - twitch - google - apple - snapchat - discord - amazon - oculusweb
   */
  getWebLinkMeUsers_ByPlatformId_v3(platformId, queryParams) {
    const params = { ...queryParams };
    const url = "/iam/v3/public/namespaces/{namespace}/users/me/platforms/{platformId}/web/link".replace("{namespace}", this.namespace).replace("{platformId}", platformId);
    const resultPromise = this.axiosInstance.get(url, { params });
    return import_sdk61.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, WebLinkingResponse, "WebLinkingResponse");
  }
  /**
   * @deprecated
   * ## The endpoint is going to be deprecated **Endpoint migration guide** - **Substitute endpoint: _/iam/v3/public/namespaces/{namespace}/users/me/platforms/{platformId} [DELETE]_** - **Substitute endpoint: _/iam/v3/public/namespaces/{namespace}/users/me/platforms/{platformId}/all [DELETE]_** ## Supported platforms: - **steam** - **steamopenid** - **facebook** - **google** - **oculus** - **twitch** - **android** - **ios** - **device** - **discord** Delete link of user&#39;s account with platform. &#39;justice&#39; platform might have multiple accounts from different namespaces linked. platform_namespace need to be specified when the platform ID is &#39;justice&#39;. Delete link of justice platform will enable password token grant and password update.
   */
  deleteLink_ByUserId_ByPlatformId_v2(userId, platformId, data) {
    const params = {};
    const url = "/iam/v2/public/namespaces/{namespace}/users/{userId}/platforms/{platformId}/link".replace("{namespace}", this.namespace).replace("{userId}", userId).replace("{platformId}", platformId);
    const resultPromise = this.axiosInstance.delete(url, { data, params });
    return import_sdk61.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, import_zod237.z.unknown(), "z.unknown()");
  }
  /**
   * @deprecated
   * ## The endpoint is going to be deprecated **Endpoint migration guide** - **Substitute endpoint: _/iam/v3/public/namespaces/{namespace}/users/me/platforms/{platformId} [POST]_** **Prerequisite:** Platform client configuration need to be added to database for specific platformId. Namespace service URL need to be specified (refer to required environment variables). ## Supported platforms: - **steam**: The ticket’s value is the authentication code returned by Steam. - **steamopenid**: Steam&#39;s user authentication method using OpenID 2.0. The ticket&#39;s value is URL generated by Steam on web authentication - **facebook**: The ticket’s value is the authorization code returned by Facebook OAuth - **google**: The ticket’s value is the authorization code returned by Google OAuth - **oculus**: The ticket’s value is a string composed of Oculus&#39;s user ID and the nonce separated by a colon (:). - **twitch**: The ticket’s value is the authorization code returned by Twitch OAuth. - **android**: The ticket&#39;s value is the Android’s device ID - **ios**: The ticket&#39;s value is the iOS’s device ID. - **device**: Every device that doesn&#39;t run Android and iOS is categorized as a device platform. The ticket&#39;s value is the device’s ID. - **discord**: The ticket’s value is the authorization code returned by Discord OAuth.
   */
  postLink_ByUserId_ByPlatformId_v2(userId, platformId, data) {
    const params = {};
    const url = "/iam/v2/public/namespaces/{namespace}/users/{userId}/platforms/{platformId}/link".replace("{namespace}", this.namespace).replace("{userId}", userId).replace("{platformId}", platformId);
    const resultPromise = this.axiosInstance.post(url, import_sdk61.CodeGenUtil.getFormUrlEncodedData(data), {
      ...params,
      headers: { ...params.headers, "content-type": "application/x-www-form-urlencoded" }
    });
    return import_sdk61.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, import_zod237.z.unknown(), "z.unknown()");
  }
  /**
   * Force update other account&#39;s Platform Account relation to current User Account. This endpoint can transfer progression from 3rd platform binding account&#39;s to current account. This endpoint need the same requestID which also used in [Get link status](#operations-Users-PublicGetAsyncStatus). **Authentication:** The _**userId**_ parameter should match the one in the access token.
   */
  createPlatformLinkWithProgression_ByUserId_v3(userId, data) {
    const params = {};
    const url = "/iam/v3/public/namespaces/{namespace}/users/{userId}/platforms/linkWithProgression".replace("{namespace}", this.namespace).replace("{userId}", userId);
    const resultPromise = this.axiosInstance.post(url, data, { params });
    return import_sdk61.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, import_zod237.z.unknown(), "z.unknown()");
  }
  /**
   * Create Justice User from Publisher User information. It will check first if Justice User on target namespace already exist.
   */
  createUserMePlatformJustice_ByTargetNamespace_v3(targetNamespace) {
    const params = {};
    const url = "/iam/v3/public/namespaces/{namespace}/users/me/platforms/justice/{targetNamespace}".replace("{namespace}", this.namespace).replace("{targetNamespace}", targetNamespace);
    const resultPromise = this.axiosInstance.post(url, null, { params });
    return import_sdk61.Validate.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      CreateJusticeUserResponse,
      "CreateJusticeUserResponse"
    );
  }
  /**
   * Get User By Platform User ID. This endpoint return user information by given platform ID and platform user ID. Several platforms are grouped under account groups, you can use either platform ID or platform group as platformId path parameter. example: for steam network platform, you can use steamnetwork / steam / steamopenid as platformId path parameter. **Supported Platforms:** - Steam group (steamnetwork): - steam - steamopenid - PSN group (psn): - ps4web - ps4 - ps5 - XBOX group(xbox): - live - xblweb - Oculus group (oculusgroup): - oculus - oculusweb - Google group (google): - google - googleplaygames: - epicgames - facebook - twitch - discord - android - ios - apple - device - nintendo - awscognito - amazon - netflix - snapchat - _oidc platform id_ Note: - You can use either platform id or platform group as **platformId** parameter. - **Nintendo platform user id**: NSA ID need to be appended with Environment ID using colon as separator. e.g kmzwa8awaa:dd1
   */
  getUser_ByPlatformId_ByPlatformUserId_v3(platformId, platformUserId) {
    const params = {};
    const url = "/iam/v3/public/namespaces/{namespace}/platforms/{platformId}/users/{platformUserId}".replace("{namespace}", this.namespace).replace("{platformId}", platformId).replace("{platformUserId}", platformUserId);
    const resultPromise = this.axiosInstance.get(url, { params });
    return import_sdk61.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, UserResponseV3, "UserResponseV3");
  }
  /**
   * @deprecated
   * ## The endpoint is going to be deprecated ### Endpoint migration guide - **Substitute endpoint: _/iam/v3/public/namespaces/{namespace}/users/me/headless/code/verify [POST]_** The endpoint upgrades a headless account by linking the headless account with the email address and the password. By upgrading the headless account into a full account, the user could use the email address and password for using Justice IAM. The endpoint is a shortcut for upgrading a headless account and verifying the email address in one call. In order to get a verification code for the endpoint, please check the send verification code endpoint.
   */
  updateUpgradeHeadlessAccountWithVerificationCode_ByUserId(userId, data) {
    const params = {};
    const url = "/iam/namespaces/{namespace}/users/{userId}/upgradeHeadlessAccountWithVerificationCode".replace("{namespace}", this.namespace).replace("{userId}", userId);
    const resultPromise = this.axiosInstance.post(url, data, { params });
    return import_sdk61.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, UserResponse, "UserResponse");
  }
  /**
   * This endpoint is used to process third party account link, this endpoint will return the link status directly instead of redirecting to the original page. The param **state** comes from the response of &lt;code&gt;/users/me/platforms/{platformId}/web/link&lt;/code&gt; Supported platforms: - ps4web - xblweb - steamopenid - epicgames - facebook - twitch - google - apple - snapchat - discord - amazon - oculusweb
   */
  postWebLinkProcesMeUser_ByPlatformId_v3(platformId, data) {
    const params = {};
    const url = "/iam/v3/public/namespaces/{namespace}/users/me/platforms/{platformId}/web/link/process".replace("{namespace}", this.namespace).replace("{platformId}", platformId);
    const resultPromise = this.axiosInstance.post(url, import_sdk61.CodeGenUtil.getFormUrlEncodedData(data), {
      ...params,
      headers: { ...params.headers, "content-type": "application/x-www-form-urlencoded" }
    });
    return import_sdk61.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, LinkRequest, "LinkRequest");
  }
  /**
   * This endpoint is used by third party to redirect the code for the purpose of linking the account third party to IAM account. Supported platforms: - ps4web - xblweb - steamopenid - epicgames - facebook - twitch - google - apple - snapchat - discord - amazon - oculusweb
   */
  getWebLinkEstablishMeUsers_ByPlatformId_v3(platformId, queryParams) {
    const params = { ...queryParams };
    const url = "/iam/v3/public/namespaces/{namespace}/users/me/platforms/{platformId}/web/link/establish".replace("{namespace}", this.namespace).replace("{platformId}", platformId);
    const resultPromise = this.axiosInstance.get(url, { params });
    return import_sdk61.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, import_zod237.z.unknown(), "z.unknown()");
  }
};

// src/generated-public/UsersApi.ts
function UsersApi(sdk, args) {
  const sdkAssembly = sdk.assembly();
  const namespace = args?.coreConfig?.namespace ?? sdkAssembly.coreConfig.namespace;
  const useSchemaValidation = args?.coreConfig?.useSchemaValidation ?? sdkAssembly.coreConfig.useSchemaValidation;
  let axiosInstance = sdkAssembly.axiosInstance;
  const requestConfigOverrides = args?.axiosConfig?.request;
  const baseURLOverride = args?.coreConfig?.baseURL;
  const interceptorsOverride = args?.axiosConfig?.interceptors ?? [];
  if (requestConfigOverrides || baseURLOverride || interceptorsOverride.length > 0) {
    const requestConfig = import_sdk62.ApiUtils.mergeAxiosConfigs(sdkAssembly.axiosInstance.defaults, {
      ...baseURLOverride ? { baseURL: baseURLOverride } : {},
      ...requestConfigOverrides
    });
    axiosInstance = import_sdk62.Network.create(requestConfig);
    for (const interceptor of interceptorsOverride) {
      if (interceptor.type === "request") {
        axiosInstance.interceptors.request.use(interceptor.onRequest, interceptor.onError);
      }
      if (interceptor.type === "response") {
        axiosInstance.interceptors.response.use(interceptor.onSuccess, interceptor.onError);
      }
    }
  }
  async function getUsersMe_v3(queryParams) {
    const $ = new Users$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getUsersMe_v3(queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function createUser(data) {
    const $ = new Users$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.createUser(data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getUsersMeProfileStatus_v3() {
    const $ = new Users$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getUsersMeProfileStatus_v3();
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getUsersAdmin(queryParams) {
    const $ = new Users$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getUsersAdmin(queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getUsersVerifyLinkVerify_v3(queryParams) {
    const $ = new Users$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getUsersVerifyLinkVerify_v3(queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getUsersSearch(queryParams) {
    const $ = new Users$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getUsersSearch(queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function deleteUser_ByUserId(userId) {
    const $ = new Users$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.deleteUser_ByUserId(userId);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getUser_ByUserId(userId) {
    const $ = new Users$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getUser_ByUserId(userId);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function updateUser_ByUserId(userId, data) {
    const $ = new Users$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.updateUser_ByUserId(userId, data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getUsersByLoginId(queryParams) {
    const $ = new Users$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getUsersByLoginId(queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function createUser_v2(data) {
    const $ = new Users$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.createUser_v2(data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getUsers_v3(queryParams) {
    const $ = new Users$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getUsers_v3(queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function createUser_v3(data) {
    const $ = new Users$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.createUser_v3(data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function createUserMeVerifyLinkRequest_v3(data) {
    const $ = new Users$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.createUserMeVerifyLinkRequest_v3(data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function createBan_ByUserId(userId, data) {
    const $ = new Users$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.createBan_ByUserId(userId, data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function patchUserMe_v3(data) {
    const $ = new Users$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.patchUserMe_v3(data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function updateUserMe_v3(data) {
    const $ = new Users$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.updateUserMe_v3(data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getUsersMeHeadlessLinkConflict_v3(queryParams) {
    const $ = new Users$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getUsersMeHeadlessLinkConflict_v3(queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getBans_ByUserId(userId) {
    const $ = new Users$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getBans_ByUserId(userId);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function createUserResetPassword(data) {
    const $ = new Users$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.createUserResetPassword(data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function updateRole_ByUserId(userId, data) {
    const $ = new Users$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.updateRole_ByUserId(userId, data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function createUserForgotPassword(data) {
    const $ = new Users$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.createUserForgotPassword(data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getUsersListByLoginIds(queryParams) {
    const $ = new Users$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getUsersListByLoginIds(queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function updateEnable_ByUserId(userId) {
    const $ = new Users$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.updateEnable_ByUserId(userId);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function createUserReset_v3(data) {
    const $ = new Users$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.createUserReset_v3(data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function updateDisable_ByUserId(userId, data) {
    const $ = new Users$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.updateDisable_ByUserId(userId, data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getUsersByPlatformUserId(queryParams) {
    const $ = new Users$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getUsersByPlatformUserId(queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function createUserForgot_v3(data) {
    const $ = new Users$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.createUserForgot_v3(data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function updatePassword_ByUserId(userId, data) {
    const $ = new Users$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.updatePassword_ByUserId(userId, data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function postCrosslink_ByUserId(userId, data) {
    const $ = new Users$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.postCrosslink_ByUserId(userId, data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getPlatforms_ByUserId(userId) {
    const $ = new Users$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getPlatforms_ByUserId(userId);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getPublisher_ByUserId(userId) {
    const $ = new Users$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getPublisher_ByUserId(userId);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getUser_ByUserId_v2(userId) {
    const $ = new Users$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getUser_ByUserId_v2(userId);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function patchUser_ByUserId_v2(userId, data) {
    const $ = new Users$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.patchUser_ByUserId_v2(userId, data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getUser_ByUserId_v3(userId) {
    const $ = new Users$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getUser_ByUserId_v3(userId);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function createUserMeHeadlesLinkWithProgression_v3(data) {
    const $ = new Users$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.createUserMeHeadlesLinkWithProgression_v3(data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function createUserPlatform_v3(data) {
    const $ = new Users$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.createUserPlatform_v3(data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function deleteInformation_ByUserId(userId) {
    const $ = new Users$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.deleteInformation_ByUserId(userId);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getInformation_ByUserId(userId) {
    const $ = new Users$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getInformation_ByUserId(userId);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function updatePermission_ByUserId(userId, data) {
    const $ = new Users$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.updatePermission_ByUserId(userId, data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function createUserBulkBasic_v3(data) {
    const $ = new Users$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.createUserBulkBasic_v3(data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function updateVerification_ByUserId(userId, data) {
    const $ = new Users$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.updateVerification_ByUserId(userId, data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function createUserCodeVerify_v3(data) {
    const $ = new Users$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.createUserCodeVerify_v3(data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function updateUserMePassword_v3(data) {
    const $ = new Users$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.updateUserMePassword_v3(data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getUsersAvailability_v3(queryParams) {
    const $ = new Users$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getUsersAvailability_v3(queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function createUserCodeRequest_v3(data) {
    const $ = new Users$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.createUserCodeRequest_v3(data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function deleteRole_ByUserId_ByRoleId(userId, roleId) {
    const $ = new Users$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.deleteRole_ByUserId_ByRoleId(userId, roleId);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function updateRole_ByUserId_ByRoleId(userId, roleId) {
    const $ = new Users$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.updateRole_ByUserId_ByRoleId(userId, roleId);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getBans_ByUserId_v2(userId, queryParams) {
    const $ = new Users$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getBans_ByUserId_v2(userId, queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function createUserResetPassword_v2(data) {
    const $ = new Users$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.createUserResetPassword_v2(data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getBans_ByUserId_v3(userId, queryParams) {
    const $ = new Users$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getBans_ByUserId_v3(userId, queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function createUserForgotPassword_v2(data) {
    const $ = new Users$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.createUserForgotPassword_v2(data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function createUserMeCodeVerify_v3(data) {
    const $ = new Users$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.createUserMeCodeVerify_v3(data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getLoginsHistories_ByUserId(userId, queryParams) {
    const $ = new Users$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getLoginsHistories_ByUserId(userId, queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function updateVerificationcode_ByUserId(userId, data) {
    const $ = new Users$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.updateVerificationcode_ByUserId(userId, data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function createUserMeCodeRequest_v3(data) {
    const $ = new Users$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.createUserMeCodeRequest_v3(data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function createUserInputValidation_v3(data) {
    const $ = new Users$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.createUserInputValidation_v3(data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function updatePassword_ByUserId_v2(userId, data) {
    const $ = new Users$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.updatePassword_ByUserId_v2(userId, data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function postValidate_ByUserId_v3(userId, data) {
    const $ = new Users$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.postValidate_ByUserId_v3(userId, data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function updateEnable_ByUserId_ByBanId(userId, banId) {
    const $ = new Users$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.updateEnable_ByUserId_ByBanId(userId, banId);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getPlatforms_ByUserId_v3(userId, queryParams) {
    const $ = new Users$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getPlatforms_ByUserId_v3(userId, queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getPublisher_ByUserId_v3(userId) {
    const $ = new Users$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getPublisher_ByUserId_v3(userId);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function createUserMeHeadlesVerify_v3(data, queryParams) {
    const $ = new Users$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.createUserMeHeadlesVerify_v3(data, queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function updateDisable_ByUserId_ByBanId(userId, banId) {
    const $ = new Users$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.updateDisable_ByUserId_ByBanId(userId, banId);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getInformation_ByUserId_v3(userId) {
    const $ = new Users$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getInformation_ByUserId_v3(userId);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function updateUpgradeHeadlessAccount_ByUserId(userId, data) {
    const $ = new Users$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.updateUpgradeHeadlessAccount_ByUserId(userId, data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getUserInvite_ByInvitationId_v3(invitationId) {
    const $ = new Users$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getUserInvite_ByInvitationId_v3(invitationId);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function createUserInvite_ByInvitationId_v3(invitationId, data) {
    const $ = new Users$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.createUserInvite_ByInvitationId_v3(invitationId, data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function createUser_ByPlatformId_v3(platformId, data, queryParams) {
    const $ = new Users$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.createUser_ByPlatformId_v3(platformId, data, queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function createPlatformLink_ByUserId_v3(userId, data) {
    const $ = new Users$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.createPlatformLink_ByUserId_v3(userId, data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function createUserMeHeadlesCodeVerify_v3(data) {
    const $ = new Users$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.createUserMeHeadlesCodeVerify_v3(data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getLoginsHistories_ByUserId_v3(userId, queryParams) {
    const $ = new Users$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getLoginsHistories_ByUserId_v3(userId, queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function deleteUserMePlatform_ByPlatformId_v3(platformId, data) {
    const $ = new Users$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.deleteUserMePlatform_ByPlatformId_v3(platformId, data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function postUserMePlatform_ByPlatformId_v3(platformId, data) {
    const $ = new Users$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.postUserMePlatform_ByPlatformId_v3(platformId, data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function postLink_ByUserId_ByPlatformId(userId, platformId, data) {
    const $ = new Users$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.postLink_ByUserId_ByPlatformId(userId, platformId, data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getPlatformsJustice_ByUserId_v2(userId) {
    const $ = new Users$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getPlatformsJustice_ByUserId_v2(userId);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getDistinctPlatforms_ByUserId_v3(userId) {
    const $ = new Users$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getDistinctPlatforms_ByUserId_v3(userId);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getPlatformsJustice_ByUserId_v3(userId) {
    const $ = new Users$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getPlatformsJustice_ByUserId_v3(userId);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getAsyncStatus_ByRequestId_v3(requestId) {
    const $ = new Users$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getAsyncStatus_ByRequestId_v3(requestId);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function postUnlink_ByUserId_ByPlatformId(userId, platformId, data) {
    const $ = new Users$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.postUnlink_ByUserId_ByPlatformId(userId, platformId, data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function deleteAllMeUser_ByPlatformId_v3(platformId) {
    const $ = new Users$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.deleteAllMeUser_ByPlatformId_v3(platformId);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function deletePermission_ByUserId_ByResource_ByAction(userId, resource, action) {
    const $ = new Users$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.deletePermission_ByUserId_ByResource_ByAction(userId, resource, action);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function updatePermission_ByUserId_ByResource_ByAction(userId, resource, action, data) {
    const $ = new Users$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.updatePermission_ByUserId_ByResource_ByAction(userId, resource, action, data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function postForceMeUser_ByPlatformId_v3(platformId, data) {
    const $ = new Users$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.postForceMeUser_ByPlatformId_v3(platformId, data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getAgerestrictions_ByCountryCode_v2(countryCode) {
    const $ = new Users$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getAgerestrictions_ByCountryCode_v2(countryCode);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getAgerestrictionCountry_ByCountryCode_v3(countryCode) {
    const $ = new Users$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getAgerestrictionCountry_ByCountryCode_v3(countryCode);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getPlatformJustice_ByUserId_ByTargetNamespace(userId, targetNamespace) {
    const $ = new Users$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getPlatformJustice_ByUserId_ByTargetNamespace(userId, targetNamespace);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function updatePlatformJustice_ByUserId_ByTargetNamespace(userId, targetNamespace) {
    const $ = new Users$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.updatePlatformJustice_ByUserId_ByTargetNamespace(userId, targetNamespace);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getWebLinkMeUsers_ByPlatformId_v3(platformId, queryParams) {
    const $ = new Users$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getWebLinkMeUsers_ByPlatformId_v3(platformId, queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function deleteLink_ByUserId_ByPlatformId_v2(userId, platformId, data) {
    const $ = new Users$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.deleteLink_ByUserId_ByPlatformId_v2(userId, platformId, data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function postLink_ByUserId_ByPlatformId_v2(userId, platformId, data) {
    const $ = new Users$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.postLink_ByUserId_ByPlatformId_v2(userId, platformId, data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function createPlatformLinkWithProgression_ByUserId_v3(userId, data) {
    const $ = new Users$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.createPlatformLinkWithProgression_ByUserId_v3(userId, data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function createUserMePlatformJustice_ByTargetNamespace_v3(targetNamespace) {
    const $ = new Users$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.createUserMePlatformJustice_ByTargetNamespace_v3(targetNamespace);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getUser_ByPlatformId_ByPlatformUserId_v3(platformId, platformUserId) {
    const $ = new Users$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getUser_ByPlatformId_ByPlatformUserId_v3(platformId, platformUserId);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function updateUpgradeHeadlessAccountWithVerificationCode_ByUserId(userId, data) {
    const $ = new Users$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.updateUpgradeHeadlessAccountWithVerificationCode_ByUserId(userId, data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function postWebLinkProcesMeUser_ByPlatformId_v3(platformId, data) {
    const $ = new Users$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.postWebLinkProcesMeUser_ByPlatformId_v3(platformId, data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getWebLinkEstablishMeUsers_ByPlatformId_v3(platformId, queryParams) {
    const $ = new Users$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getWebLinkEstablishMeUsers_ByPlatformId_v3(platformId, queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  return {
    /**
     * Get my user data __Supported 3rd platforms:__ * __PSN(ps4web, ps4, ps5)__ * account id * display name * avatar * __Xbox(live, xblweb)__ * xuid or pxuid * display name * __Steam(steam, steamopenid)__ * steam id * display name * avatar * __EpicGames(epicgames)__ * epic account id * display name action code : 10147
     */
    getUsersMe_v3,
    /**
     * @deprecated
     * ## The endpoint is going to be deprecated ### Endpoint migration guide - **Substitute endpoint: _/iam/v3/public/namespaces/{namespace}/users [POST]_** - **Substitute endpoint: _/iam/v4/public/namespaces/{namespace}/users [POST]_** - **Note:** 1. v3 &amp; v4 introduce optional verification code 2. format difference（Pascal case =&gt; Camel case) Available Authentication Types: 1. **EMAILPASSWD**: an authentication type used for new user registration through email. 2. **PHONEPASSWD**: an authentication type used for new user registration through phone number. Country use ISO3166-1 alpha-2 two letter, e.g. US.
     */
    createUser,
    /**
     * This API is for user to get self profile update allow status. Note: If the config is not found, this API will return a config with unlimited.
     */
    getUsersMeProfileStatus_v3,
    /**
     * @deprecated
     * ## The endpoint is going to be deprecated ### Endpoint migration guide - **Substitute endpoint(Public): _/iam/v3/admin/namespaces/{namespace}/roles/{roleId}/users [GET]_** - **Note:** difference in V3 response, format difference: Pascal case =&gt; Camel case This endpoint search admin users which have the roleId Notes : this endpoint only accept admin role. Admin Role is role which have admin status and members. Use endpoint [GET] /roles/{roleId}/admin to check the role status
     */
    getUsersAdmin,
    getUsersVerifyLinkVerify_v3,
    /**
     * @deprecated
     * ## The endpoint is going to be deprecated ### Endpoint migration guide - **Substitute endpoint: _/iam/v3/admin/namespaces/{namespace}/users/search [GET]_** Search all users that match the query on these fields: all login IDs (email address, phone number, and platform user id), userID, display name, and on the specified namespace. If the query is not defined, then it searches all users on the specified namespace.
     */
    getUsersSearch,
    /**
     * @deprecated
     * ## The endpoint is going to be deprecated ### Endpoint migration guide - **Substitute endpoint: _/iam/v3/admin/namespaces/{namespace}/users/{userId}/information [DELETE]_**
     */
    deleteUser_ByUserId,
    /**
     * @deprecated
     * ## The endpoint is going to be deprecated ### Endpoint migration guide - **Substitute endpoint(Public): _/iam/v3/public/namespaces/{namespace}/users/{userId} [GET]_** - **Substitute endpoint(Admin): _/iam/v3/admin/namespaces/{namespace}/users/{userId} [GET]_** - **Note:** format difference in response: Pascal case =&gt; Camel case
     */
    getUser_ByUserId,
    /**
     * @deprecated
     * ## The endpoint is going to be deprecated ### Endpoint migration guide - **Substitute endpoint([PUT]): _/iam/v3/public/namespaces/{namespace}/users/me [PUT]_** - **Substitute endpoint([PATCH]): _/iam/v3/public/namespaces/{namespace}/users/me [PATCH]_** - **Substitute endpoint([PATCH]): _/iam/v4/public/namespaces/{namespace}/users/me [PATCH]_** - **Note:** 1. Prefer [PATCH] if client support PATCH method 2. Difference in V3/v4 request body, format difference: Pascal case =&gt; Camel case This Endpoint support update user based on given data. **Single request can update single field or multi fields.** Supported field {Country, DisplayName, LanguageTag} Country use ISO3166-1 alpha-2 two letter, e.g. US. **Several case of updating email address** - User want to update email address of which have been verified, NewEmailAddress response field will be filled with new email address - User want to update email address of which have not been verified, {LoginId, OldEmailAddress, EmailAddress} response field will be filled with new email address. - User want to update email address of which have been verified and updated before, {LoginId, OldEmailAddress, EmailAddress} response field will be filled with verified email before. NewEmailAddress response field will be filled with newest email address.
     */
    updateUser_ByUserId,
    /**
     * @deprecated
     * ## The endpoint is going to be deprecated ### Endpoint migration guide - **Substitute endpoint: _/iam/v3/public/namespaces/{namespace}/users [GET]_**
     */
    getUsersByLoginId,
    /**
     * @deprecated
     * ## The endpoint is going to be deprecated **Endpoint migration guide** - **Substitute endpoint: _/iam/v3/public/namespaces/{namespace}/users [POST]_** - **Substitute endpoint: _/iam/v4/public/namespaces/{namespace}/users [POST]_** - **Note:** 1. v3 &amp; v4 introduce optional verification code 2. format difference（Pascal case =&gt; Camel case) Available Authentication Types: 1. *EMAILPASSWD*: an authentication type used for new user registration through email. Country use ISO3166-1 alpha-2 two letter, e.g. US.
     */
    createUser_v2,
    /**
     * This endpoint search all users on the specified namespace that match the query on these fields: display name, unique display name, username or by 3rd party display name. The query length should between 3-20, otherwise will not query the database. The default limit value is 20. ## Searching by 3rd party platform **Note: searching by 3rd party platform display name will use exact query, not fuzzy query.** Step when searching by 3rd party platform display name: 1. set __by__ to __thirdPartyPlatform__ 2. set __platformId__ to the _supported platform id_ 3. set __platformBy__ to __platformDisplayName__ **Supported Platforms:** - Steam group (steamnetwork): - steam - steamopenid - PSN group (psn): - ps4web - ps4 - ps5 - XBOX group(xbox): - live - xblweb - Oculus group (oculusgroup): - oculus - oculusweb - Google group (google): - google - googleplaygames: - epicgames - facebook - twitch - discord - android - ios - apple - device - nintendo - awscognito - amazon - netflix - snapchat - _oidc platform id_ Note: - You can use either platform id or platform group as **platformId** parameter. - **Nintendo platform user id**: NSA ID need to be appended with Environment ID using colon as separator. e.g kmzwa8awaa:dd1
     */
    getUsers_v3,
    /**
     * Available Authentication Types: 1. **EMAILPASSWD**: an authentication type used for new user registration through email. **Note**: * **uniqueDisplayName**: this is required when uniqueDisplayNameEnabled/UNIQUE_DISPLAY_NAME_ENABLED is true. * **code**: this is required when mandatoryEmailVerificationEnabled config is true. please refer to the config from /iam/v3/public/namespaces/{namespace}/config/{configKey} [GET] API. Country use ISO3166-1 alpha-2 two letter, e.g. US. Date of Birth format : YYYY-MM-DD, e.g. 2019-04-29. This endpoint support accepting agreements for the created user. Supply the accepted agreements in acceptedPolicies attribute.
     */
    createUser_v3,
    /**
     * The verification link is sent to email address It will not send request if user email is already verified
     */
    createUserMeVerifyLinkRequest_v3,
    /**
     * @deprecated
     * ## The endpoint is going to be deprecated ### Endpoint migration guide - **Substitute endpoint: _/iam/v3/admin/namespaces/{namespace}/users/{userId}/bans [POST]_**
     */
    createBan_ByUserId,
    /**
     * This Endpoint support update user based on given data. **Single request can update single field or multi fields.** Supported field {country, displayName, languageTag, dateOfBirth, avatarUrl, userName} Country use ISO3166-1 alpha-2 two letter, e.g. US. Date of Birth format : YYYY-MM-DD, e.g. 2019-04-29. **Response body logic when user updating email address:** - User want to update email address of which have been verified, newEmailAddress response field will be filled with new email address. - User want to update email address of which have not been verified, { oldEmailAddress, emailAddress} response field will be filled with new email address. - User want to update email address of which have been verified and updated before, { oldEmailAddress, emailAddress} response field will be filled with verified email before. newEmailAddress response field will be filled with newest email address. action code : 10103
     */
    patchUserMe_v3,
    /**
     * This Endpoint support update user based on given data. **Single request can update single field or multi fields.** Supported field {country, displayName, languageTag, dateOfBirth, avatarUrl, userName} Country use ISO3166-1 alpha-2 two letter, e.g. US. Date of Birth format : YYYY-MM-DD, e.g. 2019-04-29. **Response body logic when user updating email address:** - User want to update email address of which have been verified, newEmailAddress response field will be filled with new email address. - User want to update email address of which have not been verified, { oldEmailAddress, emailAddress} response field will be filled with new email address. - User want to update email address of which have been verified and updated before, { oldEmailAddress, emailAddress} response field will be filled with verified email before. newEmailAddress response field will be filled with newest email address. **Important notes:** This endpoint provides support for client that doesn&#39;t have PATCH support, i.e. UE4 before v4.23 released. If the client support PATCH method, use [PATCH] /iam/v3/public/namespaces/{namespace}/users/me instead action code : 10103
     */
    updateUserMe_v3,
    /**
     * Note: 1. My account should be full account 2. My account not linked to request headless account&#39;s third platform. After client resolving the conflict, it will call endpoint &lt;code&gt;/iam/v3/public/users/me/headless/linkWithProgression [POST]&lt;/code&gt;
     */
    getUsersMeHeadlessLinkConflict_v3,
    /**
     * @deprecated
     * ## The endpoint is going to be deprecated ### Endpoint migration guide - **Substitute endpoint: _/iam/v3/admin/namespaces/{namespace}/users/{userId}/bans [GET]_**
     */
    getBans_ByUserId,
    /**
     * @deprecated
     * ## The endpoint is going to be deprecated ### Endpoint migration guide - **Substitute endpoint: _/iam/v3/public/namespaces/{namespace}/users/reset [POST]_**
     */
    createUserResetPassword,
    /**
     * @deprecated
     * ## The endpoint is going to be deprecated ### Endpoint migration guide - **Substitute endpoint: _/iam/v3/admin/namespaces/{namespace}/users/{userId}/roles [PATCH]_**
     */
    updateRole_ByUserId,
    /**
     * @deprecated
     * ## The endpoint is going to be deprecated ### Endpoint migration guide - **Substitute endpoint: _/iam/v3/public/namespaces/{namespace}/users/forgot [POST]_** **Special note for publisher-game scenario:** Game Client should provide game namespace path parameter and Publisher Client should provide publisher namespace path parameter. The password reset code will be sent to the publisher account&#39;s email address.
     */
    createUserForgotPassword,
    /**
     * @deprecated
     * ## The endpoint is going to be deprecated ### Endpoint migration guide - **Substitute endpoint(query by email list): _/iam/v3/public/namespaces/{namespace}/users/bulk/basic [POST]_** - **Substitute endpoint(query by user id list): _/iam/v3/admin/namespaces/{namespace}/users/search/bulk [POST]_**
     */
    getUsersListByLoginIds,
    /**
     * @deprecated
     * ## The endpoint is going to be deprecated ### Endpoint migration guide - **Substitute endpoint: _/iam/v3/admin/namespaces/{namespace}/users/{userId}/status [PATCH]_**
     */
    updateEnable_ByUserId,
    /**
     * action code: 10105
     */
    createUserReset_v3,
    /**
     * @deprecated
     * ## The endpoint is going to be deprecated ### Endpoint migration guide - **Substitute endpoint: _/iam/v3/admin/namespaces/{namespace}/users/{userId}/status [PATCH]_** For **Deletion Account** purpose fill the reason with: - **DeactivateAccount** : if your deletion request comes from user - **AdminDeactivateAccount** : if your deletion request comes from admin
     */
    updateDisable_ByUserId,
    /**
     * @deprecated
     * ## The endpoint is going to be deprecated ### Endpoint migration guide - **Substitute endpoint(Public): _/iam/v3/public/namespaces/{namespace}/platforms/{platformId}/users/{platformUserId} [GET]_** - **Substitute endpoint(Admin): _/iam/v3/admin/namespaces/{namespace}/platforms/{platformId}/users/{platformUserId} [GET]_** - **Note:** 1. difference in V3 response, format difference: Pascal case =&gt; Camel case
     */
    getUsersByPlatformUserId,
    /**
     * **Special note for publisher-game scenario:** Game Client should provide game namespace path parameter and Publisher Client should provide publisher namespace path parameter. The password reset code will be sent to the publisher account&#39;s email address. action code : 10104
     */
    createUserForgot_v3,
    /**
     * @deprecated
     *  ## The endpoint is going to be deprecated ### Endpoint migration guide - **Substitute endpoint: _/iam/v3/public/namespaces/{namespace}/users/me/password [PUT]_**
     */
    updatePassword_ByUserId,
    /**
     * @deprecated
     * ## The endpoint is going to be deprecated ### Endpoint migration guide - **Substitute endpoint: _/iam/v3/public/namespaces/{namespace}/users/me/platforms/{platformId} [POST]_** Access token from original namespace is needed as authorization header. Access token from designated account needed as form parameter to verify the ownership of that account. When platformID (device platfom ID) is specified, platform login method for that specific platform ID is removed. This means to protect account from second hand device usage.
     */
    postCrosslink_ByUserId,
    /**
     * @deprecated
     * ## The endpoint is going to be deprecated ### Endpoint migration guide - **Substitute endpoint: _/iam/v3/public/namespaces/{namespace}/users/{userId}/platforms [GET]_** - **Substitute endpoint: _/iam/v3/admin/namespaces/{namespace}/users/{userId}/platforms [GET]_** ## Justice Platform Account The permission ’ADMIN:NAMESPACE:{namespace}:JUSTICE:USER:{userId}’ [READ] is required in order to read the UserID who linked with the user.
     */
    getPlatforms_ByUserId,
    /**
     * @deprecated
     * ## The endpoint is going to be deprecated ### Endpoint migration guide - **Substitute endpoint: _/iam/v3/public/namespaces/{namespace}/users/{userId}/publisher [GET]_** **Restriction:** Path Parameter *namespace* can be provided only with game namespace
     */
    getPublisher_ByUserId,
    /**
     * @deprecated
     * ## The endpoint is going to be deprecated **Endpoint migration guide** - **Substitute endpoint(Public): _/iam/v3/public/namespaces/{namespace}/users/{userId} [GET]_** - **Substitute endpoint(Admin): _/iam/v3/admin/namespaces/{namespace}/users/{userId} [GET]_** - **Note:** format difference in response: Pascal case =&gt; Camel case
     */
    getUser_ByUserId_v2,
    /**
     * @deprecated
     * ## The endpoint is going to be deprecated **Endpoint migration guide** - **Substitute endpoint([PUT]): _/iam/v3/public/namespaces/{namespace}/users/me [PUT]_** - **Substitute endpoint([PATCH]): _/iam/v3/public/namespaces/{namespace}/users/me [PATCH]_** - **Substitute endpoint([PATCH]): _/iam/v4/public/namespaces/{namespace}/users/me [PATCH]_** - **Note:** 1. Prefer [PATCH] if client support PATCH method 2. Difference in V3/v4 request body, format difference: Pascal case =&gt; Camel case This Endpoint support update user based on given data. **Single request can update single field or multi fields.** Supported field {Country, DisplayName, LanguageTag}
     */
    patchUser_ByUserId_v2,
    /**
     * @deprecated
     * This endpoint retrieve user attributes. action code: 10129 **Substitute endpoint:** /v4/public/namespaces/{namespace}/users/{userId} [READ]
     */
    getUser_ByUserId_v3,
    /**
     * Note: 1. My account should be full account 2. My account not linked to headless account&#39;s third platform.
     */
    createUserMeHeadlesLinkWithProgression_v3,
    /**
     * Note: 1. the max count of user ids in the request is 100 2. if platform id is not empty, the result will only contain the corresponding platform infos 3. if platform id is empty, the result will contain all the supported platform infos __Supported 3rd platforms:__ * __PSN(ps4web, ps4, ps5)__ * account id * display name * avatar * __Xbox(live, xblweb)__ * xuid or pxuid * display name * __Steam(steam, steamopenid)__ * steam id * display name * avatar * __EpicGames(epicgames)__ * epic account id * display name
     */
    createUserPlatform_v3,
    /**
     * @deprecated
     * ## The endpoint is going to be deprecated ### Endpoint migration guide - **Substitute endpoint: _/iam/v3/admin/namespaces/{namespace}/users/{userId}/information [DELETE]_**
     */
    deleteInformation_ByUserId,
    /**
     * @deprecated
     * ## The endpoint is going to be deprecated ### Endpoint migration guide - **Substitute endpoint: _/iam/v3/public/namespaces/{namespace}/users/{userId}/information [GET]_**
     */
    getInformation_ByUserId,
    /**
     * @deprecated
     * ## The endpoint is going to be deprecated ### Endpoint migration guide - **Substitute endpoint: _/iam/v3/admin/namespaces/{namespace}/users/{userId}/permissions [POST]_** This endpoint will REPLACE user&#39;s permissions with the ones defined in body Schedule contains cron string or date range (both are UTC, also in cron syntax) to indicate when a permission and action are in effect. Both schedule types accepts quartz compatible cron syntax e.g. * * * * * * *. In ranged schedule, first element will be start date, and second one will be end date If schedule is set, the scheduled action must be valid too, that is between 1 to 15, inclusive Syntax reference Fields: 1. Seconds: 0-59 * / , - 2. Minutes: 0-59 * / , - 3. Hours: 0-23 * / , - 4. Day of month: 1-31 * / , - L W 5. Month: 1-12 JAN-DEC * / , - 6. Day of week: 0-6 SUN-SAT * / , - L # 7. Year: 1970-2099 * / , - Special characters: 1. *: all values in the fields, e.g. * in seconds fields indicates every second 2. /: increments of ranges, e.g. 3-59/15 in the minute field indicate the third minute of the hour and every 15 minutes thereafter 3. ,: separate items of a list, e.g. MON,WED,FRI in day of week 4. -: range, e.g. 2010-2018 indicates every year between 2010 and 2018, inclusive 5. L: last, e.g. When used in the day-of-week field, it allows you to specify constructs such as &#34;the last Friday&#34; (5L) of a given month. In the day-of-month field, it specifies the last day of the month. 6. W: business day, e.g. if you were to specify 15W as the value for the day-of-month field, the meaning is: &#34;the nearest business day to the 15th of the month.&#34; 7. #: must be followed by a number between one and five. It allows you to specify constructs such as &#34;the second Friday&#34; of a given month.
     */
    updatePermission_ByUserId,
    /**
     * Notes: - This endpoint bulk get users&#39; basic info by userId, max allowed 100 at a time - If namespace is game, will search by game user Id, other wise will search by publisher namespace - **Result will include displayName(if it exists)**
     */
    createUserBulkBasic_v3,
    /**
     * @deprecated
     * ## The endpoint is going to be deprecated ### Endpoint migration guide - **Substitute endpoint: _/iam/v3/public/namespaces/{namespace}/users/me/code/verify [POST]_** Redeems a verification code sent to a user to verify the user&#39;s contact address is correct Available ContactType : *email* or *phone*
     */
    updateVerification_ByUserId,
    /**
     * Verify the registration code
     */
    createUserCodeVerify_v3,
    /**
     * action code: 10107
     */
    updateUserMePassword_v3,
    /**
     * Check user&#39;s account availability. Available field : - displayName - uniqueDisplayName - username If request include access token with user ID data, that user ID will be excluded from availability check. For example, in case user update his emailAddress, he can use his own emailAddress to update his account. Response Code : - Account Available : 404 (not found) - Account Not Available : 204 (no content)
     */
    getUsersAvailability_v3,
    /**
     * This endpoint will validate the request&#39;s email address. If it already been used, will response 409. If it is available, we will send a verification code to this email address. This code can be verified by this [endpoint](#operations-Users-PublicVerifyRegistrationCode).
     */
    createUserCodeRequest_v3,
    /**
     * @deprecated
     * ## The endpoint is going to be deprecated ### Endpoint migration guide - **Substitute endpoint: _/iam/v3/admin/namespaces/{namespace}/users/{userId}/roles/{roleId} [DELETE]_**
     */
    deleteRole_ByUserId_ByRoleId,
    /**
     * @deprecated
     * ## The endpoint is going to be deprecated ### Endpoint migration guide - **Substitute endpoint: _/iam/v3/admin/namespaces/{namespace}/users/{userId}/roles/{roleId} [POST]_**
     */
    updateRole_ByUserId_ByRoleId,
    /**
     * @deprecated
     * ## The endpoint is going to be deprecated **Endpoint migration guide** - **Substitute endpoint: _/iam/v3/public/namespaces/{namespace}/users/{userId}/bans [GET]_**
     */
    getBans_ByUserId_v2,
    /**
     * @deprecated
     * ## The endpoint is going to be deprecated **Endpoint migration guide** - **Substitute endpoint: _/iam/v3/public/namespaces/{namespace}/users/reset [POST]_**
     */
    createUserResetPassword_v2,
    /**
     * Notes: - This endpoint retrieve the first page of the data if after and before parameters is empty - **The pagination is not working yet** **Authentication:** The _**userId**_ parameter should match the one in the access token.
     */
    getBans_ByUserId_v3,
    /**
     * @deprecated
     * ## The endpoint is going to be deprecated **Endpoint migration guide** - **Substitute endpoint: _/iam/v3/public/namespaces/{namespace}/users/forgot [POST]_** **Special note for publisher-game scenario:** Game Client should provide game namespace path parameter and Publisher Client should provide publisher namespace path parameter. The password reset code will be sent to the publisher account&#39;s email address.
     */
    createUserForgotPassword_v2,
    /**
     * Will consume code if validateOnly is set false Redeems a verification code sent to a user to verify the user&#39;s contact address is correct Available ContactType : **email** action code: 10107
     */
    createUserMeCodeVerify_v3,
    /**
     * @deprecated
     * ## The endpoint is going to be deprecated ### Endpoint migration guide - **Substitute endpoint: _/iam/v3/public/namespaces/{namespace}/users/{userId}/logins/histories [GET]_** - **Substitute endpoint: _/iam/v3/admin/namespaces/{namespace}/users/{userId}/logins/histories [GET]_** Notes for this endpoint: - This endpoint retrieve the first page of the data if &#39;after&#39; and &#39;before&#39; parameters is empty. - The maximum value of the limit is 100 and the minimum value of the limit is 1. - This endpoint retrieve the next page of the data if we provide &#39;after&#39; parameters with valid Unix timestamp. - This endpoint retrieve the previous page of the data if we provide &#39;before&#39; parameter with valid data Unix timestamp.
     */
    getLoginsHistories_ByUserId,
    /**
     * @deprecated
     * ## The endpoint is going to be deprecated ### Endpoint migration guide - **Substitute endpoint: _/iam/v3/public/namespaces/{namespace}/users/me/code/request [POST]_** The verification code is sent to either the phone number or email address. It depends on the LoginID&#39;s value. Available contexts for use : 1. **UserAccountRegistration** a context type used for verifying email address in user account registration. It returns 409 if the email address already verified. **_It is the default context if the Context field is empty_** 2. **UpdateEmailAddress** a context type used for verify user before updating email address.(Without email address verified checking) 3. **upgradeHeadlessAccount** The context is intended to be used whenever the email address wanted to be automatically verified on upgrading a headless account. If this context used, IAM rejects the request if the loginId field&#39;s value is already used by others by returning HTTP Status Code 409.
     */
    updateVerificationcode_ByUserId,
    /**
     * The verification code is sent to email address Available contexts for use : 1. **UserAccountRegistration** a context type used for verifying email address in user account registration. It returns 409 if the email address already verified. **_It is the default context if the Context field is empty_** 2. **UpdateEmailAddress** a context type used for verify user before updating email address.(Without email address verified checking) 3. **upgradeHeadlessAccount** The context is intended to be used whenever the email address wanted to be automatically verified on upgrading a headless account. If this context used, IAM rejects the request if the email address is already used by others by returning HTTP Status Code 409. action code: 10116
     */
    createUserMeCodeRequest_v3,
    /**
     * Validate user&#39;s input. -------- **note:** - this endpoint will check the input validation and profanity filter service(if this is enabled) - the namespace should be publisher namespace
     */
    createUserInputValidation_v3,
    /**
     * @deprecated
     * ## The endpoint is going to be deprecated **Endpoint migration guide** - **Substitute endpoint: _/iam/v3/public/namespaces/{namespace}/users/me/password [PUT]_**
     */
    updatePassword_ByUserId_v2,
    /**
     * This endpoint is used to validate the user password. This endpoint validate the user password by specifying the userId and password. **Authentication:** The _**userId**_ parameter should match the one in the access token.
     */
    postValidate_ByUserId_v3,
    /**
     * @deprecated
     * ## The endpoint is going to be deprecated ### Endpoint migration guide - **Substitute endpoint: _/iam/v3/admin/namespaces/{namespace}/users/{userId}/bans/{banId} [PATCH]_**
     */
    updateEnable_ByUserId_ByBanId,
    /**
     * This endpoint retrieves platform accounts linked to user. **Supported Platforms:** - Steam group (steamnetwork): - steam - steamopenid - PSN group (psn): - ps4web - ps4 - ps5 - XBOX group(xbox): - live - xblweb - Oculus group (oculusgroup): - oculus - oculusweb - Google group (google): - google - googleplaygames: - epicgames - facebook - twitch - discord - android - ios - apple - device - nintendo - awscognito - amazon - netflix - snapchat - _oidc platform id_ Note: - You can use either platform id or platform group as **platformId** parameter. - **Nintendo platform user id**: NSA ID need to be appended with Environment ID using colon as separator. e.g kmzwa8awaa:dd1 **Authentication:** The _**userId**_ parameter should match the one in the access token. action code: 10128
     */
    getPlatforms_ByUserId_v3,
    /**
     * **Restriction:** Path Parameter **namespace** can be provided only with game namespace
     */
    getPublisher_ByUserId_v3,
    /**
     * action code : 10124 if set NeedVerificationCode = true, IAM will send verification code into email user can use that verification code to verify user through /iam/v3/public/namespaces/{namespace}/users/me/code/verify
     */
    createUserMeHeadlesVerify_v3,
    /**
     * @deprecated
     * ## The endpoint is going to be deprecated ### Endpoint migration guide - **Substitute endpoint: _/iam/v3/admin/namespaces/{namespace}/users/{userId}/bans/{banId} [PATCH]_** **Notes for using IAM in publisher - game studio scenarios** The endpoint allows: - The admin user in publisher namespace disables user’s ban in publisher namespace. - The admin user in game namespace disables user’s ban in game namespace. - The admin user in publisher namespace disables user’s ban in publisher namespace. Other scenarios are not supported and will return 403: Forbidden.
     */
    updateDisable_ByUserId_ByBanId,
    /**
     * This endpoint retrieves user info and linked platform accounts. **Authentication:** The _**userId**_ parameter should match the one in the access token.
     */
    getInformation_ByUserId_v3,
    /**
     * @deprecated
     * ## The endpoint is going to be deprecated ### Endpoint migration guide - **Substitute endpoint: _/iam/v3/public/namespaces/{namespace}/users/me/headless/verify [POST]_**
     */
    updateUpgradeHeadlessAccount_ByUserId,
    /**
     * Endpoint to validate user invitation. When not found, it could also means the invitation has expired.
     */
    getUserInvite_ByInvitationId_v3,
    /**
     * This endpoint create user from saved roles when creating invitation and submitted data. User will be able to login after completing submitting the data through this endpoint. Available Authentication Types: EMAILPASSWD: an authentication type used for new user registration through email. **Note**: * **uniqueDisplayName**: this is required when uniqueDisplayNameEnabled/UNIQUE_DISPLAY_NAME_ENABLED is true. Country use ISO3166-1 alpha-2 two letter, e.g. US. Date of Birth format : YYYY-MM-DD, e.g. 2019-04-29.
     */
    createUserInvite_ByInvitationId_v3,
    /**
     * @deprecated
     * List User ID By Platform User ID This endpoint intended to list game user ID from the given namespace This endpoint return list of user ID by given platform ID and list of platform user ID Supported platform: - steam - steamopenid - ps4web - ps4 - ps5 - live - xblweb - oculus - oculusweb - facebook - google - googleplaygames - twitch - discord - apple - device - justice - epicgames - nintendo - awscognito - netflix - snapchat - oidc platform id Note: **nintendo platform user ID**: NSA ID need to be appended with Environment ID using colon as separator. e.g kmzwa8awaa:dd1
     */
    createUser_ByPlatformId_v3,
    /**
     * It is going to be **DEPRECATED**. Update Platform Account relation to current User Account. Note: Game progression data (statistics, reward, etc) associated with previous User Account will not be transferred. If the data is tight to game user ID, the user will have the game progression data. **Authentication:** The _**userId**_ parameter should match the one in the access token.
     */
    createPlatformLink_ByUserId_v3,
    /**
     * If validateOnly is set false, consume code and upgrade headless account and automatically verified the email address if it is succeeded The endpoint upgrades a headless account by linking the headless account with the email address and the password. By upgrading the headless account into a full account, the user could use the email address and password for using Justice IAM. The endpoint is a shortcut for upgrading a headless account and verifying the email address in one call. In order to get a verification code for the endpoint, please check the send verification code endpoint. This endpoint also have an ability to update user data (if the user data field is specified) right after the upgrade account process is done. Supported user data fields : - displayName - dateOfBirth : format YYYY-MM-DD, e.g. 2019-04-29 - country : format ISO3166-1 alpha-2 two letter, e.g. US action code : 10124
     */
    createUserMeHeadlesCodeVerify_v3,
    /**
     * Notes for this endpoint: - This endpoint retrieve the first page of the data if &lt;code&gt;after&lt;/code&gt; and &lt;code&gt;before&lt;/code&gt; parameters is empty. - The maximum value of the limit is 100 and the minimum value of the limit is 1. - This endpoint retrieve the next page of the data if we provide &lt;code&gt;after&lt;/code&gt; parameters with valid Unix timestamp. - This endpoint retrieve the previous page of the data if we provide &lt;code&gt;before&lt;/code&gt; parameter with valid data Unix timestamp. **Authentication:** The _**userId**_ parameter should match the one in the access token.
     */
    getLoginsHistories_ByUserId_v3,
    /**
     * @deprecated
     * ## Supported platforms: - **steam** - **steamopenid** - **facebook** - **google** - **googleplaygames** - **oculus** - **twitch** - **android** - **ios** - **apple** - **device** - **discord** - **awscognito** - **epicgames** - **nintendo** Unlink user&#39;s account from a specific platform. &#39;justice&#39; platform might have multiple accounts from different namespaces linked. _platformNamespace_ need to be specified when the platform ID is &#39;justice&#39;. Unlink user&#39;s account from justice platform will enable password token grant and password update. If you want to unlink user&#39;s account in a game namespace, you have to specify _platformNamespace_ to that game namespace. action code : 10121
     */
    deleteUserMePlatform_ByPlatformId_v3,
    /**
     * **Prerequisite:** Platform client configuration need to be added to database for specific platformId. Namespace service URL need to be specified (refer to required environment variables). ## Supported platforms: - **steam**: The ticket’s value is the binary ticket returned by Steam. - **steamopenid**: Steam&#39;s user authentication method using OpenID 2.0. The ticket&#39;s value is URL generated by Steam on web authentication - **facebook**: The ticket’s value is the authorization code returned by Facebook OAuth - **google**: The ticket’s value is the authorization code returned by Google OAuth - **googleplaygames**: The ticket’s value is the authorization code returned by Google play games OAuth - **oculus**: The ticket’s value is a string composed of Oculus&#39;s user ID and the nonce separated by a colon (:). - **twitch**: The ticket’s value is the authorization code returned by Twitch OAuth. - **android**: The ticket&#39;s value is the Android’s device ID - **ios**: The ticket&#39;s value is the iOS’s device ID. - **apple**: The ticket’s value is the authorization code returned by Apple OAuth. - **device**: Every device that doesn&#39;t run Android and iOS is categorized as a device platform. The ticket&#39;s value is the device’s ID. - **discord**: The ticket’s value is the authorization code returned by Discord OAuth. - **ps4web**: The ticket’s value is the authorization code returned by PSN OAuth. - **ps4**: The ticket’s value is the authorization code returned by PSN OAuth. - **ps5**: The ticket’s value is the authorization code returned by PSN OAuth. - **xblweb**: The ticket’s value is the authorization code returned by XBox Live OAuth. - **live**: The ticket’s value is the XSTS token. - **awscognito**: The ticket’s value is the aws cognito access token (JWT). - **epicgames**: The ticket’s value is an access-token or authorization code obtained from Epicgames EOS Account Service. - **nintendo**: The ticket’s value is the id_token returned by Nintendo OAuth. - **netflix**: The ticket’s value is GAT (Gamer Access Token) returned by Netflix backend. - **snapchat**: The ticket’s value is authorization code returned by Snapchat OAuth. - **for specific generic oauth (OIDC)**: The platform_token’s value should be the same type as created OIDC auth type whether it is auth code, idToken or bearerToken. action code : 10144
     */
    postUserMePlatform_ByPlatformId_v3,
    /**
     * @deprecated
     * ## The endpoint is going to be deprecated ### Endpoint migration guide - **Substitute endpoint: _/iam/v3/public/namespaces/{namespace}/users/me/platforms/{platformId} [POST]_** **Prerequisite:** Platform client configuration need to be added to database for specific platformId. Namespace service URL need to be specified (refer to required environment variables). ## Supported platforms: - **steam**: The ticket’s value is the authentication code returned by Steam. - **steamopenid**: Steam&#39;s user authentication method using OpenID 2.0. The ticket&#39;s value is URL generated by Steam on web authentication - **facebook**: The ticket’s value is the authorization code returned by Facebook OAuth - **google**: The ticket’s value is the authorization code returned by Google OAuth - **oculus**: The ticket’s value is a string composed of Oculus&#39;s user ID and the nonce separated by a colon (:). - **twitch**: The ticket’s value is the authorization code returned by Twitch OAuth. - **android**: The ticket&#39;s value is the Android’s device ID - **ios**: The ticket&#39;s value is the iOS’s device ID. - **apple**: The ticket’s value is the authorization code returned by Apple OAuth. - **device**: Every device that does’nt run Android and iOS is categorized as a device platform. The ticket&#39;s value is the device’s ID. - **discord**: The ticket’s value is the authorization code returned by Discord OAuth.
     */
    postLink_ByUserId_ByPlatformId,
    /**
     * @deprecated
     * ## The endpoint is going to be deprecated **Endpoint migration guide** - **Substitute endpoint: _/iam/v3/public/namespaces/{namespace}/users/{userId}/platforms/justice [GET]_** This endpoint gets list justice platform account by providing publisher namespace and publisher userID.
     */
    getPlatformsJustice_ByUserId_v2,
    /**
     * This endpoint retrieves platform accounts linked to user. It will query all linked platform accounts. The results will be distinct and grouped by platform, and for each platform, we will select the oldest linked one. **Authentication:** The _**userId**_ parameter should match the one in the access token.
     */
    getDistinctPlatforms_ByUserId_v3,
    /**
     * This endpoint gets list justice platform account by providing publisher namespace and publisher userID. **Authentication:** The _**userId**_ parameter should match the one in the access token.
     */
    getPlatformsJustice_ByUserId_v3,
    /**
     * This endpoint is used to get linking status. This API need logged user and user can only request its own linking status.
     */
    getAsyncStatus_ByRequestId_v3,
    /**
     * @deprecated
     * ## The endpoint is going to be deprecated ### Endpoint migration guide - **Substitute endpoint: _/iam/v3/public/namespaces/{namespace}/users/me/platforms/{platformId} [DELETE]_** - **Substitute endpoint: _/iam/v3/public/namespaces/{namespace}/users/me/platforms/{platformId}/all [DELETE]_** ## Supported platforms: - **steam** - **steamopenid** - **facebook** - **google** - **oculus** - **twitch** - **android** - **ios** - **device** - **justice**: A user might have several &#39;justice’ platform on different namespaces. That’s why the platform_namespace need to be specified when the platform ID is ‘justice’. The platform_namespace is the designated user’s namespace. Unlink user&#39;s account with platform. &#39;justice&#39; platform might have multiple accounts from different namespaces linked. platform_namespace need to be specified when the platform ID is &#39;justice&#39;. Unlinking justice platform will enable password token grant and password update.
     */
    postUnlink_ByUserId_ByPlatformId,
    /**
     * Unlink user&#39;s account from third platform in all namespaces. Several platforms are grouped under account groups, you can use either platform ID or platform group as platformId path parameter. example: to unlink steam third party account, you can use steamnetwork / steam / steamopenid as platformId path parameter. **Supported Platforms:** - Steam group (steamnetwork): - steam - steamopenid - PSN group (psn): - ps4web - ps4 - ps5 - XBOX group(xbox): - live - xblweb - Oculus group (oculusgroup): - oculus - oculusweb - Google group (google): - google - googleplaygames: - epicgames - facebook - twitch - discord - android - ios - apple - device - nintendo - awscognito - amazon - netflix - snapchat - _oidc platform id_ Note: - You can use either platform id or platform group as **platformId** parameter. - **Nintendo platform user id**: NSA ID need to be appended with Environment ID using colon as separator. e.g kmzwa8awaa:dd1 Unlink platform account associated with a group: If user unlink platform account associated with a group, the API logic will unlink all of platform account under that group as well. example: if user unlink from ps4, the API logic will unlink ps5 and ps4web as well
     */
    deleteAllMeUser_ByPlatformId_v3,
    /**
     * @deprecated
     * ## The endpoint is going to be deprecated ### Endpoint migration guide - **Substitute endpoint: _/iam/v3/admin/namespaces/{namespace}/users/{userId}/permissions/{resource}/{action} [DELETE]_**
     */
    deletePermission_ByUserId_ByResource_ByAction,
    /**
     * @deprecated
     * ## The endpoint is going to be deprecated ### Endpoint migration guide - **Substitute endpoint: _/iam/v3/admin/namespaces/{namespace}/users/{userId}/permissions [POST]_** This endpoint will update existing permission (bitwise OR the action) if found one with same resource, otherwise it will append a new permission Schedule contains cron string or date range (both are UTC, also in cron syntax) to indicate when a permission and action are in effect. Both schedule types accepts quartz compatible cron syntax e.g. * * * * * * *. In ranged schedule, first element will be start date, and second one will be end date If schedule is set, the scheduled action must be valid too, that is between 1 to 15, inclusive Syntax reference Fields: 1. Seconds: 0-59 * / , - 2. Minutes: 0-59 * / , - 3. Hours: 0-23 * / , - 4. Day of month: 1-31 * / , - L W 5. Month: 1-12 JAN-DEC * / , - 6. Day of week: 0-6 SUN-SAT * / , - L # 7. Year: 1970-2099 * / , - Special characters: 1. *: all values in the fields, e.g. * in seconds fields indicates every second 2. /: increments of ranges, e.g. 3-59/15 in the minute field indicate the third minute of the hour and every 15 minutes thereafter 3. ,: separate items of a list, e.g. MON,WED,FRI in day of week 4. -: range, e.g. 2010-2018 indicates every year between 2010 and 2018, inclusive 5. L: last, e.g. When used in the day-of-week field, it allows you to specify constructs such as &#34;the last Friday&#34; (5L) of a given month. In the day-of-month field, it specifies the last day of the month. 6. W: business day, e.g. if you were to specify 15W as the value for the day-of-month field, the meaning is: &#34;the nearest business day to the 15th of the month.&#34; 7. #: must be followed by a number between one and five. It allows you to specify constructs such as &#34;the second Friday&#34; of a given month.
     */
    updatePermission_ByUserId_ByResource_ByAction,
    /**
     * Force linking user account with platform. If this platform account was already linked to another user account, this endpoint will perform force linking and remove platform from that conflict user, not only from the current request namespace but also include all the enrolled namespaces. If current user have linked to this platform with another platform account (include once linked but it is unlinked now), it will not allow user to perform linking. ## Supported platforms: - **steam**: The platform_token’s value is the binary ticket returned by Steam. - **steamopenid**: Steam&#39;s user authentication method using OpenID 2.0. The platform_token&#39;s value is URL generated by Steam on web authentication - **facebook**: The platform_token’s value is the authorization code returned by Facebook OAuth - **google**: The platform_token’s value is the authorization code returned by Google OAuth - **googleplaygames**: The platform_token’s value is the authorization code returned by Google play games OAuth - **oculus**: The platform_token’s value is a string composed of Oculus&#39;s user ID and the nonce separated by a colon (:). - **twitch**: The platform_token’s value is the authorization code returned by Twitch OAuth. - **discord**: The platform_token’s value is the authorization code returned by Discord OAuth - **android**: The device_id is the Android’s device ID - **ios**: The device_id is the iOS’s device ID. - **apple**: The platform_token’s value is the authorization code returned by Apple OAuth.(We will use this code to generate APP token) - **device**: Every device that does’nt run Android and iOS is categorized as a device. The device_id is the device’s ID. - **justice**: The platform_token’s value is the designated user’s access token. - **epicgames**: The platform_token’s value is an access-token obtained from Epicgames EOS Account Service. - **ps4**: The platform_token’s value is the authorization code returned by Sony OAuth. - **ps5**: The platform_token’s value is the authorization code returned by Sony OAuth. - **nintendo**: The platform_token’s value is the id_token returned by Nintendo OAuth. - **awscognito**: The platform_token’s value is the aws cognito access token or id token (JWT). - **live**: The platform_token’s value is xbox XSTS token - **xblweb**: The platform_token’s value is code returned by xbox after login - **netflix**: The platform_token’s value is GAT (Gamer Access Token) returned by Netflix backend - **snapchat**: The platform_token’s value is the authorization code returned by Snapchat OAuth. - **for specific generic oauth (OIDC)**: The platform_token’s value should be the same type as created OIDC auth type whether it is auth code, idToken or bearerToken.
     */
    postForceMeUser_ByPlatformId_v3,
    /**
     * @deprecated
     * ## The endpoint is going to be deprecated **Endpoint migration guide** - **Substitute endpoint: _/iam/v3/public/namespaces/{namespace}/agerestrictions/countries/{countryCode} [GET]_**
     */
    getAgerestrictions_ByCountryCode_v2,
    /**
     * Get age restriction by country code. It will always get by publisher namespace
     */
    getAgerestrictionCountry_ByCountryCode_v3,
    /**
     * @deprecated
     * ## The endpoint is going to be deprecated ### Endpoint migration guide - **Substitute endpoint: _/iam/v3/admin/namespaces/{namespace}/users/{userId}/platforms/justice/{targetNamespace} [GET]_** This endpoint requires the client access token as the bearer token This endpoint will support publisher access to game and game access to publisher If targetNamespace filled with publisher namespace then this endpoint will return its publisher user id and publisher namespace. If targetNamespace filled with game namespace then this endpoint will return its game user id and game namespace. **Will create game user id if not exists.**
     */
    getPlatformJustice_ByUserId_ByTargetNamespace,
    /**
     * @deprecated
     * ## The endpoint is going to be deprecated ### Endpoint migration guide - **Substitute endpoint: _/iam/v3/admin/namespaces/{namespace}/users/{userId}/platforms/justice/{targetNamespace} [GET]_** This endpoint requires the client access token as the bearer token The endpoint returns user Justice platform account linked with the given user. If the user Justice platform account doesn&#39;t exist in the designated namespace, the endpoint is going to *create and return the new Justice platform account.* The newly user Justice platform account is going to be forced to perform token grant through the given user and can&#39;t perform password update ### Read Justice Platform Account UserID Without permission the UserID is going to be censored and replaced with “Redacted” text.
     */
    updatePlatformJustice_ByUserId_ByTargetNamespace,
    /**
     * This endpoint is used to generate third party login page which will redirected to establish endpoint. Supported platforms: - ps4web - xblweb - steamopenid - epicgames - facebook - twitch - google - apple - snapchat - discord - amazon - oculusweb
     */
    getWebLinkMeUsers_ByPlatformId_v3,
    /**
     * @deprecated
     * ## The endpoint is going to be deprecated **Endpoint migration guide** - **Substitute endpoint: _/iam/v3/public/namespaces/{namespace}/users/me/platforms/{platformId} [DELETE]_** - **Substitute endpoint: _/iam/v3/public/namespaces/{namespace}/users/me/platforms/{platformId}/all [DELETE]_** ## Supported platforms: - **steam** - **steamopenid** - **facebook** - **google** - **oculus** - **twitch** - **android** - **ios** - **device** - **discord** Delete link of user&#39;s account with platform. &#39;justice&#39; platform might have multiple accounts from different namespaces linked. platform_namespace need to be specified when the platform ID is &#39;justice&#39;. Delete link of justice platform will enable password token grant and password update.
     */
    deleteLink_ByUserId_ByPlatformId_v2,
    /**
     * @deprecated
     * ## The endpoint is going to be deprecated **Endpoint migration guide** - **Substitute endpoint: _/iam/v3/public/namespaces/{namespace}/users/me/platforms/{platformId} [POST]_** **Prerequisite:** Platform client configuration need to be added to database for specific platformId. Namespace service URL need to be specified (refer to required environment variables). ## Supported platforms: - **steam**: The ticket’s value is the authentication code returned by Steam. - **steamopenid**: Steam&#39;s user authentication method using OpenID 2.0. The ticket&#39;s value is URL generated by Steam on web authentication - **facebook**: The ticket’s value is the authorization code returned by Facebook OAuth - **google**: The ticket’s value is the authorization code returned by Google OAuth - **oculus**: The ticket’s value is a string composed of Oculus&#39;s user ID and the nonce separated by a colon (:). - **twitch**: The ticket’s value is the authorization code returned by Twitch OAuth. - **android**: The ticket&#39;s value is the Android’s device ID - **ios**: The ticket&#39;s value is the iOS’s device ID. - **device**: Every device that doesn&#39;t run Android and iOS is categorized as a device platform. The ticket&#39;s value is the device’s ID. - **discord**: The ticket’s value is the authorization code returned by Discord OAuth.
     */
    postLink_ByUserId_ByPlatformId_v2,
    /**
     * Force update other account&#39;s Platform Account relation to current User Account. This endpoint can transfer progression from 3rd platform binding account&#39;s to current account. This endpoint need the same requestID which also used in [Get link status](#operations-Users-PublicGetAsyncStatus). **Authentication:** The _**userId**_ parameter should match the one in the access token.
     */
    createPlatformLinkWithProgression_ByUserId_v3,
    /**
     * Create Justice User from Publisher User information. It will check first if Justice User on target namespace already exist.
     */
    createUserMePlatformJustice_ByTargetNamespace_v3,
    /**
     * Get User By Platform User ID. This endpoint return user information by given platform ID and platform user ID. Several platforms are grouped under account groups, you can use either platform ID or platform group as platformId path parameter. example: for steam network platform, you can use steamnetwork / steam / steamopenid as platformId path parameter. **Supported Platforms:** - Steam group (steamnetwork): - steam - steamopenid - PSN group (psn): - ps4web - ps4 - ps5 - XBOX group(xbox): - live - xblweb - Oculus group (oculusgroup): - oculus - oculusweb - Google group (google): - google - googleplaygames: - epicgames - facebook - twitch - discord - android - ios - apple - device - nintendo - awscognito - amazon - netflix - snapchat - _oidc platform id_ Note: - You can use either platform id or platform group as **platformId** parameter. - **Nintendo platform user id**: NSA ID need to be appended with Environment ID using colon as separator. e.g kmzwa8awaa:dd1
     */
    getUser_ByPlatformId_ByPlatformUserId_v3,
    /**
     * @deprecated
     * ## The endpoint is going to be deprecated ### Endpoint migration guide - **Substitute endpoint: _/iam/v3/public/namespaces/{namespace}/users/me/headless/code/verify [POST]_** The endpoint upgrades a headless account by linking the headless account with the email address and the password. By upgrading the headless account into a full account, the user could use the email address and password for using Justice IAM. The endpoint is a shortcut for upgrading a headless account and verifying the email address in one call. In order to get a verification code for the endpoint, please check the send verification code endpoint.
     */
    updateUpgradeHeadlessAccountWithVerificationCode_ByUserId,
    /**
     * This endpoint is used to process third party account link, this endpoint will return the link status directly instead of redirecting to the original page. The param **state** comes from the response of &lt;code&gt;/users/me/platforms/{platformId}/web/link&lt;/code&gt; Supported platforms: - ps4web - xblweb - steamopenid - epicgames - facebook - twitch - google - apple - snapchat - discord - amazon - oculusweb
     */
    postWebLinkProcesMeUser_ByPlatformId_v3,
    /**
     * This endpoint is used by third party to redirect the code for the purpose of linking the account third party to IAM account. Supported platforms: - ps4web - xblweb - steamopenid - epicgames - facebook - twitch - google - apple - snapchat - discord - amazon - oculusweb
     */
    getWebLinkEstablishMeUsers_ByPlatformId_v3
  };
}

// src/generated-public/queries/Users.query.ts
var Key_Users = /* @__PURE__ */ ((Key_Users2) => {
  Key_Users2["UsersMe_v3"] = "Iam.Users.UsersMe_v3";
  Key_Users2["User"] = "Iam.Users.User";
  Key_Users2["UsersMeProfileStatus_v3"] = "Iam.Users.UsersMeProfileStatus_v3";
  Key_Users2["UsersAdmin"] = "Iam.Users.UsersAdmin";
  Key_Users2["UsersVerifyLinkVerify_v3"] = "Iam.Users.UsersVerifyLinkVerify_v3";
  Key_Users2["UsersSearch"] = "Iam.Users.UsersSearch";
  Key_Users2["User_ByUserId"] = "Iam.Users.User_ByUserId";
  Key_Users2["UsersByLoginId"] = "Iam.Users.UsersByLoginId";
  Key_Users2["User_v2"] = "Iam.Users.User_v2";
  Key_Users2["Users_v3"] = "Iam.Users.Users_v3";
  Key_Users2["User_v3"] = "Iam.Users.User_v3";
  Key_Users2["UserMeVerifyLinkRequest_v3"] = "Iam.Users.UserMeVerifyLinkRequest_v3";
  Key_Users2["Ban_ByUserId"] = "Iam.Users.Ban_ByUserId";
  Key_Users2["UserMe_v3"] = "Iam.Users.UserMe_v3";
  Key_Users2["UsersMeHeadlessLinkConflict_v3"] = "Iam.Users.UsersMeHeadlessLinkConflict_v3";
  Key_Users2["Bans_ByUserId"] = "Iam.Users.Bans_ByUserId";
  Key_Users2["UserResetPassword"] = "Iam.Users.UserResetPassword";
  Key_Users2["Role_ByUserId"] = "Iam.Users.Role_ByUserId";
  Key_Users2["UserForgotPassword"] = "Iam.Users.UserForgotPassword";
  Key_Users2["UsersListByLoginIds"] = "Iam.Users.UsersListByLoginIds";
  Key_Users2["Enable_ByUserId"] = "Iam.Users.Enable_ByUserId";
  Key_Users2["UserReset_v3"] = "Iam.Users.UserReset_v3";
  Key_Users2["Disable_ByUserId"] = "Iam.Users.Disable_ByUserId";
  Key_Users2["UsersByPlatformUserId"] = "Iam.Users.UsersByPlatformUserId";
  Key_Users2["UserForgot_v3"] = "Iam.Users.UserForgot_v3";
  Key_Users2["Password_ByUserId"] = "Iam.Users.Password_ByUserId";
  Key_Users2["Crosslink_ByUserId"] = "Iam.Users.Crosslink_ByUserId";
  Key_Users2["Platforms_ByUserId"] = "Iam.Users.Platforms_ByUserId";
  Key_Users2["Publisher_ByUserId"] = "Iam.Users.Publisher_ByUserId";
  Key_Users2["User_ByUserId_v2"] = "Iam.Users.User_ByUserId_v2";
  Key_Users2["User_ByUserId_v3"] = "Iam.Users.User_ByUserId_v3";
  Key_Users2["UserMeHeadlesLinkWithProgression_v3"] = "Iam.Users.UserMeHeadlesLinkWithProgression_v3";
  Key_Users2["UserPlatform_v3"] = "Iam.Users.UserPlatform_v3";
  Key_Users2["Information_ByUserId"] = "Iam.Users.Information_ByUserId";
  Key_Users2["Permission_ByUserId"] = "Iam.Users.Permission_ByUserId";
  Key_Users2["UserBulkBasic_v3"] = "Iam.Users.UserBulkBasic_v3";
  Key_Users2["Verification_ByUserId"] = "Iam.Users.Verification_ByUserId";
  Key_Users2["UserCodeVerify_v3"] = "Iam.Users.UserCodeVerify_v3";
  Key_Users2["UserMePassword_v3"] = "Iam.Users.UserMePassword_v3";
  Key_Users2["UsersAvailability_v3"] = "Iam.Users.UsersAvailability_v3";
  Key_Users2["UserCodeRequest_v3"] = "Iam.Users.UserCodeRequest_v3";
  Key_Users2["Role_ByUserId_ByRoleId"] = "Iam.Users.Role_ByUserId_ByRoleId";
  Key_Users2["Bans_ByUserId_v2"] = "Iam.Users.Bans_ByUserId_v2";
  Key_Users2["UserResetPassword_v2"] = "Iam.Users.UserResetPassword_v2";
  Key_Users2["Bans_ByUserId_v3"] = "Iam.Users.Bans_ByUserId_v3";
  Key_Users2["UserForgotPassword_v2"] = "Iam.Users.UserForgotPassword_v2";
  Key_Users2["UserMeCodeVerify_v3"] = "Iam.Users.UserMeCodeVerify_v3";
  Key_Users2["LoginsHistories_ByUserId"] = "Iam.Users.LoginsHistories_ByUserId";
  Key_Users2["Verificationcode_ByUserId"] = "Iam.Users.Verificationcode_ByUserId";
  Key_Users2["UserMeCodeRequest_v3"] = "Iam.Users.UserMeCodeRequest_v3";
  Key_Users2["UserInputValidation_v3"] = "Iam.Users.UserInputValidation_v3";
  Key_Users2["Password_ByUserId_v2"] = "Iam.Users.Password_ByUserId_v2";
  Key_Users2["Validate_ByUserId_v3"] = "Iam.Users.Validate_ByUserId_v3";
  Key_Users2["Enable_ByUserId_ByBanId"] = "Iam.Users.Enable_ByUserId_ByBanId";
  Key_Users2["Platforms_ByUserId_v3"] = "Iam.Users.Platforms_ByUserId_v3";
  Key_Users2["Publisher_ByUserId_v3"] = "Iam.Users.Publisher_ByUserId_v3";
  Key_Users2["UserMeHeadlesVerify_v3"] = "Iam.Users.UserMeHeadlesVerify_v3";
  Key_Users2["Disable_ByUserId_ByBanId"] = "Iam.Users.Disable_ByUserId_ByBanId";
  Key_Users2["Information_ByUserId_v3"] = "Iam.Users.Information_ByUserId_v3";
  Key_Users2["UpgradeHeadlessAccount_ByUserId"] = "Iam.Users.UpgradeHeadlessAccount_ByUserId";
  Key_Users2["UserInvite_ByInvitationId_v3"] = "Iam.Users.UserInvite_ByInvitationId_v3";
  Key_Users2["User_ByPlatformId_v3"] = "Iam.Users.User_ByPlatformId_v3";
  Key_Users2["PlatformLink_ByUserId_v3"] = "Iam.Users.PlatformLink_ByUserId_v3";
  Key_Users2["UserMeHeadlesCodeVerify_v3"] = "Iam.Users.UserMeHeadlesCodeVerify_v3";
  Key_Users2["LoginsHistories_ByUserId_v3"] = "Iam.Users.LoginsHistories_ByUserId_v3";
  Key_Users2["UserMePlatform_ByPlatformId_v3"] = "Iam.Users.UserMePlatform_ByPlatformId_v3";
  Key_Users2["Link_ByUserId_ByPlatformId"] = "Iam.Users.Link_ByUserId_ByPlatformId";
  Key_Users2["PlatformsJustice_ByUserId_v2"] = "Iam.Users.PlatformsJustice_ByUserId_v2";
  Key_Users2["DistinctPlatforms_ByUserId_v3"] = "Iam.Users.DistinctPlatforms_ByUserId_v3";
  Key_Users2["PlatformsJustice_ByUserId_v3"] = "Iam.Users.PlatformsJustice_ByUserId_v3";
  Key_Users2["AsyncStatus_ByRequestId_v3"] = "Iam.Users.AsyncStatus_ByRequestId_v3";
  Key_Users2["Unlink_ByUserId_ByPlatformId"] = "Iam.Users.Unlink_ByUserId_ByPlatformId";
  Key_Users2["AllMeUser_ByPlatformId_v3"] = "Iam.Users.AllMeUser_ByPlatformId_v3";
  Key_Users2["Permission_ByUserId_ByResource_ByAction"] = "Iam.Users.Permission_ByUserId_ByResource_ByAction";
  Key_Users2["ForceMeUser_ByPlatformId_v3"] = "Iam.Users.ForceMeUser_ByPlatformId_v3";
  Key_Users2["Agerestrictions_ByCountryCode_v2"] = "Iam.Users.Agerestrictions_ByCountryCode_v2";
  Key_Users2["AgerestrictionCountry_ByCountryCode_v3"] = "Iam.Users.AgerestrictionCountry_ByCountryCode_v3";
  Key_Users2["PlatformJustice_ByUserId_ByTargetNamespace"] = "Iam.Users.PlatformJustice_ByUserId_ByTargetNamespace";
  Key_Users2["WebLinkMeUsers_ByPlatformId_v3"] = "Iam.Users.WebLinkMeUsers_ByPlatformId_v3";
  Key_Users2["Link_ByUserId_ByPlatformId_v2"] = "Iam.Users.Link_ByUserId_ByPlatformId_v2";
  Key_Users2["PlatformLinkWithProgression_ByUserId_v3"] = "Iam.Users.PlatformLinkWithProgression_ByUserId_v3";
  Key_Users2["UserMePlatformJustice_ByTargetNamespace_v3"] = "Iam.Users.UserMePlatformJustice_ByTargetNamespace_v3";
  Key_Users2["User_ByPlatformId_ByPlatformUserId_v3"] = "Iam.Users.User_ByPlatformId_ByPlatformUserId_v3";
  Key_Users2["UpgradeHeadlessAccountWithVerificationCode_ByUserId"] = "Iam.Users.UpgradeHeadlessAccountWithVerificationCode_ByUserId";
  Key_Users2["WebLinkProcesMeUser_ByPlatformId_v3"] = "Iam.Users.WebLinkProcesMeUser_ByPlatformId_v3";
  Key_Users2["WebLinkEstablishMeUsers_ByPlatformId_v3"] = "Iam.Users.WebLinkEstablishMeUsers_ByPlatformId_v3";
  return Key_Users2;
})(Key_Users || {});
var useUsersApi_GetUsersMe_v3 = (sdk, input, options, callback) => {
  const queryFn = (sdk2, input2) => async () => {
    const response = await UsersApi(sdk2, { coreConfig: input2.coreConfig, axiosConfig: input2.axiosConfig }).getUsersMe_v3(input2.queryParams);
    callback && callback(response);
    return response.data;
  };
  return (0, import_react_query31.useQuery)({
    queryKey: ["Iam.Users.UsersMe_v3" /* UsersMe_v3 */, input],
    queryFn: queryFn(sdk, input),
    ...options
  });
};
var useUsersApi_CreateUserMutation = (sdk, options, callback) => {
  const mutationFn = async (input) => {
    const response = await UsersApi(sdk, { coreConfig: input.coreConfig, axiosConfig: input.axiosConfig }).createUser(input.data);
    callback && callback(response.data);
    return response.data;
  };
  return (0, import_react_query31.useMutation)({
    mutationKey: ["Iam.Users.User" /* User */],
    mutationFn,
    ...options
  });
};
var useUsersApi_GetUsersMeProfileStatus_v3 = (sdk, input, options, callback) => {
  const queryFn = (sdk2, input2) => async () => {
    const response = await UsersApi(sdk2, { coreConfig: input2.coreConfig, axiosConfig: input2.axiosConfig }).getUsersMeProfileStatus_v3();
    callback && callback(response);
    return response.data;
  };
  return (0, import_react_query31.useQuery)({
    queryKey: ["Iam.Users.UsersMeProfileStatus_v3" /* UsersMeProfileStatus_v3 */, input],
    queryFn: queryFn(sdk, input),
    ...options
  });
};
var useUsersApi_GetUsersAdmin = (sdk, input, options, callback) => {
  const queryFn = (sdk2, input2) => async () => {
    const response = await UsersApi(sdk2, { coreConfig: input2.coreConfig, axiosConfig: input2.axiosConfig }).getUsersAdmin(input2.queryParams);
    callback && callback(response);
    return response.data;
  };
  return (0, import_react_query31.useQuery)({
    queryKey: ["Iam.Users.UsersAdmin" /* UsersAdmin */, input],
    queryFn: queryFn(sdk, input),
    ...options
  });
};
var useUsersApi_GetUsersVerifyLinkVerify_v3 = (sdk, input, options, callback) => {
  const queryFn = (sdk2, input2) => async () => {
    const response = await UsersApi(sdk2, { coreConfig: input2.coreConfig, axiosConfig: input2.axiosConfig }).getUsersVerifyLinkVerify_v3(
      input2.queryParams
    );
    callback && callback(response);
    return response.data;
  };
  return (0, import_react_query31.useQuery)({
    queryKey: ["Iam.Users.UsersVerifyLinkVerify_v3" /* UsersVerifyLinkVerify_v3 */, input],
    queryFn: queryFn(sdk, input),
    ...options
  });
};
var useUsersApi_GetUsersSearch = (sdk, input, options, callback) => {
  const queryFn = (sdk2, input2) => async () => {
    const response = await UsersApi(sdk2, { coreConfig: input2.coreConfig, axiosConfig: input2.axiosConfig }).getUsersSearch(input2.queryParams);
    callback && callback(response);
    return response.data;
  };
  return (0, import_react_query31.useQuery)({
    queryKey: ["Iam.Users.UsersSearch" /* UsersSearch */, input],
    queryFn: queryFn(sdk, input),
    ...options
  });
};
var useUsersApi_DeleteUser_ByUserIdMutation = (sdk, options, callback) => {
  const mutationFn = async (input) => {
    const response = await UsersApi(sdk, { coreConfig: input.coreConfig, axiosConfig: input.axiosConfig }).deleteUser_ByUserId(input.userId);
    callback && callback(response.data);
    return response.data;
  };
  return (0, import_react_query31.useMutation)({
    mutationKey: ["Iam.Users.User_ByUserId" /* User_ByUserId */],
    mutationFn,
    ...options
  });
};
var useUsersApi_GetUser_ByUserId = (sdk, input, options, callback) => {
  const queryFn = (sdk2, input2) => async () => {
    const response = await UsersApi(sdk2, { coreConfig: input2.coreConfig, axiosConfig: input2.axiosConfig }).getUser_ByUserId(input2.userId);
    callback && callback(response);
    return response.data;
  };
  return (0, import_react_query31.useQuery)({
    queryKey: ["Iam.Users.User_ByUserId" /* User_ByUserId */, input],
    queryFn: queryFn(sdk, input),
    ...options
  });
};
var useUsersApi_UpdateUser_ByUserIdMutation = (sdk, options, callback) => {
  const mutationFn = async (input) => {
    const response = await UsersApi(sdk, { coreConfig: input.coreConfig, axiosConfig: input.axiosConfig }).updateUser_ByUserId(
      input.userId,
      input.data
    );
    callback && callback(response.data);
    return response.data;
  };
  return (0, import_react_query31.useMutation)({
    mutationKey: ["Iam.Users.User_ByUserId" /* User_ByUserId */],
    mutationFn,
    ...options
  });
};
var useUsersApi_GetUsersByLoginId = (sdk, input, options, callback) => {
  const queryFn = (sdk2, input2) => async () => {
    const response = await UsersApi(sdk2, { coreConfig: input2.coreConfig, axiosConfig: input2.axiosConfig }).getUsersByLoginId(
      input2.queryParams
    );
    callback && callback(response);
    return response.data;
  };
  return (0, import_react_query31.useQuery)({
    queryKey: ["Iam.Users.UsersByLoginId" /* UsersByLoginId */, input],
    queryFn: queryFn(sdk, input),
    ...options
  });
};
var useUsersApi_CreateUserMutation_v2 = (sdk, options, callback) => {
  const mutationFn = async (input) => {
    const response = await UsersApi(sdk, { coreConfig: input.coreConfig, axiosConfig: input.axiosConfig }).createUser_v2(input.data);
    callback && callback(response.data);
    return response.data;
  };
  return (0, import_react_query31.useMutation)({
    mutationKey: ["Iam.Users.User_v2" /* User_v2 */],
    mutationFn,
    ...options
  });
};
var useUsersApi_GetUsers_v3 = (sdk, input, options, callback) => {
  const queryFn = (sdk2, input2) => async () => {
    const response = await UsersApi(sdk2, { coreConfig: input2.coreConfig, axiosConfig: input2.axiosConfig }).getUsers_v3(input2.queryParams);
    callback && callback(response);
    return response.data;
  };
  return (0, import_react_query31.useQuery)({
    queryKey: ["Iam.Users.Users_v3" /* Users_v3 */, input],
    queryFn: queryFn(sdk, input),
    ...options
  });
};
var useUsersApi_CreateUserMutation_v3 = (sdk, options, callback) => {
  const mutationFn = async (input) => {
    const response = await UsersApi(sdk, { coreConfig: input.coreConfig, axiosConfig: input.axiosConfig }).createUser_v3(input.data);
    callback && callback(response.data);
    return response.data;
  };
  return (0, import_react_query31.useMutation)({
    mutationKey: ["Iam.Users.User_v3" /* User_v3 */],
    mutationFn,
    ...options
  });
};
var useUsersApi_CreateUserMeVerifyLinkRequestMutation_v3 = (sdk, options, callback) => {
  const mutationFn = async (input) => {
    const response = await UsersApi(sdk, { coreConfig: input.coreConfig, axiosConfig: input.axiosConfig }).createUserMeVerifyLinkRequest_v3(
      input.data
    );
    callback && callback(response.data);
    return response.data;
  };
  return (0, import_react_query31.useMutation)({
    mutationKey: ["Iam.Users.UserMeVerifyLinkRequest_v3" /* UserMeVerifyLinkRequest_v3 */],
    mutationFn,
    ...options
  });
};
var useUsersApi_CreateBan_ByUserIdMutation = (sdk, options, callback) => {
  const mutationFn = async (input) => {
    const response = await UsersApi(sdk, { coreConfig: input.coreConfig, axiosConfig: input.axiosConfig }).createBan_ByUserId(
      input.userId,
      input.data
    );
    callback && callback(response.data);
    return response.data;
  };
  return (0, import_react_query31.useMutation)({
    mutationKey: ["Iam.Users.Ban_ByUserId" /* Ban_ByUserId */],
    mutationFn,
    ...options
  });
};
var useUsersApi_PatchUserMeMutation_v3 = (sdk, options, callback) => {
  const mutationFn = async (input) => {
    const response = await UsersApi(sdk, { coreConfig: input.coreConfig, axiosConfig: input.axiosConfig }).patchUserMe_v3(input.data);
    callback && callback(response.data);
    return response.data;
  };
  return (0, import_react_query31.useMutation)({
    mutationKey: ["Iam.Users.UserMe_v3" /* UserMe_v3 */],
    mutationFn,
    ...options
  });
};
var useUsersApi_UpdateUserMeMutation_v3 = (sdk, options, callback) => {
  const mutationFn = async (input) => {
    const response = await UsersApi(sdk, { coreConfig: input.coreConfig, axiosConfig: input.axiosConfig }).updateUserMe_v3(input.data);
    callback && callback(response.data);
    return response.data;
  };
  return (0, import_react_query31.useMutation)({
    mutationKey: ["Iam.Users.UserMe_v3" /* UserMe_v3 */],
    mutationFn,
    ...options
  });
};
var useUsersApi_GetUsersMeHeadlessLinkConflict_v3 = (sdk, input, options, callback) => {
  const queryFn = (sdk2, input2) => async () => {
    const response = await UsersApi(sdk2, {
      coreConfig: input2.coreConfig,
      axiosConfig: input2.axiosConfig
    }).getUsersMeHeadlessLinkConflict_v3(input2.queryParams);
    callback && callback(response);
    return response.data;
  };
  return (0, import_react_query31.useQuery)({
    queryKey: ["Iam.Users.UsersMeHeadlessLinkConflict_v3" /* UsersMeHeadlessLinkConflict_v3 */, input],
    queryFn: queryFn(sdk, input),
    ...options
  });
};
var useUsersApi_GetBans_ByUserId = (sdk, input, options, callback) => {
  const queryFn = (sdk2, input2) => async () => {
    const response = await UsersApi(sdk2, { coreConfig: input2.coreConfig, axiosConfig: input2.axiosConfig }).getBans_ByUserId(input2.userId);
    callback && callback(response);
    return response.data;
  };
  return (0, import_react_query31.useQuery)({
    queryKey: ["Iam.Users.Bans_ByUserId" /* Bans_ByUserId */, input],
    queryFn: queryFn(sdk, input),
    ...options
  });
};
var useUsersApi_CreateUserResetPasswordMutation = (sdk, options, callback) => {
  const mutationFn = async (input) => {
    const response = await UsersApi(sdk, { coreConfig: input.coreConfig, axiosConfig: input.axiosConfig }).createUserResetPassword(
      input.data
    );
    callback && callback(response.data);
    return response.data;
  };
  return (0, import_react_query31.useMutation)({
    mutationKey: ["Iam.Users.UserResetPassword" /* UserResetPassword */],
    mutationFn,
    ...options
  });
};
var useUsersApi_UpdateRole_ByUserIdMutation = (sdk, options, callback) => {
  const mutationFn = async (input) => {
    const response = await UsersApi(sdk, { coreConfig: input.coreConfig, axiosConfig: input.axiosConfig }).updateRole_ByUserId(
      input.userId,
      input.data
    );
    callback && callback(response.data);
    return response.data;
  };
  return (0, import_react_query31.useMutation)({
    mutationKey: ["Iam.Users.Role_ByUserId" /* Role_ByUserId */],
    mutationFn,
    ...options
  });
};
var useUsersApi_CreateUserForgotPasswordMutation = (sdk, options, callback) => {
  const mutationFn = async (input) => {
    const response = await UsersApi(sdk, { coreConfig: input.coreConfig, axiosConfig: input.axiosConfig }).createUserForgotPassword(
      input.data
    );
    callback && callback(response.data);
    return response.data;
  };
  return (0, import_react_query31.useMutation)({
    mutationKey: ["Iam.Users.UserForgotPassword" /* UserForgotPassword */],
    mutationFn,
    ...options
  });
};
var useUsersApi_GetUsersListByLoginIds = (sdk, input, options, callback) => {
  const queryFn = (sdk2, input2) => async () => {
    const response = await UsersApi(sdk2, { coreConfig: input2.coreConfig, axiosConfig: input2.axiosConfig }).getUsersListByLoginIds(
      input2.queryParams
    );
    callback && callback(response);
    return response.data;
  };
  return (0, import_react_query31.useQuery)({
    queryKey: ["Iam.Users.UsersListByLoginIds" /* UsersListByLoginIds */, input],
    queryFn: queryFn(sdk, input),
    ...options
  });
};
var useUsersApi_UpdateEnable_ByUserIdMutation = (sdk, options, callback) => {
  const mutationFn = async (input) => {
    const response = await UsersApi(sdk, { coreConfig: input.coreConfig, axiosConfig: input.axiosConfig }).updateEnable_ByUserId(
      input.userId
    );
    callback && callback(response.data);
    return response.data;
  };
  return (0, import_react_query31.useMutation)({
    mutationKey: ["Iam.Users.Enable_ByUserId" /* Enable_ByUserId */],
    mutationFn,
    ...options
  });
};
var useUsersApi_CreateUserResetMutation_v3 = (sdk, options, callback) => {
  const mutationFn = async (input) => {
    const response = await UsersApi(sdk, { coreConfig: input.coreConfig, axiosConfig: input.axiosConfig }).createUserReset_v3(input.data);
    callback && callback(response.data);
    return response.data;
  };
  return (0, import_react_query31.useMutation)({
    mutationKey: ["Iam.Users.UserReset_v3" /* UserReset_v3 */],
    mutationFn,
    ...options
  });
};
var useUsersApi_UpdateDisable_ByUserIdMutation = (sdk, options, callback) => {
  const mutationFn = async (input) => {
    const response = await UsersApi(sdk, { coreConfig: input.coreConfig, axiosConfig: input.axiosConfig }).updateDisable_ByUserId(
      input.userId,
      input.data
    );
    callback && callback(response.data);
    return response.data;
  };
  return (0, import_react_query31.useMutation)({
    mutationKey: ["Iam.Users.Disable_ByUserId" /* Disable_ByUserId */],
    mutationFn,
    ...options
  });
};
var useUsersApi_GetUsersByPlatformUserId = (sdk, input, options, callback) => {
  const queryFn = (sdk2, input2) => async () => {
    const response = await UsersApi(sdk2, { coreConfig: input2.coreConfig, axiosConfig: input2.axiosConfig }).getUsersByPlatformUserId(
      input2.queryParams
    );
    callback && callback(response);
    return response.data;
  };
  return (0, import_react_query31.useQuery)({
    queryKey: ["Iam.Users.UsersByPlatformUserId" /* UsersByPlatformUserId */, input],
    queryFn: queryFn(sdk, input),
    ...options
  });
};
var useUsersApi_CreateUserForgotMutation_v3 = (sdk, options, callback) => {
  const mutationFn = async (input) => {
    const response = await UsersApi(sdk, { coreConfig: input.coreConfig, axiosConfig: input.axiosConfig }).createUserForgot_v3(input.data);
    callback && callback(response.data);
    return response.data;
  };
  return (0, import_react_query31.useMutation)({
    mutationKey: ["Iam.Users.UserForgot_v3" /* UserForgot_v3 */],
    mutationFn,
    ...options
  });
};
var useUsersApi_UpdatePassword_ByUserIdMutation = (sdk, options, callback) => {
  const mutationFn = async (input) => {
    const response = await UsersApi(sdk, { coreConfig: input.coreConfig, axiosConfig: input.axiosConfig }).updatePassword_ByUserId(
      input.userId,
      input.data
    );
    callback && callback(response.data);
    return response.data;
  };
  return (0, import_react_query31.useMutation)({
    mutationKey: ["Iam.Users.Password_ByUserId" /* Password_ByUserId */],
    mutationFn,
    ...options
  });
};
var useUsersApi_PostCrosslink_ByUserIdMutation = (sdk, options, callback) => {
  const mutationFn = async (input) => {
    const response = await UsersApi(sdk, { coreConfig: input.coreConfig, axiosConfig: input.axiosConfig }).postCrosslink_ByUserId(
      input.userId,
      input.data
    );
    callback && callback(response.data);
    return response.data;
  };
  return (0, import_react_query31.useMutation)({
    mutationKey: ["Iam.Users.Crosslink_ByUserId" /* Crosslink_ByUserId */],
    mutationFn,
    ...options
  });
};
var useUsersApi_GetPlatforms_ByUserId = (sdk, input, options, callback) => {
  const queryFn = (sdk2, input2) => async () => {
    const response = await UsersApi(sdk2, { coreConfig: input2.coreConfig, axiosConfig: input2.axiosConfig }).getPlatforms_ByUserId(
      input2.userId
    );
    callback && callback(response);
    return response.data;
  };
  return (0, import_react_query31.useQuery)({
    queryKey: ["Iam.Users.Platforms_ByUserId" /* Platforms_ByUserId */, input],
    queryFn: queryFn(sdk, input),
    ...options
  });
};
var useUsersApi_GetPublisher_ByUserId = (sdk, input, options, callback) => {
  const queryFn = (sdk2, input2) => async () => {
    const response = await UsersApi(sdk2, { coreConfig: input2.coreConfig, axiosConfig: input2.axiosConfig }).getPublisher_ByUserId(
      input2.userId
    );
    callback && callback(response);
    return response.data;
  };
  return (0, import_react_query31.useQuery)({
    queryKey: ["Iam.Users.Publisher_ByUserId" /* Publisher_ByUserId */, input],
    queryFn: queryFn(sdk, input),
    ...options
  });
};
var useUsersApi_GetUser_ByUserId_v2 = (sdk, input, options, callback) => {
  const queryFn = (sdk2, input2) => async () => {
    const response = await UsersApi(sdk2, { coreConfig: input2.coreConfig, axiosConfig: input2.axiosConfig }).getUser_ByUserId_v2(input2.userId);
    callback && callback(response);
    return response.data;
  };
  return (0, import_react_query31.useQuery)({
    queryKey: ["Iam.Users.User_ByUserId_v2" /* User_ByUserId_v2 */, input],
    queryFn: queryFn(sdk, input),
    ...options
  });
};
var useUsersApi_PatchUser_ByUserIdMutation_v2 = (sdk, options, callback) => {
  const mutationFn = async (input) => {
    const response = await UsersApi(sdk, { coreConfig: input.coreConfig, axiosConfig: input.axiosConfig }).patchUser_ByUserId_v2(
      input.userId,
      input.data
    );
    callback && callback(response.data);
    return response.data;
  };
  return (0, import_react_query31.useMutation)({
    mutationKey: ["Iam.Users.User_ByUserId_v2" /* User_ByUserId_v2 */],
    mutationFn,
    ...options
  });
};
var useUsersApi_GetUser_ByUserId_v3 = (sdk, input, options, callback) => {
  const queryFn = (sdk2, input2) => async () => {
    const response = await UsersApi(sdk2, { coreConfig: input2.coreConfig, axiosConfig: input2.axiosConfig }).getUser_ByUserId_v3(input2.userId);
    callback && callback(response);
    return response.data;
  };
  return (0, import_react_query31.useQuery)({
    queryKey: ["Iam.Users.User_ByUserId_v3" /* User_ByUserId_v3 */, input],
    queryFn: queryFn(sdk, input),
    ...options
  });
};
var useUsersApi_CreateUserMeHeadlesLinkWithProgressionMutation_v3 = (sdk, options, callback) => {
  const mutationFn = async (input) => {
    const response = await UsersApi(sdk, {
      coreConfig: input.coreConfig,
      axiosConfig: input.axiosConfig
    }).createUserMeHeadlesLinkWithProgression_v3(input.data);
    callback && callback(response.data);
    return response.data;
  };
  return (0, import_react_query31.useMutation)({
    mutationKey: ["Iam.Users.UserMeHeadlesLinkWithProgression_v3" /* UserMeHeadlesLinkWithProgression_v3 */],
    mutationFn,
    ...options
  });
};
var useUsersApi_CreateUserPlatformMutation_v3 = (sdk, options, callback) => {
  const mutationFn = async (input) => {
    const response = await UsersApi(sdk, { coreConfig: input.coreConfig, axiosConfig: input.axiosConfig }).createUserPlatform_v3(input.data);
    callback && callback(response.data);
    return response.data;
  };
  return (0, import_react_query31.useMutation)({
    mutationKey: ["Iam.Users.UserPlatform_v3" /* UserPlatform_v3 */],
    mutationFn,
    ...options
  });
};
var useUsersApi_DeleteInformation_ByUserIdMutation = (sdk, options, callback) => {
  const mutationFn = async (input) => {
    const response = await UsersApi(sdk, { coreConfig: input.coreConfig, axiosConfig: input.axiosConfig }).deleteInformation_ByUserId(
      input.userId
    );
    callback && callback(response.data);
    return response.data;
  };
  return (0, import_react_query31.useMutation)({
    mutationKey: ["Iam.Users.Information_ByUserId" /* Information_ByUserId */],
    mutationFn,
    ...options
  });
};
var useUsersApi_GetInformation_ByUserId = (sdk, input, options, callback) => {
  const queryFn = (sdk2, input2) => async () => {
    const response = await UsersApi(sdk2, { coreConfig: input2.coreConfig, axiosConfig: input2.axiosConfig }).getInformation_ByUserId(
      input2.userId
    );
    callback && callback(response);
    return response.data;
  };
  return (0, import_react_query31.useQuery)({
    queryKey: ["Iam.Users.Information_ByUserId" /* Information_ByUserId */, input],
    queryFn: queryFn(sdk, input),
    ...options
  });
};
var useUsersApi_UpdatePermission_ByUserIdMutation = (sdk, options, callback) => {
  const mutationFn = async (input) => {
    const response = await UsersApi(sdk, { coreConfig: input.coreConfig, axiosConfig: input.axiosConfig }).updatePermission_ByUserId(
      input.userId,
      input.data
    );
    callback && callback(response.data);
    return response.data;
  };
  return (0, import_react_query31.useMutation)({
    mutationKey: ["Iam.Users.Permission_ByUserId" /* Permission_ByUserId */],
    mutationFn,
    ...options
  });
};
var useUsersApi_CreateUserBulkBasicMutation_v3 = (sdk, options, callback) => {
  const mutationFn = async (input) => {
    const response = await UsersApi(sdk, { coreConfig: input.coreConfig, axiosConfig: input.axiosConfig }).createUserBulkBasic_v3(
      input.data
    );
    callback && callback(response.data);
    return response.data;
  };
  return (0, import_react_query31.useMutation)({
    mutationKey: ["Iam.Users.UserBulkBasic_v3" /* UserBulkBasic_v3 */],
    mutationFn,
    ...options
  });
};
var useUsersApi_UpdateVerification_ByUserIdMutation = (sdk, options, callback) => {
  const mutationFn = async (input) => {
    const response = await UsersApi(sdk, { coreConfig: input.coreConfig, axiosConfig: input.axiosConfig }).updateVerification_ByUserId(
      input.userId,
      input.data
    );
    callback && callback(response.data);
    return response.data;
  };
  return (0, import_react_query31.useMutation)({
    mutationKey: ["Iam.Users.Verification_ByUserId" /* Verification_ByUserId */],
    mutationFn,
    ...options
  });
};
var useUsersApi_CreateUserCodeVerifyMutation_v3 = (sdk, options, callback) => {
  const mutationFn = async (input) => {
    const response = await UsersApi(sdk, { coreConfig: input.coreConfig, axiosConfig: input.axiosConfig }).createUserCodeVerify_v3(
      input.data
    );
    callback && callback(response.data);
    return response.data;
  };
  return (0, import_react_query31.useMutation)({
    mutationKey: ["Iam.Users.UserCodeVerify_v3" /* UserCodeVerify_v3 */],
    mutationFn,
    ...options
  });
};
var useUsersApi_UpdateUserMePasswordMutation_v3 = (sdk, options, callback) => {
  const mutationFn = async (input) => {
    const response = await UsersApi(sdk, { coreConfig: input.coreConfig, axiosConfig: input.axiosConfig }).updateUserMePassword_v3(
      input.data
    );
    callback && callback(response.data);
    return response.data;
  };
  return (0, import_react_query31.useMutation)({
    mutationKey: ["Iam.Users.UserMePassword_v3" /* UserMePassword_v3 */],
    mutationFn,
    ...options
  });
};
var useUsersApi_GetUsersAvailability_v3 = (sdk, input, options, callback) => {
  const queryFn = (sdk2, input2) => async () => {
    const response = await UsersApi(sdk2, { coreConfig: input2.coreConfig, axiosConfig: input2.axiosConfig }).getUsersAvailability_v3(
      input2.queryParams
    );
    callback && callback(response);
    return response.data;
  };
  return (0, import_react_query31.useQuery)({
    queryKey: ["Iam.Users.UsersAvailability_v3" /* UsersAvailability_v3 */, input],
    queryFn: queryFn(sdk, input),
    ...options
  });
};
var useUsersApi_CreateUserCodeRequestMutation_v3 = (sdk, options, callback) => {
  const mutationFn = async (input) => {
    const response = await UsersApi(sdk, { coreConfig: input.coreConfig, axiosConfig: input.axiosConfig }).createUserCodeRequest_v3(
      input.data
    );
    callback && callback(response.data);
    return response.data;
  };
  return (0, import_react_query31.useMutation)({
    mutationKey: ["Iam.Users.UserCodeRequest_v3" /* UserCodeRequest_v3 */],
    mutationFn,
    ...options
  });
};
var useUsersApi_DeleteRole_ByUserId_ByRoleIdMutation = (sdk, options, callback) => {
  const mutationFn = async (input) => {
    const response = await UsersApi(sdk, { coreConfig: input.coreConfig, axiosConfig: input.axiosConfig }).deleteRole_ByUserId_ByRoleId(
      input.userId,
      input.roleId
    );
    callback && callback(response.data);
    return response.data;
  };
  return (0, import_react_query31.useMutation)({
    mutationKey: ["Iam.Users.Role_ByUserId_ByRoleId" /* Role_ByUserId_ByRoleId */],
    mutationFn,
    ...options
  });
};
var useUsersApi_UpdateRole_ByUserId_ByRoleIdMutation = (sdk, options, callback) => {
  const mutationFn = async (input) => {
    const response = await UsersApi(sdk, { coreConfig: input.coreConfig, axiosConfig: input.axiosConfig }).updateRole_ByUserId_ByRoleId(
      input.userId,
      input.roleId
    );
    callback && callback(response.data);
    return response.data;
  };
  return (0, import_react_query31.useMutation)({
    mutationKey: ["Iam.Users.Role_ByUserId_ByRoleId" /* Role_ByUserId_ByRoleId */],
    mutationFn,
    ...options
  });
};
var useUsersApi_GetBans_ByUserId_v2 = (sdk, input, options, callback) => {
  const queryFn = (sdk2, input2) => async () => {
    const response = await UsersApi(sdk2, { coreConfig: input2.coreConfig, axiosConfig: input2.axiosConfig }).getBans_ByUserId_v2(
      input2.userId,
      input2.queryParams
    );
    callback && callback(response);
    return response.data;
  };
  return (0, import_react_query31.useQuery)({
    queryKey: ["Iam.Users.Bans_ByUserId_v2" /* Bans_ByUserId_v2 */, input],
    queryFn: queryFn(sdk, input),
    ...options
  });
};
var useUsersApi_CreateUserResetPasswordMutation_v2 = (sdk, options, callback) => {
  const mutationFn = async (input) => {
    const response = await UsersApi(sdk, { coreConfig: input.coreConfig, axiosConfig: input.axiosConfig }).createUserResetPassword_v2(
      input.data
    );
    callback && callback(response.data);
    return response.data;
  };
  return (0, import_react_query31.useMutation)({
    mutationKey: ["Iam.Users.UserResetPassword_v2" /* UserResetPassword_v2 */],
    mutationFn,
    ...options
  });
};
var useUsersApi_GetBans_ByUserId_v3 = (sdk, input, options, callback) => {
  const queryFn = (sdk2, input2) => async () => {
    const response = await UsersApi(sdk2, { coreConfig: input2.coreConfig, axiosConfig: input2.axiosConfig }).getBans_ByUserId_v3(
      input2.userId,
      input2.queryParams
    );
    callback && callback(response);
    return response.data;
  };
  return (0, import_react_query31.useQuery)({
    queryKey: ["Iam.Users.Bans_ByUserId_v3" /* Bans_ByUserId_v3 */, input],
    queryFn: queryFn(sdk, input),
    ...options
  });
};
var useUsersApi_CreateUserForgotPasswordMutation_v2 = (sdk, options, callback) => {
  const mutationFn = async (input) => {
    const response = await UsersApi(sdk, { coreConfig: input.coreConfig, axiosConfig: input.axiosConfig }).createUserForgotPassword_v2(
      input.data
    );
    callback && callback(response.data);
    return response.data;
  };
  return (0, import_react_query31.useMutation)({
    mutationKey: ["Iam.Users.UserForgotPassword_v2" /* UserForgotPassword_v2 */],
    mutationFn,
    ...options
  });
};
var useUsersApi_CreateUserMeCodeVerifyMutation_v3 = (sdk, options, callback) => {
  const mutationFn = async (input) => {
    const response = await UsersApi(sdk, { coreConfig: input.coreConfig, axiosConfig: input.axiosConfig }).createUserMeCodeVerify_v3(
      input.data
    );
    callback && callback(response.data);
    return response.data;
  };
  return (0, import_react_query31.useMutation)({
    mutationKey: ["Iam.Users.UserMeCodeVerify_v3" /* UserMeCodeVerify_v3 */],
    mutationFn,
    ...options
  });
};
var useUsersApi_GetLoginsHistories_ByUserId = (sdk, input, options, callback) => {
  const queryFn = (sdk2, input2) => async () => {
    const response = await UsersApi(sdk2, { coreConfig: input2.coreConfig, axiosConfig: input2.axiosConfig }).getLoginsHistories_ByUserId(
      input2.userId,
      input2.queryParams
    );
    callback && callback(response);
    return response.data;
  };
  return (0, import_react_query31.useQuery)({
    queryKey: ["Iam.Users.LoginsHistories_ByUserId" /* LoginsHistories_ByUserId */, input],
    queryFn: queryFn(sdk, input),
    ...options
  });
};
var useUsersApi_UpdateVerificationcode_ByUserIdMutation = (sdk, options, callback) => {
  const mutationFn = async (input) => {
    const response = await UsersApi(sdk, { coreConfig: input.coreConfig, axiosConfig: input.axiosConfig }).updateVerificationcode_ByUserId(
      input.userId,
      input.data
    );
    callback && callback(response.data);
    return response.data;
  };
  return (0, import_react_query31.useMutation)({
    mutationKey: ["Iam.Users.Verificationcode_ByUserId" /* Verificationcode_ByUserId */],
    mutationFn,
    ...options
  });
};
var useUsersApi_CreateUserMeCodeRequestMutation_v3 = (sdk, options, callback) => {
  const mutationFn = async (input) => {
    const response = await UsersApi(sdk, { coreConfig: input.coreConfig, axiosConfig: input.axiosConfig }).createUserMeCodeRequest_v3(
      input.data
    );
    callback && callback(response.data);
    return response.data;
  };
  return (0, import_react_query31.useMutation)({
    mutationKey: ["Iam.Users.UserMeCodeRequest_v3" /* UserMeCodeRequest_v3 */],
    mutationFn,
    ...options
  });
};
var useUsersApi_CreateUserInputValidationMutation_v3 = (sdk, options, callback) => {
  const mutationFn = async (input) => {
    const response = await UsersApi(sdk, { coreConfig: input.coreConfig, axiosConfig: input.axiosConfig }).createUserInputValidation_v3(
      input.data
    );
    callback && callback(response.data);
    return response.data;
  };
  return (0, import_react_query31.useMutation)({
    mutationKey: ["Iam.Users.UserInputValidation_v3" /* UserInputValidation_v3 */],
    mutationFn,
    ...options
  });
};
var useUsersApi_UpdatePassword_ByUserIdMutation_v2 = (sdk, options, callback) => {
  const mutationFn = async (input) => {
    const response = await UsersApi(sdk, { coreConfig: input.coreConfig, axiosConfig: input.axiosConfig }).updatePassword_ByUserId_v2(
      input.userId,
      input.data
    );
    callback && callback(response.data);
    return response.data;
  };
  return (0, import_react_query31.useMutation)({
    mutationKey: ["Iam.Users.Password_ByUserId_v2" /* Password_ByUserId_v2 */],
    mutationFn,
    ...options
  });
};
var useUsersApi_PostValidate_ByUserIdMutation_v3 = (sdk, options, callback) => {
  const mutationFn = async (input) => {
    const response = await UsersApi(sdk, { coreConfig: input.coreConfig, axiosConfig: input.axiosConfig }).postValidate_ByUserId_v3(
      input.userId,
      input.data
    );
    callback && callback(response.data);
    return response.data;
  };
  return (0, import_react_query31.useMutation)({
    mutationKey: ["Iam.Users.Validate_ByUserId_v3" /* Validate_ByUserId_v3 */],
    mutationFn,
    ...options
  });
};
var useUsersApi_UpdateEnable_ByUserId_ByBanIdMutation = (sdk, options, callback) => {
  const mutationFn = async (input) => {
    const response = await UsersApi(sdk, { coreConfig: input.coreConfig, axiosConfig: input.axiosConfig }).updateEnable_ByUserId_ByBanId(
      input.userId,
      input.banId
    );
    callback && callback(response.data);
    return response.data;
  };
  return (0, import_react_query31.useMutation)({
    mutationKey: ["Iam.Users.Enable_ByUserId_ByBanId" /* Enable_ByUserId_ByBanId */],
    mutationFn,
    ...options
  });
};
var useUsersApi_GetPlatforms_ByUserId_v3 = (sdk, input, options, callback) => {
  const queryFn = (sdk2, input2) => async () => {
    const response = await UsersApi(sdk2, { coreConfig: input2.coreConfig, axiosConfig: input2.axiosConfig }).getPlatforms_ByUserId_v3(
      input2.userId,
      input2.queryParams
    );
    callback && callback(response);
    return response.data;
  };
  return (0, import_react_query31.useQuery)({
    queryKey: ["Iam.Users.Platforms_ByUserId_v3" /* Platforms_ByUserId_v3 */, input],
    queryFn: queryFn(sdk, input),
    ...options
  });
};
var useUsersApi_GetPublisher_ByUserId_v3 = (sdk, input, options, callback) => {
  const queryFn = (sdk2, input2) => async () => {
    const response = await UsersApi(sdk2, { coreConfig: input2.coreConfig, axiosConfig: input2.axiosConfig }).getPublisher_ByUserId_v3(
      input2.userId
    );
    callback && callback(response);
    return response.data;
  };
  return (0, import_react_query31.useQuery)({
    queryKey: ["Iam.Users.Publisher_ByUserId_v3" /* Publisher_ByUserId_v3 */, input],
    queryFn: queryFn(sdk, input),
    ...options
  });
};
var useUsersApi_CreateUserMeHeadlesVerifyMutation_v3 = (sdk, options, callback) => {
  const mutationFn = async (input) => {
    const response = await UsersApi(sdk, { coreConfig: input.coreConfig, axiosConfig: input.axiosConfig }).createUserMeHeadlesVerify_v3(
      input.data,
      input.queryParams
    );
    callback && callback(response.data);
    return response.data;
  };
  return (0, import_react_query31.useMutation)({
    mutationKey: ["Iam.Users.UserMeHeadlesVerify_v3" /* UserMeHeadlesVerify_v3 */],
    mutationFn,
    ...options
  });
};
var useUsersApi_UpdateDisable_ByUserId_ByBanIdMutation = (sdk, options, callback) => {
  const mutationFn = async (input) => {
    const response = await UsersApi(sdk, { coreConfig: input.coreConfig, axiosConfig: input.axiosConfig }).updateDisable_ByUserId_ByBanId(
      input.userId,
      input.banId
    );
    callback && callback(response.data);
    return response.data;
  };
  return (0, import_react_query31.useMutation)({
    mutationKey: ["Iam.Users.Disable_ByUserId_ByBanId" /* Disable_ByUserId_ByBanId */],
    mutationFn,
    ...options
  });
};
var useUsersApi_GetInformation_ByUserId_v3 = (sdk, input, options, callback) => {
  const queryFn = (sdk2, input2) => async () => {
    const response = await UsersApi(sdk2, { coreConfig: input2.coreConfig, axiosConfig: input2.axiosConfig }).getInformation_ByUserId_v3(
      input2.userId
    );
    callback && callback(response);
    return response.data;
  };
  return (0, import_react_query31.useQuery)({
    queryKey: ["Iam.Users.Information_ByUserId_v3" /* Information_ByUserId_v3 */, input],
    queryFn: queryFn(sdk, input),
    ...options
  });
};
var useUsersApi_UpdateUpgradeHeadlessAccount_ByUserIdMutation = (sdk, options, callback) => {
  const mutationFn = async (input) => {
    const response = await UsersApi(sdk, {
      coreConfig: input.coreConfig,
      axiosConfig: input.axiosConfig
    }).updateUpgradeHeadlessAccount_ByUserId(input.userId, input.data);
    callback && callback(response.data);
    return response.data;
  };
  return (0, import_react_query31.useMutation)({
    mutationKey: ["Iam.Users.UpgradeHeadlessAccount_ByUserId" /* UpgradeHeadlessAccount_ByUserId */],
    mutationFn,
    ...options
  });
};
var useUsersApi_GetUserInvite_ByInvitationId_v3 = (sdk, input, options, callback) => {
  const queryFn = (sdk2, input2) => async () => {
    const response = await UsersApi(sdk2, { coreConfig: input2.coreConfig, axiosConfig: input2.axiosConfig }).getUserInvite_ByInvitationId_v3(
      input2.invitationId
    );
    callback && callback(response);
    return response.data;
  };
  return (0, import_react_query31.useQuery)({
    queryKey: ["Iam.Users.UserInvite_ByInvitationId_v3" /* UserInvite_ByInvitationId_v3 */, input],
    queryFn: queryFn(sdk, input),
    ...options
  });
};
var useUsersApi_CreateUserInvite_ByInvitationIdMutation_v3 = (sdk, options, callback) => {
  const mutationFn = async (input) => {
    const response = await UsersApi(sdk, {
      coreConfig: input.coreConfig,
      axiosConfig: input.axiosConfig
    }).createUserInvite_ByInvitationId_v3(input.invitationId, input.data);
    callback && callback(response.data);
    return response.data;
  };
  return (0, import_react_query31.useMutation)({
    mutationKey: ["Iam.Users.UserInvite_ByInvitationId_v3" /* UserInvite_ByInvitationId_v3 */],
    mutationFn,
    ...options
  });
};
var useUsersApi_CreateUser_ByPlatformIdMutation_v3 = (sdk, options, callback) => {
  const mutationFn = async (input) => {
    const response = await UsersApi(sdk, { coreConfig: input.coreConfig, axiosConfig: input.axiosConfig }).createUser_ByPlatformId_v3(
      input.platformId,
      input.data,
      input.queryParams
    );
    callback && callback(response.data);
    return response.data;
  };
  return (0, import_react_query31.useMutation)({
    mutationKey: ["Iam.Users.User_ByPlatformId_v3" /* User_ByPlatformId_v3 */],
    mutationFn,
    ...options
  });
};
var useUsersApi_CreatePlatformLink_ByUserIdMutation_v3 = (sdk, options, callback) => {
  const mutationFn = async (input) => {
    const response = await UsersApi(sdk, { coreConfig: input.coreConfig, axiosConfig: input.axiosConfig }).createPlatformLink_ByUserId_v3(
      input.userId,
      input.data
    );
    callback && callback(response.data);
    return response.data;
  };
  return (0, import_react_query31.useMutation)({
    mutationKey: ["Iam.Users.PlatformLink_ByUserId_v3" /* PlatformLink_ByUserId_v3 */],
    mutationFn,
    ...options
  });
};
var useUsersApi_CreateUserMeHeadlesCodeVerifyMutation_v3 = (sdk, options, callback) => {
  const mutationFn = async (input) => {
    const response = await UsersApi(sdk, { coreConfig: input.coreConfig, axiosConfig: input.axiosConfig }).createUserMeHeadlesCodeVerify_v3(
      input.data
    );
    callback && callback(response.data);
    return response.data;
  };
  return (0, import_react_query31.useMutation)({
    mutationKey: ["Iam.Users.UserMeHeadlesCodeVerify_v3" /* UserMeHeadlesCodeVerify_v3 */],
    mutationFn,
    ...options
  });
};
var useUsersApi_GetLoginsHistories_ByUserId_v3 = (sdk, input, options, callback) => {
  const queryFn = (sdk2, input2) => async () => {
    const response = await UsersApi(sdk2, { coreConfig: input2.coreConfig, axiosConfig: input2.axiosConfig }).getLoginsHistories_ByUserId_v3(
      input2.userId,
      input2.queryParams
    );
    callback && callback(response);
    return response.data;
  };
  return (0, import_react_query31.useQuery)({
    queryKey: ["Iam.Users.LoginsHistories_ByUserId_v3" /* LoginsHistories_ByUserId_v3 */, input],
    queryFn: queryFn(sdk, input),
    ...options
  });
};
var useUsersApi_DeleteUserMePlatform_ByPlatformIdMutation_v3 = (sdk, options, callback) => {
  const mutationFn = async (input) => {
    const response = await UsersApi(sdk, {
      coreConfig: input.coreConfig,
      axiosConfig: input.axiosConfig
    }).deleteUserMePlatform_ByPlatformId_v3(input.platformId, input.data);
    callback && callback(response.data);
    return response.data;
  };
  return (0, import_react_query31.useMutation)({
    mutationKey: ["Iam.Users.UserMePlatform_ByPlatformId_v3" /* UserMePlatform_ByPlatformId_v3 */],
    mutationFn,
    ...options
  });
};
var useUsersApi_PostUserMePlatform_ByPlatformIdMutation_v3 = (sdk, options, callback) => {
  const mutationFn = async (input) => {
    const response = await UsersApi(sdk, {
      coreConfig: input.coreConfig,
      axiosConfig: input.axiosConfig
    }).postUserMePlatform_ByPlatformId_v3(input.platformId, input.data);
    callback && callback(response.data);
    return response.data;
  };
  return (0, import_react_query31.useMutation)({
    mutationKey: ["Iam.Users.UserMePlatform_ByPlatformId_v3" /* UserMePlatform_ByPlatformId_v3 */],
    mutationFn,
    ...options
  });
};
var useUsersApi_PostLink_ByUserId_ByPlatformIdMutation = (sdk, options, callback) => {
  const mutationFn = async (input) => {
    const response = await UsersApi(sdk, { coreConfig: input.coreConfig, axiosConfig: input.axiosConfig }).postLink_ByUserId_ByPlatformId(
      input.userId,
      input.platformId,
      input.data
    );
    callback && callback(response.data);
    return response.data;
  };
  return (0, import_react_query31.useMutation)({
    mutationKey: ["Iam.Users.Link_ByUserId_ByPlatformId" /* Link_ByUserId_ByPlatformId */],
    mutationFn,
    ...options
  });
};
var useUsersApi_GetPlatformsJustice_ByUserId_v2 = (sdk, input, options, callback) => {
  const queryFn = (sdk2, input2) => async () => {
    const response = await UsersApi(sdk2, { coreConfig: input2.coreConfig, axiosConfig: input2.axiosConfig }).getPlatformsJustice_ByUserId_v2(
      input2.userId
    );
    callback && callback(response);
    return response.data;
  };
  return (0, import_react_query31.useQuery)({
    queryKey: ["Iam.Users.PlatformsJustice_ByUserId_v2" /* PlatformsJustice_ByUserId_v2 */, input],
    queryFn: queryFn(sdk, input),
    ...options
  });
};
var useUsersApi_GetDistinctPlatforms_ByUserId_v3 = (sdk, input, options, callback) => {
  const queryFn = (sdk2, input2) => async () => {
    const response = await UsersApi(sdk2, { coreConfig: input2.coreConfig, axiosConfig: input2.axiosConfig }).getDistinctPlatforms_ByUserId_v3(
      input2.userId
    );
    callback && callback(response);
    return response.data;
  };
  return (0, import_react_query31.useQuery)({
    queryKey: ["Iam.Users.DistinctPlatforms_ByUserId_v3" /* DistinctPlatforms_ByUserId_v3 */, input],
    queryFn: queryFn(sdk, input),
    ...options
  });
};
var useUsersApi_GetPlatformsJustice_ByUserId_v3 = (sdk, input, options, callback) => {
  const queryFn = (sdk2, input2) => async () => {
    const response = await UsersApi(sdk2, { coreConfig: input2.coreConfig, axiosConfig: input2.axiosConfig }).getPlatformsJustice_ByUserId_v3(
      input2.userId
    );
    callback && callback(response);
    return response.data;
  };
  return (0, import_react_query31.useQuery)({
    queryKey: ["Iam.Users.PlatformsJustice_ByUserId_v3" /* PlatformsJustice_ByUserId_v3 */, input],
    queryFn: queryFn(sdk, input),
    ...options
  });
};
var useUsersApi_GetAsyncStatus_ByRequestId_v3 = (sdk, input, options, callback) => {
  const queryFn = (sdk2, input2) => async () => {
    const response = await UsersApi(sdk2, { coreConfig: input2.coreConfig, axiosConfig: input2.axiosConfig }).getAsyncStatus_ByRequestId_v3(
      input2.requestId
    );
    callback && callback(response);
    return response.data;
  };
  return (0, import_react_query31.useQuery)({
    queryKey: ["Iam.Users.AsyncStatus_ByRequestId_v3" /* AsyncStatus_ByRequestId_v3 */, input],
    queryFn: queryFn(sdk, input),
    ...options
  });
};
var useUsersApi_PostUnlink_ByUserId_ByPlatformIdMutation = (sdk, options, callback) => {
  const mutationFn = async (input) => {
    const response = await UsersApi(sdk, { coreConfig: input.coreConfig, axiosConfig: input.axiosConfig }).postUnlink_ByUserId_ByPlatformId(
      input.userId,
      input.platformId,
      input.data
    );
    callback && callback(response.data);
    return response.data;
  };
  return (0, import_react_query31.useMutation)({
    mutationKey: ["Iam.Users.Unlink_ByUserId_ByPlatformId" /* Unlink_ByUserId_ByPlatformId */],
    mutationFn,
    ...options
  });
};
var useUsersApi_DeleteAllMeUser_ByPlatformIdMutation_v3 = (sdk, options, callback) => {
  const mutationFn = async (input) => {
    const response = await UsersApi(sdk, { coreConfig: input.coreConfig, axiosConfig: input.axiosConfig }).deleteAllMeUser_ByPlatformId_v3(
      input.platformId
    );
    callback && callback(response.data);
    return response.data;
  };
  return (0, import_react_query31.useMutation)({
    mutationKey: ["Iam.Users.AllMeUser_ByPlatformId_v3" /* AllMeUser_ByPlatformId_v3 */],
    mutationFn,
    ...options
  });
};
var useUsersApi_DeletePermission_ByUserId_ByResource_ByActionMutation = (sdk, options, callback) => {
  const mutationFn = async (input) => {
    const response = await UsersApi(sdk, {
      coreConfig: input.coreConfig,
      axiosConfig: input.axiosConfig
    }).deletePermission_ByUserId_ByResource_ByAction(input.userId, input.resource, input.action);
    callback && callback(response.data);
    return response.data;
  };
  return (0, import_react_query31.useMutation)({
    mutationKey: ["Iam.Users.Permission_ByUserId_ByResource_ByAction" /* Permission_ByUserId_ByResource_ByAction */],
    mutationFn,
    ...options
  });
};
var useUsersApi_UpdatePermission_ByUserId_ByResource_ByActionMutation = (sdk, options, callback) => {
  const mutationFn = async (input) => {
    const response = await UsersApi(sdk, {
      coreConfig: input.coreConfig,
      axiosConfig: input.axiosConfig
    }).updatePermission_ByUserId_ByResource_ByAction(input.userId, input.resource, input.action, input.data);
    callback && callback(response.data);
    return response.data;
  };
  return (0, import_react_query31.useMutation)({
    mutationKey: ["Iam.Users.Permission_ByUserId_ByResource_ByAction" /* Permission_ByUserId_ByResource_ByAction */],
    mutationFn,
    ...options
  });
};
var useUsersApi_PostForceMeUser_ByPlatformIdMutation_v3 = (sdk, options, callback) => {
  const mutationFn = async (input) => {
    const response = await UsersApi(sdk, { coreConfig: input.coreConfig, axiosConfig: input.axiosConfig }).postForceMeUser_ByPlatformId_v3(
      input.platformId,
      input.data
    );
    callback && callback(response.data);
    return response.data;
  };
  return (0, import_react_query31.useMutation)({
    mutationKey: ["Iam.Users.ForceMeUser_ByPlatformId_v3" /* ForceMeUser_ByPlatformId_v3 */],
    mutationFn,
    ...options
  });
};
var useUsersApi_GetAgerestrictions_ByCountryCode_v2 = (sdk, input, options, callback) => {
  const queryFn = (sdk2, input2) => async () => {
    const response = await UsersApi(sdk2, {
      coreConfig: input2.coreConfig,
      axiosConfig: input2.axiosConfig
    }).getAgerestrictions_ByCountryCode_v2(input2.countryCode);
    callback && callback(response);
    return response.data;
  };
  return (0, import_react_query31.useQuery)({
    queryKey: ["Iam.Users.Agerestrictions_ByCountryCode_v2" /* Agerestrictions_ByCountryCode_v2 */, input],
    queryFn: queryFn(sdk, input),
    ...options
  });
};
var useUsersApi_GetAgerestrictionCountry_ByCountryCode_v3 = (sdk, input, options, callback) => {
  const queryFn = (sdk2, input2) => async () => {
    const response = await UsersApi(sdk2, {
      coreConfig: input2.coreConfig,
      axiosConfig: input2.axiosConfig
    }).getAgerestrictionCountry_ByCountryCode_v3(input2.countryCode);
    callback && callback(response);
    return response.data;
  };
  return (0, import_react_query31.useQuery)({
    queryKey: ["Iam.Users.AgerestrictionCountry_ByCountryCode_v3" /* AgerestrictionCountry_ByCountryCode_v3 */, input],
    queryFn: queryFn(sdk, input),
    ...options
  });
};
var useUsersApi_GetPlatformJustice_ByUserId_ByTargetNamespace = (sdk, input, options, callback) => {
  const queryFn = (sdk2, input2) => async () => {
    const response = await UsersApi(sdk2, {
      coreConfig: input2.coreConfig,
      axiosConfig: input2.axiosConfig
    }).getPlatformJustice_ByUserId_ByTargetNamespace(input2.userId, input2.targetNamespace);
    callback && callback(response);
    return response.data;
  };
  return (0, import_react_query31.useQuery)({
    queryKey: ["Iam.Users.PlatformJustice_ByUserId_ByTargetNamespace" /* PlatformJustice_ByUserId_ByTargetNamespace */, input],
    queryFn: queryFn(sdk, input),
    ...options
  });
};
var useUsersApi_UpdatePlatformJustice_ByUserId_ByTargetNamespaceMutation = (sdk, options, callback) => {
  const mutationFn = async (input) => {
    const response = await UsersApi(sdk, {
      coreConfig: input.coreConfig,
      axiosConfig: input.axiosConfig
    }).updatePlatformJustice_ByUserId_ByTargetNamespace(input.userId, input.targetNamespace);
    callback && callback(response.data);
    return response.data;
  };
  return (0, import_react_query31.useMutation)({
    mutationKey: ["Iam.Users.PlatformJustice_ByUserId_ByTargetNamespace" /* PlatformJustice_ByUserId_ByTargetNamespace */],
    mutationFn,
    ...options
  });
};
var useUsersApi_GetWebLinkMeUsers_ByPlatformId_v3 = (sdk, input, options, callback) => {
  const queryFn = (sdk2, input2) => async () => {
    const response = await UsersApi(sdk2, {
      coreConfig: input2.coreConfig,
      axiosConfig: input2.axiosConfig
    }).getWebLinkMeUsers_ByPlatformId_v3(input2.platformId, input2.queryParams);
    callback && callback(response);
    return response.data;
  };
  return (0, import_react_query31.useQuery)({
    queryKey: ["Iam.Users.WebLinkMeUsers_ByPlatformId_v3" /* WebLinkMeUsers_ByPlatformId_v3 */, input],
    queryFn: queryFn(sdk, input),
    ...options
  });
};
var useUsersApi_DeleteLink_ByUserId_ByPlatformIdMutation_v2 = (sdk, options, callback) => {
  const mutationFn = async (input) => {
    const response = await UsersApi(sdk, {
      coreConfig: input.coreConfig,
      axiosConfig: input.axiosConfig
    }).deleteLink_ByUserId_ByPlatformId_v2(input.userId, input.platformId, input.data);
    callback && callback(response.data);
    return response.data;
  };
  return (0, import_react_query31.useMutation)({
    mutationKey: ["Iam.Users.Link_ByUserId_ByPlatformId_v2" /* Link_ByUserId_ByPlatformId_v2 */],
    mutationFn,
    ...options
  });
};
var useUsersApi_PostLink_ByUserId_ByPlatformIdMutation_v2 = (sdk, options, callback) => {
  const mutationFn = async (input) => {
    const response = await UsersApi(sdk, {
      coreConfig: input.coreConfig,
      axiosConfig: input.axiosConfig
    }).postLink_ByUserId_ByPlatformId_v2(input.userId, input.platformId, input.data);
    callback && callback(response.data);
    return response.data;
  };
  return (0, import_react_query31.useMutation)({
    mutationKey: ["Iam.Users.Link_ByUserId_ByPlatformId_v2" /* Link_ByUserId_ByPlatformId_v2 */],
    mutationFn,
    ...options
  });
};
var useUsersApi_CreatePlatformLinkWithProgression_ByUserIdMutation_v3 = (sdk, options, callback) => {
  const mutationFn = async (input) => {
    const response = await UsersApi(sdk, {
      coreConfig: input.coreConfig,
      axiosConfig: input.axiosConfig
    }).createPlatformLinkWithProgression_ByUserId_v3(input.userId, input.data);
    callback && callback(response.data);
    return response.data;
  };
  return (0, import_react_query31.useMutation)({
    mutationKey: ["Iam.Users.PlatformLinkWithProgression_ByUserId_v3" /* PlatformLinkWithProgression_ByUserId_v3 */],
    mutationFn,
    ...options
  });
};
var useUsersApi_CreateUserMePlatformJustice_ByTargetNamespaceMutation_v3 = (sdk, options, callback) => {
  const mutationFn = async (input) => {
    const response = await UsersApi(sdk, {
      coreConfig: input.coreConfig,
      axiosConfig: input.axiosConfig
    }).createUserMePlatformJustice_ByTargetNamespace_v3(input.targetNamespace);
    callback && callback(response.data);
    return response.data;
  };
  return (0, import_react_query31.useMutation)({
    mutationKey: ["Iam.Users.UserMePlatformJustice_ByTargetNamespace_v3" /* UserMePlatformJustice_ByTargetNamespace_v3 */],
    mutationFn,
    ...options
  });
};
var useUsersApi_GetUser_ByPlatformId_ByPlatformUserId_v3 = (sdk, input, options, callback) => {
  const queryFn = (sdk2, input2) => async () => {
    const response = await UsersApi(sdk2, {
      coreConfig: input2.coreConfig,
      axiosConfig: input2.axiosConfig
    }).getUser_ByPlatformId_ByPlatformUserId_v3(input2.platformId, input2.platformUserId);
    callback && callback(response);
    return response.data;
  };
  return (0, import_react_query31.useQuery)({
    queryKey: ["Iam.Users.User_ByPlatformId_ByPlatformUserId_v3" /* User_ByPlatformId_ByPlatformUserId_v3 */, input],
    queryFn: queryFn(sdk, input),
    ...options
  });
};
var useUsersApi_UpdateUpgradeHeadlessAccountWithVerificationCode_ByUserIdMutation = (sdk, options, callback) => {
  const mutationFn = async (input) => {
    const response = await UsersApi(sdk, {
      coreConfig: input.coreConfig,
      axiosConfig: input.axiosConfig
    }).updateUpgradeHeadlessAccountWithVerificationCode_ByUserId(input.userId, input.data);
    callback && callback(response.data);
    return response.data;
  };
  return (0, import_react_query31.useMutation)({
    mutationKey: ["Iam.Users.UpgradeHeadlessAccountWithVerificationCode_ByUserId" /* UpgradeHeadlessAccountWithVerificationCode_ByUserId */],
    mutationFn,
    ...options
  });
};
var useUsersApi_PostWebLinkProcesMeUser_ByPlatformIdMutation_v3 = (sdk, options, callback) => {
  const mutationFn = async (input) => {
    const response = await UsersApi(sdk, {
      coreConfig: input.coreConfig,
      axiosConfig: input.axiosConfig
    }).postWebLinkProcesMeUser_ByPlatformId_v3(input.platformId, input.data);
    callback && callback(response.data);
    return response.data;
  };
  return (0, import_react_query31.useMutation)({
    mutationKey: ["Iam.Users.WebLinkProcesMeUser_ByPlatformId_v3" /* WebLinkProcesMeUser_ByPlatformId_v3 */],
    mutationFn,
    ...options
  });
};
var useUsersApi_GetWebLinkEstablishMeUsers_ByPlatformId_v3 = (sdk, input, options, callback) => {
  const queryFn = (sdk2, input2) => async () => {
    const response = await UsersApi(sdk2, {
      coreConfig: input2.coreConfig,
      axiosConfig: input2.axiosConfig
    }).getWebLinkEstablishMeUsers_ByPlatformId_v3(input2.platformId, input2.queryParams);
    callback && callback(response);
    return response.data;
  };
  return (0, import_react_query31.useQuery)({
    queryKey: ["Iam.Users.WebLinkEstablishMeUsers_ByPlatformId_v3" /* WebLinkEstablishMeUsers_ByPlatformId_v3 */, input],
    queryFn: queryFn(sdk, input),
    ...options
  });
};

// src/generated-public/queries/UsersV4.query.ts
var import_react_query32 = require("@tanstack/react-query");

// src/generated-public/UsersV4Api.ts
var import_sdk64 = require("@accelbyte/sdk");

// src/generated-public/endpoints/UsersV4$.ts
var import_sdk63 = require("@accelbyte/sdk");
var import_zod242 = require("zod");

// src/generated-definitions/UserPublicInfoResponseV4.ts
var import_zod238 = require("zod");
var UserPublicInfoResponseV4 = import_zod238.z.object({ displayName: import_zod238.z.string(), uniqueDisplayName: import_zod238.z.string().nullish(), userId: import_zod238.z.string() });

// src/generated-definitions/UserResponseV4.ts
var import_zod241 = require("zod");

// src/generated-definitions/UserActiveBanResponseV4.ts
var import_zod239 = require("zod");
var UserActiveBanResponseV4 = import_zod239.z.object({ ban: import_zod239.z.string(), banId: import_zod239.z.string(), endDate: import_zod239.z.string() });

// src/generated-definitions/UserPermissionsResponseV4.ts
var import_zod240 = require("zod");
var UserPermissionsResponseV4 = import_zod240.z.object({
  action: import_zod240.z.number().int(),
  resource: import_zod240.z.string(),
  schedAction: import_zod240.z.number().int().nullish(),
  schedCron: import_zod240.z.string().nullish(),
  schedRange: import_zod240.z.array(import_zod240.z.string()).nullish()
});

// src/generated-definitions/UserResponseV4.ts
var UserResponseV4 = import_zod241.z.object({
  authType: import_zod241.z.string(),
  bans: import_zod241.z.array(UserActiveBanResponseV4),
  country: import_zod241.z.string(),
  createdAt: import_zod241.z.string(),
  dateOfBirth: import_zod241.z.string(),
  deletionStatus: import_zod241.z.boolean(),
  displayName: import_zod241.z.string(),
  emailAddress: import_zod241.z.string(),
  emailVerified: import_zod241.z.boolean(),
  enabled: import_zod241.z.boolean(),
  lastDateOfBirthChangedTime: import_zod241.z.string(),
  lastEnabledChangedTime: import_zod241.z.string(),
  namespace: import_zod241.z.string(),
  newEmailAddress: import_zod241.z.string().nullish(),
  oldEmailAddress: import_zod241.z.string(),
  permissions: import_zod241.z.array(UserPermissionsResponseV4),
  phoneNumber: import_zod241.z.string().nullish(),
  phoneVerified: import_zod241.z.boolean(),
  platformId: import_zod241.z.string().nullish(),
  platformUserId: import_zod241.z.string().nullish(),
  roles: import_zod241.z.array(import_zod241.z.string()),
  uniqueDisplayName: import_zod241.z.string().nullish(),
  userId: import_zod241.z.string(),
  username: import_zod241.z.string().nullish()
});

// src/generated-public/endpoints/UsersV4$.ts
var UsersV4$ = class {
  // @ts-ignore
  // prettier-ignore
  constructor(axiosInstance, namespace, useSchemaValidation = true) {
    this.axiosInstance = axiosInstance;
    this.namespace = namespace;
    this.useSchemaValidation = useSchemaValidation;
  }
  /**
   * This endpoint is used to invite a game studio admin user with new namespace in multi tenant mode. It will return error if the service multi tenant mode is set to false. Request body details: - emailAddress: email address of the user to be invited - namespace: new namespace of the user to be created - namespaceDisplayName: display name of the new namespace - additionalData(optional): for utm parameter data The invited users will also be assigned with &#34;User&#34; role by default.
   */
  createUserInvite_v4(data) {
    const params = {};
    const url = "/iam/v4/public/users/invite";
    const resultPromise = this.axiosInstance.post(url, data, { params });
    return import_sdk63.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, InviteUserResponseV3, "InviteUserResponseV3");
  }
  /**
   * Create a new user with unique email address and username. **Required attributes:** - authType: possible value is EMAILPASSWD - emailAddress: Please refer to the rule from /v3/public/inputValidations API. - username: Please refer to the rule from /v3/public/inputValidations API. - password: Please refer to the rule from /v3/public/inputValidations API. - country: ISO3166-1 alpha-2 two letter, e.g. US. - dateOfBirth: YYYY-MM-DD, e.g. 1990-01-01. valid values are between 1905-01-01 until current date. - uniqueDisplayName: required when uniqueDisplayNameEnabled/UNIQUE_DISPLAY_NAME_ENABLED is true, please refer to the rule from /v3/public/inputValidations API. - code: required when mandatoryEmailVerificationEnabled config is true, please refer to the config from /iam/v3/public/namespaces/{namespace}/config/{configKey} [GET] API. **Not required attributes:** - displayName: Please refer to the rule from /v3/public/inputValidations API. This endpoint support accepting agreements for the created user. Supply the accepted agreements in acceptedPolicies attribute.
   */
  createUser_v4(data) {
    const params = {};
    const url = "/iam/v4/public/namespaces/{namespace}/users".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.post(url, data, { params });
    return import_sdk63.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, CreateUserResponseV4, "CreateUserResponseV4");
  }
  /**
   * This Endpoint support update user based on given data. **Single request can update single field or multi fields.** Supported field {country, displayName, languageTag, dateOfBirth, avatarUrl, userName} Country use ISO3166-1 alpha-2 two letter, e.g. US. Date of Birth format : YYYY-MM-DD, e.g. 2019-04-29. **Response body logic when user updating email address:** - User want to update email address of which have been verified, newEmailAddress response field will be filled with new email address. - User want to update email address of which have not been verified, { oldEmailAddress, emailAddress} response field will be filled with new email address. - User want to update email address of which have been verified and updated before, { oldEmailAddress, emailAddress} response field will be filled with verified email before. newEmailAddress response field will be filled with newest email address. action code : 10103
   */
  patchUserMe_v4(data) {
    const params = {};
    const url = "/iam/v4/public/namespaces/{namespace}/users/me".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.patch(url, data, { params });
    return import_sdk63.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, UserResponseV3, "UserResponseV3");
  }
  /**
   * Create a test user and not send verification code email **Required attributes:** - verified: this new user is verified or not - authType: possible value is EMAILPASSWD - emailAddress: Please refer to the rule from /v3/public/inputValidations API. - username: Please refer to the rule from /v3/public/inputValidations API. - password: Please refer to the rule from /v3/public/inputValidations API. - country: ISO3166-1 alpha-2 two letter, e.g. US. - dateOfBirth: YYYY-MM-DD, e.g. 1990-01-01. valid values are between 1905-01-01 until current date. **Not required attributes:** - displayName: Please refer to the rule from /v3/public/inputValidations API. This endpoint support accepting agreements for the created user. Supply the accepted agreements in acceptedPolicies attribute.
   */
  createTestUser_v4(data) {
    const params = {};
    const url = "/iam/v4/public/namespaces/{namespace}/test_users".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.post(url, data, { params });
    return import_sdk63.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, CreateUserResponseV4, "CreateUserResponseV4");
  }
  /**
   * This endpoint only returns user&#39;s public information. action code: 10129
   */
  getUser_ByUserId_v4(userId) {
    const params = {};
    const url = "/iam/v4/public/namespaces/{namespace}/users/{userId}".replace("{namespace}", this.namespace).replace("{userId}", userId);
    const resultPromise = this.axiosInstance.get(url, { params });
    return import_sdk63.Validate.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      UserPublicInfoResponseV4,
      "UserPublicInfoResponseV4"
    );
  }
  /**
   * The endpoint to update my email address. It requires a verification code from &lt;code&gt;/users/me/code/request&lt;/code&gt; with **UpdateEmailAddress** context.
   */
  updateUserMeEmail_v4(data) {
    const params = {};
    const url = "/iam/v4/public/namespaces/{namespace}/users/me/email".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.put(url, data, { params });
    return import_sdk63.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, import_zod242.z.unknown(), "z.unknown()");
  }
  /**
   * (Only for test)This endpoint is used to remove trusted device. This endpoint Requires device_token in cookie
   */
  deleteUserMeMfaDevice_v4() {
    const params = {};
    const url = "/iam/v4/public/namespaces/{namespace}/users/me/mfa/device".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.delete(url, { params });
    return import_sdk63.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, import_zod242.z.unknown(), "z.unknown()");
  }
  /**
   * This endpoint is used to get user enabled factors.
   */
  getUsersMeMfaFactor_v4() {
    const params = {};
    const url = "/iam/v4/public/namespaces/{namespace}/users/me/mfa/factor".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.get(url, { params });
    return import_sdk63.Validate.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      EnabledFactorsResponseV4,
      "EnabledFactorsResponseV4"
    );
  }
  /**
   * This endpoint is used to make 2FA factor default.
   */
  postUserMeMfaFactor_v4(data) {
    const params = {};
    const url = "/iam/v4/public/namespaces/{namespace}/users/me/mfa/factor".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.post(url, import_sdk63.CodeGenUtil.getFormUrlEncodedData(data), {
      ...params,
      headers: { ...params.headers, "content-type": "application/x-www-form-urlencoded" }
    });
    return import_sdk63.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, import_zod242.z.unknown(), "z.unknown()");
  }
  /**
   * This endpoint will get user&#39;s&#39; MFA status.
   */
  getUsersMeMfaStatus_v4() {
    const params = {};
    const url = "/iam/v4/public/namespaces/{namespace}/users/me/mfa/status".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.get(url, { params });
    return import_sdk63.Validate.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      UserMfaStatusResponseV4,
      "UserMfaStatusResponseV4"
    );
  }
  /**
   * @deprecated
   * This endpoint will get user&#39;s&#39; MFA status. --------- **Substitute endpoint**: /iam/v4/public/namespaces/{namespace}/users/me/mfa/status [GET]
   */
  createUserMeMfaStatus_v4() {
    const params = {};
    const url = "/iam/v4/public/namespaces/{namespace}/users/me/mfa/status".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.post(url, null, { params });
    return import_sdk63.Validate.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      UserMfaStatusResponseV4,
      "UserMfaStatusResponseV4"
    );
  }
  /**
   * @deprecated
   * This endpoint is used to get 8-digits backup codes. Each code is a one-time code and will be deleted once used.
   */
  getUsersMeMfaBackupCode_v4() {
    const params = {};
    const url = "/iam/v4/public/namespaces/{namespace}/users/me/mfa/backupCode".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.get(url, { params });
    return import_sdk63.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, BackupCodesResponseV4, "BackupCodesResponseV4");
  }
  /**
   * @deprecated
   * This endpoint is used to generate 8-digits backup codes. Each code is a one-time code and will be deleted once used.
   */
  createUserMeMfaBackupCode_v4() {
    const params = {};
    const url = "/iam/v4/public/namespaces/{namespace}/users/me/mfa/backupCode".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.post(url, null, { params });
    return import_sdk63.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, BackupCodesResponseV4, "BackupCodesResponseV4");
  }
  /**
   * This endpoint is used to send email code. ---------------- Supported values of action: * ChangePassword * DisableMFAEmail
   */
  postUserMeMfaEmailCode_v4(data) {
    const params = {};
    const url = "/iam/v4/public/namespaces/{namespace}/users/me/mfa/email/code".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.post(url, import_sdk63.CodeGenUtil.getFormUrlEncodedData(data), {
      ...params,
      headers: { ...params.headers, "content-type": "application/x-www-form-urlencoded" }
    });
    return import_sdk63.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, import_zod242.z.unknown(), "z.unknown()");
  }
  /**
   * Upgrade headless account to full account without verifying email address. Client does not need to provide verification code which sent to email address. action code : 10124
   */
  createUserMeHeadlesVerify_v4(data) {
    const params = {};
    const url = "/iam/v4/public/namespaces/{namespace}/users/me/headless/verify".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.post(url, data, { params });
    return import_sdk63.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, UserResponseV4, "UserResponseV4");
  }
  /**
   * This endpoint is used to get existing 8-digits backup codes. Each codes is a one-time code and will be deleted once used. The codes will be sent through linked email.
   */
  getUsersMeMfaBackupCodes_v4(queryParams) {
    const params = { ...queryParams };
    const url = "/iam/v4/public/namespaces/{namespace}/users/me/mfa/backupCodes".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.get(url, { params });
    return import_sdk63.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, import_zod242.z.unknown(), "z.unknown()");
  }
  /**
   * This endpoint is used to generate 8-digits backup codes. Each codes is a one-time code and will be deleted once used. The codes will be sent through linked email.
   */
  createUserMeMfaBackupCode_ByNS_v4(queryParams) {
    const params = { ...queryParams };
    const url = "/iam/v4/public/namespaces/{namespace}/users/me/mfa/backupCodes".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.post(url, null, { params });
    return import_sdk63.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, import_zod242.z.unknown(), "z.unknown()");
  }
  /**
   * This endpoint is used to enable 2FA email.
   */
  postUserMeMfaEmailEnable_v4(data) {
    const params = {};
    const url = "/iam/v4/public/namespaces/{namespace}/users/me/mfa/email/enable".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.post(url, import_sdk63.CodeGenUtil.getFormUrlEncodedData(data), {
      ...params,
      headers: { ...params.headers, "content-type": "application/x-www-form-urlencoded" }
    });
    return import_sdk63.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, import_zod242.z.unknown(), "z.unknown()");
  }
  /**
   * This endpoint is used to disable 2FA email. ------ **Note**: **mfaToken** is required when all the following are enabled: - The environment variable **SENSITIVE_MFA_AUTH_ENABLED** is true - The **Two-Factor Authentication** is enabled in the IAM client where user logs in - Users already enabled the MFA
   */
  createUserMeMfaEmailDisable_v4(data) {
    const params = {};
    const url = "/iam/v4/public/namespaces/{namespace}/users/me/mfa/email/disable".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.post(url, data, { params });
    return import_sdk63.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, import_zod242.z.unknown(), "z.unknown()");
  }
  /**
   * This endpoint create user from saved roles when creating invitation and submitted data. User will be able to login after completing submitting the data through this endpoint. Available Authentication Types: EMAILPASSWD: an authentication type used for new user registration through email. **Note**: * **uniqueDisplayName**: this is required when uniqueDisplayNameEnabled/UNIQUE_DISPLAY_NAME_ENABLED is true. Country use ISO3166-1 alpha-2 two letter, e.g. US. Date of Birth format : YYYY-MM-DD, e.g. 2019-04-29. Required attributes: - authType: possible value is EMAILPASSWD (see above) - country: ISO3166-1 alpha-2 two letter, e.g. US. - dateOfBirth: YYYY-MM-DD, e.g. 1990-01-01. valid values are between 1905-01-01 until current date. - displayName: Please refer to the rule from /v3/public/inputValidations API. - password: Please refer to the rule from /v3/public/inputValidations API. - username: Please refer to the rule from /v3/public/inputValidations API.
   */
  createUserInvite_ByInvitationId_v4(invitationId, data) {
    const params = {};
    const url = "/iam/v4/public/namespaces/{namespace}/users/invite/{invitationId}".replace("{namespace}", this.namespace).replace("{invitationId}", invitationId);
    const resultPromise = this.axiosInstance.post(url, data, { params });
    return import_sdk63.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, CreateUserResponseV4, "CreateUserResponseV4");
  }
  /**
   * List User ID By Platform User ID This endpoint intended to list game user ID from the given namespace This endpoint return list of user ID by given platform ID and list of platform user ID, the max count is 100. Supported platform: - steam - steamopenid - ps4web - ps4 - ps5 - live - xblweb - oculus - oculusweb - facebook - google - googleplaygames - twitch - discord - apple - device - justice - epicgames - nintendo - awscognito - netflix - snapchat - oidc platform id Note: **nintendo platform user ID**: NSA ID need to be appended with Environment ID using colon as separator. e.g kmzwa8awaa:dd1 &lt;br&gt; If the request body exceed the max limitation, the max count will be in response body&#39;s messageVariables: &#34;messageVariables&#34;: {&#34;maxCount&#34;: &#34;100&#34;}
   */
  createUser_ByPlatformId_v4(platformId, data, queryParams) {
    const params = { ...queryParams };
    const url = "/iam/v4/public/namespaces/{namespace}/platforms/{platformId}/users".replace("{namespace}", this.namespace).replace("{platformId}", platformId);
    const resultPromise = this.axiosInstance.post(url, data, { params });
    return import_sdk63.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, UserPlatforms, "UserPlatforms");
  }
  /**
   *  The endpoint upgrades a headless account by linking the headless account with the email address, username, and password. By upgrading the headless account into a full account, the user could use the email address, username, and password for using Justice IAM. The endpoint is a shortcut for upgrading a headless account and verifying the email address in one call. In order to get a verification code for the endpoint, please check the [send verification code endpoint](#operations-Users-PublicSendVerificationCodeV3). This endpoint also have an ability to update user data (if the user data field is specified) right after the upgrade account process is done. Supported user data fields: - displayName - dateOfBirth : format YYYY-MM-DD, e.g. 2019-04-29 - country : format ISO3166-1 alpha-2 two letter, e.g. US action code : 10124
   */
  createUserMeHeadlesCodeVerify_v4(data) {
    const params = {};
    const url = "/iam/v4/public/namespaces/{namespace}/users/me/headless/code/verify".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.post(url, data, { params });
    return import_sdk63.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, UserResponseV4, "UserResponseV4");
  }
  /**
   * This endpoint will verify user&#39;s&#39; MFA code and generate a MFA token for the action.
   */
  postUserMeMfaChallengeVerify_v4(data) {
    const params = {};
    const url = "/iam/v4/public/namespaces/{namespace}/users/me/mfa/challenge/verify".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.post(url, import_sdk63.CodeGenUtil.getFormUrlEncodedData(data), {
      ...params,
      headers: { ...params.headers, "content-type": "application/x-www-form-urlencoded" }
    });
    return import_sdk63.Validate.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      UserMfaTokenResponseV4,
      "UserMfaTokenResponseV4"
    );
  }
  /**
   * This endpoint is used to generate a secret key for 3rd-party authenticator app. A QR code URI is also returned so that frontend can generate QR code image.
   */
  createUserMeMfaAuthenticatorKey_v4() {
    const params = {};
    const url = "/iam/v4/public/namespaces/{namespace}/users/me/mfa/authenticator/key".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.post(url, null, { params });
    return import_sdk63.Validate.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      AuthenticatorKeyResponseV4,
      "AuthenticatorKeyResponseV4"
    );
  }
  /**
   * @deprecated
   * This endpoint is used to enable 2FA backup codes.
   */
  createUserMeMfaBackupCodeEnable_v4() {
    const params = {};
    const url = "/iam/v4/public/namespaces/{namespace}/users/me/mfa/backupCode/enable".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.post(url, null, { params });
    return import_sdk63.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, BackupCodesResponseV4, "BackupCodesResponseV4");
  }
  /**
   * This endpoint is used to disable 2FA backup codes. ------ **Note**: **mfaToken** is required when all the following are enabled: - The environment variable **SENSITIVE_MFA_AUTH_ENABLED** is true - The **Two-Factor Authentication** is enabled in the IAM client where user logs in - Users already enabled the MFA
   */
  deleteUserMeMfaBackupCodeDisable_v4(data) {
    const params = {};
    const url = "/iam/v4/public/namespaces/{namespace}/users/me/mfa/backupCode/disable".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.delete(url, { data, params });
    return import_sdk63.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, import_zod242.z.unknown(), "z.unknown()");
  }
  /**
   * This endpoint is used to enable 2FA backup codes.
   */
  createUserMeMfaBackupCodeEnable_ByNS_v4(queryParams) {
    const params = { ...queryParams };
    const url = "/iam/v4/public/namespaces/{namespace}/users/me/mfa/backupCodes/enable".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.post(url, null, { params });
    return import_sdk63.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, import_zod242.z.unknown(), "z.unknown()");
  }
  /**
   * @deprecated
   * This endpoint is used to download backup codes.
   */
  getUsersMeMfaBackupCodeDownload_v4() {
    const params = {};
    const url = "/iam/v4/public/namespaces/{namespace}/users/me/mfa/backupCode/download".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.get(url, { params });
    return import_sdk63.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, import_zod242.z.unknown(), "z.unknown()");
  }
  /**
   * This endpoint is used to enable 2FA authenticator. ---------- Prerequisites: - Generate the secret key/QR code uri by **_/iam/v4/public/namespaces/{namespace}/users/me/mfa/authenticator/key_** - Consume the secret key/QR code by an authenticator app - Get the code from the authenticator app
   */
  postUserMeMfaAuthenticatorEnable_v4(data) {
    const params = {};
    const url = "/iam/v4/public/namespaces/{namespace}/users/me/mfa/authenticator/enable".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.post(url, import_sdk63.CodeGenUtil.getFormUrlEncodedData(data), {
      ...params,
      headers: { ...params.headers, "content-type": "application/x-www-form-urlencoded" }
    });
    return import_sdk63.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, import_zod242.z.unknown(), "z.unknown()");
  }
  /**
   * This endpoint is used to disable 2FA authenticator. ------ **Note**: **mfaToken** is required when all the following are enabled: - The environment variable **SENSITIVE_MFA_AUTH_ENABLED** is true - The **Two-Factor Authentication** is enabled in the IAM client where user logs in - Users already enabled the MFA
   */
  deleteUserMeMfaAuthenticatorDisable_v4(data) {
    const params = {};
    const url = "/iam/v4/public/namespaces/{namespace}/users/me/mfa/authenticator/disable".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.delete(url, { data, params });
    return import_sdk63.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, import_zod242.z.unknown(), "z.unknown()");
  }
};

// src/generated-public/UsersV4Api.ts
function UsersV4Api(sdk, args) {
  const sdkAssembly = sdk.assembly();
  const namespace = args?.coreConfig?.namespace ?? sdkAssembly.coreConfig.namespace;
  const useSchemaValidation = args?.coreConfig?.useSchemaValidation ?? sdkAssembly.coreConfig.useSchemaValidation;
  let axiosInstance = sdkAssembly.axiosInstance;
  const requestConfigOverrides = args?.axiosConfig?.request;
  const baseURLOverride = args?.coreConfig?.baseURL;
  const interceptorsOverride = args?.axiosConfig?.interceptors ?? [];
  if (requestConfigOverrides || baseURLOverride || interceptorsOverride.length > 0) {
    const requestConfig = import_sdk64.ApiUtils.mergeAxiosConfigs(sdkAssembly.axiosInstance.defaults, {
      ...baseURLOverride ? { baseURL: baseURLOverride } : {},
      ...requestConfigOverrides
    });
    axiosInstance = import_sdk64.Network.create(requestConfig);
    for (const interceptor of interceptorsOverride) {
      if (interceptor.type === "request") {
        axiosInstance.interceptors.request.use(interceptor.onRequest, interceptor.onError);
      }
      if (interceptor.type === "response") {
        axiosInstance.interceptors.response.use(interceptor.onSuccess, interceptor.onError);
      }
    }
  }
  async function createUserInvite_v4(data) {
    const $ = new UsersV4$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.createUserInvite_v4(data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function createUser_v4(data) {
    const $ = new UsersV4$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.createUser_v4(data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function patchUserMe_v4(data) {
    const $ = new UsersV4$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.patchUserMe_v4(data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function createTestUser_v4(data) {
    const $ = new UsersV4$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.createTestUser_v4(data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getUser_ByUserId_v4(userId) {
    const $ = new UsersV4$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getUser_ByUserId_v4(userId);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function updateUserMeEmail_v4(data) {
    const $ = new UsersV4$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.updateUserMeEmail_v4(data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function deleteUserMeMfaDevice_v4() {
    const $ = new UsersV4$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.deleteUserMeMfaDevice_v4();
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getUsersMeMfaFactor_v4() {
    const $ = new UsersV4$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getUsersMeMfaFactor_v4();
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function postUserMeMfaFactor_v4(data) {
    const $ = new UsersV4$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.postUserMeMfaFactor_v4(data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getUsersMeMfaStatus_v4() {
    const $ = new UsersV4$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getUsersMeMfaStatus_v4();
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function createUserMeMfaStatus_v4() {
    const $ = new UsersV4$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.createUserMeMfaStatus_v4();
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getUsersMeMfaBackupCode_v4() {
    const $ = new UsersV4$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getUsersMeMfaBackupCode_v4();
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function createUserMeMfaBackupCode_v4() {
    const $ = new UsersV4$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.createUserMeMfaBackupCode_v4();
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function postUserMeMfaEmailCode_v4(data) {
    const $ = new UsersV4$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.postUserMeMfaEmailCode_v4(data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function createUserMeHeadlesVerify_v4(data) {
    const $ = new UsersV4$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.createUserMeHeadlesVerify_v4(data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getUsersMeMfaBackupCodes_v4(queryParams) {
    const $ = new UsersV4$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getUsersMeMfaBackupCodes_v4(queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function createUserMeMfaBackupCode_ByNS_v4(queryParams) {
    const $ = new UsersV4$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.createUserMeMfaBackupCode_ByNS_v4(queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function postUserMeMfaEmailEnable_v4(data) {
    const $ = new UsersV4$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.postUserMeMfaEmailEnable_v4(data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function createUserMeMfaEmailDisable_v4(data) {
    const $ = new UsersV4$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.createUserMeMfaEmailDisable_v4(data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function createUserInvite_ByInvitationId_v4(invitationId, data) {
    const $ = new UsersV4$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.createUserInvite_ByInvitationId_v4(invitationId, data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function createUser_ByPlatformId_v4(platformId, data, queryParams) {
    const $ = new UsersV4$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.createUser_ByPlatformId_v4(platformId, data, queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function createUserMeHeadlesCodeVerify_v4(data) {
    const $ = new UsersV4$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.createUserMeHeadlesCodeVerify_v4(data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function postUserMeMfaChallengeVerify_v4(data) {
    const $ = new UsersV4$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.postUserMeMfaChallengeVerify_v4(data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function createUserMeMfaAuthenticatorKey_v4() {
    const $ = new UsersV4$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.createUserMeMfaAuthenticatorKey_v4();
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function createUserMeMfaBackupCodeEnable_v4() {
    const $ = new UsersV4$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.createUserMeMfaBackupCodeEnable_v4();
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function deleteUserMeMfaBackupCodeDisable_v4(data) {
    const $ = new UsersV4$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.deleteUserMeMfaBackupCodeDisable_v4(data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function createUserMeMfaBackupCodeEnable_ByNS_v4(queryParams) {
    const $ = new UsersV4$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.createUserMeMfaBackupCodeEnable_ByNS_v4(queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getUsersMeMfaBackupCodeDownload_v4() {
    const $ = new UsersV4$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getUsersMeMfaBackupCodeDownload_v4();
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function postUserMeMfaAuthenticatorEnable_v4(data) {
    const $ = new UsersV4$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.postUserMeMfaAuthenticatorEnable_v4(data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function deleteUserMeMfaAuthenticatorDisable_v4(data) {
    const $ = new UsersV4$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.deleteUserMeMfaAuthenticatorDisable_v4(data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  return {
    /**
     * This endpoint is used to invite a game studio admin user with new namespace in multi tenant mode. It will return error if the service multi tenant mode is set to false. Request body details: - emailAddress: email address of the user to be invited - namespace: new namespace of the user to be created - namespaceDisplayName: display name of the new namespace - additionalData(optional): for utm parameter data The invited users will also be assigned with &#34;User&#34; role by default.
     */
    createUserInvite_v4,
    /**
     * Create a new user with unique email address and username. **Required attributes:** - authType: possible value is EMAILPASSWD - emailAddress: Please refer to the rule from /v3/public/inputValidations API. - username: Please refer to the rule from /v3/public/inputValidations API. - password: Please refer to the rule from /v3/public/inputValidations API. - country: ISO3166-1 alpha-2 two letter, e.g. US. - dateOfBirth: YYYY-MM-DD, e.g. 1990-01-01. valid values are between 1905-01-01 until current date. - uniqueDisplayName: required when uniqueDisplayNameEnabled/UNIQUE_DISPLAY_NAME_ENABLED is true, please refer to the rule from /v3/public/inputValidations API. - code: required when mandatoryEmailVerificationEnabled config is true, please refer to the config from /iam/v3/public/namespaces/{namespace}/config/{configKey} [GET] API. **Not required attributes:** - displayName: Please refer to the rule from /v3/public/inputValidations API. This endpoint support accepting agreements for the created user. Supply the accepted agreements in acceptedPolicies attribute.
     */
    createUser_v4,
    /**
     * This Endpoint support update user based on given data. **Single request can update single field or multi fields.** Supported field {country, displayName, languageTag, dateOfBirth, avatarUrl, userName} Country use ISO3166-1 alpha-2 two letter, e.g. US. Date of Birth format : YYYY-MM-DD, e.g. 2019-04-29. **Response body logic when user updating email address:** - User want to update email address of which have been verified, newEmailAddress response field will be filled with new email address. - User want to update email address of which have not been verified, { oldEmailAddress, emailAddress} response field will be filled with new email address. - User want to update email address of which have been verified and updated before, { oldEmailAddress, emailAddress} response field will be filled with verified email before. newEmailAddress response field will be filled with newest email address. action code : 10103
     */
    patchUserMe_v4,
    /**
     * Create a test user and not send verification code email **Required attributes:** - verified: this new user is verified or not - authType: possible value is EMAILPASSWD - emailAddress: Please refer to the rule from /v3/public/inputValidations API. - username: Please refer to the rule from /v3/public/inputValidations API. - password: Please refer to the rule from /v3/public/inputValidations API. - country: ISO3166-1 alpha-2 two letter, e.g. US. - dateOfBirth: YYYY-MM-DD, e.g. 1990-01-01. valid values are between 1905-01-01 until current date. **Not required attributes:** - displayName: Please refer to the rule from /v3/public/inputValidations API. This endpoint support accepting agreements for the created user. Supply the accepted agreements in acceptedPolicies attribute.
     */
    createTestUser_v4,
    /**
     * This endpoint only returns user&#39;s public information. action code: 10129
     */
    getUser_ByUserId_v4,
    /**
     * The endpoint to update my email address. It requires a verification code from &lt;code&gt;/users/me/code/request&lt;/code&gt; with **UpdateEmailAddress** context.
     */
    updateUserMeEmail_v4,
    /**
     * (Only for test)This endpoint is used to remove trusted device. This endpoint Requires device_token in cookie
     */
    deleteUserMeMfaDevice_v4,
    /**
     * This endpoint is used to get user enabled factors.
     */
    getUsersMeMfaFactor_v4,
    /**
     * This endpoint is used to make 2FA factor default.
     */
    postUserMeMfaFactor_v4,
    /**
     * This endpoint will get user&#39;s&#39; MFA status.
     */
    getUsersMeMfaStatus_v4,
    /**
     * @deprecated
     * This endpoint will get user&#39;s&#39; MFA status. --------- **Substitute endpoint**: /iam/v4/public/namespaces/{namespace}/users/me/mfa/status [GET]
     */
    createUserMeMfaStatus_v4,
    /**
     * @deprecated
     * This endpoint is used to get 8-digits backup codes. Each code is a one-time code and will be deleted once used.
     */
    getUsersMeMfaBackupCode_v4,
    /**
     * @deprecated
     * This endpoint is used to generate 8-digits backup codes. Each code is a one-time code and will be deleted once used.
     */
    createUserMeMfaBackupCode_v4,
    /**
     * This endpoint is used to send email code. ---------------- Supported values of action: * ChangePassword * DisableMFAEmail
     */
    postUserMeMfaEmailCode_v4,
    /**
     * Upgrade headless account to full account without verifying email address. Client does not need to provide verification code which sent to email address. action code : 10124
     */
    createUserMeHeadlesVerify_v4,
    /**
     * This endpoint is used to get existing 8-digits backup codes. Each codes is a one-time code and will be deleted once used. The codes will be sent through linked email.
     */
    getUsersMeMfaBackupCodes_v4,
    /**
     * This endpoint is used to generate 8-digits backup codes. Each codes is a one-time code and will be deleted once used. The codes will be sent through linked email.
     */
    createUserMeMfaBackupCode_ByNS_v4,
    /**
     * This endpoint is used to enable 2FA email.
     */
    postUserMeMfaEmailEnable_v4,
    /**
     * This endpoint is used to disable 2FA email. ------ **Note**: **mfaToken** is required when all the following are enabled: - The environment variable **SENSITIVE_MFA_AUTH_ENABLED** is true - The **Two-Factor Authentication** is enabled in the IAM client where user logs in - Users already enabled the MFA
     */
    createUserMeMfaEmailDisable_v4,
    /**
     * This endpoint create user from saved roles when creating invitation and submitted data. User will be able to login after completing submitting the data through this endpoint. Available Authentication Types: EMAILPASSWD: an authentication type used for new user registration through email. **Note**: * **uniqueDisplayName**: this is required when uniqueDisplayNameEnabled/UNIQUE_DISPLAY_NAME_ENABLED is true. Country use ISO3166-1 alpha-2 two letter, e.g. US. Date of Birth format : YYYY-MM-DD, e.g. 2019-04-29. Required attributes: - authType: possible value is EMAILPASSWD (see above) - country: ISO3166-1 alpha-2 two letter, e.g. US. - dateOfBirth: YYYY-MM-DD, e.g. 1990-01-01. valid values are between 1905-01-01 until current date. - displayName: Please refer to the rule from /v3/public/inputValidations API. - password: Please refer to the rule from /v3/public/inputValidations API. - username: Please refer to the rule from /v3/public/inputValidations API.
     */
    createUserInvite_ByInvitationId_v4,
    /**
     * List User ID By Platform User ID This endpoint intended to list game user ID from the given namespace This endpoint return list of user ID by given platform ID and list of platform user ID, the max count is 100. Supported platform: - steam - steamopenid - ps4web - ps4 - ps5 - live - xblweb - oculus - oculusweb - facebook - google - googleplaygames - twitch - discord - apple - device - justice - epicgames - nintendo - awscognito - netflix - snapchat - oidc platform id Note: **nintendo platform user ID**: NSA ID need to be appended with Environment ID using colon as separator. e.g kmzwa8awaa:dd1 &lt;br&gt; If the request body exceed the max limitation, the max count will be in response body&#39;s messageVariables: &#34;messageVariables&#34;: {&#34;maxCount&#34;: &#34;100&#34;}
     */
    createUser_ByPlatformId_v4,
    /**
     *  The endpoint upgrades a headless account by linking the headless account with the email address, username, and password. By upgrading the headless account into a full account, the user could use the email address, username, and password for using Justice IAM. The endpoint is a shortcut for upgrading a headless account and verifying the email address in one call. In order to get a verification code for the endpoint, please check the [send verification code endpoint](#operations-Users-PublicSendVerificationCodeV3). This endpoint also have an ability to update user data (if the user data field is specified) right after the upgrade account process is done. Supported user data fields: - displayName - dateOfBirth : format YYYY-MM-DD, e.g. 2019-04-29 - country : format ISO3166-1 alpha-2 two letter, e.g. US action code : 10124
     */
    createUserMeHeadlesCodeVerify_v4,
    /**
     * This endpoint will verify user&#39;s&#39; MFA code and generate a MFA token for the action.
     */
    postUserMeMfaChallengeVerify_v4,
    /**
     * This endpoint is used to generate a secret key for 3rd-party authenticator app. A QR code URI is also returned so that frontend can generate QR code image.
     */
    createUserMeMfaAuthenticatorKey_v4,
    /**
     * @deprecated
     * This endpoint is used to enable 2FA backup codes.
     */
    createUserMeMfaBackupCodeEnable_v4,
    /**
     * This endpoint is used to disable 2FA backup codes. ------ **Note**: **mfaToken** is required when all the following are enabled: - The environment variable **SENSITIVE_MFA_AUTH_ENABLED** is true - The **Two-Factor Authentication** is enabled in the IAM client where user logs in - Users already enabled the MFA
     */
    deleteUserMeMfaBackupCodeDisable_v4,
    /**
     * This endpoint is used to enable 2FA backup codes.
     */
    createUserMeMfaBackupCodeEnable_ByNS_v4,
    /**
     * @deprecated
     * This endpoint is used to download backup codes.
     */
    getUsersMeMfaBackupCodeDownload_v4,
    /**
     * This endpoint is used to enable 2FA authenticator. ---------- Prerequisites: - Generate the secret key/QR code uri by **_/iam/v4/public/namespaces/{namespace}/users/me/mfa/authenticator/key_** - Consume the secret key/QR code by an authenticator app - Get the code from the authenticator app
     */
    postUserMeMfaAuthenticatorEnable_v4,
    /**
     * This endpoint is used to disable 2FA authenticator. ------ **Note**: **mfaToken** is required when all the following are enabled: - The environment variable **SENSITIVE_MFA_AUTH_ENABLED** is true - The **Two-Factor Authentication** is enabled in the IAM client where user logs in - Users already enabled the MFA
     */
    deleteUserMeMfaAuthenticatorDisable_v4
  };
}

// src/generated-public/queries/UsersV4.query.ts
var Key_UsersV4 = /* @__PURE__ */ ((Key_UsersV42) => {
  Key_UsersV42["UserInvite_v4"] = "Iam.UsersV4.UserInvite_v4";
  Key_UsersV42["User_v4"] = "Iam.UsersV4.User_v4";
  Key_UsersV42["UserMe_v4"] = "Iam.UsersV4.UserMe_v4";
  Key_UsersV42["TestUser_v4"] = "Iam.UsersV4.TestUser_v4";
  Key_UsersV42["User_ByUserId_v4"] = "Iam.UsersV4.User_ByUserId_v4";
  Key_UsersV42["UserMeEmail_v4"] = "Iam.UsersV4.UserMeEmail_v4";
  Key_UsersV42["UserMeMfaDevice_v4"] = "Iam.UsersV4.UserMeMfaDevice_v4";
  Key_UsersV42["UsersMeMfaFactor_v4"] = "Iam.UsersV4.UsersMeMfaFactor_v4";
  Key_UsersV42["UserMeMfaFactor_v4"] = "Iam.UsersV4.UserMeMfaFactor_v4";
  Key_UsersV42["UsersMeMfaStatus_v4"] = "Iam.UsersV4.UsersMeMfaStatus_v4";
  Key_UsersV42["UserMeMfaStatus_v4"] = "Iam.UsersV4.UserMeMfaStatus_v4";
  Key_UsersV42["UsersMeMfaBackupCode_v4"] = "Iam.UsersV4.UsersMeMfaBackupCode_v4";
  Key_UsersV42["UserMeMfaBackupCode_v4"] = "Iam.UsersV4.UserMeMfaBackupCode_v4";
  Key_UsersV42["UserMeMfaEmailCode_v4"] = "Iam.UsersV4.UserMeMfaEmailCode_v4";
  Key_UsersV42["UserMeHeadlesVerify_v4"] = "Iam.UsersV4.UserMeHeadlesVerify_v4";
  Key_UsersV42["UsersMeMfaBackupCodes_v4"] = "Iam.UsersV4.UsersMeMfaBackupCodes_v4";
  Key_UsersV42["UserMeMfaBackupCode_ByNS_v4"] = "Iam.UsersV4.UserMeMfaBackupCode_ByNS_v4";
  Key_UsersV42["UserMeMfaEmailEnable_v4"] = "Iam.UsersV4.UserMeMfaEmailEnable_v4";
  Key_UsersV42["UserMeMfaEmailDisable_v4"] = "Iam.UsersV4.UserMeMfaEmailDisable_v4";
  Key_UsersV42["UserInvite_ByInvitationId_v4"] = "Iam.UsersV4.UserInvite_ByInvitationId_v4";
  Key_UsersV42["User_ByPlatformId_v4"] = "Iam.UsersV4.User_ByPlatformId_v4";
  Key_UsersV42["UserMeHeadlesCodeVerify_v4"] = "Iam.UsersV4.UserMeHeadlesCodeVerify_v4";
  Key_UsersV42["UserMeMfaChallengeVerify_v4"] = "Iam.UsersV4.UserMeMfaChallengeVerify_v4";
  Key_UsersV42["UserMeMfaAuthenticatorKey_v4"] = "Iam.UsersV4.UserMeMfaAuthenticatorKey_v4";
  Key_UsersV42["UserMeMfaBackupCodeEnable_v4"] = "Iam.UsersV4.UserMeMfaBackupCodeEnable_v4";
  Key_UsersV42["UserMeMfaBackupCodeDisable_v4"] = "Iam.UsersV4.UserMeMfaBackupCodeDisable_v4";
  Key_UsersV42["UserMeMfaBackupCodeEnable_ByNS_v4"] = "Iam.UsersV4.UserMeMfaBackupCodeEnable_ByNS_v4";
  Key_UsersV42["UsersMeMfaBackupCodeDownload_v4"] = "Iam.UsersV4.UsersMeMfaBackupCodeDownload_v4";
  Key_UsersV42["UserMeMfaAuthenticatorEnable_v4"] = "Iam.UsersV4.UserMeMfaAuthenticatorEnable_v4";
  Key_UsersV42["UserMeMfaAuthenticatorDisable_v4"] = "Iam.UsersV4.UserMeMfaAuthenticatorDisable_v4";
  return Key_UsersV42;
})(Key_UsersV4 || {});
var useUsersV4Api_CreateUserInviteMutation_v4 = (sdk, options, callback) => {
  const mutationFn = async (input) => {
    const response = await UsersV4Api(sdk, { coreConfig: input.coreConfig, axiosConfig: input.axiosConfig }).createUserInvite_v4(input.data);
    callback && callback(response.data);
    return response.data;
  };
  return (0, import_react_query32.useMutation)({
    mutationKey: ["Iam.UsersV4.UserInvite_v4" /* UserInvite_v4 */],
    mutationFn,
    ...options
  });
};
var useUsersV4Api_CreateUserMutation_v4 = (sdk, options, callback) => {
  const mutationFn = async (input) => {
    const response = await UsersV4Api(sdk, { coreConfig: input.coreConfig, axiosConfig: input.axiosConfig }).createUser_v4(input.data);
    callback && callback(response.data);
    return response.data;
  };
  return (0, import_react_query32.useMutation)({
    mutationKey: ["Iam.UsersV4.User_v4" /* User_v4 */],
    mutationFn,
    ...options
  });
};
var useUsersV4Api_PatchUserMeMutation_v4 = (sdk, options, callback) => {
  const mutationFn = async (input) => {
    const response = await UsersV4Api(sdk, { coreConfig: input.coreConfig, axiosConfig: input.axiosConfig }).patchUserMe_v4(input.data);
    callback && callback(response.data);
    return response.data;
  };
  return (0, import_react_query32.useMutation)({
    mutationKey: ["Iam.UsersV4.UserMe_v4" /* UserMe_v4 */],
    mutationFn,
    ...options
  });
};
var useUsersV4Api_CreateTestUserMutation_v4 = (sdk, options, callback) => {
  const mutationFn = async (input) => {
    const response = await UsersV4Api(sdk, { coreConfig: input.coreConfig, axiosConfig: input.axiosConfig }).createTestUser_v4(input.data);
    callback && callback(response.data);
    return response.data;
  };
  return (0, import_react_query32.useMutation)({
    mutationKey: ["Iam.UsersV4.TestUser_v4" /* TestUser_v4 */],
    mutationFn,
    ...options
  });
};
var useUsersV4Api_GetUser_ByUserId_v4 = (sdk, input, options, callback) => {
  const queryFn = (sdk2, input2) => async () => {
    const response = await UsersV4Api(sdk2, { coreConfig: input2.coreConfig, axiosConfig: input2.axiosConfig }).getUser_ByUserId_v4(
      input2.userId
    );
    callback && callback(response);
    return response.data;
  };
  return (0, import_react_query32.useQuery)({
    queryKey: ["Iam.UsersV4.User_ByUserId_v4" /* User_ByUserId_v4 */, input],
    queryFn: queryFn(sdk, input),
    ...options
  });
};
var useUsersV4Api_UpdateUserMeEmailMutation_v4 = (sdk, options, callback) => {
  const mutationFn = async (input) => {
    const response = await UsersV4Api(sdk, { coreConfig: input.coreConfig, axiosConfig: input.axiosConfig }).updateUserMeEmail_v4(
      input.data
    );
    callback && callback(response.data);
    return response.data;
  };
  return (0, import_react_query32.useMutation)({
    mutationKey: ["Iam.UsersV4.UserMeEmail_v4" /* UserMeEmail_v4 */],
    mutationFn,
    ...options
  });
};
var useUsersV4Api_DeleteUserMeMfaDeviceMutation_v4 = (sdk, options, callback) => {
  const mutationFn = async (input) => {
    const response = await UsersV4Api(sdk, { coreConfig: input.coreConfig, axiosConfig: input.axiosConfig }).deleteUserMeMfaDevice_v4();
    callback && callback(response.data);
    return response.data;
  };
  return (0, import_react_query32.useMutation)({
    mutationKey: ["Iam.UsersV4.UserMeMfaDevice_v4" /* UserMeMfaDevice_v4 */],
    mutationFn,
    ...options
  });
};
var useUsersV4Api_GetUsersMeMfaFactor_v4 = (sdk, input, options, callback) => {
  const queryFn = (sdk2, input2) => async () => {
    const response = await UsersV4Api(sdk2, { coreConfig: input2.coreConfig, axiosConfig: input2.axiosConfig }).getUsersMeMfaFactor_v4();
    callback && callback(response);
    return response.data;
  };
  return (0, import_react_query32.useQuery)({
    queryKey: ["Iam.UsersV4.UsersMeMfaFactor_v4" /* UsersMeMfaFactor_v4 */, input],
    queryFn: queryFn(sdk, input),
    ...options
  });
};
var useUsersV4Api_PostUserMeMfaFactorMutation_v4 = (sdk, options, callback) => {
  const mutationFn = async (input) => {
    const response = await UsersV4Api(sdk, { coreConfig: input.coreConfig, axiosConfig: input.axiosConfig }).postUserMeMfaFactor_v4(
      input.data
    );
    callback && callback(response.data);
    return response.data;
  };
  return (0, import_react_query32.useMutation)({
    mutationKey: ["Iam.UsersV4.UserMeMfaFactor_v4" /* UserMeMfaFactor_v4 */],
    mutationFn,
    ...options
  });
};
var useUsersV4Api_GetUsersMeMfaStatus_v4 = (sdk, input, options, callback) => {
  const queryFn = (sdk2, input2) => async () => {
    const response = await UsersV4Api(sdk2, { coreConfig: input2.coreConfig, axiosConfig: input2.axiosConfig }).getUsersMeMfaStatus_v4();
    callback && callback(response);
    return response.data;
  };
  return (0, import_react_query32.useQuery)({
    queryKey: ["Iam.UsersV4.UsersMeMfaStatus_v4" /* UsersMeMfaStatus_v4 */, input],
    queryFn: queryFn(sdk, input),
    ...options
  });
};
var useUsersV4Api_CreateUserMeMfaStatusMutation_v4 = (sdk, options, callback) => {
  const mutationFn = async (input) => {
    const response = await UsersV4Api(sdk, { coreConfig: input.coreConfig, axiosConfig: input.axiosConfig }).createUserMeMfaStatus_v4();
    callback && callback(response.data);
    return response.data;
  };
  return (0, import_react_query32.useMutation)({
    mutationKey: ["Iam.UsersV4.UserMeMfaStatus_v4" /* UserMeMfaStatus_v4 */],
    mutationFn,
    ...options
  });
};
var useUsersV4Api_GetUsersMeMfaBackupCode_v4 = (sdk, input, options, callback) => {
  const queryFn = (sdk2, input2) => async () => {
    const response = await UsersV4Api(sdk2, { coreConfig: input2.coreConfig, axiosConfig: input2.axiosConfig }).getUsersMeMfaBackupCode_v4();
    callback && callback(response);
    return response.data;
  };
  return (0, import_react_query32.useQuery)({
    queryKey: ["Iam.UsersV4.UsersMeMfaBackupCode_v4" /* UsersMeMfaBackupCode_v4 */, input],
    queryFn: queryFn(sdk, input),
    ...options
  });
};
var useUsersV4Api_CreateUserMeMfaBackupCodeMutation_v4 = (sdk, options, callback) => {
  const mutationFn = async (input) => {
    const response = await UsersV4Api(sdk, { coreConfig: input.coreConfig, axiosConfig: input.axiosConfig }).createUserMeMfaBackupCode_v4();
    callback && callback(response.data);
    return response.data;
  };
  return (0, import_react_query32.useMutation)({
    mutationKey: ["Iam.UsersV4.UserMeMfaBackupCode_v4" /* UserMeMfaBackupCode_v4 */],
    mutationFn,
    ...options
  });
};
var useUsersV4Api_PostUserMeMfaEmailCodeMutation_v4 = (sdk, options, callback) => {
  const mutationFn = async (input) => {
    const response = await UsersV4Api(sdk, { coreConfig: input.coreConfig, axiosConfig: input.axiosConfig }).postUserMeMfaEmailCode_v4(
      input.data
    );
    callback && callback(response.data);
    return response.data;
  };
  return (0, import_react_query32.useMutation)({
    mutationKey: ["Iam.UsersV4.UserMeMfaEmailCode_v4" /* UserMeMfaEmailCode_v4 */],
    mutationFn,
    ...options
  });
};
var useUsersV4Api_CreateUserMeHeadlesVerifyMutation_v4 = (sdk, options, callback) => {
  const mutationFn = async (input) => {
    const response = await UsersV4Api(sdk, { coreConfig: input.coreConfig, axiosConfig: input.axiosConfig }).createUserMeHeadlesVerify_v4(
      input.data
    );
    callback && callback(response.data);
    return response.data;
  };
  return (0, import_react_query32.useMutation)({
    mutationKey: ["Iam.UsersV4.UserMeHeadlesVerify_v4" /* UserMeHeadlesVerify_v4 */],
    mutationFn,
    ...options
  });
};
var useUsersV4Api_GetUsersMeMfaBackupCodes_v4 = (sdk, input, options, callback) => {
  const queryFn = (sdk2, input2) => async () => {
    const response = await UsersV4Api(sdk2, { coreConfig: input2.coreConfig, axiosConfig: input2.axiosConfig }).getUsersMeMfaBackupCodes_v4(
      input2.queryParams
    );
    callback && callback(response);
    return response.data;
  };
  return (0, import_react_query32.useQuery)({
    queryKey: ["Iam.UsersV4.UsersMeMfaBackupCodes_v4" /* UsersMeMfaBackupCodes_v4 */, input],
    queryFn: queryFn(sdk, input),
    ...options
  });
};
var useUsersV4Api_CreateUserMeMfaBackupCode_ByNSMutation_v4 = (sdk, options, callback) => {
  const mutationFn = async (input) => {
    const response = await UsersV4Api(sdk, {
      coreConfig: input.coreConfig,
      axiosConfig: input.axiosConfig
    }).createUserMeMfaBackupCode_ByNS_v4(input.queryParams);
    callback && callback(response.data);
    return response.data;
  };
  return (0, import_react_query32.useMutation)({
    mutationKey: ["Iam.UsersV4.UserMeMfaBackupCode_ByNS_v4" /* UserMeMfaBackupCode_ByNS_v4 */],
    mutationFn,
    ...options
  });
};
var useUsersV4Api_PostUserMeMfaEmailEnableMutation_v4 = (sdk, options, callback) => {
  const mutationFn = async (input) => {
    const response = await UsersV4Api(sdk, { coreConfig: input.coreConfig, axiosConfig: input.axiosConfig }).postUserMeMfaEmailEnable_v4(
      input.data
    );
    callback && callback(response.data);
    return response.data;
  };
  return (0, import_react_query32.useMutation)({
    mutationKey: ["Iam.UsersV4.UserMeMfaEmailEnable_v4" /* UserMeMfaEmailEnable_v4 */],
    mutationFn,
    ...options
  });
};
var useUsersV4Api_CreateUserMeMfaEmailDisableMutation_v4 = (sdk, options, callback) => {
  const mutationFn = async (input) => {
    const response = await UsersV4Api(sdk, { coreConfig: input.coreConfig, axiosConfig: input.axiosConfig }).createUserMeMfaEmailDisable_v4(
      input.data
    );
    callback && callback(response.data);
    return response.data;
  };
  return (0, import_react_query32.useMutation)({
    mutationKey: ["Iam.UsersV4.UserMeMfaEmailDisable_v4" /* UserMeMfaEmailDisable_v4 */],
    mutationFn,
    ...options
  });
};
var useUsersV4Api_CreateUserInvite_ByInvitationIdMutation_v4 = (sdk, options, callback) => {
  const mutationFn = async (input) => {
    const response = await UsersV4Api(sdk, {
      coreConfig: input.coreConfig,
      axiosConfig: input.axiosConfig
    }).createUserInvite_ByInvitationId_v4(input.invitationId, input.data);
    callback && callback(response.data);
    return response.data;
  };
  return (0, import_react_query32.useMutation)({
    mutationKey: ["Iam.UsersV4.UserInvite_ByInvitationId_v4" /* UserInvite_ByInvitationId_v4 */],
    mutationFn,
    ...options
  });
};
var useUsersV4Api_CreateUser_ByPlatformIdMutation_v4 = (sdk, options, callback) => {
  const mutationFn = async (input) => {
    const response = await UsersV4Api(sdk, { coreConfig: input.coreConfig, axiosConfig: input.axiosConfig }).createUser_ByPlatformId_v4(
      input.platformId,
      input.data,
      input.queryParams
    );
    callback && callback(response.data);
    return response.data;
  };
  return (0, import_react_query32.useMutation)({
    mutationKey: ["Iam.UsersV4.User_ByPlatformId_v4" /* User_ByPlatformId_v4 */],
    mutationFn,
    ...options
  });
};
var useUsersV4Api_CreateUserMeHeadlesCodeVerifyMutation_v4 = (sdk, options, callback) => {
  const mutationFn = async (input) => {
    const response = await UsersV4Api(sdk, {
      coreConfig: input.coreConfig,
      axiosConfig: input.axiosConfig
    }).createUserMeHeadlesCodeVerify_v4(input.data);
    callback && callback(response.data);
    return response.data;
  };
  return (0, import_react_query32.useMutation)({
    mutationKey: ["Iam.UsersV4.UserMeHeadlesCodeVerify_v4" /* UserMeHeadlesCodeVerify_v4 */],
    mutationFn,
    ...options
  });
};
var useUsersV4Api_PostUserMeMfaChallengeVerifyMutation_v4 = (sdk, options, callback) => {
  const mutationFn = async (input) => {
    const response = await UsersV4Api(sdk, {
      coreConfig: input.coreConfig,
      axiosConfig: input.axiosConfig
    }).postUserMeMfaChallengeVerify_v4(input.data);
    callback && callback(response.data);
    return response.data;
  };
  return (0, import_react_query32.useMutation)({
    mutationKey: ["Iam.UsersV4.UserMeMfaChallengeVerify_v4" /* UserMeMfaChallengeVerify_v4 */],
    mutationFn,
    ...options
  });
};
var useUsersV4Api_CreateUserMeMfaAuthenticatorKeyMutation_v4 = (sdk, options, callback) => {
  const mutationFn = async (input) => {
    const response = await UsersV4Api(sdk, {
      coreConfig: input.coreConfig,
      axiosConfig: input.axiosConfig
    }).createUserMeMfaAuthenticatorKey_v4();
    callback && callback(response.data);
    return response.data;
  };
  return (0, import_react_query32.useMutation)({
    mutationKey: ["Iam.UsersV4.UserMeMfaAuthenticatorKey_v4" /* UserMeMfaAuthenticatorKey_v4 */],
    mutationFn,
    ...options
  });
};
var useUsersV4Api_CreateUserMeMfaBackupCodeEnableMutation_v4 = (sdk, options, callback) => {
  const mutationFn = async (input) => {
    const response = await UsersV4Api(sdk, {
      coreConfig: input.coreConfig,
      axiosConfig: input.axiosConfig
    }).createUserMeMfaBackupCodeEnable_v4();
    callback && callback(response.data);
    return response.data;
  };
  return (0, import_react_query32.useMutation)({
    mutationKey: ["Iam.UsersV4.UserMeMfaBackupCodeEnable_v4" /* UserMeMfaBackupCodeEnable_v4 */],
    mutationFn,
    ...options
  });
};
var useUsersV4Api_DeleteUserMeMfaBackupCodeDisableMutation_v4 = (sdk, options, callback) => {
  const mutationFn = async (input) => {
    const response = await UsersV4Api(sdk, {
      coreConfig: input.coreConfig,
      axiosConfig: input.axiosConfig
    }).deleteUserMeMfaBackupCodeDisable_v4(input.data);
    callback && callback(response.data);
    return response.data;
  };
  return (0, import_react_query32.useMutation)({
    mutationKey: ["Iam.UsersV4.UserMeMfaBackupCodeDisable_v4" /* UserMeMfaBackupCodeDisable_v4 */],
    mutationFn,
    ...options
  });
};
var useUsersV4Api_CreateUserMeMfaBackupCodeEnable_ByNSMutation_v4 = (sdk, options, callback) => {
  const mutationFn = async (input) => {
    const response = await UsersV4Api(sdk, {
      coreConfig: input.coreConfig,
      axiosConfig: input.axiosConfig
    }).createUserMeMfaBackupCodeEnable_ByNS_v4(input.queryParams);
    callback && callback(response.data);
    return response.data;
  };
  return (0, import_react_query32.useMutation)({
    mutationKey: ["Iam.UsersV4.UserMeMfaBackupCodeEnable_ByNS_v4" /* UserMeMfaBackupCodeEnable_ByNS_v4 */],
    mutationFn,
    ...options
  });
};
var useUsersV4Api_GetUsersMeMfaBackupCodeDownload_v4 = (sdk, input, options, callback) => {
  const queryFn = (sdk2, input2) => async () => {
    const response = await UsersV4Api(sdk2, {
      coreConfig: input2.coreConfig,
      axiosConfig: input2.axiosConfig
    }).getUsersMeMfaBackupCodeDownload_v4();
    callback && callback(response);
    return response.data;
  };
  return (0, import_react_query32.useQuery)({
    queryKey: ["Iam.UsersV4.UsersMeMfaBackupCodeDownload_v4" /* UsersMeMfaBackupCodeDownload_v4 */, input],
    queryFn: queryFn(sdk, input),
    ...options
  });
};
var useUsersV4Api_PostUserMeMfaAuthenticatorEnableMutation_v4 = (sdk, options, callback) => {
  const mutationFn = async (input) => {
    const response = await UsersV4Api(sdk, {
      coreConfig: input.coreConfig,
      axiosConfig: input.axiosConfig
    }).postUserMeMfaAuthenticatorEnable_v4(input.data);
    callback && callback(response.data);
    return response.data;
  };
  return (0, import_react_query32.useMutation)({
    mutationKey: ["Iam.UsersV4.UserMeMfaAuthenticatorEnable_v4" /* UserMeMfaAuthenticatorEnable_v4 */],
    mutationFn,
    ...options
  });
};
var useUsersV4Api_DeleteUserMeMfaAuthenticatorDisableMutation_v4 = (sdk, options, callback) => {
  const mutationFn = async (input) => {
    const response = await UsersV4Api(sdk, {
      coreConfig: input.coreConfig,
      axiosConfig: input.axiosConfig
    }).deleteUserMeMfaAuthenticatorDisable_v4(input.data);
    callback && callback(response.data);
    return response.data;
  };
  return (0, import_react_query32.useMutation)({
    mutationKey: ["Iam.UsersV4.UserMeMfaAuthenticatorDisable_v4" /* UserMeMfaAuthenticatorDisable_v4 */],
    mutationFn,
    ...options
  });
};
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  Key_Bans,
  Key_BansAdmin,
  Key_Clients,
  Key_ClientsAdmin,
  Key_ClientsConfigV3Admin,
  Key_Config,
  Key_ConfigAdmin,
  Key_Country,
  Key_CountryAdmin,
  Key_DevicesV4Admin,
  Key_InputValidations,
  Key_InputValidationsAdmin,
  Key_LoginAllowlistAdmin,
  Key_OAuth,
  Key_OAuth20,
  Key_OAuth20Admin,
  Key_OAuth20Extension,
  Key_OAuth20V4,
  Key_OverrideRoleConfigV3Admin,
  Key_ProfileUpdateStrategy,
  Key_ProfileUpdateStrategyAdmin,
  Key_Roles,
  Key_RolesAdmin,
  Key_Sso,
  Key_SsoCredentialAdmin,
  Key_SsoSaml20,
  Key_ThirdPartyCredential,
  Key_ThirdPartyCredentialAdmin,
  Key_Users,
  Key_UsersAdmin,
  Key_UsersV4,
  Key_UsersV4Admin,
  useBansAdminApi_CreateBanUserMutation_v3,
  useBansAdminApi_GetBansReasons_v3,
  useBansAdminApi_GetBansUsers_v3,
  useBansAdminApi_GetBans_v3,
  useBansAdminApi_GetBantypes_v3,
  useBansAdminApi_PatchBanUserDisabledMutation_v3,
  useBansApi_GetBans,
  useBansApi_GetBansReasons,
  useClientsAdminApi_CreateClientMutation_v3,
  useClientsAdminApi_DeleteClient_ByClientIdMutation_v3,
  useClientsAdminApi_DeletePermission_ByClientId_ByResource_ByActionMutation_v3,
  useClientsAdminApi_GetClient_ByClientId_v3,
  useClientsAdminApi_GetClients_v3,
  useClientsAdminApi_PatchClient_ByClientIdMutation_v3,
  useClientsAdminApi_UpdateClientMutation_v3,
  useClientsAdminApi_UpdatePermission_ByClientIdMutation_v3,
  useClientsAdminApi_UpdatePermission_ByClientId_ByNSMutation_v3,
  useClientsAdminApi_UpdateSecret_ByClientIdMutation_v3,
  useClientsApi_CreateClientMutation,
  useClientsApi_CreateClient_ByNSMutation,
  useClientsApi_DeleteClient_ByClientIdMutation,
  useClientsApi_DeleteClient_ByClientId_ByNSMutation,
  useClientsApi_DeleteClientpermission_ByClientId_ByResource_ByActionMutation,
  useClientsApi_GetClient_ByClientId,
  useClientsApi_GetClients,
  useClientsApi_GetClients_ByNS,
  useClientsApi_UpdateClient_ByClientIdMutation,
  useClientsApi_UpdateClientpermission_ByClientIdMutation,
  useClientsApi_UpdateClientpermission_ByClientId_ByResource_ByActionMutation,
  useClientsApi_UpdateSecret_ByClientIdMutation,
  useClientsConfigV3AdminApi_DeleteClientConfigPermissionMutation_v3,
  useClientsConfigV3AdminApi_GetClientConfigPermissions_v3,
  useClientsConfigV3AdminApi_GetClientConfigTemplates_v3,
  useClientsConfigV3AdminApi_UpdateClientConfigPermissionMutation_v3,
  useConfigAdminApi_GetConfig_ByConfigKey_v3,
  useConfigApi_GetConfig_ByConfigKey_v3,
  useCountryAdminApi_GetCountriesBlacklist_v3,
  useCountryAdminApi_GetCountries_v3,
  useCountryAdminApi_UpdateCountryBlacklistMutation_v3,
  useCountryApi_GetCountries_v3,
  useDevicesV4AdminApi_CreateDeviceBanMutation_v4,
  useDevicesV4AdminApi_GetBans_ByDeviceId_v4,
  useDevicesV4AdminApi_GetDecrypt_ByDeviceId_v4,
  useDevicesV4AdminApi_GetDeviceBan_ByBanId_v4,
  useDevicesV4AdminApi_GetDevicesBanned_v4,
  useDevicesV4AdminApi_GetDevicesBans_v4,
  useDevicesV4AdminApi_GetDevicesReport_v4,
  useDevicesV4AdminApi_GetDevicesTypes_v4,
  useDevicesV4AdminApi_GetDevices_v4,
  useDevicesV4AdminApi_GetUsers_ByDeviceId_v4,
  useDevicesV4AdminApi_UpdateDeviceBan_ByBanIdMutation_v4,
  useDevicesV4AdminApi_UpdateUnban_ByDeviceIdMutation_v4,
  useInputValidationsAdminApi_DeleteInputValidation_ByFieldMutation_v3,
  useInputValidationsAdminApi_GetInputValidations_v3,
  useInputValidationsAdminApi_UpdateInputValidationMutation_v3,
  useInputValidationsApi_GetInputValidation_ByField_v3,
  useInputValidationsApi_GetInputValidations_v3,
  useLoginAllowlistAdminApi_GetLoginAllowlist_v3,
  useLoginAllowlistAdminApi_UpdateLoginAllowlistMutation_v3,
  useOAuth20AdminApi_GetPlatformTokenOauth_ByUserId_ByPlatformId_v3,
  useOAuth20AdminApi_UpdateRevokeOauth_ByUserIdMutation_v3,
  useOAuth20Api_GetAuthorizeOauth_ByPlatformId_v3,
  useOAuth20Api_GetOauthAuthorize_v3,
  useOAuth20Api_GetOauthJwks_v3,
  useOAuth20Api_GetOauthRevocationlist_v3,
  useOAuth20Api_GetPlatformTokenOauth_ByUserId_ByPlatformId_v3,
  useOAuth20Api_PostOauthIntrospectMutation_v3,
  useOAuth20Api_PostOauthMfaCodeMutation_v3,
  useOAuth20Api_PostOauthMfaFactorChangeMutation_v3,
  useOAuth20Api_PostOauthMfaVerifyMutation_v3,
  useOAuth20Api_PostOauthRevokeMutation_v3,
  useOAuth20Api_PostOauthSimultaneousLoginMutation_v3,
  useOAuth20Api_PostOauthTokenMutation_v3,
  useOAuth20Api_PostOauthVerifyMutation_v3,
  useOAuth20Api_PostTokenOauth_ByPlatformIdMutation_v3,
  useOAuth20ExtensionApi_CreateLogoutMutation_v3,
  useOAuth20ExtensionApi_GetAuthenticate_ByPlatformId_v3,
  useOAuth20ExtensionApi_GetLocationCountry_v3,
  useOAuth20ExtensionApi_PostAuthenticateMutation_v3,
  useOAuth20ExtensionApi_PostAuthenticateWithLinkMutation_v3,
  useOAuth20ExtensionApi_PostHeadlesTokenMutation_v3,
  useOAuth20ExtensionApi_PostLinkCodeRequestMutation_v3,
  useOAuth20ExtensionApi_PostLinkCodeValidateMutation_v3,
  useOAuth20ExtensionApi_PostLinkTokenExchangeMutation_v3,
  useOAuth20ExtensionApi_PostTokenExchangeMutation_v3,
  useOAuth20ExtensionApi_PostTokenRequestMutation_v3,
  useOAuth20ExtensionApi_PostTokenVerify_ByPlatformIdMutation_v3,
  useOAuth20V4Api_PostOauthAuthenticateWithLinkMutation_v4,
  useOAuth20V4Api_PostOauthHeadlesTokenMutation_v4,
  useOAuth20V4Api_PostOauthMfaVerifyMutation_v4,
  useOAuth20V4Api_PostOauthSimultaneousLoginMutation_v4,
  useOAuth20V4Api_PostOauthTokenExchangeMutation_v4,
  useOAuth20V4Api_PostOauthTokenMutation_v4,
  useOAuth20V4Api_PostTokenOauth_ByPlatformIdMutation_v4,
  useOAuthApi_GetOauthJwks,
  useOAuthApi_GetOauthRevocationlist,
  useOAuthApi_PostOauthAuthorizeMutation,
  useOAuthApi_PostOauthRevokeTokenMutation,
  useOAuthApi_PostOauthRevokeUserMutation,
  useOAuthApi_PostOauthTokenMutation,
  useOAuthApi_PostOauthVerifyMutation,
  useOAuthApi_PostTokenOauth_ByPlatformIdMutation,
  useOAuthApi_UpdateRevokeOauth_ByUserIdMutation,
  useOverrideRoleConfigV3AdminApi_GetPermissions_ByRoleId_v3,
  useOverrideRoleConfigV3AdminApi_GetRoleoverrideSource_v3,
  useOverrideRoleConfigV3AdminApi_GetRoleoverride_v3,
  useOverrideRoleConfigV3AdminApi_PatchRoleoverrideMutation_v3,
  useOverrideRoleConfigV3AdminApi_PatchRoleoverrideStatusMutation_v3,
  useProfileUpdateStrategyAdminApi_GetProfileUpdateStrategies_v3,
  useProfileUpdateStrategyAdminApi_UpdateProfileUpdateStrategyMutation_v3,
  useProfileUpdateStrategyApi_GetProfileUpdateStrategies_v3,
  useRolesAdminApi_CreateRoleMutation_v3,
  useRolesAdminApi_CreateRoleMutation_v4,
  useRolesAdminApi_DeleteAdmin_ByRoleIdMutation_v3,
  useRolesAdminApi_DeleteManager_ByRoleIdMutation_v3,
  useRolesAdminApi_DeleteMember_ByRoleIdMutation_v3,
  useRolesAdminApi_DeletePermission_ByRoleIdMutation_v3,
  useRolesAdminApi_DeletePermission_ByRoleIdMutation_v4,
  useRolesAdminApi_DeletePermission_ByRoleId_ByResource_ByActionMutation_v3,
  useRolesAdminApi_DeleteRole_ByRoleIdMutation_v3,
  useRolesAdminApi_DeleteRole_ByRoleIdMutation_v4,
  useRolesAdminApi_DeleteUser_ByRoleIdMutation_v4,
  useRolesAdminApi_GetAdmin_ByRoleId_v3,
  useRolesAdminApi_GetManagers_ByRoleId_v3,
  useRolesAdminApi_GetMembers_ByRoleId_v3,
  useRolesAdminApi_GetRole_ByRoleId_v3,
  useRolesAdminApi_GetRole_ByRoleId_v4,
  useRolesAdminApi_GetRoles_v3,
  useRolesAdminApi_GetRoles_v4,
  useRolesAdminApi_GetUsers_ByRoleId_v4,
  useRolesAdminApi_PatchRole_ByRoleIdMutation_v3,
  useRolesAdminApi_PatchRole_ByRoleIdMutation_v4,
  useRolesAdminApi_UpdateAdmin_ByRoleIdMutation_v3,
  useRolesAdminApi_UpdateManager_ByRoleIdMutation_v3,
  useRolesAdminApi_UpdateMember_ByRoleIdMutation_v3,
  useRolesAdminApi_UpdatePermission_ByRoleIdMutation_v3,
  useRolesAdminApi_UpdatePermission_ByRoleIdMutation_v4,
  useRolesAdminApi_UpdatePermission_ByRoleId_adminMutation_v3,
  useRolesAdminApi_UpdatePermission_ByRoleId_adminMutation_v4,
  useRolesAdminApi_UpdateUser_ByRoleIdMutation_v4,
  useRolesApi_CreateRoleMutation,
  useRolesApi_DeleteAdmin_ByRoleIdMutation,
  useRolesApi_DeleteManager_ByRoleIdMutation,
  useRolesApi_DeleteMember_ByRoleIdMutation,
  useRolesApi_DeletePermission_ByRoleId_ByResource_ByActionMutation,
  useRolesApi_DeleteRole_ByRoleIdMutation,
  useRolesApi_GetAdmin_ByRoleId,
  useRolesApi_GetManagers_ByRoleId,
  useRolesApi_GetMembers_ByRoleId,
  useRolesApi_GetRole_ByRoleId,
  useRolesApi_GetRole_ByRoleId_v3,
  useRolesApi_GetRoles,
  useRolesApi_GetRoles_v3,
  useRolesApi_UpdateAdmin_ByRoleIdMutation,
  useRolesApi_UpdateManager_ByRoleIdMutation,
  useRolesApi_UpdateMember_ByRoleIdMutation,
  useRolesApi_UpdatePermission_ByRoleIdMutation,
  useRolesApi_UpdatePermission_ByRoleId_ByResource_ByActionMutation,
  useRolesApi_UpdateRole_ByRoleIdMutation,
  useSsoApi_CreateLogout_ByPlatformIdMutation_v3,
  useSsoApi_GetSso_ByPlatformId_v3,
  useSsoCredentialAdminApi_CreateSso_ByPlatformIdMutation_v3,
  useSsoCredentialAdminApi_DeleteSso_ByPlatformIdMutation_v3,
  useSsoCredentialAdminApi_GetPlatformsSso_v3,
  useSsoCredentialAdminApi_GetSso_ByPlatformId_v3,
  useSsoCredentialAdminApi_PatchSso_ByPlatformIdMutation_v3,
  useSsoSaml20Api_PostAuthenticateSamlSso_ByPlatformIdMutation_v3,
  useThirdPartyCredentialAdminApi_CreateClient_ByPlatformIdMutation_v3,
  useThirdPartyCredentialAdminApi_DeleteClientDomain_ByPlatformIdMutation_v3,
  useThirdPartyCredentialAdminApi_DeleteClient_ByPlatformIdMutation_v3,
  useThirdPartyCredentialAdminApi_GetAvailability_ByPlatformId_v3,
  useThirdPartyCredentialAdminApi_GetClients_ByPlatformId_v3,
  useThirdPartyCredentialAdminApi_GetPlatformsAllClientsActive_v3,
  useThirdPartyCredentialAdminApi_GetPlatformsAllClients_v3,
  useThirdPartyCredentialAdminApi_PatchClient_ByPlatformIdMutation_v3,
  useThirdPartyCredentialAdminApi_UpdateClientDomain_ByPlatformIdMutation_v3,
  useThirdPartyCredentialApi_GetPlatformsClientsActive_v3,
  useThirdPartyCredentialApi_GetPlatformsClientsOidc_v3,
  useUsersAdminApi_CreateBan_ByUserIdMutation_v2,
  useUsersAdminApi_CreateBan_ByUserIdMutation_v3,
  useUsersAdminApi_CreatePermission_ByUserIdMutation_v3,
  useUsersAdminApi_CreatePlatformJustice_ByUserId_ByTargetNamespaceMutation_v3,
  useUsersAdminApi_CreateUserBulkMutation_v3,
  useUsersAdminApi_CreateUserInviteMutation_v3,
  useUsersAdminApi_DeleteAll_ByUserId_ByPlatformIdMutation_v3,
  useUsersAdminApi_DeleteInformation_ByUserIdMutation_v3,
  useUsersAdminApi_DeleteLinkHistory_ByUserId_ByPlatformIdMutation_v3,
  useUsersAdminApi_DeleteLinkRestriction_ByUserId_ByPlatformIdMutation_v3,
  useUsersAdminApi_DeleteLink_ByUserId_ByPlatformIdMutation_v2,
  useUsersAdminApi_DeletePermission_ByUserIdMutation_v3,
  useUsersAdminApi_DeletePermission_ByUserId_ByResource_ByActionMutation_v3,
  useUsersAdminApi_DeletePlatform_ByUserId_ByPlatformIdMutation_v3,
  useUsersAdminApi_DeleteRole_ByUserIdMutation_v3,
  useUsersAdminApi_DeleteRole_ByUserId_ByRoleIdMutation_v3,
  useUsersAdminApi_FetchUserBan_v3,
  useUsersAdminApi_FetchUserBulkPlatform_v3,
  useUsersAdminApi_FetchUserSearchBulk_v3,
  useUsersAdminApi_FetchUser_ByPlatformId_v3,
  useUsersAdminApi_GetAdmins_v3,
  useUsersAdminApi_GetAgerestrictionsCountries_v3,
  useUsersAdminApi_GetAgerestrictions_v2,
  useUsersAdminApi_GetAgerestrictions_v3,
  useUsersAdminApi_GetBansSummary_ByUserId_v3,
  useUsersAdminApi_GetBans_ByUserId_v2,
  useUsersAdminApi_GetBans_ByUserId_v3,
  useUsersAdminApi_GetCodes_ByUserId_v3,
  useUsersAdminApi_GetCountriesAgerestrictions_v2,
  useUsersAdminApi_GetDeletionStatus_ByUserId_v3,
  useUsersAdminApi_GetDistinctPlatforms_ByUserId_v3,
  useUsersAdminApi_GetLoginsHistories_ByUserId_v3,
  useUsersAdminApi_GetMetadata_ByUserId_ByPlatformId_v3,
  useUsersAdminApi_GetPlatformJustice_ByUserId_ByTargetNamespace_v3,
  useUsersAdminApi_GetPlatformsDistinct_ByUserId_v3,
  useUsersAdminApi_GetPlatformsJustice_ByUserId_v3,
  useUsersAdminApi_GetPlatformsLinkHistories_ByUserId_v3,
  useUsersAdminApi_GetPlatforms_ByUserId_v3,
  useUsersAdminApi_GetUser_ByPlatformId_ByPlatformUserId_v3,
  useUsersAdminApi_GetUser_ByUserId_v2,
  useUsersAdminApi_GetUser_ByUserId_v3,
  useUsersAdminApi_GetUsersLinkhistories_v3,
  useUsersAdminApi_GetUsersMe_v3,
  useUsersAdminApi_GetUsersPlatformsJustice_v3,
  useUsersAdminApi_GetUsersSearch_v3,
  useUsersAdminApi_GetUsers_ByRoleId_v3,
  useUsersAdminApi_GetUsers_v2,
  useUsersAdminApi_GetUsers_v3,
  useUsersAdminApi_PatchAgerestrictionCountry_ByCountryCodeMutation_v3,
  useUsersAdminApi_PatchAgerestrictionMutation_v2,
  useUsersAdminApi_PatchAgerestrictionMutation_v3,
  useUsersAdminApi_PatchBan_ByUserId_ByBanIdMutation_v3,
  useUsersAdminApi_PatchCountry_ByCountryCodeMutation_v2,
  useUsersAdminApi_PatchDeletionStatus_ByUserIdMutation_v3,
  useUsersAdminApi_PatchRole_ByUserIdMutation_v3,
  useUsersAdminApi_PatchStatus_ByUserIdMutation_v3,
  useUsersAdminApi_PatchTrustlyIdentity_ByUserIdMutation_v3,
  useUsersAdminApi_PatchUser_ByUserIdMutation_v2,
  useUsersAdminApi_PatchUser_ByUserIdMutation_v3,
  useUsersAdminApi_PostLinkStatu_ByUserId_ByPlatformIdMutation_v3,
  useUsersAdminApi_PostLink_ByUserId_ByPlatformIdMutation_v3,
  useUsersAdminApi_UpdateCodeRequest_ByUserIdMutation_v3,
  useUsersAdminApi_UpdateCodeVerify_ByUserIdMutation_v3,
  useUsersAdminApi_UpdateDisable_ByUserIdMutation_v2,
  useUsersAdminApi_UpdateEnable_ByUserIdMutation_v2,
  useUsersAdminApi_UpdateHeadlesCodeVerify_ByUserIdMutation_v3,
  useUsersAdminApi_UpdatePassword_ByUserIdMutation_v2,
  useUsersAdminApi_UpdatePassword_ByUserIdMutation_v3,
  useUsersAdminApi_UpdatePermission_ByUserIdMutation_v3,
  useUsersAdminApi_UpdatePlatformLink_ByUserIdMutation_v3,
  useUsersAdminApi_UpdateRole_ByUserIdMutation_v2,
  useUsersAdminApi_UpdateRole_ByUserId_ByNSMutation_v2,
  useUsersAdminApi_UpdateRole_ByUserId_ByRoleIdMutation_v3,
  useUsersAdminApi_UpdateUserMutation_v3,
  useUsersAdminApi_UpdateVerify_ByUserIdMutation_v3,
  useUsersApi_CreateBan_ByUserIdMutation,
  useUsersApi_CreatePlatformLinkWithProgression_ByUserIdMutation_v3,
  useUsersApi_CreatePlatformLink_ByUserIdMutation_v3,
  useUsersApi_CreateUserBulkBasicMutation_v3,
  useUsersApi_CreateUserCodeRequestMutation_v3,
  useUsersApi_CreateUserCodeVerifyMutation_v3,
  useUsersApi_CreateUserForgotMutation_v3,
  useUsersApi_CreateUserForgotPasswordMutation,
  useUsersApi_CreateUserForgotPasswordMutation_v2,
  useUsersApi_CreateUserInputValidationMutation_v3,
  useUsersApi_CreateUserInvite_ByInvitationIdMutation_v3,
  useUsersApi_CreateUserMeCodeRequestMutation_v3,
  useUsersApi_CreateUserMeCodeVerifyMutation_v3,
  useUsersApi_CreateUserMeHeadlesCodeVerifyMutation_v3,
  useUsersApi_CreateUserMeHeadlesLinkWithProgressionMutation_v3,
  useUsersApi_CreateUserMeHeadlesVerifyMutation_v3,
  useUsersApi_CreateUserMePlatformJustice_ByTargetNamespaceMutation_v3,
  useUsersApi_CreateUserMeVerifyLinkRequestMutation_v3,
  useUsersApi_CreateUserMutation,
  useUsersApi_CreateUserMutation_v2,
  useUsersApi_CreateUserMutation_v3,
  useUsersApi_CreateUserPlatformMutation_v3,
  useUsersApi_CreateUserResetMutation_v3,
  useUsersApi_CreateUserResetPasswordMutation,
  useUsersApi_CreateUserResetPasswordMutation_v2,
  useUsersApi_CreateUser_ByPlatformIdMutation_v3,
  useUsersApi_DeleteAllMeUser_ByPlatformIdMutation_v3,
  useUsersApi_DeleteInformation_ByUserIdMutation,
  useUsersApi_DeleteLink_ByUserId_ByPlatformIdMutation_v2,
  useUsersApi_DeletePermission_ByUserId_ByResource_ByActionMutation,
  useUsersApi_DeleteRole_ByUserId_ByRoleIdMutation,
  useUsersApi_DeleteUserMePlatform_ByPlatformIdMutation_v3,
  useUsersApi_DeleteUser_ByUserIdMutation,
  useUsersApi_GetAgerestrictionCountry_ByCountryCode_v3,
  useUsersApi_GetAgerestrictions_ByCountryCode_v2,
  useUsersApi_GetAsyncStatus_ByRequestId_v3,
  useUsersApi_GetBans_ByUserId,
  useUsersApi_GetBans_ByUserId_v2,
  useUsersApi_GetBans_ByUserId_v3,
  useUsersApi_GetDistinctPlatforms_ByUserId_v3,
  useUsersApi_GetInformation_ByUserId,
  useUsersApi_GetInformation_ByUserId_v3,
  useUsersApi_GetLoginsHistories_ByUserId,
  useUsersApi_GetLoginsHistories_ByUserId_v3,
  useUsersApi_GetPlatformJustice_ByUserId_ByTargetNamespace,
  useUsersApi_GetPlatformsJustice_ByUserId_v2,
  useUsersApi_GetPlatformsJustice_ByUserId_v3,
  useUsersApi_GetPlatforms_ByUserId,
  useUsersApi_GetPlatforms_ByUserId_v3,
  useUsersApi_GetPublisher_ByUserId,
  useUsersApi_GetPublisher_ByUserId_v3,
  useUsersApi_GetUserInvite_ByInvitationId_v3,
  useUsersApi_GetUser_ByPlatformId_ByPlatformUserId_v3,
  useUsersApi_GetUser_ByUserId,
  useUsersApi_GetUser_ByUserId_v2,
  useUsersApi_GetUser_ByUserId_v3,
  useUsersApi_GetUsersAdmin,
  useUsersApi_GetUsersAvailability_v3,
  useUsersApi_GetUsersByLoginId,
  useUsersApi_GetUsersByPlatformUserId,
  useUsersApi_GetUsersListByLoginIds,
  useUsersApi_GetUsersMeHeadlessLinkConflict_v3,
  useUsersApi_GetUsersMeProfileStatus_v3,
  useUsersApi_GetUsersMe_v3,
  useUsersApi_GetUsersSearch,
  useUsersApi_GetUsersVerifyLinkVerify_v3,
  useUsersApi_GetUsers_v3,
  useUsersApi_GetWebLinkEstablishMeUsers_ByPlatformId_v3,
  useUsersApi_GetWebLinkMeUsers_ByPlatformId_v3,
  useUsersApi_PatchUserMeMutation_v3,
  useUsersApi_PatchUser_ByUserIdMutation_v2,
  useUsersApi_PostCrosslink_ByUserIdMutation,
  useUsersApi_PostForceMeUser_ByPlatformIdMutation_v3,
  useUsersApi_PostLink_ByUserId_ByPlatformIdMutation,
  useUsersApi_PostLink_ByUserId_ByPlatformIdMutation_v2,
  useUsersApi_PostUnlink_ByUserId_ByPlatformIdMutation,
  useUsersApi_PostUserMePlatform_ByPlatformIdMutation_v3,
  useUsersApi_PostValidate_ByUserIdMutation_v3,
  useUsersApi_PostWebLinkProcesMeUser_ByPlatformIdMutation_v3,
  useUsersApi_UpdateDisable_ByUserIdMutation,
  useUsersApi_UpdateDisable_ByUserId_ByBanIdMutation,
  useUsersApi_UpdateEnable_ByUserIdMutation,
  useUsersApi_UpdateEnable_ByUserId_ByBanIdMutation,
  useUsersApi_UpdatePassword_ByUserIdMutation,
  useUsersApi_UpdatePassword_ByUserIdMutation_v2,
  useUsersApi_UpdatePermission_ByUserIdMutation,
  useUsersApi_UpdatePermission_ByUserId_ByResource_ByActionMutation,
  useUsersApi_UpdatePlatformJustice_ByUserId_ByTargetNamespaceMutation,
  useUsersApi_UpdateRole_ByUserIdMutation,
  useUsersApi_UpdateRole_ByUserId_ByRoleIdMutation,
  useUsersApi_UpdateUpgradeHeadlessAccountWithVerificationCode_ByUserIdMutation,
  useUsersApi_UpdateUpgradeHeadlessAccount_ByUserIdMutation,
  useUsersApi_UpdateUserMeMutation_v3,
  useUsersApi_UpdateUserMePasswordMutation_v3,
  useUsersApi_UpdateUser_ByUserIdMutation,
  useUsersApi_UpdateVerification_ByUserIdMutation,
  useUsersApi_UpdateVerificationcode_ByUserIdMutation,
  useUsersV4AdminApi_CreateTestUserMutation_v4,
  useUsersV4AdminApi_CreateUserInviteMutation_v4,
  useUsersV4AdminApi_CreateUserMeMfaAuthenticatorKeyMutation_v4,
  useUsersV4AdminApi_CreateUserMeMfaBackupCodeEnableMutation_v4,
  useUsersV4AdminApi_CreateUserMeMfaBackupCodeEnable_adminMutation_v4,
  useUsersV4AdminApi_CreateUserMeMfaBackupCodeMutation_v4,
  useUsersV4AdminApi_CreateUserMeMfaBackupCode_adminMutation_v4,
  useUsersV4AdminApi_CreateUserMeMfaEmailDisableMutation_v4,
  useUsersV4AdminApi_CreateUserMeMfaStatusMutation_v4,
  useUsersV4AdminApi_CreateUserMutation_v4,
  useUsersV4AdminApi_CreateUserUserInviteMutation_v4,
  useUsersV4AdminApi_DeleteMfaDisable_ByUserIdMutation_v4,
  useUsersV4AdminApi_DeleteRole_ByUserIdMutation_v4,
  useUsersV4AdminApi_DeleteUserMeMfaAuthenticatorDisableMutation_v4,
  useUsersV4AdminApi_DeleteUserMeMfaBackupCodeDisableMutation_v4,
  useUsersV4AdminApi_FetchUserBulkValidate_v4,
  useUsersV4AdminApi_GetInvitationHistoriesUsers_v4,
  useUsersV4AdminApi_GetInvitationHistories_ByNS_v4,
  useUsersV4AdminApi_GetInvitationHistories_v4,
  useUsersV4AdminApi_GetMfaStatus_ByUserId_v4,
  useUsersV4AdminApi_GetRoles_ByUserId_v4,
  useUsersV4AdminApi_GetUsersMeMfaBackupCodeDownload_v4,
  useUsersV4AdminApi_GetUsersMeMfaBackupCode_v4,
  useUsersV4AdminApi_GetUsersMeMfaBackupCodes_v4,
  useUsersV4AdminApi_GetUsersMeMfaFactor_v4,
  useUsersV4AdminApi_GetUsersMeMfaStatus_v4,
  useUsersV4AdminApi_PatchUserBulkAccountTypeMutation_v4,
  useUsersV4AdminApi_PatchUserMeMutation_v4,
  useUsersV4AdminApi_PostUserMeMfaAuthenticatorEnableMutation_v4,
  useUsersV4AdminApi_PostUserMeMfaChallengeVerifyMutation_v4,
  useUsersV4AdminApi_PostUserMeMfaEmailCodeMutation_v4,
  useUsersV4AdminApi_PostUserMeMfaEmailEnableMutation_v4,
  useUsersV4AdminApi_PostUserMeMfaFactorMutation_v4,
  useUsersV4AdminApi_UpdateEmail_ByUserIdMutation_v4,
  useUsersV4AdminApi_UpdateRole_ByUserIdMutation_v4,
  useUsersV4AdminApi_UpdateRole_ByUserId_ByNSMutation_v4,
  useUsersV4AdminApi_UpdateUser_ByUserIdMutation_v4,
  useUsersV4Api_CreateTestUserMutation_v4,
  useUsersV4Api_CreateUserInviteMutation_v4,
  useUsersV4Api_CreateUserInvite_ByInvitationIdMutation_v4,
  useUsersV4Api_CreateUserMeHeadlesCodeVerifyMutation_v4,
  useUsersV4Api_CreateUserMeHeadlesVerifyMutation_v4,
  useUsersV4Api_CreateUserMeMfaAuthenticatorKeyMutation_v4,
  useUsersV4Api_CreateUserMeMfaBackupCodeEnableMutation_v4,
  useUsersV4Api_CreateUserMeMfaBackupCodeEnable_ByNSMutation_v4,
  useUsersV4Api_CreateUserMeMfaBackupCodeMutation_v4,
  useUsersV4Api_CreateUserMeMfaBackupCode_ByNSMutation_v4,
  useUsersV4Api_CreateUserMeMfaEmailDisableMutation_v4,
  useUsersV4Api_CreateUserMeMfaStatusMutation_v4,
  useUsersV4Api_CreateUserMutation_v4,
  useUsersV4Api_CreateUser_ByPlatformIdMutation_v4,
  useUsersV4Api_DeleteUserMeMfaAuthenticatorDisableMutation_v4,
  useUsersV4Api_DeleteUserMeMfaBackupCodeDisableMutation_v4,
  useUsersV4Api_DeleteUserMeMfaDeviceMutation_v4,
  useUsersV4Api_GetUser_ByUserId_v4,
  useUsersV4Api_GetUsersMeMfaBackupCodeDownload_v4,
  useUsersV4Api_GetUsersMeMfaBackupCode_v4,
  useUsersV4Api_GetUsersMeMfaBackupCodes_v4,
  useUsersV4Api_GetUsersMeMfaFactor_v4,
  useUsersV4Api_GetUsersMeMfaStatus_v4,
  useUsersV4Api_PatchUserMeMutation_v4,
  useUsersV4Api_PostUserMeMfaAuthenticatorEnableMutation_v4,
  useUsersV4Api_PostUserMeMfaChallengeVerifyMutation_v4,
  useUsersV4Api_PostUserMeMfaEmailCodeMutation_v4,
  useUsersV4Api_PostUserMeMfaEmailEnableMutation_v4,
  useUsersV4Api_PostUserMeMfaFactorMutation_v4,
  useUsersV4Api_UpdateUserMeEmailMutation_v4
});

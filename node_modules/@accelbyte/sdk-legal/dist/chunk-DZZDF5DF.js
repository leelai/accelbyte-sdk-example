// src/generated-definitions/Paging.ts
import { z } from "zod";
var Paging = z.object({ next: z.string().nullish(), previous: z.string().nullish() });

// src/generated-definitions/LocalizedPolicyVersionObject.ts
import { z as z2 } from "zod";
var LocalizedPolicyVersionObject = z2.object({
  attachmentChecksum: z2.string().nullish(),
  attachmentLocation: z2.string().nullish(),
  attachmentVersionIdentifier: z2.string().nullish(),
  contentType: z2.string().nullish(),
  createdAt: z2.string().nullish(),
  description: z2.string().nullish(),
  id: z2.string(),
  isDefaultSelection: z2.boolean(),
  localeCode: z2.string(),
  publishedDate: z2.string().nullish(),
  status: z2.string().nullish(),
  updatedAt: z2.string().nullish()
});

// src/generated-definitions/RetrieveUserAcceptedAgreementResponse.ts
import { z as z3 } from "zod";
var RetrieveUserAcceptedAgreementResponse = z3.object({
  createdAt: z3.string().nullish(),
  displayName: z3.string().nullish(),
  email: z3.string().nullish(),
  id: z3.string(),
  isAccepted: z3.boolean().nullish(),
  localizedPolicyVersion: LocalizedPolicyVersionObject.nullish(),
  namespace: z3.string().nullish(),
  policyName: z3.string().nullish(),
  policyType: z3.string().nullish(),
  publisherUserId: z3.string().nullish(),
  signingDate: z3.string().nullish(),
  updatedAt: z3.string().nullish(),
  userId: z3.string().nullish(),
  username: z3.string().nullish()
});

// src/generated-definitions/PagedRetrieveUserAcceptedAgreementResponse.ts
import { z as z4 } from "zod";
var PagedRetrieveUserAcceptedAgreementResponse = z4.object({
  data: z4.array(RetrieveUserAcceptedAgreementResponse).nullish(),
  paging: Paging.nullish()
});

// src/generated-definitions/RetrieveAcceptedAgreementResponse.ts
import { z as z5 } from "zod";
var RetrieveAcceptedAgreementResponse = z5.object({
  countryCode: z5.string().nullish(),
  createdAt: z5.string().nullish(),
  description: z5.string().nullish(),
  displayVersion: z5.string().nullish(),
  id: z5.string(),
  isAccepted: z5.boolean().nullish(),
  localizedPolicyVersion: LocalizedPolicyVersionObject.nullish(),
  namespace: z5.string().nullish(),
  policyId: z5.string().nullish(),
  policyName: z5.string().nullish(),
  policyType: z5.string().nullish(),
  signingDate: z5.string().nullish(),
  tags: z5.array(z5.string()).nullish(),
  updatedAt: z5.string().nullish(),
  userId: z5.string().nullish()
});

// src/generated-definitions/RetrieveAcceptedAgreementResponseArray.ts
import { z as z6 } from "zod";
var RetrieveAcceptedAgreementResponseArray = z6.array(RetrieveAcceptedAgreementResponse);

// src/generated-admin/endpoints/AgreementAdmin$.ts
import { Validate } from "@accelbyte/sdk";
import { z as z7 } from "zod";
var AgreementAdmin$ = class {
  // @ts-ignore
  // prettier-ignore
  constructor(axiosInstance, namespace, useSchemaValidation = true) {
    this.axiosInstance = axiosInstance;
    this.namespace = namespace;
    this.useSchemaValidation = useSchemaValidation;
  }
  /**
   * This API will return users who has accepted a specific policy version.
   */
  getAgreementsPolicyVersionsUsers(queryParams) {
    const params = { limit: 20, ...queryParams };
    const url = "/agreement/admin/agreements/policy-versions/users";
    const resultPromise = this.axiosInstance.get(url, { params });
    return Validate.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      PagedRetrieveUserAcceptedAgreementResponse,
      "PagedRetrieveUserAcceptedAgreementResponse"
    );
  }
  /**
   * This API will return all accepted Legal Agreements for specified user
   */
  getAgreementPolicyUser_ByUserId(userId) {
    const params = {};
    const url = "/agreement/admin/agreements/policies/users/{userId}".replace("{userId}", userId);
    const resultPromise = this.axiosInstance.get(url, { params });
    return Validate.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      RetrieveAcceptedAgreementResponseArray,
      "RetrieveAcceptedAgreementResponseArray"
    );
  }
  /**
   * This API will Update Preference Consent
   */
  patchAgreementLocalizedPolicyVersionPreferenceUserId_ByUserId(userId, data) {
    const params = {};
    const url = "/agreement/admin/agreements/localized-policy-versions/preferences/namespaces/{namespace}/userId/{userId}".replace("{namespace}", this.namespace).replace("{userId}", userId);
    const resultPromise = this.axiosInstance.patch(url, data, { params });
    return Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, z7.unknown(), "z.unknown()");
  }
};

// src/generated-admin/AgreementAdminApi.ts
import { ApiUtils, Network } from "@accelbyte/sdk";
function AgreementAdminApi(sdk, args) {
  const sdkAssembly = sdk.assembly();
  const namespace = args?.coreConfig?.namespace ?? sdkAssembly.coreConfig.namespace;
  const useSchemaValidation = args?.coreConfig?.useSchemaValidation ?? sdkAssembly.coreConfig.useSchemaValidation;
  let axiosInstance = sdkAssembly.axiosInstance;
  const requestConfigOverrides = args?.axiosConfig?.request;
  const baseURLOverride = args?.coreConfig?.baseURL;
  const interceptorsOverride = args?.axiosConfig?.interceptors ?? [];
  if (requestConfigOverrides || baseURLOverride || interceptorsOverride.length > 0) {
    const requestConfig = ApiUtils.mergeAxiosConfigs(sdkAssembly.axiosInstance.defaults, {
      ...baseURLOverride ? { baseURL: baseURLOverride } : {},
      ...requestConfigOverrides
    });
    axiosInstance = Network.create(requestConfig);
    for (const interceptor of interceptorsOverride) {
      if (interceptor.type === "request") {
        axiosInstance.interceptors.request.use(interceptor.onRequest, interceptor.onError);
      }
      if (interceptor.type === "response") {
        axiosInstance.interceptors.response.use(interceptor.onSuccess, interceptor.onError);
      }
    }
  }
  async function getAgreementsPolicyVersionsUsers(queryParams) {
    const $ = new AgreementAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getAgreementsPolicyVersionsUsers(queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getAgreementPolicyUser_ByUserId(userId) {
    const $ = new AgreementAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getAgreementPolicyUser_ByUserId(userId);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function patchAgreementLocalizedPolicyVersionPreferenceUserId_ByUserId(userId, data) {
    const $ = new AgreementAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.patchAgreementLocalizedPolicyVersionPreferenceUserId_ByUserId(userId, data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  return {
    /**
     * This API will return users who has accepted a specific policy version.
     */
    getAgreementsPolicyVersionsUsers,
    /**
     * This API will return all accepted Legal Agreements for specified user
     */
    getAgreementPolicyUser_ByUserId,
    /**
     * This API will Update Preference Consent
     */
    patchAgreementLocalizedPolicyVersionPreferenceUserId_ByUserId
  };
}

// src/generated-definitions/DownloadExportedAgreementsInCsvResponse.ts
import { z as z8 } from "zod";
var DownloadExportedAgreementsInCsvResponse = z8.object({ done: z8.boolean(), downloadUrl: z8.string().nullish() });

// src/generated-definitions/InitiateExportAgreementsToCsvResponse.ts
import { z as z9 } from "zod";
var InitiateExportAgreementsToCsvResponse = z9.object({ exportId: z9.string(), processing: z9.boolean() });

// src/generated-definitions/UserAgreementsResponse.ts
import { z as z10 } from "zod";
var UserAgreementsResponse = z10.object({
  agreements: z10.array(RetrieveAcceptedAgreementResponse).nullish(),
  userId: z10.string().nullish()
});

// src/generated-definitions/UserAgreementsResponseArray.ts
import { z as z11 } from "zod";
var UserAgreementsResponseArray = z11.array(UserAgreementsResponse);

// src/generated-admin/endpoints/AgreementWithNamespaceAdmin$.ts
import { Validate as Validate2 } from "@accelbyte/sdk";
var AgreementWithNamespaceAdmin$ = class {
  // @ts-ignore
  // prettier-ignore
  constructor(axiosInstance, namespace, useSchemaValidation = true) {
    this.axiosInstance = axiosInstance;
    this.namespace = namespace;
    this.useSchemaValidation = useSchemaValidation;
  }
  /**
   * This API will return all accepted Legal Agreements for each user, including agreements of game users if publisher user has corresponding game account.
   */
  createAgreement(data) {
    const params = {};
    const url = "/agreement/admin/namespaces/{namespace}/agreements".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.post(url, data, { params });
    return Validate2.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      UserAgreementsResponseArray,
      "UserAgreementsResponseArray"
    );
  }
  /**
   * This API will return all users who has accepted a specific policy version.
   */
  getAgreementsPolicyVersionsUsers(queryParams) {
    const params = { limit: 20, ...queryParams };
    const url = "/agreement/admin/namespaces/{namespace}/agreements/policy-versions/users".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.get(url, { params });
    return Validate2.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      PagedRetrieveUserAcceptedAgreementResponse,
      "PagedRetrieveUserAcceptedAgreementResponse"
    );
  }
  /**
   * This API will return all accepted Legal Agreements for specified user.
   */
  getAgreementPolicyUser_ByUserId(userId, queryParams) {
    const params = { ...queryParams };
    const url = "/agreement/admin/namespaces/{namespace}/agreements/policies/users/{userId}".replace("{namespace}", this.namespace).replace("{userId}", userId);
    const resultPromise = this.axiosInstance.get(url, { params });
    return Validate2.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      RetrieveAcceptedAgreementResponseArray,
      "RetrieveAcceptedAgreementResponseArray"
    );
  }
  /**
   * This API will check the status of export process.&lt;br&gt;If the export process has been completed, the response body will include the download url.
   */
  getAgreementsPolicyVersionsUsersExportCsvDownload(queryParams) {
    const params = { ...queryParams };
    const url = "/agreement/admin/namespaces/{namespace}/agreements/policy-versions/users/export-csv/download".replace(
      "{namespace}",
      this.namespace
    );
    const resultPromise = this.axiosInstance.get(url, { params });
    return Validate2.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      DownloadExportedAgreementsInCsvResponse,
      "DownloadExportedAgreementsInCsvResponse"
    );
  }
  /**
   * This API will initiate a worker to export list of users who has accepted a specific policy version into a CSV file.&lt;br&gt;To check the export state after initialize it, use `GET /admin/namespaces/{namespace}/agreements/policy-versions/users/export-csv/download` API.&lt;br/&gt;&lt;br/&gt;This Initiate API is &lt;b&gt;not allow&lt;/b&gt; multiple export worker running for the same namespace, it will return 409 http error if so.&lt;br/&gt;
   */
  createAgreementPolicyVersionUserExportCsvInitiate(queryParams) {
    const params = { ...queryParams };
    const url = "/agreement/admin/namespaces/{namespace}/agreements/policy-versions/users/export-csv/initiate".replace(
      "{namespace}",
      this.namespace
    );
    const resultPromise = this.axiosInstance.post(url, null, { params });
    return Validate2.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      InitiateExportAgreementsToCsvResponse,
      "InitiateExportAgreementsToCsvResponse"
    );
  }
};

// src/generated-admin/AgreementWithNamespaceAdminApi.ts
import { ApiUtils as ApiUtils2, Network as Network2 } from "@accelbyte/sdk";
function AgreementWithNamespaceAdminApi(sdk, args) {
  const sdkAssembly = sdk.assembly();
  const namespace = args?.coreConfig?.namespace ?? sdkAssembly.coreConfig.namespace;
  const useSchemaValidation = args?.coreConfig?.useSchemaValidation ?? sdkAssembly.coreConfig.useSchemaValidation;
  let axiosInstance = sdkAssembly.axiosInstance;
  const requestConfigOverrides = args?.axiosConfig?.request;
  const baseURLOverride = args?.coreConfig?.baseURL;
  const interceptorsOverride = args?.axiosConfig?.interceptors ?? [];
  if (requestConfigOverrides || baseURLOverride || interceptorsOverride.length > 0) {
    const requestConfig = ApiUtils2.mergeAxiosConfigs(sdkAssembly.axiosInstance.defaults, {
      ...baseURLOverride ? { baseURL: baseURLOverride } : {},
      ...requestConfigOverrides
    });
    axiosInstance = Network2.create(requestConfig);
    for (const interceptor of interceptorsOverride) {
      if (interceptor.type === "request") {
        axiosInstance.interceptors.request.use(interceptor.onRequest, interceptor.onError);
      }
      if (interceptor.type === "response") {
        axiosInstance.interceptors.response.use(interceptor.onSuccess, interceptor.onError);
      }
    }
  }
  async function createAgreement(data) {
    const $ = new AgreementWithNamespaceAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.createAgreement(data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getAgreementsPolicyVersionsUsers(queryParams) {
    const $ = new AgreementWithNamespaceAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getAgreementsPolicyVersionsUsers(queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getAgreementPolicyUser_ByUserId(userId, queryParams) {
    const $ = new AgreementWithNamespaceAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getAgreementPolicyUser_ByUserId(userId, queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getAgreementsPolicyVersionsUsersExportCsvDownload(queryParams) {
    const $ = new AgreementWithNamespaceAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getAgreementsPolicyVersionsUsersExportCsvDownload(queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function createAgreementPolicyVersionUserExportCsvInitiate(queryParams) {
    const $ = new AgreementWithNamespaceAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.createAgreementPolicyVersionUserExportCsvInitiate(queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  return {
    /**
     * This API will return all accepted Legal Agreements for each user, including agreements of game users if publisher user has corresponding game account.
     */
    createAgreement,
    /**
     * This API will return all users who has accepted a specific policy version.
     */
    getAgreementsPolicyVersionsUsers,
    /**
     * This API will return all accepted Legal Agreements for specified user.
     */
    getAgreementPolicyUser_ByUserId,
    /**
     * This API will check the status of export process.&lt;br&gt;If the export process has been completed, the response body will include the download url.
     */
    getAgreementsPolicyVersionsUsersExportCsvDownload,
    /**
     * This API will initiate a worker to export list of users who has accepted a specific policy version into a CSV file.&lt;br&gt;To check the export state after initialize it, use `GET /admin/namespaces/{namespace}/agreements/policy-versions/users/export-csv/download` API.&lt;br/&gt;&lt;br/&gt;This Initiate API is &lt;b&gt;not allow&lt;/b&gt; multiple export worker running for the same namespace, it will return 409 http error if so.&lt;br/&gt;
     */
    createAgreementPolicyVersionUserExportCsvInitiate
  };
}

// src/generated-admin/endpoints/AnonymizationAdmin$.ts
import { Validate as Validate3 } from "@accelbyte/sdk";
import { z as z12 } from "zod";
var AnonymizationAdmin$ = class {
  // @ts-ignore
  // prettier-ignore
  constructor(axiosInstance, namespace, useSchemaValidation = true) {
    this.axiosInstance = axiosInstance;
    this.namespace = namespace;
    this.useSchemaValidation = useSchemaValidation;
  }
  /**
   * This API will anonymize agreement record for specified user.
   */
  deleteAnonymizationAgreement_ByUserId(userId) {
    const params = {};
    const url = "/agreement/admin/users/{userId}/anonymization/agreements".replace("{userId}", userId);
    const resultPromise = this.axiosInstance.delete(url, { params });
    return Validate3.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, z12.unknown(), "z.unknown()");
  }
};

// src/generated-admin/AnonymizationAdminApi.ts
import { ApiUtils as ApiUtils3, Network as Network3 } from "@accelbyte/sdk";
function AnonymizationAdminApi(sdk, args) {
  const sdkAssembly = sdk.assembly();
  const namespace = args?.coreConfig?.namespace ?? sdkAssembly.coreConfig.namespace;
  const useSchemaValidation = args?.coreConfig?.useSchemaValidation ?? sdkAssembly.coreConfig.useSchemaValidation;
  let axiosInstance = sdkAssembly.axiosInstance;
  const requestConfigOverrides = args?.axiosConfig?.request;
  const baseURLOverride = args?.coreConfig?.baseURL;
  const interceptorsOverride = args?.axiosConfig?.interceptors ?? [];
  if (requestConfigOverrides || baseURLOverride || interceptorsOverride.length > 0) {
    const requestConfig = ApiUtils3.mergeAxiosConfigs(sdkAssembly.axiosInstance.defaults, {
      ...baseURLOverride ? { baseURL: baseURLOverride } : {},
      ...requestConfigOverrides
    });
    axiosInstance = Network3.create(requestConfig);
    for (const interceptor of interceptorsOverride) {
      if (interceptor.type === "request") {
        axiosInstance.interceptors.request.use(interceptor.onRequest, interceptor.onError);
      }
      if (interceptor.type === "response") {
        axiosInstance.interceptors.response.use(interceptor.onSuccess, interceptor.onError);
      }
    }
  }
  async function deleteAnonymizationAgreement_ByUserId(userId) {
    const $ = new AnonymizationAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.deleteAnonymizationAgreement_ByUserId(userId);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  return {
    /**
     * This API will anonymize agreement record for specified user.
     */
    deleteAnonymizationAgreement_ByUserId
  };
}

// src/generated-definitions/CreateBasePolicyResponse.ts
import { z as z13 } from "zod";
var CreateBasePolicyResponse = z13.object({
  affectedClientIds: z13.array(z13.string()).nullish(),
  affectedCountries: z13.array(z13.string()).nullish(),
  createdAt: z13.string().nullish(),
  description: z13.string().nullish(),
  globalPolicyName: z13.string().nullish(),
  id: z13.string(),
  isHidden: z13.boolean().nullish(),
  isHiddenPublic: z13.boolean().nullish(),
  namespace: z13.string().nullish(),
  policyId: z13.string().nullish(),
  tags: z13.array(z13.string()).nullish(),
  typeId: z13.string().nullish(),
  updatedAt: z13.string().nullish()
});

// src/generated-definitions/PolicyObject.ts
import { z as z14 } from "zod";
var PolicyObject = z14.object({
  countryCode: z14.string(),
  countryGroupCode: z14.string().nullish(),
  createdAt: z14.string().nullish(),
  description: z14.string().nullish(),
  id: z14.string(),
  isDefaultOpted: z14.boolean(),
  isDefaultSelection: z14.boolean(),
  isMandatory: z14.boolean(),
  policyName: z14.string(),
  readableId: z14.string().nullish(),
  shouldNotifyOnUpdate: z14.boolean(),
  updatedAt: z14.string().nullish()
});

// src/generated-definitions/RetrieveBasePolicyResponse.ts
import { z as z15 } from "zod";
var RetrieveBasePolicyResponse = z15.object({
  affectedClientIds: z15.array(z15.string()).nullish(),
  basePolicyName: z15.string(),
  createdAt: z15.string().nullish(),
  description: z15.string().nullish(),
  id: z15.string(),
  isHidden: z15.boolean().nullish(),
  isHiddenPublic: z15.boolean().nullish(),
  namespace: z15.string(),
  policies: z15.array(PolicyObject).nullish(),
  policyTypeId: z15.string().nullish(),
  policyTypeName: z15.string().nullish(),
  tags: z15.array(z15.string()).nullish(),
  updatedAt: z15.string().nullish()
});

// src/generated-definitions/RetrieveBasePolicyResponseArray.ts
import { z as z16 } from "zod";
var RetrieveBasePolicyResponseArray = z16.array(RetrieveBasePolicyResponse);

// src/generated-definitions/PolicyVersionObject.ts
import { z as z17 } from "zod";
var PolicyVersionObject = z17.object({
  createdAt: z17.string().nullish(),
  description: z17.string().nullish(),
  displayVersion: z17.string(),
  id: z17.string(),
  isCommitted: z17.boolean(),
  isInEffect: z17.boolean(),
  publishedDate: z17.string().nullish(),
  status: z17.string().nullish(),
  updatedAt: z17.string().nullish()
});

// src/generated-definitions/RetrievePolicyResponse.ts
import { z as z18 } from "zod";
var RetrievePolicyResponse = z18.object({
  countryCode: z18.string(),
  countryGroupCode: z18.string().nullish(),
  createdAt: z18.string().nullish(),
  description: z18.string().nullish(),
  id: z18.string(),
  isDefaultOpted: z18.boolean(),
  isDefaultSelection: z18.boolean(),
  isMandatory: z18.boolean(),
  policyName: z18.string(),
  policyVersions: z18.array(PolicyVersionObject).nullish(),
  readableId: z18.string().nullish(),
  shouldNotifyOnUpdate: z18.boolean(),
  updatedAt: z18.string().nullish()
});

// src/generated-definitions/RetrievePolicyTypeResponse.ts
import { z as z19 } from "zod";
var RetrievePolicyTypeResponse = z19.object({
  createdAt: z19.string().nullish(),
  description: z19.string().nullish(),
  id: z19.string(),
  isNeedDocument: z19.boolean(),
  policyTypeName: z19.string(),
  updatedAt: z19.string().nullish()
});

// src/generated-definitions/RetrievePolicyTypeResponseArray.ts
import { z as z20 } from "zod";
var RetrievePolicyTypeResponseArray = z20.array(RetrievePolicyTypeResponse);

// src/generated-definitions/UpdateBasePolicyResponse.ts
import { z as z21 } from "zod";
var UpdateBasePolicyResponse = z21.object({
  affectedClientIds: z21.array(z21.string()).nullish(),
  affectedCountries: z21.array(z21.string()).nullish(),
  createdAt: z21.string().nullish(),
  description: z21.string().nullish(),
  globalPolicyName: z21.string().nullish(),
  id: z21.string(),
  isHidden: z21.boolean().nullish(),
  isHiddenPublic: z21.boolean().nullish(),
  namespace: z21.string().nullish(),
  policyId: z21.string().nullish(),
  tags: z21.array(z21.string()).nullish(),
  typeId: z21.string().nullish(),
  updatedAt: z21.string().nullish()
});

// src/generated-admin/endpoints/BaseLegalPoliciesAdmin$.ts
import { Validate as Validate4 } from "@accelbyte/sdk";
var BaseLegalPoliciesAdmin$ = class {
  // @ts-ignore
  // prettier-ignore
  constructor(axiosInstance, namespace, useSchemaValidation = true) {
    this.axiosInstance = axiosInstance;
    this.namespace = namespace;
    this.useSchemaValidation = useSchemaValidation;
  }
  /**
   * Retrieve all supported policy types.
   */
  getPolicyTypes(queryParams) {
    const params = { ...queryParams };
    const url = "/agreement/admin/policy-types";
    const resultPromise = this.axiosInstance.get(url, { params });
    return Validate4.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      RetrievePolicyTypeResponseArray,
      "RetrievePolicyTypeResponseArray"
    );
  }
  /**
   * Retrieve all base policies.
   */
  getBasePolicies(queryParams) {
    const params = { ...queryParams };
    const url = "/agreement/admin/base-policies";
    const resultPromise = this.axiosInstance.get(url, { params });
    return Validate4.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      RetrieveBasePolicyResponseArray,
      "RetrieveBasePolicyResponseArray"
    );
  }
  /**
   * Create a legal policy.
   */
  createBasePolicy(data) {
    const params = {};
    const url = "/agreement/admin/base-policies";
    const resultPromise = this.axiosInstance.post(url, data, { params });
    return Validate4.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      CreateBasePolicyResponse,
      "CreateBasePolicyResponse"
    );
  }
  /**
   * Retrieve a base policy.
   */
  getBasePolicy_ByBasePolicyId(basePolicyId) {
    const params = {};
    const url = "/agreement/admin/base-policies/{basePolicyId}".replace("{basePolicyId}", basePolicyId);
    const resultPromise = this.axiosInstance.get(url, { params });
    return Validate4.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      RetrieveBasePolicyResponse,
      "RetrieveBasePolicyResponse"
    );
  }
  /**
   * Update an existing base policy.
   */
  patchBasePolicy_ByBasePolicyId(basePolicyId, data) {
    const params = {};
    const url = "/agreement/admin/base-policies/{basePolicyId}".replace("{basePolicyId}", basePolicyId);
    const resultPromise = this.axiosInstance.patch(url, data, { params });
    return Validate4.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      UpdateBasePolicyResponse,
      "UpdateBasePolicyResponse"
    );
  }
  /**
   * Retrieve a Base Legal Policy based on a Particular Country.
   */
  getCountry_ByBasePolicyId_ByCountryCode(basePolicyId, countryCode) {
    const params = {};
    const url = "/agreement/admin/base-policies/{basePolicyId}/countries/{countryCode}".replace("{basePolicyId}", basePolicyId).replace("{countryCode}", countryCode);
    const resultPromise = this.axiosInstance.get(url, { params });
    return Validate4.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      RetrievePolicyResponse,
      "RetrievePolicyResponse"
    );
  }
};

// src/generated-admin/BaseLegalPoliciesAdminApi.ts
import { ApiUtils as ApiUtils4, Network as Network4 } from "@accelbyte/sdk";
function BaseLegalPoliciesAdminApi(sdk, args) {
  const sdkAssembly = sdk.assembly();
  const namespace = args?.coreConfig?.namespace ?? sdkAssembly.coreConfig.namespace;
  const useSchemaValidation = args?.coreConfig?.useSchemaValidation ?? sdkAssembly.coreConfig.useSchemaValidation;
  let axiosInstance = sdkAssembly.axiosInstance;
  const requestConfigOverrides = args?.axiosConfig?.request;
  const baseURLOverride = args?.coreConfig?.baseURL;
  const interceptorsOverride = args?.axiosConfig?.interceptors ?? [];
  if (requestConfigOverrides || baseURLOverride || interceptorsOverride.length > 0) {
    const requestConfig = ApiUtils4.mergeAxiosConfigs(sdkAssembly.axiosInstance.defaults, {
      ...baseURLOverride ? { baseURL: baseURLOverride } : {},
      ...requestConfigOverrides
    });
    axiosInstance = Network4.create(requestConfig);
    for (const interceptor of interceptorsOverride) {
      if (interceptor.type === "request") {
        axiosInstance.interceptors.request.use(interceptor.onRequest, interceptor.onError);
      }
      if (interceptor.type === "response") {
        axiosInstance.interceptors.response.use(interceptor.onSuccess, interceptor.onError);
      }
    }
  }
  async function getPolicyTypes(queryParams) {
    const $ = new BaseLegalPoliciesAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getPolicyTypes(queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getBasePolicies(queryParams) {
    const $ = new BaseLegalPoliciesAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getBasePolicies(queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function createBasePolicy(data) {
    const $ = new BaseLegalPoliciesAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.createBasePolicy(data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getBasePolicy_ByBasePolicyId(basePolicyId) {
    const $ = new BaseLegalPoliciesAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getBasePolicy_ByBasePolicyId(basePolicyId);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function patchBasePolicy_ByBasePolicyId(basePolicyId, data) {
    const $ = new BaseLegalPoliciesAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.patchBasePolicy_ByBasePolicyId(basePolicyId, data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getCountry_ByBasePolicyId_ByCountryCode(basePolicyId, countryCode) {
    const $ = new BaseLegalPoliciesAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getCountry_ByBasePolicyId_ByCountryCode(basePolicyId, countryCode);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  return {
    /**
     * Retrieve all supported policy types.
     */
    getPolicyTypes,
    /**
     * Retrieve all base policies.
     */
    getBasePolicies,
    /**
     * Create a legal policy.
     */
    createBasePolicy,
    /**
     * Retrieve a base policy.
     */
    getBasePolicy_ByBasePolicyId,
    /**
     * Update an existing base policy.
     */
    patchBasePolicy_ByBasePolicyId,
    /**
     * Retrieve a Base Legal Policy based on a Particular Country.
     */
    getCountry_ByBasePolicyId_ByCountryCode
  };
}

// src/generated-admin/endpoints/BaseLegalPoliciesWithNamespaceAdmin$.ts
import { Validate as Validate5 } from "@accelbyte/sdk";
var BaseLegalPoliciesWithNamespaceAdmin$ = class {
  // @ts-ignore
  // prettier-ignore
  constructor(axiosInstance, namespace, useSchemaValidation = true) {
    this.axiosInstance = axiosInstance;
    this.namespace = namespace;
    this.useSchemaValidation = useSchemaValidation;
  }
  /**
   * Retrieve all supported policy types.
   */
  getPolicyTypes(queryParams) {
    const params = { ...queryParams };
    const url = "/agreement/admin/namespaces/{namespace}/policy-types".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.get(url, { params });
    return Validate5.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      RetrievePolicyTypeResponseArray,
      "RetrievePolicyTypeResponseArray"
    );
  }
  /**
   * Retrieve all base policies in the namespace.
   */
  getBasePolicies(queryParams) {
    const params = { ...queryParams };
    const url = "/agreement/admin/namespaces/{namespace}/base-policies".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.get(url, { params });
    return Validate5.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      RetrieveBasePolicyResponseArray,
      "RetrieveBasePolicyResponseArray"
    );
  }
  /**
   * Create a legal policy.
   */
  createBasePolicy(data) {
    const params = {};
    const url = "/agreement/admin/namespaces/{namespace}/base-policies".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.post(url, data, { params });
    return Validate5.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      CreateBasePolicyResponse,
      "CreateBasePolicyResponse"
    );
  }
  /**
   * Retrieve a base policy.
   */
  getBasePolicy_ByBasePolicyId(basePolicyId) {
    const params = {};
    const url = "/agreement/admin/namespaces/{namespace}/base-policies/{basePolicyId}".replace("{namespace}", this.namespace).replace("{basePolicyId}", basePolicyId);
    const resultPromise = this.axiosInstance.get(url, { params });
    return Validate5.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      RetrieveBasePolicyResponse,
      "RetrieveBasePolicyResponse"
    );
  }
  /**
   * Update an existing base policy.
   */
  patchBasePolicy_ByBasePolicyId(basePolicyId, data) {
    const params = {};
    const url = "/agreement/admin/namespaces/{namespace}/base-policies/{basePolicyId}".replace("{namespace}", this.namespace).replace("{basePolicyId}", basePolicyId);
    const resultPromise = this.axiosInstance.patch(url, data, { params });
    return Validate5.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      UpdateBasePolicyResponse,
      "UpdateBasePolicyResponse"
    );
  }
  /**
   * Retrieve a Base Legal Policy based on a Particular Country.
   */
  getCountry_ByBasePolicyId_ByCountryCode(basePolicyId, countryCode) {
    const params = {};
    const url = "/agreement/admin/namespaces/{namespace}/base-policies/{basePolicyId}/countries/{countryCode}".replace("{namespace}", this.namespace).replace("{basePolicyId}", basePolicyId).replace("{countryCode}", countryCode);
    const resultPromise = this.axiosInstance.get(url, { params });
    return Validate5.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      RetrievePolicyResponse,
      "RetrievePolicyResponse"
    );
  }
};

// src/generated-admin/BaseLegalPoliciesWithNamespaceAdminApi.ts
import { ApiUtils as ApiUtils5, Network as Network5 } from "@accelbyte/sdk";
function BaseLegalPoliciesWithNamespaceAdminApi(sdk, args) {
  const sdkAssembly = sdk.assembly();
  const namespace = args?.coreConfig?.namespace ?? sdkAssembly.coreConfig.namespace;
  const useSchemaValidation = args?.coreConfig?.useSchemaValidation ?? sdkAssembly.coreConfig.useSchemaValidation;
  let axiosInstance = sdkAssembly.axiosInstance;
  const requestConfigOverrides = args?.axiosConfig?.request;
  const baseURLOverride = args?.coreConfig?.baseURL;
  const interceptorsOverride = args?.axiosConfig?.interceptors ?? [];
  if (requestConfigOverrides || baseURLOverride || interceptorsOverride.length > 0) {
    const requestConfig = ApiUtils5.mergeAxiosConfigs(sdkAssembly.axiosInstance.defaults, {
      ...baseURLOverride ? { baseURL: baseURLOverride } : {},
      ...requestConfigOverrides
    });
    axiosInstance = Network5.create(requestConfig);
    for (const interceptor of interceptorsOverride) {
      if (interceptor.type === "request") {
        axiosInstance.interceptors.request.use(interceptor.onRequest, interceptor.onError);
      }
      if (interceptor.type === "response") {
        axiosInstance.interceptors.response.use(interceptor.onSuccess, interceptor.onError);
      }
    }
  }
  async function getPolicyTypes(queryParams) {
    const $ = new BaseLegalPoliciesWithNamespaceAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getPolicyTypes(queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getBasePolicies(queryParams) {
    const $ = new BaseLegalPoliciesWithNamespaceAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getBasePolicies(queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function createBasePolicy(data) {
    const $ = new BaseLegalPoliciesWithNamespaceAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.createBasePolicy(data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getBasePolicy_ByBasePolicyId(basePolicyId) {
    const $ = new BaseLegalPoliciesWithNamespaceAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getBasePolicy_ByBasePolicyId(basePolicyId);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function patchBasePolicy_ByBasePolicyId(basePolicyId, data) {
    const $ = new BaseLegalPoliciesWithNamespaceAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.patchBasePolicy_ByBasePolicyId(basePolicyId, data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getCountry_ByBasePolicyId_ByCountryCode(basePolicyId, countryCode) {
    const $ = new BaseLegalPoliciesWithNamespaceAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getCountry_ByBasePolicyId_ByCountryCode(basePolicyId, countryCode);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  return {
    /**
     * Retrieve all supported policy types.
     */
    getPolicyTypes,
    /**
     * Retrieve all base policies in the namespace.
     */
    getBasePolicies,
    /**
     * Create a legal policy.
     */
    createBasePolicy,
    /**
     * Retrieve a base policy.
     */
    getBasePolicy_ByBasePolicyId,
    /**
     * Update an existing base policy.
     */
    patchBasePolicy_ByBasePolicyId,
    /**
     * Retrieve a Base Legal Policy based on a Particular Country.
     */
    getCountry_ByBasePolicyId_ByCountryCode
  };
}

// src/generated-definitions/CreateLocalizedPolicyVersionResponse.ts
import { z as z22 } from "zod";
var CreateLocalizedPolicyVersionResponse = z22.object({
  createdAt: z22.string().nullish(),
  description: z22.string().nullish(),
  id: z22.string(),
  localeCode: z22.string().nullish(),
  updatedAt: z22.string().nullish()
});

// src/generated-definitions/RetrieveLocalizedPolicyVersionResponse.ts
import { z as z23 } from "zod";
var RetrieveLocalizedPolicyVersionResponse = z23.object({
  attachmentChecksum: z23.string().nullish(),
  attachmentLocation: z23.string().nullish(),
  attachmentVersionIdentifier: z23.string().nullish(),
  baseUrls: z23.array(z23.string()).nullish(),
  contentType: z23.string().nullish(),
  createdAt: z23.string().nullish(),
  description: z23.string().nullish(),
  id: z23.string(),
  localeCode: z23.string(),
  policy: PolicyObject.nullish(),
  policyVersion: PolicyVersionObject,
  updatedAt: z23.string().nullish()
});

// src/generated-definitions/RetrieveLocalizedPolicyVersionResponseArray.ts
import { z as z24 } from "zod";
var RetrieveLocalizedPolicyVersionResponseArray = z24.array(RetrieveLocalizedPolicyVersionResponse);

// src/generated-definitions/UpdateLocalizedPolicyVersionResponse.ts
import { z as z25 } from "zod";
var UpdateLocalizedPolicyVersionResponse = z25.object({
  attachmentChecksum: z25.string().nullish(),
  attachmentLocation: z25.string().nullish(),
  attachmentVersionIdentifier: z25.string().nullish(),
  contentType: z25.string().nullish(),
  createdAt: z25.string().nullish(),
  description: z25.string().nullish(),
  id: z25.string(),
  localeCode: z25.string().nullish(),
  updatedAt: z25.string().nullish()
});

// src/generated-definitions/UploadLocalizedPolicyVersionAttachmentResponse.ts
import { z as z26 } from "zod";
var UploadLocalizedPolicyVersionAttachmentResponse = z26.object({
  attachmentChecksum: z26.string().nullish(),
  attachmentLocation: z26.string().nullish(),
  attachmentUploadUrl: z26.string().nullish()
});

// src/generated-admin/endpoints/LocalizedPolicyVersionsAdmin$.ts
import { Validate as Validate6 } from "@accelbyte/sdk";
import { z as z27 } from "zod";
var LocalizedPolicyVersionsAdmin$ = class {
  // @ts-ignore
  // prettier-ignore
  constructor(axiosInstance, namespace, useSchemaValidation = true) {
    this.axiosInstance = axiosInstance;
    this.namespace = namespace;
    this.useSchemaValidation = useSchemaValidation;
  }
  /**
   * Retrieve a version of a particular country-specific policy.
   */
  getLocalizedPolicyVersion_ByLocalizedPolicyVersionId(localizedPolicyVersionId) {
    const params = {};
    const url = "/agreement/admin/localized-policy-versions/{localizedPolicyVersionId}".replace(
      "{localizedPolicyVersionId}",
      localizedPolicyVersionId
    );
    const resultPromise = this.axiosInstance.get(url, { params });
    return Validate6.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      RetrieveLocalizedPolicyVersionResponse,
      "RetrieveLocalizedPolicyVersionResponse"
    );
  }
  /**
   * Update a version of a particular country-specific policy.
   */
  updateLocalizedPolicyVersion_ByLocalizedPolicyVersionId(localizedPolicyVersionId, data) {
    const params = {};
    const url = "/agreement/admin/localized-policy-versions/{localizedPolicyVersionId}".replace(
      "{localizedPolicyVersionId}",
      localizedPolicyVersionId
    );
    const resultPromise = this.axiosInstance.put(url, data, { params });
    return Validate6.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      UpdateLocalizedPolicyVersionResponse,
      "UpdateLocalizedPolicyVersionResponse"
    );
  }
  /**
   * Retrieve versions of a particular country-specific policy.
   */
  getLocalizedPolicyVersionVersion_ByPolicyVersionId(policyVersionId) {
    const params = {};
    const url = "/agreement/admin/localized-policy-versions/versions/{policyVersionId}".replace("{policyVersionId}", policyVersionId);
    const resultPromise = this.axiosInstance.get(url, { params });
    return Validate6.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      RetrieveLocalizedPolicyVersionResponseArray,
      "RetrieveLocalizedPolicyVersionResponseArray"
    );
  }
  /**
   * Create a version of a particular country-specific policy.
   */
  createLocalizedPolicyVersionVersion_ByPolicyVersionId(policyVersionId, data) {
    const params = {};
    const url = "/agreement/admin/localized-policy-versions/versions/{policyVersionId}".replace("{policyVersionId}", policyVersionId);
    const resultPromise = this.axiosInstance.post(url, data, { params });
    return Validate6.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      CreateLocalizedPolicyVersionResponse,
      "CreateLocalizedPolicyVersionResponse"
    );
  }
  /**
   * Update a localized version policy to be the default.
   */
  patchDefault_ByLocalizedPolicyVersionId(localizedPolicyVersionId) {
    const params = {};
    const url = "/agreement/admin/localized-policy-versions/{localizedPolicyVersionId}/default".replace(
      "{localizedPolicyVersionId}",
      localizedPolicyVersionId
    );
    const resultPromise = this.axiosInstance.patch(url, null, { params });
    return Validate6.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, z27.unknown(), "z.unknown()");
  }
  /**
   * Request presigned URL for upload attachment for a particular localized version of base policy.
   */
  createAttachment_ByLocalizedPolicyVersionId(localizedPolicyVersionId, data) {
    const params = {};
    const url = "/agreement/admin/localized-policy-versions/{localizedPolicyVersionId}/attachments".replace(
      "{localizedPolicyVersionId}",
      localizedPolicyVersionId
    );
    const resultPromise = this.axiosInstance.post(url, data, { params });
    return Validate6.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      UploadLocalizedPolicyVersionAttachmentResponse,
      "UploadLocalizedPolicyVersionAttachmentResponse"
    );
  }
};

// src/generated-admin/endpoints/LocalizedPolicyVersionsWithNamespaceAdmin$.ts
import { Validate as Validate7 } from "@accelbyte/sdk";
import { z as z28 } from "zod";
var LocalizedPolicyVersionsWithNamespaceAdmin$ = class {
  // @ts-ignore
  // prettier-ignore
  constructor(axiosInstance, namespace, useSchemaValidation = true) {
    this.axiosInstance = axiosInstance;
    this.namespace = namespace;
    this.useSchemaValidation = useSchemaValidation;
  }
  /**
   * Retrieve a version of a particular country-specific policy.
   */
  getLocalizedPolicyVersion_ByLocalizedPolicyVersionId(localizedPolicyVersionId) {
    const params = {};
    const url = "/agreement/admin/namespaces/{namespace}/localized-policy-versions/{localizedPolicyVersionId}".replace("{namespace}", this.namespace).replace("{localizedPolicyVersionId}", localizedPolicyVersionId);
    const resultPromise = this.axiosInstance.get(url, { params });
    return Validate7.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      RetrieveLocalizedPolicyVersionResponse,
      "RetrieveLocalizedPolicyVersionResponse"
    );
  }
  /**
   * Update a version of a particular country-specific policy.
   */
  updateLocalizedPolicyVersion_ByLocalizedPolicyVersionId(localizedPolicyVersionId, data) {
    const params = {};
    const url = "/agreement/admin/namespaces/{namespace}/localized-policy-versions/{localizedPolicyVersionId}".replace("{namespace}", this.namespace).replace("{localizedPolicyVersionId}", localizedPolicyVersionId);
    const resultPromise = this.axiosInstance.put(url, data, { params });
    return Validate7.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      UpdateLocalizedPolicyVersionResponse,
      "UpdateLocalizedPolicyVersionResponse"
    );
  }
  /**
   * Retrieve versions of a particular country-specific policy.
   */
  getLocalizedPolicyVersionVersion_ByPolicyVersionId(policyVersionId) {
    const params = {};
    const url = "/agreement/admin/namespaces/{namespace}/localized-policy-versions/versions/{policyVersionId}".replace("{namespace}", this.namespace).replace("{policyVersionId}", policyVersionId);
    const resultPromise = this.axiosInstance.get(url, { params });
    return Validate7.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      RetrieveLocalizedPolicyVersionResponseArray,
      "RetrieveLocalizedPolicyVersionResponseArray"
    );
  }
  /**
   * Create a version of a particular country-specific policy.
   */
  createLocalizedPolicyVersionVersion_ByPolicyVersionId(policyVersionId, data) {
    const params = {};
    const url = "/agreement/admin/namespaces/{namespace}/localized-policy-versions/versions/{policyVersionId}".replace("{namespace}", this.namespace).replace("{policyVersionId}", policyVersionId);
    const resultPromise = this.axiosInstance.post(url, data, { params });
    return Validate7.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      CreateLocalizedPolicyVersionResponse,
      "CreateLocalizedPolicyVersionResponse"
    );
  }
  /**
   * Update a localized version policy to be the default.
   */
  patchDefault_ByLocalizedPolicyVersionId(localizedPolicyVersionId) {
    const params = {};
    const url = "/agreement/admin/namespaces/{namespace}/localized-policy-versions/{localizedPolicyVersionId}/default".replace("{namespace}", this.namespace).replace("{localizedPolicyVersionId}", localizedPolicyVersionId);
    const resultPromise = this.axiosInstance.patch(url, null, { params });
    return Validate7.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, z28.unknown(), "z.unknown()");
  }
  /**
   * Request presigned URL for upload attachment for a particular localized version of base policy.
   */
  createAttachment_ByLocalizedPolicyVersionId(localizedPolicyVersionId, data) {
    const params = {};
    const url = "/agreement/admin/namespaces/{namespace}/localized-policy-versions/{localizedPolicyVersionId}/attachments".replace("{namespace}", this.namespace).replace("{localizedPolicyVersionId}", localizedPolicyVersionId);
    const resultPromise = this.axiosInstance.post(url, data, { params });
    return Validate7.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      UploadLocalizedPolicyVersionAttachmentResponse,
      "UploadLocalizedPolicyVersionAttachmentResponse"
    );
  }
};

// src/generated-definitions/RetrievePolicyResponseArray.ts
import { z as z29 } from "zod";
var RetrievePolicyResponseArray = z29.array(RetrievePolicyResponse);

// src/generated-admin/endpoints/PoliciesAdmin$.ts
import { Validate as Validate8 } from "@accelbyte/sdk";
import { z as z30 } from "zod";
var PoliciesAdmin$ = class {
  // @ts-ignore
  // prettier-ignore
  constructor(axiosInstance, namespace, useSchemaValidation = true) {
    this.axiosInstance = axiosInstance;
    this.namespace = namespace;
    this.useSchemaValidation = useSchemaValidation;
  }
  /**
   * Update country-specific policy.
   */
  patchPolicy_ByPolicyId(policyId, data) {
    const params = {};
    const url = "/agreement/admin/policies/{policyId}".replace("{policyId}", policyId);
    const resultPromise = this.axiosInstance.patch(url, data, { params });
    return Validate8.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, z30.unknown(), "z.unknown()");
  }
  /**
   * Update a policy to be the default.
   */
  patchDefault_ByPolicyId(policyId) {
    const params = {};
    const url = "/agreement/admin/policies/{policyId}/default".replace("{policyId}", policyId);
    const resultPromise = this.axiosInstance.patch(url, null, { params });
    return Validate8.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, z30.unknown(), "z.unknown()");
  }
  /**
   * Retrieve all active policies based on a country.
   */
  getPolicyCountry_ByCountryCode(countryCode) {
    const params = {};
    const url = "/agreement/admin/policies/countries/{countryCode}".replace("{countryCode}", countryCode);
    const resultPromise = this.axiosInstance.get(url, { params });
    return Validate8.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      RetrievePolicyResponseArray,
      "RetrievePolicyResponseArray"
    );
  }
};

// src/generated-admin/endpoints/PoliciesWithNamespaceAdmin$.ts
import { Validate as Validate9 } from "@accelbyte/sdk";
import { z as z31 } from "zod";
var PoliciesWithNamespaceAdmin$ = class {
  // @ts-ignore
  // prettier-ignore
  constructor(axiosInstance, namespace, useSchemaValidation = true) {
    this.axiosInstance = axiosInstance;
    this.namespace = namespace;
    this.useSchemaValidation = useSchemaValidation;
  }
  /**
   * Update country-specific policy.
   */
  patchPolicy_ByPolicyId(policyId, data) {
    const params = {};
    const url = "/agreement/admin/namespaces/{namespace}/policies/{policyId}".replace("{namespace}", this.namespace).replace("{policyId}", policyId);
    const resultPromise = this.axiosInstance.patch(url, data, { params });
    return Validate9.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, z31.unknown(), "z.unknown()");
  }
  /**
   * Update a policy to be the default.
   */
  patchDefault_ByPolicyId(policyId) {
    const params = {};
    const url = "/agreement/admin/namespaces/{namespace}/policies/{policyId}/default".replace("{namespace}", this.namespace).replace("{policyId}", policyId);
    const resultPromise = this.axiosInstance.patch(url, null, { params });
    return Validate9.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, z31.unknown(), "z.unknown()");
  }
};

// src/generated-definitions/CreatePolicyVersionResponse.ts
import { z as z32 } from "zod";
var CreatePolicyVersionResponse = z32.object({
  basePolicyId: z32.string().nullish(),
  createdAt: z32.string().nullish(),
  description: z32.string().nullish(),
  displayVersion: z32.string().nullish(),
  id: z32.string(),
  isCommitted: z32.boolean().nullish(),
  updatedAt: z32.string().nullish()
});

// src/generated-definitions/RetrievePolicyVersionResponse.ts
import { z as z33 } from "zod";
var RetrievePolicyVersionResponse = z33.object({
  basePolicyId: z33.string().nullish(),
  createdAt: z33.string().nullish(),
  description: z33.string().nullish(),
  displayVersion: z33.string(),
  id: z33.string(),
  isCommitted: z33.boolean(),
  isInEffect: z33.boolean(),
  localizedPolicyVersions: z33.array(LocalizedPolicyVersionObject).nullish(),
  policyId: z33.string().nullish(),
  publishedDate: z33.string().nullish(),
  status: z33.string().nullish(),
  updatedAt: z33.string().nullish()
});

// src/generated-definitions/RetrievePolicyVersionResponseArray.ts
import { z as z34 } from "zod";
var RetrievePolicyVersionResponseArray = z34.array(RetrievePolicyVersionResponse);

// src/generated-definitions/UpdatePolicyVersionResponse.ts
import { z as z35 } from "zod";
var UpdatePolicyVersionResponse = z35.object({
  basePolicyId: z35.string().nullish(),
  createdAt: z35.string().nullish(),
  description: z35.string().nullish(),
  displayVersion: z35.string().nullish(),
  id: z35.string(),
  isCommitted: z35.boolean().nullish(),
  publishedDate: z35.string().nullish(),
  status: z35.string().nullish(),
  updatedAt: z35.string().nullish()
});

// src/generated-admin/endpoints/PolicyVersionsAdmin$.ts
import { Validate as Validate10 } from "@accelbyte/sdk";
import { z as z36 } from "zod";
var PolicyVersionsAdmin$ = class {
  // @ts-ignore
  // prettier-ignore
  constructor(axiosInstance, namespace, useSchemaValidation = true) {
    this.axiosInstance = axiosInstance;
    this.namespace = namespace;
    this.useSchemaValidation = useSchemaValidation;
  }
  /**
   * Retrieve a version of a particular country specific policy. If version is not provided, the Legal Service will assume caller requesting all versions from country-specific policy.
   */
  getVersions_ByPolicyId(policyId, queryParams) {
    const params = { ...queryParams };
    const url = "/agreement/admin/policies/{policyId}/versions".replace("{policyId}", policyId);
    const resultPromise = this.axiosInstance.get(url, { params });
    return Validate10.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      RetrievePolicyVersionResponseArray,
      "RetrievePolicyVersionResponseArray"
    );
  }
  /**
   * Create a version of a particular country-specific policy.
   */
  createVersion_ByPolicyId(policyId, data) {
    const params = {};
    const url = "/agreement/admin/policies/{policyId}/versions".replace("{policyId}", policyId);
    const resultPromise = this.axiosInstance.post(url, data, { params });
    return Validate10.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      CreatePolicyVersionResponse,
      "CreatePolicyVersionResponse"
    );
  }
  /**
   * Update a particular policy version.
   */
  patchPolicyVersion_ByPolicyVersionId(policyVersionId, data) {
    const params = {};
    const url = "/agreement/admin/policies/versions/{policyVersionId}".replace("{policyVersionId}", policyVersionId);
    const resultPromise = this.axiosInstance.patch(url, data, { params });
    return Validate10.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      UpdatePolicyVersionResponse,
      "UpdatePolicyVersionResponse"
    );
  }
  /**
   * Manually publish a version of a particular country-specific policy.
   */
  patchLatestPolicy_ByPolicyVersionId(policyVersionId, queryParams) {
    const params = { shouldNotify: true, ...queryParams };
    const url = "/agreement/admin/policies/versions/{policyVersionId}/latest".replace("{policyVersionId}", policyVersionId);
    const resultPromise = this.axiosInstance.patch(url, null, { params });
    return Validate10.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, z36.unknown(), "z.unknown()");
  }
};

// src/generated-admin/endpoints/PolicyVersionsWithNamespaceAdmin$.ts
import { Validate as Validate11 } from "@accelbyte/sdk";
import { z as z37 } from "zod";
var PolicyVersionsWithNamespaceAdmin$ = class {
  // @ts-ignore
  // prettier-ignore
  constructor(axiosInstance, namespace, useSchemaValidation = true) {
    this.axiosInstance = axiosInstance;
    this.namespace = namespace;
    this.useSchemaValidation = useSchemaValidation;
  }
  /**
   * Retrieve a version of a particular country specific policy. If version is not provided, the Legal Service will assume caller requesting all versions from country-specific policy.
   */
  getVersions_ByPolicyId(policyId, queryParams) {
    const params = { ...queryParams };
    const url = "/agreement/admin/namespaces/{namespace}/policies/{policyId}/versions".replace("{namespace}", this.namespace).replace("{policyId}", policyId);
    const resultPromise = this.axiosInstance.get(url, { params });
    return Validate11.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      RetrievePolicyVersionResponseArray,
      "RetrievePolicyVersionResponseArray"
    );
  }
  /**
   * Create a version of a particular country-specific policy.
   */
  createVersion_ByPolicyId(policyId, data) {
    const params = {};
    const url = "/agreement/admin/namespaces/{namespace}/policies/{policyId}/versions".replace("{namespace}", this.namespace).replace("{policyId}", policyId);
    const resultPromise = this.axiosInstance.post(url, data, { params });
    return Validate11.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      CreatePolicyVersionResponse,
      "CreatePolicyVersionResponse"
    );
  }
  /**
   * Update a particular policy version.
   */
  patchPolicyVersion_ByPolicyVersionId(policyVersionId, data) {
    const params = {};
    const url = "/agreement/admin/namespaces/{namespace}/policies/versions/{policyVersionId}".replace("{namespace}", this.namespace).replace("{policyVersionId}", policyVersionId);
    const resultPromise = this.axiosInstance.patch(url, data, { params });
    return Validate11.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      UpdatePolicyVersionResponse,
      "UpdatePolicyVersionResponse"
    );
  }
  /**
   * Manually publish a version of a particular country-specific policy.
   */
  patchLatestPolicy_ByPolicyVersionId(policyVersionId, queryParams) {
    const params = { shouldNotify: true, ...queryParams };
    const url = "/agreement/admin/namespaces/{namespace}/policies/versions/{policyVersionId}/latest".replace("{namespace}", this.namespace).replace("{policyVersionId}", policyVersionId);
    const resultPromise = this.axiosInstance.patch(url, null, { params });
    return Validate11.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, z37.unknown(), "z.unknown()");
  }
};

// src/generated-definitions/AcceptAgreementResponse.ts
import { z as z38 } from "zod";
var AcceptAgreementResponse = z38.object({ comply: z38.boolean(), proceed: z38.boolean() });

// src/generated-admin/endpoints/UserAgreementAdmin$.ts
import { Validate as Validate12 } from "@accelbyte/sdk";
var UserAgreementAdmin$ = class {
  // @ts-ignore
  // prettier-ignore
  constructor(axiosInstance, namespace, useSchemaValidation = true) {
    this.axiosInstance = axiosInstance;
    this.namespace = namespace;
    this.useSchemaValidation = useSchemaValidation;
  }
  /**
   * Accepts many legal policy versions all at once. Supply with localized version policy id and userId to accept an agreement.
   */
  createAgreementPolicy_ByUserId(userId, data, queryParams) {
    const params = { ...queryParams };
    const url = "/agreement/admin/namespaces/{namespace}/users/{userId}/agreements/policies".replace("{namespace}", this.namespace).replace("{userId}", userId);
    const resultPromise = this.axiosInstance.post(url, data, { params });
    return Validate12.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      AcceptAgreementResponse,
      "AcceptAgreementResponse"
    );
  }
};

// src/generated-definitions/RetrieveUserEligibilitiesIndirectResponse.ts
import { z as z39 } from "zod";
var RetrieveUserEligibilitiesIndirectResponse = z39.object({ isComply: z39.boolean() });

// src/generated-admin/endpoints/UserEligibilitiesAdmin$.ts
import { Validate as Validate13 } from "@accelbyte/sdk";
var UserEligibilitiesAdmin$ = class {
  // @ts-ignore
  // prettier-ignore
  constructor(axiosInstance, namespace, useSchemaValidation = true) {
    this.axiosInstance = axiosInstance;
    this.namespace = namespace;
    this.useSchemaValidation = useSchemaValidation;
  }
  /**
   * Retrieve the active policies and its conformance status by user.&lt;br&gt;This process only supports cross-namespace checking between game namespace and publisher namespace , that means if the active policy already accepted by the same user in publisher namespace, then it will also be considered as eligible in non-publisher namespace.
   */
  getEligibilities_ByUserId(userId, queryParams) {
    const params = { ...queryParams };
    const url = "/agreement/admin/namespaces/{namespace}/users/{userId}/eligibilities".replace("{namespace}", this.namespace).replace("{userId}", userId);
    const resultPromise = this.axiosInstance.get(url, { params });
    return Validate13.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      RetrieveUserEligibilitiesIndirectResponse,
      "RetrieveUserEligibilitiesIndirectResponse"
    );
  }
};

// src/generated-definitions/RetrieveUserInfoCacheStatusResponse.ts
import { z as z40 } from "zod";
var RetrieveUserInfoCacheStatusResponse = z40.object({ lastUpdatedAt: z40.string(), namespace: z40.string() });

// src/generated-definitions/RetrieveUserInfoCacheStatusResponseArray.ts
import { z as z41 } from "zod";
var RetrieveUserInfoCacheStatusResponseArray = z41.array(RetrieveUserInfoCacheStatusResponse);

// src/generated-admin/endpoints/UserInfoAdmin$.ts
import { Validate as Validate14 } from "@accelbyte/sdk";
import { z as z42 } from "zod";
var UserInfoAdmin$ = class {
  // @ts-ignore
  // prettier-ignore
  constructor(axiosInstance, namespace, useSchemaValidation = true) {
    this.axiosInstance = axiosInstance;
    this.namespace = namespace;
    this.useSchemaValidation = useSchemaValidation;
  }
  /**
   * @deprecated
   * Invalidate user info cache in agreement service.
   */
  deleteUserInfo(queryParams) {
    const params = { ...queryParams };
    const url = "/agreement/admin/userInfo";
    const resultPromise = this.axiosInstance.delete(url, { params });
    return Validate14.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, z42.unknown(), "z.unknown()");
  }
  /**
   * Get user info cache last updated time per namespace.&lt;br&gt;The query parameter namespaces can be a list of namespace separated by comma.&lt;br&gt;If query parameter namespaces is empty, user info cache status for all available namespaces will be returned.
   */
  getUserInfo(queryParams) {
    const params = { ...queryParams };
    const url = "/agreement/admin/userInfo";
    const resultPromise = this.axiosInstance.get(url, { params });
    return Validate14.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      RetrieveUserInfoCacheStatusResponseArray,
      "RetrieveUserInfoCacheStatusResponseArray"
    );
  }
  /**
   * @deprecated
   * Sync user info cache in agreement service with iam service.
   */
  updateUserInfo(queryParams) {
    const params = { ...queryParams };
    const url = "/agreement/admin/userInfo";
    const resultPromise = this.axiosInstance.put(url, null, { params });
    return Validate14.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, z42.unknown(), "z.unknown()");
  }
};

// src/generated-admin/LocalizedPolicyVersionsAdminApi.ts
import { ApiUtils as ApiUtils6, Network as Network6 } from "@accelbyte/sdk";
function LocalizedPolicyVersionsAdminApi(sdk, args) {
  const sdkAssembly = sdk.assembly();
  const namespace = args?.coreConfig?.namespace ?? sdkAssembly.coreConfig.namespace;
  const useSchemaValidation = args?.coreConfig?.useSchemaValidation ?? sdkAssembly.coreConfig.useSchemaValidation;
  let axiosInstance = sdkAssembly.axiosInstance;
  const requestConfigOverrides = args?.axiosConfig?.request;
  const baseURLOverride = args?.coreConfig?.baseURL;
  const interceptorsOverride = args?.axiosConfig?.interceptors ?? [];
  if (requestConfigOverrides || baseURLOverride || interceptorsOverride.length > 0) {
    const requestConfig = ApiUtils6.mergeAxiosConfigs(sdkAssembly.axiosInstance.defaults, {
      ...baseURLOverride ? { baseURL: baseURLOverride } : {},
      ...requestConfigOverrides
    });
    axiosInstance = Network6.create(requestConfig);
    for (const interceptor of interceptorsOverride) {
      if (interceptor.type === "request") {
        axiosInstance.interceptors.request.use(interceptor.onRequest, interceptor.onError);
      }
      if (interceptor.type === "response") {
        axiosInstance.interceptors.response.use(interceptor.onSuccess, interceptor.onError);
      }
    }
  }
  async function getLocalizedPolicyVersion_ByLocalizedPolicyVersionId(localizedPolicyVersionId) {
    const $ = new LocalizedPolicyVersionsAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getLocalizedPolicyVersion_ByLocalizedPolicyVersionId(localizedPolicyVersionId);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function updateLocalizedPolicyVersion_ByLocalizedPolicyVersionId(localizedPolicyVersionId, data) {
    const $ = new LocalizedPolicyVersionsAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.updateLocalizedPolicyVersion_ByLocalizedPolicyVersionId(localizedPolicyVersionId, data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getLocalizedPolicyVersionVersion_ByPolicyVersionId(policyVersionId) {
    const $ = new LocalizedPolicyVersionsAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getLocalizedPolicyVersionVersion_ByPolicyVersionId(policyVersionId);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function createLocalizedPolicyVersionVersion_ByPolicyVersionId(policyVersionId, data) {
    const $ = new LocalizedPolicyVersionsAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.createLocalizedPolicyVersionVersion_ByPolicyVersionId(policyVersionId, data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function patchDefault_ByLocalizedPolicyVersionId(localizedPolicyVersionId) {
    const $ = new LocalizedPolicyVersionsAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.patchDefault_ByLocalizedPolicyVersionId(localizedPolicyVersionId);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function createAttachment_ByLocalizedPolicyVersionId(localizedPolicyVersionId, data) {
    const $ = new LocalizedPolicyVersionsAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.createAttachment_ByLocalizedPolicyVersionId(localizedPolicyVersionId, data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  return {
    /**
     * Retrieve a version of a particular country-specific policy.
     */
    getLocalizedPolicyVersion_ByLocalizedPolicyVersionId,
    /**
     * Update a version of a particular country-specific policy.
     */
    updateLocalizedPolicyVersion_ByLocalizedPolicyVersionId,
    /**
     * Retrieve versions of a particular country-specific policy.
     */
    getLocalizedPolicyVersionVersion_ByPolicyVersionId,
    /**
     * Create a version of a particular country-specific policy.
     */
    createLocalizedPolicyVersionVersion_ByPolicyVersionId,
    /**
     * Update a localized version policy to be the default.
     */
    patchDefault_ByLocalizedPolicyVersionId,
    /**
     * Request presigned URL for upload attachment for a particular localized version of base policy.
     */
    createAttachment_ByLocalizedPolicyVersionId
  };
}

// src/generated-admin/LocalizedPolicyVersionsWithNamespaceAdminApi.ts
import { ApiUtils as ApiUtils7, Network as Network7 } from "@accelbyte/sdk";
function LocalizedPolicyVersionsWithNamespaceAdminApi(sdk, args) {
  const sdkAssembly = sdk.assembly();
  const namespace = args?.coreConfig?.namespace ?? sdkAssembly.coreConfig.namespace;
  const useSchemaValidation = args?.coreConfig?.useSchemaValidation ?? sdkAssembly.coreConfig.useSchemaValidation;
  let axiosInstance = sdkAssembly.axiosInstance;
  const requestConfigOverrides = args?.axiosConfig?.request;
  const baseURLOverride = args?.coreConfig?.baseURL;
  const interceptorsOverride = args?.axiosConfig?.interceptors ?? [];
  if (requestConfigOverrides || baseURLOverride || interceptorsOverride.length > 0) {
    const requestConfig = ApiUtils7.mergeAxiosConfigs(sdkAssembly.axiosInstance.defaults, {
      ...baseURLOverride ? { baseURL: baseURLOverride } : {},
      ...requestConfigOverrides
    });
    axiosInstance = Network7.create(requestConfig);
    for (const interceptor of interceptorsOverride) {
      if (interceptor.type === "request") {
        axiosInstance.interceptors.request.use(interceptor.onRequest, interceptor.onError);
      }
      if (interceptor.type === "response") {
        axiosInstance.interceptors.response.use(interceptor.onSuccess, interceptor.onError);
      }
    }
  }
  async function getLocalizedPolicyVersion_ByLocalizedPolicyVersionId(localizedPolicyVersionId) {
    const $ = new LocalizedPolicyVersionsWithNamespaceAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getLocalizedPolicyVersion_ByLocalizedPolicyVersionId(localizedPolicyVersionId);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function updateLocalizedPolicyVersion_ByLocalizedPolicyVersionId(localizedPolicyVersionId, data) {
    const $ = new LocalizedPolicyVersionsWithNamespaceAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.updateLocalizedPolicyVersion_ByLocalizedPolicyVersionId(localizedPolicyVersionId, data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getLocalizedPolicyVersionVersion_ByPolicyVersionId(policyVersionId) {
    const $ = new LocalizedPolicyVersionsWithNamespaceAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getLocalizedPolicyVersionVersion_ByPolicyVersionId(policyVersionId);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function createLocalizedPolicyVersionVersion_ByPolicyVersionId(policyVersionId, data) {
    const $ = new LocalizedPolicyVersionsWithNamespaceAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.createLocalizedPolicyVersionVersion_ByPolicyVersionId(policyVersionId, data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function patchDefault_ByLocalizedPolicyVersionId(localizedPolicyVersionId) {
    const $ = new LocalizedPolicyVersionsWithNamespaceAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.patchDefault_ByLocalizedPolicyVersionId(localizedPolicyVersionId);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function createAttachment_ByLocalizedPolicyVersionId(localizedPolicyVersionId, data) {
    const $ = new LocalizedPolicyVersionsWithNamespaceAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.createAttachment_ByLocalizedPolicyVersionId(localizedPolicyVersionId, data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  return {
    /**
     * Retrieve a version of a particular country-specific policy.
     */
    getLocalizedPolicyVersion_ByLocalizedPolicyVersionId,
    /**
     * Update a version of a particular country-specific policy.
     */
    updateLocalizedPolicyVersion_ByLocalizedPolicyVersionId,
    /**
     * Retrieve versions of a particular country-specific policy.
     */
    getLocalizedPolicyVersionVersion_ByPolicyVersionId,
    /**
     * Create a version of a particular country-specific policy.
     */
    createLocalizedPolicyVersionVersion_ByPolicyVersionId,
    /**
     * Update a localized version policy to be the default.
     */
    patchDefault_ByLocalizedPolicyVersionId,
    /**
     * Request presigned URL for upload attachment for a particular localized version of base policy.
     */
    createAttachment_ByLocalizedPolicyVersionId
  };
}

// src/generated-admin/PoliciesAdminApi.ts
import { ApiUtils as ApiUtils8, Network as Network8 } from "@accelbyte/sdk";
function PoliciesAdminApi(sdk, args) {
  const sdkAssembly = sdk.assembly();
  const namespace = args?.coreConfig?.namespace ?? sdkAssembly.coreConfig.namespace;
  const useSchemaValidation = args?.coreConfig?.useSchemaValidation ?? sdkAssembly.coreConfig.useSchemaValidation;
  let axiosInstance = sdkAssembly.axiosInstance;
  const requestConfigOverrides = args?.axiosConfig?.request;
  const baseURLOverride = args?.coreConfig?.baseURL;
  const interceptorsOverride = args?.axiosConfig?.interceptors ?? [];
  if (requestConfigOverrides || baseURLOverride || interceptorsOverride.length > 0) {
    const requestConfig = ApiUtils8.mergeAxiosConfigs(sdkAssembly.axiosInstance.defaults, {
      ...baseURLOverride ? { baseURL: baseURLOverride } : {},
      ...requestConfigOverrides
    });
    axiosInstance = Network8.create(requestConfig);
    for (const interceptor of interceptorsOverride) {
      if (interceptor.type === "request") {
        axiosInstance.interceptors.request.use(interceptor.onRequest, interceptor.onError);
      }
      if (interceptor.type === "response") {
        axiosInstance.interceptors.response.use(interceptor.onSuccess, interceptor.onError);
      }
    }
  }
  async function patchPolicy_ByPolicyId(policyId, data) {
    const $ = new PoliciesAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.patchPolicy_ByPolicyId(policyId, data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function patchDefault_ByPolicyId(policyId) {
    const $ = new PoliciesAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.patchDefault_ByPolicyId(policyId);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getPolicyCountry_ByCountryCode(countryCode) {
    const $ = new PoliciesAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getPolicyCountry_ByCountryCode(countryCode);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  return {
    /**
     * Update country-specific policy.
     */
    patchPolicy_ByPolicyId,
    /**
     * Update a policy to be the default.
     */
    patchDefault_ByPolicyId,
    /**
     * Retrieve all active policies based on a country.
     */
    getPolicyCountry_ByCountryCode
  };
}

// src/generated-admin/PoliciesWithNamespaceAdminApi.ts
import { ApiUtils as ApiUtils9, Network as Network9 } from "@accelbyte/sdk";
function PoliciesWithNamespaceAdminApi(sdk, args) {
  const sdkAssembly = sdk.assembly();
  const namespace = args?.coreConfig?.namespace ?? sdkAssembly.coreConfig.namespace;
  const useSchemaValidation = args?.coreConfig?.useSchemaValidation ?? sdkAssembly.coreConfig.useSchemaValidation;
  let axiosInstance = sdkAssembly.axiosInstance;
  const requestConfigOverrides = args?.axiosConfig?.request;
  const baseURLOverride = args?.coreConfig?.baseURL;
  const interceptorsOverride = args?.axiosConfig?.interceptors ?? [];
  if (requestConfigOverrides || baseURLOverride || interceptorsOverride.length > 0) {
    const requestConfig = ApiUtils9.mergeAxiosConfigs(sdkAssembly.axiosInstance.defaults, {
      ...baseURLOverride ? { baseURL: baseURLOverride } : {},
      ...requestConfigOverrides
    });
    axiosInstance = Network9.create(requestConfig);
    for (const interceptor of interceptorsOverride) {
      if (interceptor.type === "request") {
        axiosInstance.interceptors.request.use(interceptor.onRequest, interceptor.onError);
      }
      if (interceptor.type === "response") {
        axiosInstance.interceptors.response.use(interceptor.onSuccess, interceptor.onError);
      }
    }
  }
  async function patchPolicy_ByPolicyId(policyId, data) {
    const $ = new PoliciesWithNamespaceAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.patchPolicy_ByPolicyId(policyId, data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function patchDefault_ByPolicyId(policyId) {
    const $ = new PoliciesWithNamespaceAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.patchDefault_ByPolicyId(policyId);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  return {
    /**
     * Update country-specific policy.
     */
    patchPolicy_ByPolicyId,
    /**
     * Update a policy to be the default.
     */
    patchDefault_ByPolicyId
  };
}

// src/generated-admin/PolicyVersionsAdminApi.ts
import { ApiUtils as ApiUtils10, Network as Network10 } from "@accelbyte/sdk";
function PolicyVersionsAdminApi(sdk, args) {
  const sdkAssembly = sdk.assembly();
  const namespace = args?.coreConfig?.namespace ?? sdkAssembly.coreConfig.namespace;
  const useSchemaValidation = args?.coreConfig?.useSchemaValidation ?? sdkAssembly.coreConfig.useSchemaValidation;
  let axiosInstance = sdkAssembly.axiosInstance;
  const requestConfigOverrides = args?.axiosConfig?.request;
  const baseURLOverride = args?.coreConfig?.baseURL;
  const interceptorsOverride = args?.axiosConfig?.interceptors ?? [];
  if (requestConfigOverrides || baseURLOverride || interceptorsOverride.length > 0) {
    const requestConfig = ApiUtils10.mergeAxiosConfigs(sdkAssembly.axiosInstance.defaults, {
      ...baseURLOverride ? { baseURL: baseURLOverride } : {},
      ...requestConfigOverrides
    });
    axiosInstance = Network10.create(requestConfig);
    for (const interceptor of interceptorsOverride) {
      if (interceptor.type === "request") {
        axiosInstance.interceptors.request.use(interceptor.onRequest, interceptor.onError);
      }
      if (interceptor.type === "response") {
        axiosInstance.interceptors.response.use(interceptor.onSuccess, interceptor.onError);
      }
    }
  }
  async function getVersions_ByPolicyId(policyId, queryParams) {
    const $ = new PolicyVersionsAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getVersions_ByPolicyId(policyId, queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function createVersion_ByPolicyId(policyId, data) {
    const $ = new PolicyVersionsAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.createVersion_ByPolicyId(policyId, data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function patchPolicyVersion_ByPolicyVersionId(policyVersionId, data) {
    const $ = new PolicyVersionsAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.patchPolicyVersion_ByPolicyVersionId(policyVersionId, data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function patchLatestPolicy_ByPolicyVersionId(policyVersionId, queryParams) {
    const $ = new PolicyVersionsAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.patchLatestPolicy_ByPolicyVersionId(policyVersionId, queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  return {
    /**
     * Retrieve a version of a particular country specific policy. If version is not provided, the Legal Service will assume caller requesting all versions from country-specific policy.
     */
    getVersions_ByPolicyId,
    /**
     * Create a version of a particular country-specific policy.
     */
    createVersion_ByPolicyId,
    /**
     * Update a particular policy version.
     */
    patchPolicyVersion_ByPolicyVersionId,
    /**
     * Manually publish a version of a particular country-specific policy.
     */
    patchLatestPolicy_ByPolicyVersionId
  };
}

// src/generated-admin/PolicyVersionsWithNamespaceAdminApi.ts
import { ApiUtils as ApiUtils11, Network as Network11 } from "@accelbyte/sdk";
function PolicyVersionsWithNamespaceAdminApi(sdk, args) {
  const sdkAssembly = sdk.assembly();
  const namespace = args?.coreConfig?.namespace ?? sdkAssembly.coreConfig.namespace;
  const useSchemaValidation = args?.coreConfig?.useSchemaValidation ?? sdkAssembly.coreConfig.useSchemaValidation;
  let axiosInstance = sdkAssembly.axiosInstance;
  const requestConfigOverrides = args?.axiosConfig?.request;
  const baseURLOverride = args?.coreConfig?.baseURL;
  const interceptorsOverride = args?.axiosConfig?.interceptors ?? [];
  if (requestConfigOverrides || baseURLOverride || interceptorsOverride.length > 0) {
    const requestConfig = ApiUtils11.mergeAxiosConfigs(sdkAssembly.axiosInstance.defaults, {
      ...baseURLOverride ? { baseURL: baseURLOverride } : {},
      ...requestConfigOverrides
    });
    axiosInstance = Network11.create(requestConfig);
    for (const interceptor of interceptorsOverride) {
      if (interceptor.type === "request") {
        axiosInstance.interceptors.request.use(interceptor.onRequest, interceptor.onError);
      }
      if (interceptor.type === "response") {
        axiosInstance.interceptors.response.use(interceptor.onSuccess, interceptor.onError);
      }
    }
  }
  async function getVersions_ByPolicyId(policyId, queryParams) {
    const $ = new PolicyVersionsWithNamespaceAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getVersions_ByPolicyId(policyId, queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function createVersion_ByPolicyId(policyId, data) {
    const $ = new PolicyVersionsWithNamespaceAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.createVersion_ByPolicyId(policyId, data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function patchPolicyVersion_ByPolicyVersionId(policyVersionId, data) {
    const $ = new PolicyVersionsWithNamespaceAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.patchPolicyVersion_ByPolicyVersionId(policyVersionId, data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function patchLatestPolicy_ByPolicyVersionId(policyVersionId, queryParams) {
    const $ = new PolicyVersionsWithNamespaceAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.patchLatestPolicy_ByPolicyVersionId(policyVersionId, queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  return {
    /**
     * Retrieve a version of a particular country specific policy. If version is not provided, the Legal Service will assume caller requesting all versions from country-specific policy.
     */
    getVersions_ByPolicyId,
    /**
     * Create a version of a particular country-specific policy.
     */
    createVersion_ByPolicyId,
    /**
     * Update a particular policy version.
     */
    patchPolicyVersion_ByPolicyVersionId,
    /**
     * Manually publish a version of a particular country-specific policy.
     */
    patchLatestPolicy_ByPolicyVersionId
  };
}

// src/generated-admin/UserAgreementAdminApi.ts
import { ApiUtils as ApiUtils12, Network as Network12 } from "@accelbyte/sdk";
function UserAgreementAdminApi(sdk, args) {
  const sdkAssembly = sdk.assembly();
  const namespace = args?.coreConfig?.namespace ?? sdkAssembly.coreConfig.namespace;
  const useSchemaValidation = args?.coreConfig?.useSchemaValidation ?? sdkAssembly.coreConfig.useSchemaValidation;
  let axiosInstance = sdkAssembly.axiosInstance;
  const requestConfigOverrides = args?.axiosConfig?.request;
  const baseURLOverride = args?.coreConfig?.baseURL;
  const interceptorsOverride = args?.axiosConfig?.interceptors ?? [];
  if (requestConfigOverrides || baseURLOverride || interceptorsOverride.length > 0) {
    const requestConfig = ApiUtils12.mergeAxiosConfigs(sdkAssembly.axiosInstance.defaults, {
      ...baseURLOverride ? { baseURL: baseURLOverride } : {},
      ...requestConfigOverrides
    });
    axiosInstance = Network12.create(requestConfig);
    for (const interceptor of interceptorsOverride) {
      if (interceptor.type === "request") {
        axiosInstance.interceptors.request.use(interceptor.onRequest, interceptor.onError);
      }
      if (interceptor.type === "response") {
        axiosInstance.interceptors.response.use(interceptor.onSuccess, interceptor.onError);
      }
    }
  }
  async function createAgreementPolicy_ByUserId(userId, data, queryParams) {
    const $ = new UserAgreementAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.createAgreementPolicy_ByUserId(userId, data, queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  return {
    /**
     * Accepts many legal policy versions all at once. Supply with localized version policy id and userId to accept an agreement.
     */
    createAgreementPolicy_ByUserId
  };
}

// src/generated-admin/UserEligibilitiesAdminApi.ts
import { ApiUtils as ApiUtils13, Network as Network13 } from "@accelbyte/sdk";
function UserEligibilitiesAdminApi(sdk, args) {
  const sdkAssembly = sdk.assembly();
  const namespace = args?.coreConfig?.namespace ?? sdkAssembly.coreConfig.namespace;
  const useSchemaValidation = args?.coreConfig?.useSchemaValidation ?? sdkAssembly.coreConfig.useSchemaValidation;
  let axiosInstance = sdkAssembly.axiosInstance;
  const requestConfigOverrides = args?.axiosConfig?.request;
  const baseURLOverride = args?.coreConfig?.baseURL;
  const interceptorsOverride = args?.axiosConfig?.interceptors ?? [];
  if (requestConfigOverrides || baseURLOverride || interceptorsOverride.length > 0) {
    const requestConfig = ApiUtils13.mergeAxiosConfigs(sdkAssembly.axiosInstance.defaults, {
      ...baseURLOverride ? { baseURL: baseURLOverride } : {},
      ...requestConfigOverrides
    });
    axiosInstance = Network13.create(requestConfig);
    for (const interceptor of interceptorsOverride) {
      if (interceptor.type === "request") {
        axiosInstance.interceptors.request.use(interceptor.onRequest, interceptor.onError);
      }
      if (interceptor.type === "response") {
        axiosInstance.interceptors.response.use(interceptor.onSuccess, interceptor.onError);
      }
    }
  }
  async function getEligibilities_ByUserId(userId, queryParams) {
    const $ = new UserEligibilitiesAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getEligibilities_ByUserId(userId, queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  return {
    /**
     * Retrieve the active policies and its conformance status by user.&lt;br&gt;This process only supports cross-namespace checking between game namespace and publisher namespace , that means if the active policy already accepted by the same user in publisher namespace, then it will also be considered as eligible in non-publisher namespace.
     */
    getEligibilities_ByUserId
  };
}

// src/generated-admin/UserInfoAdminApi.ts
import { ApiUtils as ApiUtils14, Network as Network14 } from "@accelbyte/sdk";
function UserInfoAdminApi(sdk, args) {
  const sdkAssembly = sdk.assembly();
  const namespace = args?.coreConfig?.namespace ?? sdkAssembly.coreConfig.namespace;
  const useSchemaValidation = args?.coreConfig?.useSchemaValidation ?? sdkAssembly.coreConfig.useSchemaValidation;
  let axiosInstance = sdkAssembly.axiosInstance;
  const requestConfigOverrides = args?.axiosConfig?.request;
  const baseURLOverride = args?.coreConfig?.baseURL;
  const interceptorsOverride = args?.axiosConfig?.interceptors ?? [];
  if (requestConfigOverrides || baseURLOverride || interceptorsOverride.length > 0) {
    const requestConfig = ApiUtils14.mergeAxiosConfigs(sdkAssembly.axiosInstance.defaults, {
      ...baseURLOverride ? { baseURL: baseURLOverride } : {},
      ...requestConfigOverrides
    });
    axiosInstance = Network14.create(requestConfig);
    for (const interceptor of interceptorsOverride) {
      if (interceptor.type === "request") {
        axiosInstance.interceptors.request.use(interceptor.onRequest, interceptor.onError);
      }
      if (interceptor.type === "response") {
        axiosInstance.interceptors.response.use(interceptor.onSuccess, interceptor.onError);
      }
    }
  }
  async function deleteUserInfo(queryParams) {
    const $ = new UserInfoAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.deleteUserInfo(queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getUserInfo(queryParams) {
    const $ = new UserInfoAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getUserInfo(queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function updateUserInfo(queryParams) {
    const $ = new UserInfoAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.updateUserInfo(queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  return {
    /**
     * @deprecated
     * Invalidate user info cache in agreement service.
     */
    deleteUserInfo,
    /**
     * Get user info cache last updated time per namespace.&lt;br&gt;The query parameter namespaces can be a list of namespace separated by comma.&lt;br&gt;If query parameter namespaces is empty, user info cache status for all available namespaces will be returned.
     */
    getUserInfo,
    /**
     * @deprecated
     * Sync user info cache in agreement service with iam service.
     */
    updateUserInfo
  };
}

// src/generated-definitions/LegalReadinessStatusResponse.ts
import { z as z43 } from "zod";
var LegalReadinessStatusResponse = z43.object({ isReady: z43.boolean().nullish() });

// src/generated-definitions/PolicyVersionWithLocalizedVersionObject.ts
import { z as z44 } from "zod";
var PolicyVersionWithLocalizedVersionObject = z44.object({
  createdAt: z44.string().nullish(),
  description: z44.string().nullish(),
  displayVersion: z44.string(),
  id: z44.string(),
  isCommitted: z44.boolean(),
  isInEffect: z44.boolean(),
  localizedPolicyVersions: z44.array(LocalizedPolicyVersionObject).nullish(),
  publishedDate: z44.string().nullish(),
  status: z44.string().nullish(),
  updatedAt: z44.string().nullish()
});

// src/generated-definitions/RetrieveLocalizedPolicyVersionPublicResponse.ts
import { z as z45 } from "zod";
var RetrieveLocalizedPolicyVersionPublicResponse = z45.object({
  attachmentChecksum: z45.string().nullish(),
  attachmentLocation: z45.string().nullish(),
  attachmentVersionIdentifier: z45.string().nullish(),
  basePolicyId: z45.string().nullish(),
  baseUrls: z45.array(z45.string()).nullish(),
  contentType: z45.string().nullish(),
  createdAt: z45.string().nullish(),
  description: z45.string().nullish(),
  id: z45.string(),
  isHidden: z45.boolean().nullish(),
  localeCode: z45.string(),
  namespace: z45.string(),
  policy: PolicyObject,
  policyVersion: PolicyVersionObject,
  tags: z45.array(z45.string()).nullish(),
  updatedAt: z45.string().nullish()
});

// src/generated-definitions/RetrievePolicyPublicResponse.ts
import { z as z46 } from "zod";
var RetrievePolicyPublicResponse = z46.object({
  basePolicyId: z46.string(),
  baseUrls: z46.array(z46.string()).nullish(),
  countryCode: z46.string(),
  countryGroupCode: z46.string().nullish(),
  createdAt: z46.string().nullish(),
  description: z46.string().nullish(),
  id: z46.string(),
  isDefaultOpted: z46.boolean(),
  isDefaultSelection: z46.boolean(),
  isMandatory: z46.boolean(),
  namespace: z46.string(),
  policyName: z46.string(),
  policyType: z46.string(),
  policyVersions: z46.array(PolicyVersionWithLocalizedVersionObject).nullish(),
  readableId: z46.string().nullish(),
  shouldNotifyOnUpdate: z46.boolean(),
  tags: z46.array(z46.string()).nullish(),
  updatedAt: z46.string().nullish()
});

// src/generated-definitions/RetrievePolicyPublicResponseArray.ts
import { z as z47 } from "zod";
var RetrievePolicyPublicResponseArray = z47.array(RetrievePolicyPublicResponse);

// src/generated-definitions/RetrieveUserEligibilitiesResponse.ts
import { z as z48 } from "zod";
var RetrieveUserEligibilitiesResponse = z48.object({
  baseUrls: z48.array(z48.string()).nullish(),
  countryCode: z48.string(),
  countryGroupCode: z48.string().nullish(),
  description: z48.string().nullish(),
  isAccepted: z48.boolean(),
  isHiddenPublic: z48.boolean().nullish(),
  isMandatory: z48.boolean(),
  namespace: z48.string(),
  policyId: z48.string(),
  policyName: z48.string(),
  policyType: z48.string(),
  policyVersions: z48.array(PolicyVersionWithLocalizedVersionObject).nullish(),
  readableId: z48.string().nullish()
});

// src/generated-definitions/RetrieveUserEligibilitiesResponseArray.ts
import { z as z49 } from "zod";
var RetrieveUserEligibilitiesResponseArray = z49.array(RetrieveUserEligibilitiesResponse);

// src/generated-public/endpoints/Agreement$.ts
import { Validate as Validate15 } from "@accelbyte/sdk";
import { z as z50 } from "zod";
var Agreement$ = class {
  // @ts-ignore
  // prettier-ignore
  constructor(axiosInstance, namespace, useSchemaValidation = true) {
    this.axiosInstance = axiosInstance;
    this.namespace = namespace;
    this.useSchemaValidation = useSchemaValidation;
  }
  /**
   * Retrieve accepted Legal Agreements.
   */
  getAgreementsPolicies() {
    const params = {};
    const url = "/agreement/public/agreements/policies";
    const resultPromise = this.axiosInstance.get(url, { params });
    return Validate15.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      RetrieveAcceptedAgreementResponseArray,
      "RetrieveAcceptedAgreementResponseArray"
    );
  }
  /**
   * Accepts many legal policy versions all at once. Supply with localized version policy id to accept an agreement.
   */
  createAgreementPolicy(data) {
    const params = {};
    const url = "/agreement/public/agreements/policies";
    const resultPromise = this.axiosInstance.post(url, data, { params });
    return Validate15.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      AcceptAgreementResponse,
      "AcceptAgreementResponse"
    );
  }
  /**
   * @deprecated
   * Accepts many legal policy versions all at once. Supply with localized version policy id and userId to accept an agreement. This endpoint used by Authentication Service during new user registration.
   */
  createAgreementPolicyUser_ByUserId(userId, data) {
    const params = {};
    const url = "/agreement/public/agreements/policies/users/{userId}".replace("{userId}", userId);
    const resultPromise = this.axiosInstance.post(url, data, { params });
    return Validate15.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      AcceptAgreementResponse,
      "AcceptAgreementResponse"
    );
  }
  /**
   * Change marketing preference consent.
   */
  patchAgreementLocalizedPolicyVersionPreference(data) {
    const params = {};
    const url = "/agreement/public/agreements/localized-policy-versions/preferences";
    const resultPromise = this.axiosInstance.patch(url, data, { params });
    return Validate15.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, z50.unknown(), "z.unknown()");
  }
  /**
   * Accepts a legal policy version. Supply with localized version policy id to accept an agreement
   */
  createAgreementLocalizedPolicyVersion_ByLocalizedPolicyVersionId(localizedPolicyVersionId) {
    const params = {};
    const url = "/agreement/public/agreements/localized-policy-versions/{localizedPolicyVersionId}".replace(
      "{localizedPolicyVersionId}",
      localizedPolicyVersionId
    );
    const resultPromise = this.axiosInstance.post(url, null, { params });
    return Validate15.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, z50.unknown(), "z.unknown()");
  }
  /**
   * @deprecated
   * Accepts many legal policy versions all at once. Supply with localized version policy id, version policy id, policy id, userId, namespace, country code and client id to accept an agreement. This endpoint used by APIGateway during new user registration.
   */
  createUserPolicyAgreement_ByCountryCode_ByClientId_ByUserId(countryCode, clientId, userId, data) {
    const params = {};
    const url = "/agreement/public/agreements/policies/namespaces/{namespace}/countries/{countryCode}/clients/{clientId}/users/{userId}".replace("{namespace}", this.namespace).replace("{countryCode}", countryCode).replace("{clientId}", clientId).replace("{userId}", userId);
    const resultPromise = this.axiosInstance.post(url, data, { params });
    return Validate15.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      AcceptAgreementResponse,
      "AcceptAgreementResponse"
    );
  }
};

// src/generated-public/AgreementApi.ts
import { ApiUtils as ApiUtils15, Network as Network15 } from "@accelbyte/sdk";
function AgreementApi(sdk, args) {
  const sdkAssembly = sdk.assembly();
  const namespace = args?.coreConfig?.namespace ?? sdkAssembly.coreConfig.namespace;
  const useSchemaValidation = args?.coreConfig?.useSchemaValidation ?? sdkAssembly.coreConfig.useSchemaValidation;
  let axiosInstance = sdkAssembly.axiosInstance;
  const requestConfigOverrides = args?.axiosConfig?.request;
  const baseURLOverride = args?.coreConfig?.baseURL;
  const interceptorsOverride = args?.axiosConfig?.interceptors ?? [];
  if (requestConfigOverrides || baseURLOverride || interceptorsOverride.length > 0) {
    const requestConfig = ApiUtils15.mergeAxiosConfigs(sdkAssembly.axiosInstance.defaults, {
      ...baseURLOverride ? { baseURL: baseURLOverride } : {},
      ...requestConfigOverrides
    });
    axiosInstance = Network15.create(requestConfig);
    for (const interceptor of interceptorsOverride) {
      if (interceptor.type === "request") {
        axiosInstance.interceptors.request.use(interceptor.onRequest, interceptor.onError);
      }
      if (interceptor.type === "response") {
        axiosInstance.interceptors.response.use(interceptor.onSuccess, interceptor.onError);
      }
    }
  }
  async function getAgreementsPolicies() {
    const $ = new Agreement$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getAgreementsPolicies();
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function createAgreementPolicy(data) {
    const $ = new Agreement$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.createAgreementPolicy(data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function createAgreementPolicyUser_ByUserId(userId, data) {
    const $ = new Agreement$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.createAgreementPolicyUser_ByUserId(userId, data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function patchAgreementLocalizedPolicyVersionPreference(data) {
    const $ = new Agreement$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.patchAgreementLocalizedPolicyVersionPreference(data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function createAgreementLocalizedPolicyVersion_ByLocalizedPolicyVersionId(localizedPolicyVersionId) {
    const $ = new Agreement$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.createAgreementLocalizedPolicyVersion_ByLocalizedPolicyVersionId(localizedPolicyVersionId);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function createUserPolicyAgreement_ByCountryCode_ByClientId_ByUserId(countryCode, clientId, userId, data) {
    const $ = new Agreement$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.createUserPolicyAgreement_ByCountryCode_ByClientId_ByUserId(countryCode, clientId, userId, data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  return {
    /**
     * Retrieve accepted Legal Agreements.
     */
    getAgreementsPolicies,
    /**
     * Accepts many legal policy versions all at once. Supply with localized version policy id to accept an agreement.
     */
    createAgreementPolicy,
    /**
     * @deprecated
     * Accepts many legal policy versions all at once. Supply with localized version policy id and userId to accept an agreement. This endpoint used by Authentication Service during new user registration.
     */
    createAgreementPolicyUser_ByUserId,
    /**
     * Change marketing preference consent.
     */
    patchAgreementLocalizedPolicyVersionPreference,
    /**
     * Accepts a legal policy version. Supply with localized version policy id to accept an agreement
     */
    createAgreementLocalizedPolicyVersion_ByLocalizedPolicyVersionId,
    /**
     * @deprecated
     * Accepts many legal policy versions all at once. Supply with localized version policy id, version policy id, policy id, userId, namespace, country code and client id to accept an agreement. This endpoint used by APIGateway during new user registration.
     */
    createUserPolicyAgreement_ByCountryCode_ByClientId_ByUserId
  };
}

// src/generated-public/endpoints/Eligibilities$.ts
import { Validate as Validate16 } from "@accelbyte/sdk";
var Eligibilities$ = class {
  // @ts-ignore
  // prettier-ignore
  constructor(axiosInstance, namespace, useSchemaValidation = true) {
    this.axiosInstance = axiosInstance;
    this.namespace = namespace;
    this.useSchemaValidation = useSchemaValidation;
  }
  /**
   * Retrieve the active policies and its conformance status by user.&lt;br&gt;This process supports cross-namespace checking, that means if the active policy already accepted by the same user in other namespace, then it will be considered as eligible.
   */
  getEligibility_ByNamespace() {
    const params = {};
    const url = "/agreement/public/eligibilities/namespaces/{namespace}".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.get(url, { params });
    return Validate16.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      RetrieveUserEligibilitiesResponseArray,
      "RetrieveUserEligibilitiesResponseArray"
    );
  }
  /**
   * Retrieve the active policies and its conformance status by user.&lt;br&gt;This process only supports cross-namespace checking between game namespace and publisher namespace , that means if the active policy already accepted by the same user in publisher namespace, then it will also be considered as eligible in non-publisher namespace.
   */
  getUserEligibility_ByCountryCode_ByClientId_ByUserId(countryCode, clientId, userId) {
    const params = {};
    const url = "/agreement/public/eligibilities/namespaces/{namespace}/countries/{countryCode}/clients/{clientId}/users/{userId}".replace("{namespace}", this.namespace).replace("{countryCode}", countryCode).replace("{clientId}", clientId).replace("{userId}", userId);
    const resultPromise = this.axiosInstance.get(url, { params });
    return Validate16.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      RetrieveUserEligibilitiesIndirectResponse,
      "RetrieveUserEligibilitiesIndirectResponse"
    );
  }
};

// src/generated-public/EligibilitiesApi.ts
import { ApiUtils as ApiUtils16, Network as Network16 } from "@accelbyte/sdk";
function EligibilitiesApi(sdk, args) {
  const sdkAssembly = sdk.assembly();
  const namespace = args?.coreConfig?.namespace ?? sdkAssembly.coreConfig.namespace;
  const useSchemaValidation = args?.coreConfig?.useSchemaValidation ?? sdkAssembly.coreConfig.useSchemaValidation;
  let axiosInstance = sdkAssembly.axiosInstance;
  const requestConfigOverrides = args?.axiosConfig?.request;
  const baseURLOverride = args?.coreConfig?.baseURL;
  const interceptorsOverride = args?.axiosConfig?.interceptors ?? [];
  if (requestConfigOverrides || baseURLOverride || interceptorsOverride.length > 0) {
    const requestConfig = ApiUtils16.mergeAxiosConfigs(sdkAssembly.axiosInstance.defaults, {
      ...baseURLOverride ? { baseURL: baseURLOverride } : {},
      ...requestConfigOverrides
    });
    axiosInstance = Network16.create(requestConfig);
    for (const interceptor of interceptorsOverride) {
      if (interceptor.type === "request") {
        axiosInstance.interceptors.request.use(interceptor.onRequest, interceptor.onError);
      }
      if (interceptor.type === "response") {
        axiosInstance.interceptors.response.use(interceptor.onSuccess, interceptor.onError);
      }
    }
  }
  async function getEligibility_ByNamespace() {
    const $ = new Eligibilities$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getEligibility_ByNamespace();
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getUserEligibility_ByCountryCode_ByClientId_ByUserId(countryCode, clientId, userId) {
    const $ = new Eligibilities$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getUserEligibility_ByCountryCode_ByClientId_ByUserId(countryCode, clientId, userId);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  return {
    /**
     * Retrieve the active policies and its conformance status by user.&lt;br&gt;This process supports cross-namespace checking, that means if the active policy already accepted by the same user in other namespace, then it will be considered as eligible.
     */
    getEligibility_ByNamespace,
    /**
     * Retrieve the active policies and its conformance status by user.&lt;br&gt;This process only supports cross-namespace checking between game namespace and publisher namespace , that means if the active policy already accepted by the same user in publisher namespace, then it will also be considered as eligible in non-publisher namespace.
     */
    getUserEligibility_ByCountryCode_ByClientId_ByUserId
  };
}

// src/generated-public/endpoints/LocalizedPolicyVersions$.ts
import { Validate as Validate17 } from "@accelbyte/sdk";
var LocalizedPolicyVersions$ = class {
  // @ts-ignore
  // prettier-ignore
  constructor(axiosInstance, namespace, useSchemaValidation = true) {
    this.axiosInstance = axiosInstance;
    this.namespace = namespace;
    this.useSchemaValidation = useSchemaValidation;
  }
  /**
   * Retrieve specific localized policy version including the policy version and base policy version where the localized policy version located.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;/ul&gt;
   */
  getLocalizedPolicyVersion_ByLocalizedPolicyVersionId(localizedPolicyVersionId) {
    const params = {};
    const url = "/agreement/public/localized-policy-versions/{localizedPolicyVersionId}".replace(
      "{localizedPolicyVersionId}",
      localizedPolicyVersionId
    );
    const resultPromise = this.axiosInstance.get(url, { params });
    return Validate17.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      RetrieveLocalizedPolicyVersionPublicResponse,
      "RetrieveLocalizedPolicyVersionPublicResponse"
    );
  }
};

// src/generated-public/endpoints/LocalizedPolicyVersionsWithNamespace$.ts
import { Validate as Validate18 } from "@accelbyte/sdk";
var LocalizedPolicyVersionsWithNamespace$ = class {
  // @ts-ignore
  // prettier-ignore
  constructor(axiosInstance, namespace, useSchemaValidation = true) {
    this.axiosInstance = axiosInstance;
    this.namespace = namespace;
    this.useSchemaValidation = useSchemaValidation;
  }
  /**
   * Retrieve specific localized policy version including the policy version and base policy version where the localized policy version located.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;/ul&gt;
   */
  getLocalizedPolicyVersion_ByLocalizedPolicyVersionId(localizedPolicyVersionId) {
    const params = {};
    const url = "/agreement/public/namespaces/{namespace}/localized-policy-versions/{localizedPolicyVersionId}".replace("{namespace}", this.namespace).replace("{localizedPolicyVersionId}", localizedPolicyVersionId);
    const resultPromise = this.axiosInstance.get(url, { params });
    return Validate18.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      RetrieveLocalizedPolicyVersionPublicResponse,
      "RetrieveLocalizedPolicyVersionPublicResponse"
    );
  }
};

// src/generated-public/endpoints/Policies$.ts
import { Validate as Validate19 } from "@accelbyte/sdk";
import { z as z51 } from "zod";
var Policies$ = class {
  // @ts-ignore
  // prettier-ignore
  constructor(axiosInstance, namespace, useSchemaValidation = true) {
    this.axiosInstance = axiosInstance;
    this.namespace = namespace;
    this.useSchemaValidation = useSchemaValidation;
  }
  /**
   * Retrieve List of Countries that have Active and Visible Legal Policies.
   */
  getPoliciesCountriesList() {
    const params = {};
    const url = "/agreement/public/policies/countries/list";
    const resultPromise = this.axiosInstance.get(url, { params });
    return Validate19.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, z51.unknown(), "z.unknown()");
  }
  /**
   * Retrieve all active latest policies based on a namespace and country. The country will be read from user token.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Leave the policyType empty if you want to be responded with all policy type&lt;/i&gt;&lt;/li&gt;&lt;li&gt;&lt;i&gt;Fill the tags if you want to filter the responded policy by tags&lt;/i&gt;&lt;/li&gt;&lt;li&gt;&lt;i&gt;Fill the defaultOnEmpty with true if you want to be responded with default country-specific policy if your requested country is not exist&lt;/i&gt;&lt;/li&gt;&lt;li&gt;&lt;i&gt;Fill the alwaysIncludeDefault with true if you want to be responded with always include default policy. If there are duplicate policies (default policies and country specific policies with same base policy) it&#39;ll include policy with same country code, for example:&lt;ul&gt;&lt;li&gt;Document 1 (default): Region US (default), UA&lt;/li&gt;&lt;li&gt;Document 2 (default): Region US (default)&lt;/li&gt;&lt;li&gt;Document 3 (default): Region US (default)&lt;/li&gt;&lt;li&gt;User: Region UA&lt;/li&gt;&lt;li&gt;Query: alwaysIncludeDefault: true&lt;/li&gt;&lt;li&gt;Response: Document 1 (UA), Document 2 (US), Document 3 (US)&lt;/li&gt;&lt;/ul&gt;&lt;/i&gt;&lt;/li&gt;&lt;/ul&gt;
   */
  getPolicy_ByNamespace(queryParams) {
    const params = { ...queryParams };
    const url = "/agreement/public/policies/namespaces/{namespace}".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.get(url, { params });
    return Validate19.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      RetrievePolicyPublicResponseArray,
      "RetrievePolicyPublicResponseArray"
    );
  }
  /**
   * Retrieve all active latest policies based on a country.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Leave the policyType empty if you want to be responded with all policy type&lt;/i&gt;&lt;/li&gt;&lt;li&gt;&lt;i&gt;Fill the tags if you want to filter the responded policy by tags&lt;/i&gt;&lt;/li&gt;&lt;li&gt;&lt;i&gt;Fill the defaultOnEmpty with true if you want to be responded with default country-specific policy if your requested country is not exist&lt;/i&gt;&lt;/li&gt;&lt;/ul&gt;
   */
  getPolicyCountry_ByCountryCode(countryCode, queryParams) {
    const params = { ...queryParams };
    const url = "/agreement/public/policies/countries/{countryCode}".replace("{countryCode}", countryCode);
    const resultPromise = this.axiosInstance.get(url, { params });
    return Validate19.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      RetrievePolicyPublicResponseArray,
      "RetrievePolicyPublicResponseArray"
    );
  }
  /**
   * Retrieve all active latest policies based on a namespace and country.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Leave the policyType empty if you want to be responded with all policy type&lt;/i&gt;&lt;/li&gt;&lt;li&gt;&lt;i&gt;Fill the tags if you want to filter the responded policy by tags&lt;/i&gt;&lt;/li&gt;&lt;li&gt;&lt;i&gt;Fill the defaultOnEmpty with true if you want to be responded with default country-specific policy if your requested country is not exist&lt;/i&gt;&lt;/li&gt;&lt;li&gt;&lt;i&gt;Fill the alwaysIncludeDefault with true if you want to be responded with always include default policy. If there are duplicate policies (default policies and country specific policies with same base policy) it&#39;ll include policy with same country code, for example:&lt;ul&gt;&lt;li&gt;Document 1 (default): Region US (default), UA&lt;/li&gt;&lt;li&gt;Document 2 (default): Region US (default)&lt;/li&gt;&lt;li&gt;Document 3 (default): Region US (default)&lt;/li&gt;&lt;li&gt;User: Region UA&lt;/li&gt;&lt;li&gt;Query: alwaysIncludeDefault: true&lt;/li&gt;&lt;li&gt;Response: Document 1 (UA), Document 2 (US), Document 3 (US)&lt;/li&gt;&lt;/ul&gt;
   */
  getPolicyCountry_ByCountryCode_ByNS(countryCode, queryParams) {
    const params = { ...queryParams };
    const url = "/agreement/public/policies/namespaces/{namespace}/countries/{countryCode}".replace("{namespace}", this.namespace).replace("{countryCode}", countryCode);
    const resultPromise = this.axiosInstance.get(url, { params });
    return Validate19.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      RetrievePolicyPublicResponseArray,
      "RetrievePolicyPublicResponseArray"
    );
  }
};

// src/generated-public/endpoints/Utility$.ts
import { Validate as Validate20 } from "@accelbyte/sdk";
var Utility$ = class {
  // @ts-ignore
  // prettier-ignore
  constructor(axiosInstance, namespace, useSchemaValidation = true) {
    this.axiosInstance = axiosInstance;
    this.namespace = namespace;
    this.useSchemaValidation = useSchemaValidation;
  }
  /**
   * Readiness status defined as at least one legal basePolicy is present and having active basePolicy.
   */
  getReadiness() {
    const params = {};
    const url = "/agreement/public/readiness";
    const resultPromise = this.axiosInstance.get(url, { params });
    return Validate20.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      LegalReadinessStatusResponse,
      "LegalReadinessStatusResponse"
    );
  }
};

// src/generated-public/LocalizedPolicyVersionsApi.ts
import { ApiUtils as ApiUtils17, Network as Network17 } from "@accelbyte/sdk";
function LocalizedPolicyVersionsApi(sdk, args) {
  const sdkAssembly = sdk.assembly();
  const namespace = args?.coreConfig?.namespace ?? sdkAssembly.coreConfig.namespace;
  const useSchemaValidation = args?.coreConfig?.useSchemaValidation ?? sdkAssembly.coreConfig.useSchemaValidation;
  let axiosInstance = sdkAssembly.axiosInstance;
  const requestConfigOverrides = args?.axiosConfig?.request;
  const baseURLOverride = args?.coreConfig?.baseURL;
  const interceptorsOverride = args?.axiosConfig?.interceptors ?? [];
  if (requestConfigOverrides || baseURLOverride || interceptorsOverride.length > 0) {
    const requestConfig = ApiUtils17.mergeAxiosConfigs(sdkAssembly.axiosInstance.defaults, {
      ...baseURLOverride ? { baseURL: baseURLOverride } : {},
      ...requestConfigOverrides
    });
    axiosInstance = Network17.create(requestConfig);
    for (const interceptor of interceptorsOverride) {
      if (interceptor.type === "request") {
        axiosInstance.interceptors.request.use(interceptor.onRequest, interceptor.onError);
      }
      if (interceptor.type === "response") {
        axiosInstance.interceptors.response.use(interceptor.onSuccess, interceptor.onError);
      }
    }
  }
  async function getLocalizedPolicyVersion_ByLocalizedPolicyVersionId(localizedPolicyVersionId) {
    const $ = new LocalizedPolicyVersions$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getLocalizedPolicyVersion_ByLocalizedPolicyVersionId(localizedPolicyVersionId);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  return {
    /**
     * Retrieve specific localized policy version including the policy version and base policy version where the localized policy version located.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;/ul&gt;
     */
    getLocalizedPolicyVersion_ByLocalizedPolicyVersionId
  };
}

// src/generated-public/LocalizedPolicyVersionsWithNamespaceApi.ts
import { ApiUtils as ApiUtils18, Network as Network18 } from "@accelbyte/sdk";
function LocalizedPolicyVersionsWithNamespaceApi(sdk, args) {
  const sdkAssembly = sdk.assembly();
  const namespace = args?.coreConfig?.namespace ?? sdkAssembly.coreConfig.namespace;
  const useSchemaValidation = args?.coreConfig?.useSchemaValidation ?? sdkAssembly.coreConfig.useSchemaValidation;
  let axiosInstance = sdkAssembly.axiosInstance;
  const requestConfigOverrides = args?.axiosConfig?.request;
  const baseURLOverride = args?.coreConfig?.baseURL;
  const interceptorsOverride = args?.axiosConfig?.interceptors ?? [];
  if (requestConfigOverrides || baseURLOverride || interceptorsOverride.length > 0) {
    const requestConfig = ApiUtils18.mergeAxiosConfigs(sdkAssembly.axiosInstance.defaults, {
      ...baseURLOverride ? { baseURL: baseURLOverride } : {},
      ...requestConfigOverrides
    });
    axiosInstance = Network18.create(requestConfig);
    for (const interceptor of interceptorsOverride) {
      if (interceptor.type === "request") {
        axiosInstance.interceptors.request.use(interceptor.onRequest, interceptor.onError);
      }
      if (interceptor.type === "response") {
        axiosInstance.interceptors.response.use(interceptor.onSuccess, interceptor.onError);
      }
    }
  }
  async function getLocalizedPolicyVersion_ByLocalizedPolicyVersionId(localizedPolicyVersionId) {
    const $ = new LocalizedPolicyVersionsWithNamespace$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getLocalizedPolicyVersion_ByLocalizedPolicyVersionId(localizedPolicyVersionId);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  return {
    /**
     * Retrieve specific localized policy version including the policy version and base policy version where the localized policy version located.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;/ul&gt;
     */
    getLocalizedPolicyVersion_ByLocalizedPolicyVersionId
  };
}

// src/generated-public/PoliciesApi.ts
import { ApiUtils as ApiUtils19, Network as Network19 } from "@accelbyte/sdk";
function PoliciesApi(sdk, args) {
  const sdkAssembly = sdk.assembly();
  const namespace = args?.coreConfig?.namespace ?? sdkAssembly.coreConfig.namespace;
  const useSchemaValidation = args?.coreConfig?.useSchemaValidation ?? sdkAssembly.coreConfig.useSchemaValidation;
  let axiosInstance = sdkAssembly.axiosInstance;
  const requestConfigOverrides = args?.axiosConfig?.request;
  const baseURLOverride = args?.coreConfig?.baseURL;
  const interceptorsOverride = args?.axiosConfig?.interceptors ?? [];
  if (requestConfigOverrides || baseURLOverride || interceptorsOverride.length > 0) {
    const requestConfig = ApiUtils19.mergeAxiosConfigs(sdkAssembly.axiosInstance.defaults, {
      ...baseURLOverride ? { baseURL: baseURLOverride } : {},
      ...requestConfigOverrides
    });
    axiosInstance = Network19.create(requestConfig);
    for (const interceptor of interceptorsOverride) {
      if (interceptor.type === "request") {
        axiosInstance.interceptors.request.use(interceptor.onRequest, interceptor.onError);
      }
      if (interceptor.type === "response") {
        axiosInstance.interceptors.response.use(interceptor.onSuccess, interceptor.onError);
      }
    }
  }
  async function getPoliciesCountriesList() {
    const $ = new Policies$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getPoliciesCountriesList();
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getPolicy_ByNamespace(queryParams) {
    const $ = new Policies$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getPolicy_ByNamespace(queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getPolicyCountry_ByCountryCode(countryCode, queryParams) {
    const $ = new Policies$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getPolicyCountry_ByCountryCode(countryCode, queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getPolicyCountry_ByCountryCode_ByNS(countryCode, queryParams) {
    const $ = new Policies$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getPolicyCountry_ByCountryCode_ByNS(countryCode, queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  return {
    /**
     * Retrieve List of Countries that have Active and Visible Legal Policies.
     */
    getPoliciesCountriesList,
    /**
     * Retrieve all active latest policies based on a namespace and country. The country will be read from user token.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Leave the policyType empty if you want to be responded with all policy type&lt;/i&gt;&lt;/li&gt;&lt;li&gt;&lt;i&gt;Fill the tags if you want to filter the responded policy by tags&lt;/i&gt;&lt;/li&gt;&lt;li&gt;&lt;i&gt;Fill the defaultOnEmpty with true if you want to be responded with default country-specific policy if your requested country is not exist&lt;/i&gt;&lt;/li&gt;&lt;li&gt;&lt;i&gt;Fill the alwaysIncludeDefault with true if you want to be responded with always include default policy. If there are duplicate policies (default policies and country specific policies with same base policy) it&#39;ll include policy with same country code, for example:&lt;ul&gt;&lt;li&gt;Document 1 (default): Region US (default), UA&lt;/li&gt;&lt;li&gt;Document 2 (default): Region US (default)&lt;/li&gt;&lt;li&gt;Document 3 (default): Region US (default)&lt;/li&gt;&lt;li&gt;User: Region UA&lt;/li&gt;&lt;li&gt;Query: alwaysIncludeDefault: true&lt;/li&gt;&lt;li&gt;Response: Document 1 (UA), Document 2 (US), Document 3 (US)&lt;/li&gt;&lt;/ul&gt;&lt;/i&gt;&lt;/li&gt;&lt;/ul&gt;
     */
    getPolicy_ByNamespace,
    /**
     * Retrieve all active latest policies based on a country.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Leave the policyType empty if you want to be responded with all policy type&lt;/i&gt;&lt;/li&gt;&lt;li&gt;&lt;i&gt;Fill the tags if you want to filter the responded policy by tags&lt;/i&gt;&lt;/li&gt;&lt;li&gt;&lt;i&gt;Fill the defaultOnEmpty with true if you want to be responded with default country-specific policy if your requested country is not exist&lt;/i&gt;&lt;/li&gt;&lt;/ul&gt;
     */
    getPolicyCountry_ByCountryCode,
    /**
     * Retrieve all active latest policies based on a namespace and country.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Leave the policyType empty if you want to be responded with all policy type&lt;/i&gt;&lt;/li&gt;&lt;li&gt;&lt;i&gt;Fill the tags if you want to filter the responded policy by tags&lt;/i&gt;&lt;/li&gt;&lt;li&gt;&lt;i&gt;Fill the defaultOnEmpty with true if you want to be responded with default country-specific policy if your requested country is not exist&lt;/i&gt;&lt;/li&gt;&lt;li&gt;&lt;i&gt;Fill the alwaysIncludeDefault with true if you want to be responded with always include default policy. If there are duplicate policies (default policies and country specific policies with same base policy) it&#39;ll include policy with same country code, for example:&lt;ul&gt;&lt;li&gt;Document 1 (default): Region US (default), UA&lt;/li&gt;&lt;li&gt;Document 2 (default): Region US (default)&lt;/li&gt;&lt;li&gt;Document 3 (default): Region US (default)&lt;/li&gt;&lt;li&gt;User: Region UA&lt;/li&gt;&lt;li&gt;Query: alwaysIncludeDefault: true&lt;/li&gt;&lt;li&gt;Response: Document 1 (UA), Document 2 (US), Document 3 (US)&lt;/li&gt;&lt;/ul&gt;
     */
    getPolicyCountry_ByCountryCode_ByNS
  };
}

// src/generated-public/UtilityApi.ts
import { ApiUtils as ApiUtils20, Network as Network20 } from "@accelbyte/sdk";
function UtilityApi(sdk, args) {
  const sdkAssembly = sdk.assembly();
  const namespace = args?.coreConfig?.namespace ?? sdkAssembly.coreConfig.namespace;
  const useSchemaValidation = args?.coreConfig?.useSchemaValidation ?? sdkAssembly.coreConfig.useSchemaValidation;
  let axiosInstance = sdkAssembly.axiosInstance;
  const requestConfigOverrides = args?.axiosConfig?.request;
  const baseURLOverride = args?.coreConfig?.baseURL;
  const interceptorsOverride = args?.axiosConfig?.interceptors ?? [];
  if (requestConfigOverrides || baseURLOverride || interceptorsOverride.length > 0) {
    const requestConfig = ApiUtils20.mergeAxiosConfigs(sdkAssembly.axiosInstance.defaults, {
      ...baseURLOverride ? { baseURL: baseURLOverride } : {},
      ...requestConfigOverrides
    });
    axiosInstance = Network20.create(requestConfig);
    for (const interceptor of interceptorsOverride) {
      if (interceptor.type === "request") {
        axiosInstance.interceptors.request.use(interceptor.onRequest, interceptor.onError);
      }
      if (interceptor.type === "response") {
        axiosInstance.interceptors.response.use(interceptor.onSuccess, interceptor.onError);
      }
    }
  }
  async function getReadiness() {
    const $ = new Utility$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getReadiness();
    if (resp.error) throw resp.error;
    return resp.response;
  }
  return {
    /**
     * Readiness status defined as at least one legal basePolicy is present and having active basePolicy.
     */
    getReadiness
  };
}

export {
  Paging,
  LocalizedPolicyVersionObject,
  RetrieveUserAcceptedAgreementResponse,
  PagedRetrieveUserAcceptedAgreementResponse,
  RetrieveAcceptedAgreementResponse,
  RetrieveAcceptedAgreementResponseArray,
  AgreementAdmin$,
  AgreementAdminApi,
  DownloadExportedAgreementsInCsvResponse,
  InitiateExportAgreementsToCsvResponse,
  UserAgreementsResponse,
  UserAgreementsResponseArray,
  AgreementWithNamespaceAdmin$,
  AgreementWithNamespaceAdminApi,
  AnonymizationAdmin$,
  AnonymizationAdminApi,
  CreateBasePolicyResponse,
  PolicyObject,
  RetrieveBasePolicyResponse,
  RetrieveBasePolicyResponseArray,
  PolicyVersionObject,
  RetrievePolicyResponse,
  RetrievePolicyTypeResponse,
  RetrievePolicyTypeResponseArray,
  UpdateBasePolicyResponse,
  BaseLegalPoliciesAdmin$,
  BaseLegalPoliciesAdminApi,
  BaseLegalPoliciesWithNamespaceAdmin$,
  BaseLegalPoliciesWithNamespaceAdminApi,
  CreateLocalizedPolicyVersionResponse,
  RetrieveLocalizedPolicyVersionResponse,
  RetrieveLocalizedPolicyVersionResponseArray,
  UpdateLocalizedPolicyVersionResponse,
  UploadLocalizedPolicyVersionAttachmentResponse,
  LocalizedPolicyVersionsAdmin$,
  LocalizedPolicyVersionsWithNamespaceAdmin$,
  RetrievePolicyResponseArray,
  PoliciesAdmin$,
  PoliciesWithNamespaceAdmin$,
  CreatePolicyVersionResponse,
  RetrievePolicyVersionResponse,
  RetrievePolicyVersionResponseArray,
  UpdatePolicyVersionResponse,
  PolicyVersionsAdmin$,
  PolicyVersionsWithNamespaceAdmin$,
  AcceptAgreementResponse,
  UserAgreementAdmin$,
  RetrieveUserEligibilitiesIndirectResponse,
  UserEligibilitiesAdmin$,
  RetrieveUserInfoCacheStatusResponse,
  RetrieveUserInfoCacheStatusResponseArray,
  UserInfoAdmin$,
  LocalizedPolicyVersionsAdminApi,
  LocalizedPolicyVersionsWithNamespaceAdminApi,
  PoliciesAdminApi,
  PoliciesWithNamespaceAdminApi,
  PolicyVersionsAdminApi,
  PolicyVersionsWithNamespaceAdminApi,
  UserAgreementAdminApi,
  UserEligibilitiesAdminApi,
  UserInfoAdminApi,
  LegalReadinessStatusResponse,
  PolicyVersionWithLocalizedVersionObject,
  RetrieveLocalizedPolicyVersionPublicResponse,
  RetrievePolicyPublicResponse,
  RetrievePolicyPublicResponseArray,
  RetrieveUserEligibilitiesResponse,
  RetrieveUserEligibilitiesResponseArray,
  Agreement$,
  AgreementApi,
  Eligibilities$,
  EligibilitiesApi,
  LocalizedPolicyVersions$,
  LocalizedPolicyVersionsWithNamespace$,
  Policies$,
  Utility$,
  LocalizedPolicyVersionsApi,
  LocalizedPolicyVersionsWithNamespaceApi,
  PoliciesApi,
  UtilityApi
};

"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name2 in all)
    __defProp(target, name2, { get: all[name2], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/index.ts
var src_exports = {};
__export(src_exports, {
  AcceptAgreementRequest: () => AcceptAgreementRequest,
  AcceptAgreementResponse: () => AcceptAgreementResponse,
  Agreement$: () => Agreement$,
  AgreementAdmin$: () => AgreementAdmin$,
  AgreementAdminApi: () => AgreementAdminApi,
  AgreementApi: () => AgreementApi,
  AgreementWithNamespaceAdmin$: () => AgreementWithNamespaceAdmin$,
  AgreementWithNamespaceAdminApi: () => AgreementWithNamespaceAdminApi,
  AnonymizationAdmin$: () => AnonymizationAdmin$,
  AnonymizationAdminApi: () => AnonymizationAdminApi,
  BaseLegalPoliciesAdmin$: () => BaseLegalPoliciesAdmin$,
  BaseLegalPoliciesAdminApi: () => BaseLegalPoliciesAdminApi,
  BaseLegalPoliciesWithNamespaceAdmin$: () => BaseLegalPoliciesWithNamespaceAdmin$,
  BaseLegalPoliciesWithNamespaceAdminApi: () => BaseLegalPoliciesWithNamespaceAdminApi,
  CreateBasePolicyRequest: () => CreateBasePolicyRequest,
  CreateBasePolicyRequestV2: () => CreateBasePolicyRequestV2,
  CreateBasePolicyResponse: () => CreateBasePolicyResponse,
  CreateLocalizedPolicyVersionRequest: () => CreateLocalizedPolicyVersionRequest,
  CreateLocalizedPolicyVersionResponse: () => CreateLocalizedPolicyVersionResponse,
  CreatePolicyVersionRequest: () => CreatePolicyVersionRequest,
  CreatePolicyVersionResponse: () => CreatePolicyVersionResponse,
  DisplayedPolicy: () => DisplayedPolicy,
  DownloadExportedAgreementsInCsvResponse: () => DownloadExportedAgreementsInCsvResponse,
  Eligibilities$: () => Eligibilities$,
  EligibilitiesApi: () => EligibilitiesApi,
  ErrorEntity: () => ErrorEntity,
  FieldValidationError: () => FieldValidationError,
  InitiateExportAgreementsToCsvResponse: () => InitiateExportAgreementsToCsvResponse,
  Legal: () => Legal,
  LegalHelper: () => LegalHelper,
  LegalPolicyType: () => LegalPolicyType,
  LegalReadinessStatusResponse: () => LegalReadinessStatusResponse,
  LocalizedPolicyVersionObject: () => LocalizedPolicyVersionObject,
  LocalizedPolicyVersions$: () => LocalizedPolicyVersions$,
  LocalizedPolicyVersionsAdmin$: () => LocalizedPolicyVersionsAdmin$,
  LocalizedPolicyVersionsAdminApi: () => LocalizedPolicyVersionsAdminApi,
  LocalizedPolicyVersionsApi: () => LocalizedPolicyVersionsApi,
  LocalizedPolicyVersionsWithNamespace$: () => LocalizedPolicyVersionsWithNamespace$,
  LocalizedPolicyVersionsWithNamespaceAdmin$: () => LocalizedPolicyVersionsWithNamespaceAdmin$,
  LocalizedPolicyVersionsWithNamespaceAdminApi: () => LocalizedPolicyVersionsWithNamespaceAdminApi,
  LocalizedPolicyVersionsWithNamespaceApi: () => LocalizedPolicyVersionsWithNamespaceApi,
  PagedRetrieveUserAcceptedAgreementResponse: () => PagedRetrieveUserAcceptedAgreementResponse,
  Paging: () => Paging,
  Permission: () => Permission,
  Policies$: () => Policies$,
  PoliciesAdmin$: () => PoliciesAdmin$,
  PoliciesAdminApi: () => PoliciesAdminApi,
  PoliciesApi: () => PoliciesApi,
  PoliciesWithNamespaceAdmin$: () => PoliciesWithNamespaceAdmin$,
  PoliciesWithNamespaceAdminApi: () => PoliciesWithNamespaceAdminApi,
  PolicyObject: () => PolicyObject,
  PolicyVersionObject: () => PolicyVersionObject,
  PolicyVersionWithLocalizedVersionObject: () => PolicyVersionWithLocalizedVersionObject,
  PolicyVersionsAdmin$: () => PolicyVersionsAdmin$,
  PolicyVersionsAdminApi: () => PolicyVersionsAdminApi,
  PolicyVersionsWithNamespaceAdmin$: () => PolicyVersionsWithNamespaceAdmin$,
  PolicyVersionsWithNamespaceAdminApi: () => PolicyVersionsWithNamespaceAdminApi,
  RetrieveAcceptedAgreementResponse: () => RetrieveAcceptedAgreementResponse,
  RetrieveAcceptedAgreementResponseArray: () => RetrieveAcceptedAgreementResponseArray,
  RetrieveBasePolicyResponse: () => RetrieveBasePolicyResponse,
  RetrieveBasePolicyResponseArray: () => RetrieveBasePolicyResponseArray,
  RetrieveLocalizedPolicyVersionPublicResponse: () => RetrieveLocalizedPolicyVersionPublicResponse,
  RetrieveLocalizedPolicyVersionResponse: () => RetrieveLocalizedPolicyVersionResponse,
  RetrieveLocalizedPolicyVersionResponseArray: () => RetrieveLocalizedPolicyVersionResponseArray,
  RetrievePolicyPublicResponse: () => RetrievePolicyPublicResponse,
  RetrievePolicyPublicResponseArray: () => RetrievePolicyPublicResponseArray,
  RetrievePolicyResponse: () => RetrievePolicyResponse,
  RetrievePolicyResponseArray: () => RetrievePolicyResponseArray,
  RetrievePolicyTypeResponse: () => RetrievePolicyTypeResponse,
  RetrievePolicyTypeResponseArray: () => RetrievePolicyTypeResponseArray,
  RetrievePolicyVersionResponse: () => RetrievePolicyVersionResponse,
  RetrievePolicyVersionResponseArray: () => RetrievePolicyVersionResponseArray,
  RetrieveUserAcceptedAgreementResponse: () => RetrieveUserAcceptedAgreementResponse,
  RetrieveUserEligibilitiesIndirectResponse: () => RetrieveUserEligibilitiesIndirectResponse,
  RetrieveUserEligibilitiesResponse: () => RetrieveUserEligibilitiesResponse,
  RetrieveUserEligibilitiesResponseArray: () => RetrieveUserEligibilitiesResponseArray,
  RetrieveUserInfoCacheStatusResponse: () => RetrieveUserInfoCacheStatusResponse,
  RetrieveUserInfoCacheStatusResponseArray: () => RetrieveUserInfoCacheStatusResponseArray,
  UpdateBasePolicyRequest: () => UpdateBasePolicyRequest,
  UpdateBasePolicyRequestV2: () => UpdateBasePolicyRequestV2,
  UpdateBasePolicyResponse: () => UpdateBasePolicyResponse,
  UpdateLocalizedPolicyVersionRequest: () => UpdateLocalizedPolicyVersionRequest,
  UpdateLocalizedPolicyVersionResponse: () => UpdateLocalizedPolicyVersionResponse,
  UpdatePolicyRequest: () => UpdatePolicyRequest,
  UpdatePolicyVersionRequest: () => UpdatePolicyVersionRequest,
  UpdatePolicyVersionResponse: () => UpdatePolicyVersionResponse,
  UploadLocalizedPolicyVersionAttachmentResponse: () => UploadLocalizedPolicyVersionAttachmentResponse,
  UploadPolicyVersionAttachmentRequest: () => UploadPolicyVersionAttachmentRequest,
  UserAgreementAdmin$: () => UserAgreementAdmin$,
  UserAgreementAdminApi: () => UserAgreementAdminApi,
  UserAgreementsResponse: () => UserAgreementsResponse,
  UserAgreementsResponseArray: () => UserAgreementsResponseArray,
  UserEligibilitiesAdmin$: () => UserEligibilitiesAdmin$,
  UserEligibilitiesAdminApi: () => UserEligibilitiesAdminApi,
  UserInfoAdmin$: () => UserInfoAdmin$,
  UserInfoAdminApi: () => UserInfoAdminApi,
  UsersAgreementsRequest: () => UsersAgreementsRequest,
  Utility$: () => Utility$,
  UtilityApi: () => UtilityApi,
  ValidationErrorEntity: () => ValidationErrorEntity
});
module.exports = __toCommonJS(src_exports);

// src/generated-admin/AgreementAdminApi.ts
var import_sdk2 = require("@accelbyte/sdk");

// src/generated-admin/endpoints/AgreementAdmin$.ts
var import_sdk = require("@accelbyte/sdk");
var import_zod7 = require("zod");

// src/generated-definitions/PagedRetrieveUserAcceptedAgreementResponse.ts
var import_zod4 = require("zod");

// src/generated-definitions/Paging.ts
var import_zod = require("zod");
var Paging = import_zod.z.object({ next: import_zod.z.string().nullish(), previous: import_zod.z.string().nullish() });

// src/generated-definitions/RetrieveUserAcceptedAgreementResponse.ts
var import_zod3 = require("zod");

// src/generated-definitions/LocalizedPolicyVersionObject.ts
var import_zod2 = require("zod");
var LocalizedPolicyVersionObject = import_zod2.z.object({
  attachmentChecksum: import_zod2.z.string().nullish(),
  attachmentLocation: import_zod2.z.string().nullish(),
  attachmentVersionIdentifier: import_zod2.z.string().nullish(),
  contentType: import_zod2.z.string().nullish(),
  createdAt: import_zod2.z.string().nullish(),
  description: import_zod2.z.string().nullish(),
  id: import_zod2.z.string(),
  isDefaultSelection: import_zod2.z.boolean(),
  localeCode: import_zod2.z.string(),
  publishedDate: import_zod2.z.string().nullish(),
  status: import_zod2.z.string().nullish(),
  updatedAt: import_zod2.z.string().nullish()
});

// src/generated-definitions/RetrieveUserAcceptedAgreementResponse.ts
var RetrieveUserAcceptedAgreementResponse = import_zod3.z.object({
  createdAt: import_zod3.z.string().nullish(),
  displayName: import_zod3.z.string().nullish(),
  email: import_zod3.z.string().nullish(),
  id: import_zod3.z.string(),
  isAccepted: import_zod3.z.boolean().nullish(),
  localizedPolicyVersion: LocalizedPolicyVersionObject.nullish(),
  namespace: import_zod3.z.string().nullish(),
  policyName: import_zod3.z.string().nullish(),
  policyType: import_zod3.z.string().nullish(),
  publisherUserId: import_zod3.z.string().nullish(),
  signingDate: import_zod3.z.string().nullish(),
  updatedAt: import_zod3.z.string().nullish(),
  userId: import_zod3.z.string().nullish(),
  username: import_zod3.z.string().nullish()
});

// src/generated-definitions/PagedRetrieveUserAcceptedAgreementResponse.ts
var PagedRetrieveUserAcceptedAgreementResponse = import_zod4.z.object({
  data: import_zod4.z.array(RetrieveUserAcceptedAgreementResponse).nullish(),
  paging: Paging.nullish()
});

// src/generated-definitions/RetrieveAcceptedAgreementResponseArray.ts
var import_zod6 = require("zod");

// src/generated-definitions/RetrieveAcceptedAgreementResponse.ts
var import_zod5 = require("zod");
var RetrieveAcceptedAgreementResponse = import_zod5.z.object({
  countryCode: import_zod5.z.string().nullish(),
  createdAt: import_zod5.z.string().nullish(),
  description: import_zod5.z.string().nullish(),
  displayVersion: import_zod5.z.string().nullish(),
  id: import_zod5.z.string(),
  isAccepted: import_zod5.z.boolean().nullish(),
  localizedPolicyVersion: LocalizedPolicyVersionObject.nullish(),
  namespace: import_zod5.z.string().nullish(),
  policyId: import_zod5.z.string().nullish(),
  policyName: import_zod5.z.string().nullish(),
  policyType: import_zod5.z.string().nullish(),
  signingDate: import_zod5.z.string().nullish(),
  tags: import_zod5.z.array(import_zod5.z.string()).nullish(),
  updatedAt: import_zod5.z.string().nullish(),
  userId: import_zod5.z.string().nullish()
});

// src/generated-definitions/RetrieveAcceptedAgreementResponseArray.ts
var RetrieveAcceptedAgreementResponseArray = import_zod6.z.array(RetrieveAcceptedAgreementResponse);

// src/generated-admin/endpoints/AgreementAdmin$.ts
var AgreementAdmin$ = class {
  // @ts-ignore
  // prettier-ignore
  constructor(axiosInstance, namespace, useSchemaValidation = true) {
    this.axiosInstance = axiosInstance;
    this.namespace = namespace;
    this.useSchemaValidation = useSchemaValidation;
  }
  /**
   * This API will return users who has accepted a specific policy version.
   */
  getAgreementsPolicyVersionsUsers(queryParams) {
    const params = { limit: 20, ...queryParams };
    const url = "/agreement/admin/agreements/policy-versions/users";
    const resultPromise = this.axiosInstance.get(url, { params });
    return import_sdk.Validate.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      PagedRetrieveUserAcceptedAgreementResponse,
      "PagedRetrieveUserAcceptedAgreementResponse"
    );
  }
  /**
   * This API will return all accepted Legal Agreements for specified user
   */
  getAgreementPolicyUser_ByUserId(userId) {
    const params = {};
    const url = "/agreement/admin/agreements/policies/users/{userId}".replace("{userId}", userId);
    const resultPromise = this.axiosInstance.get(url, { params });
    return import_sdk.Validate.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      RetrieveAcceptedAgreementResponseArray,
      "RetrieveAcceptedAgreementResponseArray"
    );
  }
  /**
   * This API will Update Preference Consent
   */
  patchAgreementLocalizedPolicyVersionPreferenceUserId_ByUserId(userId, data) {
    const params = {};
    const url = "/agreement/admin/agreements/localized-policy-versions/preferences/namespaces/{namespace}/userId/{userId}".replace("{namespace}", this.namespace).replace("{userId}", userId);
    const resultPromise = this.axiosInstance.patch(url, data, { params });
    return import_sdk.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, import_zod7.z.unknown(), "z.unknown()");
  }
};

// src/generated-admin/AgreementAdminApi.ts
function AgreementAdminApi(sdk, args) {
  const sdkAssembly = sdk.assembly();
  const namespace = args?.coreConfig?.namespace ?? sdkAssembly.coreConfig.namespace;
  const useSchemaValidation = args?.coreConfig?.useSchemaValidation ?? sdkAssembly.coreConfig.useSchemaValidation;
  let axiosInstance = sdkAssembly.axiosInstance;
  const requestConfigOverrides = args?.axiosConfig?.request;
  const baseURLOverride = args?.coreConfig?.baseURL;
  const interceptorsOverride = args?.axiosConfig?.interceptors ?? [];
  if (requestConfigOverrides || baseURLOverride || interceptorsOverride.length > 0) {
    const requestConfig = import_sdk2.ApiUtils.mergeAxiosConfigs(sdkAssembly.axiosInstance.defaults, {
      ...baseURLOverride ? { baseURL: baseURLOverride } : {},
      ...requestConfigOverrides
    });
    axiosInstance = import_sdk2.Network.create(requestConfig);
    for (const interceptor of interceptorsOverride) {
      if (interceptor.type === "request") {
        axiosInstance.interceptors.request.use(interceptor.onRequest, interceptor.onError);
      }
      if (interceptor.type === "response") {
        axiosInstance.interceptors.response.use(interceptor.onSuccess, interceptor.onError);
      }
    }
  }
  async function getAgreementsPolicyVersionsUsers(queryParams) {
    const $ = new AgreementAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getAgreementsPolicyVersionsUsers(queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getAgreementPolicyUser_ByUserId(userId) {
    const $ = new AgreementAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getAgreementPolicyUser_ByUserId(userId);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function patchAgreementLocalizedPolicyVersionPreferenceUserId_ByUserId(userId, data) {
    const $ = new AgreementAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.patchAgreementLocalizedPolicyVersionPreferenceUserId_ByUserId(userId, data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  return {
    /**
     * This API will return users who has accepted a specific policy version.
     */
    getAgreementsPolicyVersionsUsers,
    /**
     * This API will return all accepted Legal Agreements for specified user
     */
    getAgreementPolicyUser_ByUserId,
    /**
     * This API will Update Preference Consent
     */
    patchAgreementLocalizedPolicyVersionPreferenceUserId_ByUserId
  };
}

// src/generated-admin/AgreementWithNamespaceAdminApi.ts
var import_sdk4 = require("@accelbyte/sdk");

// src/generated-admin/endpoints/AgreementWithNamespaceAdmin$.ts
var import_sdk3 = require("@accelbyte/sdk");

// src/generated-definitions/DownloadExportedAgreementsInCsvResponse.ts
var import_zod8 = require("zod");
var DownloadExportedAgreementsInCsvResponse = import_zod8.z.object({ done: import_zod8.z.boolean(), downloadUrl: import_zod8.z.string().nullish() });

// src/generated-definitions/InitiateExportAgreementsToCsvResponse.ts
var import_zod9 = require("zod");
var InitiateExportAgreementsToCsvResponse = import_zod9.z.object({ exportId: import_zod9.z.string(), processing: import_zod9.z.boolean() });

// src/generated-definitions/UserAgreementsResponseArray.ts
var import_zod11 = require("zod");

// src/generated-definitions/UserAgreementsResponse.ts
var import_zod10 = require("zod");
var UserAgreementsResponse = import_zod10.z.object({
  agreements: import_zod10.z.array(RetrieveAcceptedAgreementResponse).nullish(),
  userId: import_zod10.z.string().nullish()
});

// src/generated-definitions/UserAgreementsResponseArray.ts
var UserAgreementsResponseArray = import_zod11.z.array(UserAgreementsResponse);

// src/generated-admin/endpoints/AgreementWithNamespaceAdmin$.ts
var AgreementWithNamespaceAdmin$ = class {
  // @ts-ignore
  // prettier-ignore
  constructor(axiosInstance, namespace, useSchemaValidation = true) {
    this.axiosInstance = axiosInstance;
    this.namespace = namespace;
    this.useSchemaValidation = useSchemaValidation;
  }
  /**
   * This API will return all accepted Legal Agreements for each user, including agreements of game users if publisher user has corresponding game account.
   */
  createAgreement(data) {
    const params = {};
    const url = "/agreement/admin/namespaces/{namespace}/agreements".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.post(url, data, { params });
    return import_sdk3.Validate.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      UserAgreementsResponseArray,
      "UserAgreementsResponseArray"
    );
  }
  /**
   * This API will return all users who has accepted a specific policy version.
   */
  getAgreementsPolicyVersionsUsers(queryParams) {
    const params = { limit: 20, ...queryParams };
    const url = "/agreement/admin/namespaces/{namespace}/agreements/policy-versions/users".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.get(url, { params });
    return import_sdk3.Validate.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      PagedRetrieveUserAcceptedAgreementResponse,
      "PagedRetrieveUserAcceptedAgreementResponse"
    );
  }
  /**
   * This API will return all accepted Legal Agreements for specified user.
   */
  getAgreementPolicyUser_ByUserId(userId, queryParams) {
    const params = { ...queryParams };
    const url = "/agreement/admin/namespaces/{namespace}/agreements/policies/users/{userId}".replace("{namespace}", this.namespace).replace("{userId}", userId);
    const resultPromise = this.axiosInstance.get(url, { params });
    return import_sdk3.Validate.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      RetrieveAcceptedAgreementResponseArray,
      "RetrieveAcceptedAgreementResponseArray"
    );
  }
  /**
   * This API will check the status of export process.&lt;br&gt;If the export process has been completed, the response body will include the download url.
   */
  getAgreementsPolicyVersionsUsersExportCsvDownload(queryParams) {
    const params = { ...queryParams };
    const url = "/agreement/admin/namespaces/{namespace}/agreements/policy-versions/users/export-csv/download".replace(
      "{namespace}",
      this.namespace
    );
    const resultPromise = this.axiosInstance.get(url, { params });
    return import_sdk3.Validate.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      DownloadExportedAgreementsInCsvResponse,
      "DownloadExportedAgreementsInCsvResponse"
    );
  }
  /**
   * This API will initiate a worker to export list of users who has accepted a specific policy version into a CSV file.&lt;br&gt;To check the export state after initialize it, use `GET /admin/namespaces/{namespace}/agreements/policy-versions/users/export-csv/download` API.&lt;br/&gt;&lt;br/&gt;This Initiate API is &lt;b&gt;not allow&lt;/b&gt; multiple export worker running for the same namespace, it will return 409 http error if so.&lt;br/&gt;
   */
  createAgreementPolicyVersionUserExportCsvInitiate(queryParams) {
    const params = { ...queryParams };
    const url = "/agreement/admin/namespaces/{namespace}/agreements/policy-versions/users/export-csv/initiate".replace(
      "{namespace}",
      this.namespace
    );
    const resultPromise = this.axiosInstance.post(url, null, { params });
    return import_sdk3.Validate.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      InitiateExportAgreementsToCsvResponse,
      "InitiateExportAgreementsToCsvResponse"
    );
  }
};

// src/generated-admin/AgreementWithNamespaceAdminApi.ts
function AgreementWithNamespaceAdminApi(sdk, args) {
  const sdkAssembly = sdk.assembly();
  const namespace = args?.coreConfig?.namespace ?? sdkAssembly.coreConfig.namespace;
  const useSchemaValidation = args?.coreConfig?.useSchemaValidation ?? sdkAssembly.coreConfig.useSchemaValidation;
  let axiosInstance = sdkAssembly.axiosInstance;
  const requestConfigOverrides = args?.axiosConfig?.request;
  const baseURLOverride = args?.coreConfig?.baseURL;
  const interceptorsOverride = args?.axiosConfig?.interceptors ?? [];
  if (requestConfigOverrides || baseURLOverride || interceptorsOverride.length > 0) {
    const requestConfig = import_sdk4.ApiUtils.mergeAxiosConfigs(sdkAssembly.axiosInstance.defaults, {
      ...baseURLOverride ? { baseURL: baseURLOverride } : {},
      ...requestConfigOverrides
    });
    axiosInstance = import_sdk4.Network.create(requestConfig);
    for (const interceptor of interceptorsOverride) {
      if (interceptor.type === "request") {
        axiosInstance.interceptors.request.use(interceptor.onRequest, interceptor.onError);
      }
      if (interceptor.type === "response") {
        axiosInstance.interceptors.response.use(interceptor.onSuccess, interceptor.onError);
      }
    }
  }
  async function createAgreement(data) {
    const $ = new AgreementWithNamespaceAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.createAgreement(data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getAgreementsPolicyVersionsUsers(queryParams) {
    const $ = new AgreementWithNamespaceAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getAgreementsPolicyVersionsUsers(queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getAgreementPolicyUser_ByUserId(userId, queryParams) {
    const $ = new AgreementWithNamespaceAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getAgreementPolicyUser_ByUserId(userId, queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getAgreementsPolicyVersionsUsersExportCsvDownload(queryParams) {
    const $ = new AgreementWithNamespaceAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getAgreementsPolicyVersionsUsersExportCsvDownload(queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function createAgreementPolicyVersionUserExportCsvInitiate(queryParams) {
    const $ = new AgreementWithNamespaceAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.createAgreementPolicyVersionUserExportCsvInitiate(queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  return {
    /**
     * This API will return all accepted Legal Agreements for each user, including agreements of game users if publisher user has corresponding game account.
     */
    createAgreement,
    /**
     * This API will return all users who has accepted a specific policy version.
     */
    getAgreementsPolicyVersionsUsers,
    /**
     * This API will return all accepted Legal Agreements for specified user.
     */
    getAgreementPolicyUser_ByUserId,
    /**
     * This API will check the status of export process.&lt;br&gt;If the export process has been completed, the response body will include the download url.
     */
    getAgreementsPolicyVersionsUsersExportCsvDownload,
    /**
     * This API will initiate a worker to export list of users who has accepted a specific policy version into a CSV file.&lt;br&gt;To check the export state after initialize it, use `GET /admin/namespaces/{namespace}/agreements/policy-versions/users/export-csv/download` API.&lt;br/&gt;&lt;br/&gt;This Initiate API is &lt;b&gt;not allow&lt;/b&gt; multiple export worker running for the same namespace, it will return 409 http error if so.&lt;br/&gt;
     */
    createAgreementPolicyVersionUserExportCsvInitiate
  };
}

// src/generated-admin/AnonymizationAdminApi.ts
var import_sdk6 = require("@accelbyte/sdk");

// src/generated-admin/endpoints/AnonymizationAdmin$.ts
var import_sdk5 = require("@accelbyte/sdk");
var import_zod12 = require("zod");
var AnonymizationAdmin$ = class {
  // @ts-ignore
  // prettier-ignore
  constructor(axiosInstance, namespace, useSchemaValidation = true) {
    this.axiosInstance = axiosInstance;
    this.namespace = namespace;
    this.useSchemaValidation = useSchemaValidation;
  }
  /**
   * This API will anonymize agreement record for specified user.
   */
  deleteAnonymizationAgreement_ByUserId(userId) {
    const params = {};
    const url = "/agreement/admin/users/{userId}/anonymization/agreements".replace("{userId}", userId);
    const resultPromise = this.axiosInstance.delete(url, { params });
    return import_sdk5.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, import_zod12.z.unknown(), "z.unknown()");
  }
};

// src/generated-admin/AnonymizationAdminApi.ts
function AnonymizationAdminApi(sdk, args) {
  const sdkAssembly = sdk.assembly();
  const namespace = args?.coreConfig?.namespace ?? sdkAssembly.coreConfig.namespace;
  const useSchemaValidation = args?.coreConfig?.useSchemaValidation ?? sdkAssembly.coreConfig.useSchemaValidation;
  let axiosInstance = sdkAssembly.axiosInstance;
  const requestConfigOverrides = args?.axiosConfig?.request;
  const baseURLOverride = args?.coreConfig?.baseURL;
  const interceptorsOverride = args?.axiosConfig?.interceptors ?? [];
  if (requestConfigOverrides || baseURLOverride || interceptorsOverride.length > 0) {
    const requestConfig = import_sdk6.ApiUtils.mergeAxiosConfigs(sdkAssembly.axiosInstance.defaults, {
      ...baseURLOverride ? { baseURL: baseURLOverride } : {},
      ...requestConfigOverrides
    });
    axiosInstance = import_sdk6.Network.create(requestConfig);
    for (const interceptor of interceptorsOverride) {
      if (interceptor.type === "request") {
        axiosInstance.interceptors.request.use(interceptor.onRequest, interceptor.onError);
      }
      if (interceptor.type === "response") {
        axiosInstance.interceptors.response.use(interceptor.onSuccess, interceptor.onError);
      }
    }
  }
  async function deleteAnonymizationAgreement_ByUserId(userId) {
    const $ = new AnonymizationAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.deleteAnonymizationAgreement_ByUserId(userId);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  return {
    /**
     * This API will anonymize agreement record for specified user.
     */
    deleteAnonymizationAgreement_ByUserId
  };
}

// src/generated-admin/BaseLegalPoliciesAdminApi.ts
var import_sdk8 = require("@accelbyte/sdk");

// src/generated-admin/endpoints/BaseLegalPoliciesAdmin$.ts
var import_sdk7 = require("@accelbyte/sdk");

// src/generated-definitions/CreateBasePolicyResponse.ts
var import_zod13 = require("zod");
var CreateBasePolicyResponse = import_zod13.z.object({
  affectedClientIds: import_zod13.z.array(import_zod13.z.string()).nullish(),
  affectedCountries: import_zod13.z.array(import_zod13.z.string()).nullish(),
  createdAt: import_zod13.z.string().nullish(),
  description: import_zod13.z.string().nullish(),
  globalPolicyName: import_zod13.z.string().nullish(),
  id: import_zod13.z.string(),
  isHidden: import_zod13.z.boolean().nullish(),
  isHiddenPublic: import_zod13.z.boolean().nullish(),
  namespace: import_zod13.z.string().nullish(),
  policyId: import_zod13.z.string().nullish(),
  tags: import_zod13.z.array(import_zod13.z.string()).nullish(),
  typeId: import_zod13.z.string().nullish(),
  updatedAt: import_zod13.z.string().nullish()
});

// src/generated-definitions/RetrieveBasePolicyResponse.ts
var import_zod15 = require("zod");

// src/generated-definitions/PolicyObject.ts
var import_zod14 = require("zod");
var PolicyObject = import_zod14.z.object({
  countryCode: import_zod14.z.string(),
  countryGroupCode: import_zod14.z.string().nullish(),
  createdAt: import_zod14.z.string().nullish(),
  description: import_zod14.z.string().nullish(),
  id: import_zod14.z.string(),
  isDefaultOpted: import_zod14.z.boolean(),
  isDefaultSelection: import_zod14.z.boolean(),
  isMandatory: import_zod14.z.boolean(),
  policyName: import_zod14.z.string(),
  readableId: import_zod14.z.string().nullish(),
  shouldNotifyOnUpdate: import_zod14.z.boolean(),
  updatedAt: import_zod14.z.string().nullish()
});

// src/generated-definitions/RetrieveBasePolicyResponse.ts
var RetrieveBasePolicyResponse = import_zod15.z.object({
  affectedClientIds: import_zod15.z.array(import_zod15.z.string()).nullish(),
  basePolicyName: import_zod15.z.string(),
  createdAt: import_zod15.z.string().nullish(),
  description: import_zod15.z.string().nullish(),
  id: import_zod15.z.string(),
  isHidden: import_zod15.z.boolean().nullish(),
  isHiddenPublic: import_zod15.z.boolean().nullish(),
  namespace: import_zod15.z.string(),
  policies: import_zod15.z.array(PolicyObject).nullish(),
  policyTypeId: import_zod15.z.string().nullish(),
  policyTypeName: import_zod15.z.string().nullish(),
  tags: import_zod15.z.array(import_zod15.z.string()).nullish(),
  updatedAt: import_zod15.z.string().nullish()
});

// src/generated-definitions/RetrieveBasePolicyResponseArray.ts
var import_zod16 = require("zod");
var RetrieveBasePolicyResponseArray = import_zod16.z.array(RetrieveBasePolicyResponse);

// src/generated-definitions/RetrievePolicyResponse.ts
var import_zod18 = require("zod");

// src/generated-definitions/PolicyVersionObject.ts
var import_zod17 = require("zod");
var PolicyVersionObject = import_zod17.z.object({
  createdAt: import_zod17.z.string().nullish(),
  description: import_zod17.z.string().nullish(),
  displayVersion: import_zod17.z.string(),
  id: import_zod17.z.string(),
  isCommitted: import_zod17.z.boolean(),
  isInEffect: import_zod17.z.boolean(),
  publishedDate: import_zod17.z.string().nullish(),
  status: import_zod17.z.string().nullish(),
  updatedAt: import_zod17.z.string().nullish()
});

// src/generated-definitions/RetrievePolicyResponse.ts
var RetrievePolicyResponse = import_zod18.z.object({
  countryCode: import_zod18.z.string(),
  countryGroupCode: import_zod18.z.string().nullish(),
  createdAt: import_zod18.z.string().nullish(),
  description: import_zod18.z.string().nullish(),
  id: import_zod18.z.string(),
  isDefaultOpted: import_zod18.z.boolean(),
  isDefaultSelection: import_zod18.z.boolean(),
  isMandatory: import_zod18.z.boolean(),
  policyName: import_zod18.z.string(),
  policyVersions: import_zod18.z.array(PolicyVersionObject).nullish(),
  readableId: import_zod18.z.string().nullish(),
  shouldNotifyOnUpdate: import_zod18.z.boolean(),
  updatedAt: import_zod18.z.string().nullish()
});

// src/generated-definitions/RetrievePolicyTypeResponseArray.ts
var import_zod20 = require("zod");

// src/generated-definitions/RetrievePolicyTypeResponse.ts
var import_zod19 = require("zod");
var RetrievePolicyTypeResponse = import_zod19.z.object({
  createdAt: import_zod19.z.string().nullish(),
  description: import_zod19.z.string().nullish(),
  id: import_zod19.z.string(),
  isNeedDocument: import_zod19.z.boolean(),
  policyTypeName: import_zod19.z.string(),
  updatedAt: import_zod19.z.string().nullish()
});

// src/generated-definitions/RetrievePolicyTypeResponseArray.ts
var RetrievePolicyTypeResponseArray = import_zod20.z.array(RetrievePolicyTypeResponse);

// src/generated-definitions/UpdateBasePolicyResponse.ts
var import_zod21 = require("zod");
var UpdateBasePolicyResponse = import_zod21.z.object({
  affectedClientIds: import_zod21.z.array(import_zod21.z.string()).nullish(),
  affectedCountries: import_zod21.z.array(import_zod21.z.string()).nullish(),
  createdAt: import_zod21.z.string().nullish(),
  description: import_zod21.z.string().nullish(),
  globalPolicyName: import_zod21.z.string().nullish(),
  id: import_zod21.z.string(),
  isHidden: import_zod21.z.boolean().nullish(),
  isHiddenPublic: import_zod21.z.boolean().nullish(),
  namespace: import_zod21.z.string().nullish(),
  policyId: import_zod21.z.string().nullish(),
  tags: import_zod21.z.array(import_zod21.z.string()).nullish(),
  typeId: import_zod21.z.string().nullish(),
  updatedAt: import_zod21.z.string().nullish()
});

// src/generated-admin/endpoints/BaseLegalPoliciesAdmin$.ts
var BaseLegalPoliciesAdmin$ = class {
  // @ts-ignore
  // prettier-ignore
  constructor(axiosInstance, namespace, useSchemaValidation = true) {
    this.axiosInstance = axiosInstance;
    this.namespace = namespace;
    this.useSchemaValidation = useSchemaValidation;
  }
  /**
   * Retrieve all supported policy types.
   */
  getPolicyTypes(queryParams) {
    const params = { ...queryParams };
    const url = "/agreement/admin/policy-types";
    const resultPromise = this.axiosInstance.get(url, { params });
    return import_sdk7.Validate.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      RetrievePolicyTypeResponseArray,
      "RetrievePolicyTypeResponseArray"
    );
  }
  /**
   * Retrieve all base policies.
   */
  getBasePolicies(queryParams) {
    const params = { ...queryParams };
    const url = "/agreement/admin/base-policies";
    const resultPromise = this.axiosInstance.get(url, { params });
    return import_sdk7.Validate.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      RetrieveBasePolicyResponseArray,
      "RetrieveBasePolicyResponseArray"
    );
  }
  /**
   * Create a legal policy.
   */
  createBasePolicy(data) {
    const params = {};
    const url = "/agreement/admin/base-policies";
    const resultPromise = this.axiosInstance.post(url, data, { params });
    return import_sdk7.Validate.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      CreateBasePolicyResponse,
      "CreateBasePolicyResponse"
    );
  }
  /**
   * Retrieve a base policy.
   */
  getBasePolicy_ByBasePolicyId(basePolicyId) {
    const params = {};
    const url = "/agreement/admin/base-policies/{basePolicyId}".replace("{basePolicyId}", basePolicyId);
    const resultPromise = this.axiosInstance.get(url, { params });
    return import_sdk7.Validate.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      RetrieveBasePolicyResponse,
      "RetrieveBasePolicyResponse"
    );
  }
  /**
   * Update an existing base policy.
   */
  patchBasePolicy_ByBasePolicyId(basePolicyId, data) {
    const params = {};
    const url = "/agreement/admin/base-policies/{basePolicyId}".replace("{basePolicyId}", basePolicyId);
    const resultPromise = this.axiosInstance.patch(url, data, { params });
    return import_sdk7.Validate.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      UpdateBasePolicyResponse,
      "UpdateBasePolicyResponse"
    );
  }
  /**
   * Retrieve a Base Legal Policy based on a Particular Country.
   */
  getCountry_ByBasePolicyId_ByCountryCode(basePolicyId, countryCode) {
    const params = {};
    const url = "/agreement/admin/base-policies/{basePolicyId}/countries/{countryCode}".replace("{basePolicyId}", basePolicyId).replace("{countryCode}", countryCode);
    const resultPromise = this.axiosInstance.get(url, { params });
    return import_sdk7.Validate.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      RetrievePolicyResponse,
      "RetrievePolicyResponse"
    );
  }
};

// src/generated-admin/BaseLegalPoliciesAdminApi.ts
function BaseLegalPoliciesAdminApi(sdk, args) {
  const sdkAssembly = sdk.assembly();
  const namespace = args?.coreConfig?.namespace ?? sdkAssembly.coreConfig.namespace;
  const useSchemaValidation = args?.coreConfig?.useSchemaValidation ?? sdkAssembly.coreConfig.useSchemaValidation;
  let axiosInstance = sdkAssembly.axiosInstance;
  const requestConfigOverrides = args?.axiosConfig?.request;
  const baseURLOverride = args?.coreConfig?.baseURL;
  const interceptorsOverride = args?.axiosConfig?.interceptors ?? [];
  if (requestConfigOverrides || baseURLOverride || interceptorsOverride.length > 0) {
    const requestConfig = import_sdk8.ApiUtils.mergeAxiosConfigs(sdkAssembly.axiosInstance.defaults, {
      ...baseURLOverride ? { baseURL: baseURLOverride } : {},
      ...requestConfigOverrides
    });
    axiosInstance = import_sdk8.Network.create(requestConfig);
    for (const interceptor of interceptorsOverride) {
      if (interceptor.type === "request") {
        axiosInstance.interceptors.request.use(interceptor.onRequest, interceptor.onError);
      }
      if (interceptor.type === "response") {
        axiosInstance.interceptors.response.use(interceptor.onSuccess, interceptor.onError);
      }
    }
  }
  async function getPolicyTypes(queryParams) {
    const $ = new BaseLegalPoliciesAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getPolicyTypes(queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getBasePolicies(queryParams) {
    const $ = new BaseLegalPoliciesAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getBasePolicies(queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function createBasePolicy(data) {
    const $ = new BaseLegalPoliciesAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.createBasePolicy(data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getBasePolicy_ByBasePolicyId(basePolicyId) {
    const $ = new BaseLegalPoliciesAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getBasePolicy_ByBasePolicyId(basePolicyId);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function patchBasePolicy_ByBasePolicyId(basePolicyId, data) {
    const $ = new BaseLegalPoliciesAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.patchBasePolicy_ByBasePolicyId(basePolicyId, data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getCountry_ByBasePolicyId_ByCountryCode(basePolicyId, countryCode) {
    const $ = new BaseLegalPoliciesAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getCountry_ByBasePolicyId_ByCountryCode(basePolicyId, countryCode);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  return {
    /**
     * Retrieve all supported policy types.
     */
    getPolicyTypes,
    /**
     * Retrieve all base policies.
     */
    getBasePolicies,
    /**
     * Create a legal policy.
     */
    createBasePolicy,
    /**
     * Retrieve a base policy.
     */
    getBasePolicy_ByBasePolicyId,
    /**
     * Update an existing base policy.
     */
    patchBasePolicy_ByBasePolicyId,
    /**
     * Retrieve a Base Legal Policy based on a Particular Country.
     */
    getCountry_ByBasePolicyId_ByCountryCode
  };
}

// src/generated-admin/BaseLegalPoliciesWithNamespaceAdminApi.ts
var import_sdk10 = require("@accelbyte/sdk");

// src/generated-admin/endpoints/BaseLegalPoliciesWithNamespaceAdmin$.ts
var import_sdk9 = require("@accelbyte/sdk");
var BaseLegalPoliciesWithNamespaceAdmin$ = class {
  // @ts-ignore
  // prettier-ignore
  constructor(axiosInstance, namespace, useSchemaValidation = true) {
    this.axiosInstance = axiosInstance;
    this.namespace = namespace;
    this.useSchemaValidation = useSchemaValidation;
  }
  /**
   * Retrieve all supported policy types.
   */
  getPolicyTypes(queryParams) {
    const params = { ...queryParams };
    const url = "/agreement/admin/namespaces/{namespace}/policy-types".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.get(url, { params });
    return import_sdk9.Validate.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      RetrievePolicyTypeResponseArray,
      "RetrievePolicyTypeResponseArray"
    );
  }
  /**
   * Retrieve all base policies in the namespace.
   */
  getBasePolicies(queryParams) {
    const params = { ...queryParams };
    const url = "/agreement/admin/namespaces/{namespace}/base-policies".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.get(url, { params });
    return import_sdk9.Validate.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      RetrieveBasePolicyResponseArray,
      "RetrieveBasePolicyResponseArray"
    );
  }
  /**
   * Create a legal policy.
   */
  createBasePolicy(data) {
    const params = {};
    const url = "/agreement/admin/namespaces/{namespace}/base-policies".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.post(url, data, { params });
    return import_sdk9.Validate.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      CreateBasePolicyResponse,
      "CreateBasePolicyResponse"
    );
  }
  /**
   * Retrieve a base policy.
   */
  getBasePolicy_ByBasePolicyId(basePolicyId) {
    const params = {};
    const url = "/agreement/admin/namespaces/{namespace}/base-policies/{basePolicyId}".replace("{namespace}", this.namespace).replace("{basePolicyId}", basePolicyId);
    const resultPromise = this.axiosInstance.get(url, { params });
    return import_sdk9.Validate.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      RetrieveBasePolicyResponse,
      "RetrieveBasePolicyResponse"
    );
  }
  /**
   * Update an existing base policy.
   */
  patchBasePolicy_ByBasePolicyId(basePolicyId, data) {
    const params = {};
    const url = "/agreement/admin/namespaces/{namespace}/base-policies/{basePolicyId}".replace("{namespace}", this.namespace).replace("{basePolicyId}", basePolicyId);
    const resultPromise = this.axiosInstance.patch(url, data, { params });
    return import_sdk9.Validate.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      UpdateBasePolicyResponse,
      "UpdateBasePolicyResponse"
    );
  }
  /**
   * Retrieve a Base Legal Policy based on a Particular Country.
   */
  getCountry_ByBasePolicyId_ByCountryCode(basePolicyId, countryCode) {
    const params = {};
    const url = "/agreement/admin/namespaces/{namespace}/base-policies/{basePolicyId}/countries/{countryCode}".replace("{namespace}", this.namespace).replace("{basePolicyId}", basePolicyId).replace("{countryCode}", countryCode);
    const resultPromise = this.axiosInstance.get(url, { params });
    return import_sdk9.Validate.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      RetrievePolicyResponse,
      "RetrievePolicyResponse"
    );
  }
};

// src/generated-admin/BaseLegalPoliciesWithNamespaceAdminApi.ts
function BaseLegalPoliciesWithNamespaceAdminApi(sdk, args) {
  const sdkAssembly = sdk.assembly();
  const namespace = args?.coreConfig?.namespace ?? sdkAssembly.coreConfig.namespace;
  const useSchemaValidation = args?.coreConfig?.useSchemaValidation ?? sdkAssembly.coreConfig.useSchemaValidation;
  let axiosInstance = sdkAssembly.axiosInstance;
  const requestConfigOverrides = args?.axiosConfig?.request;
  const baseURLOverride = args?.coreConfig?.baseURL;
  const interceptorsOverride = args?.axiosConfig?.interceptors ?? [];
  if (requestConfigOverrides || baseURLOverride || interceptorsOverride.length > 0) {
    const requestConfig = import_sdk10.ApiUtils.mergeAxiosConfigs(sdkAssembly.axiosInstance.defaults, {
      ...baseURLOverride ? { baseURL: baseURLOverride } : {},
      ...requestConfigOverrides
    });
    axiosInstance = import_sdk10.Network.create(requestConfig);
    for (const interceptor of interceptorsOverride) {
      if (interceptor.type === "request") {
        axiosInstance.interceptors.request.use(interceptor.onRequest, interceptor.onError);
      }
      if (interceptor.type === "response") {
        axiosInstance.interceptors.response.use(interceptor.onSuccess, interceptor.onError);
      }
    }
  }
  async function getPolicyTypes(queryParams) {
    const $ = new BaseLegalPoliciesWithNamespaceAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getPolicyTypes(queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getBasePolicies(queryParams) {
    const $ = new BaseLegalPoliciesWithNamespaceAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getBasePolicies(queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function createBasePolicy(data) {
    const $ = new BaseLegalPoliciesWithNamespaceAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.createBasePolicy(data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getBasePolicy_ByBasePolicyId(basePolicyId) {
    const $ = new BaseLegalPoliciesWithNamespaceAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getBasePolicy_ByBasePolicyId(basePolicyId);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function patchBasePolicy_ByBasePolicyId(basePolicyId, data) {
    const $ = new BaseLegalPoliciesWithNamespaceAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.patchBasePolicy_ByBasePolicyId(basePolicyId, data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getCountry_ByBasePolicyId_ByCountryCode(basePolicyId, countryCode) {
    const $ = new BaseLegalPoliciesWithNamespaceAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getCountry_ByBasePolicyId_ByCountryCode(basePolicyId, countryCode);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  return {
    /**
     * Retrieve all supported policy types.
     */
    getPolicyTypes,
    /**
     * Retrieve all base policies in the namespace.
     */
    getBasePolicies,
    /**
     * Create a legal policy.
     */
    createBasePolicy,
    /**
     * Retrieve a base policy.
     */
    getBasePolicy_ByBasePolicyId,
    /**
     * Update an existing base policy.
     */
    patchBasePolicy_ByBasePolicyId,
    /**
     * Retrieve a Base Legal Policy based on a Particular Country.
     */
    getCountry_ByBasePolicyId_ByCountryCode
  };
}

// src/generated-admin/endpoints/LocalizedPolicyVersionsAdmin$.ts
var import_sdk11 = require("@accelbyte/sdk");
var import_zod27 = require("zod");

// src/generated-definitions/CreateLocalizedPolicyVersionResponse.ts
var import_zod22 = require("zod");
var CreateLocalizedPolicyVersionResponse = import_zod22.z.object({
  createdAt: import_zod22.z.string().nullish(),
  description: import_zod22.z.string().nullish(),
  id: import_zod22.z.string(),
  localeCode: import_zod22.z.string().nullish(),
  updatedAt: import_zod22.z.string().nullish()
});

// src/generated-definitions/RetrieveLocalizedPolicyVersionResponse.ts
var import_zod23 = require("zod");
var RetrieveLocalizedPolicyVersionResponse = import_zod23.z.object({
  attachmentChecksum: import_zod23.z.string().nullish(),
  attachmentLocation: import_zod23.z.string().nullish(),
  attachmentVersionIdentifier: import_zod23.z.string().nullish(),
  baseUrls: import_zod23.z.array(import_zod23.z.string()).nullish(),
  contentType: import_zod23.z.string().nullish(),
  createdAt: import_zod23.z.string().nullish(),
  description: import_zod23.z.string().nullish(),
  id: import_zod23.z.string(),
  localeCode: import_zod23.z.string(),
  policy: PolicyObject.nullish(),
  policyVersion: PolicyVersionObject,
  updatedAt: import_zod23.z.string().nullish()
});

// src/generated-definitions/RetrieveLocalizedPolicyVersionResponseArray.ts
var import_zod24 = require("zod");
var RetrieveLocalizedPolicyVersionResponseArray = import_zod24.z.array(RetrieveLocalizedPolicyVersionResponse);

// src/generated-definitions/UpdateLocalizedPolicyVersionResponse.ts
var import_zod25 = require("zod");
var UpdateLocalizedPolicyVersionResponse = import_zod25.z.object({
  attachmentChecksum: import_zod25.z.string().nullish(),
  attachmentLocation: import_zod25.z.string().nullish(),
  attachmentVersionIdentifier: import_zod25.z.string().nullish(),
  contentType: import_zod25.z.string().nullish(),
  createdAt: import_zod25.z.string().nullish(),
  description: import_zod25.z.string().nullish(),
  id: import_zod25.z.string(),
  localeCode: import_zod25.z.string().nullish(),
  updatedAt: import_zod25.z.string().nullish()
});

// src/generated-definitions/UploadLocalizedPolicyVersionAttachmentResponse.ts
var import_zod26 = require("zod");
var UploadLocalizedPolicyVersionAttachmentResponse = import_zod26.z.object({
  attachmentChecksum: import_zod26.z.string().nullish(),
  attachmentLocation: import_zod26.z.string().nullish(),
  attachmentUploadUrl: import_zod26.z.string().nullish()
});

// src/generated-admin/endpoints/LocalizedPolicyVersionsAdmin$.ts
var LocalizedPolicyVersionsAdmin$ = class {
  // @ts-ignore
  // prettier-ignore
  constructor(axiosInstance, namespace, useSchemaValidation = true) {
    this.axiosInstance = axiosInstance;
    this.namespace = namespace;
    this.useSchemaValidation = useSchemaValidation;
  }
  /**
   * Retrieve a version of a particular country-specific policy.
   */
  getLocalizedPolicyVersion_ByLocalizedPolicyVersionId(localizedPolicyVersionId) {
    const params = {};
    const url = "/agreement/admin/localized-policy-versions/{localizedPolicyVersionId}".replace(
      "{localizedPolicyVersionId}",
      localizedPolicyVersionId
    );
    const resultPromise = this.axiosInstance.get(url, { params });
    return import_sdk11.Validate.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      RetrieveLocalizedPolicyVersionResponse,
      "RetrieveLocalizedPolicyVersionResponse"
    );
  }
  /**
   * Update a version of a particular country-specific policy.
   */
  updateLocalizedPolicyVersion_ByLocalizedPolicyVersionId(localizedPolicyVersionId, data) {
    const params = {};
    const url = "/agreement/admin/localized-policy-versions/{localizedPolicyVersionId}".replace(
      "{localizedPolicyVersionId}",
      localizedPolicyVersionId
    );
    const resultPromise = this.axiosInstance.put(url, data, { params });
    return import_sdk11.Validate.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      UpdateLocalizedPolicyVersionResponse,
      "UpdateLocalizedPolicyVersionResponse"
    );
  }
  /**
   * Retrieve versions of a particular country-specific policy.
   */
  getLocalizedPolicyVersionVersion_ByPolicyVersionId(policyVersionId) {
    const params = {};
    const url = "/agreement/admin/localized-policy-versions/versions/{policyVersionId}".replace("{policyVersionId}", policyVersionId);
    const resultPromise = this.axiosInstance.get(url, { params });
    return import_sdk11.Validate.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      RetrieveLocalizedPolicyVersionResponseArray,
      "RetrieveLocalizedPolicyVersionResponseArray"
    );
  }
  /**
   * Create a version of a particular country-specific policy.
   */
  createLocalizedPolicyVersionVersion_ByPolicyVersionId(policyVersionId, data) {
    const params = {};
    const url = "/agreement/admin/localized-policy-versions/versions/{policyVersionId}".replace("{policyVersionId}", policyVersionId);
    const resultPromise = this.axiosInstance.post(url, data, { params });
    return import_sdk11.Validate.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      CreateLocalizedPolicyVersionResponse,
      "CreateLocalizedPolicyVersionResponse"
    );
  }
  /**
   * Update a localized version policy to be the default.
   */
  patchDefault_ByLocalizedPolicyVersionId(localizedPolicyVersionId) {
    const params = {};
    const url = "/agreement/admin/localized-policy-versions/{localizedPolicyVersionId}/default".replace(
      "{localizedPolicyVersionId}",
      localizedPolicyVersionId
    );
    const resultPromise = this.axiosInstance.patch(url, null, { params });
    return import_sdk11.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, import_zod27.z.unknown(), "z.unknown()");
  }
  /**
   * Request presigned URL for upload attachment for a particular localized version of base policy.
   */
  createAttachment_ByLocalizedPolicyVersionId(localizedPolicyVersionId, data) {
    const params = {};
    const url = "/agreement/admin/localized-policy-versions/{localizedPolicyVersionId}/attachments".replace(
      "{localizedPolicyVersionId}",
      localizedPolicyVersionId
    );
    const resultPromise = this.axiosInstance.post(url, data, { params });
    return import_sdk11.Validate.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      UploadLocalizedPolicyVersionAttachmentResponse,
      "UploadLocalizedPolicyVersionAttachmentResponse"
    );
  }
};

// src/generated-admin/endpoints/LocalizedPolicyVersionsWithNamespaceAdmin$.ts
var import_sdk12 = require("@accelbyte/sdk");
var import_zod28 = require("zod");
var LocalizedPolicyVersionsWithNamespaceAdmin$ = class {
  // @ts-ignore
  // prettier-ignore
  constructor(axiosInstance, namespace, useSchemaValidation = true) {
    this.axiosInstance = axiosInstance;
    this.namespace = namespace;
    this.useSchemaValidation = useSchemaValidation;
  }
  /**
   * Retrieve a version of a particular country-specific policy.
   */
  getLocalizedPolicyVersion_ByLocalizedPolicyVersionId(localizedPolicyVersionId) {
    const params = {};
    const url = "/agreement/admin/namespaces/{namespace}/localized-policy-versions/{localizedPolicyVersionId}".replace("{namespace}", this.namespace).replace("{localizedPolicyVersionId}", localizedPolicyVersionId);
    const resultPromise = this.axiosInstance.get(url, { params });
    return import_sdk12.Validate.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      RetrieveLocalizedPolicyVersionResponse,
      "RetrieveLocalizedPolicyVersionResponse"
    );
  }
  /**
   * Update a version of a particular country-specific policy.
   */
  updateLocalizedPolicyVersion_ByLocalizedPolicyVersionId(localizedPolicyVersionId, data) {
    const params = {};
    const url = "/agreement/admin/namespaces/{namespace}/localized-policy-versions/{localizedPolicyVersionId}".replace("{namespace}", this.namespace).replace("{localizedPolicyVersionId}", localizedPolicyVersionId);
    const resultPromise = this.axiosInstance.put(url, data, { params });
    return import_sdk12.Validate.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      UpdateLocalizedPolicyVersionResponse,
      "UpdateLocalizedPolicyVersionResponse"
    );
  }
  /**
   * Retrieve versions of a particular country-specific policy.
   */
  getLocalizedPolicyVersionVersion_ByPolicyVersionId(policyVersionId) {
    const params = {};
    const url = "/agreement/admin/namespaces/{namespace}/localized-policy-versions/versions/{policyVersionId}".replace("{namespace}", this.namespace).replace("{policyVersionId}", policyVersionId);
    const resultPromise = this.axiosInstance.get(url, { params });
    return import_sdk12.Validate.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      RetrieveLocalizedPolicyVersionResponseArray,
      "RetrieveLocalizedPolicyVersionResponseArray"
    );
  }
  /**
   * Create a version of a particular country-specific policy.
   */
  createLocalizedPolicyVersionVersion_ByPolicyVersionId(policyVersionId, data) {
    const params = {};
    const url = "/agreement/admin/namespaces/{namespace}/localized-policy-versions/versions/{policyVersionId}".replace("{namespace}", this.namespace).replace("{policyVersionId}", policyVersionId);
    const resultPromise = this.axiosInstance.post(url, data, { params });
    return import_sdk12.Validate.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      CreateLocalizedPolicyVersionResponse,
      "CreateLocalizedPolicyVersionResponse"
    );
  }
  /**
   * Update a localized version policy to be the default.
   */
  patchDefault_ByLocalizedPolicyVersionId(localizedPolicyVersionId) {
    const params = {};
    const url = "/agreement/admin/namespaces/{namespace}/localized-policy-versions/{localizedPolicyVersionId}/default".replace("{namespace}", this.namespace).replace("{localizedPolicyVersionId}", localizedPolicyVersionId);
    const resultPromise = this.axiosInstance.patch(url, null, { params });
    return import_sdk12.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, import_zod28.z.unknown(), "z.unknown()");
  }
  /**
   * Request presigned URL for upload attachment for a particular localized version of base policy.
   */
  createAttachment_ByLocalizedPolicyVersionId(localizedPolicyVersionId, data) {
    const params = {};
    const url = "/agreement/admin/namespaces/{namespace}/localized-policy-versions/{localizedPolicyVersionId}/attachments".replace("{namespace}", this.namespace).replace("{localizedPolicyVersionId}", localizedPolicyVersionId);
    const resultPromise = this.axiosInstance.post(url, data, { params });
    return import_sdk12.Validate.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      UploadLocalizedPolicyVersionAttachmentResponse,
      "UploadLocalizedPolicyVersionAttachmentResponse"
    );
  }
};

// src/generated-admin/endpoints/PoliciesAdmin$.ts
var import_sdk13 = require("@accelbyte/sdk");
var import_zod30 = require("zod");

// src/generated-definitions/RetrievePolicyResponseArray.ts
var import_zod29 = require("zod");
var RetrievePolicyResponseArray = import_zod29.z.array(RetrievePolicyResponse);

// src/generated-admin/endpoints/PoliciesAdmin$.ts
var PoliciesAdmin$ = class {
  // @ts-ignore
  // prettier-ignore
  constructor(axiosInstance, namespace, useSchemaValidation = true) {
    this.axiosInstance = axiosInstance;
    this.namespace = namespace;
    this.useSchemaValidation = useSchemaValidation;
  }
  /**
   * Update country-specific policy.
   */
  patchPolicy_ByPolicyId(policyId, data) {
    const params = {};
    const url = "/agreement/admin/policies/{policyId}".replace("{policyId}", policyId);
    const resultPromise = this.axiosInstance.patch(url, data, { params });
    return import_sdk13.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, import_zod30.z.unknown(), "z.unknown()");
  }
  /**
   * Update a policy to be the default.
   */
  patchDefault_ByPolicyId(policyId) {
    const params = {};
    const url = "/agreement/admin/policies/{policyId}/default".replace("{policyId}", policyId);
    const resultPromise = this.axiosInstance.patch(url, null, { params });
    return import_sdk13.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, import_zod30.z.unknown(), "z.unknown()");
  }
  /**
   * Retrieve all active policies based on a country.
   */
  getPolicyCountry_ByCountryCode(countryCode) {
    const params = {};
    const url = "/agreement/admin/policies/countries/{countryCode}".replace("{countryCode}", countryCode);
    const resultPromise = this.axiosInstance.get(url, { params });
    return import_sdk13.Validate.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      RetrievePolicyResponseArray,
      "RetrievePolicyResponseArray"
    );
  }
};

// src/generated-admin/endpoints/PoliciesWithNamespaceAdmin$.ts
var import_sdk14 = require("@accelbyte/sdk");
var import_zod31 = require("zod");
var PoliciesWithNamespaceAdmin$ = class {
  // @ts-ignore
  // prettier-ignore
  constructor(axiosInstance, namespace, useSchemaValidation = true) {
    this.axiosInstance = axiosInstance;
    this.namespace = namespace;
    this.useSchemaValidation = useSchemaValidation;
  }
  /**
   * Update country-specific policy.
   */
  patchPolicy_ByPolicyId(policyId, data) {
    const params = {};
    const url = "/agreement/admin/namespaces/{namespace}/policies/{policyId}".replace("{namespace}", this.namespace).replace("{policyId}", policyId);
    const resultPromise = this.axiosInstance.patch(url, data, { params });
    return import_sdk14.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, import_zod31.z.unknown(), "z.unknown()");
  }
  /**
   * Update a policy to be the default.
   */
  patchDefault_ByPolicyId(policyId) {
    const params = {};
    const url = "/agreement/admin/namespaces/{namespace}/policies/{policyId}/default".replace("{namespace}", this.namespace).replace("{policyId}", policyId);
    const resultPromise = this.axiosInstance.patch(url, null, { params });
    return import_sdk14.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, import_zod31.z.unknown(), "z.unknown()");
  }
};

// src/generated-admin/endpoints/PolicyVersionsAdmin$.ts
var import_sdk15 = require("@accelbyte/sdk");
var import_zod36 = require("zod");

// src/generated-definitions/CreatePolicyVersionResponse.ts
var import_zod32 = require("zod");
var CreatePolicyVersionResponse = import_zod32.z.object({
  basePolicyId: import_zod32.z.string().nullish(),
  createdAt: import_zod32.z.string().nullish(),
  description: import_zod32.z.string().nullish(),
  displayVersion: import_zod32.z.string().nullish(),
  id: import_zod32.z.string(),
  isCommitted: import_zod32.z.boolean().nullish(),
  updatedAt: import_zod32.z.string().nullish()
});

// src/generated-definitions/RetrievePolicyVersionResponseArray.ts
var import_zod34 = require("zod");

// src/generated-definitions/RetrievePolicyVersionResponse.ts
var import_zod33 = require("zod");
var RetrievePolicyVersionResponse = import_zod33.z.object({
  basePolicyId: import_zod33.z.string().nullish(),
  createdAt: import_zod33.z.string().nullish(),
  description: import_zod33.z.string().nullish(),
  displayVersion: import_zod33.z.string(),
  id: import_zod33.z.string(),
  isCommitted: import_zod33.z.boolean(),
  isInEffect: import_zod33.z.boolean(),
  localizedPolicyVersions: import_zod33.z.array(LocalizedPolicyVersionObject).nullish(),
  policyId: import_zod33.z.string().nullish(),
  publishedDate: import_zod33.z.string().nullish(),
  status: import_zod33.z.string().nullish(),
  updatedAt: import_zod33.z.string().nullish()
});

// src/generated-definitions/RetrievePolicyVersionResponseArray.ts
var RetrievePolicyVersionResponseArray = import_zod34.z.array(RetrievePolicyVersionResponse);

// src/generated-definitions/UpdatePolicyVersionResponse.ts
var import_zod35 = require("zod");
var UpdatePolicyVersionResponse = import_zod35.z.object({
  basePolicyId: import_zod35.z.string().nullish(),
  createdAt: import_zod35.z.string().nullish(),
  description: import_zod35.z.string().nullish(),
  displayVersion: import_zod35.z.string().nullish(),
  id: import_zod35.z.string(),
  isCommitted: import_zod35.z.boolean().nullish(),
  publishedDate: import_zod35.z.string().nullish(),
  status: import_zod35.z.string().nullish(),
  updatedAt: import_zod35.z.string().nullish()
});

// src/generated-admin/endpoints/PolicyVersionsAdmin$.ts
var PolicyVersionsAdmin$ = class {
  // @ts-ignore
  // prettier-ignore
  constructor(axiosInstance, namespace, useSchemaValidation = true) {
    this.axiosInstance = axiosInstance;
    this.namespace = namespace;
    this.useSchemaValidation = useSchemaValidation;
  }
  /**
   * Retrieve a version of a particular country specific policy. If version is not provided, the Legal Service will assume caller requesting all versions from country-specific policy.
   */
  getVersions_ByPolicyId(policyId, queryParams) {
    const params = { ...queryParams };
    const url = "/agreement/admin/policies/{policyId}/versions".replace("{policyId}", policyId);
    const resultPromise = this.axiosInstance.get(url, { params });
    return import_sdk15.Validate.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      RetrievePolicyVersionResponseArray,
      "RetrievePolicyVersionResponseArray"
    );
  }
  /**
   * Create a version of a particular country-specific policy.
   */
  createVersion_ByPolicyId(policyId, data) {
    const params = {};
    const url = "/agreement/admin/policies/{policyId}/versions".replace("{policyId}", policyId);
    const resultPromise = this.axiosInstance.post(url, data, { params });
    return import_sdk15.Validate.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      CreatePolicyVersionResponse,
      "CreatePolicyVersionResponse"
    );
  }
  /**
   * Update a particular policy version.
   */
  patchPolicyVersion_ByPolicyVersionId(policyVersionId, data) {
    const params = {};
    const url = "/agreement/admin/policies/versions/{policyVersionId}".replace("{policyVersionId}", policyVersionId);
    const resultPromise = this.axiosInstance.patch(url, data, { params });
    return import_sdk15.Validate.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      UpdatePolicyVersionResponse,
      "UpdatePolicyVersionResponse"
    );
  }
  /**
   * Manually publish a version of a particular country-specific policy.
   */
  patchLatestPolicy_ByPolicyVersionId(policyVersionId, queryParams) {
    const params = { shouldNotify: true, ...queryParams };
    const url = "/agreement/admin/policies/versions/{policyVersionId}/latest".replace("{policyVersionId}", policyVersionId);
    const resultPromise = this.axiosInstance.patch(url, null, { params });
    return import_sdk15.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, import_zod36.z.unknown(), "z.unknown()");
  }
};

// src/generated-admin/endpoints/PolicyVersionsWithNamespaceAdmin$.ts
var import_sdk16 = require("@accelbyte/sdk");
var import_zod37 = require("zod");
var PolicyVersionsWithNamespaceAdmin$ = class {
  // @ts-ignore
  // prettier-ignore
  constructor(axiosInstance, namespace, useSchemaValidation = true) {
    this.axiosInstance = axiosInstance;
    this.namespace = namespace;
    this.useSchemaValidation = useSchemaValidation;
  }
  /**
   * Retrieve a version of a particular country specific policy. If version is not provided, the Legal Service will assume caller requesting all versions from country-specific policy.
   */
  getVersions_ByPolicyId(policyId, queryParams) {
    const params = { ...queryParams };
    const url = "/agreement/admin/namespaces/{namespace}/policies/{policyId}/versions".replace("{namespace}", this.namespace).replace("{policyId}", policyId);
    const resultPromise = this.axiosInstance.get(url, { params });
    return import_sdk16.Validate.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      RetrievePolicyVersionResponseArray,
      "RetrievePolicyVersionResponseArray"
    );
  }
  /**
   * Create a version of a particular country-specific policy.
   */
  createVersion_ByPolicyId(policyId, data) {
    const params = {};
    const url = "/agreement/admin/namespaces/{namespace}/policies/{policyId}/versions".replace("{namespace}", this.namespace).replace("{policyId}", policyId);
    const resultPromise = this.axiosInstance.post(url, data, { params });
    return import_sdk16.Validate.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      CreatePolicyVersionResponse,
      "CreatePolicyVersionResponse"
    );
  }
  /**
   * Update a particular policy version.
   */
  patchPolicyVersion_ByPolicyVersionId(policyVersionId, data) {
    const params = {};
    const url = "/agreement/admin/namespaces/{namespace}/policies/versions/{policyVersionId}".replace("{namespace}", this.namespace).replace("{policyVersionId}", policyVersionId);
    const resultPromise = this.axiosInstance.patch(url, data, { params });
    return import_sdk16.Validate.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      UpdatePolicyVersionResponse,
      "UpdatePolicyVersionResponse"
    );
  }
  /**
   * Manually publish a version of a particular country-specific policy.
   */
  patchLatestPolicy_ByPolicyVersionId(policyVersionId, queryParams) {
    const params = { shouldNotify: true, ...queryParams };
    const url = "/agreement/admin/namespaces/{namespace}/policies/versions/{policyVersionId}/latest".replace("{namespace}", this.namespace).replace("{policyVersionId}", policyVersionId);
    const resultPromise = this.axiosInstance.patch(url, null, { params });
    return import_sdk16.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, import_zod37.z.unknown(), "z.unknown()");
  }
};

// src/generated-admin/endpoints/UserAgreementAdmin$.ts
var import_sdk17 = require("@accelbyte/sdk");

// src/generated-definitions/AcceptAgreementResponse.ts
var import_zod38 = require("zod");
var AcceptAgreementResponse = import_zod38.z.object({ comply: import_zod38.z.boolean(), proceed: import_zod38.z.boolean() });

// src/generated-admin/endpoints/UserAgreementAdmin$.ts
var UserAgreementAdmin$ = class {
  // @ts-ignore
  // prettier-ignore
  constructor(axiosInstance, namespace, useSchemaValidation = true) {
    this.axiosInstance = axiosInstance;
    this.namespace = namespace;
    this.useSchemaValidation = useSchemaValidation;
  }
  /**
   * Accepts many legal policy versions all at once. Supply with localized version policy id and userId to accept an agreement.
   */
  createAgreementPolicy_ByUserId(userId, data, queryParams) {
    const params = { ...queryParams };
    const url = "/agreement/admin/namespaces/{namespace}/users/{userId}/agreements/policies".replace("{namespace}", this.namespace).replace("{userId}", userId);
    const resultPromise = this.axiosInstance.post(url, data, { params });
    return import_sdk17.Validate.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      AcceptAgreementResponse,
      "AcceptAgreementResponse"
    );
  }
};

// src/generated-admin/endpoints/UserEligibilitiesAdmin$.ts
var import_sdk18 = require("@accelbyte/sdk");

// src/generated-definitions/RetrieveUserEligibilitiesIndirectResponse.ts
var import_zod39 = require("zod");
var RetrieveUserEligibilitiesIndirectResponse = import_zod39.z.object({ isComply: import_zod39.z.boolean() });

// src/generated-admin/endpoints/UserEligibilitiesAdmin$.ts
var UserEligibilitiesAdmin$ = class {
  // @ts-ignore
  // prettier-ignore
  constructor(axiosInstance, namespace, useSchemaValidation = true) {
    this.axiosInstance = axiosInstance;
    this.namespace = namespace;
    this.useSchemaValidation = useSchemaValidation;
  }
  /**
   * Retrieve the active policies and its conformance status by user.&lt;br&gt;This process only supports cross-namespace checking between game namespace and publisher namespace , that means if the active policy already accepted by the same user in publisher namespace, then it will also be considered as eligible in non-publisher namespace.
   */
  getEligibilities_ByUserId(userId, queryParams) {
    const params = { ...queryParams };
    const url = "/agreement/admin/namespaces/{namespace}/users/{userId}/eligibilities".replace("{namespace}", this.namespace).replace("{userId}", userId);
    const resultPromise = this.axiosInstance.get(url, { params });
    return import_sdk18.Validate.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      RetrieveUserEligibilitiesIndirectResponse,
      "RetrieveUserEligibilitiesIndirectResponse"
    );
  }
};

// src/generated-admin/endpoints/UserInfoAdmin$.ts
var import_sdk19 = require("@accelbyte/sdk");
var import_zod42 = require("zod");

// src/generated-definitions/RetrieveUserInfoCacheStatusResponseArray.ts
var import_zod41 = require("zod");

// src/generated-definitions/RetrieveUserInfoCacheStatusResponse.ts
var import_zod40 = require("zod");
var RetrieveUserInfoCacheStatusResponse = import_zod40.z.object({ lastUpdatedAt: import_zod40.z.string(), namespace: import_zod40.z.string() });

// src/generated-definitions/RetrieveUserInfoCacheStatusResponseArray.ts
var RetrieveUserInfoCacheStatusResponseArray = import_zod41.z.array(RetrieveUserInfoCacheStatusResponse);

// src/generated-admin/endpoints/UserInfoAdmin$.ts
var UserInfoAdmin$ = class {
  // @ts-ignore
  // prettier-ignore
  constructor(axiosInstance, namespace, useSchemaValidation = true) {
    this.axiosInstance = axiosInstance;
    this.namespace = namespace;
    this.useSchemaValidation = useSchemaValidation;
  }
  /**
   * @deprecated
   * Invalidate user info cache in agreement service.
   */
  deleteUserInfo(queryParams) {
    const params = { ...queryParams };
    const url = "/agreement/admin/userInfo";
    const resultPromise = this.axiosInstance.delete(url, { params });
    return import_sdk19.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, import_zod42.z.unknown(), "z.unknown()");
  }
  /**
   * Get user info cache last updated time per namespace.&lt;br&gt;The query parameter namespaces can be a list of namespace separated by comma.&lt;br&gt;If query parameter namespaces is empty, user info cache status for all available namespaces will be returned.
   */
  getUserInfo(queryParams) {
    const params = { ...queryParams };
    const url = "/agreement/admin/userInfo";
    const resultPromise = this.axiosInstance.get(url, { params });
    return import_sdk19.Validate.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      RetrieveUserInfoCacheStatusResponseArray,
      "RetrieveUserInfoCacheStatusResponseArray"
    );
  }
  /**
   * @deprecated
   * Sync user info cache in agreement service with iam service.
   */
  updateUserInfo(queryParams) {
    const params = { ...queryParams };
    const url = "/agreement/admin/userInfo";
    const resultPromise = this.axiosInstance.put(url, null, { params });
    return import_sdk19.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, import_zod42.z.unknown(), "z.unknown()");
  }
};

// src/generated-admin/LocalizedPolicyVersionsAdminApi.ts
var import_sdk20 = require("@accelbyte/sdk");
function LocalizedPolicyVersionsAdminApi(sdk, args) {
  const sdkAssembly = sdk.assembly();
  const namespace = args?.coreConfig?.namespace ?? sdkAssembly.coreConfig.namespace;
  const useSchemaValidation = args?.coreConfig?.useSchemaValidation ?? sdkAssembly.coreConfig.useSchemaValidation;
  let axiosInstance = sdkAssembly.axiosInstance;
  const requestConfigOverrides = args?.axiosConfig?.request;
  const baseURLOverride = args?.coreConfig?.baseURL;
  const interceptorsOverride = args?.axiosConfig?.interceptors ?? [];
  if (requestConfigOverrides || baseURLOverride || interceptorsOverride.length > 0) {
    const requestConfig = import_sdk20.ApiUtils.mergeAxiosConfigs(sdkAssembly.axiosInstance.defaults, {
      ...baseURLOverride ? { baseURL: baseURLOverride } : {},
      ...requestConfigOverrides
    });
    axiosInstance = import_sdk20.Network.create(requestConfig);
    for (const interceptor of interceptorsOverride) {
      if (interceptor.type === "request") {
        axiosInstance.interceptors.request.use(interceptor.onRequest, interceptor.onError);
      }
      if (interceptor.type === "response") {
        axiosInstance.interceptors.response.use(interceptor.onSuccess, interceptor.onError);
      }
    }
  }
  async function getLocalizedPolicyVersion_ByLocalizedPolicyVersionId(localizedPolicyVersionId) {
    const $ = new LocalizedPolicyVersionsAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getLocalizedPolicyVersion_ByLocalizedPolicyVersionId(localizedPolicyVersionId);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function updateLocalizedPolicyVersion_ByLocalizedPolicyVersionId(localizedPolicyVersionId, data) {
    const $ = new LocalizedPolicyVersionsAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.updateLocalizedPolicyVersion_ByLocalizedPolicyVersionId(localizedPolicyVersionId, data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getLocalizedPolicyVersionVersion_ByPolicyVersionId(policyVersionId) {
    const $ = new LocalizedPolicyVersionsAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getLocalizedPolicyVersionVersion_ByPolicyVersionId(policyVersionId);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function createLocalizedPolicyVersionVersion_ByPolicyVersionId(policyVersionId, data) {
    const $ = new LocalizedPolicyVersionsAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.createLocalizedPolicyVersionVersion_ByPolicyVersionId(policyVersionId, data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function patchDefault_ByLocalizedPolicyVersionId(localizedPolicyVersionId) {
    const $ = new LocalizedPolicyVersionsAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.patchDefault_ByLocalizedPolicyVersionId(localizedPolicyVersionId);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function createAttachment_ByLocalizedPolicyVersionId(localizedPolicyVersionId, data) {
    const $ = new LocalizedPolicyVersionsAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.createAttachment_ByLocalizedPolicyVersionId(localizedPolicyVersionId, data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  return {
    /**
     * Retrieve a version of a particular country-specific policy.
     */
    getLocalizedPolicyVersion_ByLocalizedPolicyVersionId,
    /**
     * Update a version of a particular country-specific policy.
     */
    updateLocalizedPolicyVersion_ByLocalizedPolicyVersionId,
    /**
     * Retrieve versions of a particular country-specific policy.
     */
    getLocalizedPolicyVersionVersion_ByPolicyVersionId,
    /**
     * Create a version of a particular country-specific policy.
     */
    createLocalizedPolicyVersionVersion_ByPolicyVersionId,
    /**
     * Update a localized version policy to be the default.
     */
    patchDefault_ByLocalizedPolicyVersionId,
    /**
     * Request presigned URL for upload attachment for a particular localized version of base policy.
     */
    createAttachment_ByLocalizedPolicyVersionId
  };
}

// src/generated-admin/LocalizedPolicyVersionsWithNamespaceAdminApi.ts
var import_sdk21 = require("@accelbyte/sdk");
function LocalizedPolicyVersionsWithNamespaceAdminApi(sdk, args) {
  const sdkAssembly = sdk.assembly();
  const namespace = args?.coreConfig?.namespace ?? sdkAssembly.coreConfig.namespace;
  const useSchemaValidation = args?.coreConfig?.useSchemaValidation ?? sdkAssembly.coreConfig.useSchemaValidation;
  let axiosInstance = sdkAssembly.axiosInstance;
  const requestConfigOverrides = args?.axiosConfig?.request;
  const baseURLOverride = args?.coreConfig?.baseURL;
  const interceptorsOverride = args?.axiosConfig?.interceptors ?? [];
  if (requestConfigOverrides || baseURLOverride || interceptorsOverride.length > 0) {
    const requestConfig = import_sdk21.ApiUtils.mergeAxiosConfigs(sdkAssembly.axiosInstance.defaults, {
      ...baseURLOverride ? { baseURL: baseURLOverride } : {},
      ...requestConfigOverrides
    });
    axiosInstance = import_sdk21.Network.create(requestConfig);
    for (const interceptor of interceptorsOverride) {
      if (interceptor.type === "request") {
        axiosInstance.interceptors.request.use(interceptor.onRequest, interceptor.onError);
      }
      if (interceptor.type === "response") {
        axiosInstance.interceptors.response.use(interceptor.onSuccess, interceptor.onError);
      }
    }
  }
  async function getLocalizedPolicyVersion_ByLocalizedPolicyVersionId(localizedPolicyVersionId) {
    const $ = new LocalizedPolicyVersionsWithNamespaceAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getLocalizedPolicyVersion_ByLocalizedPolicyVersionId(localizedPolicyVersionId);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function updateLocalizedPolicyVersion_ByLocalizedPolicyVersionId(localizedPolicyVersionId, data) {
    const $ = new LocalizedPolicyVersionsWithNamespaceAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.updateLocalizedPolicyVersion_ByLocalizedPolicyVersionId(localizedPolicyVersionId, data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getLocalizedPolicyVersionVersion_ByPolicyVersionId(policyVersionId) {
    const $ = new LocalizedPolicyVersionsWithNamespaceAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getLocalizedPolicyVersionVersion_ByPolicyVersionId(policyVersionId);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function createLocalizedPolicyVersionVersion_ByPolicyVersionId(policyVersionId, data) {
    const $ = new LocalizedPolicyVersionsWithNamespaceAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.createLocalizedPolicyVersionVersion_ByPolicyVersionId(policyVersionId, data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function patchDefault_ByLocalizedPolicyVersionId(localizedPolicyVersionId) {
    const $ = new LocalizedPolicyVersionsWithNamespaceAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.patchDefault_ByLocalizedPolicyVersionId(localizedPolicyVersionId);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function createAttachment_ByLocalizedPolicyVersionId(localizedPolicyVersionId, data) {
    const $ = new LocalizedPolicyVersionsWithNamespaceAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.createAttachment_ByLocalizedPolicyVersionId(localizedPolicyVersionId, data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  return {
    /**
     * Retrieve a version of a particular country-specific policy.
     */
    getLocalizedPolicyVersion_ByLocalizedPolicyVersionId,
    /**
     * Update a version of a particular country-specific policy.
     */
    updateLocalizedPolicyVersion_ByLocalizedPolicyVersionId,
    /**
     * Retrieve versions of a particular country-specific policy.
     */
    getLocalizedPolicyVersionVersion_ByPolicyVersionId,
    /**
     * Create a version of a particular country-specific policy.
     */
    createLocalizedPolicyVersionVersion_ByPolicyVersionId,
    /**
     * Update a localized version policy to be the default.
     */
    patchDefault_ByLocalizedPolicyVersionId,
    /**
     * Request presigned URL for upload attachment for a particular localized version of base policy.
     */
    createAttachment_ByLocalizedPolicyVersionId
  };
}

// src/generated-admin/PoliciesAdminApi.ts
var import_sdk22 = require("@accelbyte/sdk");
function PoliciesAdminApi(sdk, args) {
  const sdkAssembly = sdk.assembly();
  const namespace = args?.coreConfig?.namespace ?? sdkAssembly.coreConfig.namespace;
  const useSchemaValidation = args?.coreConfig?.useSchemaValidation ?? sdkAssembly.coreConfig.useSchemaValidation;
  let axiosInstance = sdkAssembly.axiosInstance;
  const requestConfigOverrides = args?.axiosConfig?.request;
  const baseURLOverride = args?.coreConfig?.baseURL;
  const interceptorsOverride = args?.axiosConfig?.interceptors ?? [];
  if (requestConfigOverrides || baseURLOverride || interceptorsOverride.length > 0) {
    const requestConfig = import_sdk22.ApiUtils.mergeAxiosConfigs(sdkAssembly.axiosInstance.defaults, {
      ...baseURLOverride ? { baseURL: baseURLOverride } : {},
      ...requestConfigOverrides
    });
    axiosInstance = import_sdk22.Network.create(requestConfig);
    for (const interceptor of interceptorsOverride) {
      if (interceptor.type === "request") {
        axiosInstance.interceptors.request.use(interceptor.onRequest, interceptor.onError);
      }
      if (interceptor.type === "response") {
        axiosInstance.interceptors.response.use(interceptor.onSuccess, interceptor.onError);
      }
    }
  }
  async function patchPolicy_ByPolicyId(policyId, data) {
    const $ = new PoliciesAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.patchPolicy_ByPolicyId(policyId, data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function patchDefault_ByPolicyId(policyId) {
    const $ = new PoliciesAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.patchDefault_ByPolicyId(policyId);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getPolicyCountry_ByCountryCode(countryCode) {
    const $ = new PoliciesAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getPolicyCountry_ByCountryCode(countryCode);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  return {
    /**
     * Update country-specific policy.
     */
    patchPolicy_ByPolicyId,
    /**
     * Update a policy to be the default.
     */
    patchDefault_ByPolicyId,
    /**
     * Retrieve all active policies based on a country.
     */
    getPolicyCountry_ByCountryCode
  };
}

// src/generated-admin/PoliciesWithNamespaceAdminApi.ts
var import_sdk23 = require("@accelbyte/sdk");
function PoliciesWithNamespaceAdminApi(sdk, args) {
  const sdkAssembly = sdk.assembly();
  const namespace = args?.coreConfig?.namespace ?? sdkAssembly.coreConfig.namespace;
  const useSchemaValidation = args?.coreConfig?.useSchemaValidation ?? sdkAssembly.coreConfig.useSchemaValidation;
  let axiosInstance = sdkAssembly.axiosInstance;
  const requestConfigOverrides = args?.axiosConfig?.request;
  const baseURLOverride = args?.coreConfig?.baseURL;
  const interceptorsOverride = args?.axiosConfig?.interceptors ?? [];
  if (requestConfigOverrides || baseURLOverride || interceptorsOverride.length > 0) {
    const requestConfig = import_sdk23.ApiUtils.mergeAxiosConfigs(sdkAssembly.axiosInstance.defaults, {
      ...baseURLOverride ? { baseURL: baseURLOverride } : {},
      ...requestConfigOverrides
    });
    axiosInstance = import_sdk23.Network.create(requestConfig);
    for (const interceptor of interceptorsOverride) {
      if (interceptor.type === "request") {
        axiosInstance.interceptors.request.use(interceptor.onRequest, interceptor.onError);
      }
      if (interceptor.type === "response") {
        axiosInstance.interceptors.response.use(interceptor.onSuccess, interceptor.onError);
      }
    }
  }
  async function patchPolicy_ByPolicyId(policyId, data) {
    const $ = new PoliciesWithNamespaceAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.patchPolicy_ByPolicyId(policyId, data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function patchDefault_ByPolicyId(policyId) {
    const $ = new PoliciesWithNamespaceAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.patchDefault_ByPolicyId(policyId);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  return {
    /**
     * Update country-specific policy.
     */
    patchPolicy_ByPolicyId,
    /**
     * Update a policy to be the default.
     */
    patchDefault_ByPolicyId
  };
}

// src/generated-admin/PolicyVersionsAdminApi.ts
var import_sdk24 = require("@accelbyte/sdk");
function PolicyVersionsAdminApi(sdk, args) {
  const sdkAssembly = sdk.assembly();
  const namespace = args?.coreConfig?.namespace ?? sdkAssembly.coreConfig.namespace;
  const useSchemaValidation = args?.coreConfig?.useSchemaValidation ?? sdkAssembly.coreConfig.useSchemaValidation;
  let axiosInstance = sdkAssembly.axiosInstance;
  const requestConfigOverrides = args?.axiosConfig?.request;
  const baseURLOverride = args?.coreConfig?.baseURL;
  const interceptorsOverride = args?.axiosConfig?.interceptors ?? [];
  if (requestConfigOverrides || baseURLOverride || interceptorsOverride.length > 0) {
    const requestConfig = import_sdk24.ApiUtils.mergeAxiosConfigs(sdkAssembly.axiosInstance.defaults, {
      ...baseURLOverride ? { baseURL: baseURLOverride } : {},
      ...requestConfigOverrides
    });
    axiosInstance = import_sdk24.Network.create(requestConfig);
    for (const interceptor of interceptorsOverride) {
      if (interceptor.type === "request") {
        axiosInstance.interceptors.request.use(interceptor.onRequest, interceptor.onError);
      }
      if (interceptor.type === "response") {
        axiosInstance.interceptors.response.use(interceptor.onSuccess, interceptor.onError);
      }
    }
  }
  async function getVersions_ByPolicyId(policyId, queryParams) {
    const $ = new PolicyVersionsAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getVersions_ByPolicyId(policyId, queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function createVersion_ByPolicyId(policyId, data) {
    const $ = new PolicyVersionsAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.createVersion_ByPolicyId(policyId, data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function patchPolicyVersion_ByPolicyVersionId(policyVersionId, data) {
    const $ = new PolicyVersionsAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.patchPolicyVersion_ByPolicyVersionId(policyVersionId, data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function patchLatestPolicy_ByPolicyVersionId(policyVersionId, queryParams) {
    const $ = new PolicyVersionsAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.patchLatestPolicy_ByPolicyVersionId(policyVersionId, queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  return {
    /**
     * Retrieve a version of a particular country specific policy. If version is not provided, the Legal Service will assume caller requesting all versions from country-specific policy.
     */
    getVersions_ByPolicyId,
    /**
     * Create a version of a particular country-specific policy.
     */
    createVersion_ByPolicyId,
    /**
     * Update a particular policy version.
     */
    patchPolicyVersion_ByPolicyVersionId,
    /**
     * Manually publish a version of a particular country-specific policy.
     */
    patchLatestPolicy_ByPolicyVersionId
  };
}

// src/generated-admin/PolicyVersionsWithNamespaceAdminApi.ts
var import_sdk25 = require("@accelbyte/sdk");
function PolicyVersionsWithNamespaceAdminApi(sdk, args) {
  const sdkAssembly = sdk.assembly();
  const namespace = args?.coreConfig?.namespace ?? sdkAssembly.coreConfig.namespace;
  const useSchemaValidation = args?.coreConfig?.useSchemaValidation ?? sdkAssembly.coreConfig.useSchemaValidation;
  let axiosInstance = sdkAssembly.axiosInstance;
  const requestConfigOverrides = args?.axiosConfig?.request;
  const baseURLOverride = args?.coreConfig?.baseURL;
  const interceptorsOverride = args?.axiosConfig?.interceptors ?? [];
  if (requestConfigOverrides || baseURLOverride || interceptorsOverride.length > 0) {
    const requestConfig = import_sdk25.ApiUtils.mergeAxiosConfigs(sdkAssembly.axiosInstance.defaults, {
      ...baseURLOverride ? { baseURL: baseURLOverride } : {},
      ...requestConfigOverrides
    });
    axiosInstance = import_sdk25.Network.create(requestConfig);
    for (const interceptor of interceptorsOverride) {
      if (interceptor.type === "request") {
        axiosInstance.interceptors.request.use(interceptor.onRequest, interceptor.onError);
      }
      if (interceptor.type === "response") {
        axiosInstance.interceptors.response.use(interceptor.onSuccess, interceptor.onError);
      }
    }
  }
  async function getVersions_ByPolicyId(policyId, queryParams) {
    const $ = new PolicyVersionsWithNamespaceAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getVersions_ByPolicyId(policyId, queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function createVersion_ByPolicyId(policyId, data) {
    const $ = new PolicyVersionsWithNamespaceAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.createVersion_ByPolicyId(policyId, data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function patchPolicyVersion_ByPolicyVersionId(policyVersionId, data) {
    const $ = new PolicyVersionsWithNamespaceAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.patchPolicyVersion_ByPolicyVersionId(policyVersionId, data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function patchLatestPolicy_ByPolicyVersionId(policyVersionId, queryParams) {
    const $ = new PolicyVersionsWithNamespaceAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.patchLatestPolicy_ByPolicyVersionId(policyVersionId, queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  return {
    /**
     * Retrieve a version of a particular country specific policy. If version is not provided, the Legal Service will assume caller requesting all versions from country-specific policy.
     */
    getVersions_ByPolicyId,
    /**
     * Create a version of a particular country-specific policy.
     */
    createVersion_ByPolicyId,
    /**
     * Update a particular policy version.
     */
    patchPolicyVersion_ByPolicyVersionId,
    /**
     * Manually publish a version of a particular country-specific policy.
     */
    patchLatestPolicy_ByPolicyVersionId
  };
}

// src/generated-admin/UserAgreementAdminApi.ts
var import_sdk26 = require("@accelbyte/sdk");
function UserAgreementAdminApi(sdk, args) {
  const sdkAssembly = sdk.assembly();
  const namespace = args?.coreConfig?.namespace ?? sdkAssembly.coreConfig.namespace;
  const useSchemaValidation = args?.coreConfig?.useSchemaValidation ?? sdkAssembly.coreConfig.useSchemaValidation;
  let axiosInstance = sdkAssembly.axiosInstance;
  const requestConfigOverrides = args?.axiosConfig?.request;
  const baseURLOverride = args?.coreConfig?.baseURL;
  const interceptorsOverride = args?.axiosConfig?.interceptors ?? [];
  if (requestConfigOverrides || baseURLOverride || interceptorsOverride.length > 0) {
    const requestConfig = import_sdk26.ApiUtils.mergeAxiosConfigs(sdkAssembly.axiosInstance.defaults, {
      ...baseURLOverride ? { baseURL: baseURLOverride } : {},
      ...requestConfigOverrides
    });
    axiosInstance = import_sdk26.Network.create(requestConfig);
    for (const interceptor of interceptorsOverride) {
      if (interceptor.type === "request") {
        axiosInstance.interceptors.request.use(interceptor.onRequest, interceptor.onError);
      }
      if (interceptor.type === "response") {
        axiosInstance.interceptors.response.use(interceptor.onSuccess, interceptor.onError);
      }
    }
  }
  async function createAgreementPolicy_ByUserId(userId, data, queryParams) {
    const $ = new UserAgreementAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.createAgreementPolicy_ByUserId(userId, data, queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  return {
    /**
     * Accepts many legal policy versions all at once. Supply with localized version policy id and userId to accept an agreement.
     */
    createAgreementPolicy_ByUserId
  };
}

// src/generated-admin/UserEligibilitiesAdminApi.ts
var import_sdk27 = require("@accelbyte/sdk");
function UserEligibilitiesAdminApi(sdk, args) {
  const sdkAssembly = sdk.assembly();
  const namespace = args?.coreConfig?.namespace ?? sdkAssembly.coreConfig.namespace;
  const useSchemaValidation = args?.coreConfig?.useSchemaValidation ?? sdkAssembly.coreConfig.useSchemaValidation;
  let axiosInstance = sdkAssembly.axiosInstance;
  const requestConfigOverrides = args?.axiosConfig?.request;
  const baseURLOverride = args?.coreConfig?.baseURL;
  const interceptorsOverride = args?.axiosConfig?.interceptors ?? [];
  if (requestConfigOverrides || baseURLOverride || interceptorsOverride.length > 0) {
    const requestConfig = import_sdk27.ApiUtils.mergeAxiosConfigs(sdkAssembly.axiosInstance.defaults, {
      ...baseURLOverride ? { baseURL: baseURLOverride } : {},
      ...requestConfigOverrides
    });
    axiosInstance = import_sdk27.Network.create(requestConfig);
    for (const interceptor of interceptorsOverride) {
      if (interceptor.type === "request") {
        axiosInstance.interceptors.request.use(interceptor.onRequest, interceptor.onError);
      }
      if (interceptor.type === "response") {
        axiosInstance.interceptors.response.use(interceptor.onSuccess, interceptor.onError);
      }
    }
  }
  async function getEligibilities_ByUserId(userId, queryParams) {
    const $ = new UserEligibilitiesAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getEligibilities_ByUserId(userId, queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  return {
    /**
     * Retrieve the active policies and its conformance status by user.&lt;br&gt;This process only supports cross-namespace checking between game namespace and publisher namespace , that means if the active policy already accepted by the same user in publisher namespace, then it will also be considered as eligible in non-publisher namespace.
     */
    getEligibilities_ByUserId
  };
}

// src/generated-admin/UserInfoAdminApi.ts
var import_sdk28 = require("@accelbyte/sdk");
function UserInfoAdminApi(sdk, args) {
  const sdkAssembly = sdk.assembly();
  const namespace = args?.coreConfig?.namespace ?? sdkAssembly.coreConfig.namespace;
  const useSchemaValidation = args?.coreConfig?.useSchemaValidation ?? sdkAssembly.coreConfig.useSchemaValidation;
  let axiosInstance = sdkAssembly.axiosInstance;
  const requestConfigOverrides = args?.axiosConfig?.request;
  const baseURLOverride = args?.coreConfig?.baseURL;
  const interceptorsOverride = args?.axiosConfig?.interceptors ?? [];
  if (requestConfigOverrides || baseURLOverride || interceptorsOverride.length > 0) {
    const requestConfig = import_sdk28.ApiUtils.mergeAxiosConfigs(sdkAssembly.axiosInstance.defaults, {
      ...baseURLOverride ? { baseURL: baseURLOverride } : {},
      ...requestConfigOverrides
    });
    axiosInstance = import_sdk28.Network.create(requestConfig);
    for (const interceptor of interceptorsOverride) {
      if (interceptor.type === "request") {
        axiosInstance.interceptors.request.use(interceptor.onRequest, interceptor.onError);
      }
      if (interceptor.type === "response") {
        axiosInstance.interceptors.response.use(interceptor.onSuccess, interceptor.onError);
      }
    }
  }
  async function deleteUserInfo(queryParams) {
    const $ = new UserInfoAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.deleteUserInfo(queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getUserInfo(queryParams) {
    const $ = new UserInfoAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getUserInfo(queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function updateUserInfo(queryParams) {
    const $ = new UserInfoAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.updateUserInfo(queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  return {
    /**
     * @deprecated
     * Invalidate user info cache in agreement service.
     */
    deleteUserInfo,
    /**
     * Get user info cache last updated time per namespace.&lt;br&gt;The query parameter namespaces can be a list of namespace separated by comma.&lt;br&gt;If query parameter namespaces is empty, user info cache status for all available namespaces will be returned.
     */
    getUserInfo,
    /**
     * @deprecated
     * Sync user info cache in agreement service with iam service.
     */
    updateUserInfo
  };
}

// src/generated-definitions/AcceptAgreementRequest.ts
var import_zod43 = require("zod");
var AcceptAgreementRequest = import_zod43.z.object({
  isAccepted: import_zod43.z.boolean(),
  isNeedToSendEventMarketing: import_zod43.z.boolean().nullish(),
  localizedPolicyVersionId: import_zod43.z.string(),
  policyId: import_zod43.z.string(),
  policyVersionId: import_zod43.z.string()
});

// src/generated-definitions/CreateBasePolicyRequest.ts
var import_zod44 = require("zod");
var CreateBasePolicyRequest = import_zod44.z.object({
  affectedClientIds: import_zod44.z.array(import_zod44.z.string()).nullish(),
  affectedCountries: import_zod44.z.array(import_zod44.z.string()).nullish(),
  basePolicyName: import_zod44.z.string().nullish(),
  description: import_zod44.z.string().nullish(),
  isHidden: import_zod44.z.boolean().nullish(),
  isHiddenPublic: import_zod44.z.boolean().nullish(),
  namespace: import_zod44.z.string().nullish(),
  tags: import_zod44.z.array(import_zod44.z.string()).nullish(),
  typeId: import_zod44.z.string().nullish()
});

// src/generated-definitions/CreateBasePolicyRequestV2.ts
var import_zod45 = require("zod");
var CreateBasePolicyRequestV2 = import_zod45.z.object({
  affectedClientIds: import_zod45.z.array(import_zod45.z.string()).nullish(),
  affectedCountries: import_zod45.z.array(import_zod45.z.string()).nullish(),
  basePolicyName: import_zod45.z.string().nullish(),
  description: import_zod45.z.string().nullish(),
  isHidden: import_zod45.z.boolean().nullish(),
  isHiddenPublic: import_zod45.z.boolean().nullish(),
  tags: import_zod45.z.array(import_zod45.z.string()).nullish(),
  typeId: import_zod45.z.string().nullish()
});

// src/generated-definitions/CreateLocalizedPolicyVersionRequest.ts
var import_zod46 = require("zod");
var CreateLocalizedPolicyVersionRequest = import_zod46.z.object({
  contentType: import_zod46.z.string().nullish(),
  description: import_zod46.z.string().nullish(),
  localeCode: import_zod46.z.string().nullish()
});

// src/generated-definitions/CreatePolicyVersionRequest.ts
var import_zod47 = require("zod");
var CreatePolicyVersionRequest = import_zod47.z.object({
  description: import_zod47.z.string().nullish(),
  displayVersion: import_zod47.z.string().nullish(),
  isCommitted: import_zod47.z.boolean().nullish()
});

// src/generated-definitions/ErrorEntity.ts
var import_zod49 = require("zod");

// src/generated-definitions/Permission.ts
var import_zod48 = require("zod");
var Permission = import_zod48.z.object({ action: import_zod48.z.number().int().nullish(), resource: import_zod48.z.string().nullish() });

// src/generated-definitions/ErrorEntity.ts
var ErrorEntity = import_zod49.z.object({
  devStackTrace: import_zod49.z.string().nullish(),
  errorCode: import_zod49.z.number().int(),
  errorMessage: import_zod49.z.string(),
  messageVariables: import_zod49.z.record(import_zod49.z.string()).nullish(),
  requiredPermission: Permission.nullish()
});

// src/generated-definitions/FieldValidationError.ts
var import_zod50 = require("zod");
var FieldValidationError = import_zod50.z.object({
  errorCode: import_zod50.z.string().nullish(),
  errorField: import_zod50.z.string().nullish(),
  errorMessage: import_zod50.z.string().nullish(),
  errorValue: import_zod50.z.string().nullish(),
  messageVariables: import_zod50.z.record(import_zod50.z.string()).nullish()
});

// src/generated-definitions/LegalReadinessStatusResponse.ts
var import_zod51 = require("zod");
var LegalReadinessStatusResponse = import_zod51.z.object({ isReady: import_zod51.z.boolean().nullish() });

// src/generated-definitions/PolicyVersionWithLocalizedVersionObject.ts
var import_zod52 = require("zod");
var PolicyVersionWithLocalizedVersionObject = import_zod52.z.object({
  createdAt: import_zod52.z.string().nullish(),
  description: import_zod52.z.string().nullish(),
  displayVersion: import_zod52.z.string(),
  id: import_zod52.z.string(),
  isCommitted: import_zod52.z.boolean(),
  isInEffect: import_zod52.z.boolean(),
  localizedPolicyVersions: import_zod52.z.array(LocalizedPolicyVersionObject).nullish(),
  publishedDate: import_zod52.z.string().nullish(),
  status: import_zod52.z.string().nullish(),
  updatedAt: import_zod52.z.string().nullish()
});

// src/generated-definitions/RetrieveLocalizedPolicyVersionPublicResponse.ts
var import_zod53 = require("zod");
var RetrieveLocalizedPolicyVersionPublicResponse = import_zod53.z.object({
  attachmentChecksum: import_zod53.z.string().nullish(),
  attachmentLocation: import_zod53.z.string().nullish(),
  attachmentVersionIdentifier: import_zod53.z.string().nullish(),
  basePolicyId: import_zod53.z.string().nullish(),
  baseUrls: import_zod53.z.array(import_zod53.z.string()).nullish(),
  contentType: import_zod53.z.string().nullish(),
  createdAt: import_zod53.z.string().nullish(),
  description: import_zod53.z.string().nullish(),
  id: import_zod53.z.string(),
  isHidden: import_zod53.z.boolean().nullish(),
  localeCode: import_zod53.z.string(),
  namespace: import_zod53.z.string(),
  policy: PolicyObject,
  policyVersion: PolicyVersionObject,
  tags: import_zod53.z.array(import_zod53.z.string()).nullish(),
  updatedAt: import_zod53.z.string().nullish()
});

// src/generated-definitions/RetrievePolicyPublicResponse.ts
var import_zod54 = require("zod");
var RetrievePolicyPublicResponse = import_zod54.z.object({
  basePolicyId: import_zod54.z.string(),
  baseUrls: import_zod54.z.array(import_zod54.z.string()).nullish(),
  countryCode: import_zod54.z.string(),
  countryGroupCode: import_zod54.z.string().nullish(),
  createdAt: import_zod54.z.string().nullish(),
  description: import_zod54.z.string().nullish(),
  id: import_zod54.z.string(),
  isDefaultOpted: import_zod54.z.boolean(),
  isDefaultSelection: import_zod54.z.boolean(),
  isMandatory: import_zod54.z.boolean(),
  namespace: import_zod54.z.string(),
  policyName: import_zod54.z.string(),
  policyType: import_zod54.z.string(),
  policyVersions: import_zod54.z.array(PolicyVersionWithLocalizedVersionObject).nullish(),
  readableId: import_zod54.z.string().nullish(),
  shouldNotifyOnUpdate: import_zod54.z.boolean(),
  tags: import_zod54.z.array(import_zod54.z.string()).nullish(),
  updatedAt: import_zod54.z.string().nullish()
});

// src/generated-definitions/RetrievePolicyPublicResponseArray.ts
var import_zod55 = require("zod");
var RetrievePolicyPublicResponseArray = import_zod55.z.array(RetrievePolicyPublicResponse);

// src/generated-definitions/RetrieveUserEligibilitiesResponse.ts
var import_zod56 = require("zod");
var RetrieveUserEligibilitiesResponse = import_zod56.z.object({
  baseUrls: import_zod56.z.array(import_zod56.z.string()).nullish(),
  countryCode: import_zod56.z.string(),
  countryGroupCode: import_zod56.z.string().nullish(),
  description: import_zod56.z.string().nullish(),
  isAccepted: import_zod56.z.boolean(),
  isHiddenPublic: import_zod56.z.boolean().nullish(),
  isMandatory: import_zod56.z.boolean(),
  namespace: import_zod56.z.string(),
  policyId: import_zod56.z.string(),
  policyName: import_zod56.z.string(),
  policyType: import_zod56.z.string(),
  policyVersions: import_zod56.z.array(PolicyVersionWithLocalizedVersionObject).nullish(),
  readableId: import_zod56.z.string().nullish()
});

// src/generated-definitions/RetrieveUserEligibilitiesResponseArray.ts
var import_zod57 = require("zod");
var RetrieveUserEligibilitiesResponseArray = import_zod57.z.array(RetrieveUserEligibilitiesResponse);

// src/generated-definitions/UpdateBasePolicyRequest.ts
var import_zod58 = require("zod");
var UpdateBasePolicyRequest = import_zod58.z.object({
  affectedClientIds: import_zod58.z.array(import_zod58.z.string()).nullish(),
  affectedCountries: import_zod58.z.array(import_zod58.z.string()).nullish(),
  basePolicyName: import_zod58.z.string().nullish(),
  description: import_zod58.z.string().nullish(),
  isHidden: import_zod58.z.boolean().nullish(),
  isHiddenPublic: import_zod58.z.boolean().nullish(),
  namespace: import_zod58.z.string().nullish(),
  tags: import_zod58.z.array(import_zod58.z.string()).nullish()
});

// src/generated-definitions/UpdateBasePolicyRequestV2.ts
var import_zod59 = require("zod");
var UpdateBasePolicyRequestV2 = import_zod59.z.object({
  affectedClientIds: import_zod59.z.array(import_zod59.z.string()).nullish(),
  affectedCountries: import_zod59.z.array(import_zod59.z.string()).nullish(),
  basePolicyName: import_zod59.z.string().nullish(),
  description: import_zod59.z.string().nullish(),
  isHidden: import_zod59.z.boolean().nullish(),
  isHiddenPublic: import_zod59.z.boolean().nullish(),
  tags: import_zod59.z.array(import_zod59.z.string()).nullish()
});

// src/generated-definitions/UpdateLocalizedPolicyVersionRequest.ts
var import_zod60 = require("zod");
var UpdateLocalizedPolicyVersionRequest = import_zod60.z.object({
  attachmentChecksum: import_zod60.z.string().nullish(),
  attachmentLocation: import_zod60.z.string().nullish(),
  attachmentVersionIdentifier: import_zod60.z.string().nullish(),
  contentType: import_zod60.z.string().nullish(),
  description: import_zod60.z.string().nullish()
});

// src/generated-definitions/UpdatePolicyRequest.ts
var import_zod61 = require("zod");
var UpdatePolicyRequest = import_zod61.z.object({
  description: import_zod61.z.string().nullish(),
  isDefaultOpted: import_zod61.z.boolean(),
  isMandatory: import_zod61.z.boolean(),
  policyName: import_zod61.z.string(),
  readableId: import_zod61.z.string().nullish(),
  shouldNotifyOnUpdate: import_zod61.z.boolean()
});

// src/generated-definitions/UpdatePolicyVersionRequest.ts
var import_zod62 = require("zod");
var UpdatePolicyVersionRequest = import_zod62.z.object({ description: import_zod62.z.string(), displayVersion: import_zod62.z.string(), isCommitted: import_zod62.z.boolean() });

// src/generated-definitions/UploadPolicyVersionAttachmentRequest.ts
var import_zod63 = require("zod");
var UploadPolicyVersionAttachmentRequest = import_zod63.z.object({ contentMD5: import_zod63.z.string().nullish(), contentType: import_zod63.z.string().nullish() });

// src/generated-definitions/UsersAgreementsRequest.ts
var import_zod64 = require("zod");
var UsersAgreementsRequest = import_zod64.z.object({ currentPublishedOnly: import_zod64.z.boolean().nullish(), userIds: import_zod64.z.array(import_zod64.z.string()) });

// src/generated-definitions/ValidationErrorEntity.ts
var import_zod65 = require("zod");
var ValidationErrorEntity = import_zod65.z.object({
  errorCode: import_zod65.z.number().int(),
  errorMessage: import_zod65.z.string(),
  errors: import_zod65.z.array(FieldValidationError).nullish()
});

// src/generated-public/AgreementApi.ts
var import_sdk30 = require("@accelbyte/sdk");

// src/generated-public/endpoints/Agreement$.ts
var import_sdk29 = require("@accelbyte/sdk");
var import_zod66 = require("zod");
var Agreement$ = class {
  // @ts-ignore
  // prettier-ignore
  constructor(axiosInstance, namespace, useSchemaValidation = true) {
    this.axiosInstance = axiosInstance;
    this.namespace = namespace;
    this.useSchemaValidation = useSchemaValidation;
  }
  /**
   * Retrieve accepted Legal Agreements.
   */
  getAgreementsPolicies() {
    const params = {};
    const url = "/agreement/public/agreements/policies";
    const resultPromise = this.axiosInstance.get(url, { params });
    return import_sdk29.Validate.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      RetrieveAcceptedAgreementResponseArray,
      "RetrieveAcceptedAgreementResponseArray"
    );
  }
  /**
   * Accepts many legal policy versions all at once. Supply with localized version policy id to accept an agreement.
   */
  createAgreementPolicy(data) {
    const params = {};
    const url = "/agreement/public/agreements/policies";
    const resultPromise = this.axiosInstance.post(url, data, { params });
    return import_sdk29.Validate.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      AcceptAgreementResponse,
      "AcceptAgreementResponse"
    );
  }
  /**
   * @deprecated
   * Accepts many legal policy versions all at once. Supply with localized version policy id and userId to accept an agreement. This endpoint used by Authentication Service during new user registration.
   */
  createAgreementPolicyUser_ByUserId(userId, data) {
    const params = {};
    const url = "/agreement/public/agreements/policies/users/{userId}".replace("{userId}", userId);
    const resultPromise = this.axiosInstance.post(url, data, { params });
    return import_sdk29.Validate.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      AcceptAgreementResponse,
      "AcceptAgreementResponse"
    );
  }
  /**
   * Change marketing preference consent.
   */
  patchAgreementLocalizedPolicyVersionPreference(data) {
    const params = {};
    const url = "/agreement/public/agreements/localized-policy-versions/preferences";
    const resultPromise = this.axiosInstance.patch(url, data, { params });
    return import_sdk29.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, import_zod66.z.unknown(), "z.unknown()");
  }
  /**
   * Accepts a legal policy version. Supply with localized version policy id to accept an agreement
   */
  createAgreementLocalizedPolicyVersion_ByLocalizedPolicyVersionId(localizedPolicyVersionId) {
    const params = {};
    const url = "/agreement/public/agreements/localized-policy-versions/{localizedPolicyVersionId}".replace(
      "{localizedPolicyVersionId}",
      localizedPolicyVersionId
    );
    const resultPromise = this.axiosInstance.post(url, null, { params });
    return import_sdk29.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, import_zod66.z.unknown(), "z.unknown()");
  }
  /**
   * @deprecated
   * Accepts many legal policy versions all at once. Supply with localized version policy id, version policy id, policy id, userId, namespace, country code and client id to accept an agreement. This endpoint used by APIGateway during new user registration.
   */
  createUserPolicyAgreement_ByCountryCode_ByClientId_ByUserId(countryCode, clientId, userId, data) {
    const params = {};
    const url = "/agreement/public/agreements/policies/namespaces/{namespace}/countries/{countryCode}/clients/{clientId}/users/{userId}".replace("{namespace}", this.namespace).replace("{countryCode}", countryCode).replace("{clientId}", clientId).replace("{userId}", userId);
    const resultPromise = this.axiosInstance.post(url, data, { params });
    return import_sdk29.Validate.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      AcceptAgreementResponse,
      "AcceptAgreementResponse"
    );
  }
};

// src/generated-public/AgreementApi.ts
function AgreementApi(sdk, args) {
  const sdkAssembly = sdk.assembly();
  const namespace = args?.coreConfig?.namespace ?? sdkAssembly.coreConfig.namespace;
  const useSchemaValidation = args?.coreConfig?.useSchemaValidation ?? sdkAssembly.coreConfig.useSchemaValidation;
  let axiosInstance = sdkAssembly.axiosInstance;
  const requestConfigOverrides = args?.axiosConfig?.request;
  const baseURLOverride = args?.coreConfig?.baseURL;
  const interceptorsOverride = args?.axiosConfig?.interceptors ?? [];
  if (requestConfigOverrides || baseURLOverride || interceptorsOverride.length > 0) {
    const requestConfig = import_sdk30.ApiUtils.mergeAxiosConfigs(sdkAssembly.axiosInstance.defaults, {
      ...baseURLOverride ? { baseURL: baseURLOverride } : {},
      ...requestConfigOverrides
    });
    axiosInstance = import_sdk30.Network.create(requestConfig);
    for (const interceptor of interceptorsOverride) {
      if (interceptor.type === "request") {
        axiosInstance.interceptors.request.use(interceptor.onRequest, interceptor.onError);
      }
      if (interceptor.type === "response") {
        axiosInstance.interceptors.response.use(interceptor.onSuccess, interceptor.onError);
      }
    }
  }
  async function getAgreementsPolicies() {
    const $ = new Agreement$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getAgreementsPolicies();
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function createAgreementPolicy(data) {
    const $ = new Agreement$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.createAgreementPolicy(data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function createAgreementPolicyUser_ByUserId(userId, data) {
    const $ = new Agreement$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.createAgreementPolicyUser_ByUserId(userId, data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function patchAgreementLocalizedPolicyVersionPreference(data) {
    const $ = new Agreement$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.patchAgreementLocalizedPolicyVersionPreference(data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function createAgreementLocalizedPolicyVersion_ByLocalizedPolicyVersionId(localizedPolicyVersionId) {
    const $ = new Agreement$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.createAgreementLocalizedPolicyVersion_ByLocalizedPolicyVersionId(localizedPolicyVersionId);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function createUserPolicyAgreement_ByCountryCode_ByClientId_ByUserId(countryCode, clientId, userId, data) {
    const $ = new Agreement$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.createUserPolicyAgreement_ByCountryCode_ByClientId_ByUserId(countryCode, clientId, userId, data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  return {
    /**
     * Retrieve accepted Legal Agreements.
     */
    getAgreementsPolicies,
    /**
     * Accepts many legal policy versions all at once. Supply with localized version policy id to accept an agreement.
     */
    createAgreementPolicy,
    /**
     * @deprecated
     * Accepts many legal policy versions all at once. Supply with localized version policy id and userId to accept an agreement. This endpoint used by Authentication Service during new user registration.
     */
    createAgreementPolicyUser_ByUserId,
    /**
     * Change marketing preference consent.
     */
    patchAgreementLocalizedPolicyVersionPreference,
    /**
     * Accepts a legal policy version. Supply with localized version policy id to accept an agreement
     */
    createAgreementLocalizedPolicyVersion_ByLocalizedPolicyVersionId,
    /**
     * @deprecated
     * Accepts many legal policy versions all at once. Supply with localized version policy id, version policy id, policy id, userId, namespace, country code and client id to accept an agreement. This endpoint used by APIGateway during new user registration.
     */
    createUserPolicyAgreement_ByCountryCode_ByClientId_ByUserId
  };
}

// src/generated-public/EligibilitiesApi.ts
var import_sdk32 = require("@accelbyte/sdk");

// src/generated-public/endpoints/Eligibilities$.ts
var import_sdk31 = require("@accelbyte/sdk");
var Eligibilities$ = class {
  // @ts-ignore
  // prettier-ignore
  constructor(axiosInstance, namespace, useSchemaValidation = true) {
    this.axiosInstance = axiosInstance;
    this.namespace = namespace;
    this.useSchemaValidation = useSchemaValidation;
  }
  /**
   * Retrieve the active policies and its conformance status by user.&lt;br&gt;This process supports cross-namespace checking, that means if the active policy already accepted by the same user in other namespace, then it will be considered as eligible.
   */
  getEligibility_ByNamespace() {
    const params = {};
    const url = "/agreement/public/eligibilities/namespaces/{namespace}".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.get(url, { params });
    return import_sdk31.Validate.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      RetrieveUserEligibilitiesResponseArray,
      "RetrieveUserEligibilitiesResponseArray"
    );
  }
  /**
   * Retrieve the active policies and its conformance status by user.&lt;br&gt;This process only supports cross-namespace checking between game namespace and publisher namespace , that means if the active policy already accepted by the same user in publisher namespace, then it will also be considered as eligible in non-publisher namespace.
   */
  getUserEligibility_ByCountryCode_ByClientId_ByUserId(countryCode, clientId, userId) {
    const params = {};
    const url = "/agreement/public/eligibilities/namespaces/{namespace}/countries/{countryCode}/clients/{clientId}/users/{userId}".replace("{namespace}", this.namespace).replace("{countryCode}", countryCode).replace("{clientId}", clientId).replace("{userId}", userId);
    const resultPromise = this.axiosInstance.get(url, { params });
    return import_sdk31.Validate.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      RetrieveUserEligibilitiesIndirectResponse,
      "RetrieveUserEligibilitiesIndirectResponse"
    );
  }
};

// src/generated-public/EligibilitiesApi.ts
function EligibilitiesApi(sdk, args) {
  const sdkAssembly = sdk.assembly();
  const namespace = args?.coreConfig?.namespace ?? sdkAssembly.coreConfig.namespace;
  const useSchemaValidation = args?.coreConfig?.useSchemaValidation ?? sdkAssembly.coreConfig.useSchemaValidation;
  let axiosInstance = sdkAssembly.axiosInstance;
  const requestConfigOverrides = args?.axiosConfig?.request;
  const baseURLOverride = args?.coreConfig?.baseURL;
  const interceptorsOverride = args?.axiosConfig?.interceptors ?? [];
  if (requestConfigOverrides || baseURLOverride || interceptorsOverride.length > 0) {
    const requestConfig = import_sdk32.ApiUtils.mergeAxiosConfigs(sdkAssembly.axiosInstance.defaults, {
      ...baseURLOverride ? { baseURL: baseURLOverride } : {},
      ...requestConfigOverrides
    });
    axiosInstance = import_sdk32.Network.create(requestConfig);
    for (const interceptor of interceptorsOverride) {
      if (interceptor.type === "request") {
        axiosInstance.interceptors.request.use(interceptor.onRequest, interceptor.onError);
      }
      if (interceptor.type === "response") {
        axiosInstance.interceptors.response.use(interceptor.onSuccess, interceptor.onError);
      }
    }
  }
  async function getEligibility_ByNamespace() {
    const $ = new Eligibilities$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getEligibility_ByNamespace();
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getUserEligibility_ByCountryCode_ByClientId_ByUserId(countryCode, clientId, userId) {
    const $ = new Eligibilities$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getUserEligibility_ByCountryCode_ByClientId_ByUserId(countryCode, clientId, userId);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  return {
    /**
     * Retrieve the active policies and its conformance status by user.&lt;br&gt;This process supports cross-namespace checking, that means if the active policy already accepted by the same user in other namespace, then it will be considered as eligible.
     */
    getEligibility_ByNamespace,
    /**
     * Retrieve the active policies and its conformance status by user.&lt;br&gt;This process only supports cross-namespace checking between game namespace and publisher namespace , that means if the active policy already accepted by the same user in publisher namespace, then it will also be considered as eligible in non-publisher namespace.
     */
    getUserEligibility_ByCountryCode_ByClientId_ByUserId
  };
}

// src/generated-public/endpoints/LocalizedPolicyVersions$.ts
var import_sdk33 = require("@accelbyte/sdk");
var LocalizedPolicyVersions$ = class {
  // @ts-ignore
  // prettier-ignore
  constructor(axiosInstance, namespace, useSchemaValidation = true) {
    this.axiosInstance = axiosInstance;
    this.namespace = namespace;
    this.useSchemaValidation = useSchemaValidation;
  }
  /**
   * Retrieve specific localized policy version including the policy version and base policy version where the localized policy version located.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;/ul&gt;
   */
  getLocalizedPolicyVersion_ByLocalizedPolicyVersionId(localizedPolicyVersionId) {
    const params = {};
    const url = "/agreement/public/localized-policy-versions/{localizedPolicyVersionId}".replace(
      "{localizedPolicyVersionId}",
      localizedPolicyVersionId
    );
    const resultPromise = this.axiosInstance.get(url, { params });
    return import_sdk33.Validate.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      RetrieveLocalizedPolicyVersionPublicResponse,
      "RetrieveLocalizedPolicyVersionPublicResponse"
    );
  }
};

// src/generated-public/endpoints/LocalizedPolicyVersionsWithNamespace$.ts
var import_sdk34 = require("@accelbyte/sdk");
var LocalizedPolicyVersionsWithNamespace$ = class {
  // @ts-ignore
  // prettier-ignore
  constructor(axiosInstance, namespace, useSchemaValidation = true) {
    this.axiosInstance = axiosInstance;
    this.namespace = namespace;
    this.useSchemaValidation = useSchemaValidation;
  }
  /**
   * Retrieve specific localized policy version including the policy version and base policy version where the localized policy version located.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;/ul&gt;
   */
  getLocalizedPolicyVersion_ByLocalizedPolicyVersionId(localizedPolicyVersionId) {
    const params = {};
    const url = "/agreement/public/namespaces/{namespace}/localized-policy-versions/{localizedPolicyVersionId}".replace("{namespace}", this.namespace).replace("{localizedPolicyVersionId}", localizedPolicyVersionId);
    const resultPromise = this.axiosInstance.get(url, { params });
    return import_sdk34.Validate.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      RetrieveLocalizedPolicyVersionPublicResponse,
      "RetrieveLocalizedPolicyVersionPublicResponse"
    );
  }
};

// src/generated-public/endpoints/Policies$.ts
var import_sdk35 = require("@accelbyte/sdk");
var import_zod67 = require("zod");
var Policies$ = class {
  // @ts-ignore
  // prettier-ignore
  constructor(axiosInstance, namespace, useSchemaValidation = true) {
    this.axiosInstance = axiosInstance;
    this.namespace = namespace;
    this.useSchemaValidation = useSchemaValidation;
  }
  /**
   * Retrieve List of Countries that have Active and Visible Legal Policies.
   */
  getPoliciesCountriesList() {
    const params = {};
    const url = "/agreement/public/policies/countries/list";
    const resultPromise = this.axiosInstance.get(url, { params });
    return import_sdk35.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, import_zod67.z.unknown(), "z.unknown()");
  }
  /**
   * Retrieve all active latest policies based on a namespace and country. The country will be read from user token.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Leave the policyType empty if you want to be responded with all policy type&lt;/i&gt;&lt;/li&gt;&lt;li&gt;&lt;i&gt;Fill the tags if you want to filter the responded policy by tags&lt;/i&gt;&lt;/li&gt;&lt;li&gt;&lt;i&gt;Fill the defaultOnEmpty with true if you want to be responded with default country-specific policy if your requested country is not exist&lt;/i&gt;&lt;/li&gt;&lt;li&gt;&lt;i&gt;Fill the alwaysIncludeDefault with true if you want to be responded with always include default policy. If there are duplicate policies (default policies and country specific policies with same base policy) it&#39;ll include policy with same country code, for example:&lt;ul&gt;&lt;li&gt;Document 1 (default): Region US (default), UA&lt;/li&gt;&lt;li&gt;Document 2 (default): Region US (default)&lt;/li&gt;&lt;li&gt;Document 3 (default): Region US (default)&lt;/li&gt;&lt;li&gt;User: Region UA&lt;/li&gt;&lt;li&gt;Query: alwaysIncludeDefault: true&lt;/li&gt;&lt;li&gt;Response: Document 1 (UA), Document 2 (US), Document 3 (US)&lt;/li&gt;&lt;/ul&gt;&lt;/i&gt;&lt;/li&gt;&lt;/ul&gt;
   */
  getPolicy_ByNamespace(queryParams) {
    const params = { ...queryParams };
    const url = "/agreement/public/policies/namespaces/{namespace}".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.get(url, { params });
    return import_sdk35.Validate.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      RetrievePolicyPublicResponseArray,
      "RetrievePolicyPublicResponseArray"
    );
  }
  /**
   * Retrieve all active latest policies based on a country.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Leave the policyType empty if you want to be responded with all policy type&lt;/i&gt;&lt;/li&gt;&lt;li&gt;&lt;i&gt;Fill the tags if you want to filter the responded policy by tags&lt;/i&gt;&lt;/li&gt;&lt;li&gt;&lt;i&gt;Fill the defaultOnEmpty with true if you want to be responded with default country-specific policy if your requested country is not exist&lt;/i&gt;&lt;/li&gt;&lt;/ul&gt;
   */
  getPolicyCountry_ByCountryCode(countryCode, queryParams) {
    const params = { ...queryParams };
    const url = "/agreement/public/policies/countries/{countryCode}".replace("{countryCode}", countryCode);
    const resultPromise = this.axiosInstance.get(url, { params });
    return import_sdk35.Validate.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      RetrievePolicyPublicResponseArray,
      "RetrievePolicyPublicResponseArray"
    );
  }
  /**
   * Retrieve all active latest policies based on a namespace and country.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Leave the policyType empty if you want to be responded with all policy type&lt;/i&gt;&lt;/li&gt;&lt;li&gt;&lt;i&gt;Fill the tags if you want to filter the responded policy by tags&lt;/i&gt;&lt;/li&gt;&lt;li&gt;&lt;i&gt;Fill the defaultOnEmpty with true if you want to be responded with default country-specific policy if your requested country is not exist&lt;/i&gt;&lt;/li&gt;&lt;li&gt;&lt;i&gt;Fill the alwaysIncludeDefault with true if you want to be responded with always include default policy. If there are duplicate policies (default policies and country specific policies with same base policy) it&#39;ll include policy with same country code, for example:&lt;ul&gt;&lt;li&gt;Document 1 (default): Region US (default), UA&lt;/li&gt;&lt;li&gt;Document 2 (default): Region US (default)&lt;/li&gt;&lt;li&gt;Document 3 (default): Region US (default)&lt;/li&gt;&lt;li&gt;User: Region UA&lt;/li&gt;&lt;li&gt;Query: alwaysIncludeDefault: true&lt;/li&gt;&lt;li&gt;Response: Document 1 (UA), Document 2 (US), Document 3 (US)&lt;/li&gt;&lt;/ul&gt;
   */
  getPolicyCountry_ByCountryCode_ByNS(countryCode, queryParams) {
    const params = { ...queryParams };
    const url = "/agreement/public/policies/namespaces/{namespace}/countries/{countryCode}".replace("{namespace}", this.namespace).replace("{countryCode}", countryCode);
    const resultPromise = this.axiosInstance.get(url, { params });
    return import_sdk35.Validate.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      RetrievePolicyPublicResponseArray,
      "RetrievePolicyPublicResponseArray"
    );
  }
};

// src/generated-public/endpoints/Utility$.ts
var import_sdk36 = require("@accelbyte/sdk");
var Utility$ = class {
  // @ts-ignore
  // prettier-ignore
  constructor(axiosInstance, namespace, useSchemaValidation = true) {
    this.axiosInstance = axiosInstance;
    this.namespace = namespace;
    this.useSchemaValidation = useSchemaValidation;
  }
  /**
   * Readiness status defined as at least one legal basePolicy is present and having active basePolicy.
   */
  getReadiness() {
    const params = {};
    const url = "/agreement/public/readiness";
    const resultPromise = this.axiosInstance.get(url, { params });
    return import_sdk36.Validate.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      LegalReadinessStatusResponse,
      "LegalReadinessStatusResponse"
    );
  }
};

// src/generated-public/LocalizedPolicyVersionsApi.ts
var import_sdk37 = require("@accelbyte/sdk");
function LocalizedPolicyVersionsApi(sdk, args) {
  const sdkAssembly = sdk.assembly();
  const namespace = args?.coreConfig?.namespace ?? sdkAssembly.coreConfig.namespace;
  const useSchemaValidation = args?.coreConfig?.useSchemaValidation ?? sdkAssembly.coreConfig.useSchemaValidation;
  let axiosInstance = sdkAssembly.axiosInstance;
  const requestConfigOverrides = args?.axiosConfig?.request;
  const baseURLOverride = args?.coreConfig?.baseURL;
  const interceptorsOverride = args?.axiosConfig?.interceptors ?? [];
  if (requestConfigOverrides || baseURLOverride || interceptorsOverride.length > 0) {
    const requestConfig = import_sdk37.ApiUtils.mergeAxiosConfigs(sdkAssembly.axiosInstance.defaults, {
      ...baseURLOverride ? { baseURL: baseURLOverride } : {},
      ...requestConfigOverrides
    });
    axiosInstance = import_sdk37.Network.create(requestConfig);
    for (const interceptor of interceptorsOverride) {
      if (interceptor.type === "request") {
        axiosInstance.interceptors.request.use(interceptor.onRequest, interceptor.onError);
      }
      if (interceptor.type === "response") {
        axiosInstance.interceptors.response.use(interceptor.onSuccess, interceptor.onError);
      }
    }
  }
  async function getLocalizedPolicyVersion_ByLocalizedPolicyVersionId(localizedPolicyVersionId) {
    const $ = new LocalizedPolicyVersions$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getLocalizedPolicyVersion_ByLocalizedPolicyVersionId(localizedPolicyVersionId);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  return {
    /**
     * Retrieve specific localized policy version including the policy version and base policy version where the localized policy version located.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;/ul&gt;
     */
    getLocalizedPolicyVersion_ByLocalizedPolicyVersionId
  };
}

// src/generated-public/LocalizedPolicyVersionsWithNamespaceApi.ts
var import_sdk38 = require("@accelbyte/sdk");
function LocalizedPolicyVersionsWithNamespaceApi(sdk, args) {
  const sdkAssembly = sdk.assembly();
  const namespace = args?.coreConfig?.namespace ?? sdkAssembly.coreConfig.namespace;
  const useSchemaValidation = args?.coreConfig?.useSchemaValidation ?? sdkAssembly.coreConfig.useSchemaValidation;
  let axiosInstance = sdkAssembly.axiosInstance;
  const requestConfigOverrides = args?.axiosConfig?.request;
  const baseURLOverride = args?.coreConfig?.baseURL;
  const interceptorsOverride = args?.axiosConfig?.interceptors ?? [];
  if (requestConfigOverrides || baseURLOverride || interceptorsOverride.length > 0) {
    const requestConfig = import_sdk38.ApiUtils.mergeAxiosConfigs(sdkAssembly.axiosInstance.defaults, {
      ...baseURLOverride ? { baseURL: baseURLOverride } : {},
      ...requestConfigOverrides
    });
    axiosInstance = import_sdk38.Network.create(requestConfig);
    for (const interceptor of interceptorsOverride) {
      if (interceptor.type === "request") {
        axiosInstance.interceptors.request.use(interceptor.onRequest, interceptor.onError);
      }
      if (interceptor.type === "response") {
        axiosInstance.interceptors.response.use(interceptor.onSuccess, interceptor.onError);
      }
    }
  }
  async function getLocalizedPolicyVersion_ByLocalizedPolicyVersionId(localizedPolicyVersionId) {
    const $ = new LocalizedPolicyVersionsWithNamespace$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getLocalizedPolicyVersion_ByLocalizedPolicyVersionId(localizedPolicyVersionId);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  return {
    /**
     * Retrieve specific localized policy version including the policy version and base policy version where the localized policy version located.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;/ul&gt;
     */
    getLocalizedPolicyVersion_ByLocalizedPolicyVersionId
  };
}

// src/generated-public/PoliciesApi.ts
var import_sdk39 = require("@accelbyte/sdk");
function PoliciesApi(sdk, args) {
  const sdkAssembly = sdk.assembly();
  const namespace = args?.coreConfig?.namespace ?? sdkAssembly.coreConfig.namespace;
  const useSchemaValidation = args?.coreConfig?.useSchemaValidation ?? sdkAssembly.coreConfig.useSchemaValidation;
  let axiosInstance = sdkAssembly.axiosInstance;
  const requestConfigOverrides = args?.axiosConfig?.request;
  const baseURLOverride = args?.coreConfig?.baseURL;
  const interceptorsOverride = args?.axiosConfig?.interceptors ?? [];
  if (requestConfigOverrides || baseURLOverride || interceptorsOverride.length > 0) {
    const requestConfig = import_sdk39.ApiUtils.mergeAxiosConfigs(sdkAssembly.axiosInstance.defaults, {
      ...baseURLOverride ? { baseURL: baseURLOverride } : {},
      ...requestConfigOverrides
    });
    axiosInstance = import_sdk39.Network.create(requestConfig);
    for (const interceptor of interceptorsOverride) {
      if (interceptor.type === "request") {
        axiosInstance.interceptors.request.use(interceptor.onRequest, interceptor.onError);
      }
      if (interceptor.type === "response") {
        axiosInstance.interceptors.response.use(interceptor.onSuccess, interceptor.onError);
      }
    }
  }
  async function getPoliciesCountriesList() {
    const $ = new Policies$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getPoliciesCountriesList();
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getPolicy_ByNamespace(queryParams) {
    const $ = new Policies$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getPolicy_ByNamespace(queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getPolicyCountry_ByCountryCode(countryCode, queryParams) {
    const $ = new Policies$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getPolicyCountry_ByCountryCode(countryCode, queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getPolicyCountry_ByCountryCode_ByNS(countryCode, queryParams) {
    const $ = new Policies$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getPolicyCountry_ByCountryCode_ByNS(countryCode, queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  return {
    /**
     * Retrieve List of Countries that have Active and Visible Legal Policies.
     */
    getPoliciesCountriesList,
    /**
     * Retrieve all active latest policies based on a namespace and country. The country will be read from user token.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Leave the policyType empty if you want to be responded with all policy type&lt;/i&gt;&lt;/li&gt;&lt;li&gt;&lt;i&gt;Fill the tags if you want to filter the responded policy by tags&lt;/i&gt;&lt;/li&gt;&lt;li&gt;&lt;i&gt;Fill the defaultOnEmpty with true if you want to be responded with default country-specific policy if your requested country is not exist&lt;/i&gt;&lt;/li&gt;&lt;li&gt;&lt;i&gt;Fill the alwaysIncludeDefault with true if you want to be responded with always include default policy. If there are duplicate policies (default policies and country specific policies with same base policy) it&#39;ll include policy with same country code, for example:&lt;ul&gt;&lt;li&gt;Document 1 (default): Region US (default), UA&lt;/li&gt;&lt;li&gt;Document 2 (default): Region US (default)&lt;/li&gt;&lt;li&gt;Document 3 (default): Region US (default)&lt;/li&gt;&lt;li&gt;User: Region UA&lt;/li&gt;&lt;li&gt;Query: alwaysIncludeDefault: true&lt;/li&gt;&lt;li&gt;Response: Document 1 (UA), Document 2 (US), Document 3 (US)&lt;/li&gt;&lt;/ul&gt;&lt;/i&gt;&lt;/li&gt;&lt;/ul&gt;
     */
    getPolicy_ByNamespace,
    /**
     * Retrieve all active latest policies based on a country.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Leave the policyType empty if you want to be responded with all policy type&lt;/i&gt;&lt;/li&gt;&lt;li&gt;&lt;i&gt;Fill the tags if you want to filter the responded policy by tags&lt;/i&gt;&lt;/li&gt;&lt;li&gt;&lt;i&gt;Fill the defaultOnEmpty with true if you want to be responded with default country-specific policy if your requested country is not exist&lt;/i&gt;&lt;/li&gt;&lt;/ul&gt;
     */
    getPolicyCountry_ByCountryCode,
    /**
     * Retrieve all active latest policies based on a namespace and country.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Leave the policyType empty if you want to be responded with all policy type&lt;/i&gt;&lt;/li&gt;&lt;li&gt;&lt;i&gt;Fill the tags if you want to filter the responded policy by tags&lt;/i&gt;&lt;/li&gt;&lt;li&gt;&lt;i&gt;Fill the defaultOnEmpty with true if you want to be responded with default country-specific policy if your requested country is not exist&lt;/i&gt;&lt;/li&gt;&lt;li&gt;&lt;i&gt;Fill the alwaysIncludeDefault with true if you want to be responded with always include default policy. If there are duplicate policies (default policies and country specific policies with same base policy) it&#39;ll include policy with same country code, for example:&lt;ul&gt;&lt;li&gt;Document 1 (default): Region US (default), UA&lt;/li&gt;&lt;li&gt;Document 2 (default): Region US (default)&lt;/li&gt;&lt;li&gt;Document 3 (default): Region US (default)&lt;/li&gt;&lt;li&gt;User: Region UA&lt;/li&gt;&lt;li&gt;Query: alwaysIncludeDefault: true&lt;/li&gt;&lt;li&gt;Response: Document 1 (UA), Document 2 (US), Document 3 (US)&lt;/li&gt;&lt;/ul&gt;
     */
    getPolicyCountry_ByCountryCode_ByNS
  };
}

// src/generated-public/UtilityApi.ts
var import_sdk40 = require("@accelbyte/sdk");
function UtilityApi(sdk, args) {
  const sdkAssembly = sdk.assembly();
  const namespace = args?.coreConfig?.namespace ?? sdkAssembly.coreConfig.namespace;
  const useSchemaValidation = args?.coreConfig?.useSchemaValidation ?? sdkAssembly.coreConfig.useSchemaValidation;
  let axiosInstance = sdkAssembly.axiosInstance;
  const requestConfigOverrides = args?.axiosConfig?.request;
  const baseURLOverride = args?.coreConfig?.baseURL;
  const interceptorsOverride = args?.axiosConfig?.interceptors ?? [];
  if (requestConfigOverrides || baseURLOverride || interceptorsOverride.length > 0) {
    const requestConfig = import_sdk40.ApiUtils.mergeAxiosConfigs(sdkAssembly.axiosInstance.defaults, {
      ...baseURLOverride ? { baseURL: baseURLOverride } : {},
      ...requestConfigOverrides
    });
    axiosInstance = import_sdk40.Network.create(requestConfig);
    for (const interceptor of interceptorsOverride) {
      if (interceptor.type === "request") {
        axiosInstance.interceptors.request.use(interceptor.onRequest, interceptor.onError);
      }
      if (interceptor.type === "response") {
        axiosInstance.interceptors.response.use(interceptor.onSuccess, interceptor.onError);
      }
    }
  }
  async function getReadiness() {
    const $ = new Utility$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getReadiness();
    if (resp.error) throw resp.error;
    return resp.response;
  }
  return {
    /**
     * Readiness status defined as at least one legal basePolicy is present and having active basePolicy.
     */
    getReadiness
  };
}

// package.json
var name = "@accelbyte/sdk-legal";
var version = "6.0.0";
var author = "AccelByte Inc";

// src/Legal.ts
console.log(`${name}@${version}`);
var apis = {
  UserInfoAdminApi,
  BaseLegalPoliciesAdminApi,
  PoliciesAdminApi,
  PolicyVersionsAdminApi,
  AgreementAdminApi,
  AgreementWithNamespaceAdminApi,
  BaseLegalPoliciesWithNamespaceAdminApi,
  AnonymizationAdminApi,
  PoliciesWithNamespaceAdminApi,
  PolicyVersionsWithNamespaceAdminApi,
  UserEligibilitiesAdminApi,
  LocalizedPolicyVersionsAdminApi,
  UserAgreementAdminApi,
  LocalizedPolicyVersionsWithNamespaceAdminApi,
  UtilityApi,
  AgreementApi,
  PoliciesApi,
  EligibilitiesApi,
  LocalizedPolicyVersionsApi,
  LocalizedPolicyVersionsWithNamespaceApi,
  version: () => console.log({
    version,
    name,
    author
  })
};
var Legal = apis;

// src/custom/clients/LegalHelper.ts
var import_sdk41 = require("@accelbyte/sdk");
var import_dompurify = __toESM(require("dompurify"), 1);
var import_isURL = __toESM(require("validator/lib/isURL.js"), 1);
var _LegalHelper = class _LegalHelper {
  static convertPoliciesToDisplayedPolicies(policies, namespace) {
    const displayedPolicies = [];
    for (const policy of policies) {
      if (policy.namespace === namespace && policy.policyVersions?.length) {
        const policyVersion = policy.policyVersions[0];
        if (policyVersion.localizedPolicyVersions?.length) {
          const localizedPolicyVersion = policyVersion.localizedPolicyVersions.find((localization) => localization.isDefaultSelection);
          if (localizedPolicyVersion) {
            displayedPolicies.push({
              policyName: policy.policyName,
              policyId: policy.id,
              policyVersionId: policyVersion.id,
              localizedPolicyVersionId: localizedPolicyVersion.id,
              isMandatory: policy.isMandatory,
              description: policy.description,
              policyType: policy.policyType
            });
          }
        }
      }
    }
    return displayedPolicies;
  }
  static createLegalURL({ legalBaseUrl, policyId, languageId }) {
    if (!legalBaseUrl) return `${languageId ? `/${languageId}` : ""}/legal${policyId ? `/${policyId}` : ""}`;
    if ((0, import_isURL.default)(legalBaseUrl)) {
      const { origin, pathname } = new URL(legalBaseUrl);
      const legalUrl = import_sdk41.UrlHelper.combineURLPaths(origin, languageId || "", pathname);
      return import_sdk41.UrlHelper.combineURLPaths(legalUrl, policyId || "");
    }
    return import_sdk41.UrlHelper.combinePaths(legalBaseUrl, policyId || "");
  }
  static getAcceptedPolicies(eligibilities) {
    const acceptedPolicies = [];
    for (const legalEligibility of eligibilities) {
      if (legalEligibility.policyVersions) {
        for (const policyVersion of legalEligibility.policyVersions) {
          if (policyVersion.localizedPolicyVersions) {
            for (const localizedPolicyVersion of policyVersion.localizedPolicyVersions) {
              acceptedPolicies.push({
                policyId: legalEligibility.policyId,
                policyVersionId: policyVersion.id,
                localizedPolicyVersionId: localizedPolicyVersion.id,
                isAccepted: true
              });
            }
          }
        }
      }
    }
    return acceptedPolicies;
  }
};
_LegalHelper.getUnsignedPolicies = (userEligibilities) => {
  const legals = [];
  for (const legal of userEligibilities) {
    const policyVersions = _LegalHelper.getDefaultLocalizedPolicy(legal);
    if (!legal.isAccepted && legal.isMandatory && policyVersions.length > 0) {
      legals.push({ ...legal, policyVersions });
    }
  }
  return legals;
};
_LegalHelper.currentUserIsBlockedByLegal = (eligibilities) => {
  return eligibilities ? eligibilities.length > 0 : false;
};
_LegalHelper.getDefaultLocalizedPolicy = (legalEligibility) => {
  const lastVersions = legalEligibility.policyVersions?.slice(0, 1) || [];
  let localizedPolicyVersions = lastVersions[0].localizedPolicyVersions || [];
  localizedPolicyVersions = localizedPolicyVersions.filter((item) => item.isDefaultSelection);
  if (localizedPolicyVersions.length === 0) return [];
  lastVersions[0].localizedPolicyVersions = localizedPolicyVersions;
  return lastVersions;
};
_LegalHelper.sanitizeHTML = (document) => {
  const domPurifyOption = {
    WHOLE_DOCUMENT: true,
    ADD_TAGS: ["head", "meta", "link"],
    ADD_ATTR: ["content", "property", "http-equiv", "charset", "target"]
  };
  const sanitizedHTML = import_dompurify.default.sanitize(document, domPurifyOption);
  return sanitizedHTML;
};
var LegalHelper = _LegalHelper;

// src/custom/models/Legal.ts
var import_zod68 = require("zod");
var DisplayedPolicy = import_zod68.z.object({
  policyName: import_zod68.z.string(),
  policyId: import_zod68.z.string(),
  policyVersionId: import_zod68.z.string(),
  localizedPolicyVersionId: import_zod68.z.string(),
  isMandatory: import_zod68.z.boolean(),
  description: import_zod68.z.string().nullish(),
  policyType: import_zod68.z.string().optional()
});
var LegalPolicyType = {
  LEGAL_DOCUMENT: "Legal Document",
  MARKETING_PREFERENCE: "Marketing Preference"
};
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  AcceptAgreementRequest,
  AcceptAgreementResponse,
  Agreement$,
  AgreementAdmin$,
  AgreementAdminApi,
  AgreementApi,
  AgreementWithNamespaceAdmin$,
  AgreementWithNamespaceAdminApi,
  AnonymizationAdmin$,
  AnonymizationAdminApi,
  BaseLegalPoliciesAdmin$,
  BaseLegalPoliciesAdminApi,
  BaseLegalPoliciesWithNamespaceAdmin$,
  BaseLegalPoliciesWithNamespaceAdminApi,
  CreateBasePolicyRequest,
  CreateBasePolicyRequestV2,
  CreateBasePolicyResponse,
  CreateLocalizedPolicyVersionRequest,
  CreateLocalizedPolicyVersionResponse,
  CreatePolicyVersionRequest,
  CreatePolicyVersionResponse,
  DisplayedPolicy,
  DownloadExportedAgreementsInCsvResponse,
  Eligibilities$,
  EligibilitiesApi,
  ErrorEntity,
  FieldValidationError,
  InitiateExportAgreementsToCsvResponse,
  Legal,
  LegalHelper,
  LegalPolicyType,
  LegalReadinessStatusResponse,
  LocalizedPolicyVersionObject,
  LocalizedPolicyVersions$,
  LocalizedPolicyVersionsAdmin$,
  LocalizedPolicyVersionsAdminApi,
  LocalizedPolicyVersionsApi,
  LocalizedPolicyVersionsWithNamespace$,
  LocalizedPolicyVersionsWithNamespaceAdmin$,
  LocalizedPolicyVersionsWithNamespaceAdminApi,
  LocalizedPolicyVersionsWithNamespaceApi,
  PagedRetrieveUserAcceptedAgreementResponse,
  Paging,
  Permission,
  Policies$,
  PoliciesAdmin$,
  PoliciesAdminApi,
  PoliciesApi,
  PoliciesWithNamespaceAdmin$,
  PoliciesWithNamespaceAdminApi,
  PolicyObject,
  PolicyVersionObject,
  PolicyVersionWithLocalizedVersionObject,
  PolicyVersionsAdmin$,
  PolicyVersionsAdminApi,
  PolicyVersionsWithNamespaceAdmin$,
  PolicyVersionsWithNamespaceAdminApi,
  RetrieveAcceptedAgreementResponse,
  RetrieveAcceptedAgreementResponseArray,
  RetrieveBasePolicyResponse,
  RetrieveBasePolicyResponseArray,
  RetrieveLocalizedPolicyVersionPublicResponse,
  RetrieveLocalizedPolicyVersionResponse,
  RetrieveLocalizedPolicyVersionResponseArray,
  RetrievePolicyPublicResponse,
  RetrievePolicyPublicResponseArray,
  RetrievePolicyResponse,
  RetrievePolicyResponseArray,
  RetrievePolicyTypeResponse,
  RetrievePolicyTypeResponseArray,
  RetrievePolicyVersionResponse,
  RetrievePolicyVersionResponseArray,
  RetrieveUserAcceptedAgreementResponse,
  RetrieveUserEligibilitiesIndirectResponse,
  RetrieveUserEligibilitiesResponse,
  RetrieveUserEligibilitiesResponseArray,
  RetrieveUserInfoCacheStatusResponse,
  RetrieveUserInfoCacheStatusResponseArray,
  UpdateBasePolicyRequest,
  UpdateBasePolicyRequestV2,
  UpdateBasePolicyResponse,
  UpdateLocalizedPolicyVersionRequest,
  UpdateLocalizedPolicyVersionResponse,
  UpdatePolicyRequest,
  UpdatePolicyVersionRequest,
  UpdatePolicyVersionResponse,
  UploadLocalizedPolicyVersionAttachmentResponse,
  UploadPolicyVersionAttachmentRequest,
  UserAgreementAdmin$,
  UserAgreementAdminApi,
  UserAgreementsResponse,
  UserAgreementsResponseArray,
  UserEligibilitiesAdmin$,
  UserEligibilitiesAdminApi,
  UserInfoAdmin$,
  UserInfoAdminApi,
  UsersAgreementsRequest,
  Utility$,
  UtilityApi,
  ValidationErrorEntity
});

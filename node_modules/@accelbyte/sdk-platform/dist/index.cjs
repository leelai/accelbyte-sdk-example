"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name2 in all)
    __defProp(target, name2, { get: all[name2], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/index.ts
var src_exports = {};
__export(src_exports, {
  AchievementInfo: () => AchievementInfo,
  AchievementPlatformAdmin$: () => AchievementPlatformAdmin$,
  AchievementPlatformAdminApi: () => AchievementPlatformAdminApi,
  Action: () => Action,
  ActionRequest: () => ActionRequest,
  AdditionalData: () => AdditionalData,
  AdditionalDataEntitlement: () => AdditionalDataEntitlement,
  AdminEntitlementDecrement: () => AdminEntitlementDecrement,
  AdminEntitlementSoldRequest: () => AdminEntitlementSoldRequest,
  AdminOrderCreate: () => AdminOrderCreate,
  AdyenConfig: () => AdyenConfig,
  AliPayConfig: () => AliPayConfig,
  AnonymizationAdmin$: () => AnonymizationAdmin$,
  AnonymizationAdminApi: () => AnonymizationAdminApi,
  AppConfig: () => AppConfig,
  AppEntitlementInfo: () => AppEntitlementInfo,
  AppEntitlementPagingSlicedResult: () => AppEntitlementPagingSlicedResult,
  AppInfo: () => AppInfo,
  AppLocalization: () => AppLocalization,
  AppUpdate: () => AppUpdate,
  AppleIapConfigInfo: () => AppleIapConfigInfo,
  AppleIapConfigRequest: () => AppleIapConfigRequest,
  AppleIapConfigVersionInfo: () => AppleIapConfigVersionInfo,
  AppleIapReceipt: () => AppleIapReceipt,
  AppleIapRequest: () => AppleIapRequest,
  AvailableComparison: () => AvailableComparison,
  AvailablePredicate: () => AvailablePredicate,
  AvailablePredicateArray: () => AvailablePredicateArray,
  AvailablePrice: () => AvailablePrice,
  BaseCustomConfig: () => BaseCustomConfig,
  BaseTlsConfig: () => BaseTlsConfig,
  BasicCategoryInfo: () => BasicCategoryInfo,
  BasicCategoryInfoArray: () => BasicCategoryInfoArray,
  BasicItem: () => BasicItem,
  BasicItemArray: () => BasicItemArray,
  BillingAccount: () => BillingAccount,
  BillingHistoryInfo: () => BillingHistoryInfo,
  BillingHistoryPagingSlicedResult: () => BillingHistoryPagingSlicedResult,
  BinarySchema: () => BinarySchema,
  BoxItem: () => BoxItem,
  BulkCreditRequest: () => BulkCreditRequest,
  BulkCreditResult: () => BulkCreditResult,
  BulkDebitRequest: () => BulkDebitRequest,
  BulkDebitResult: () => BulkDebitResult,
  BulkEntitlementGrantRequest: () => BulkEntitlementGrantRequest,
  BulkEntitlementGrantResult: () => BulkEntitlementGrantResult,
  BulkEntitlementRevokeResult: () => BulkEntitlementRevokeResult,
  BulkOperationResult: () => BulkOperationResult,
  BulkRegionDataChangeRequest: () => BulkRegionDataChangeRequest,
  BundledItemInfo: () => BundledItemInfo,
  CampaignAdmin$: () => CampaignAdmin$,
  CampaignAdminApi: () => CampaignAdminApi,
  CampaignBatchNameChange: () => CampaignBatchNameChange,
  CampaignBatchNameInfo: () => CampaignBatchNameInfo,
  CampaignBatchNameInfoArray: () => CampaignBatchNameInfoArray,
  CampaignCreate: () => CampaignCreate,
  CampaignDynamicInfo: () => CampaignDynamicInfo,
  CampaignIfc: () => CampaignIfc,
  CampaignInfo: () => CampaignInfo,
  CampaignPagingSlicedResult: () => CampaignPagingSlicedResult,
  CampaignUpdate: () => CampaignUpdate,
  CancelRequest: () => CancelRequest,
  CatalogChangeInfo: () => CatalogChangeInfo,
  CatalogChangePagingResult: () => CatalogChangePagingResult,
  CatalogChangeStatistics: () => CatalogChangeStatistics,
  CatalogChangesAdmin$: () => CatalogChangesAdmin$,
  CatalogChangesAdminApi: () => CatalogChangesAdminApi,
  CatalogConfigInfo: () => CatalogConfigInfo,
  CatalogConfigUpdate: () => CatalogConfigUpdate,
  CatalogDefinitionInfo: () => CatalogDefinitionInfo,
  CatalogDefinitionInfoArray: () => CatalogDefinitionInfoArray,
  Category$: () => Category$,
  CategoryAdmin$: () => CategoryAdmin$,
  CategoryAdminApi: () => CategoryAdminApi,
  CategoryApi: () => CategoryApi,
  CategoryCreate: () => CategoryCreate,
  CategoryInfo: () => CategoryInfo,
  CategoryInfoArray: () => CategoryInfoArray,
  CategoryUpdate: () => CategoryUpdate,
  CheckoutConfig: () => CheckoutConfig,
  ClawbackAdmin$: () => ClawbackAdmin$,
  ClawbackAdminApi: () => ClawbackAdminApi,
  ClawbackInfo: () => ClawbackInfo,
  ClientRequestParameter: () => ClientRequestParameter,
  ClientTransaction: () => ClientTransaction,
  CodeCreate: () => CodeCreate,
  CodeCreateResult: () => CodeCreateResult,
  CodeInfo: () => CodeInfo,
  CodeInfoPagingSlicedResult: () => CodeInfoPagingSlicedResult,
  ConditionGroup: () => ConditionGroup,
  ConditionGroupValidateResult: () => ConditionGroupValidateResult,
  ConditionMatchResult: () => ConditionMatchResult,
  ConsumableEntitlementRevocationConfig: () => ConsumableEntitlementRevocationConfig,
  ConsumeItem: () => ConsumeItem,
  CreditPayload: () => CreditPayload,
  CreditRequest: () => CreditRequest,
  CreditResult: () => CreditResult,
  CreditRevocation: () => CreditRevocation,
  CreditSummary: () => CreditSummary,
  Currency$: () => Currency$,
  CurrencyAdmin$: () => CurrencyAdmin$,
  CurrencyAdminApi: () => CurrencyAdminApi,
  CurrencyApi: () => CurrencyApi,
  CurrencyConfig: () => CurrencyConfig,
  CurrencyCreate: () => CurrencyCreate,
  CurrencyInfo: () => CurrencyInfo,
  CurrencyInfoArray: () => CurrencyInfoArray,
  CurrencySummary: () => CurrencySummary,
  CurrencyUpdate: () => CurrencyUpdate,
  CurrencyWallet: () => CurrencyWallet,
  CurrencyWalletArray: () => CurrencyWalletArray,
  Customization: () => Customization,
  DebitByCurrencyCodeRequest: () => DebitByCurrencyCodeRequest,
  DebitByWalletPlatformRequest: () => DebitByWalletPlatformRequest,
  DebitPayload: () => DebitPayload,
  DebitRequest: () => DebitRequest,
  DebitResult: () => DebitResult,
  DeductionDetail: () => DeductionDetail,
  DeleteRewardConditionRequest: () => DeleteRewardConditionRequest,
  DetailedWalletTransactionInfo: () => DetailedWalletTransactionInfo,
  DetailedWalletTransactionPagingSlicedResult: () => DetailedWalletTransactionPagingSlicedResult,
  DiscountCategory: () => DiscountCategory,
  DiscountCodeDeductionDetail: () => DiscountCodeDeductionDetail,
  DiscountCodeInfo: () => DiscountCodeInfo,
  DiscountConfig: () => DiscountConfig,
  DiscountItem: () => DiscountItem,
  Dlc$: () => Dlc$,
  DlcAdmin$: () => DlcAdmin$,
  DlcAdminApi: () => DlcAdminApi,
  DlcApi: () => DlcApi,
  DlcConfigRewardShortInfo: () => DlcConfigRewardShortInfo,
  DlcItem: () => DlcItem,
  DlcItemConfigInfo: () => DlcItemConfigInfo,
  DlcItemConfigUpdate: () => DlcItemConfigUpdate,
  DlcRecord: () => DlcRecord,
  DurableEntitlementRevocationConfig: () => DurableEntitlementRevocationConfig,
  Entitlement$: () => Entitlement$,
  EntitlementAdmin$: () => EntitlementAdmin$,
  EntitlementAdminApi: () => EntitlementAdminApi,
  EntitlementApi: () => EntitlementApi,
  EntitlementConfigInfo: () => EntitlementConfigInfo,
  EntitlementDecrementResult: () => EntitlementDecrementResult,
  EntitlementGrant: () => EntitlementGrant,
  EntitlementGrantResult: () => EntitlementGrantResult,
  EntitlementHistoryInfo: () => EntitlementHistoryInfo,
  EntitlementHistoryInfoArray: () => EntitlementHistoryInfoArray,
  EntitlementIfc: () => EntitlementIfc,
  EntitlementInfo: () => EntitlementInfo,
  EntitlementInfoArray: () => EntitlementInfoArray,
  EntitlementLootBoxReward: () => EntitlementLootBoxReward,
  EntitlementOriginSyncResult: () => EntitlementOriginSyncResult,
  EntitlementOwnership: () => EntitlementOwnership,
  EntitlementOwnershipArray: () => EntitlementOwnershipArray,
  EntitlementPagingSlicedResult: () => EntitlementPagingSlicedResult,
  EntitlementPlatformConfigInfo: () => EntitlementPlatformConfigInfo,
  EntitlementPlatformConfigUpdate: () => EntitlementPlatformConfigUpdate,
  EntitlementPrechekResult: () => EntitlementPrechekResult,
  EntitlementRevocation: () => EntitlementRevocation,
  EntitlementRevocationConfig: () => EntitlementRevocationConfig,
  EntitlementRevokeRequest: () => EntitlementRevokeRequest,
  EntitlementRevokeResult: () => EntitlementRevokeResult,
  EntitlementSoldRequest: () => EntitlementSoldRequest,
  EntitlementSoldResult: () => EntitlementSoldResult,
  EntitlementSplitRequest: () => EntitlementSplitRequest,
  EntitlementSplitResult: () => EntitlementSplitResult,
  EntitlementSummary: () => EntitlementSummary,
  EntitlementTransferRequest: () => EntitlementTransferRequest,
  EntitlementTransferResult: () => EntitlementTransferResult,
  EntitlementUpdate: () => EntitlementUpdate,
  EpicGamesDlcSyncRequest: () => EpicGamesDlcSyncRequest,
  EpicGamesIapConfigInfo: () => EpicGamesIapConfigInfo,
  EpicGamesIapConfigRequest: () => EpicGamesIapConfigRequest,
  EpicGamesReconcileRequest: () => EpicGamesReconcileRequest,
  EpicGamesReconcileResult: () => EpicGamesReconcileResult,
  EpicGamesReconcileResultArray: () => EpicGamesReconcileResultArray,
  ErrorEntity: () => ErrorEntity,
  EstimatedPriceInfo: () => EstimatedPriceInfo,
  EstimatedPriceInfoArray: () => EstimatedPriceInfoArray,
  EventAdditionalData: () => EventAdditionalData,
  EventPayload: () => EventPayload,
  ExportStoreRequest: () => ExportStoreRequest,
  ExportStoreToCsvRequest: () => ExportStoreToCsvRequest,
  ExtensionFulfillmentSummary: () => ExtensionFulfillmentSummary,
  ExternalPaymentOrderCreate: () => ExternalPaymentOrderCreate,
  FieldValidationError: () => FieldValidationError,
  FixedPeriodRotationConfig: () => FixedPeriodRotationConfig,
  FulFillItemPayload: () => FulFillItemPayload,
  FulfillBundledItemResult: () => FulfillBundledItemResult,
  FulfillCodeRequest: () => FulfillCodeRequest,
  FulfillItemResult: () => FulfillItemResult,
  Fulfillment$: () => Fulfillment$,
  FulfillmentActionHistory: () => FulfillmentActionHistory,
  FulfillmentAdmin$: () => FulfillmentAdmin$,
  FulfillmentAdminApi: () => FulfillmentAdminApi,
  FulfillmentApi: () => FulfillmentApi,
  FulfillmentError: () => FulfillmentError,
  FulfillmentHistoryInfo: () => FulfillmentHistoryInfo,
  FulfillmentHistoryPagingSlicedResult: () => FulfillmentHistoryPagingSlicedResult,
  FulfillmentInfo: () => FulfillmentInfo,
  FulfillmentItem: () => FulfillmentItem,
  FulfillmentItemArray: () => FulfillmentItemArray,
  FulfillmentPagingSlicedResult: () => FulfillmentPagingSlicedResult,
  FulfillmentRequest: () => FulfillmentRequest,
  FulfillmentResult: () => FulfillmentResult,
  FulfillmentScriptAdmin$: () => FulfillmentScriptAdmin$,
  FulfillmentScriptAdminApi: () => FulfillmentScriptAdminApi,
  FulfillmentScriptCreate: () => FulfillmentScriptCreate,
  FulfillmentScriptInfo: () => FulfillmentScriptInfo,
  FulfillmentScriptInfoArray: () => FulfillmentScriptInfoArray,
  FulfillmentScriptUpdate: () => FulfillmentScriptUpdate,
  FulfillmentStateInfo: () => FulfillmentStateInfo,
  FulfillmentV2Request: () => FulfillmentV2Request,
  FulfillmentV2RequestItem: () => FulfillmentV2RequestItem,
  FulfillmentV2Result: () => FulfillmentV2Result,
  FullAppInfo: () => FullAppInfo,
  FullCategoryInfo: () => FullCategoryInfo,
  FullCategoryInfoArray: () => FullCategoryInfoArray,
  FullItemInfo: () => FullItemInfo,
  FullItemInfoArray: () => FullItemInfoArray,
  FullItemPagingResult: () => FullItemPagingResult,
  FullItemPagingSlicedResult: () => FullItemPagingSlicedResult,
  FullSectionInfo: () => FullSectionInfo,
  FullViewInfo: () => FullViewInfo,
  GoogleIapConfigInfo: () => GoogleIapConfigInfo,
  GoogleIapConfigRequest: () => GoogleIapConfigRequest,
  GoogleIapReceipt: () => GoogleIapReceipt,
  GoogleReceiptResolveResult: () => GoogleReceiptResolveResult,
  GrantSubscriptionDaysRequest: () => GrantSubscriptionDaysRequest,
  GrpcServerInfo: () => GrpcServerInfo,
  HierarchicalCategoryInfo: () => HierarchicalCategoryInfo,
  HierarchicalCategoryInfoArray: () => HierarchicalCategoryInfoArray,
  Iap$: () => Iap$,
  IapAdmin$: () => IapAdmin$,
  IapAdminApi: () => IapAdminApi,
  IapApi: () => IapApi,
  IapClawbackPagingSlicedResult: () => IapClawbackPagingSlicedResult,
  IapConsumeHistoryInfo: () => IapConsumeHistoryInfo,
  IapConsumeHistoryPagingSlicedResult: () => IapConsumeHistoryPagingSlicedResult,
  IapItemConfigInfo: () => IapItemConfigInfo,
  IapItemConfigUpdate: () => IapItemConfigUpdate,
  IapItemEntry: () => IapItemEntry,
  IapItemFlatEntry: () => IapItemFlatEntry,
  IapItemMappingInfo: () => IapItemMappingInfo,
  IapNotificationAdmin$: () => IapNotificationAdmin$,
  IapNotificationAdminApi: () => IapNotificationAdminApi,
  IapOrderInfo: () => IapOrderInfo,
  IapOrderPagingSlicedResult: () => IapOrderPagingSlicedResult,
  IapSubscription$: () => IapSubscription$,
  IapSubscriptionAdmin$: () => IapSubscriptionAdmin$,
  IapSubscriptionAdminApi: () => IapSubscriptionAdminApi,
  IapSubscriptionApi: () => IapSubscriptionApi,
  Image: () => Image,
  ImportErrorDetails: () => ImportErrorDetails,
  ImportStoreAppInfo: () => ImportStoreAppInfo,
  ImportStoreCategoryInfo: () => ImportStoreCategoryInfo,
  ImportStoreError: () => ImportStoreError,
  ImportStoreHistoryInfo: () => ImportStoreHistoryInfo,
  ImportStoreHistoryPagingResult: () => ImportStoreHistoryPagingResult,
  ImportStoreItemInfo: () => ImportStoreItemInfo,
  ImportStoreResult: () => ImportStoreResult,
  ImportStoreSectionInfo: () => ImportStoreSectionInfo,
  ImportStoreViewInfo: () => ImportStoreViewInfo,
  InGameItemSync: () => InGameItemSync,
  InventoryConfig: () => InventoryConfig,
  InvoiceAdmin$: () => InvoiceAdmin$,
  InvoiceAdminApi: () => InvoiceAdminApi,
  InvoiceCurrencySummary: () => InvoiceCurrencySummary,
  InvoiceSummary: () => InvoiceSummary,
  Item$: () => Item$,
  ItemAcquireRequest: () => ItemAcquireRequest,
  ItemAcquireResult: () => ItemAcquireResult,
  ItemAdmin$: () => ItemAdmin$,
  ItemAdminApi: () => ItemAdminApi,
  ItemApi: () => ItemApi,
  ItemCreate: () => ItemCreate,
  ItemDynamicDataInfo: () => ItemDynamicDataInfo,
  ItemId: () => ItemId,
  ItemIdArray: () => ItemIdArray,
  ItemInfo: () => ItemInfo,
  ItemInfoArray: () => ItemInfoArray,
  ItemNaming: () => ItemNaming,
  ItemPagingSlicedResult: () => ItemPagingSlicedResult,
  ItemPurchaseConditionValidateRequest: () => ItemPurchaseConditionValidateRequest,
  ItemPurchaseConditionValidateResult: () => ItemPurchaseConditionValidateResult,
  ItemPurchaseConditionValidateResultArray: () => ItemPurchaseConditionValidateResultArray,
  ItemReturnRequest: () => ItemReturnRequest,
  ItemRevocation: () => ItemRevocation,
  ItemSnapshot: () => ItemSnapshot,
  ItemTypeConfigCreate: () => ItemTypeConfigCreate,
  ItemTypeConfigInfo: () => ItemTypeConfigInfo,
  ItemTypeConfigInfoArray: () => ItemTypeConfigInfoArray,
  ItemTypeConfigUpdate: () => ItemTypeConfigUpdate,
  ItemUpdate: () => ItemUpdate,
  KeyGroupAdmin$: () => KeyGroupAdmin$,
  KeyGroupAdminApi: () => KeyGroupAdminApi,
  KeyGroupCreate: () => KeyGroupCreate,
  KeyGroupDynamicInfo: () => KeyGroupDynamicInfo,
  KeyGroupInfo: () => KeyGroupInfo,
  KeyGroupPagingSlicedResult: () => KeyGroupPagingSlicedResult,
  KeyGroupUpdate: () => KeyGroupUpdate,
  KeyInfo: () => KeyInfo,
  KeyPagingSliceResult: () => KeyPagingSliceResult,
  ListViewInfo: () => ListViewInfo,
  ListViewInfoArray: () => ListViewInfoArray,
  Localization: () => Localization,
  LootBoxConfig: () => LootBoxConfig,
  LootBoxPluginConfigInfo: () => LootBoxPluginConfigInfo,
  LootBoxPluginConfigUpdate: () => LootBoxPluginConfigUpdate,
  LootBoxReward: () => LootBoxReward,
  MockIapReceipt: () => MockIapReceipt,
  NeonPayConfig: () => NeonPayConfig,
  NotificationPagingSlicedResult: () => NotificationPagingSlicedResult,
  NotificationProcessResult: () => NotificationProcessResult,
  OculusIapConfigInfo: () => OculusIapConfigInfo,
  OculusIapConfigRequest: () => OculusIapConfigRequest,
  OculusReconcileResult: () => OculusReconcileResult,
  OculusReconcileResultArray: () => OculusReconcileResultArray,
  Operation: () => Operation,
  OperationRequest: () => OperationRequest,
  OptionBoxConfig: () => OptionBoxConfig,
  Order: () => Order,
  Order$: () => Order$,
  OrderAdmin$: () => OrderAdmin$,
  OrderAdminApi: () => OrderAdminApi,
  OrderApi: () => OrderApi,
  OrderBundleItemInfo: () => OrderBundleItemInfo,
  OrderCreate: () => OrderCreate,
  OrderCreationOptions: () => OrderCreationOptions,
  OrderDedicatedAdmin$: () => OrderDedicatedAdmin$,
  OrderDedicatedAdminApi: () => OrderDedicatedAdminApi,
  OrderDiscountPreviewRequest: () => OrderDiscountPreviewRequest,
  OrderDiscountPreviewResponse: () => OrderDiscountPreviewResponse,
  OrderGrantInfo: () => OrderGrantInfo,
  OrderHistoryInfo: () => OrderHistoryInfo,
  OrderHistoryInfoArray: () => OrderHistoryInfoArray,
  OrderInfo: () => OrderInfo,
  OrderPagingResult: () => OrderPagingResult,
  OrderPagingSlicedResult: () => OrderPagingSlicedResult,
  OrderRefundCreate: () => OrderRefundCreate,
  OrderStatistics: () => OrderStatistics,
  OrderStatus: () => OrderStatus,
  OrderSummary: () => OrderSummary,
  OrderSyncResult: () => OrderSyncResult,
  OrderUpdate: () => OrderUpdate,
  Ownership: () => Ownership,
  OwnershipToken: () => OwnershipToken,
  Paging: () => Paging,
  PayPalConfig: () => PayPalConfig,
  PaymentAccount: () => PaymentAccount,
  PaymentAccount$: () => PaymentAccount$,
  PaymentAccountApi: () => PaymentAccountApi,
  PaymentAccountArray: () => PaymentAccountArray,
  PaymentAdmin$: () => PaymentAdmin$,
  PaymentAdminApi: () => PaymentAdminApi,
  PaymentCallbackConfigAdmin$: () => PaymentCallbackConfigAdmin$,
  PaymentCallbackConfigAdminApi: () => PaymentCallbackConfigAdminApi,
  PaymentCallbackConfigInfo: () => PaymentCallbackConfigInfo,
  PaymentCallbackConfigUpdate: () => PaymentCallbackConfigUpdate,
  PaymentConfigAdmin$: () => PaymentConfigAdmin$,
  PaymentConfigAdminApi: () => PaymentConfigAdminApi,
  PaymentData: () => PaymentData,
  PaymentDedicatedAdmin$: () => PaymentDedicatedAdmin$,
  PaymentDedicatedAdminApi: () => PaymentDedicatedAdminApi,
  PaymentDomainWhitelistConfigEdit: () => PaymentDomainWhitelistConfigEdit,
  PaymentDomainWhitelistConfigInfo: () => PaymentDomainWhitelistConfigInfo,
  PaymentMerchantConfigInfo: () => PaymentMerchantConfigInfo,
  PaymentMethod: () => PaymentMethod,
  PaymentMethodArray: () => PaymentMethodArray,
  PaymentNotificationInfo: () => PaymentNotificationInfo,
  PaymentNotificationPagingSlicedResult: () => PaymentNotificationPagingSlicedResult,
  PaymentOrder: () => PaymentOrder,
  PaymentOrderChargeRequest: () => PaymentOrderChargeRequest,
  PaymentOrderChargeStatus: () => PaymentOrderChargeStatus,
  PaymentOrderCreate: () => PaymentOrderCreate,
  PaymentOrderCreateResult: () => PaymentOrderCreateResult,
  PaymentOrderDetails: () => PaymentOrderDetails,
  PaymentOrderInfo: () => PaymentOrderInfo,
  PaymentOrderNeonPayConfig: () => PaymentOrderNeonPayConfig,
  PaymentOrderNotifySimulation: () => PaymentOrderNotifySimulation,
  PaymentOrderPagingSlicedResult: () => PaymentOrderPagingSlicedResult,
  PaymentOrderPaidResult: () => PaymentOrderPaidResult,
  PaymentOrderRefund: () => PaymentOrderRefund,
  PaymentOrderRefundResult: () => PaymentOrderRefundResult,
  PaymentOrderSyncResult: () => PaymentOrderSyncResult,
  PaymentProcessResult: () => PaymentProcessResult,
  PaymentProviderConfigEdit: () => PaymentProviderConfigEdit,
  PaymentProviderConfigInfo: () => PaymentProviderConfigInfo,
  PaymentProviderConfigPagingSlicedResult: () => PaymentProviderConfigPagingSlicedResult,
  PaymentRequest: () => PaymentRequest,
  PaymentStation$: () => PaymentStation$,
  PaymentStationApi: () => PaymentStationApi,
  PaymentTaxConfigEdit: () => PaymentTaxConfigEdit,
  PaymentTaxConfigInfo: () => PaymentTaxConfigInfo,
  PaymentToken: () => PaymentToken,
  PaymentUrl: () => PaymentUrl,
  PaymentUrlCreate: () => PaymentUrlCreate,
  Permission: () => Permission,
  Platform: () => Platform,
  PlatformAccountClosureAdmin$: () => PlatformAccountClosureAdmin$,
  PlatformAccountClosureAdminApi: () => PlatformAccountClosureAdminApi,
  PlatformAccountClosureHistoryInfo: () => PlatformAccountClosureHistoryInfo,
  PlatformAccountClosureHistoryInfoArray: () => PlatformAccountClosureHistoryInfoArray,
  PlatformAdmin$: () => PlatformAdmin$,
  PlatformAdminApi: () => PlatformAdminApi,
  PlatformClient: () => PlatformClient,
  PlatformDlcConfigInfo: () => PlatformDlcConfigInfo,
  PlatformDlcConfigUpdate: () => PlatformDlcConfigUpdate,
  PlatformDlcEntry: () => PlatformDlcEntry,
  PlatformOwnership: () => PlatformOwnership,
  PlatformReward: () => PlatformReward,
  PlatformRewardCurrency: () => PlatformRewardCurrency,
  PlatformRewardItem: () => PlatformRewardItem,
  PlatformSubscribeRequest: () => PlatformSubscribeRequest,
  PlatformWallet: () => PlatformWallet,
  PlatformWalletConfigInfo: () => PlatformWalletConfigInfo,
  PlatformWalletConfigUpdate: () => PlatformWalletConfigUpdate,
  PlayStationDlcSyncMultiServiceLabelsRequest: () => PlayStationDlcSyncMultiServiceLabelsRequest,
  PlayStationDlcSyncRequest: () => PlayStationDlcSyncRequest,
  PlayStationIapConfigInfo: () => PlayStationIapConfigInfo,
  PlayStationMultiServiceLabelsReconcileRequest: () => PlayStationMultiServiceLabelsReconcileRequest,
  PlayStationReconcileRequest: () => PlayStationReconcileRequest,
  PlayStationReconcileResult: () => PlayStationReconcileResult,
  PlayStationReconcileResultArray: () => PlayStationReconcileResultArray,
  PlaystationIapConfigRequest: () => PlaystationIapConfigRequest,
  PopulatedItemInfo: () => PopulatedItemInfo,
  PreCheckFulfillmentRequest: () => PreCheckFulfillmentRequest,
  Predicate: () => Predicate,
  PredicateValidateResult: () => PredicateValidateResult,
  PsnEntitlementOwnershipRequest: () => PsnEntitlementOwnershipRequest,
  PublicCustomConfigInfo: () => PublicCustomConfigInfo,
  PublicEntitlementDecrement: () => PublicEntitlementDecrement,
  PublicEntitlementHistoryInfo: () => PublicEntitlementHistoryInfo,
  PublicEntitlementMetadata: () => PublicEntitlementMetadata,
  PurchaseCondition: () => PurchaseCondition,
  PurchaseConditionUpdate: () => PurchaseConditionUpdate,
  PurchasedItemCount: () => PurchasedItemCount,
  Recurring: () => Recurring,
  RecurringChargeResult: () => RecurringChargeResult,
  RedeemHistoryInfo: () => RedeemHistoryInfo,
  RedeemHistoryPagingSlicedResult: () => RedeemHistoryPagingSlicedResult,
  RedeemRequest: () => RedeemRequest,
  RedeemResult: () => RedeemResult,
  RedeemableItem: () => RedeemableItem,
  RegionDataChange: () => RegionDataChange,
  RegionDataItem: () => RegionDataItem,
  RegionDataItemDto: () => RegionDataItemDto,
  RequestHistory: () => RequestHistory,
  Requirement: () => Requirement,
  RevocationAdmin$: () => RevocationAdmin$,
  RevocationAdminApi: () => RevocationAdminApi,
  RevocationConfigInfo: () => RevocationConfigInfo,
  RevocationConfigUpdate: () => RevocationConfigUpdate,
  RevocationError: () => RevocationError,
  RevocationHistoryInfo: () => RevocationHistoryInfo,
  RevocationHistoryPagingSlicedResult: () => RevocationHistoryPagingSlicedResult,
  RevocationPluginConfigInfo: () => RevocationPluginConfigInfo,
  RevocationPluginConfigUpdate: () => RevocationPluginConfigUpdate,
  RevocationRequest: () => RevocationRequest,
  RevocationResult: () => RevocationResult,
  RevokeCurrency: () => RevokeCurrency,
  RevokeEntitlement: () => RevokeEntitlement,
  RevokeEntitlementPayload: () => RevokeEntitlementPayload,
  RevokeEntry: () => RevokeEntry,
  RevokeFulfillmentV2Result: () => RevokeFulfillmentV2Result,
  RevokeItem: () => RevokeItem,
  RevokeItemSummary: () => RevokeItemSummary,
  RevokeResult: () => RevokeResult,
  RevokeUseCountRequest: () => RevokeUseCountRequest,
  Reward$: () => Reward$,
  RewardAdmin$: () => RewardAdmin$,
  RewardAdminApi: () => RewardAdminApi,
  RewardApi: () => RewardApi,
  RewardCondition: () => RewardCondition,
  RewardCreate: () => RewardCreate,
  RewardInfo: () => RewardInfo,
  RewardItem: () => RewardItem,
  RewardMigrationResult: () => RewardMigrationResult,
  RewardPagingSlicedResult: () => RewardPagingSlicedResult,
  RewardUpdate: () => RewardUpdate,
  RewardsRequest: () => RewardsRequest,
  SaleConfig: () => SaleConfig,
  Section$: () => Section$,
  SectionAdmin$: () => SectionAdmin$,
  SectionAdminApi: () => SectionAdminApi,
  SectionApi: () => SectionApi,
  SectionCreate: () => SectionCreate,
  SectionInfo: () => SectionInfo,
  SectionInfoArray: () => SectionInfoArray,
  SectionItem: () => SectionItem,
  SectionPagingSlicedResult: () => SectionPagingSlicedResult,
  SectionPluginConfigInfo: () => SectionPluginConfigInfo,
  SectionPluginConfigUpdate: () => SectionPluginConfigUpdate,
  SectionUpdate: () => SectionUpdate,
  ServicePluginConfigAdmin$: () => ServicePluginConfigAdmin$,
  ServicePluginConfigAdminApi: () => ServicePluginConfigAdminApi,
  ServicePluginConfigInfo: () => ServicePluginConfigInfo,
  ServicePluginConfigUpdate: () => ServicePluginConfigUpdate,
  SessionPlatformAdmin$: () => SessionPlatformAdmin$,
  SessionPlatformAdminApi: () => SessionPlatformAdminApi,
  SimpleDlcRewardItem: () => SimpleDlcRewardItem,
  SimpleEntitlement: () => SimpleEntitlement,
  SimpleUserDlc: () => SimpleUserDlc,
  SimpleUserDlcRewardContent: () => SimpleUserDlcRewardContent,
  SimpleUserDlcRewardContentsResponse: () => SimpleUserDlcRewardContentsResponse,
  SimpleWallet: () => SimpleWallet,
  Slide: () => Slide,
  StackableEntitlementInfo: () => StackableEntitlementInfo,
  StackableEntitlementInfoArray: () => StackableEntitlementInfoArray,
  SteamAchievement: () => SteamAchievement,
  SteamAchievementUpdateRequest: () => SteamAchievementUpdateRequest,
  SteamDlcSyncRequest: () => SteamDlcSyncRequest,
  SteamIapConfig: () => SteamIapConfig,
  SteamIapConfigInfo: () => SteamIapConfigInfo,
  SteamIapConfigRequest: () => SteamIapConfigRequest,
  SteamSyncRequest: () => SteamSyncRequest,
  Store$: () => Store$,
  StoreAdmin$: () => StoreAdmin$,
  StoreAdminApi: () => StoreAdminApi,
  StoreApi: () => StoreApi,
  StoreBackupInfo: () => StoreBackupInfo,
  StoreCreate: () => StoreCreate,
  StoreInfo: () => StoreInfo,
  StoreInfoArray: () => StoreInfoArray,
  StoreUpdate: () => StoreUpdate,
  StreamEvent: () => StreamEvent,
  StreamEventBody: () => StreamEventBody,
  StripeConfig: () => StripeConfig,
  SubItemAvailablePrice: () => SubItemAvailablePrice,
  Subscribable: () => Subscribable,
  SubscribeRequest: () => SubscribeRequest,
  Subscription$: () => Subscription$,
  SubscriptionActivityInfo: () => SubscriptionActivityInfo,
  SubscriptionActivityPagingSlicedResult: () => SubscriptionActivityPagingSlicedResult,
  SubscriptionAdmin$: () => SubscriptionAdmin$,
  SubscriptionAdminApi: () => SubscriptionAdminApi,
  SubscriptionApi: () => SubscriptionApi,
  SubscriptionInfo: () => SubscriptionInfo,
  SubscriptionPagingSlicedResult: () => SubscriptionPagingSlicedResult,
  SubscriptionSummary: () => SubscriptionSummary,
  TaxResult: () => TaxResult,
  TestResult: () => TestResult,
  ThirdPartySubscriptionOwnership: () => ThirdPartySubscriptionOwnership,
  ThirdPartySubscriptionTransactionHistoryInfo: () => ThirdPartySubscriptionTransactionHistoryInfo,
  ThirdPartySubscriptionTransactionHistoryPagingSlicedResult: () => ThirdPartySubscriptionTransactionHistoryPagingSlicedResult,
  ThirdPartySubscriptionTransactionInfo: () => ThirdPartySubscriptionTransactionInfo,
  ThirdPartySubscriptionTransactionPagingSlicedResult: () => ThirdPartySubscriptionTransactionPagingSlicedResult,
  ThirdPartyUserSubscriptionInfo: () => ThirdPartyUserSubscriptionInfo,
  ThirdPartyUserSubscriptionPagingSlicedResult: () => ThirdPartyUserSubscriptionPagingSlicedResult,
  TicketAcquireRequest: () => TicketAcquireRequest,
  TicketAcquireResult: () => TicketAcquireResult,
  TicketAdmin$: () => TicketAdmin$,
  TicketAdminApi: () => TicketAdminApi,
  TicketBoothId: () => TicketBoothId,
  TicketDynamicInfo: () => TicketDynamicInfo,
  TicketSaleDecrementRequest: () => TicketSaleDecrementRequest,
  TicketSaleIncrementRequest: () => TicketSaleIncrementRequest,
  TicketSaleIncrementResult: () => TicketSaleIncrementResult,
  TimeLimitedBalance: () => TimeLimitedBalance,
  TimedOwnership: () => TimedOwnership,
  TlsConfig: () => TlsConfig,
  TradeActionAdmin$: () => TradeActionAdmin$,
  TradeActionAdminApi: () => TradeActionAdminApi,
  TradeActionPagingSlicedResult: () => TradeActionPagingSlicedResult,
  TradeChainActionHistoryInfo: () => TradeChainActionHistoryInfo,
  TradeChainedActionCommitRequest: () => TradeChainedActionCommitRequest,
  TradeNotification: () => TradeNotification,
  Transaction: () => Transaction,
  TransactionAmountDetails: () => TransactionAmountDetails,
  TwitchIapConfigInfo: () => TwitchIapConfigInfo,
  TwitchIapConfigRequest: () => TwitchIapConfigRequest,
  TwitchSyncRequest: () => TwitchSyncRequest,
  TwitchSyncResult: () => TwitchSyncResult,
  TwitchSyncResultArray: () => TwitchSyncResultArray,
  UserDlc: () => UserDlc,
  UserDlcRecord: () => UserDlcRecord,
  UserDlcRecordArray: () => UserDlcRecordArray,
  UserEntitlementHistoryPagingSlicedResult: () => UserEntitlementHistoryPagingSlicedResult,
  UserEntitlementHistoryPagingSlicedResultArray: () => UserEntitlementHistoryPagingSlicedResultArray,
  ValidationErrorEntity: () => ValidationErrorEntity,
  View$: () => View$,
  ViewAdmin$: () => ViewAdmin$,
  ViewAdminApi: () => ViewAdminApi,
  ViewApi: () => ViewApi,
  ViewCreate: () => ViewCreate,
  ViewInfo: () => ViewInfo,
  ViewInfoArray: () => ViewInfoArray,
  ViewUpdate: () => ViewUpdate,
  Wallet$: () => Wallet$,
  WalletAdmin$: () => WalletAdmin$,
  WalletAdminApi: () => WalletAdminApi,
  WalletApi: () => WalletApi,
  WalletInfo: () => WalletInfo,
  WalletPagingSlicedResult: () => WalletPagingSlicedResult,
  WalletRevocationConfig: () => WalletRevocationConfig,
  WalletTransactionInfo: () => WalletTransactionInfo,
  WalletTransactionPagingSlicedResult: () => WalletTransactionPagingSlicedResult,
  WxPayConfigInfo: () => WxPayConfigInfo,
  WxPayConfigRequest: () => WxPayConfigRequest,
  XblAchievementUpdateRequest: () => XblAchievementUpdateRequest,
  XblDlcSyncRequest: () => XblDlcSyncRequest,
  XblEntitlementOwnershipRequest: () => XblEntitlementOwnershipRequest,
  XblIapConfigInfo: () => XblIapConfigInfo,
  XblIapConfigRequest: () => XblIapConfigRequest,
  XblReconcileRequest: () => XblReconcileRequest,
  XblReconcileResult: () => XblReconcileResult,
  XblReconcileResultArray: () => XblReconcileResultArray,
  XblUserAchievements: () => XblUserAchievements,
  XblUserSessionRequest: () => XblUserSessionRequest,
  XboxAchievement: () => XboxAchievement,
  XsollaConfig: () => XsollaConfig,
  XsollaPaywallConfig: () => XsollaPaywallConfig,
  XsollaPaywallConfigRequest: () => XsollaPaywallConfigRequest
});
module.exports = __toCommonJS(src_exports);

// src/generated-admin/AchievementPlatformAdminApi.ts
var import_sdk2 = require("@accelbyte/sdk");

// src/generated-admin/endpoints/AchievementPlatformAdmin$.ts
var import_sdk = require("@accelbyte/sdk");
var import_zod3 = require("zod");

// src/generated-definitions/XblUserAchievements.ts
var import_zod2 = require("zod");

// src/generated-definitions/AchievementInfo.ts
var import_zod = require("zod");
var AchievementInfo = import_zod.z.object({
  id: import_zod.z.string().nullish(),
  name: import_zod.z.string().nullish(),
  progressState: import_zod.z.string().nullish(),
  progression: import_zod.z.record(import_zod.z.any()).nullish(),
  serviceConfigId: import_zod.z.string().nullish()
});

// src/generated-definitions/XblUserAchievements.ts
var XblUserAchievements = import_zod2.z.object({ achievements: import_zod2.z.array(AchievementInfo).nullish() });

// src/generated-admin/endpoints/AchievementPlatformAdmin$.ts
var AchievementPlatformAdmin$ = class {
  // @ts-ignore
  // prettier-ignore
  constructor(axiosInstance, namespace, useSchemaValidation = true) {
    this.axiosInstance = axiosInstance;
    this.namespace = namespace;
    this.useSchemaValidation = useSchemaValidation;
  }
  /**
   * This API is used to get xbox live user achievements(Only for test).
   */
  getAchievementXbl_ByUserId(userId, queryParams) {
    const params = { ...queryParams };
    const url = "/platform/admin/namespaces/{namespace}/users/{userId}/achievement/xbl".replace("{namespace}", this.namespace).replace("{userId}", userId);
    const resultPromise = this.axiosInstance.get(url, { params });
    return import_sdk.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, XblUserAchievements, "XblUserAchievements");
  }
  /**
   * This API is used to update xbox live achievements.
   */
  updateAchievementXbl_ByUserId(userId, data) {
    const params = {};
    const url = "/platform/admin/namespaces/{namespace}/users/{userId}/achievement/xbl".replace("{namespace}", this.namespace).replace("{userId}", userId);
    const resultPromise = this.axiosInstance.put(url, data, { params });
    return import_sdk.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, import_zod3.z.unknown(), "z.unknown()");
  }
  /**
   * This API is used to unlock steam achievement.
   */
  updateAchievementSteam_ByUserId(userId, data) {
    const params = {};
    const url = "/platform/admin/namespaces/{namespace}/users/{userId}/achievement/steam".replace("{namespace}", this.namespace).replace("{userId}", userId);
    const resultPromise = this.axiosInstance.put(url, data, { params });
    return import_sdk.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, import_zod3.z.unknown(), "z.unknown()");
  }
};

// src/generated-admin/AchievementPlatformAdminApi.ts
function AchievementPlatformAdminApi(sdk, args) {
  const sdkAssembly = sdk.assembly();
  const namespace = args?.coreConfig?.namespace ?? sdkAssembly.coreConfig.namespace;
  const useSchemaValidation = args?.coreConfig?.useSchemaValidation ?? sdkAssembly.coreConfig.useSchemaValidation;
  let axiosInstance = sdkAssembly.axiosInstance;
  const requestConfigOverrides = args?.axiosConfig?.request;
  const baseURLOverride = args?.coreConfig?.baseURL;
  const interceptorsOverride = args?.axiosConfig?.interceptors ?? [];
  if (requestConfigOverrides || baseURLOverride || interceptorsOverride.length > 0) {
    const requestConfig = import_sdk2.ApiUtils.mergeAxiosConfigs(sdkAssembly.axiosInstance.defaults, {
      ...baseURLOverride ? { baseURL: baseURLOverride } : {},
      ...requestConfigOverrides
    });
    axiosInstance = import_sdk2.Network.create(requestConfig);
    for (const interceptor of interceptorsOverride) {
      if (interceptor.type === "request") {
        axiosInstance.interceptors.request.use(interceptor.onRequest, interceptor.onError);
      }
      if (interceptor.type === "response") {
        axiosInstance.interceptors.response.use(interceptor.onSuccess, interceptor.onError);
      }
    }
  }
  async function getAchievementXbl_ByUserId(userId, queryParams) {
    const $ = new AchievementPlatformAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getAchievementXbl_ByUserId(userId, queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function updateAchievementXbl_ByUserId(userId, data) {
    const $ = new AchievementPlatformAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.updateAchievementXbl_ByUserId(userId, data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function updateAchievementSteam_ByUserId(userId, data) {
    const $ = new AchievementPlatformAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.updateAchievementSteam_ByUserId(userId, data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  return {
    /**
     * This API is used to get xbox live user achievements(Only for test).
     */
    getAchievementXbl_ByUserId,
    /**
     * This API is used to update xbox live achievements.
     */
    updateAchievementXbl_ByUserId,
    /**
     * This API is used to unlock steam achievement.
     */
    updateAchievementSteam_ByUserId
  };
}

// src/generated-admin/AnonymizationAdminApi.ts
var import_sdk4 = require("@accelbyte/sdk");

// src/generated-admin/endpoints/AnonymizationAdmin$.ts
var import_sdk3 = require("@accelbyte/sdk");
var import_zod4 = require("zod");
var AnonymizationAdmin$ = class {
  // @ts-ignore
  // prettier-ignore
  constructor(axiosInstance, namespace, useSchemaValidation = true) {
    this.axiosInstance = axiosInstance;
    this.namespace = namespace;
    this.useSchemaValidation = useSchemaValidation;
  }
  /**
   * Anonymize order. At current it will only anonymize order, order history.
   */
  deleteAnonymizationOrder_ByUserId(userId) {
    const params = {};
    const url = "/platform/admin/namespaces/{namespace}/users/{userId}/anonymization/orders".replace("{namespace}", this.namespace).replace("{userId}", userId);
    const resultPromise = this.axiosInstance.delete(url, { params });
    return import_sdk3.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, import_zod4.z.unknown(), "z.unknown()");
  }
  /**
   * Anonymize payment. At current it will only anonymize payment order, payment order history.
   */
  deleteAnonymizationPayment_ByUserId(userId) {
    const params = {};
    const url = "/platform/admin/namespaces/{namespace}/users/{userId}/anonymization/payment".replace("{namespace}", this.namespace).replace("{userId}", userId);
    const resultPromise = this.axiosInstance.delete(url, { params });
    return import_sdk3.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, import_zod4.z.unknown(), "z.unknown()");
  }
  /**
   * Anonymize wallet. At current it will only anonymize wallet, wallet transaction.
   */
  deleteAnonymizationWallet_ByUserId(userId) {
    const params = {};
    const url = "/platform/admin/namespaces/{namespace}/users/{userId}/anonymization/wallets".replace("{namespace}", this.namespace).replace("{userId}", userId);
    const resultPromise = this.axiosInstance.delete(url, { params });
    return import_sdk3.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, import_zod4.z.unknown(), "z.unknown()");
  }
  /**
   * Anonymize campaign. At current it will only anonymize redeem history.
   */
  deleteAnonymizationCampaign_ByUserId(userId) {
    const params = {};
    const url = "/platform/admin/namespaces/{namespace}/users/{userId}/anonymization/campaign".replace("{namespace}", this.namespace).replace("{userId}", userId);
    const resultPromise = this.axiosInstance.delete(url, { params });
    return import_sdk3.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, import_zod4.z.unknown(), "z.unknown()");
  }
  /**
   * Anonymize revocation. At current it will only anonymize revocation history.
   */
  deleteAnonymizationRevocation_ByUserId(userId) {
    const params = {};
    const url = "/platform/admin/namespaces/{namespace}/users/{userId}/anonymization/revocation".replace("{namespace}", this.namespace).replace("{userId}", userId);
    const resultPromise = this.axiosInstance.delete(url, { params });
    return import_sdk3.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, import_zod4.z.unknown(), "z.unknown()");
  }
  /**
   * Anonymize fulfillment. At current it will only anonymize fulfillment history.
   */
  deleteAnonymizationFulfillment_ByUserId(userId) {
    const params = {};
    const url = "/platform/admin/namespaces/{namespace}/users/{userId}/anonymization/fulfillment".replace("{namespace}", this.namespace).replace("{userId}", userId);
    const resultPromise = this.axiosInstance.delete(url, { params });
    return import_sdk3.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, import_zod4.z.unknown(), "z.unknown()");
  }
  /**
   * Anonymize entitlement. At current it will only anonymize entitlement, entitlement history.
   */
  deleteAnonymizationEntitlement_ByUserId(userId) {
    const params = {};
    const url = "/platform/admin/namespaces/{namespace}/users/{userId}/anonymization/entitlements".replace("{namespace}", this.namespace).replace("{userId}", userId);
    const resultPromise = this.axiosInstance.delete(url, { params });
    return import_sdk3.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, import_zod4.z.unknown(), "z.unknown()");
  }
  /**
   * Anonymize integrations. At current it will only anonymize iap histories.
   */
  deleteAnonymizationIntegration_ByUserId(userId) {
    const params = {};
    const url = "/platform/admin/namespaces/{namespace}/users/{userId}/anonymization/integrations".replace("{namespace}", this.namespace).replace("{userId}", userId);
    const resultPromise = this.axiosInstance.delete(url, { params });
    return import_sdk3.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, import_zod4.z.unknown(), "z.unknown()");
  }
  /**
   * Anonymize subscription. At current it will anonymize subscription, billing history and subscription activity.
   */
  deleteAnonymizationSubscription_ByUserId(userId) {
    const params = {};
    const url = "/platform/admin/namespaces/{namespace}/users/{userId}/anonymization/subscriptions".replace("{namespace}", this.namespace).replace("{userId}", userId);
    const resultPromise = this.axiosInstance.delete(url, { params });
    return import_sdk3.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, import_zod4.z.unknown(), "z.unknown()");
  }
};

// src/generated-admin/AnonymizationAdminApi.ts
function AnonymizationAdminApi(sdk, args) {
  const sdkAssembly = sdk.assembly();
  const namespace = args?.coreConfig?.namespace ?? sdkAssembly.coreConfig.namespace;
  const useSchemaValidation = args?.coreConfig?.useSchemaValidation ?? sdkAssembly.coreConfig.useSchemaValidation;
  let axiosInstance = sdkAssembly.axiosInstance;
  const requestConfigOverrides = args?.axiosConfig?.request;
  const baseURLOverride = args?.coreConfig?.baseURL;
  const interceptorsOverride = args?.axiosConfig?.interceptors ?? [];
  if (requestConfigOverrides || baseURLOverride || interceptorsOverride.length > 0) {
    const requestConfig = import_sdk4.ApiUtils.mergeAxiosConfigs(sdkAssembly.axiosInstance.defaults, {
      ...baseURLOverride ? { baseURL: baseURLOverride } : {},
      ...requestConfigOverrides
    });
    axiosInstance = import_sdk4.Network.create(requestConfig);
    for (const interceptor of interceptorsOverride) {
      if (interceptor.type === "request") {
        axiosInstance.interceptors.request.use(interceptor.onRequest, interceptor.onError);
      }
      if (interceptor.type === "response") {
        axiosInstance.interceptors.response.use(interceptor.onSuccess, interceptor.onError);
      }
    }
  }
  async function deleteAnonymizationOrder_ByUserId(userId) {
    const $ = new AnonymizationAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.deleteAnonymizationOrder_ByUserId(userId);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function deleteAnonymizationPayment_ByUserId(userId) {
    const $ = new AnonymizationAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.deleteAnonymizationPayment_ByUserId(userId);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function deleteAnonymizationWallet_ByUserId(userId) {
    const $ = new AnonymizationAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.deleteAnonymizationWallet_ByUserId(userId);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function deleteAnonymizationCampaign_ByUserId(userId) {
    const $ = new AnonymizationAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.deleteAnonymizationCampaign_ByUserId(userId);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function deleteAnonymizationRevocation_ByUserId(userId) {
    const $ = new AnonymizationAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.deleteAnonymizationRevocation_ByUserId(userId);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function deleteAnonymizationFulfillment_ByUserId(userId) {
    const $ = new AnonymizationAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.deleteAnonymizationFulfillment_ByUserId(userId);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function deleteAnonymizationEntitlement_ByUserId(userId) {
    const $ = new AnonymizationAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.deleteAnonymizationEntitlement_ByUserId(userId);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function deleteAnonymizationIntegration_ByUserId(userId) {
    const $ = new AnonymizationAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.deleteAnonymizationIntegration_ByUserId(userId);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function deleteAnonymizationSubscription_ByUserId(userId) {
    const $ = new AnonymizationAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.deleteAnonymizationSubscription_ByUserId(userId);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  return {
    /**
     * Anonymize order. At current it will only anonymize order, order history.
     */
    deleteAnonymizationOrder_ByUserId,
    /**
     * Anonymize payment. At current it will only anonymize payment order, payment order history.
     */
    deleteAnonymizationPayment_ByUserId,
    /**
     * Anonymize wallet. At current it will only anonymize wallet, wallet transaction.
     */
    deleteAnonymizationWallet_ByUserId,
    /**
     * Anonymize campaign. At current it will only anonymize redeem history.
     */
    deleteAnonymizationCampaign_ByUserId,
    /**
     * Anonymize revocation. At current it will only anonymize revocation history.
     */
    deleteAnonymizationRevocation_ByUserId,
    /**
     * Anonymize fulfillment. At current it will only anonymize fulfillment history.
     */
    deleteAnonymizationFulfillment_ByUserId,
    /**
     * Anonymize entitlement. At current it will only anonymize entitlement, entitlement history.
     */
    deleteAnonymizationEntitlement_ByUserId,
    /**
     * Anonymize integrations. At current it will only anonymize iap histories.
     */
    deleteAnonymizationIntegration_ByUserId,
    /**
     * Anonymize subscription. At current it will anonymize subscription, billing history and subscription activity.
     */
    deleteAnonymizationSubscription_ByUserId
  };
}

// src/generated-admin/CampaignAdminApi.ts
var import_sdk6 = require("@accelbyte/sdk");

// src/generated-admin/endpoints/CampaignAdmin$.ts
var import_sdk5 = require("@accelbyte/sdk");
var import_zod23 = require("zod");

// src/generated-definitions/BulkOperationResult.ts
var import_zod5 = require("zod");
var BulkOperationResult = import_zod5.z.object({ affected: import_zod5.z.number().int().nullish() });

// src/generated-definitions/CampaignBatchNameInfoArray.ts
var import_zod7 = require("zod");

// src/generated-definitions/CampaignBatchNameInfo.ts
var import_zod6 = require("zod");
var CampaignBatchNameInfo = import_zod6.z.object({ batchName: import_zod6.z.string(), batchNos: import_zod6.z.array(import_zod6.z.number().int()) });

// src/generated-definitions/CampaignBatchNameInfoArray.ts
var CampaignBatchNameInfoArray = import_zod7.z.array(CampaignBatchNameInfo);

// src/generated-definitions/CampaignDynamicInfo.ts
var import_zod8 = require("zod");
var CampaignDynamicInfo = import_zod8.z.object({
  availableSaleCount: import_zod8.z.number().int(),
  lastBatchNo: import_zod8.z.number().int(),
  quantity: import_zod8.z.number().int(),
  remainder: import_zod8.z.number().int(),
  saleCount: import_zod8.z.number().int()
});

// src/generated-definitions/CampaignInfo.ts
var import_zod13 = require("zod");

// src/generated-definitions/DiscountConfig.ts
var import_zod11 = require("zod");

// src/generated-definitions/DiscountCategory.ts
var import_zod9 = require("zod");
var DiscountCategory = import_zod9.z.object({ categoryPath: import_zod9.z.string(), includeSubCategories: import_zod9.z.boolean().nullish() });

// src/generated-definitions/DiscountItem.ts
var import_zod10 = require("zod");
var DiscountItem = import_zod10.z.object({ itemId: import_zod10.z.string(), itemName: import_zod10.z.string() });

// src/generated-definitions/DiscountConfig.ts
var DiscountConfig = import_zod11.z.object({
  categories: import_zod11.z.array(DiscountCategory).nullish(),
  currencyCode: import_zod11.z.string().nullish(),
  currencyNamespace: import_zod11.z.string().nullish(),
  discountAmount: import_zod11.z.number().int().nullish(),
  discountPercentage: import_zod11.z.number().int().nullish(),
  discountType: import_zod11.z.enum(["AMOUNT", "PERCENTAGE"]).nullish(),
  items: import_zod11.z.array(DiscountItem).nullish(),
  restrictType: import_zod11.z.enum(["ITEMS_AND_CATEGORIES", "NONE"]).nullish(),
  stackable: import_zod11.z.boolean().nullish()
});

// src/generated-definitions/RedeemableItem.ts
var import_zod12 = require("zod");
var RedeemableItem = import_zod12.z.object({
  extraSubscriptionDays: import_zod12.z.number().int().nullish(),
  itemId: import_zod12.z.string(),
  itemName: import_zod12.z.string(),
  quantity: import_zod12.z.number().int().nullish()
});

// src/generated-definitions/CampaignInfo.ts
var CampaignInfo = import_zod13.z.object({
  boothName: import_zod13.z.string(),
  createdAt: import_zod13.z.string(),
  description: import_zod13.z.string().nullish(),
  discountConfig: DiscountConfig.nullish(),
  id: import_zod13.z.string(),
  items: import_zod13.z.array(RedeemableItem).nullish(),
  maxRedeemCountPerCampaignPerUser: import_zod13.z.number().int(),
  maxRedeemCountPerCode: import_zod13.z.number().int(),
  maxRedeemCountPerCodePerUser: import_zod13.z.number().int(),
  maxSaleCount: import_zod13.z.number().int(),
  name: import_zod13.z.string(),
  namespace: import_zod13.z.string(),
  redeemEnd: import_zod13.z.string().nullish(),
  redeemStart: import_zod13.z.string().nullish(),
  redeemType: import_zod13.z.enum(["DISCOUNT", "ITEM"]),
  status: import_zod13.z.enum(["ACTIVE", "INACTIVE"]),
  tags: import_zod13.z.array(import_zod13.z.string()).nullish(),
  type: import_zod13.z.enum(["REDEMPTION"]),
  updatedAt: import_zod13.z.string()
});

// src/generated-definitions/CampaignPagingSlicedResult.ts
var import_zod15 = require("zod");

// src/generated-definitions/Paging.ts
var import_zod14 = require("zod");
var Paging = import_zod14.z.object({ next: import_zod14.z.string().nullish(), previous: import_zod14.z.string().nullish() });

// src/generated-definitions/CampaignPagingSlicedResult.ts
var CampaignPagingSlicedResult = import_zod15.z.object({ data: import_zod15.z.array(CampaignInfo), paging: Paging.nullish() });

// src/generated-definitions/CodeCreateResult.ts
var import_zod16 = require("zod");
var CodeCreateResult = import_zod16.z.object({ numCreated: import_zod16.z.number().int() });

// src/generated-definitions/CodeInfo.ts
var import_zod18 = require("zod");

// src/generated-definitions/CampaignIfc.ts
var import_zod17 = require("zod");
var CampaignIfc = import_zod17.z.object({ id: import_zod17.z.string().nullish(), name: import_zod17.z.string().nullish() });

// src/generated-definitions/CodeInfo.ts
var CodeInfo = import_zod18.z.object({
  acquireOrderNo: import_zod18.z.string().nullish(),
  acquireUserId: import_zod18.z.string().nullish(),
  batchName: import_zod18.z.string().nullish(),
  batchNo: import_zod18.z.number().int(),
  campaign: CampaignIfc.nullish(),
  campaignId: import_zod18.z.string(),
  createdAt: import_zod18.z.string(),
  discountConfig: DiscountConfig.nullish(),
  id: import_zod18.z.string(),
  items: import_zod18.z.array(RedeemableItem).nullish(),
  maxRedeemCountPerCampaignPerUser: import_zod18.z.number().int(),
  maxRedeemCountPerCode: import_zod18.z.number().int(),
  maxRedeemCountPerCodePerUser: import_zod18.z.number().int(),
  namespace: import_zod18.z.string(),
  redeemEnd: import_zod18.z.string().nullish(),
  redeemStart: import_zod18.z.string().nullish(),
  redeemType: import_zod18.z.enum(["DISCOUNT", "ITEM"]),
  redeemedCount: import_zod18.z.number().int(),
  remainder: import_zod18.z.number().int(),
  status: import_zod18.z.enum(["ACTIVE", "INACTIVE"]),
  type: import_zod18.z.enum(["REDEMPTION"]),
  updatedAt: import_zod18.z.string(),
  value: import_zod18.z.string()
});

// src/generated-definitions/CodeInfoPagingSlicedResult.ts
var import_zod19 = require("zod");
var CodeInfoPagingSlicedResult = import_zod19.z.object({ data: import_zod19.z.array(CodeInfo), paging: Paging.nullish() });

// src/generated-definitions/RedeemHistoryPagingSlicedResult.ts
var import_zod21 = require("zod");

// src/generated-definitions/RedeemHistoryInfo.ts
var import_zod20 = require("zod");
var RedeemHistoryInfo = import_zod20.z.object({
  campaignId: import_zod20.z.string(),
  code: import_zod20.z.string(),
  createdAt: import_zod20.z.string(),
  id: import_zod20.z.string(),
  namespace: import_zod20.z.string(),
  orderNo: import_zod20.z.string().nullish(),
  redeemedAt: import_zod20.z.string().nullish(),
  updatedAt: import_zod20.z.string(),
  userId: import_zod20.z.string()
});

// src/generated-definitions/RedeemHistoryPagingSlicedResult.ts
var RedeemHistoryPagingSlicedResult = import_zod21.z.object({ data: import_zod21.z.array(RedeemHistoryInfo), paging: Paging.nullish() });

// src/generated-definitions/RedeemResult.ts
var import_zod22 = require("zod");
var RedeemResult = import_zod22.z.object({ items: import_zod22.z.array(RedeemableItem).nullish() });

// src/generated-admin/endpoints/CampaignAdmin$.ts
var CampaignAdmin$ = class {
  // @ts-ignore
  // prettier-ignore
  constructor(axiosInstance, namespace, useSchemaValidation = true) {
    this.axiosInstance = axiosInstance;
    this.namespace = namespace;
    this.useSchemaValidation = useSchemaValidation;
  }
  /**
   * Query campaigns, if name is presented, it&#39;s fuzzy match.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: slice of campaigns&lt;/li&gt;&lt;/ul&gt;
   */
  getCampaigns(queryParams) {
    const params = { limit: 20, ...queryParams };
    const url = "/platform/admin/namespaces/{namespace}/campaigns".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.get(url, { params });
    return import_sdk5.Validate.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      CampaignPagingSlicedResult,
      "CampaignPagingSlicedResult"
    );
  }
  /**
   * Create campaign.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: created campaign&lt;/li&gt;&lt;/ul&gt;
   */
  createCampaign(data) {
    const params = {};
    const url = "/platform/admin/namespaces/{namespace}/campaigns".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.post(url, data, { params });
    return import_sdk5.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, CampaignInfo, "CampaignInfo");
  }
  /**
   * Get campaign code, it will check code whether available to redeem if redeemable true.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: code info&lt;/li&gt;&lt;/ul&gt;
   */
  getCode_ByCode(code, queryParams) {
    const params = { ...queryParams };
    const url = "/platform/admin/namespaces/{namespace}/codes/{code}".replace("{namespace}", this.namespace).replace("{code}", code);
    const resultPromise = this.axiosInstance.get(url, { params });
    return import_sdk5.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, CodeInfo, "CodeInfo");
  }
  /**
   * Enable code.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: enabled code&lt;/li&gt;&lt;/ul&gt;
   */
  updateEnable_ByCode(code) {
    const params = {};
    const url = "/platform/admin/namespaces/{namespace}/codes/{code}/enable".replace("{namespace}", this.namespace).replace("{code}", code);
    const resultPromise = this.axiosInstance.put(url, null, { params });
    return import_sdk5.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, CodeInfo, "CodeInfo");
  }
  /**
   * Disable code.&lt;p&gt;Disable an active code, the code can&#39;t be disabled if it has already been redeemed.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: disabled code&lt;/li&gt;&lt;/ul&gt;
   */
  updateDisable_ByCode(code) {
    const params = {};
    const url = "/platform/admin/namespaces/{namespace}/codes/{code}/disable".replace("{namespace}", this.namespace).replace("{code}", code);
    const resultPromise = this.axiosInstance.put(url, null, { params });
    return import_sdk5.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, CodeInfo, "CodeInfo");
  }
  /**
   * Get campaign info.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: campaign info&lt;/li&gt;&lt;/ul&gt;
   */
  getCampaign_ByCampaignId(campaignId) {
    const params = {};
    const url = "/platform/admin/namespaces/{namespace}/campaigns/{campaignId}".replace("{namespace}", this.namespace).replace("{campaignId}", campaignId);
    const resultPromise = this.axiosInstance.get(url, { params });
    return import_sdk5.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, CampaignInfo, "CampaignInfo");
  }
  /**
   * Update campaign.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: updated campaign&lt;/li&gt;&lt;/ul&gt;
   */
  updateCampaign_ByCampaignId(campaignId, data) {
    const params = {};
    const url = "/platform/admin/namespaces/{namespace}/campaigns/{campaignId}".replace("{namespace}", this.namespace).replace("{campaignId}", campaignId);
    const resultPromise = this.axiosInstance.put(url, data, { params });
    return import_sdk5.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, CampaignInfo, "CampaignInfo");
  }
  /**
   * &lt;b&gt;[SERVICE COMMUNICATION ONLY]&lt;/b&gt; Redeem code. If the campaign which the code belongs to is INACTIVE, the code couldn&#39;t be redeemed even if its status is ACTIVE.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: Redeem result&lt;/li&gt;&lt;/ul&gt;
   */
  createRedemption_ByUserId(userId, data) {
    const params = {};
    const url = "/platform/admin/namespaces/{namespace}/users/{userId}/redemption".replace("{namespace}", this.namespace).replace("{userId}", userId);
    const resultPromise = this.axiosInstance.post(url, data, { params });
    return import_sdk5.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, RedeemResult, "RedeemResult");
  }
  /**
   * Query campaign codes.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: list of codes&lt;/li&gt;&lt;li&gt;The &lt;i&gt;batchName&lt;/i&gt; field in the codes response will be present only when the &lt;i&gt;withBatchName&lt;/i&gt; parameter is &lt;i&gt;true&lt;/i&gt;, or when the &lt;i&gt;batchName&lt;/i&gt; filter is not blank.&lt;/li&gt;&lt;/ul&gt;
   */
  getCodeCampaign_ByCampaignId(campaignId, queryParams) {
    const params = { activeOnly: true, limit: 20, ...queryParams };
    const url = "/platform/admin/namespaces/{namespace}/codes/campaigns/{campaignId}".replace("{namespace}", this.namespace).replace("{campaignId}", campaignId);
    const resultPromise = this.axiosInstance.get(url, { params });
    return import_sdk5.Validate.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      CodeInfoPagingSlicedResult,
      "CodeInfoPagingSlicedResult"
    );
  }
  /**
   * This API is used to create campaign codes, it will increase the batch No. based on last creation.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: number of codes created&lt;/li&gt;&lt;/ul&gt;
   */
  createCodeCampaign_ByCampaignId(campaignId, data) {
    const params = {};
    const url = "/platform/admin/namespaces/{namespace}/codes/campaigns/{campaignId}".replace("{namespace}", this.namespace).replace("{campaignId}", campaignId);
    const resultPromise = this.axiosInstance.post(url, data, { params });
    return import_sdk5.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, CodeCreateResult, "CodeCreateResult");
  }
  /**
   * Get campaign dynamic.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: campaign dynamic&lt;/li&gt;&lt;/ul&gt;
   */
  getDynamic_ByCampaignId(campaignId) {
    const params = {};
    const url = "/platform/admin/namespaces/{namespace}/campaigns/{campaignId}/dynamic".replace("{namespace}", this.namespace).replace("{campaignId}", campaignId);
    const resultPromise = this.axiosInstance.get(url, { params });
    return import_sdk5.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, CampaignDynamicInfo, "CampaignDynamicInfo");
  }
  /**
   * Change campaign batch name.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;/ul&gt;
   */
  updateBatchName_ByCampaignId(campaignId, data) {
    const params = {};
    const url = "/platform/admin/namespaces/{namespace}/campaigns/{campaignId}/batchName".replace("{namespace}", this.namespace).replace("{campaignId}", campaignId);
    const resultPromise = this.axiosInstance.put(url, data, { params });
    return import_sdk5.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, import_zod23.z.unknown(), "z.unknown()");
  }
  /**
   * Query campaign batch name by fuzzy match.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: list of campaign batch names&lt;/li&gt;&lt;/ul&gt;
   */
  getBatchNames_ByCampaignId(campaignId, queryParams) {
    const params = { limit: 10, ...queryParams };
    const url = "/platform/admin/namespaces/{namespace}/campaigns/{campaignId}/batchNames".replace("{namespace}", this.namespace).replace("{campaignId}", campaignId);
    const resultPromise = this.axiosInstance.get(url, { params });
    return import_sdk5.Validate.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      CampaignBatchNameInfoArray,
      "CampaignBatchNameInfoArray"
    );
  }
  /**
   * Query redeem history.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: slice of redeem history&lt;/li&gt;&lt;/ul&gt;
   */
  getHistoryCodes_ByCampaignId(campaignId, queryParams) {
    const params = { limit: 20, ...queryParams };
    const url = "/platform/admin/namespaces/{namespace}/codes/campaigns/{campaignId}/history".replace("{namespace}", this.namespace).replace("{campaignId}", campaignId);
    const resultPromise = this.axiosInstance.get(url, { params });
    return import_sdk5.Validate.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      RedeemHistoryPagingSlicedResult,
      "RedeemHistoryPagingSlicedResult"
    );
  }
  /**
   * Download all or a batch of campaign&#39;s codes as a csv file.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: codes csv file&lt;/li&gt;&lt;li&gt;The csv file will always have &lt;i&gt;Batch Name&lt;/i&gt; column, but this column will be filled only when the &lt;i&gt;withBatchName&lt;/i&gt; parameter is &lt;i&gt;true&lt;/i&gt;, or when the &lt;i&gt;batchName&lt;/i&gt; filter is not blank.&lt;/li&gt;&lt;/ul&gt;
   */
  getCodesCsv_ByCampaignId(campaignId, queryParams) {
    const params = { ...queryParams };
    const url = "/platform/admin/namespaces/{namespace}/codes/campaigns/{campaignId}/codes.csv".replace("{namespace}", this.namespace).replace("{campaignId}", campaignId);
    const resultPromise = this.axiosInstance.get(url, { params });
    return import_sdk5.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, import_zod23.z.unknown(), "z.unknown()");
  }
  /**
   * Bulk enable campaign codes.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: the number of code actually enabled&lt;/li&gt;&lt;/ul&gt;
   */
  updateEnableBulkCode_ByCampaignId(campaignId, queryParams) {
    const params = { ...queryParams };
    const url = "/platform/admin/namespaces/{namespace}/codes/campaigns/{campaignId}/enable/bulk".replace("{namespace}", this.namespace).replace("{campaignId}", campaignId);
    const resultPromise = this.axiosInstance.put(url, null, { params });
    return import_sdk5.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, BulkOperationResult, "BulkOperationResult");
  }
  /**
   * Bulk disable codes.&lt;p&gt;Bulk disable campaign codes, all matched codes will be disabled except those have already been redeemed.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: the number of code actually disabled&lt;/li&gt;&lt;/ul&gt;
   */
  updateDisableBulkCode_ByCampaignId(campaignId, queryParams) {
    const params = { ...queryParams };
    const url = "/platform/admin/namespaces/{namespace}/codes/campaigns/{campaignId}/disable/bulk".replace("{namespace}", this.namespace).replace("{campaignId}", campaignId);
    const resultPromise = this.axiosInstance.put(url, null, { params });
    return import_sdk5.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, BulkOperationResult, "BulkOperationResult");
  }
};

// src/generated-admin/CampaignAdminApi.ts
function CampaignAdminApi(sdk, args) {
  const sdkAssembly = sdk.assembly();
  const namespace = args?.coreConfig?.namespace ?? sdkAssembly.coreConfig.namespace;
  const useSchemaValidation = args?.coreConfig?.useSchemaValidation ?? sdkAssembly.coreConfig.useSchemaValidation;
  let axiosInstance = sdkAssembly.axiosInstance;
  const requestConfigOverrides = args?.axiosConfig?.request;
  const baseURLOverride = args?.coreConfig?.baseURL;
  const interceptorsOverride = args?.axiosConfig?.interceptors ?? [];
  if (requestConfigOverrides || baseURLOverride || interceptorsOverride.length > 0) {
    const requestConfig = import_sdk6.ApiUtils.mergeAxiosConfigs(sdkAssembly.axiosInstance.defaults, {
      ...baseURLOverride ? { baseURL: baseURLOverride } : {},
      ...requestConfigOverrides
    });
    axiosInstance = import_sdk6.Network.create(requestConfig);
    for (const interceptor of interceptorsOverride) {
      if (interceptor.type === "request") {
        axiosInstance.interceptors.request.use(interceptor.onRequest, interceptor.onError);
      }
      if (interceptor.type === "response") {
        axiosInstance.interceptors.response.use(interceptor.onSuccess, interceptor.onError);
      }
    }
  }
  async function getCampaigns(queryParams) {
    const $ = new CampaignAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getCampaigns(queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function createCampaign(data) {
    const $ = new CampaignAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.createCampaign(data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getCode_ByCode(code, queryParams) {
    const $ = new CampaignAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getCode_ByCode(code, queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function updateEnable_ByCode(code) {
    const $ = new CampaignAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.updateEnable_ByCode(code);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function updateDisable_ByCode(code) {
    const $ = new CampaignAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.updateDisable_ByCode(code);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getCampaign_ByCampaignId(campaignId) {
    const $ = new CampaignAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getCampaign_ByCampaignId(campaignId);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function updateCampaign_ByCampaignId(campaignId, data) {
    const $ = new CampaignAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.updateCampaign_ByCampaignId(campaignId, data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function createRedemption_ByUserId(userId, data) {
    const $ = new CampaignAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.createRedemption_ByUserId(userId, data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getCodeCampaign_ByCampaignId(campaignId, queryParams) {
    const $ = new CampaignAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getCodeCampaign_ByCampaignId(campaignId, queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function createCodeCampaign_ByCampaignId(campaignId, data) {
    const $ = new CampaignAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.createCodeCampaign_ByCampaignId(campaignId, data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getDynamic_ByCampaignId(campaignId) {
    const $ = new CampaignAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getDynamic_ByCampaignId(campaignId);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function updateBatchName_ByCampaignId(campaignId, data) {
    const $ = new CampaignAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.updateBatchName_ByCampaignId(campaignId, data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getBatchNames_ByCampaignId(campaignId, queryParams) {
    const $ = new CampaignAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getBatchNames_ByCampaignId(campaignId, queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getHistoryCodes_ByCampaignId(campaignId, queryParams) {
    const $ = new CampaignAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getHistoryCodes_ByCampaignId(campaignId, queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getCodesCsv_ByCampaignId(campaignId, queryParams) {
    const $ = new CampaignAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getCodesCsv_ByCampaignId(campaignId, queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function updateEnableBulkCode_ByCampaignId(campaignId, queryParams) {
    const $ = new CampaignAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.updateEnableBulkCode_ByCampaignId(campaignId, queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function updateDisableBulkCode_ByCampaignId(campaignId, queryParams) {
    const $ = new CampaignAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.updateDisableBulkCode_ByCampaignId(campaignId, queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  return {
    /**
     * Query campaigns, if name is presented, it&#39;s fuzzy match.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: slice of campaigns&lt;/li&gt;&lt;/ul&gt;
     */
    getCampaigns,
    /**
     * Create campaign.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: created campaign&lt;/li&gt;&lt;/ul&gt;
     */
    createCampaign,
    /**
     * Get campaign code, it will check code whether available to redeem if redeemable true.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: code info&lt;/li&gt;&lt;/ul&gt;
     */
    getCode_ByCode,
    /**
     * Enable code.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: enabled code&lt;/li&gt;&lt;/ul&gt;
     */
    updateEnable_ByCode,
    /**
     * Disable code.&lt;p&gt;Disable an active code, the code can&#39;t be disabled if it has already been redeemed.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: disabled code&lt;/li&gt;&lt;/ul&gt;
     */
    updateDisable_ByCode,
    /**
     * Get campaign info.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: campaign info&lt;/li&gt;&lt;/ul&gt;
     */
    getCampaign_ByCampaignId,
    /**
     * Update campaign.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: updated campaign&lt;/li&gt;&lt;/ul&gt;
     */
    updateCampaign_ByCampaignId,
    /**
     * &lt;b&gt;[SERVICE COMMUNICATION ONLY]&lt;/b&gt; Redeem code. If the campaign which the code belongs to is INACTIVE, the code couldn&#39;t be redeemed even if its status is ACTIVE.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: Redeem result&lt;/li&gt;&lt;/ul&gt;
     */
    createRedemption_ByUserId,
    /**
     * Query campaign codes.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: list of codes&lt;/li&gt;&lt;li&gt;The &lt;i&gt;batchName&lt;/i&gt; field in the codes response will be present only when the &lt;i&gt;withBatchName&lt;/i&gt; parameter is &lt;i&gt;true&lt;/i&gt;, or when the &lt;i&gt;batchName&lt;/i&gt; filter is not blank.&lt;/li&gt;&lt;/ul&gt;
     */
    getCodeCampaign_ByCampaignId,
    /**
     * This API is used to create campaign codes, it will increase the batch No. based on last creation.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: number of codes created&lt;/li&gt;&lt;/ul&gt;
     */
    createCodeCampaign_ByCampaignId,
    /**
     * Get campaign dynamic.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: campaign dynamic&lt;/li&gt;&lt;/ul&gt;
     */
    getDynamic_ByCampaignId,
    /**
     * Change campaign batch name.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;/ul&gt;
     */
    updateBatchName_ByCampaignId,
    /**
     * Query campaign batch name by fuzzy match.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: list of campaign batch names&lt;/li&gt;&lt;/ul&gt;
     */
    getBatchNames_ByCampaignId,
    /**
     * Query redeem history.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: slice of redeem history&lt;/li&gt;&lt;/ul&gt;
     */
    getHistoryCodes_ByCampaignId,
    /**
     * Download all or a batch of campaign&#39;s codes as a csv file.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: codes csv file&lt;/li&gt;&lt;li&gt;The csv file will always have &lt;i&gt;Batch Name&lt;/i&gt; column, but this column will be filled only when the &lt;i&gt;withBatchName&lt;/i&gt; parameter is &lt;i&gt;true&lt;/i&gt;, or when the &lt;i&gt;batchName&lt;/i&gt; filter is not blank.&lt;/li&gt;&lt;/ul&gt;
     */
    getCodesCsv_ByCampaignId,
    /**
     * Bulk enable campaign codes.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: the number of code actually enabled&lt;/li&gt;&lt;/ul&gt;
     */
    updateEnableBulkCode_ByCampaignId,
    /**
     * Bulk disable codes.&lt;p&gt;Bulk disable campaign codes, all matched codes will be disabled except those have already been redeemed.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: the number of code actually disabled&lt;/li&gt;&lt;/ul&gt;
     */
    updateDisableBulkCode_ByCampaignId
  };
}

// src/generated-admin/CatalogChangesAdminApi.ts
var import_sdk8 = require("@accelbyte/sdk");

// src/generated-admin/endpoints/CatalogChangesAdmin$.ts
var import_sdk7 = require("@accelbyte/sdk");
var import_zod28 = require("zod");

// src/generated-definitions/CatalogChangePagingResult.ts
var import_zod25 = require("zod");

// src/generated-definitions/CatalogChangeInfo.ts
var import_zod24 = require("zod");
var CatalogChangeInfo = import_zod24.z.object({
  action: import_zod24.z.enum(["CREATE", "DELETE", "UPDATE"]),
  categoryPath: import_zod24.z.string().nullish(),
  changeId: import_zod24.z.string(),
  createdAt: import_zod24.z.string(),
  description: import_zod24.z.string().nullish(),
  itemId: import_zod24.z.string().nullish(),
  itemType: import_zod24.z.enum(["APP", "BUNDLE", "CODE", "COINS", "EXTENSION", "INGAMEITEM", "LOOTBOX", "MEDIA", "OPTIONBOX", "SEASON", "SUBSCRIPTION"]).nullish(),
  namespace: import_zod24.z.string(),
  publishedAt: import_zod24.z.string().nullish(),
  sectionId: import_zod24.z.string().nullish(),
  selected: import_zod24.z.boolean(),
  sku: import_zod24.z.string().nullish(),
  status: import_zod24.z.enum(["PUBLISHED", "UNPUBLISHED"]),
  storeId: import_zod24.z.string(),
  title: import_zod24.z.string().nullish(),
  type: import_zod24.z.enum(["CATEGORY", "ITEM", "SECTION", "STORE", "VIEW"]).nullish(),
  updatedAt: import_zod24.z.string(),
  viewId: import_zod24.z.string().nullish()
});

// src/generated-definitions/CatalogChangePagingResult.ts
var CatalogChangePagingResult = import_zod25.z.object({
  data: import_zod25.z.array(CatalogChangeInfo),
  paging: Paging.nullish(),
  total: import_zod25.z.number().int().nullish()
});

// src/generated-definitions/CatalogChangeStatistics.ts
var import_zod26 = require("zod");
var CatalogChangeStatistics = import_zod26.z.object({ count: import_zod26.z.number().int(), selectedCount: import_zod26.z.number().int() });

// src/generated-definitions/StoreInfo.ts
var import_zod27 = require("zod");
var StoreInfo = import_zod27.z.object({
  createdAt: import_zod27.z.string(),
  defaultLanguage: import_zod27.z.string(),
  defaultRegion: import_zod27.z.string(),
  description: import_zod27.z.string().nullish(),
  namespace: import_zod27.z.string(),
  published: import_zod27.z.boolean(),
  publishedTime: import_zod27.z.string().nullish(),
  storeId: import_zod27.z.string(),
  supportedLanguages: import_zod27.z.array(import_zod27.z.string()),
  supportedRegions: import_zod27.z.array(import_zod27.z.string()),
  title: import_zod27.z.string(),
  updatedAt: import_zod27.z.string()
});

// src/generated-admin/endpoints/CatalogChangesAdmin$.ts
var CatalogChangesAdmin$ = class {
  // @ts-ignore
  // prettier-ignore
  constructor(axiosInstance, namespace, useSchemaValidation = true) {
    this.axiosInstance = axiosInstance;
    this.namespace = namespace;
    this.useSchemaValidation = useSchemaValidation;
  }
  /**
   * Select all changes.
   */
  updateCatalogChangeSelectAll_ByStoreId(storeId) {
    const params = {};
    const url = "/platform/admin/namespaces/{namespace}/stores/{storeId}/catalogChanges/selectAll".replace("{namespace}", this.namespace).replace("{storeId}", storeId);
    const resultPromise = this.axiosInstance.put(url, null, { params });
    return import_sdk7.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, import_zod28.z.unknown(), "z.unknown()");
  }
  /**
   * This API is used to query changes .&lt;p&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: the pagination of changes&lt;/li&gt;&lt;/ul&gt;
   */
  getCatalogChangesByCriteria_ByStoreId(storeId, queryParams) {
    const params = { limit: 20, sortBy: ["updatedAt:desc"], status: "UNPUBLISHED", ...queryParams };
    const url = "/platform/admin/namespaces/{namespace}/stores/{storeId}/catalogChanges/byCriteria".replace("{namespace}", this.namespace).replace("{storeId}", storeId);
    const resultPromise = this.axiosInstance.get(url, { params });
    return import_sdk7.Validate.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      CatalogChangePagingResult,
      "CatalogChangePagingResult"
    );
  }
  /**
   * This API is used to publish all unpublished changes.&lt;p&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: no content&lt;/li&gt;&lt;/ul&gt;
   */
  updateCatalogChangePublishAll_ByStoreId(storeId) {
    const params = {};
    const url = "/platform/admin/namespaces/{namespace}/stores/{storeId}/catalogChanges/publishAll".replace("{namespace}", this.namespace).replace("{storeId}", storeId);
    const resultPromise = this.axiosInstance.put(url, null, { params });
    return import_sdk7.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, StoreInfo, "StoreInfo");
  }
  /**
   * This API is used to query catalog changes statistics .&lt;p&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: catalog changes statistics changes&lt;/li&gt;&lt;/ul&gt;
   */
  getCatalogChangesStatistics_ByStoreId(storeId, queryParams) {
    const params = { ...queryParams };
    const url = "/platform/admin/namespaces/{namespace}/stores/{storeId}/catalogChanges/statistics".replace("{namespace}", this.namespace).replace("{storeId}", storeId);
    const resultPromise = this.axiosInstance.get(url, { params });
    return import_sdk7.Validate.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      CatalogChangeStatistics,
      "CatalogChangeStatistics"
    );
  }
  /**
   * Unselect all change.
   */
  updateCatalogChangeUnselectAll_ByStoreId(storeId) {
    const params = {};
    const url = "/platform/admin/namespaces/{namespace}/stores/{storeId}/catalogChanges/unselectAll".replace("{namespace}", this.namespace).replace("{storeId}", storeId);
    const resultPromise = this.axiosInstance.put(url, null, { params });
    return import_sdk7.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, import_zod28.z.unknown(), "z.unknown()");
  }
  /**
   * This API is used to publish selected unpublished changes.&lt;p&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: no content&lt;/li&gt;&lt;/ul&gt;
   */
  updateCatalogChangePublishSelected_ByStoreId(storeId) {
    const params = {};
    const url = "/platform/admin/namespaces/{namespace}/stores/{storeId}/catalogChanges/publishSelected".replace("{namespace}", this.namespace).replace("{storeId}", storeId);
    const resultPromise = this.axiosInstance.put(url, null, { params });
    return import_sdk7.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, StoreInfo, "StoreInfo");
  }
  /**
   * Select a change, it will be included when partial publish.
   */
  updateSelect_ByStoreId_ByChangeId(storeId, changeId) {
    const params = {};
    const url = "/platform/admin/namespaces/{namespace}/stores/{storeId}/catalogChanges/{changeId}/select".replace("{namespace}", this.namespace).replace("{storeId}", storeId).replace("{changeId}", changeId);
    const resultPromise = this.axiosInstance.put(url, null, { params });
    return import_sdk7.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, import_zod28.z.unknown(), "z.unknown()");
  }
  /**
   * Unselect a change, it will not be included when partial publish.
   */
  updateUnselect_ByStoreId_ByChangeId(storeId, changeId) {
    const params = {};
    const url = "/platform/admin/namespaces/{namespace}/stores/{storeId}/catalogChanges/{changeId}/unselect".replace("{namespace}", this.namespace).replace("{storeId}", storeId).replace("{changeId}", changeId);
    const resultPromise = this.axiosInstance.put(url, null, { params });
    return import_sdk7.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, import_zod28.z.unknown(), "z.unknown()");
  }
  /**
   * Select all changes by criteria
   */
  updateCatalogChangeSelectAllByCriteria_ByStoreId(storeId, queryParams) {
    const params = { ...queryParams };
    const url = "/platform/admin/namespaces/{namespace}/stores/{storeId}/catalogChanges/selectAllByCriteria".replace("{namespace}", this.namespace).replace("{storeId}", storeId);
    const resultPromise = this.axiosInstance.put(url, null, { params });
    return import_sdk7.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, import_zod28.z.unknown(), "z.unknown()");
  }
};

// src/generated-admin/CatalogChangesAdminApi.ts
function CatalogChangesAdminApi(sdk, args) {
  const sdkAssembly = sdk.assembly();
  const namespace = args?.coreConfig?.namespace ?? sdkAssembly.coreConfig.namespace;
  const useSchemaValidation = args?.coreConfig?.useSchemaValidation ?? sdkAssembly.coreConfig.useSchemaValidation;
  let axiosInstance = sdkAssembly.axiosInstance;
  const requestConfigOverrides = args?.axiosConfig?.request;
  const baseURLOverride = args?.coreConfig?.baseURL;
  const interceptorsOverride = args?.axiosConfig?.interceptors ?? [];
  if (requestConfigOverrides || baseURLOverride || interceptorsOverride.length > 0) {
    const requestConfig = import_sdk8.ApiUtils.mergeAxiosConfigs(sdkAssembly.axiosInstance.defaults, {
      ...baseURLOverride ? { baseURL: baseURLOverride } : {},
      ...requestConfigOverrides
    });
    axiosInstance = import_sdk8.Network.create(requestConfig);
    for (const interceptor of interceptorsOverride) {
      if (interceptor.type === "request") {
        axiosInstance.interceptors.request.use(interceptor.onRequest, interceptor.onError);
      }
      if (interceptor.type === "response") {
        axiosInstance.interceptors.response.use(interceptor.onSuccess, interceptor.onError);
      }
    }
  }
  async function updateCatalogChangeSelectAll_ByStoreId(storeId) {
    const $ = new CatalogChangesAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.updateCatalogChangeSelectAll_ByStoreId(storeId);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getCatalogChangesByCriteria_ByStoreId(storeId, queryParams) {
    const $ = new CatalogChangesAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getCatalogChangesByCriteria_ByStoreId(storeId, queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function updateCatalogChangePublishAll_ByStoreId(storeId) {
    const $ = new CatalogChangesAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.updateCatalogChangePublishAll_ByStoreId(storeId);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getCatalogChangesStatistics_ByStoreId(storeId, queryParams) {
    const $ = new CatalogChangesAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getCatalogChangesStatistics_ByStoreId(storeId, queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function updateCatalogChangeUnselectAll_ByStoreId(storeId) {
    const $ = new CatalogChangesAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.updateCatalogChangeUnselectAll_ByStoreId(storeId);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function updateCatalogChangePublishSelected_ByStoreId(storeId) {
    const $ = new CatalogChangesAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.updateCatalogChangePublishSelected_ByStoreId(storeId);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function updateSelect_ByStoreId_ByChangeId(storeId, changeId) {
    const $ = new CatalogChangesAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.updateSelect_ByStoreId_ByChangeId(storeId, changeId);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function updateUnselect_ByStoreId_ByChangeId(storeId, changeId) {
    const $ = new CatalogChangesAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.updateUnselect_ByStoreId_ByChangeId(storeId, changeId);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function updateCatalogChangeSelectAllByCriteria_ByStoreId(storeId, queryParams) {
    const $ = new CatalogChangesAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.updateCatalogChangeSelectAllByCriteria_ByStoreId(storeId, queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  return {
    /**
     * Select all changes.
     */
    updateCatalogChangeSelectAll_ByStoreId,
    /**
     * This API is used to query changes .&lt;p&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: the pagination of changes&lt;/li&gt;&lt;/ul&gt;
     */
    getCatalogChangesByCriteria_ByStoreId,
    /**
     * This API is used to publish all unpublished changes.&lt;p&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: no content&lt;/li&gt;&lt;/ul&gt;
     */
    updateCatalogChangePublishAll_ByStoreId,
    /**
     * This API is used to query catalog changes statistics .&lt;p&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: catalog changes statistics changes&lt;/li&gt;&lt;/ul&gt;
     */
    getCatalogChangesStatistics_ByStoreId,
    /**
     * Unselect all change.
     */
    updateCatalogChangeUnselectAll_ByStoreId,
    /**
     * This API is used to publish selected unpublished changes.&lt;p&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: no content&lt;/li&gt;&lt;/ul&gt;
     */
    updateCatalogChangePublishSelected_ByStoreId,
    /**
     * Select a change, it will be included when partial publish.
     */
    updateSelect_ByStoreId_ByChangeId,
    /**
     * Unselect a change, it will not be included when partial publish.
     */
    updateUnselect_ByStoreId_ByChangeId,
    /**
     * Select all changes by criteria
     */
    updateCatalogChangeSelectAllByCriteria_ByStoreId
  };
}

// src/generated-admin/CategoryAdminApi.ts
var import_sdk10 = require("@accelbyte/sdk");

// src/generated-admin/endpoints/CategoryAdmin$.ts
var import_sdk9 = require("@accelbyte/sdk");

// src/generated-definitions/BasicCategoryInfoArray.ts
var import_zod30 = require("zod");

// src/generated-definitions/BasicCategoryInfo.ts
var import_zod29 = require("zod");
var BasicCategoryInfo = import_zod29.z.object({
  categoryPath: import_zod29.z.string(),
  createdAt: import_zod29.z.string(),
  namespace: import_zod29.z.string(),
  parentCategoryPath: import_zod29.z.string(),
  root: import_zod29.z.boolean().nullish(),
  updatedAt: import_zod29.z.string()
});

// src/generated-definitions/BasicCategoryInfoArray.ts
var BasicCategoryInfoArray = import_zod30.z.array(BasicCategoryInfo);

// src/generated-definitions/FullCategoryInfo.ts
var import_zod31 = require("zod");
var FullCategoryInfo = import_zod31.z.object({
  categoryPath: import_zod31.z.string(),
  createdAt: import_zod31.z.string(),
  localizationDisplayNames: import_zod31.z.record(import_zod31.z.string()),
  namespace: import_zod31.z.string(),
  parentCategoryPath: import_zod31.z.string(),
  root: import_zod31.z.boolean().nullish(),
  updatedAt: import_zod31.z.string()
});

// src/generated-definitions/FullCategoryInfoArray.ts
var import_zod32 = require("zod");
var FullCategoryInfoArray = import_zod32.z.array(FullCategoryInfo);

// src/generated-admin/endpoints/CategoryAdmin$.ts
var CategoryAdmin$ = class {
  // @ts-ignore
  // prettier-ignore
  constructor(axiosInstance, namespace, useSchemaValidation = true) {
    this.axiosInstance = axiosInstance;
    this.namespace = namespace;
    this.useSchemaValidation = useSchemaValidation;
  }
  /**
   * This API is used to get root categories.&lt;p&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: root category data&lt;/li&gt;&lt;/ul&gt;
   */
  getCategories(queryParams) {
    const params = { ...queryParams };
    const url = "/platform/admin/namespaces/{namespace}/categories".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.get(url, { params });
    return import_sdk9.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, FullCategoryInfoArray, "FullCategoryInfoArray");
  }
  /**
   * This API is used to create category.&lt;p&gt;A category is a path separated by &#34;/&#34;. A category also has localized display names. Example:&lt;p&gt;&lt;pre&gt;&lt;code&gt;{ &#34;categoryPath&#34;: &#34;/games&#34;, &#34;localizationDisplayNames&#34;: \{&#34;en&#34; : &#34;Games&#34;} }&lt;/code&gt;&lt;/pre&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: created category data&lt;/li&gt;&lt;/ul&gt;
   */
  createCategory(data, queryParams) {
    const params = { ...queryParams };
    const url = "/platform/admin/namespaces/{namespace}/categories".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.post(url, data, { params });
    return import_sdk9.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, FullCategoryInfo, "FullCategoryInfo");
  }
  /**
   * This API is used to list all categories&#39; basic info of a store ordered by category path.&lt;p&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: list of categories&#39; paths&lt;/li&gt;&lt;/ul&gt;
   */
  getCategoriesBasic(queryParams) {
    const params = { ...queryParams };
    const url = "/platform/admin/namespaces/{namespace}/categories/basic".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.get(url, { params });
    return import_sdk9.Validate.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      BasicCategoryInfoArray,
      "BasicCategoryInfoArray"
    );
  }
  /**
   * This API is used to delete category by category path. &lt;p&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: the deleted category data&lt;/li&gt;&lt;/ul&gt;
   */
  deleteCategory_ByCategoryPath(categoryPath, queryParams) {
    const params = { ...queryParams };
    const url = "/platform/admin/namespaces/{namespace}/categories/{categoryPath}".replace("{namespace}", this.namespace).replace("{categoryPath}", categoryPath);
    const resultPromise = this.axiosInstance.delete(url, { params });
    return import_sdk9.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, FullCategoryInfo, "FullCategoryInfo");
  }
  /**
   * This API is used to get category by category path.&lt;p&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: category data&lt;/li&gt;&lt;/ul&gt;
   */
  getCategory_ByCategoryPath(categoryPath, queryParams) {
    const params = { ...queryParams };
    const url = "/platform/admin/namespaces/{namespace}/categories/{categoryPath}".replace("{namespace}", this.namespace).replace("{categoryPath}", categoryPath);
    const resultPromise = this.axiosInstance.get(url, { params });
    return import_sdk9.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, FullCategoryInfo, "FullCategoryInfo");
  }
  /**
   * This API is used to update category. &lt;p&gt; The category update data is a category object, example as:&lt;pre&gt;&lt;code&gt;{ &#34;storeId&#34;: &#34;store-id&#34;, &#34;localizationDisplayNames&#34;: {&#34;en&#34; : &#34;Games&#34;} }&lt;/code&gt;&lt;/pre&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: the updated category data&lt;/li&gt;&lt;/ul&gt;
   */
  updateCategory_ByCategoryPath(categoryPath, data, queryParams) {
    const params = { ...queryParams };
    const url = "/platform/admin/namespaces/{namespace}/categories/{categoryPath}".replace("{namespace}", this.namespace).replace("{categoryPath}", categoryPath);
    const resultPromise = this.axiosInstance.put(url, data, { params });
    return import_sdk9.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, FullCategoryInfo, "FullCategoryInfo");
  }
  /**
   * This API is used to get child categories by category path.&lt;p&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: list of child categories data&lt;/li&gt;&lt;/ul&gt;
   */
  getChildren_ByCategoryPath(categoryPath, queryParams) {
    const params = { ...queryParams };
    const url = "/platform/admin/namespaces/{namespace}/categories/{categoryPath}/children".replace("{namespace}", this.namespace).replace("{categoryPath}", categoryPath);
    const resultPromise = this.axiosInstance.get(url, { params });
    return import_sdk9.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, FullCategoryInfoArray, "FullCategoryInfoArray");
  }
  /**
   * This API is used to get descendant categories by category path.&lt;p&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: list of descendant categories data&lt;/li&gt;&lt;/ul&gt;
   */
  getDescendants_ByCategoryPath(categoryPath, queryParams) {
    const params = { ...queryParams };
    const url = "/platform/admin/namespaces/{namespace}/categories/{categoryPath}/descendants".replace("{namespace}", this.namespace).replace("{categoryPath}", categoryPath);
    const resultPromise = this.axiosInstance.get(url, { params });
    return import_sdk9.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, FullCategoryInfoArray, "FullCategoryInfoArray");
  }
};

// src/generated-admin/CategoryAdminApi.ts
function CategoryAdminApi(sdk, args) {
  const sdkAssembly = sdk.assembly();
  const namespace = args?.coreConfig?.namespace ?? sdkAssembly.coreConfig.namespace;
  const useSchemaValidation = args?.coreConfig?.useSchemaValidation ?? sdkAssembly.coreConfig.useSchemaValidation;
  let axiosInstance = sdkAssembly.axiosInstance;
  const requestConfigOverrides = args?.axiosConfig?.request;
  const baseURLOverride = args?.coreConfig?.baseURL;
  const interceptorsOverride = args?.axiosConfig?.interceptors ?? [];
  if (requestConfigOverrides || baseURLOverride || interceptorsOverride.length > 0) {
    const requestConfig = import_sdk10.ApiUtils.mergeAxiosConfigs(sdkAssembly.axiosInstance.defaults, {
      ...baseURLOverride ? { baseURL: baseURLOverride } : {},
      ...requestConfigOverrides
    });
    axiosInstance = import_sdk10.Network.create(requestConfig);
    for (const interceptor of interceptorsOverride) {
      if (interceptor.type === "request") {
        axiosInstance.interceptors.request.use(interceptor.onRequest, interceptor.onError);
      }
      if (interceptor.type === "response") {
        axiosInstance.interceptors.response.use(interceptor.onSuccess, interceptor.onError);
      }
    }
  }
  async function getCategories(queryParams) {
    const $ = new CategoryAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getCategories(queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function createCategory(data, queryParams) {
    const $ = new CategoryAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.createCategory(data, queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getCategoriesBasic(queryParams) {
    const $ = new CategoryAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getCategoriesBasic(queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function deleteCategory_ByCategoryPath(categoryPath, queryParams) {
    const $ = new CategoryAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.deleteCategory_ByCategoryPath(categoryPath, queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getCategory_ByCategoryPath(categoryPath, queryParams) {
    const $ = new CategoryAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getCategory_ByCategoryPath(categoryPath, queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function updateCategory_ByCategoryPath(categoryPath, data, queryParams) {
    const $ = new CategoryAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.updateCategory_ByCategoryPath(categoryPath, data, queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getChildren_ByCategoryPath(categoryPath, queryParams) {
    const $ = new CategoryAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getChildren_ByCategoryPath(categoryPath, queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getDescendants_ByCategoryPath(categoryPath, queryParams) {
    const $ = new CategoryAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getDescendants_ByCategoryPath(categoryPath, queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  return {
    /**
     * This API is used to get root categories.&lt;p&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: root category data&lt;/li&gt;&lt;/ul&gt;
     */
    getCategories,
    /**
     * This API is used to create category.&lt;p&gt;A category is a path separated by &#34;/&#34;. A category also has localized display names. Example:&lt;p&gt;&lt;pre&gt;&lt;code&gt;{ &#34;categoryPath&#34;: &#34;/games&#34;, &#34;localizationDisplayNames&#34;: \{&#34;en&#34; : &#34;Games&#34;} }&lt;/code&gt;&lt;/pre&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: created category data&lt;/li&gt;&lt;/ul&gt;
     */
    createCategory,
    /**
     * This API is used to list all categories&#39; basic info of a store ordered by category path.&lt;p&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: list of categories&#39; paths&lt;/li&gt;&lt;/ul&gt;
     */
    getCategoriesBasic,
    /**
     * This API is used to delete category by category path. &lt;p&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: the deleted category data&lt;/li&gt;&lt;/ul&gt;
     */
    deleteCategory_ByCategoryPath,
    /**
     * This API is used to get category by category path.&lt;p&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: category data&lt;/li&gt;&lt;/ul&gt;
     */
    getCategory_ByCategoryPath,
    /**
     * This API is used to update category. &lt;p&gt; The category update data is a category object, example as:&lt;pre&gt;&lt;code&gt;{ &#34;storeId&#34;: &#34;store-id&#34;, &#34;localizationDisplayNames&#34;: {&#34;en&#34; : &#34;Games&#34;} }&lt;/code&gt;&lt;/pre&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: the updated category data&lt;/li&gt;&lt;/ul&gt;
     */
    updateCategory_ByCategoryPath,
    /**
     * This API is used to get child categories by category path.&lt;p&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: list of child categories data&lt;/li&gt;&lt;/ul&gt;
     */
    getChildren_ByCategoryPath,
    /**
     * This API is used to get descendant categories by category path.&lt;p&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: list of descendant categories data&lt;/li&gt;&lt;/ul&gt;
     */
    getDescendants_ByCategoryPath
  };
}

// src/generated-admin/ClawbackAdminApi.ts
var import_sdk12 = require("@accelbyte/sdk");

// src/generated-admin/endpoints/ClawbackAdmin$.ts
var import_sdk11 = require("@accelbyte/sdk");

// src/generated-definitions/ClawbackInfo.ts
var import_zod33 = require("zod");
var ClawbackInfo = import_zod33.z.object({
  createdAt: import_zod33.z.string().nullish(),
  dryRun: import_zod33.z.boolean().nullish(),
  eventContent: import_zod33.z.record(import_zod33.z.any()).nullish(),
  eventId: import_zod33.z.string().nullish(),
  eventType: import_zod33.z.string().nullish(),
  externalOrderId: import_zod33.z.string().nullish(),
  feedbackContent: import_zod33.z.record(import_zod33.z.any()).nullish(),
  feedbackStatus: import_zod33.z.enum(["FAIL", "INIT", "SUCCESS"]).nullish(),
  feedbackStatusReason: import_zod33.z.string().nullish(),
  id: import_zod33.z.string(),
  namespace: import_zod33.z.string(),
  platform: import_zod33.z.string().nullish(),
  processId: import_zod33.z.string().nullish(),
  status: import_zod33.z.enum(["FAIL", "IGNORED", "INIT", "SUCCESS"]).nullish(),
  statusReason: import_zod33.z.string().nullish(),
  updatedAt: import_zod33.z.string().nullish(),
  userId: import_zod33.z.string().nullish()
});

// src/generated-definitions/IapClawbackPagingSlicedResult.ts
var import_zod34 = require("zod");
var IapClawbackPagingSlicedResult = import_zod34.z.object({ data: import_zod34.z.array(ClawbackInfo), paging: Paging.nullish() });

// src/generated-admin/endpoints/ClawbackAdmin$.ts
var ClawbackAdmin$ = class {
  // @ts-ignore
  // prettier-ignore
  constructor(axiosInstance, namespace, useSchemaValidation = true) {
    this.axiosInstance = axiosInstance;
    this.namespace = namespace;
    this.useSchemaValidation = useSchemaValidation;
  }
  /**
   * Query clawback history.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: paginated clawback history&lt;/li&gt;&lt;/ul&gt;
   */
  getIapClawbackHistories(queryParams) {
    const params = { limit: 20, ...queryParams };
    const url = "/platform/admin/namespaces/{namespace}/iap/clawback/histories".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.get(url, { params });
    return import_sdk11.Validate.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      IapClawbackPagingSlicedResult,
      "IapClawbackPagingSlicedResult"
    );
  }
  /**
   * Mock Sync PlayStation Clawback event..
   */
  createIapClawbackPlaystationMock(data) {
    const params = {};
    const url = "/platform/admin/namespaces/{namespace}/iap/clawback/playstation/mock".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.post(url, data, { params });
    return import_sdk11.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, ClawbackInfo, "ClawbackInfo");
  }
};

// src/generated-admin/ClawbackAdminApi.ts
function ClawbackAdminApi(sdk, args) {
  const sdkAssembly = sdk.assembly();
  const namespace = args?.coreConfig?.namespace ?? sdkAssembly.coreConfig.namespace;
  const useSchemaValidation = args?.coreConfig?.useSchemaValidation ?? sdkAssembly.coreConfig.useSchemaValidation;
  let axiosInstance = sdkAssembly.axiosInstance;
  const requestConfigOverrides = args?.axiosConfig?.request;
  const baseURLOverride = args?.coreConfig?.baseURL;
  const interceptorsOverride = args?.axiosConfig?.interceptors ?? [];
  if (requestConfigOverrides || baseURLOverride || interceptorsOverride.length > 0) {
    const requestConfig = import_sdk12.ApiUtils.mergeAxiosConfigs(sdkAssembly.axiosInstance.defaults, {
      ...baseURLOverride ? { baseURL: baseURLOverride } : {},
      ...requestConfigOverrides
    });
    axiosInstance = import_sdk12.Network.create(requestConfig);
    for (const interceptor of interceptorsOverride) {
      if (interceptor.type === "request") {
        axiosInstance.interceptors.request.use(interceptor.onRequest, interceptor.onError);
      }
      if (interceptor.type === "response") {
        axiosInstance.interceptors.response.use(interceptor.onSuccess, interceptor.onError);
      }
    }
  }
  async function getIapClawbackHistories(queryParams) {
    const $ = new ClawbackAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getIapClawbackHistories(queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function createIapClawbackPlaystationMock(data) {
    const $ = new ClawbackAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.createIapClawbackPlaystationMock(data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  return {
    /**
     * Query clawback history.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: paginated clawback history&lt;/li&gt;&lt;/ul&gt;
     */
    getIapClawbackHistories,
    /**
     * Mock Sync PlayStation Clawback event..
     */
    createIapClawbackPlaystationMock
  };
}

// src/generated-admin/CurrencyAdminApi.ts
var import_sdk14 = require("@accelbyte/sdk");

// src/generated-admin/endpoints/CurrencyAdmin$.ts
var import_sdk13 = require("@accelbyte/sdk");

// src/generated-definitions/CurrencyConfig.ts
var import_zod35 = require("zod");
var CurrencyConfig = import_zod35.z.object({ currencySymbol: import_zod35.z.string() });

// src/generated-definitions/CurrencyInfo.ts
var import_zod36 = require("zod");
var CurrencyInfo = import_zod36.z.object({
  createdAt: import_zod36.z.string(),
  currencyCode: import_zod36.z.string(),
  currencySymbol: import_zod36.z.string(),
  currencyType: import_zod36.z.enum(["REAL", "VIRTUAL"]),
  decimals: import_zod36.z.number().int(),
  localizationDescriptions: import_zod36.z.record(import_zod36.z.string()).nullish(),
  namespace: import_zod36.z.string(),
  updatedAt: import_zod36.z.string()
});

// src/generated-definitions/CurrencyInfoArray.ts
var import_zod37 = require("zod");
var CurrencyInfoArray = import_zod37.z.array(CurrencyInfo);

// src/generated-definitions/CurrencySummary.ts
var import_zod38 = require("zod");
var CurrencySummary = import_zod38.z.object({
  currencyCode: import_zod38.z.string(),
  currencySymbol: import_zod38.z.string(),
  currencyType: import_zod38.z.enum(["REAL", "VIRTUAL"]),
  decimals: import_zod38.z.number().int(),
  namespace: import_zod38.z.string()
});

// src/generated-admin/endpoints/CurrencyAdmin$.ts
var CurrencyAdmin$ = class {
  // @ts-ignore
  // prettier-ignore
  constructor(axiosInstance, namespace, useSchemaValidation = true) {
    this.axiosInstance = axiosInstance;
    this.namespace = namespace;
    this.useSchemaValidation = useSchemaValidation;
  }
  /**
   * List currencies of a namespace.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: Currency List&lt;/li&gt;&lt;/ul&gt;
   */
  getCurrencies(queryParams) {
    const params = { ...queryParams };
    const url = "/platform/admin/namespaces/{namespace}/currencies".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.get(url, { params });
    return import_sdk13.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, CurrencyInfoArray, "CurrencyInfoArray");
  }
  /**
   * Create a currency.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: created currency&lt;/li&gt;&lt;/ul&gt;
   */
  createCurrency(data) {
    const params = {};
    const url = "/platform/admin/namespaces/{namespace}/currencies".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.post(url, data, { params });
    return import_sdk13.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, CurrencyInfo, "CurrencyInfo");
  }
  /**
   * Delete a currency by currency code.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: &lt;/li&gt;&lt;/ul&gt;
   */
  deleteCurrency_ByCurrencyCode(currencyCode) {
    const params = {};
    const url = "/platform/admin/namespaces/{namespace}/currencies/{currencyCode}".replace("{namespace}", this.namespace).replace("{currencyCode}", currencyCode);
    const resultPromise = this.axiosInstance.delete(url, { params });
    return import_sdk13.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, CurrencyInfo, "CurrencyInfo");
  }
  /**
   * Update a currency by currency code.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: updated currency&lt;/li&gt;&lt;/ul&gt;
   */
  updateCurrency_ByCurrencyCode(currencyCode, data) {
    const params = {};
    const url = "/platform/admin/namespaces/{namespace}/currencies/{currencyCode}".replace("{namespace}", this.namespace).replace("{currencyCode}", currencyCode);
    const resultPromise = this.axiosInstance.put(url, data, { params });
    return import_sdk13.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, CurrencyInfo, "CurrencyInfo");
  }
  /**
   * &lt;b&gt;[SERVICE COMMUNICATION ONLY]&lt;/b&gt; Get currency config by code.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: simplified Currency&lt;/li&gt;&lt;/ul&gt;
   */
  getConfig_ByCurrencyCode(currencyCode) {
    const params = {};
    const url = "/platform/admin/namespaces/{namespace}/currencies/{currencyCode}/config".replace("{namespace}", this.namespace).replace("{currencyCode}", currencyCode);
    const resultPromise = this.axiosInstance.get(url, { params });
    return import_sdk13.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, CurrencyConfig, "CurrencyConfig");
  }
  /**
   * Get currency summary by code.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: simplified Currency&lt;/li&gt;&lt;/ul&gt;
   */
  getSummary_ByCurrencyCode(currencyCode) {
    const params = {};
    const url = "/platform/admin/namespaces/{namespace}/currencies/{currencyCode}/summary".replace("{namespace}", this.namespace).replace("{currencyCode}", currencyCode);
    const resultPromise = this.axiosInstance.get(url, { params });
    return import_sdk13.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, CurrencySummary, "CurrencySummary");
  }
};

// src/generated-admin/CurrencyAdminApi.ts
function CurrencyAdminApi(sdk, args) {
  const sdkAssembly = sdk.assembly();
  const namespace = args?.coreConfig?.namespace ?? sdkAssembly.coreConfig.namespace;
  const useSchemaValidation = args?.coreConfig?.useSchemaValidation ?? sdkAssembly.coreConfig.useSchemaValidation;
  let axiosInstance = sdkAssembly.axiosInstance;
  const requestConfigOverrides = args?.axiosConfig?.request;
  const baseURLOverride = args?.coreConfig?.baseURL;
  const interceptorsOverride = args?.axiosConfig?.interceptors ?? [];
  if (requestConfigOverrides || baseURLOverride || interceptorsOverride.length > 0) {
    const requestConfig = import_sdk14.ApiUtils.mergeAxiosConfigs(sdkAssembly.axiosInstance.defaults, {
      ...baseURLOverride ? { baseURL: baseURLOverride } : {},
      ...requestConfigOverrides
    });
    axiosInstance = import_sdk14.Network.create(requestConfig);
    for (const interceptor of interceptorsOverride) {
      if (interceptor.type === "request") {
        axiosInstance.interceptors.request.use(interceptor.onRequest, interceptor.onError);
      }
      if (interceptor.type === "response") {
        axiosInstance.interceptors.response.use(interceptor.onSuccess, interceptor.onError);
      }
    }
  }
  async function getCurrencies(queryParams) {
    const $ = new CurrencyAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getCurrencies(queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function createCurrency(data) {
    const $ = new CurrencyAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.createCurrency(data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function deleteCurrency_ByCurrencyCode(currencyCode) {
    const $ = new CurrencyAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.deleteCurrency_ByCurrencyCode(currencyCode);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function updateCurrency_ByCurrencyCode(currencyCode, data) {
    const $ = new CurrencyAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.updateCurrency_ByCurrencyCode(currencyCode, data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getConfig_ByCurrencyCode(currencyCode) {
    const $ = new CurrencyAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getConfig_ByCurrencyCode(currencyCode);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getSummary_ByCurrencyCode(currencyCode) {
    const $ = new CurrencyAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getSummary_ByCurrencyCode(currencyCode);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  return {
    /**
     * List currencies of a namespace.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: Currency List&lt;/li&gt;&lt;/ul&gt;
     */
    getCurrencies,
    /**
     * Create a currency.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: created currency&lt;/li&gt;&lt;/ul&gt;
     */
    createCurrency,
    /**
     * Delete a currency by currency code.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: &lt;/li&gt;&lt;/ul&gt;
     */
    deleteCurrency_ByCurrencyCode,
    /**
     * Update a currency by currency code.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: updated currency&lt;/li&gt;&lt;/ul&gt;
     */
    updateCurrency_ByCurrencyCode,
    /**
     * &lt;b&gt;[SERVICE COMMUNICATION ONLY]&lt;/b&gt; Get currency config by code.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: simplified Currency&lt;/li&gt;&lt;/ul&gt;
     */
    getConfig_ByCurrencyCode,
    /**
     * Get currency summary by code.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: simplified Currency&lt;/li&gt;&lt;/ul&gt;
     */
    getSummary_ByCurrencyCode
  };
}

// src/generated-admin/DlcAdminApi.ts
var import_sdk16 = require("@accelbyte/sdk");

// src/generated-admin/endpoints/DlcAdmin$.ts
var import_sdk15 = require("@accelbyte/sdk");
var import_zod58 = require("zod");

// src/generated-definitions/DlcItemConfigInfo.ts
var import_zod43 = require("zod");

// src/generated-definitions/DlcItem.ts
var import_zod42 = require("zod");

// src/generated-definitions/PlatformReward.ts
var import_zod41 = require("zod");

// src/generated-definitions/PlatformRewardCurrency.ts
var import_zod39 = require("zod");
var PlatformRewardCurrency = import_zod39.z.object({ currencyCode: import_zod39.z.string(), namespace: import_zod39.z.string() });

// src/generated-definitions/PlatformRewardItem.ts
var import_zod40 = require("zod");
var PlatformRewardItem = import_zod40.z.object({
  itemId: import_zod40.z.string().nullish(),
  itemName: import_zod40.z.string().nullish(),
  itemSku: import_zod40.z.string().nullish(),
  itemType: import_zod40.z.string().nullish()
});

// src/generated-definitions/PlatformReward.ts
var PlatformReward = import_zod41.z.object({
  currency: PlatformRewardCurrency.nullish(),
  item: PlatformRewardItem.nullish(),
  quantity: import_zod41.z.number().int().nullish(),
  type: import_zod41.z.enum(["CURRENCY", "ITEM"]).nullish()
});

// src/generated-definitions/DlcItem.ts
var DlcItem = import_zod42.z.object({ id: import_zod42.z.string().nullish(), rewards: import_zod42.z.array(PlatformReward).nullish() });

// src/generated-definitions/DlcItemConfigInfo.ts
var DlcItemConfigInfo = import_zod43.z.object({ data: import_zod43.z.array(DlcItem).nullish() });

// src/generated-definitions/PlatformDlcConfigInfo.ts
var import_zod45 = require("zod");

// src/generated-definitions/PlatformDlcEntry.ts
var import_zod44 = require("zod");
var PlatformDlcEntry = import_zod44.z.object({
  platform: import_zod44.z.enum(["EPICGAMES", "OCULUS", "PSN", "STEAM", "XBOX"]).nullish(),
  platformDlcIdMap: import_zod44.z.record(import_zod44.z.string()).nullish()
});

// src/generated-definitions/PlatformDlcConfigInfo.ts
var PlatformDlcConfigInfo = import_zod45.z.object({ data: import_zod45.z.array(PlatformDlcEntry).nullish() });

// src/generated-definitions/UserDlc.ts
var import_zod55 = require("zod");

// src/generated-definitions/DlcRecord.ts
var import_zod54 = require("zod");

// src/generated-definitions/EntitlementOriginSyncResult.ts
var import_zod47 = require("zod");

// src/generated-definitions/RewardMigrationResult.ts
var import_zod46 = require("zod");
var RewardMigrationResult = import_zod46.z.object({
  itemId: import_zod46.z.string().nullish(),
  quantity: import_zod46.z.number().int().nullish(),
  reason: import_zod46.z.string().nullish(),
  sku: import_zod46.z.string().nullish(),
  status: import_zod46.z.enum(["FAIL", "SUCCESS"]).nullish(),
  syncedCount: import_zod46.z.number().int().nullish(),
  syncedEntitlementIds: import_zod46.z.array(import_zod46.z.string()).nullish()
});

// src/generated-definitions/EntitlementOriginSyncResult.ts
var EntitlementOriginSyncResult = import_zod47.z.object({
  reason: import_zod47.z.string().nullish(),
  reward: PlatformReward.nullish(),
  summary: import_zod47.z.array(RewardMigrationResult).nullish()
});

// src/generated-definitions/RevocationResult.ts
var import_zod51 = require("zod");

// src/generated-definitions/CreditRevocation.ts
var import_zod48 = require("zod");
var CreditRevocation = import_zod48.z.object({
  amount: import_zod48.z.number().int().nullish(),
  balanceOrigin: import_zod48.z.string().nullish(),
  currencyCode: import_zod48.z.string().nullish(),
  customRevocation: import_zod48.z.record(import_zod48.z.any()).nullish(),
  reason: import_zod48.z.string().nullish(),
  revocationStrategy: import_zod48.z.string().nullish(),
  skipped: import_zod48.z.boolean().nullish(),
  status: import_zod48.z.enum(["FAIL", "SUCCESS"]).nullish(),
  walletId: import_zod48.z.string().nullish()
});

// src/generated-definitions/EntitlementRevocation.ts
var import_zod49 = require("zod");
var EntitlementRevocation = import_zod49.z.object({
  customRevocation: import_zod49.z.record(import_zod49.z.any()).nullish(),
  entitlementId: import_zod49.z.string().nullish(),
  itemId: import_zod49.z.string().nullish(),
  itemSku: import_zod49.z.string().nullish(),
  quantity: import_zod49.z.number().int().nullish(),
  reason: import_zod49.z.string().nullish(),
  revocationStrategy: import_zod49.z.string().nullish(),
  skipped: import_zod49.z.boolean().nullish(),
  status: import_zod49.z.enum(["FAIL", "SUCCESS"]).nullish()
});

// src/generated-definitions/ItemRevocation.ts
var import_zod50 = require("zod");
var ItemRevocation = import_zod50.z.lazy(
  () => import_zod50.z.object({
    creditRevocations: import_zod50.z.array(CreditRevocation).nullish(),
    customRevocation: import_zod50.z.record(import_zod50.z.any()).nullish(),
    entitlementOrigin: import_zod50.z.enum(["Epic", "GooglePlay", "IOS", "Nintendo", "Oculus", "Other", "Playstation", "Steam", "System", "Twitch", "Xbox"]).nullish(),
    entitlementRevocations: import_zod50.z.array(EntitlementRevocation).nullish(),
    itemId: import_zod50.z.string().nullish(),
    itemRevocations: import_zod50.z.array(ItemRevocation).nullish(),
    itemSku: import_zod50.z.string().nullish(),
    itemType: import_zod50.z.enum(["APP", "BUNDLE", "CODE", "COINS", "EXTENSION", "INGAMEITEM", "LOOTBOX", "MEDIA", "OPTIONBOX", "SEASON", "SUBSCRIPTION"]).nullish(),
    quantity: import_zod50.z.number().int().nullish(),
    reason: import_zod50.z.string().nullish(),
    skipped: import_zod50.z.boolean().nullish(),
    status: import_zod50.z.enum(["FAIL", "SUCCESS"]).nullish(),
    strategy: import_zod50.z.string().nullish()
  })
);

// src/generated-definitions/RevocationResult.ts
var RevocationResult = import_zod51.z.object({
  creditRevocations: import_zod51.z.array(CreditRevocation).nullish(),
  entitlementRevocations: import_zod51.z.array(EntitlementRevocation).nullish(),
  id: import_zod51.z.string(),
  itemRevocations: import_zod51.z.array(ItemRevocation).nullish(),
  status: import_zod51.z.enum(["FAIL", "SUCCESS"])
});

// src/generated-definitions/RevokeResult.ts
var import_zod53 = require("zod");

// src/generated-definitions/RevokeItemSummary.ts
var import_zod52 = require("zod");
var RevokeItemSummary = import_zod52.z.object({
  itemId: import_zod52.z.string().nullish(),
  itemSku: import_zod52.z.string().nullish(),
  itemType: import_zod52.z.string().nullish(),
  revokeStatus: import_zod52.z.enum(["COMPLETED", "SKIPPED"]).nullish()
});

// src/generated-definitions/RevokeResult.ts
var RevokeResult = import_zod53.z.object({
  revokeItemSummaries: import_zod53.z.array(RevokeItemSummary).nullish(),
  reward: PlatformReward.nullish(),
  status: import_zod53.z.enum(["COMPLETED", "SKIPPED"]).nullish()
});

// src/generated-definitions/DlcRecord.ts
var DlcRecord = import_zod54.z.object({
  entitlementOriginSyncResult: import_zod54.z.array(EntitlementOriginSyncResult).nullish(),
  entitlementOriginSyncStatus: import_zod54.z.enum(["NOT_SYNCED", "SYNCED", "SYNCED_FAILED"]).nullish(),
  id: import_zod54.z.string().nullish(),
  metadata: import_zod54.z.record(import_zod54.z.any()).nullish(),
  obtainedAt: import_zod54.z.string().nullish(),
  revocationResult: RevocationResult.nullish(),
  revokeResults: import_zod54.z.array(RevokeResult).nullish(),
  revokedAt: import_zod54.z.string().nullish(),
  rewards: import_zod54.z.array(PlatformReward).nullish(),
  sources: import_zod54.z.array(import_zod54.z.string()).nullish(),
  status: import_zod54.z.enum(["FULFILLED", "REVOKED", "REVOKE_FAILED"]).nullish(),
  transactionId: import_zod54.z.string().nullish(),
  version: import_zod54.z.number().int().nullish()
});

// src/generated-definitions/UserDlc.ts
var UserDlc = import_zod55.z.object({
  createdAt: import_zod55.z.string().nullish(),
  dlcs: import_zod55.z.array(DlcRecord).nullish(),
  id: import_zod55.z.string().nullish(),
  namespace: import_zod55.z.string().nullish(),
  platform: import_zod55.z.enum(["EPICGAMES", "OCULUS", "PSN", "STEAM", "XBOX"]).nullish(),
  rvn: import_zod55.z.number().int().nullish(),
  updatedAt: import_zod55.z.string().nullish(),
  userId: import_zod55.z.string().nullish()
});

// src/generated-definitions/UserDlcRecordArray.ts
var import_zod57 = require("zod");

// src/generated-definitions/UserDlcRecord.ts
var import_zod56 = require("zod");
var UserDlcRecord = import_zod56.z.object({
  entitlementOriginSyncResult: import_zod56.z.array(EntitlementOriginSyncResult).nullish(),
  entitlementOriginSyncStatus: import_zod56.z.enum(["NOT_SYNCED", "SYNCED", "SYNCED_FAILED"]).nullish(),
  id: import_zod56.z.string().nullish(),
  metadata: import_zod56.z.record(import_zod56.z.any()).nullish(),
  namespace: import_zod56.z.string().nullish(),
  obtainedAt: import_zod56.z.string().nullish(),
  platform: import_zod56.z.enum(["EPICGAMES", "OCULUS", "PSN", "STEAM", "XBOX"]).nullish(),
  revocationResult: RevocationResult.nullish(),
  revokeResults: import_zod56.z.array(RevokeResult).nullish(),
  revokedAt: import_zod56.z.string().nullish(),
  rewards: import_zod56.z.array(PlatformReward).nullish(),
  sources: import_zod56.z.array(import_zod56.z.string()).nullish(),
  status: import_zod56.z.enum(["FULFILLED", "REVOKED", "REVOKE_FAILED"]).nullish(),
  transactionId: import_zod56.z.string().nullish(),
  userId: import_zod56.z.string().nullish(),
  version: import_zod56.z.number().int().nullish()
});

// src/generated-definitions/UserDlcRecordArray.ts
var UserDlcRecordArray = import_zod57.z.array(UserDlcRecord);

// src/generated-admin/endpoints/DlcAdmin$.ts
var DlcAdmin$ = class {
  // @ts-ignore
  // prettier-ignore
  constructor(axiosInstance, namespace, useSchemaValidation = true) {
    this.axiosInstance = axiosInstance;
    this.namespace = namespace;
    this.useSchemaValidation = useSchemaValidation;
  }
  /**
   * delete a DLC item config.
   */
  deleteDlcConfigItem() {
    const params = {};
    const url = "/platform/admin/namespaces/{namespace}/dlc/config/item".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.delete(url, { params });
    return import_sdk15.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, import_zod58.z.unknown(), "z.unknown()");
  }
  /**
   * Get DLC item config.
   */
  getDlcConfigItem() {
    const params = {};
    const url = "/platform/admin/namespaces/{namespace}/dlc/config/item".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.get(url, { params });
    return import_sdk15.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, DlcItemConfigInfo, "DlcItemConfigInfo");
  }
  /**
   * Update DLC item config. Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: updated DLC item config&lt;/li&gt;&lt;/ul&gt;
   */
  updateDlcConfigItem(data) {
    const params = {};
    const url = "/platform/admin/namespaces/{namespace}/dlc/config/item".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.put(url, data, { params });
    return import_sdk15.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, DlcItemConfigInfo, "DlcItemConfigInfo");
  }
  /**
   * Get user dlc by platform.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: user dlc&lt;/li&gt;&lt;/ul&gt;
   */
  getDlc_ByUserId(userId, queryParams) {
    const params = { ...queryParams };
    const url = "/platform/admin/namespaces/{namespace}/users/{userId}/dlc".replace("{namespace}", this.namespace).replace("{userId}", userId);
    const resultPromise = this.axiosInstance.get(url, { params });
    return import_sdk15.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, UserDlc, "UserDlc");
  }
  /**
   * delete a Platform DLC config.
   */
  deleteDlcConfigPlatformMap() {
    const params = {};
    const url = "/platform/admin/namespaces/{namespace}/dlc/config/platformMap".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.delete(url, { params });
    return import_sdk15.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, import_zod58.z.unknown(), "z.unknown()");
  }
  /**
   * Get Platform DLC config.
   */
  getDlcConfigPlatformMap() {
    const params = {};
    const url = "/platform/admin/namespaces/{namespace}/dlc/config/platformMap".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.get(url, { params });
    return import_sdk15.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, PlatformDlcConfigInfo, "PlatformDlcConfigInfo");
  }
  /**
   * Update Platform DLC config. Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: updated Platform DLC config&lt;/li&gt;&lt;/ul&gt;&lt;h2&gt;Restrictions for platform dlc map&lt;/h2&gt; 1. Cannot use &lt;b&gt;&#34;.&#34;&lt;/b&gt; as the key name - &lt;pre&gt;{ &#34;data.2&#34;: &#34;value&#34; }&lt;/pre&gt; 2. Cannot use &lt;b&gt;&#34;$&#34;&lt;/b&gt; as the prefix in key names - &lt;pre&gt;{ &#34;$data&#34;: &#34;value&#34; }&lt;/pre&gt;
   */
  updateDlcConfigPlatformMap(data) {
    const params = {};
    const url = "/platform/admin/namespaces/{namespace}/dlc/config/platformMap".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.put(url, data, { params });
    return import_sdk15.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, PlatformDlcConfigInfo, "PlatformDlcConfigInfo");
  }
  /**
   * Get user dlc records.&lt;br&gt;Note: includeAllNamespaces means this endpoint will return user dlcs from all namespace, example scenario isadmin may need to check the user dlcs before unlink a 3rd party account, so the user dlcs should be from all namespaces because unlinking is a platform level action &lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: user dlc&lt;/li&gt;&lt;/ul&gt;
   */
  getDlcRecords_ByUserId(userId, queryParams) {
    const params = { ...queryParams };
    const url = "/platform/admin/namespaces/{namespace}/users/{userId}/dlc/records".replace("{namespace}", this.namespace).replace("{userId}", userId);
    const resultPromise = this.axiosInstance.get(url, { params });
    return import_sdk15.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, UserDlcRecordArray, "UserDlcRecordArray");
  }
};

// src/generated-admin/DlcAdminApi.ts
function DlcAdminApi(sdk, args) {
  const sdkAssembly = sdk.assembly();
  const namespace = args?.coreConfig?.namespace ?? sdkAssembly.coreConfig.namespace;
  const useSchemaValidation = args?.coreConfig?.useSchemaValidation ?? sdkAssembly.coreConfig.useSchemaValidation;
  let axiosInstance = sdkAssembly.axiosInstance;
  const requestConfigOverrides = args?.axiosConfig?.request;
  const baseURLOverride = args?.coreConfig?.baseURL;
  const interceptorsOverride = args?.axiosConfig?.interceptors ?? [];
  if (requestConfigOverrides || baseURLOverride || interceptorsOverride.length > 0) {
    const requestConfig = import_sdk16.ApiUtils.mergeAxiosConfigs(sdkAssembly.axiosInstance.defaults, {
      ...baseURLOverride ? { baseURL: baseURLOverride } : {},
      ...requestConfigOverrides
    });
    axiosInstance = import_sdk16.Network.create(requestConfig);
    for (const interceptor of interceptorsOverride) {
      if (interceptor.type === "request") {
        axiosInstance.interceptors.request.use(interceptor.onRequest, interceptor.onError);
      }
      if (interceptor.type === "response") {
        axiosInstance.interceptors.response.use(interceptor.onSuccess, interceptor.onError);
      }
    }
  }
  async function deleteDlcConfigItem() {
    const $ = new DlcAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.deleteDlcConfigItem();
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getDlcConfigItem() {
    const $ = new DlcAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getDlcConfigItem();
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function updateDlcConfigItem(data) {
    const $ = new DlcAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.updateDlcConfigItem(data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getDlc_ByUserId(userId, queryParams) {
    const $ = new DlcAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getDlc_ByUserId(userId, queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function deleteDlcConfigPlatformMap() {
    const $ = new DlcAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.deleteDlcConfigPlatformMap();
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getDlcConfigPlatformMap() {
    const $ = new DlcAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getDlcConfigPlatformMap();
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function updateDlcConfigPlatformMap(data) {
    const $ = new DlcAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.updateDlcConfigPlatformMap(data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getDlcRecords_ByUserId(userId, queryParams) {
    const $ = new DlcAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getDlcRecords_ByUserId(userId, queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  return {
    /**
     * delete a DLC item config.
     */
    deleteDlcConfigItem,
    /**
     * Get DLC item config.
     */
    getDlcConfigItem,
    /**
     * Update DLC item config. Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: updated DLC item config&lt;/li&gt;&lt;/ul&gt;
     */
    updateDlcConfigItem,
    /**
     * Get user dlc by platform.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: user dlc&lt;/li&gt;&lt;/ul&gt;
     */
    getDlc_ByUserId,
    /**
     * delete a Platform DLC config.
     */
    deleteDlcConfigPlatformMap,
    /**
     * Get Platform DLC config.
     */
    getDlcConfigPlatformMap,
    /**
     * Update Platform DLC config. Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: updated Platform DLC config&lt;/li&gt;&lt;/ul&gt;&lt;h2&gt;Restrictions for platform dlc map&lt;/h2&gt; 1. Cannot use &lt;b&gt;&#34;.&#34;&lt;/b&gt; as the key name - &lt;pre&gt;{ &#34;data.2&#34;: &#34;value&#34; }&lt;/pre&gt; 2. Cannot use &lt;b&gt;&#34;$&#34;&lt;/b&gt; as the prefix in key names - &lt;pre&gt;{ &#34;$data&#34;: &#34;value&#34; }&lt;/pre&gt;
     */
    updateDlcConfigPlatformMap,
    /**
     * Get user dlc records.&lt;br&gt;Note: includeAllNamespaces means this endpoint will return user dlcs from all namespace, example scenario isadmin may need to check the user dlcs before unlink a 3rd party account, so the user dlcs should be from all namespaces because unlinking is a platform level action &lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: user dlc&lt;/li&gt;&lt;/ul&gt;
     */
    getDlcRecords_ByUserId
  };
}

// src/generated-admin/endpoints/EntitlementAdmin$.ts
var import_sdk17 = require("@accelbyte/sdk");

// src/generated-definitions/AppEntitlementInfo.ts
var import_zod68 = require("zod");

// src/generated-definitions/ItemSnapshot.ts
var import_zod67 = require("zod");

// src/generated-definitions/InventoryConfig.ts
var import_zod59 = require("zod");
var InventoryConfig = import_zod59.z.object({
  customAttributes: import_zod59.z.record(import_zod59.z.any()).nullish(),
  serverCustomAttributes: import_zod59.z.record(import_zod59.z.any()).nullish(),
  slotUsed: import_zod59.z.number().int().nullish()
});

// src/generated-definitions/LootBoxConfig.ts
var import_zod62 = require("zod");

// src/generated-definitions/LootBoxReward.ts
var import_zod61 = require("zod");

// src/generated-definitions/BoxItem.ts
var import_zod60 = require("zod");
var BoxItem = import_zod60.z.object({
  count: import_zod60.z.number().int().nullish(),
  duration: import_zod60.z.number().int().nullish(),
  endDate: import_zod60.z.string().nullish(),
  itemId: import_zod60.z.string().nullish(),
  itemSku: import_zod60.z.string().nullish(),
  itemType: import_zod60.z.string().nullish()
});

// src/generated-definitions/LootBoxReward.ts
var LootBoxReward = import_zod61.z.object({
  lootBoxItems: import_zod61.z.array(BoxItem).nullish(),
  name: import_zod61.z.string().nullish(),
  odds: import_zod61.z.number().nullish(),
  type: import_zod61.z.enum(["PROBABILITY_GROUP", "REWARD", "REWARD_GROUP"]).nullish(),
  weight: import_zod61.z.number().int().nullish()
});

// src/generated-definitions/LootBoxConfig.ts
var LootBoxConfig = import_zod62.z.object({
  rewardCount: import_zod62.z.number().int().nullish(),
  rewards: import_zod62.z.array(LootBoxReward).nullish(),
  rollFunction: import_zod62.z.enum(["CUSTOM", "DEFAULT"]).nullish()
});

// src/generated-definitions/OptionBoxConfig.ts
var import_zod63 = require("zod");
var OptionBoxConfig = import_zod63.z.object({ boxItems: import_zod63.z.array(BoxItem).nullish() });

// src/generated-definitions/Recurring.ts
var import_zod64 = require("zod");
var Recurring = import_zod64.z.object({
  cycle: import_zod64.z.enum(["MONTHLY", "QUARTERLY", "WEEKLY", "YEARLY"]),
  fixedFreeDays: import_zod64.z.number().int(),
  fixedTrialCycles: import_zod64.z.number().int(),
  graceDays: import_zod64.z.number().int()
});

// src/generated-definitions/RegionDataItem.ts
var import_zod65 = require("zod");
var RegionDataItem = import_zod65.z.object({
  currencyCode: import_zod65.z.string(),
  currencyNamespace: import_zod65.z.string(),
  currencyType: import_zod65.z.enum(["REAL", "VIRTUAL"]),
  discountAmount: import_zod65.z.number().int().nullish(),
  discountExpireAt: import_zod65.z.string().nullish(),
  discountPercentage: import_zod65.z.number().int().nullish(),
  discountPurchaseAt: import_zod65.z.string().nullish(),
  discountedPrice: import_zod65.z.number().int().nullish(),
  expireAt: import_zod65.z.string().nullish(),
  price: import_zod65.z.number().int().nullish(),
  purchaseAt: import_zod65.z.string().nullish(),
  trialPrice: import_zod65.z.number().int().nullish()
});

// src/generated-definitions/SaleConfig.ts
var import_zod66 = require("zod");
var SaleConfig = import_zod66.z.object({ currencyCode: import_zod66.z.string(), price: import_zod66.z.number().int() });

// src/generated-definitions/ItemSnapshot.ts
var ItemSnapshot = import_zod67.z.object({
  appId: import_zod67.z.string().nullish(),
  appType: import_zod67.z.enum(["DEMO", "DLC", "GAME", "SOFTWARE"]).nullish(),
  baseAppId: import_zod67.z.string().nullish(),
  boothName: import_zod67.z.string().nullish(),
  createdAt: import_zod67.z.string().nullish(),
  description: import_zod67.z.string().nullish(),
  entitlementType: import_zod67.z.enum(["CONSUMABLE", "DURABLE"]),
  features: import_zod67.z.array(import_zod67.z.string()).nullish(),
  flexible: import_zod67.z.boolean().nullish(),
  inventoryConfig: InventoryConfig.nullish(),
  itemId: import_zod67.z.string(),
  itemIds: import_zod67.z.array(import_zod67.z.string()).nullish(),
  itemQty: import_zod67.z.record(import_zod67.z.number().int()).nullish(),
  itemType: import_zod67.z.enum([
    "APP",
    "BUNDLE",
    "CODE",
    "COINS",
    "EXTENSION",
    "INGAMEITEM",
    "LOOTBOX",
    "MEDIA",
    "OPTIONBOX",
    "SEASON",
    "SUBSCRIPTION"
  ]),
  language: import_zod67.z.string(),
  listable: import_zod67.z.boolean().nullish(),
  lootBoxConfig: LootBoxConfig.nullish(),
  maxCount: import_zod67.z.number().int().nullish(),
  maxCountPerUser: import_zod67.z.number().int().nullish(),
  name: import_zod67.z.string(),
  namespace: import_zod67.z.string(),
  optionBoxConfig: OptionBoxConfig.nullish(),
  purchasable: import_zod67.z.boolean().nullish(),
  recurring: Recurring.nullish(),
  region: import_zod67.z.string(),
  regionDataItem: RegionDataItem.nullish(),
  saleConfig: SaleConfig.nullish(),
  seasonType: import_zod67.z.enum(["PASS", "TIER"]).nullish(),
  sectionExclusive: import_zod67.z.boolean().nullish(),
  sellable: import_zod67.z.boolean().nullish(),
  sku: import_zod67.z.string().nullish(),
  stackable: import_zod67.z.boolean().nullish(),
  targetCurrencyCode: import_zod67.z.string().nullish(),
  targetItemId: import_zod67.z.string().nullish(),
  targetNamespace: import_zod67.z.string().nullish(),
  thumbnailUrl: import_zod67.z.string().nullish(),
  title: import_zod67.z.string(),
  updatedAt: import_zod67.z.string().nullish(),
  useCount: import_zod67.z.number().int().nullish()
});

// src/generated-definitions/AppEntitlementInfo.ts
var AppEntitlementInfo = import_zod68.z.object({
  appId: import_zod68.z.string().nullish(),
  appType: import_zod68.z.enum(["DEMO", "DLC", "GAME", "SOFTWARE"]).nullish(),
  collectionId: import_zod68.z.string().nullish(),
  endDate: import_zod68.z.string().nullish(),
  grantedAt: import_zod68.z.string(),
  itemId: import_zod68.z.string().nullish(),
  itemSnapshot: ItemSnapshot.nullish(),
  namespace: import_zod68.z.string(),
  noOrigin: import_zod68.z.boolean().nullish(),
  origin: import_zod68.z.enum(["Epic", "GooglePlay", "IOS", "Nintendo", "Oculus", "Other", "Playstation", "Steam", "System", "Twitch", "Xbox"]).nullish(),
  sku: import_zod68.z.string().nullish(),
  startDate: import_zod68.z.string().nullish(),
  status: import_zod68.z.enum(["ACTIVE", "CONSUMED", "INACTIVE", "REVOKED", "SOLD"]),
  storeId: import_zod68.z.string().nullish(),
  userId: import_zod68.z.string()
});

// src/generated-definitions/AppEntitlementPagingSlicedResult.ts
var import_zod69 = require("zod");
var AppEntitlementPagingSlicedResult = import_zod69.z.object({ data: import_zod69.z.array(AppEntitlementInfo).nullish(), paging: Paging.nullish() });

// src/generated-definitions/BulkEntitlementGrantResult.ts
var import_zod72 = require("zod");

// src/generated-definitions/EntitlementGrantResult.ts
var import_zod71 = require("zod");

// src/generated-definitions/EntitlementGrant.ts
var import_zod70 = require("zod");
var EntitlementGrant = import_zod70.z.object({
  collectionId: import_zod70.z.string().nullish(),
  endDate: import_zod70.z.string().nullish(),
  grantedCode: import_zod70.z.string().nullish(),
  itemId: import_zod70.z.string(),
  itemNamespace: import_zod70.z.string(),
  language: import_zod70.z.string().nullish(),
  metadata: import_zod70.z.record(import_zod70.z.any()).nullish(),
  origin: import_zod70.z.enum(["Epic", "GooglePlay", "IOS", "Nintendo", "Oculus", "Other", "Playstation", "Steam", "System", "Twitch", "Xbox"]).nullish(),
  quantity: import_zod70.z.number().int(),
  region: import_zod70.z.string().nullish(),
  source: import_zod70.z.enum(["ACHIEVEMENT", "GIFT", "IAP", "OTHER", "PROMOTION", "PURCHASE", "REDEEM_CODE", "REFERRAL_BONUS", "REWARD"]).nullish(),
  startDate: import_zod70.z.string().nullish(),
  storeId: import_zod70.z.string().nullish()
});

// src/generated-definitions/EntitlementGrantResult.ts
var EntitlementGrantResult = import_zod71.z.object({
  entitlementGrants: EntitlementGrant.nullish(),
  reason: import_zod71.z.string().nullish(),
  userId: import_zod71.z.string().nullish()
});

// src/generated-definitions/BulkEntitlementGrantResult.ts
var BulkEntitlementGrantResult = import_zod72.z.object({
  failList: import_zod72.z.array(EntitlementGrantResult).nullish(),
  status: import_zod72.z.enum(["FAIL", "PARTIAL_SUCCESS", "SUCCESS"]).nullish(),
  successList: import_zod72.z.array(EntitlementGrantResult).nullish()
});

// src/generated-definitions/BulkEntitlementRevokeResult.ts
var import_zod74 = require("zod");

// src/generated-definitions/EntitlementRevokeResult.ts
var import_zod73 = require("zod");
var EntitlementRevokeResult = import_zod73.z.object({
  entitlementId: import_zod73.z.string().nullish(),
  reason: import_zod73.z.string().nullish(),
  userId: import_zod73.z.string().nullish()
});

// src/generated-definitions/BulkEntitlementRevokeResult.ts
var BulkEntitlementRevokeResult = import_zod74.z.object({
  failList: import_zod74.z.array(EntitlementRevokeResult).nullish(),
  status: import_zod74.z.enum(["FAIL", "PARTIAL_SUCCESS", "SUCCESS"]).nullish(),
  successList: import_zod74.z.array(EntitlementRevokeResult).nullish()
});

// src/generated-definitions/EntitlementConfigInfo.ts
var import_zod75 = require("zod");
var EntitlementConfigInfo = import_zod75.z.object({ enableEntitlementOriginFeature: import_zod75.z.boolean().nullish(), namespace: import_zod75.z.string().nullish() });

// src/generated-definitions/EntitlementDecrementResult.ts
var import_zod77 = require("zod");

// src/generated-definitions/EntitlementLootBoxReward.ts
var import_zod76 = require("zod");
var EntitlementLootBoxReward = import_zod76.z.object({
  count: import_zod76.z.number().int().nullish(),
  itemId: import_zod76.z.string().nullish(),
  itemSku: import_zod76.z.string().nullish()
});

// src/generated-definitions/EntitlementDecrementResult.ts
var EntitlementDecrementResult = import_zod77.z.object({
  appId: import_zod77.z.string().nullish(),
  appType: import_zod77.z.enum(["DEMO", "DLC", "GAME", "SOFTWARE"]).nullish(),
  clazz: import_zod77.z.enum(["APP", "CODE", "ENTITLEMENT", "LOOTBOX", "MEDIA", "OPTIONBOX", "SUBSCRIPTION"]),
  collectionId: import_zod77.z.string().nullish(),
  createdAt: import_zod77.z.string(),
  endDate: import_zod77.z.string().nullish(),
  features: import_zod77.z.array(import_zod77.z.string()).nullish(),
  grantedAt: import_zod77.z.string().nullish(),
  grantedCode: import_zod77.z.string().nullish(),
  id: import_zod77.z.string(),
  itemId: import_zod77.z.string(),
  itemNamespace: import_zod77.z.string(),
  itemSnapshot: ItemSnapshot.nullish(),
  name: import_zod77.z.string().nullish(),
  namespace: import_zod77.z.string(),
  noOrigin: import_zod77.z.boolean().nullish(),
  origin: import_zod77.z.enum(["Epic", "GooglePlay", "IOS", "Nintendo", "Oculus", "Other", "Playstation", "Steam", "System", "Twitch", "Xbox"]).nullish(),
  platformAvailable: import_zod77.z.boolean().nullish(),
  replayed: import_zod77.z.boolean().nullish(),
  requestId: import_zod77.z.string().nullish(),
  rewards: import_zod77.z.array(EntitlementLootBoxReward).nullish(),
  sku: import_zod77.z.string().nullish(),
  source: import_zod77.z.enum(["ACHIEVEMENT", "GIFT", "IAP", "OTHER", "PROMOTION", "PURCHASE", "REDEEM_CODE", "REFERRAL_BONUS", "REWARD"]).nullish(),
  stackable: import_zod77.z.boolean().nullish(),
  startDate: import_zod77.z.string().nullish(),
  status: import_zod77.z.enum(["ACTIVE", "CONSUMED", "INACTIVE", "REVOKED", "SOLD"]),
  storeId: import_zod77.z.string().nullish(),
  type: import_zod77.z.enum(["CONSUMABLE", "DURABLE"]).nullish(),
  updatedAt: import_zod77.z.string(),
  useCount: import_zod77.z.number().int().nullish(),
  userId: import_zod77.z.string().nullish()
});

// src/generated-definitions/EntitlementHistoryInfoArray.ts
var import_zod79 = require("zod");

// src/generated-definitions/EntitlementHistoryInfo.ts
var import_zod78 = require("zod");
var EntitlementHistoryInfo = import_zod78.z.object({
  action: import_zod78.z.enum(["DECREMENT", "DISABLE", "ENABLE", "GRANT", "REVOKE", "SELL_BACK", "UPDATE"]),
  clazz: import_zod78.z.enum(["APP", "CODE", "ENTITLEMENT", "LOOTBOX", "MEDIA", "OPTIONBOX", "SUBSCRIPTION"]).nullish(),
  createdAt: import_zod78.z.string(),
  entitlementId: import_zod78.z.string(),
  itemId: import_zod78.z.string().nullish(),
  namespace: import_zod78.z.string(),
  operator: import_zod78.z.string(),
  origin: import_zod78.z.enum(["Epic", "GooglePlay", "IOS", "Nintendo", "Oculus", "Other", "Playstation", "Steam", "System", "Twitch", "Xbox"]).nullish(),
  reason: import_zod78.z.string().nullish(),
  sku: import_zod78.z.string().nullish(),
  updatedAt: import_zod78.z.string(),
  useCount: import_zod78.z.number().int().nullish(),
  useCountChange: import_zod78.z.number().int().nullish(),
  userId: import_zod78.z.string()
});

// src/generated-definitions/EntitlementHistoryInfoArray.ts
var EntitlementHistoryInfoArray = import_zod79.z.array(EntitlementHistoryInfo);

// src/generated-definitions/EntitlementIfc.ts
var import_zod80 = require("zod");
var EntitlementIfc = import_zod80.z.object({
  appId: import_zod80.z.string().nullish(),
  appType: import_zod80.z.enum(["DEMO", "DLC", "GAME", "SOFTWARE"]).nullish(),
  clazz: import_zod80.z.enum(["APP", "CODE", "ENTITLEMENT", "LOOTBOX", "MEDIA", "OPTIONBOX", "SUBSCRIPTION"]).nullish(),
  collectionId: import_zod80.z.string().nullish(),
  createdAt: import_zod80.z.string().nullish(),
  endDate: import_zod80.z.string().nullish(),
  features: import_zod80.z.array(import_zod80.z.string()).nullish(),
  grantedCode: import_zod80.z.string().nullish(),
  id: import_zod80.z.string().nullish(),
  itemId: import_zod80.z.string().nullish(),
  itemNamespace: import_zod80.z.string().nullish(),
  name: import_zod80.z.string().nullish(),
  namespace: import_zod80.z.string().nullish(),
  noOrigin: import_zod80.z.boolean().nullish(),
  origin: import_zod80.z.enum(["Epic", "GooglePlay", "IOS", "Nintendo", "Oculus", "Other", "Playstation", "Steam", "System", "Twitch", "Xbox"]).nullish(),
  sku: import_zod80.z.string().nullish(),
  startDate: import_zod80.z.string().nullish(),
  status: import_zod80.z.enum(["ACTIVE", "CONSUMED", "INACTIVE", "REVOKED", "SOLD"]).nullish(),
  storeId: import_zod80.z.string().nullish(),
  type: import_zod80.z.enum(["CONSUMABLE", "DURABLE"]).nullish(),
  updatedAt: import_zod80.z.string().nullish(),
  useCount: import_zod80.z.number().int().nullish(),
  userId: import_zod80.z.string().nullish()
});

// src/generated-definitions/EntitlementInfo.ts
var import_zod81 = require("zod");
var EntitlementInfo = import_zod81.z.object({
  appId: import_zod81.z.string().nullish(),
  appType: import_zod81.z.enum(["DEMO", "DLC", "GAME", "SOFTWARE"]).nullish(),
  clazz: import_zod81.z.enum(["APP", "CODE", "ENTITLEMENT", "LOOTBOX", "MEDIA", "OPTIONBOX", "SUBSCRIPTION"]),
  collectionId: import_zod81.z.string().nullish(),
  createdAt: import_zod81.z.string(),
  endDate: import_zod81.z.string().nullish(),
  features: import_zod81.z.array(import_zod81.z.string()).nullish(),
  grantedAt: import_zod81.z.string().nullish(),
  grantedCode: import_zod81.z.string().nullish(),
  id: import_zod81.z.string(),
  itemId: import_zod81.z.string(),
  itemNamespace: import_zod81.z.string(),
  itemSnapshot: ItemSnapshot.nullish(),
  name: import_zod81.z.string().nullish(),
  namespace: import_zod81.z.string(),
  noOrigin: import_zod81.z.boolean().nullish(),
  origin: import_zod81.z.enum(["Epic", "GooglePlay", "IOS", "Nintendo", "Oculus", "Other", "Playstation", "Steam", "System", "Twitch", "Xbox"]).nullish(),
  platformAvailable: import_zod81.z.boolean().nullish(),
  sku: import_zod81.z.string().nullish(),
  source: import_zod81.z.enum(["ACHIEVEMENT", "GIFT", "IAP", "OTHER", "PROMOTION", "PURCHASE", "REDEEM_CODE", "REFERRAL_BONUS", "REWARD"]).nullish(),
  stackable: import_zod81.z.boolean().nullish(),
  startDate: import_zod81.z.string().nullish(),
  status: import_zod81.z.enum(["ACTIVE", "CONSUMED", "INACTIVE", "REVOKED", "SOLD"]),
  storeId: import_zod81.z.string().nullish(),
  type: import_zod81.z.enum(["CONSUMABLE", "DURABLE"]).nullish(),
  updatedAt: import_zod81.z.string(),
  useCount: import_zod81.z.number().int().nullish(),
  userId: import_zod81.z.string().nullish()
});

// src/generated-definitions/EntitlementInfoArray.ts
var import_zod82 = require("zod");
var EntitlementInfoArray = import_zod82.z.array(EntitlementInfo);

// src/generated-definitions/EntitlementOwnershipArray.ts
var import_zod84 = require("zod");

// src/generated-definitions/EntitlementOwnership.ts
var import_zod83 = require("zod");
var EntitlementOwnership = import_zod83.z.object({ itemId: import_zod83.z.string().nullish(), owned: import_zod83.z.boolean() });

// src/generated-definitions/EntitlementOwnershipArray.ts
var EntitlementOwnershipArray = import_zod84.z.array(EntitlementOwnership);

// src/generated-definitions/EntitlementPagingSlicedResult.ts
var import_zod85 = require("zod");
var EntitlementPagingSlicedResult = import_zod85.z.object({ data: import_zod85.z.array(EntitlementInfo).nullish(), paging: Paging.nullish() });

// src/generated-definitions/EntitlementPlatformConfigInfo.ts
var import_zod86 = require("zod");
var EntitlementPlatformConfigInfo = import_zod86.z.object({
  allowedPlatformOrigins: import_zod86.z.array(import_zod86.z.string()),
  createdAt: import_zod86.z.string().nullish(),
  id: import_zod86.z.string().nullish(),
  namespace: import_zod86.z.string(),
  platform: import_zod86.z.string(),
  updatedAt: import_zod86.z.string().nullish()
});

// src/generated-definitions/EntitlementPrechekResult.ts
var import_zod87 = require("zod");
var EntitlementPrechekResult = import_zod87.z.object({ isRevokePossible: import_zod87.z.boolean().nullish() });

// src/generated-definitions/EntitlementSoldResult.ts
var import_zod89 = require("zod");

// src/generated-definitions/CreditSummary.ts
var import_zod88 = require("zod");
var CreditSummary = import_zod88.z.object({
  amount: import_zod88.z.number().int(),
  currencyCode: import_zod88.z.string().nullish(),
  namespace: import_zod88.z.string(),
  userId: import_zod88.z.string(),
  walletId: import_zod88.z.string()
});

// src/generated-definitions/EntitlementSoldResult.ts
var EntitlementSoldResult = import_zod89.z.object({
  creditSummaries: import_zod89.z.array(CreditSummary).nullish(),
  entitlementInfo: EntitlementInfo.nullish(),
  replayed: import_zod89.z.boolean().nullish(),
  requestId: import_zod89.z.string().nullish()
});

// src/generated-definitions/Ownership.ts
var import_zod90 = require("zod");
var Ownership = import_zod90.z.object({ owned: import_zod90.z.boolean() });

// src/generated-definitions/StackableEntitlementInfoArray.ts
var import_zod92 = require("zod");

// src/generated-definitions/StackableEntitlementInfo.ts
var import_zod91 = require("zod");
var StackableEntitlementInfo = import_zod91.z.object({
  appId: import_zod91.z.string().nullish(),
  appType: import_zod91.z.enum(["DEMO", "DLC", "GAME", "SOFTWARE"]).nullish(),
  clazz: import_zod91.z.enum(["APP", "CODE", "ENTITLEMENT", "LOOTBOX", "MEDIA", "OPTIONBOX", "SUBSCRIPTION"]),
  collectionId: import_zod91.z.string().nullish(),
  createdAt: import_zod91.z.string(),
  endDate: import_zod91.z.string().nullish(),
  features: import_zod91.z.array(import_zod91.z.string()).nullish(),
  grantedAt: import_zod91.z.string().nullish(),
  grantedCode: import_zod91.z.string().nullish(),
  id: import_zod91.z.string(),
  itemId: import_zod91.z.string(),
  itemNamespace: import_zod91.z.string(),
  itemSnapshot: ItemSnapshot.nullish(),
  name: import_zod91.z.string().nullish(),
  namespace: import_zod91.z.string(),
  noOrigin: import_zod91.z.boolean().nullish(),
  origin: import_zod91.z.enum(["Epic", "GooglePlay", "IOS", "Nintendo", "Oculus", "Other", "Playstation", "Steam", "System", "Twitch", "Xbox"]).nullish(),
  platformAvailable: import_zod91.z.boolean().nullish(),
  sku: import_zod91.z.string().nullish(),
  source: import_zod91.z.enum(["ACHIEVEMENT", "GIFT", "IAP", "OTHER", "PROMOTION", "PURCHASE", "REDEEM_CODE", "REFERRAL_BONUS", "REWARD"]).nullish(),
  stackable: import_zod91.z.boolean().nullish(),
  stackedUseCount: import_zod91.z.number().int().nullish(),
  startDate: import_zod91.z.string().nullish(),
  status: import_zod91.z.enum(["ACTIVE", "CONSUMED", "INACTIVE", "REVOKED", "SOLD"]),
  storeId: import_zod91.z.string().nullish(),
  type: import_zod91.z.enum(["CONSUMABLE", "DURABLE"]).nullish(),
  updatedAt: import_zod91.z.string(),
  useCount: import_zod91.z.number().int().nullish(),
  userId: import_zod91.z.string().nullish()
});

// src/generated-definitions/StackableEntitlementInfoArray.ts
var StackableEntitlementInfoArray = import_zod92.z.array(StackableEntitlementInfo);

// src/generated-definitions/TimedOwnership.ts
var import_zod93 = require("zod");
var TimedOwnership = import_zod93.z.object({ endDate: import_zod93.z.string().nullish(), owned: import_zod93.z.boolean() });

// src/generated-admin/endpoints/EntitlementAdmin$.ts
var EntitlementAdmin$ = class {
  // @ts-ignore
  // prettier-ignore
  constructor(axiosInstance, namespace, useSchemaValidation = true) {
    this.axiosInstance = axiosInstance;
    this.namespace = namespace;
    this.useSchemaValidation = useSchemaValidation;
  }
  /**
   * Query entitlements.&lt;p&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: entitlement list&lt;/li&gt;&lt;/ul&gt;
   */
  getEntitlements(queryParams) {
    const params = { activeOnly: true, limit: 20, ...queryParams };
    const url = "/platform/admin/namespaces/{namespace}/entitlements".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.get(url, { params });
    return import_sdk17.Validate.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      EntitlementPagingSlicedResult,
      "EntitlementPagingSlicedResult"
    );
  }
  /**
   * Grant entitlements to multiple users, skipped granting will be treated as fail.&lt;br&gt;&lt;br&gt;Notes: &lt;br&gt;&lt;br&gt;Support Item Types:&lt;ul&gt;&lt;li&gt;&lt;i&gt;APP&lt;/i&gt;&lt;/li&gt;&lt;li&gt;&lt;i&gt;INGAMEITEM&lt;/i&gt;&lt;/li&gt;&lt;li&gt;&lt;i&gt;CODE&lt;/i&gt;&lt;/li&gt;&lt;li&gt;&lt;i&gt;SUBSCRIPTION&lt;/i&gt;&lt;/li&gt;&lt;li&gt;&lt;i&gt;MEDIA&lt;/i&gt;&lt;/li&gt;&lt;li&gt;&lt;i&gt;OPTIONBOX&lt;/i&gt;&lt;/li&gt;&lt;li&gt;&lt;i&gt;LOOTBOX&lt;/i&gt;&lt;/li&gt;&lt;/ul&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: bulk grant entitlements result&lt;/li&gt;&lt;/ul&gt;
   */
  createEntitlementGrant(data) {
    const params = {};
    const url = "/platform/admin/namespaces/{namespace}/entitlements/grant".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.post(url, data, { params });
    return import_sdk17.Validate.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      BulkEntitlementGrantResult,
      "BulkEntitlementGrantResult"
    );
  }
  /**
   * Revoke entitlements, skipped revocation will be treated as fail.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: bulk revoke entitlements result&lt;/li&gt;&lt;/ul&gt;
   */
  createEntitlementRevoke(data) {
    const params = {};
    const url = "/platform/admin/namespaces/{namespace}/entitlements/revoke".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.post(url, data, { params });
    return import_sdk17.Validate.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      BulkEntitlementRevokeResult,
      "BulkEntitlementRevokeResult"
    );
  }
  /**
   * Query entitlements by Item Ids.&lt;p&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: entitlement list&lt;/li&gt;&lt;/ul&gt;
   */
  getEntitlementsByItemIds(queryParams) {
    const params = { activeOnly: true, limit: 20, ...queryParams };
    const url = "/platform/admin/namespaces/{namespace}/entitlements/byItemIds".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.get(url, { params });
    return import_sdk17.Validate.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      EntitlementPagingSlicedResult,
      "EntitlementPagingSlicedResult"
    );
  }
  /**
   * Get entitlement config info.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: entitlement info&lt;/li&gt;&lt;/ul&gt;
   */
  getEntitlementsConfigInfo(queryParams) {
    const params = { withoutCache: true, ...queryParams };
    const url = "/platform/admin/namespaces/{namespace}/entitlements/config/info".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.get(url, { params });
    return import_sdk17.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, EntitlementConfigInfo, "EntitlementConfigInfo");
  }
  /**
   * Query entitlements for a specific user.&lt;p&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: entitlement list&lt;/li&gt;&lt;/ul&gt;
   */
  getEntitlements_ByUserId(userId, queryParams) {
    const params = { activeOnly: true, limit: 20, ...queryParams };
    const url = "/platform/admin/namespaces/{namespace}/users/{userId}/entitlements".replace("{namespace}", this.namespace).replace("{userId}", userId);
    const resultPromise = this.axiosInstance.get(url, { params });
    return import_sdk17.Validate.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      EntitlementPagingSlicedResult,
      "EntitlementPagingSlicedResult"
    );
  }
  /**
   * Grant user entitlement.&lt;br&gt;&lt;br&gt;Notes: &lt;br&gt;&lt;br&gt;will skip un-supported item if input un-supported item types, please use /admin/namespaces/{namespace}/users/{userId}/fulfillment endpoint if want to fulfill other item type, like coin item&lt;br&gt;&lt;br&gt;Support Item Types:&lt;ul&gt;&lt;li&gt;&lt;i&gt;APP&lt;/i&gt;&lt;/li&gt;&lt;li&gt;&lt;i&gt;INGAMEITEM&lt;/i&gt;&lt;/li&gt;&lt;li&gt;&lt;i&gt;CODE&lt;/i&gt;&lt;/li&gt;&lt;li&gt;&lt;i&gt;SUBSCRIPTION&lt;/i&gt;&lt;/li&gt;&lt;li&gt;&lt;i&gt;MEDIA&lt;/i&gt;&lt;/li&gt;&lt;li&gt;&lt;i&gt;OPTIONBOX&lt;/i&gt;&lt;/li&gt;&lt;li&gt;&lt;i&gt;LOOTBOX&lt;/i&gt;&lt;/li&gt;&lt;/ul&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: granted entitlement&lt;/li&gt;&lt;/ul&gt;
   */
  createEntitlement_ByUserId(userId, data) {
    const params = {};
    const url = "/platform/admin/namespaces/{namespace}/users/{userId}/entitlements".replace("{namespace}", this.namespace).replace("{userId}", userId);
    const resultPromise = this.axiosInstance.post(url, data, { params });
    return import_sdk17.Validate.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      StackableEntitlementInfoArray,
      "StackableEntitlementInfoArray"
    );
  }
  /**
   * Get entitlement.&lt;p&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: entitlement&lt;/li&gt;&lt;/ul&gt;
   */
  getEntitlement_ByEntitlementId(entitlementId) {
    const params = {};
    const url = "/platform/admin/namespaces/{namespace}/entitlements/{entitlementId}".replace("{namespace}", this.namespace).replace("{entitlementId}", entitlementId);
    const resultPromise = this.axiosInstance.get(url, { params });
    return import_sdk17.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, EntitlementInfo, "EntitlementInfo");
  }
  /**
   * Get user entitlement by sku.
   */
  getEntitlementsBySku_ByUserId(userId, queryParams) {
    const params = { activeOnly: true, ...queryParams };
    const url = "/platform/admin/namespaces/{namespace}/users/{userId}/entitlements/bySku".replace("{namespace}", this.namespace).replace("{userId}", userId);
    const resultPromise = this.axiosInstance.get(url, { params });
    return import_sdk17.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, EntitlementInfo, "EntitlementInfo");
  }
  /**
   * Revoke all entitlements of a user (This API is for testing purpose only)&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: revoked entitlements count&lt;/li&gt;&lt;/ul&gt;
   */
  updateEntitlementRevoke_ByUserId(userId) {
    const params = {};
    const url = "/platform/admin/namespaces/{namespace}/users/{userId}/entitlements/revoke".replace("{namespace}", this.namespace).replace("{userId}", userId);
    const resultPromise = this.axiosInstance.put(url, null, { params });
    return import_sdk17.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, BulkOperationResult, "BulkOperationResult");
  }
  /**
   * Get user app entitlement by appId.
   */
  getEntitlementsByAppId_ByUserId(userId, queryParams) {
    const params = { activeOnly: true, ...queryParams };
    const url = "/platform/admin/namespaces/{namespace}/users/{userId}/entitlements/byAppId".replace("{namespace}", this.namespace).replace("{userId}", userId);
    const resultPromise = this.axiosInstance.get(url, { params });
    return import_sdk17.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, AppEntitlementInfo, "AppEntitlementInfo");
  }
  /**
   * Get user entitlement by itemId.
   */
  getEntitlementsByItemId_ByUserId(userId, queryParams) {
    const params = { activeOnly: true, ...queryParams };
    const url = "/platform/admin/namespaces/{namespace}/users/{userId}/entitlements/byItemId".replace("{namespace}", this.namespace).replace("{userId}", userId);
    const resultPromise = this.axiosInstance.get(url, { params });
    return import_sdk17.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, EntitlementInfo, "EntitlementInfo");
  }
  /**
   * Query app entitlements by appType.&lt;p&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: app entitlement pagination&lt;/li&gt;&lt;/ul&gt;
   */
  getEntitlementsByAppType_ByUserId(userId, queryParams) {
    const params = { activeOnly: true, limit: 20, ...queryParams };
    const url = "/platform/admin/namespaces/{namespace}/users/{userId}/entitlements/byAppType".replace("{namespace}", this.namespace).replace("{userId}", userId);
    const resultPromise = this.axiosInstance.get(url, { params });
    return import_sdk17.Validate.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      AppEntitlementPagingSlicedResult,
      "AppEntitlementPagingSlicedResult"
    );
  }
  /**
   * Get user entitlements by itemIds.
   */
  getEntitlementsByItemIds_ByUserId(userId, queryParams) {
    const params = { ...queryParams };
    const url = "/platform/admin/namespaces/{namespace}/users/{userId}/entitlements/byItemIds".replace("{namespace}", this.namespace).replace("{userId}", userId);
    const resultPromise = this.axiosInstance.get(url, { params });
    return import_sdk17.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, EntitlementInfoArray, "EntitlementInfoArray");
  }
  /**
   * Get platform entitlement config list.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: entitlement info&lt;/li&gt;&lt;/ul&gt;
   */
  getEntitlementConfig_ByPlatform(platform) {
    const params = {};
    const url = "/platform/admin/namespaces/{namespace}/platforms/{platform}/entitlement/config".replace("{namespace}", this.namespace).replace("{platform}", platform);
    const resultPromise = this.axiosInstance.get(url, { params });
    return import_sdk17.Validate.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      EntitlementPlatformConfigInfo,
      "EntitlementPlatformConfigInfo"
    );
  }
  /**
   * Update platform entitlement config.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: platform entitlement config&lt;/li&gt;&lt;/ul&gt;
   */
  updateEntitlementConfig_ByPlatform(platform, data) {
    const params = {};
    const url = "/platform/admin/namespaces/{namespace}/platforms/{platform}/entitlement/config".replace("{namespace}", this.namespace).replace("{platform}", platform);
    const resultPromise = this.axiosInstance.put(url, data, { params });
    return import_sdk17.Validate.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      EntitlementPlatformConfigInfo,
      "EntitlementPlatformConfigInfo"
    );
  }
  /**
   * Revoke user&#39;s entitlements by ids.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: revoke entitlements count&lt;/li&gt;&lt;/ul&gt;
   */
  updateEntitlementRevokeById_ByUserId(userId, queryParams) {
    const params = { ...queryParams };
    const url = "/platform/admin/namespaces/{namespace}/users/{userId}/entitlements/revoke/byIds".replace("{namespace}", this.namespace).replace("{userId}", userId);
    const resultPromise = this.axiosInstance.put(url, null, { params });
    return import_sdk17.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, BulkOperationResult, "BulkOperationResult");
  }
  /**
   * Exists any user active entitlement of specified itemIds, skus and appIds
   */
  getEntitlementsOwnershipAny_ByUserId(userId, queryParams) {
    const params = { ...queryParams };
    const url = "/platform/admin/namespaces/{namespace}/users/{userId}/entitlements/ownership/any".replace("{namespace}", this.namespace).replace("{userId}", userId);
    const resultPromise = this.axiosInstance.get(url, { params });
    return import_sdk17.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, Ownership, "Ownership");
  }
  /**
   * Get user entitlement.&lt;p&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: entitlement&lt;/li&gt;&lt;/ul&gt;
   */
  getEntitlement_ByUserId_ByEntitlementId(userId, entitlementId) {
    const params = {};
    const url = "/platform/admin/namespaces/{namespace}/users/{userId}/entitlements/{entitlementId}".replace("{namespace}", this.namespace).replace("{userId}", userId).replace("{entitlementId}", entitlementId);
    const resultPromise = this.axiosInstance.get(url, { params });
    return import_sdk17.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, EntitlementInfo, "EntitlementInfo");
  }
  /**
   * Update user entitlement. If update CONSUMABLE entitlement useCount to 0, the status will be CONSUMED.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: updated entitlement&lt;/li&gt;&lt;/ul&gt;
   */
  updateEntitlement_ByUserId_ByEntitlementId(userId, entitlementId, data) {
    const params = {};
    const url = "/platform/admin/namespaces/{namespace}/users/{userId}/entitlements/{entitlementId}".replace("{namespace}", this.namespace).replace("{userId}", userId).replace("{entitlementId}", entitlementId);
    const resultPromise = this.axiosInstance.put(url, data, { params });
    return import_sdk17.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, EntitlementInfo, "EntitlementInfo");
  }
  /**
   * Exists any user active entitlement of specified items.
   */
  getEntitlementsOwnershipAnyOf_ByUserId(userId, queryParams) {
    const params = { ...queryParams };
    const url = "/platform/admin/namespaces/{namespace}/users/{userId}/entitlements/ownership/anyOf".replace("{namespace}", this.namespace).replace("{userId}", userId);
    const resultPromise = this.axiosInstance.get(url, { params });
    return import_sdk17.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, Ownership, "Ownership");
  }
  /**
   * Get user entitlement ownership by sku.
   */
  getEntitlementsOwnershipBySku_ByUserId(userId, queryParams) {
    const params = { ...queryParams };
    const url = "/platform/admin/namespaces/{namespace}/users/{userId}/entitlements/ownership/bySku".replace("{namespace}", this.namespace).replace("{userId}", userId);
    const resultPromise = this.axiosInstance.get(url, { params });
    return import_sdk17.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, TimedOwnership, "TimedOwnership");
  }
  /**
   * Enable Entitlement origin feature.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: entitlement info&lt;/li&gt;&lt;/ul&gt;
   */
  updateEntitlementConfigEntitlementOriginEnable() {
    const params = {};
    const url = "/platform/admin/namespaces/{namespace}/entitlements/config/entitlementOrigin/enable".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.put(url, null, { params });
    return import_sdk17.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, EntitlementConfigInfo, "EntitlementConfigInfo");
  }
  /**
   * Get user app entitlement ownership by appId.
   */
  getEntitlementsOwnershipByAppId_ByUserId(userId, queryParams) {
    const params = { ...queryParams };
    const url = "/platform/admin/namespaces/{namespace}/users/{userId}/entitlements/ownership/byAppId".replace("{namespace}", this.namespace).replace("{userId}", userId);
    const resultPromise = this.axiosInstance.get(url, { params });
    return import_sdk17.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, Ownership, "Ownership");
  }
  /**
   * Get user entitlement ownership by itemId.
   */
  getEntitlementsOwnershipByItemId_ByUserId(userId, queryParams) {
    const params = { ...queryParams };
    const url = "/platform/admin/namespaces/{namespace}/users/{userId}/entitlements/ownership/byItemId".replace("{namespace}", this.namespace).replace("{userId}", userId);
    const resultPromise = this.axiosInstance.get(url, { params });
    return import_sdk17.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, TimedOwnership, "TimedOwnership");
  }
  /**
   * Get user entitlement ownership by itemIds.
   */
  getEntitlementsOwnershipByItemIds_ByUserId(userId, queryParams) {
    const params = { ...queryParams };
    const url = "/platform/admin/namespaces/{namespace}/users/{userId}/entitlements/ownership/byItemIds".replace("{namespace}", this.namespace).replace("{userId}", userId);
    const resultPromise = this.axiosInstance.get(url, { params });
    return import_sdk17.Validate.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      EntitlementOwnershipArray,
      "EntitlementOwnershipArray"
    );
  }
  /**
   * Sell user entitlement. If the entitlement is consumable, useCount is 0, the status will be CONSUMED. If the entitlement is durable, the status will be SOLD. Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: entitlement&lt;/li&gt;&lt;/ul&gt;
   */
  updateSell_ByUserId_ByEntitlementId(userId, entitlementId, data) {
    const params = {};
    const url = "/platform/admin/namespaces/{namespace}/users/{userId}/entitlements/{entitlementId}/sell".replace("{namespace}", this.namespace).replace("{userId}", userId).replace("{entitlementId}", entitlementId);
    const resultPromise = this.axiosInstance.put(url, data, { params });
    return import_sdk17.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, EntitlementSoldResult, "EntitlementSoldResult");
  }
  /**
   * Enable user entitlement.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: enable entitlement&lt;/li&gt;&lt;/ul&gt;
   */
  updateEnable_ByUserId_ByEntitlementId(userId, entitlementId) {
    const params = {};
    const url = "/platform/admin/namespaces/{namespace}/users/{userId}/entitlements/{entitlementId}/enable".replace("{namespace}", this.namespace).replace("{userId}", userId).replace("{entitlementId}", entitlementId);
    const resultPromise = this.axiosInstance.put(url, null, { params });
    return import_sdk17.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, EntitlementInfo, "EntitlementInfo");
  }
  /**
   * Revoke user entitlement.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: revoke entitlement&lt;/li&gt;&lt;/ul&gt;
   */
  updateRevoke_ByUserId_ByEntitlementId(userId, entitlementId, data) {
    const params = {};
    const url = "/platform/admin/namespaces/{namespace}/users/{userId}/entitlements/{entitlementId}/revoke".replace("{namespace}", this.namespace).replace("{userId}", userId).replace("{entitlementId}", entitlementId);
    const resultPromise = this.axiosInstance.put(url, data, { params });
    return import_sdk17.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, EntitlementInfo, "EntitlementInfo");
  }
  /**
   * Disable user entitlement if entitlement, only active entitlement can be disable, disabled entitlement can&#39;t consume.&lt;br&gt;&lt;b&gt;Like revoke, it will lose the entitlement ownership, except disabled entitlement can enable.&lt;/b&gt;&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: disable entitlement&lt;/li&gt;&lt;/ul&gt;
   */
  updateDisable_ByUserId_ByEntitlementId(userId, entitlementId) {
    const params = {};
    const url = "/platform/admin/namespaces/{namespace}/users/{userId}/entitlements/{entitlementId}/disable".replace("{namespace}", this.namespace).replace("{userId}", userId).replace("{entitlementId}", entitlementId);
    const resultPromise = this.axiosInstance.put(url, null, { params });
    return import_sdk17.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, EntitlementInfo, "EntitlementInfo");
  }
  /**
   * Get user entitlement histories.&lt;p&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: list of entitlement history&lt;/li&gt;&lt;/ul&gt;
   */
  getHistory_ByUserId_ByEntitlementId(userId, entitlementId) {
    const params = {};
    const url = "/platform/admin/namespaces/{namespace}/users/{userId}/entitlements/{entitlementId}/history".replace("{namespace}", this.namespace).replace("{userId}", userId).replace("{entitlementId}", entitlementId);
    const resultPromise = this.axiosInstance.get(url, { params });
    return import_sdk17.Validate.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      EntitlementHistoryInfoArray,
      "EntitlementHistoryInfoArray"
    );
  }
  /**
   * Consume user entitlement. If the entitlement useCount is 0, the status will be CONSUMED.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: consumed entitlement&lt;/li&gt;&lt;/ul&gt;
   */
  updateDecrement_ByUserId_ByEntitlementId(userId, entitlementId, data) {
    const params = {};
    const url = "/platform/admin/namespaces/{namespace}/users/{userId}/entitlements/{entitlementId}/decrement".replace("{namespace}", this.namespace).replace("{userId}", userId).replace("{entitlementId}", entitlementId);
    const resultPromise = this.axiosInstance.put(url, data, { params });
    return import_sdk17.Validate.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      EntitlementDecrementResult,
      "EntitlementDecrementResult"
    );
  }
  /**
   * @deprecated
   * Revoke specified use count of user entitlement. please use /{entitlementId}/revoke/byUseCount endpoint instead of this endpoint&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: revoke entitlement&lt;/li&gt;&lt;/ul&gt;
   */
  updateRevokeByUseCount_ByUserId_ByEntitlementId(userId, entitlementId, data) {
    const params = {};
    const url = "/platform/admin/namespaces/{namespace}/users/{userId}/entitlements/{entitlementId}/revokeByUseCount".replace("{namespace}", this.namespace).replace("{userId}", userId).replace("{entitlementId}", entitlementId);
    const resultPromise = this.axiosInstance.put(url, data, { params });
    return import_sdk17.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, EntitlementInfo, "EntitlementInfo");
  }
  /**
   * Revoke specified count of user entitlement.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: The revoked entitlement&lt;/li&gt;&lt;/ul&gt;
   */
  createRevokeByUseCount_ByUserId_ByEntitlementId(userId, entitlementId, data) {
    const params = {};
    const url = "/platform/admin/namespaces/{namespace}/users/{userId}/entitlements/{entitlementId}/revoke/byUseCount".replace("{namespace}", this.namespace).replace("{userId}", userId).replace("{entitlementId}", entitlementId);
    const resultPromise = this.axiosInstance.post(url, data, { params });
    return import_sdk17.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, EntitlementIfc, "EntitlementIfc");
  }
  /**
   * Checks if specified use count of user entitlement can be revoked without actually revoking it.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: true if revokable, false otherwise&lt;/li&gt;&lt;/ul&gt;
   */
  getRevokeByUseCountPreCheck_ByUserId_ByEntitlementId(userId, entitlementId, queryParams) {
    const params = { ...queryParams };
    const url = "/platform/admin/namespaces/{namespace}/users/{userId}/entitlements/{entitlementId}/revoke/byUseCount/preCheck".replace("{namespace}", this.namespace).replace("{userId}", userId).replace("{entitlementId}", entitlementId);
    const resultPromise = this.axiosInstance.get(url, { params });
    return import_sdk17.Validate.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      EntitlementPrechekResult,
      "EntitlementPrechekResult"
    );
  }
};

// src/generated-admin/endpoints/FulfillmentAdmin$.ts
var import_sdk18 = require("@accelbyte/sdk");
var import_zod111 = require("zod");

// src/generated-definitions/FulfillmentHistoryPagingSlicedResult.ts
var import_zod99 = require("zod");

// src/generated-definitions/FulfillmentHistoryInfo.ts
var import_zod98 = require("zod");

// src/generated-definitions/EntitlementSummary.ts
var import_zod94 = require("zod");
var EntitlementSummary = import_zod94.z.object({
  clazz: import_zod94.z.enum(["APP", "CODE", "ENTITLEMENT", "LOOTBOX", "MEDIA", "OPTIONBOX", "SUBSCRIPTION"]),
  collectionId: import_zod94.z.string().nullish(),
  createdAt: import_zod94.z.string(),
  endDate: import_zod94.z.string().nullish(),
  grantedCode: import_zod94.z.string().nullish(),
  id: import_zod94.z.string(),
  itemId: import_zod94.z.string().nullish(),
  name: import_zod94.z.string().nullish(),
  namespace: import_zod94.z.string(),
  noOrigin: import_zod94.z.boolean().nullish(),
  origin: import_zod94.z.enum(["Epic", "GooglePlay", "IOS", "Nintendo", "Oculus", "Other", "Playstation", "Steam", "System", "Twitch", "Xbox"]).nullish(),
  stackable: import_zod94.z.boolean().nullish(),
  stackedUseCount: import_zod94.z.number().int().nullish(),
  startDate: import_zod94.z.string().nullish(),
  storeId: import_zod94.z.string().nullish(),
  type: import_zod94.z.enum(["CONSUMABLE", "DURABLE"]),
  updatedAt: import_zod94.z.string(),
  userId: import_zod94.z.string()
});

// src/generated-definitions/ExtensionFulfillmentSummary.ts
var import_zod95 = require("zod");
var ExtensionFulfillmentSummary = import_zod95.z.object({
  grantedAt: import_zod95.z.string().nullish(),
  itemClazz: import_zod95.z.string().nullish(),
  itemExt: import_zod95.z.record(import_zod95.z.any()).nullish(),
  itemId: import_zod95.z.string().nullish(),
  itemType: import_zod95.z.enum(["APP", "BUNDLE", "CODE", "COINS", "EXTENSION", "INGAMEITEM", "LOOTBOX", "MEDIA", "OPTIONBOX", "SEASON", "SUBSCRIPTION"]).nullish(),
  metadata: import_zod95.z.record(import_zod95.z.any()).nullish(),
  namespace: import_zod95.z.string().nullish(),
  quantity: import_zod95.z.number().int(),
  userId: import_zod95.z.string().nullish()
});

// src/generated-definitions/FulfillmentError.ts
var import_zod96 = require("zod");
var FulfillmentError = import_zod96.z.object({
  code: import_zod96.z.number().int().nullish(),
  httpStatus: import_zod96.z.number().int().nullish(),
  message: import_zod96.z.string().nullish()
});

// src/generated-definitions/FulfillmentItem.ts
var import_zod97 = require("zod");
var FulfillmentItem = import_zod97.z.object({
  extraSubscriptionDays: import_zod97.z.number().int().nullish(),
  itemId: import_zod97.z.string().nullish(),
  itemName: import_zod97.z.string().nullish(),
  itemSku: import_zod97.z.string().nullish(),
  itemType: import_zod97.z.enum(["APP", "BUNDLE", "CODE", "COINS", "EXTENSION", "INGAMEITEM", "LOOTBOX", "MEDIA", "OPTIONBOX", "SEASON", "SUBSCRIPTION"]).nullish(),
  quantity: import_zod97.z.number().int(),
  storeId: import_zod97.z.string().nullish()
});

// src/generated-definitions/FulfillmentHistoryInfo.ts
var FulfillmentHistoryInfo = import_zod98.z.object({
  code: import_zod98.z.string().nullish(),
  createdAt: import_zod98.z.string(),
  creditSummaries: import_zod98.z.array(CreditSummary).nullish(),
  entitlementOrigin: import_zod98.z.enum(["Epic", "GooglePlay", "IOS", "Nintendo", "Oculus", "Other", "Playstation", "Steam", "System", "Twitch", "Xbox"]).nullish(),
  entitlementSummaries: import_zod98.z.array(EntitlementSummary).nullish(),
  extensionFulfillmentSummaries: import_zod98.z.array(ExtensionFulfillmentSummary).nullish(),
  fulfillItems: import_zod98.z.array(FulfillmentItem).nullish(),
  fulfillmentError: FulfillmentError.nullish(),
  grantedItemIds: import_zod98.z.array(import_zod98.z.string()).nullish(),
  id: import_zod98.z.string(),
  namespace: import_zod98.z.string(),
  orderNo: import_zod98.z.string().nullish(),
  status: import_zod98.z.enum(["FAIL", "SUCCESS"]),
  updatedAt: import_zod98.z.string(),
  userId: import_zod98.z.string()
});

// src/generated-definitions/FulfillmentHistoryPagingSlicedResult.ts
var FulfillmentHistoryPagingSlicedResult = import_zod99.z.object({ data: import_zod99.z.array(FulfillmentHistoryInfo), paging: Paging.nullish() });

// src/generated-definitions/FulfillmentItemArray.ts
var import_zod100 = require("zod");
var FulfillmentItemArray = import_zod100.z.array(FulfillmentItem);

// src/generated-definitions/FulfillmentPagingSlicedResult.ts
var import_zod106 = require("zod");

// src/generated-definitions/FulfillmentInfo.ts
var import_zod105 = require("zod");

// src/generated-definitions/FulfillmentActionHistory.ts
var import_zod101 = require("zod");
var FulfillmentActionHistory = import_zod101.z.object({
  action: import_zod101.z.enum(["FULFILLMENT", "REVOKE_FULFILLMENT"]).nullish(),
  createdAt: import_zod101.z.string().nullish(),
  fulfillmentHistoryId: import_zod101.z.string().nullish(),
  revocationHistoryId: import_zod101.z.string().nullish(),
  state: import_zod101.z.enum(["FULFILLED", "FULFILL_FAILED", "REVOKED", "REVOKE_FAILED"]).nullish()
});

// src/generated-definitions/FulfillmentStateInfo.ts
var import_zod104 = require("zod");

// src/generated-definitions/FulfillItemResult.ts
var import_zod103 = require("zod");

// src/generated-definitions/FulfillBundledItemResult.ts
var import_zod102 = require("zod");
var FulfillBundledItemResult = import_zod102.z.object({
  error: import_zod102.z.string().nullish(),
  itemId: import_zod102.z.string().nullish(),
  itemSku: import_zod102.z.string().nullish(),
  quantity: import_zod102.z.number().int().nullish()
});

// src/generated-definitions/FulfillItemResult.ts
var FulfillItemResult = import_zod103.z.object({
  error: import_zod103.z.string().nullish(),
  itemId: import_zod103.z.string().nullish(),
  itemSku: import_zod103.z.string().nullish(),
  items: import_zod103.z.array(FulfillBundledItemResult).nullish()
});

// src/generated-definitions/FulfillmentStateInfo.ts
var FulfillmentStateInfo = import_zod104.z.object({
  failedList: import_zod104.z.array(FulfillItemResult).nullish(),
  successList: import_zod104.z.array(FulfillItemResult).nullish()
});

// src/generated-definitions/FulfillmentInfo.ts
var FulfillmentInfo = import_zod105.z.object({
  actions: import_zod105.z.array(FulfillmentActionHistory).nullish(),
  createdAt: import_zod105.z.string(),
  id: import_zod105.z.string(),
  items: import_zod105.z.array(FulfillmentItem).nullish(),
  namespace: import_zod105.z.string(),
  state: import_zod105.z.enum(["FULFILLED", "FULFILL_FAILED", "REVOKED", "REVOKE_FAILED"]).nullish(),
  stateInfo: FulfillmentStateInfo.nullish(),
  transactionId: import_zod105.z.string().nullish(),
  updatedAt: import_zod105.z.string(),
  userId: import_zod105.z.string()
});

// src/generated-definitions/FulfillmentPagingSlicedResult.ts
var FulfillmentPagingSlicedResult = import_zod106.z.object({ data: import_zod106.z.array(FulfillmentInfo), paging: Paging.nullish() });

// src/generated-definitions/FulfillmentResult.ts
var import_zod108 = require("zod");

// src/generated-definitions/SubscriptionSummary.ts
var import_zod107 = require("zod");
var SubscriptionSummary = import_zod107.z.object({
  currentPeriodEnd: import_zod107.z.string().nullish(),
  currentPeriodStart: import_zod107.z.string().nullish(),
  id: import_zod107.z.string(),
  itemId: import_zod107.z.string(),
  namespace: import_zod107.z.string(),
  sku: import_zod107.z.string().nullish(),
  status: import_zod107.z.enum(["ACTIVE", "CANCELLED", "EXPIRED", "INIT"]),
  subscribedBy: import_zod107.z.enum(["PLATFORM", "USER"]).nullish(),
  userId: import_zod107.z.string()
});

// src/generated-definitions/FulfillmentResult.ts
var FulfillmentResult = import_zod108.z.object({
  creditSummaries: import_zod108.z.array(CreditSummary).nullish(),
  entitlementSummaries: import_zod108.z.array(EntitlementSummary).nullish(),
  id: import_zod108.z.string().nullish(),
  namespace: import_zod108.z.string(),
  subscriptionSummaries: import_zod108.z.array(SubscriptionSummary).nullish(),
  userId: import_zod108.z.string()
});

// src/generated-definitions/FulfillmentV2Result.ts
var import_zod109 = require("zod");
var FulfillmentV2Result = import_zod109.z.object({
  creditSummaries: import_zod109.z.array(CreditSummary).nullish(),
  entitlementSummaries: import_zod109.z.array(EntitlementSummary).nullish(),
  id: import_zod109.z.string().nullish(),
  items: import_zod109.z.array(FulfillmentItem),
  namespace: import_zod109.z.string(),
  state: import_zod109.z.enum(["FULFILLED", "FULFILL_FAILED", "REVOKED", "REVOKE_FAILED"]),
  stateInfo: FulfillmentStateInfo,
  subscriptionSummaries: import_zod109.z.array(SubscriptionSummary).nullish(),
  transactionId: import_zod109.z.string(),
  userId: import_zod109.z.string()
});

// src/generated-definitions/RevokeFulfillmentV2Result.ts
var import_zod110 = require("zod");
var RevokeFulfillmentV2Result = import_zod110.z.object({
  creditRevocations: import_zod110.z.array(CreditRevocation).nullish(),
  entitlementRevocations: import_zod110.z.array(EntitlementRevocation).nullish(),
  id: import_zod110.z.string(),
  itemRevocations: import_zod110.z.array(ItemRevocation).nullish(),
  items: import_zod110.z.array(FulfillmentItem),
  namespace: import_zod110.z.string(),
  state: import_zod110.z.enum(["FULFILLED", "FULFILL_FAILED", "REVOKED", "REVOKE_FAILED"]),
  stateInfo: FulfillmentStateInfo,
  transactionId: import_zod110.z.string(),
  userId: import_zod110.z.string()
});

// src/generated-admin/endpoints/FulfillmentAdmin$.ts
var FulfillmentAdmin$ = class {
  // @ts-ignore
  // prettier-ignore
  constructor(axiosInstance, namespace, useSchemaValidation = true) {
    this.axiosInstance = axiosInstance;
    this.namespace = namespace;
    this.useSchemaValidation = useSchemaValidation;
  }
  /**
   * &lt;b&gt;[Not supported yet in AGS Shared Cloud]&lt;/b&gt; Query fulfillments in a namespace.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: list of fulfillment info:&lt;ul&gt;&lt;li&gt;storeId in items can be ignored&lt;/li&gt;&lt;li&gt;error in successList will always be null&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;/ul&gt;
   */
  getFulfillments_v2(queryParams) {
    const params = { limit: 20, ...queryParams };
    const url = "/platform/v2/admin/namespaces/{namespace}/fulfillments".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.get(url, { params });
    return import_sdk18.Validate.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      FulfillmentPagingSlicedResult,
      "FulfillmentPagingSlicedResult"
    );
  }
  /**
   * Query fulfillment histories in a namespace.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: query fulfillment history&lt;/li&gt;&lt;/ul&gt;
   */
  getFulfillmentHistory(queryParams) {
    const params = { limit: 20, ...queryParams };
    const url = "/platform/admin/namespaces/{namespace}/fulfillment/history".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.get(url, { params });
    return import_sdk18.Validate.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      FulfillmentHistoryPagingSlicedResult,
      "FulfillmentHistoryPagingSlicedResult"
    );
  }
  /**
   * Fulfill item.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: fulfillment result&lt;/li&gt;&lt;/ul&gt;
   */
  createFulfillment_ByUserId(userId, data) {
    const params = {};
    const url = "/platform/admin/namespaces/{namespace}/users/{userId}/fulfillment".replace("{namespace}", this.namespace).replace("{userId}", userId);
    const resultPromise = this.axiosInstance.post(url, data, { params });
    return import_sdk18.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, FulfillmentResult, "FulfillmentResult");
  }
  /**
   * Redeem campaign code.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: fulfillment result&lt;/li&gt;&lt;/ul&gt;
   */
  createFulfillmentCode_ByUserId(userId, data) {
    const params = {};
    const url = "/platform/admin/namespaces/{namespace}/users/{userId}/fulfillment/code".replace("{namespace}", this.namespace).replace("{userId}", userId);
    const resultPromise = this.axiosInstance.post(url, data, { params });
    return import_sdk18.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, FulfillmentResult, "FulfillmentResult");
  }
  /**
   * &lt;b&gt;[SERVICE COMMUNICATION ONLY]&lt;/b&gt; Fulfill rewards.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: fulfillment result&lt;/li&gt;&lt;/ul&gt;
   */
  createFulfillmentReward_ByUserId(userId, data) {
    const params = {};
    const url = "/platform/admin/namespaces/{namespace}/users/{userId}/fulfillment/rewards".replace("{namespace}", this.namespace).replace("{userId}", userId);
    const resultPromise = this.axiosInstance.post(url, data, { params });
    return import_sdk18.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, import_zod111.z.unknown(), "z.unknown()");
  }
  /**
   * Retrieve and check fulfillment items based on the provided request.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: list of fulfillment items&lt;/li&gt;&lt;/ul&gt;
   */
  createFulfillmentPreCheck_ByUserId(userId, data) {
    const params = {};
    const url = "/platform/admin/namespaces/{namespace}/users/{userId}/fulfillment/preCheck".replace("{namespace}", this.namespace).replace("{userId}", userId);
    const resultPromise = this.axiosInstance.post(url, data, { params });
    return import_sdk18.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, FulfillmentItemArray, "FulfillmentItemArray");
  }
  /**
   * &lt;b&gt;[SERVICE COMMUNICATION ONLY]&lt;/b&gt; Fulfill rewards.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: fulfillment result&lt;/li&gt;&lt;li&gt;&lt;i&gt;rewards Item unsupported Type&lt;/i&gt;: SUBSCRIPTION&lt;/ul&gt;
   */
  createFulfillmentReward_ByUserId_v2(userId, data) {
    const params = {};
    const url = "/platform/v2/admin/namespaces/{namespace}/users/{userId}/fulfillment/rewards".replace("{namespace}", this.namespace).replace("{userId}", userId);
    const resultPromise = this.axiosInstance.post(url, data, { params });
    return import_sdk18.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, FulfillmentResult, "FulfillmentResult");
  }
  /**
   * &lt;b&gt;[Not supported yet in AGS Shared Cloud]&lt;/b&gt; Fulfill items by transactionId.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Request body&lt;/i&gt;: storeId, region, language, and entitlementCollectionId can be ignored.&lt;/li&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: fulfillment v2 result, storeId field can be ignored.&lt;/li&gt;&lt;/ul&gt;
   */
  updateFulfillment_ByUserId_ByTransactionId_v2(userId, transactionId, data) {
    const params = {};
    const url = "/platform/v2/admin/namespaces/{namespace}/users/{userId}/fulfillments/{transactionId}".replace("{namespace}", this.namespace).replace("{userId}", userId).replace("{transactionId}", transactionId);
    const resultPromise = this.axiosInstance.put(url, data, { params });
    return import_sdk18.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, FulfillmentV2Result, "FulfillmentV2Result");
  }
  /**
   * &lt;b&gt;[Not supported yet in AGS Shared Cloud]&lt;/b&gt; Retry fulfill items by transactionId without sending the original payload.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: fulfillment v2 result, storeId field can be ignored.&lt;/li&gt;&lt;/ul&gt;
   */
  updateRetry_ByUserId_ByTransactionId_v2(userId, transactionId) {
    const params = {};
    const url = "/platform/v2/admin/namespaces/{namespace}/users/{userId}/fulfillments/{transactionId}/retry".replace("{namespace}", this.namespace).replace("{userId}", userId).replace("{transactionId}", transactionId);
    const resultPromise = this.axiosInstance.put(url, null, { params });
    return import_sdk18.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, FulfillmentV2Result, "FulfillmentV2Result");
  }
  /**
   * &lt;b&gt;[Not supported yet in AGS Shared Cloud]&lt;/b&gt; Revoke items by transactionId.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: revoke fulfillment v2 result, storeId field can be ignored.&lt;/li&gt;&lt;/ul&gt;
   */
  updateRevoke_ByUserId_ByTransactionId_v2(userId, transactionId) {
    const params = {};
    const url = "/platform/v2/admin/namespaces/{namespace}/users/{userId}/fulfillments/{transactionId}/revoke".replace("{namespace}", this.namespace).replace("{userId}", userId).replace("{transactionId}", transactionId);
    const resultPromise = this.axiosInstance.put(url, null, { params });
    return import_sdk18.Validate.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      RevokeFulfillmentV2Result,
      "RevokeFulfillmentV2Result"
    );
  }
};

// src/generated-admin/endpoints/FulfillmentScriptAdmin$.ts
var import_sdk19 = require("@accelbyte/sdk");
var import_zod114 = require("zod");

// src/generated-definitions/FulfillmentScriptInfo.ts
var import_zod112 = require("zod");
var FulfillmentScriptInfo = import_zod112.z.object({ grantDays: import_zod112.z.string().nullish(), id: import_zod112.z.string().nullish() });

// src/generated-definitions/FulfillmentScriptInfoArray.ts
var import_zod113 = require("zod");
var FulfillmentScriptInfoArray = import_zod113.z.array(FulfillmentScriptInfo);

// src/generated-admin/endpoints/FulfillmentScriptAdmin$.ts
var FulfillmentScriptAdmin$ = class {
  // @ts-ignore
  // prettier-ignore
  constructor(axiosInstance, namespace, useSchemaValidation = true) {
    this.axiosInstance = axiosInstance;
    this.namespace = namespace;
    this.useSchemaValidation = useSchemaValidation;
  }
  /**
   * &lt;b&gt;[Not supported yet in AGS Shared Cloud]&lt;/b&gt;List all fulfillment scripts.
   */
  getFulfillmentScripts() {
    const params = {};
    const url = "/platform/admin/fulfillment/scripts";
    const resultPromise = this.axiosInstance.get(url, { params });
    return import_sdk19.Validate.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      FulfillmentScriptInfoArray,
      "FulfillmentScriptInfoArray"
    );
  }
  /**
   * &lt;b&gt;[Not supported yet in AGS Shared Cloud]&lt;/b&gt;Delete fulfillment script.
   */
  deleteFulfillmentScript_ById(id) {
    const params = {};
    const url = "/platform/admin/fulfillment/scripts/{id}".replace("{id}", id);
    const resultPromise = this.axiosInstance.delete(url, { params });
    return import_sdk19.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, import_zod114.z.unknown(), "z.unknown()");
  }
  /**
   * &lt;b&gt;[Not supported yet in AGS Shared Cloud]&lt;/b&gt;Get fulfillment script by id.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: get fulfillment script&lt;/li&gt;&lt;/ul&gt;
   */
  getFulfillmentScript_ById(id) {
    const params = {};
    const url = "/platform/admin/fulfillment/scripts/{id}".replace("{id}", id);
    const resultPromise = this.axiosInstance.get(url, { params });
    return import_sdk19.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, FulfillmentScriptInfo, "FulfillmentScriptInfo");
  }
  /**
   * &lt;b&gt;[Not supported yet in AGS Shared Cloud]&lt;/b&gt;Update fulfillment script.
   */
  patchFulfillmentScript_ById(id, data) {
    const params = {};
    const url = "/platform/admin/fulfillment/scripts/{id}".replace("{id}", id);
    const resultPromise = this.axiosInstance.patch(url, data, { params });
    return import_sdk19.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, FulfillmentScriptInfo, "FulfillmentScriptInfo");
  }
  /**
   * &lt;b&gt;[Not supported yet in AGS Shared Cloud]&lt;/b&gt;Create fulfillment script.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;/ul&gt;Fulfillment scripts are used for adding custom fulfillment logic based on &lt;b&gt;ITEM_TYPE&lt;/b&gt;: [MEDIA,INGAMEITEM] for now, and the custom scripts only cover grantDays.&lt;br&gt;Example for grantDays: &lt;br&gt;&lt;code&gt;order &amp;&amp; ((order.currency &amp;&amp; order.currency.currencyCode) == &#39;LP&#39; || order.isFree) ? 30 : -1&lt;/code&gt;&lt;br&gt;
   */
  createFulfillmentScript_ById(id, data) {
    const params = {};
    const url = "/platform/admin/fulfillment/scripts/{id}".replace("{id}", id);
    const resultPromise = this.axiosInstance.post(url, data, { params });
    return import_sdk19.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, FulfillmentScriptInfo, "FulfillmentScriptInfo");
  }
};

// src/generated-admin/endpoints/IapAdmin$.ts
var import_sdk20 = require("@accelbyte/sdk");
var import_zod134 = require("zod");

// src/generated-definitions/AppleIapConfigInfo.ts
var import_zod115 = require("zod");
var AppleIapConfigInfo = import_zod115.z.object({
  appAppleId: import_zod115.z.number().int().nullish(),
  authKeyFileName: import_zod115.z.string().nullish(),
  bundleId: import_zod115.z.string().nullish(),
  issuerId: import_zod115.z.string().nullish(),
  keyId: import_zod115.z.string().nullish(),
  namespace: import_zod115.z.string(),
  password: import_zod115.z.string().nullish(),
  version: import_zod115.z.enum(["V1", "V2"]).nullish()
});

// src/generated-definitions/EpicGamesIapConfigInfo.ts
var import_zod116 = require("zod");
var EpicGamesIapConfigInfo = import_zod116.z.object({ namespace: import_zod116.z.string(), sandboxId: import_zod116.z.string().nullish() });

// src/generated-definitions/GoogleIapConfigInfo.ts
var import_zod117 = require("zod");
var GoogleIapConfigInfo = import_zod117.z.object({
  applicationName: import_zod117.z.string().nullish(),
  namespace: import_zod117.z.string(),
  notificationTokenAudience: import_zod117.z.string().nullish(),
  notificationTokenEmail: import_zod117.z.string().nullish(),
  p12FileName: import_zod117.z.string().nullish(),
  serviceAccountId: import_zod117.z.string().nullish()
});

// src/generated-definitions/IapConsumeHistoryPagingSlicedResult.ts
var import_zod122 = require("zod");

// src/generated-definitions/IapConsumeHistoryInfo.ts
var import_zod121 = require("zod");

// src/generated-definitions/ClientRequestParameter.ts
var import_zod118 = require("zod");
var ClientRequestParameter = import_zod118.z.object({
  currencyCode: import_zod118.z.string().nullish(),
  language: import_zod118.z.string().nullish(),
  price: import_zod118.z.number().nullish(),
  region: import_zod118.z.string().nullish()
});

// src/generated-definitions/ConsumeItem.ts
var import_zod119 = require("zod");
var ConsumeItem = import_zod119.z.object({
  extItemDefId: import_zod119.z.string().nullish(),
  extItemId: import_zod119.z.string().nullish(),
  itemIdentity: import_zod119.z.string().nullish(),
  itemIdentityType: import_zod119.z.enum(["ITEM_ID", "ITEM_SKU"]).nullish()
});

// src/generated-definitions/RequestHistory.ts
var import_zod120 = require("zod");
var RequestHistory = import_zod120.z.object({
  requestTime: import_zod120.z.string().nullish(),
  responseBody: import_zod120.z.record(import_zod120.z.any()).nullish(),
  responseTime: import_zod120.z.string().nullish(),
  status: import_zod120.z.enum(["FAIL", "PENDING", "SUCCESS"]).nullish(),
  statusCode: import_zod120.z.number().int().nullish()
});

// src/generated-definitions/IapConsumeHistoryInfo.ts
var IapConsumeHistoryInfo = import_zod121.z.object({
  clientRequestParameter: ClientRequestParameter.nullish(),
  consumeItems: import_zod121.z.array(ConsumeItem).nullish(),
  iapType: import_zod121.z.enum(["APPLE", "EPICGAMES", "GOOGLE", "OCULUS", "PLAYSTATION", "STADIA", "STEAM", "TWITCH", "XBOX"]).nullish(),
  id: import_zod121.z.string().nullish(),
  namespace: import_zod121.z.string().nullish(),
  requestBody: import_zod121.z.record(import_zod121.z.any()).nullish(),
  requestHistories: import_zod121.z.array(RequestHistory).nullish(),
  requestUrl: import_zod121.z.string().nullish(),
  status: import_zod121.z.enum(["FAIL", "PENDING", "SUCCESS"]).nullish(),
  userId: import_zod121.z.string().nullish()
});

// src/generated-definitions/IapConsumeHistoryPagingSlicedResult.ts
var IapConsumeHistoryPagingSlicedResult = import_zod122.z.object({ data: import_zod122.z.array(IapConsumeHistoryInfo), paging: Paging.nullish() });

// src/generated-definitions/IapItemConfigInfo.ts
var import_zod124 = require("zod");

// src/generated-definitions/IapItemEntry.ts
var import_zod123 = require("zod");
var IapItemEntry = import_zod123.z.object({
  itemIdentity: import_zod123.z.string().nullish(),
  itemIdentityType: import_zod123.z.enum(["ITEM_ID", "ITEM_SKU"]).nullish(),
  platformProductIdMap: import_zod123.z.record(import_zod123.z.string()).nullish()
});

// src/generated-definitions/IapItemConfigInfo.ts
var IapItemConfigInfo = import_zod124.z.object({ data: import_zod124.z.array(IapItemEntry).nullish() });

// src/generated-definitions/IapOrderPagingSlicedResult.ts
var import_zod126 = require("zod");

// src/generated-definitions/IapOrderInfo.ts
var import_zod125 = require("zod");
var IapOrderInfo = import_zod125.z.object({
  createdAt: import_zod125.z.string(),
  credits: import_zod125.z.array(CreditSummary).nullish(),
  currencyCode: import_zod125.z.string().nullish(),
  entitlements: import_zod125.z.array(EntitlementSummary).nullish(),
  fulfilledTime: import_zod125.z.string().nullish(),
  iapOrderNo: import_zod125.z.string(),
  language: import_zod125.z.string().nullish(),
  namespace: import_zod125.z.string(),
  price: import_zod125.z.number().nullish(),
  productId: import_zod125.z.string().nullish(),
  quantity: import_zod125.z.number().int().nullish(),
  receiptData: import_zod125.z.string().nullish(),
  region: import_zod125.z.string().nullish(),
  retryCount: import_zod125.z.number().int().nullish(),
  sandbox: import_zod125.z.boolean().nullish(),
  status: import_zod125.z.enum(["FAILED", "FULFILLED", "VERIFIED"]),
  statusReason: import_zod125.z.string().nullish(),
  transactionId: import_zod125.z.string().nullish(),
  type: import_zod125.z.enum(["APPLE", "EPICGAMES", "GOOGLE", "OCULUS", "PLAYSTATION", "STADIA", "STEAM", "TWITCH", "XBOX"]),
  updatedAt: import_zod125.z.string(),
  userId: import_zod125.z.string()
});

// src/generated-definitions/IapOrderPagingSlicedResult.ts
var IapOrderPagingSlicedResult = import_zod126.z.object({ data: import_zod126.z.array(IapOrderInfo), paging: Paging.nullish() });

// src/generated-definitions/OculusIapConfigInfo.ts
var import_zod127 = require("zod");
var OculusIapConfigInfo = import_zod127.z.object({ appId: import_zod127.z.string().nullish(), appSecret: import_zod127.z.string().nullish(), namespace: import_zod127.z.string() });

// src/generated-definitions/PlayStationIapConfigInfo.ts
var import_zod128 = require("zod");
var PlayStationIapConfigInfo = import_zod128.z.object({
  backOfficeServerClientId: import_zod128.z.string().nullish(),
  backOfficeServerClientSecret: import_zod128.z.string().nullish(),
  enableStreamJob: import_zod128.z.boolean().nullish(),
  environment: import_zod128.z.string().nullish(),
  namespace: import_zod128.z.string(),
  streamName: import_zod128.z.string().nullish(),
  streamPartnerName: import_zod128.z.string().nullish()
});

// src/generated-definitions/SteamIapConfig.ts
var import_zod129 = require("zod");
var SteamIapConfig = import_zod129.z.object({
  appId: import_zod129.z.string().nullish(),
  createdAt: import_zod129.z.string().nullish(),
  namespace: import_zod129.z.string().nullish(),
  publisherAuthenticationKey: import_zod129.z.string().nullish(),
  rvn: import_zod129.z.number().int().nullish(),
  updatedAt: import_zod129.z.string().nullish()
});

// src/generated-definitions/SteamIapConfigInfo.ts
var import_zod130 = require("zod");
var SteamIapConfigInfo = import_zod130.z.object({ appId: import_zod130.z.string().nullish(), namespace: import_zod130.z.string(), publisherAuthenticationKey: import_zod130.z.string() });

// src/generated-definitions/TestResult.ts
var import_zod131 = require("zod");
var TestResult = import_zod131.z.object({ msg: import_zod131.z.string().nullish(), success: import_zod131.z.boolean() });

// src/generated-definitions/TwitchIapConfigInfo.ts
var import_zod132 = require("zod");
var TwitchIapConfigInfo = import_zod132.z.object({
  clientId: import_zod132.z.string().nullish(),
  clientSecret: import_zod132.z.string().nullish(),
  namespace: import_zod132.z.string(),
  organizationId: import_zod132.z.string().nullish()
});

// src/generated-definitions/XblIapConfigInfo.ts
var import_zod133 = require("zod");
var XblIapConfigInfo = import_zod133.z.object({
  businessPartnerCertExpiredTime: import_zod133.z.string().nullish(),
  businessPartnerCertFileName: import_zod133.z.string().nullish(),
  namespace: import_zod133.z.string(),
  password: import_zod133.z.string().nullish(),
  relyingPartyCert: import_zod133.z.string().nullish()
});

// src/generated-admin/endpoints/IapAdmin$.ts
var IapAdmin$ = class {
  // @ts-ignore
  // prettier-ignore
  constructor(axiosInstance, namespace, useSchemaValidation = true) {
    this.axiosInstance = axiosInstance;
    this.namespace = namespace;
    this.useSchemaValidation = useSchemaValidation;
  }
  /**
   * Delete xbl iap config.
   */
  deleteIapConfigXbl() {
    const params = {};
    const url = "/platform/admin/namespaces/{namespace}/iap/config/xbl".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.delete(url, { params });
    return import_sdk20.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, import_zod134.z.unknown(), "z.unknown()");
  }
  /**
   * Get xbox iap config.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: xbox iap config&lt;/li&gt;&lt;/ul&gt;
   */
  getIapConfigXbl() {
    const params = {};
    const url = "/platform/admin/namespaces/{namespace}/iap/config/xbl".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.get(url, { params });
    return import_sdk20.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, XblIapConfigInfo, "XblIapConfigInfo");
  }
  /**
   * Update xbl iap config. Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: updated xbl iap config&lt;/li&gt;&lt;/ul&gt;
   */
  updateIapConfigXbl(data) {
    const params = {};
    const url = "/platform/admin/namespaces/{namespace}/iap/config/xbl".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.put(url, data, { params });
    return import_sdk20.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, XblIapConfigInfo, "XblIapConfigInfo");
  }
  /**
   * delete a iap item config.
   */
  deleteIapConfigItem() {
    const params = {};
    const url = "/platform/admin/namespaces/{namespace}/iap/config/item".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.delete(url, { params });
    return import_sdk20.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, import_zod134.z.unknown(), "z.unknown()");
  }
  /**
   * Get iap item config.
   */
  getIapConfigItem() {
    const params = {};
    const url = "/platform/admin/namespaces/{namespace}/iap/config/item".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.get(url, { params });
    return import_sdk20.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, IapItemConfigInfo, "IapItemConfigInfo");
  }
  /**
   * Update iap item config. Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: updated iap item config&lt;/li&gt;&lt;/ul&gt;
   */
  updateIapConfigItem(data) {
    const params = {};
    const url = "/platform/admin/namespaces/{namespace}/iap/config/item".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.put(url, data, { params });
    return import_sdk20.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, IapItemConfigInfo, "IapItemConfigInfo");
  }
  /**
   * Delete apple iap config.
   */
  deleteIapConfigApple() {
    const params = {};
    const url = "/platform/admin/namespaces/{namespace}/iap/config/apple".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.delete(url, { params });
    return import_sdk20.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, import_zod134.z.unknown(), "z.unknown()");
  }
  /**
   * Get apple iap config.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: apple iap config&lt;/li&gt;&lt;/ul&gt;
   */
  getIapConfigApple() {
    const params = {};
    const url = "/platform/admin/namespaces/{namespace}/iap/config/apple".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.get(url, { params });
    return import_sdk20.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, AppleIapConfigInfo, "AppleIapConfigInfo");
  }
  /**
   * Update apple iap config. Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: updated apple iap config&lt;/li&gt;&lt;/ul&gt;
   */
  updateIapConfigApple(data) {
    const params = {};
    const url = "/platform/admin/namespaces/{namespace}/iap/config/apple".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.put(url, data, { params });
    return import_sdk20.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, AppleIapConfigInfo, "AppleIapConfigInfo");
  }
  /**
   * Delete steam iap config.
   */
  deleteIapConfigSteam() {
    const params = {};
    const url = "/platform/admin/namespaces/{namespace}/iap/config/steam".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.delete(url, { params });
    return import_sdk20.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, import_zod134.z.unknown(), "z.unknown()");
  }
  /**
   * Get steam iap config.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: steam iap config&lt;/li&gt;&lt;/ul&gt;
   */
  getIapConfigSteam() {
    const params = {};
    const url = "/platform/admin/namespaces/{namespace}/iap/config/steam".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.get(url, { params });
    return import_sdk20.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, SteamIapConfig, "SteamIapConfig");
  }
  /**
   * Update steam iap config. Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: updated steam iap config&lt;/li&gt;&lt;/ul&gt;
   */
  updateIapConfigSteam(data) {
    const params = {};
    const url = "/platform/admin/namespaces/{namespace}/iap/config/steam".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.put(url, data, { params });
    return import_sdk20.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, SteamIapConfigInfo, "SteamIapConfigInfo");
  }
  /**
   * Delete google iap config.
   */
  deleteIapConfigGoogle() {
    const params = {};
    const url = "/platform/admin/namespaces/{namespace}/iap/config/google".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.delete(url, { params });
    return import_sdk20.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, import_zod134.z.unknown(), "z.unknown()");
  }
  /**
   * Get google iap config.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: google iap config&lt;/li&gt;&lt;/ul&gt;
   */
  getIapConfigGoogle() {
    const params = {};
    const url = "/platform/admin/namespaces/{namespace}/iap/config/google".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.get(url, { params });
    return import_sdk20.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, GoogleIapConfigInfo, "GoogleIapConfigInfo");
  }
  /**
   * Update google iap config. Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: updated google iap config&lt;/li&gt;&lt;/ul&gt;
   */
  updateIapConfigGoogle(data) {
    const params = {};
    const url = "/platform/admin/namespaces/{namespace}/iap/config/google".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.put(url, data, { params });
    return import_sdk20.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, GoogleIapConfigInfo, "GoogleIapConfigInfo");
  }
  /**
   * Delete oculus iap config.
   */
  deleteIapConfigOculu() {
    const params = {};
    const url = "/platform/admin/namespaces/{namespace}/iap/config/oculus".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.delete(url, { params });
    return import_sdk20.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, import_zod134.z.unknown(), "z.unknown()");
  }
  /**
   * Get oculus iap config.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: steam iap config&lt;/li&gt;&lt;/ul&gt;
   */
  getIapConfigOculus() {
    const params = {};
    const url = "/platform/admin/namespaces/{namespace}/iap/config/oculus".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.get(url, { params });
    return import_sdk20.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, OculusIapConfigInfo, "OculusIapConfigInfo");
  }
  /**
   * Update oculus iap config. Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: updated steam iap config&lt;/li&gt;&lt;/ul&gt;
   */
  updateIapConfigOculu(data) {
    const params = {};
    const url = "/platform/admin/namespaces/{namespace}/iap/config/oculus".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.put(url, data, { params });
    return import_sdk20.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, OculusIapConfigInfo, "OculusIapConfigInfo");
  }
  /**
   * Delete twitch iap config.
   */
  deleteIapConfigTwitch() {
    const params = {};
    const url = "/platform/admin/namespaces/{namespace}/iap/config/twitch".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.delete(url, { params });
    return import_sdk20.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, import_zod134.z.unknown(), "z.unknown()");
  }
  /**
   * Get twitch iap config.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: twitch iap config&lt;/li&gt;&lt;/ul&gt;
   */
  getIapConfigTwitch() {
    const params = {};
    const url = "/platform/admin/namespaces/{namespace}/iap/config/twitch".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.get(url, { params });
    return import_sdk20.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, TwitchIapConfigInfo, "TwitchIapConfigInfo");
  }
  /**
   * Update twitch iap config. Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: updated twitch iap config&lt;/li&gt;&lt;/ul&gt;
   */
  updateIapConfigTwitch(data) {
    const params = {};
    const url = "/platform/admin/namespaces/{namespace}/iap/config/twitch".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.put(url, data, { params });
    return import_sdk20.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, TwitchIapConfigInfo, "TwitchIapConfigInfo");
  }
  /**
   * Query IAP orders.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: paginated iap orders&lt;/li&gt;&lt;/ul&gt;
   */
  getIap_ByUserId(userId, queryParams) {
    const params = { limit: 20, ...queryParams };
    const url = "/platform/admin/namespaces/{namespace}/users/{userId}/iap".replace("{namespace}", this.namespace).replace("{userId}", userId);
    const resultPromise = this.axiosInstance.get(url, { params });
    return import_sdk20.Validate.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      IapOrderPagingSlicedResult,
      "IapOrderPagingSlicedResult"
    );
  }
  /**
   * Upload xbl business partner cert file.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: updated xbl iap config&lt;/li&gt;&lt;/ul&gt;
   */
  updateIapConfigXblCert(data) {
    const params = {};
    const url = "/platform/admin/namespaces/{namespace}/iap/config/xbl/cert".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.put(url, data, { params });
    return import_sdk20.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, XblIapConfigInfo, "XblIapConfigInfo");
  }
  /**
   * Delete epic games iap config.
   */
  deleteIapConfigEpicgame() {
    const params = {};
    const url = "/platform/admin/namespaces/{namespace}/iap/config/epicgames".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.delete(url, { params });
    return import_sdk20.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, import_zod134.z.unknown(), "z.unknown()");
  }
  /**
   * Get epic games iap config.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: epic games iap config&lt;/li&gt;&lt;/ul&gt;
   */
  getIapConfigEpicgames() {
    const params = {};
    const url = "/platform/admin/namespaces/{namespace}/iap/config/epicgames".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.get(url, { params });
    return import_sdk20.Validate.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      EpicGamesIapConfigInfo,
      "EpicGamesIapConfigInfo"
    );
  }
  /**
   * Update epic games iap config. Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: updated epic games iap config&lt;/li&gt;&lt;/ul&gt;
   */
  updateIapConfigEpicgame(data) {
    const params = {};
    const url = "/platform/admin/namespaces/{namespace}/iap/config/epicgames".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.put(url, data, { params });
    return import_sdk20.Validate.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      EpicGamesIapConfigInfo,
      "EpicGamesIapConfigInfo"
    );
  }
  /**
   * Upload Apple Store p8 file.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: updated apple iap config&lt;/li&gt;&lt;/ul&gt;
   */
  updateIapConfigAppleCert(data) {
    const params = {};
    const url = "/platform/admin/namespaces/{namespace}/iap/config/apple/cert".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.put(url, data, { params });
    return import_sdk20.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, AppleIapConfigInfo, "AppleIapConfigInfo");
  }
  /**
   * Upload google play p12 file.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: updated google iap config&lt;/li&gt;&lt;/ul&gt;
   */
  updateIapConfigGoogleCert(data) {
    const params = {};
    const url = "/platform/admin/namespaces/{namespace}/iap/config/google/cert".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.put(url, data, { params });
    return import_sdk20.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, GoogleIapConfigInfo, "GoogleIapConfigInfo");
  }
  /**
   * Delete playstation iap config.
   */
  deleteIapConfigPlaystation() {
    const params = {};
    const url = "/platform/admin/namespaces/{namespace}/iap/config/playstation".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.delete(url, { params });
    return import_sdk20.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, import_zod134.z.unknown(), "z.unknown()");
  }
  /**
   * Get playstation iap config.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: playstation iap config&lt;/li&gt;&lt;/ul&gt;
   */
  getIapConfigPlaystation() {
    const params = {};
    const url = "/platform/admin/namespaces/{namespace}/iap/config/playstation".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.get(url, { params });
    return import_sdk20.Validate.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      PlayStationIapConfigInfo,
      "PlayStationIapConfigInfo"
    );
  }
  /**
   * Update playstation iap config. Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: updated playstation iap config&lt;/li&gt;&lt;/ul&gt;
   */
  updateIapConfigPlaystation(data) {
    const params = {};
    const url = "/platform/admin/namespaces/{namespace}/iap/config/playstation".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.put(url, data, { params });
    return import_sdk20.Validate.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      PlayStationIapConfigInfo,
      "PlayStationIapConfigInfo"
    );
  }
  /**
   * Query all user IAP orders.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: list of iap orders&lt;/li&gt;&lt;/ul&gt;
   */
  getIapAll_ByUserId(userId) {
    const params = {};
    const url = "/platform/admin/namespaces/{namespace}/users/{userId}/iap/all".replace("{namespace}", this.namespace).replace("{userId}", userId);
    const resultPromise = this.axiosInstance.get(url, { params });
    return import_sdk20.Validate.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      IapOrderPagingSlicedResult,
      "IapOrderPagingSlicedResult"
    );
  }
  /**
   * Validate playstation iap config. Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: Test Results&lt;/li&gt;&lt;/ul&gt;
   */
  getIapConfigPlaystationValidate() {
    const params = {};
    const url = "/platform/admin/namespaces/{namespace}/iap/config/playstation/validate".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.get(url, { params });
    return import_sdk20.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, TestResult, "TestResult");
  }
  /**
   * Validate playstation iap config. Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: Test Results&lt;/li&gt;&lt;/ul&gt;
   */
  updateIapConfigPlaystationValidate(data) {
    const params = {};
    const url = "/platform/admin/namespaces/{namespace}/iap/config/playstation/validate".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.put(url, data, { params });
    return import_sdk20.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, TestResult, "TestResult");
  }
  /**
   * &lt;b&gt;[TEST FACILITY ONLY] Forbidden in live environment. &lt;/b&gt; Mock fulfill iap item without validate receipt.Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: &lt;/li&gt;&lt;/ul&gt;
   */
  updateIapMockReceipt_ByUserId(userId, data) {
    const params = {};
    const url = "/platform/admin/namespaces/{namespace}/users/{userId}/iap/mock/receipt".replace("{namespace}", this.namespace).replace("{userId}", userId);
    const resultPromise = this.axiosInstance.put(url, data, { params });
    return import_sdk20.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, import_zod134.z.unknown(), "z.unknown()");
  }
  /**
   * Query IAP consume history.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: paginated iap consume history&lt;/li&gt;&lt;/ul&gt;
   */
  getIapConsumeHistory_ByUserId(userId, queryParams) {
    const params = { limit: 20, ...queryParams };
    const url = "/platform/admin/namespaces/{namespace}/users/{userId}/iap/consume/history".replace("{namespace}", this.namespace).replace("{userId}", userId);
    const resultPromise = this.axiosInstance.get(url, { params });
    return import_sdk20.Validate.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      IapConsumeHistoryPagingSlicedResult,
      "IapConsumeHistoryPagingSlicedResult"
    );
  }
};

// src/generated-admin/endpoints/IapNotificationAdmin$.ts
var import_sdk21 = require("@accelbyte/sdk");

// src/generated-definitions/NotificationPagingSlicedResult.ts
var import_zod135 = require("zod");
var NotificationPagingSlicedResult = import_zod135.z.any();

// src/generated-admin/endpoints/IapNotificationAdmin$.ts
var IapNotificationAdmin$ = class {
  // @ts-ignore
  // prettier-ignore
  constructor(axiosInstance, namespace, useSchemaValidation = true) {
    this.axiosInstance = axiosInstance;
    this.namespace = namespace;
    this.useSchemaValidation = useSchemaValidation;
  }
  /**
   * Query third party notifications.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: Third Party Platform notifications&lt;/li&gt;&lt;/ul&gt;
   */
  getIapNotifications(queryParams) {
    const params = { limit: 20, ...queryParams };
    const url = "/platform/admin/namespaces/{namespace}/iap/notifications".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.get(url, { params });
    return import_sdk21.Validate.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      NotificationPagingSlicedResult,
      "NotificationPagingSlicedResult"
    );
  }
};

// src/generated-admin/endpoints/IapSubscriptionAdmin$.ts
var import_sdk22 = require("@accelbyte/sdk");

// src/generated-definitions/ThirdPartySubscriptionOwnership.ts
var import_zod136 = require("zod");
var ThirdPartySubscriptionOwnership = import_zod136.z.object({ owned: import_zod136.z.boolean() });

// src/generated-definitions/ThirdPartySubscriptionTransactionHistoryPagingSlicedResult.ts
var import_zod138 = require("zod");

// src/generated-definitions/ThirdPartySubscriptionTransactionHistoryInfo.ts
var import_zod137 = require("zod");
var ThirdPartySubscriptionTransactionHistoryInfo = import_zod137.z.object({
  createdAt: import_zod137.z.string().nullish(),
  expiredAt: import_zod137.z.string().nullish(),
  id: import_zod137.z.string(),
  lastTransactionId: import_zod137.z.string().nullish(),
  namespace: import_zod137.z.string(),
  operator: import_zod137.z.string().nullish(),
  reason: import_zod137.z.string().nullish(),
  status: import_zod137.z.enum([
    "ACTIVE",
    "BILLING_RETRY_PERIOD",
    "CANCELED",
    "EXPIRED",
    "IN_GRACE_PERIOD",
    "ON_HOLD",
    "PAUSED",
    "PENDING",
    "REVOKED",
    "UNKNOWN"
  ]),
  subscriptionProductId: import_zod137.z.string().nullish(),
  thirdPartySubscriptionId: import_zod137.z.string(),
  updatedAt: import_zod137.z.string().nullish(),
  userId: import_zod137.z.string()
});

// src/generated-definitions/ThirdPartySubscriptionTransactionHistoryPagingSlicedResult.ts
var ThirdPartySubscriptionTransactionHistoryPagingSlicedResult = import_zod138.z.object({
  data: import_zod138.z.array(ThirdPartySubscriptionTransactionHistoryInfo),
  paging: Paging.nullish()
});

// src/generated-definitions/ThirdPartySubscriptionTransactionInfo.ts
var import_zod139 = require("zod");
var ThirdPartySubscriptionTransactionInfo = import_zod139.z.object({
  active: import_zod139.z.boolean(),
  createdAt: import_zod139.z.string().nullish(),
  expiredAt: import_zod139.z.string(),
  id: import_zod139.z.string(),
  lastTransactionId: import_zod139.z.string().nullish(),
  namespace: import_zod139.z.string(),
  originalTransactionId: import_zod139.z.string(),
  platform: import_zod139.z.enum(["APPLE", "EPICGAMES", "GOOGLE", "OCULUS", "PLAYSTATION", "STADIA", "STEAM", "TWITCH", "XBOX"]),
  purchaseToken: import_zod139.z.string().nullish(),
  startAt: import_zod139.z.string().nullish(),
  status: import_zod139.z.enum([
    "ACTIVE",
    "BILLING_RETRY_PERIOD",
    "CANCELED",
    "EXPIRED",
    "IN_GRACE_PERIOD",
    "ON_HOLD",
    "PAUSED",
    "PENDING",
    "REVOKED",
    "UNKNOWN"
  ]),
  subscriptionGroupId: import_zod139.z.string().nullish(),
  subscriptionProductId: import_zod139.z.string(),
  updatedAt: import_zod139.z.string().nullish(),
  userId: import_zod139.z.string()
});

// src/generated-definitions/ThirdPartySubscriptionTransactionPagingSlicedResult.ts
var import_zod140 = require("zod");
var ThirdPartySubscriptionTransactionPagingSlicedResult = import_zod140.z.object({
  data: import_zod140.z.array(ThirdPartySubscriptionTransactionInfo),
  paging: Paging.nullish()
});

// src/generated-definitions/ThirdPartyUserSubscriptionInfo.ts
var import_zod141 = require("zod");
var ThirdPartyUserSubscriptionInfo = import_zod141.z.object({
  active: import_zod141.z.boolean(),
  createdAt: import_zod141.z.string().nullish(),
  expiredAt: import_zod141.z.string(),
  id: import_zod141.z.string(),
  lastTransactionId: import_zod141.z.string().nullish(),
  namespace: import_zod141.z.string(),
  platform: import_zod141.z.enum(["APPLE", "EPICGAMES", "GOOGLE", "OCULUS", "PLAYSTATION", "STADIA", "STEAM", "TWITCH", "XBOX"]),
  startAt: import_zod141.z.string().nullish(),
  status: import_zod141.z.enum([
    "ACTIVE",
    "BILLING_RETRY_PERIOD",
    "CANCELED",
    "EXPIRED",
    "IN_GRACE_PERIOD",
    "ON_HOLD",
    "PAUSED",
    "PENDING",
    "REVOKED",
    "UNKNOWN"
  ]),
  subscriptionGroupId: import_zod141.z.string().nullish(),
  subscriptionProductId: import_zod141.z.string(),
  updatedAt: import_zod141.z.string().nullish(),
  userId: import_zod141.z.string()
});

// src/generated-definitions/ThirdPartyUserSubscriptionPagingSlicedResult.ts
var import_zod142 = require("zod");
var ThirdPartyUserSubscriptionPagingSlicedResult = import_zod142.z.object({
  data: import_zod142.z.array(ThirdPartyUserSubscriptionInfo),
  paging: Paging.nullish()
});

// src/generated-admin/endpoints/IapSubscriptionAdmin$.ts
var IapSubscriptionAdmin$ = class {
  // @ts-ignore
  // prettier-ignore
  constructor(axiosInstance, namespace, useSchemaValidation = true) {
    this.axiosInstance = axiosInstance;
    this.namespace = namespace;
    this.useSchemaValidation = useSchemaValidation;
  }
  /**
   * Query subscriptions, default sort by updatedAt Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: &lt;/li&gt;&lt;/ul&gt;
   */
  getIapSubscriptions(queryParams) {
    const params = { limit: 20, ...queryParams };
    const url = "/platform/admin/namespaces/{namespace}/iap/subscriptions".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.get(url, { params });
    return import_sdk22.Validate.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      ThirdPartyUserSubscriptionPagingSlicedResult,
      "ThirdPartyUserSubscriptionPagingSlicedResult"
    );
  }
  /**
   * Query user subscription, default sort by updatedAtOther detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: &lt;/li&gt;&lt;/ul&gt;
   */
  getIapSubscriptions_ByUserId(userId, queryParams) {
    const params = { limit: 20, ...queryParams };
    const url = "/platform/admin/namespaces/{namespace}/users/{userId}/iap/subscriptions".replace("{namespace}", this.namespace).replace("{userId}", userId);
    const resultPromise = this.axiosInstance.get(url, { params });
    return import_sdk22.Validate.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      ThirdPartyUserSubscriptionPagingSlicedResult,
      "ThirdPartyUserSubscriptionPagingSlicedResult"
    );
  }
  /**
   * Admin get user subscription details.Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: &lt;/li&gt;&lt;/ul&gt;
   */
  getIapSubscription_ByUserId_ById(userId, id) {
    const params = {};
    const url = "/platform/admin/namespaces/{namespace}/users/{userId}/iap/subscriptions/{id}".replace("{namespace}", this.namespace).replace("{userId}", userId).replace("{id}", id);
    const resultPromise = this.axiosInstance.get(url, { params });
    return import_sdk22.Validate.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      ThirdPartyUserSubscriptionInfo,
      "ThirdPartyUserSubscriptionInfo"
    );
  }
  /**
   * Sync Subscription Status
   */
  updateSyncIap_ByUserId_ById(userId, id) {
    const params = {};
    const url = "/platform/admin/namespaces/{namespace}/users/{userId}/iap/subscriptions/{id}/sync".replace("{namespace}", this.namespace).replace("{userId}", userId).replace("{id}", id);
    const resultPromise = this.axiosInstance.put(url, null, { params });
    return import_sdk22.Validate.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      ThirdPartyUserSubscriptionInfo,
      "ThirdPartyUserSubscriptionInfo"
    );
  }
  /**
   * Admin query user subscription transactions, default sort by startAt timeOther detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: &lt;/li&gt;&lt;/ul&gt;
   */
  getIapSubscriptionsTransactions_ByUserId(userId, queryParams) {
    const params = { limit: 20, ...queryParams };
    const url = "/platform/admin/namespaces/{namespace}/users/{userId}/iap/subscriptions/transactions".replace("{namespace}", this.namespace).replace("{userId}", userId);
    const resultPromise = this.axiosInstance.get(url, { params });
    return import_sdk22.Validate.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      ThirdPartySubscriptionTransactionPagingSlicedResult,
      "ThirdPartySubscriptionTransactionPagingSlicedResult"
    );
  }
  /**
   * Admin get user subscription details.Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: &lt;/li&gt;&lt;/ul&gt;
   */
  getIapSubscriptionTransaction_ByUserId_ById(userId, id) {
    const params = {};
    const url = "/platform/admin/namespaces/{namespace}/users/{userId}/iap/subscriptions/transactions/{id}".replace("{namespace}", this.namespace).replace("{userId}", userId).replace("{id}", id);
    const resultPromise = this.axiosInstance.get(url, { params });
    return import_sdk22.Validate.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      ThirdPartySubscriptionTransactionInfo,
      "ThirdPartySubscriptionTransactionInfo"
    );
  }
  /**
   * Sync Subscription Status
   */
  updateSyncSubscriptionIap_ByUserId_ById(userId, id) {
    const params = {};
    const url = "/platform/admin/namespaces/{namespace}/users/{userId}/iap/subscriptions/transactions/{id}/sync".replace("{namespace}", this.namespace).replace("{userId}", userId).replace("{id}", id);
    const resultPromise = this.axiosInstance.put(url, null, { params });
    return import_sdk22.Validate.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      ThirdPartySubscriptionTransactionInfo,
      "ThirdPartySubscriptionTransactionInfo"
    );
  }
  /**
   * Get Subscription Transaction Update History
   */
  getHistoriesSubscriptionsIap_ByUserId_ById(userId, id, queryParams) {
    const params = { limit: 20, ...queryParams };
    const url = "/platform/admin/namespaces/{namespace}/users/{userId}/iap/subscriptions/transactions/{id}/histories".replace("{namespace}", this.namespace).replace("{userId}", userId).replace("{id}", id);
    const resultPromise = this.axiosInstance.get(url, { params });
    return import_sdk22.Validate.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      ThirdPartySubscriptionTransactionHistoryPagingSlicedResult,
      "ThirdPartySubscriptionTransactionHistoryPagingSlicedResult"
    );
  }
  /**
   * Get user third party subscription by subscription group id.
   */
  getOwnershipByGroupIdSubscriptionsIap_ByUserId_ByPlatform(userId, platform, queryParams) {
    const params = { ...queryParams };
    const url = "/platform/admin/namespaces/{namespace}/users/{userId}/iap/subscriptions/platforms/{platform}/ownership/byGroupId".replace("{namespace}", this.namespace).replace("{userId}", userId).replace("{platform}", platform);
    const resultPromise = this.axiosInstance.get(url, { params });
    return import_sdk22.Validate.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      ThirdPartySubscriptionOwnership,
      "ThirdPartySubscriptionOwnership"
    );
  }
  /**
   * Get user third party subscription by subscription product id.
   */
  getOwnershipByProductIdSubscriptionsIap_ByUserId_ByPlatform(userId, platform, queryParams) {
    const params = { ...queryParams };
    const url = "/platform/admin/namespaces/{namespace}/users/{userId}/iap/subscriptions/platforms/{platform}/ownership/byProductId".replace("{namespace}", this.namespace).replace("{userId}", userId).replace("{platform}", platform);
    const resultPromise = this.axiosInstance.get(url, { params });
    return import_sdk22.Validate.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      ThirdPartySubscriptionOwnership,
      "ThirdPartySubscriptionOwnership"
    );
  }
};

// src/generated-admin/endpoints/InvoiceAdmin$.ts
var import_sdk23 = require("@accelbyte/sdk");
var import_zod145 = require("zod");

// src/generated-definitions/InvoiceSummary.ts
var import_zod144 = require("zod");

// src/generated-definitions/InvoiceCurrencySummary.ts
var import_zod143 = require("zod");
var InvoiceCurrencySummary = import_zod143.z.object({
  currency: CurrencySummary,
  salesVolume: import_zod143.z.number().int(),
  subtotalPrice: import_zod143.z.number().int(),
  totalPrice: import_zod143.z.number().int(),
  totalTax: import_zod143.z.number().int()
});

// src/generated-definitions/InvoiceSummary.ts
var InvoiceSummary = import_zod144.z.object({ invoiceCurrencySummary: import_zod144.z.array(InvoiceCurrencySummary), totalSalesVolume: import_zod144.z.number().int() });

// src/generated-admin/endpoints/InvoiceAdmin$.ts
var InvoiceAdmin$ = class {
  // @ts-ignore
  // prettier-ignore
  constructor(axiosInstance, namespace, useSchemaValidation = true) {
    this.axiosInstance = axiosInstance;
    this.namespace = namespace;
    this.useSchemaValidation = useSchemaValidation;
  }
  /**
   * Generate invoice summary.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: query orders&lt;/li&gt;&lt;/ul&gt;
   */
  getInvoiceSummary(queryParams) {
    const params = { ...queryParams };
    const url = "/platform/admin/namespaces/{namespace}/invoice/summary".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.get(url, { params });
    return import_sdk23.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, InvoiceSummary, "InvoiceSummary");
  }
  /**
   * Download invoice details as a csv file.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: invoice details csv file&lt;/li&gt;&lt;/ul&gt;
   */
  getInvoiceDetailsCsv(queryParams) {
    const params = { ...queryParams };
    const url = "/platform/admin/namespaces/{namespace}/invoice/details.csv".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.get(url, { params });
    return import_sdk23.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, import_zod145.z.unknown(), "z.unknown()");
  }
};

// src/generated-admin/endpoints/ItemAdmin$.ts
var import_sdk24 = require("@accelbyte/sdk");
var import_zod181 = require("zod");

// src/generated-definitions/AvailablePredicateArray.ts
var import_zod148 = require("zod");

// src/generated-definitions/AvailablePredicate.ts
var import_zod147 = require("zod");

// src/generated-definitions/AvailableComparison.ts
var import_zod146 = require("zod");
var AvailableComparison = import_zod146.z.object({
  comparison: import_zod146.z.enum(["excludes", "includes", "is", "isGreaterThan", "isGreaterThanOrEqual", "isLessThan", "isLessThanOrEqual", "isNot"]).nullish(),
  text: import_zod146.z.string().nullish()
});

// src/generated-definitions/AvailablePredicate.ts
var AvailablePredicate = import_zod147.z.object({
  availableComparisons: import_zod147.z.array(AvailableComparison).nullish(),
  predicateType: import_zod147.z.enum(["EntitlementPredicate", "SeasonPassPredicate", "SeasonTierPredicate", "StatisticCodePredicate"]).nullish(),
  showAnyOf: import_zod147.z.boolean().nullish(),
  valueType: import_zod147.z.enum(["List", "Number", "String"]).nullish()
});

// src/generated-definitions/AvailablePredicateArray.ts
var AvailablePredicateArray = import_zod148.z.array(AvailablePredicate);

// src/generated-definitions/BasicItemArray.ts
var import_zod150 = require("zod");

// src/generated-definitions/BasicItem.ts
var import_zod149 = require("zod");
var BasicItem = import_zod149.z.object({
  appId: import_zod149.z.string().nullish(),
  appType: import_zod149.z.enum(["DEMO", "DLC", "GAME", "SOFTWARE"]).nullish(),
  baseAppId: import_zod149.z.string().nullish(),
  createdAt: import_zod149.z.string(),
  entitlementType: import_zod149.z.enum(["CONSUMABLE", "DURABLE"]),
  features: import_zod149.z.array(import_zod149.z.string()).nullish(),
  itemId: import_zod149.z.string(),
  itemType: import_zod149.z.enum([
    "APP",
    "BUNDLE",
    "CODE",
    "COINS",
    "EXTENSION",
    "INGAMEITEM",
    "LOOTBOX",
    "MEDIA",
    "OPTIONBOX",
    "SEASON",
    "SUBSCRIPTION"
  ]),
  name: import_zod149.z.string(),
  namespace: import_zod149.z.string(),
  seasonType: import_zod149.z.enum(["PASS", "TIER"]).nullish(),
  sku: import_zod149.z.string().nullish(),
  status: import_zod149.z.enum(["ACTIVE", "INACTIVE"]),
  tags: import_zod149.z.array(import_zod149.z.string()).nullish(),
  updatedAt: import_zod149.z.string(),
  useCount: import_zod149.z.number().int().nullish()
});

// src/generated-definitions/BasicItemArray.ts
var BasicItemArray = import_zod150.z.array(BasicItem);

// src/generated-definitions/EstimatedPriceInfo.ts
var import_zod153 = require("zod");

// src/generated-definitions/AvailablePrice.ts
var import_zod152 = require("zod");

// src/generated-definitions/SubItemAvailablePrice.ts
var import_zod151 = require("zod");
var SubItemAvailablePrice = import_zod151.z.object({
  discountedPrice: import_zod151.z.number().int(),
  itemId: import_zod151.z.string(),
  itemName: import_zod151.z.string(),
  itemSku: import_zod151.z.string(),
  owned: import_zod151.z.boolean().nullish(),
  price: import_zod151.z.number().int(),
  quantity: import_zod151.z.number().int().nullish()
});

// src/generated-definitions/AvailablePrice.ts
var AvailablePrice = import_zod152.z.object({
  currencyCode: import_zod152.z.string(),
  currencyNamespace: import_zod152.z.string(),
  discountExpireAt: import_zod152.z.string().nullish(),
  discountPurchaseAt: import_zod152.z.string().nullish(),
  discountedPrice: import_zod152.z.number().int(),
  expireAt: import_zod152.z.string().nullish(),
  price: import_zod152.z.number().int(),
  priceDetails: import_zod152.z.array(SubItemAvailablePrice).nullish(),
  purchaseAt: import_zod152.z.string().nullish()
});

// src/generated-definitions/EstimatedPriceInfo.ts
var EstimatedPriceInfo = import_zod153.z.object({
  estimatedPrices: import_zod153.z.array(AvailablePrice).nullish(),
  itemId: import_zod153.z.string(),
  region: import_zod153.z.string().nullish()
});

// src/generated-definitions/FullAppInfo.ts
var import_zod157 = require("zod");

// src/generated-definitions/AppLocalization.ts
var import_zod154 = require("zod");
var AppLocalization = import_zod154.z.object({ announcement: import_zod154.z.string().nullish(), slogan: import_zod154.z.string().nullish() });

// src/generated-definitions/Requirement.ts
var import_zod155 = require("zod");
var Requirement = import_zod155.z.object({
  additionals: import_zod155.z.string().nullish(),
  directXVersion: import_zod155.z.string().nullish(),
  diskSpace: import_zod155.z.string().nullish(),
  graphics: import_zod155.z.string().nullish(),
  label: import_zod155.z.string(),
  osVersion: import_zod155.z.string().nullish(),
  processor: import_zod155.z.string().nullish(),
  ram: import_zod155.z.string().nullish(),
  soundCard: import_zod155.z.string().nullish()
});

// src/generated-definitions/Slide.ts
var import_zod156 = require("zod");
var Slide = import_zod156.z.object({
  alt: import_zod156.z.string().nullish(),
  previewUrl: import_zod156.z.string().nullish(),
  thumbnailUrl: import_zod156.z.string().nullish(),
  type: import_zod156.z.enum(["image", "video"]).nullish(),
  url: import_zod156.z.string().nullish(),
  videoSource: import_zod156.z.enum(["generic", "vimeo", "youtube"]).nullish()
});

// src/generated-definitions/FullAppInfo.ts
var FullAppInfo = import_zod157.z.object({
  carousel: import_zod157.z.array(Slide).nullish(),
  developer: import_zod157.z.string().nullish(),
  forumUrl: import_zod157.z.string().nullish(),
  genres: import_zod157.z.array(
    import_zod157.z.enum([
      "Action",
      "Adventure",
      "Casual",
      "FreeToPlay",
      "Indie",
      "MassivelyMultiplayer",
      "RPG",
      "Racing",
      "Simulation",
      "Sports",
      "Strategy"
    ])
  ).nullish(),
  itemId: import_zod157.z.string(),
  localizations: import_zod157.z.record(AppLocalization).nullish(),
  namespace: import_zod157.z.string(),
  platformRequirements: import_zod157.z.record(import_zod157.z.array(Requirement)).nullish(),
  platforms: import_zod157.z.array(import_zod157.z.enum(["Android", "IOS", "Linux", "MacOS", "Windows"])).nullish(),
  players: import_zod157.z.array(import_zod157.z.enum(["Coop", "CrossPlatformMulti", "LocalCoop", "MMO", "Multi", "Single"])).nullish(),
  primaryGenre: import_zod157.z.enum([
    "Action",
    "Adventure",
    "Casual",
    "FreeToPlay",
    "Indie",
    "MassivelyMultiplayer",
    "RPG",
    "Racing",
    "Simulation",
    "Sports",
    "Strategy"
  ]).nullish(),
  publisher: import_zod157.z.string().nullish(),
  releaseDate: import_zod157.z.string().nullish(),
  websiteUrl: import_zod157.z.string().nullish()
});

// src/generated-definitions/FullItemInfo.ts
var import_zod163 = require("zod");

// src/generated-definitions/Image.ts
var import_zod158 = require("zod");
var Image = import_zod158.z.object({
  as: import_zod158.z.string().nullish(),
  caption: import_zod158.z.string().nullish(),
  height: import_zod158.z.number().int(),
  imageUrl: import_zod158.z.string(),
  smallImageUrl: import_zod158.z.string(),
  width: import_zod158.z.number().int()
});

// src/generated-definitions/Localization.ts
var import_zod159 = require("zod");
var Localization = import_zod159.z.object({
  description: import_zod159.z.string().nullish(),
  localExt: import_zod159.z.record(import_zod159.z.any()).nullish(),
  longDescription: import_zod159.z.string().nullish(),
  title: import_zod159.z.string()
});

// src/generated-definitions/PurchaseCondition.ts
var import_zod162 = require("zod");

// src/generated-definitions/ConditionGroup.ts
var import_zod161 = require("zod");

// src/generated-definitions/Predicate.ts
var import_zod160 = require("zod");
var Predicate = import_zod160.z.object({
  anyOf: import_zod160.z.number().int().nullish(),
  code: import_zod160.z.string().nullish(),
  comparison: import_zod160.z.enum(["excludes", "includes", "is", "isGreaterThan", "isGreaterThanOrEqual", "isLessThan", "isLessThanOrEqual", "isNot"]).nullish(),
  name: import_zod160.z.string().nullish(),
  predicateType: import_zod160.z.enum(["EntitlementPredicate", "SeasonPassPredicate", "SeasonTierPredicate", "StatisticCodePredicate"]).nullish(),
  value: import_zod160.z.string().nullish(),
  values: import_zod160.z.array(import_zod160.z.string()).nullish()
});

// src/generated-definitions/ConditionGroup.ts
var ConditionGroup = import_zod161.z.object({ operator: import_zod161.z.enum(["and", "or"]).nullish(), predicates: import_zod161.z.array(Predicate).nullish() });

// src/generated-definitions/PurchaseCondition.ts
var PurchaseCondition = import_zod162.z.object({ conditionGroups: import_zod162.z.array(ConditionGroup).nullish() });

// src/generated-definitions/FullItemInfo.ts
var FullItemInfo = import_zod163.z.object({
  appId: import_zod163.z.string().nullish(),
  appType: import_zod163.z.enum(["DEMO", "DLC", "GAME", "SOFTWARE"]).nullish(),
  baseAppId: import_zod163.z.string().nullish(),
  boothName: import_zod163.z.string().nullish(),
  boundItemIds: import_zod163.z.array(import_zod163.z.string()).nullish(),
  categoryPath: import_zod163.z.string().nullish(),
  clazz: import_zod163.z.string().nullish(),
  createdAt: import_zod163.z.string(),
  displayOrder: import_zod163.z.number().int().nullish(),
  entitlementType: import_zod163.z.enum(["CONSUMABLE", "DURABLE"]),
  ext: import_zod163.z.record(import_zod163.z.any()).nullish(),
  features: import_zod163.z.array(import_zod163.z.string()).nullish(),
  flexible: import_zod163.z.boolean().nullish(),
  images: import_zod163.z.array(Image).nullish(),
  inventoryConfig: InventoryConfig.nullish(),
  itemId: import_zod163.z.string(),
  itemIds: import_zod163.z.array(import_zod163.z.string()).nullish(),
  itemQty: import_zod163.z.record(import_zod163.z.number().int()).nullish(),
  itemType: import_zod163.z.enum([
    "APP",
    "BUNDLE",
    "CODE",
    "COINS",
    "EXTENSION",
    "INGAMEITEM",
    "LOOTBOX",
    "MEDIA",
    "OPTIONBOX",
    "SEASON",
    "SUBSCRIPTION"
  ]),
  listable: import_zod163.z.boolean().nullish(),
  localizations: import_zod163.z.record(Localization),
  lootBoxConfig: LootBoxConfig.nullish(),
  maxCount: import_zod163.z.number().int().nullish(),
  maxCountPerUser: import_zod163.z.number().int().nullish(),
  name: import_zod163.z.string(),
  namespace: import_zod163.z.string(),
  optionBoxConfig: OptionBoxConfig.nullish(),
  purchasable: import_zod163.z.boolean().nullish(),
  purchaseCondition: PurchaseCondition.nullish(),
  recurring: Recurring.nullish(),
  regionData: import_zod163.z.record(import_zod163.z.array(RegionDataItem)),
  saleConfig: SaleConfig.nullish(),
  seasonType: import_zod163.z.enum(["PASS", "TIER"]).nullish(),
  sectionExclusive: import_zod163.z.boolean().nullish(),
  sellable: import_zod163.z.boolean().nullish(),
  sku: import_zod163.z.string().nullish(),
  stackable: import_zod163.z.boolean().nullish(),
  status: import_zod163.z.enum(["ACTIVE", "INACTIVE"]),
  tags: import_zod163.z.array(import_zod163.z.string()).nullish(),
  targetCurrencyCode: import_zod163.z.string().nullish(),
  targetItemId: import_zod163.z.string().nullish(),
  targetNamespace: import_zod163.z.string().nullish(),
  thumbnailUrl: import_zod163.z.string().nullish(),
  updatedAt: import_zod163.z.string(),
  useCount: import_zod163.z.number().int().nullish()
});

// src/generated-definitions/FullItemInfoArray.ts
var import_zod164 = require("zod");
var FullItemInfoArray = import_zod164.z.array(FullItemInfo);

// src/generated-definitions/FullItemPagingResult.ts
var import_zod165 = require("zod");
var FullItemPagingResult = import_zod165.z.object({ data: import_zod165.z.array(FullItemInfo), paging: Paging.nullish(), total: import_zod165.z.number().int().nullish() });

// src/generated-definitions/FullItemPagingSlicedResult.ts
var import_zod166 = require("zod");
var FullItemPagingSlicedResult = import_zod166.z.object({ data: import_zod166.z.array(FullItemInfo), paging: Paging.nullish() });

// src/generated-definitions/ItemAcquireResult.ts
var import_zod167 = require("zod");
var ItemAcquireResult = import_zod167.z.object({ maxCount: import_zod167.z.number().int(), success: import_zod167.z.boolean() });

// src/generated-definitions/ItemDynamicDataInfo.ts
var import_zod168 = require("zod");
var ItemDynamicDataInfo = import_zod168.z.object({
  availableCount: import_zod168.z.number().int(),
  itemId: import_zod168.z.string(),
  namespace: import_zod168.z.string(),
  userAvailableCount: import_zod168.z.number().int(),
  userPurchaseLimit: import_zod168.z.number().int()
});

// src/generated-definitions/ItemId.ts
var import_zod169 = require("zod");
var ItemId = import_zod169.z.object({ itemId: import_zod169.z.string(), sku: import_zod169.z.string().nullish(), status: import_zod169.z.enum(["ACTIVE", "INACTIVE"]).nullish() });

// src/generated-definitions/ItemIdArray.ts
var import_zod170 = require("zod");
var ItemIdArray = import_zod170.z.array(ItemId);

// src/generated-definitions/ItemInfoArray.ts
var import_zod172 = require("zod");

// src/generated-definitions/ItemInfo.ts
var import_zod171 = require("zod");
var ItemInfo = import_zod171.z.object({
  appId: import_zod171.z.string().nullish(),
  appType: import_zod171.z.enum(["DEMO", "DLC", "GAME", "SOFTWARE"]).nullish(),
  baseAppId: import_zod171.z.string().nullish(),
  boothName: import_zod171.z.string().nullish(),
  boundItemIds: import_zod171.z.array(import_zod171.z.string()).nullish(),
  categoryPath: import_zod171.z.string(),
  clazz: import_zod171.z.string().nullish(),
  createdAt: import_zod171.z.string(),
  description: import_zod171.z.string().nullish(),
  displayOrder: import_zod171.z.number().int().nullish(),
  entitlementType: import_zod171.z.enum(["CONSUMABLE", "DURABLE"]),
  ext: import_zod171.z.record(import_zod171.z.any()).nullish(),
  features: import_zod171.z.array(import_zod171.z.string()).nullish(),
  flexible: import_zod171.z.boolean().nullish(),
  fresh: import_zod171.z.boolean().nullish(),
  images: import_zod171.z.array(Image).nullish(),
  inventoryConfig: InventoryConfig.nullish(),
  itemId: import_zod171.z.string(),
  itemIds: import_zod171.z.array(import_zod171.z.string()).nullish(),
  itemQty: import_zod171.z.record(import_zod171.z.number().int()).nullish(),
  itemType: import_zod171.z.enum([
    "APP",
    "BUNDLE",
    "CODE",
    "COINS",
    "EXTENSION",
    "INGAMEITEM",
    "LOOTBOX",
    "MEDIA",
    "OPTIONBOX",
    "SEASON",
    "SUBSCRIPTION"
  ]),
  language: import_zod171.z.string(),
  listable: import_zod171.z.boolean().nullish(),
  localExt: import_zod171.z.record(import_zod171.z.any()).nullish(),
  longDescription: import_zod171.z.string().nullish(),
  lootBoxConfig: LootBoxConfig.nullish(),
  maxCount: import_zod171.z.number().int().nullish(),
  maxCountPerUser: import_zod171.z.number().int().nullish(),
  name: import_zod171.z.string(),
  namespace: import_zod171.z.string(),
  optionBoxConfig: OptionBoxConfig.nullish(),
  purchasable: import_zod171.z.boolean().nullish(),
  purchaseCondition: PurchaseCondition.nullish(),
  recurring: Recurring.nullish(),
  region: import_zod171.z.string(),
  regionData: import_zod171.z.array(RegionDataItem).nullish(),
  saleConfig: SaleConfig.nullish(),
  seasonType: import_zod171.z.enum(["PASS", "TIER"]).nullish(),
  sectionExclusive: import_zod171.z.boolean().nullish(),
  sellable: import_zod171.z.boolean().nullish(),
  sku: import_zod171.z.string().nullish(),
  stackable: import_zod171.z.boolean().nullish(),
  status: import_zod171.z.enum(["ACTIVE", "INACTIVE"]),
  tags: import_zod171.z.array(import_zod171.z.string()).nullish(),
  targetCurrencyCode: import_zod171.z.string().nullish(),
  targetItemId: import_zod171.z.string().nullish(),
  targetNamespace: import_zod171.z.string().nullish(),
  thumbnailUrl: import_zod171.z.string().nullish(),
  title: import_zod171.z.string(),
  updatedAt: import_zod171.z.string(),
  useCount: import_zod171.z.number().int().nullish()
});

// src/generated-definitions/ItemInfoArray.ts
var ItemInfoArray = import_zod172.z.array(ItemInfo);

// src/generated-definitions/ItemPurchaseConditionValidateResultArray.ts
var import_zod176 = require("zod");

// src/generated-definitions/ItemPurchaseConditionValidateResult.ts
var import_zod175 = require("zod");

// src/generated-definitions/ConditionGroupValidateResult.ts
var import_zod174 = require("zod");

// src/generated-definitions/PredicateValidateResult.ts
var import_zod173 = require("zod");
var PredicateValidateResult = import_zod173.z.object({
  matched: import_zod173.z.array(import_zod173.z.string()).nullish(),
  predicateName: import_zod173.z.string().nullish(),
  unmatched: import_zod173.z.array(import_zod173.z.string()).nullish(),
  validated: import_zod173.z.boolean().nullish()
});

// src/generated-definitions/ConditionGroupValidateResult.ts
var ConditionGroupValidateResult = import_zod174.z.object({ predicateValidateResults: import_zod174.z.array(PredicateValidateResult).nullish() });

// src/generated-definitions/ItemPurchaseConditionValidateResult.ts
var ItemPurchaseConditionValidateResult = import_zod175.z.object({
  itemId: import_zod175.z.string().nullish(),
  purchasable: import_zod175.z.boolean().nullish(),
  sku: import_zod175.z.string().nullish(),
  validateDetails: import_zod175.z.array(ConditionGroupValidateResult).nullish()
});

// src/generated-definitions/ItemPurchaseConditionValidateResultArray.ts
var ItemPurchaseConditionValidateResultArray = import_zod176.z.array(ItemPurchaseConditionValidateResult);

// src/generated-definitions/ItemTypeConfigInfo.ts
var import_zod177 = require("zod");
var ItemTypeConfigInfo = import_zod177.z.object({
  clazz: import_zod177.z.string().nullish(),
  createdAt: import_zod177.z.string(),
  dryRun: import_zod177.z.boolean().nullish(),
  fulfillmentUrl: import_zod177.z.string(),
  id: import_zod177.z.string(),
  itemType: import_zod177.z.enum([
    "APP",
    "BUNDLE",
    "CODE",
    "COINS",
    "EXTENSION",
    "INGAMEITEM",
    "LOOTBOX",
    "MEDIA",
    "OPTIONBOX",
    "SEASON",
    "SUBSCRIPTION"
  ]),
  purchaseConditionUrl: import_zod177.z.string().nullish(),
  updatedAt: import_zod177.z.string()
});

// src/generated-definitions/ItemTypeConfigInfoArray.ts
var import_zod178 = require("zod");
var ItemTypeConfigInfoArray = import_zod178.z.array(ItemTypeConfigInfo);

// src/generated-definitions/PopulatedItemInfo.ts
var import_zod180 = require("zod");

// src/generated-definitions/BundledItemInfo.ts
var import_zod179 = require("zod");
var BundledItemInfo = import_zod179.z.object({
  appId: import_zod179.z.string().nullish(),
  appType: import_zod179.z.enum(["DEMO", "DLC", "GAME", "SOFTWARE"]).nullish(),
  baseAppId: import_zod179.z.string().nullish(),
  boothName: import_zod179.z.string().nullish(),
  boundItemIds: import_zod179.z.array(import_zod179.z.string()).nullish(),
  bundledQty: import_zod179.z.number().int().nullish(),
  categoryPath: import_zod179.z.string(),
  clazz: import_zod179.z.string().nullish(),
  createdAt: import_zod179.z.string(),
  description: import_zod179.z.string().nullish(),
  displayOrder: import_zod179.z.number().int().nullish(),
  entitlementType: import_zod179.z.enum(["CONSUMABLE", "DURABLE"]),
  ext: import_zod179.z.record(import_zod179.z.any()).nullish(),
  features: import_zod179.z.array(import_zod179.z.string()).nullish(),
  flexible: import_zod179.z.boolean().nullish(),
  fresh: import_zod179.z.boolean().nullish(),
  images: import_zod179.z.array(Image).nullish(),
  inventoryConfig: InventoryConfig.nullish(),
  itemId: import_zod179.z.string(),
  itemIds: import_zod179.z.array(import_zod179.z.string()).nullish(),
  itemQty: import_zod179.z.record(import_zod179.z.number().int()).nullish(),
  itemType: import_zod179.z.enum([
    "APP",
    "BUNDLE",
    "CODE",
    "COINS",
    "EXTENSION",
    "INGAMEITEM",
    "LOOTBOX",
    "MEDIA",
    "OPTIONBOX",
    "SEASON",
    "SUBSCRIPTION"
  ]),
  language: import_zod179.z.string(),
  listable: import_zod179.z.boolean().nullish(),
  localExt: import_zod179.z.record(import_zod179.z.any()).nullish(),
  longDescription: import_zod179.z.string().nullish(),
  lootBoxConfig: LootBoxConfig.nullish(),
  maxCount: import_zod179.z.number().int().nullish(),
  maxCountPerUser: import_zod179.z.number().int().nullish(),
  name: import_zod179.z.string(),
  namespace: import_zod179.z.string(),
  optionBoxConfig: OptionBoxConfig.nullish(),
  purchasable: import_zod179.z.boolean().nullish(),
  purchaseCondition: PurchaseCondition.nullish(),
  recurring: Recurring.nullish(),
  region: import_zod179.z.string(),
  regionData: import_zod179.z.array(RegionDataItem).nullish(),
  saleConfig: SaleConfig.nullish(),
  seasonType: import_zod179.z.enum(["PASS", "TIER"]).nullish(),
  sectionExclusive: import_zod179.z.boolean().nullish(),
  sellable: import_zod179.z.boolean().nullish(),
  sku: import_zod179.z.string().nullish(),
  stackable: import_zod179.z.boolean().nullish(),
  status: import_zod179.z.enum(["ACTIVE", "INACTIVE"]),
  tags: import_zod179.z.array(import_zod179.z.string()).nullish(),
  targetCurrencyCode: import_zod179.z.string().nullish(),
  targetItemId: import_zod179.z.string().nullish(),
  targetNamespace: import_zod179.z.string().nullish(),
  thumbnailUrl: import_zod179.z.string().nullish(),
  title: import_zod179.z.string(),
  updatedAt: import_zod179.z.string(),
  useCount: import_zod179.z.number().int().nullish()
});

// src/generated-definitions/PopulatedItemInfo.ts
var PopulatedItemInfo = import_zod180.z.object({
  appId: import_zod180.z.string().nullish(),
  appType: import_zod180.z.enum(["DEMO", "DLC", "GAME", "SOFTWARE"]).nullish(),
  baseAppId: import_zod180.z.string().nullish(),
  boothName: import_zod180.z.string().nullish(),
  boundItemIds: import_zod180.z.array(import_zod180.z.string()).nullish(),
  categoryPath: import_zod180.z.string(),
  clazz: import_zod180.z.string().nullish(),
  createdAt: import_zod180.z.string(),
  description: import_zod180.z.string().nullish(),
  displayOrder: import_zod180.z.number().int().nullish(),
  entitlementType: import_zod180.z.enum(["CONSUMABLE", "DURABLE"]),
  ext: import_zod180.z.record(import_zod180.z.any()).nullish(),
  features: import_zod180.z.array(import_zod180.z.string()).nullish(),
  flexible: import_zod180.z.boolean().nullish(),
  fresh: import_zod180.z.boolean().nullish(),
  images: import_zod180.z.array(Image).nullish(),
  inventoryConfig: InventoryConfig.nullish(),
  itemId: import_zod180.z.string(),
  itemIds: import_zod180.z.array(import_zod180.z.string()).nullish(),
  itemQty: import_zod180.z.record(import_zod180.z.number().int()).nullish(),
  itemType: import_zod180.z.enum([
    "APP",
    "BUNDLE",
    "CODE",
    "COINS",
    "EXTENSION",
    "INGAMEITEM",
    "LOOTBOX",
    "MEDIA",
    "OPTIONBOX",
    "SEASON",
    "SUBSCRIPTION"
  ]),
  items: import_zod180.z.array(BundledItemInfo).nullish(),
  language: import_zod180.z.string(),
  listable: import_zod180.z.boolean().nullish(),
  localExt: import_zod180.z.record(import_zod180.z.any()).nullish(),
  longDescription: import_zod180.z.string().nullish(),
  lootBoxConfig: LootBoxConfig.nullish(),
  maxCount: import_zod180.z.number().int().nullish(),
  maxCountPerUser: import_zod180.z.number().int().nullish(),
  name: import_zod180.z.string(),
  namespace: import_zod180.z.string(),
  optionBoxConfig: OptionBoxConfig.nullish(),
  purchasable: import_zod180.z.boolean().nullish(),
  purchaseCondition: PurchaseCondition.nullish(),
  recurring: Recurring.nullish(),
  region: import_zod180.z.string(),
  regionData: import_zod180.z.array(RegionDataItem).nullish(),
  saleConfig: SaleConfig.nullish(),
  seasonType: import_zod180.z.enum(["PASS", "TIER"]).nullish(),
  sectionExclusive: import_zod180.z.boolean().nullish(),
  sellable: import_zod180.z.boolean().nullish(),
  sku: import_zod180.z.string().nullish(),
  stackable: import_zod180.z.boolean().nullish(),
  status: import_zod180.z.enum(["ACTIVE", "INACTIVE"]),
  tags: import_zod180.z.array(import_zod180.z.string()).nullish(),
  targetCurrencyCode: import_zod180.z.string().nullish(),
  targetItemId: import_zod180.z.string().nullish(),
  targetNamespace: import_zod180.z.string().nullish(),
  thumbnailUrl: import_zod180.z.string().nullish(),
  title: import_zod180.z.string(),
  updatedAt: import_zod180.z.string(),
  useCount: import_zod180.z.number().int().nullish()
});

// src/generated-admin/endpoints/ItemAdmin$.ts
var ItemAdmin$ = class {
  // @ts-ignore
  // prettier-ignore
  constructor(axiosInstance, namespace, useSchemaValidation = true) {
    this.axiosInstance = axiosInstance;
    this.namespace = namespace;
    this.useSchemaValidation = useSchemaValidation;
  }
  /**
   * &lt;b&gt;[Not supported yet in AGS Shared Cloud]&lt;/b&gt;This API is used to get all item type configs.&lt;p&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: the list of items&lt;/li&gt;&lt;/ul&gt;
   */
  getItemsConfigs() {
    const params = {};
    const url = "/platform/admin/items/configs";
    const resultPromise = this.axiosInstance.get(url, { params });
    return import_sdk24.Validate.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      ItemTypeConfigInfoArray,
      "ItemTypeConfigInfoArray"
    );
  }
  /**
   * &lt;b&gt;[Not supported yet in AGS Shared Cloud]&lt;/b&gt;This API is used to create an item type config.&lt;p&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: item type config data&lt;/li&gt;&lt;/ul&gt;
   */
  createItemConfig(data) {
    const params = {};
    const url = "/platform/admin/items/configs";
    const resultPromise = this.axiosInstance.post(url, data, { params });
    return import_sdk24.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, import_zod181.z.unknown(), "z.unknown()");
  }
  /**
   * &lt;b&gt;[Not supported yet in AGS Shared Cloud]&lt;/b&gt;This API is used to delete an item type config permanently.
   */
  deleteItemConfig_ById(id) {
    const params = {};
    const url = "/platform/admin/items/configs/{id}".replace("{id}", id);
    const resultPromise = this.axiosInstance.delete(url, { params });
    return import_sdk24.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, import_zod181.z.unknown(), "z.unknown()");
  }
  /**
   * &lt;b&gt;[Not supported yet in AGS Shared Cloud]&lt;/b&gt;This API is used to get an item type config.&lt;p&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: item type config data&lt;/li&gt;&lt;/ul&gt;
   */
  getItemConfig_ById(id) {
    const params = {};
    const url = "/platform/admin/items/configs/{id}".replace("{id}", id);
    const resultPromise = this.axiosInstance.get(url, { params });
    return import_sdk24.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, ItemTypeConfigInfo, "ItemTypeConfigInfo");
  }
  /**
   * &lt;b&gt;[Not supported yet in AGS Shared Cloud]&lt;/b&gt;This API is used to update an item type config.&lt;p&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: item type config data&lt;/li&gt;&lt;/ul&gt;
   */
  updateItemConfig_ById(id, data) {
    const params = {};
    const url = "/platform/admin/items/configs/{id}".replace("{id}", id);
    const resultPromise = this.axiosInstance.put(url, data, { params });
    return import_sdk24.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, ItemTypeConfigInfo, "ItemTypeConfigInfo");
  }
  /**
   * &lt;b&gt;[Not supported yet in AGS Shared Cloud]&lt;/b&gt;This API is used to get an item type config.&lt;p&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: item type config data&lt;/li&gt;&lt;/ul&gt;
   */
  getItemsConfigsSearch(queryParams) {
    const params = { ...queryParams };
    const url = "/platform/admin/items/configs/search";
    const resultPromise = this.axiosInstance.get(url, { params });
    return import_sdk24.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, ItemTypeConfigInfo, "ItemTypeConfigInfo");
  }
  /**
   * This API is used to create an item. APP item only can created in publisher namespace.&lt;p&gt;An item create example:&lt;p&gt;&lt;pre&gt;&lt;code&gt;{ &#34;categoryPath&#34;: &#34;/games&#34;, &#34;localizations&#34;: \{ &#34;en&#34;: \{ &#34;title&#34;:&#34;required&#34;, &#34;description&#34;:&#34;optional&#34;, &#34;longDescription&#34;:&#34;optional&#34;, &#34;localExt&#34;: \{ &#34;properties&#34;:\[ \{ &#34;key1&#34;:&#34;value1&#34;, &#34;key2&#34;:&#34;value2&#34; \} \], &#34;functions&#34;:\[ \{ &#34;key1&#34;:&#34;value1&#34;, &#34;key2&#34;:&#34;value2&#34; \} \] \} \} \}, &#34;images&#34;: \[ \{ &#34;as&#34;:&#34;optional, image for&#34;, &#34;caption&#34;:&#34;optional&#34;, &#34;height&#34;:10, &#34;width&#34;:10, &#34;imageUrl&#34;:&#34;http://img-url-required&#34;, &#34;smallImageUrl&#34;:&#34;http://small-img-url-required&#34; \} \], &#34;thumbnailUrl&#34;: &#34;optional, thumbnail url&#34;, &#34;status&#34;: &#34;ACTIVE&#34;, &#34;listable&#34;: true, &#34;purchasable&#34;: true, &#34;itemType&#34;: &#34;APP(allowed: [APP,COINS,INGAMEITEM,CODE,BUNDLE])&#34;, &#34;name&#34;: &#34;required, also will be used as entitlement name&#34;, &#34;entitlementType&#34;: &#34;DURABLE(allowed:[DURABLE,CONSUMABLE], should be CONSUMABLE when item type is COINS)&#34;, &#34;useCount&#34;: 1(optional, required if the entitlement type is consumable), &#34;stackable&#34;: false, &#34;appId&#34;: &#34;optional, required if itemType is APP&#34;, &#34;appType&#34;: &#34;GAME(optional, required if itemType is APP)&#34;, &#34;seasonType&#34;: &#34;PASS(optional, required if itemType is SEASON)&#34;, &#34;baseAppId&#34;: &#34;optional, set value of game app id if you want to link to a game&#34;, &#34;targetCurrencyCode&#34;: &#34;optional, required if itemType is COINS&#34;, &#34;targetNamespace&#34;: &#34;optional, required when itemType is INGAMEITEM, the targetNamespace will only take effect when the item created belongs to the publisher namespace&#34;, &#34;sku&#34;: &#34;optional, commonly unique item code&#34;, &#34;regionData&#34;: \{ &#34;US(store&#39;s default region is required)&#34;: \[ \{ &#34;price&#34;:10, &#34;discountPercentage&#34;: 0(integer, optional, range[0,100], discountedPrice = price \* ((100 - discountPercentage) \* 0.01), will use it to calculate discounted price if it is not 0), &#34;discountAmount&#34;:0(integer, optional, range[0,itemPrice], will use it to calculate discounted price if discountPercentage is 0), &#34;currencyCode&#34;:&#34;code(required, example: USD)&#34;, &#34;currencyNamespace&#34;:&#34;test-ns-required(allow publisher namespace if namespace is publisher namespace, allow publisher and game namespace if namespace is not publisher namespace)&#34;, &#34;trialPrice&#34;:5(required while fixedTrialCycles set, should &gt;=0 and &lt;= price, will same as price if not present), &#34;purchaseAt&#34;:&#34;optional yyyy-MM-dd&#39;T&#39;HH:mm:ss.SSS&#39;Z&#39;&#34;, &#34;expireAt&#34;:&#34;optional yyyy-MM-dd&#39;T&#39;HH:mm:ss.SSS&#39;Z&#39;&#34;, &#34;discountPurchaseAt&#34;:&#34;optional yyyy-MM-dd&#39;T&#39;HH:mm:ss.SSS&#39;Z&#39;&#34;, &#34;discountExpireAt&#34;:&#34;optional yyyy-MM-dd&#39;T&#39;HH:mm:ss.SSS&#39;Z&#39;&#34; \} \] \}, &#34;itemIds&#34;: \[ &#34;itemId&#34; \], &#34;itemQty&#34;: \{ &#34;itemId&#34;:1 \}, &#34;recurring&#34;: \{ &#34;cycle&#34;:&#34;MONTHLY(allowed: [WEEKLY,MONTHLY,QUARTERLY,YEARLY])&#34;, &#34;fixedFreeDays&#34;:0(integer, fixed free days, 0 means not set), &#34;fixedTrialCycles&#34;:0(integer, fixed trial cycles, 0 means not set, will not take effect if fixedFreeDays set), &#34;graceDays&#34;:7(integer, recurring grace days, retry recurring charge within configured days if charge fail, default 7) \}, &#34;tags&#34;: \[ &#34;exampleTag24&#34; \], &#34;features&#34;: \[ &#34;feature&#34; \], &#34;clazz&#34;: &#34;weapon&#34;, &#34;boothName&#34;: &#34;C_campaign1&#34;, &#34;displayOrder&#34;: 1000, &#34;ext&#34;: \{ &#34;properties&#34;:\[ \{ &#34;key1&#34;:&#34;value1&#34;, &#34;key2&#34;:&#34;value2&#34; \} \], &#34;functions&#34;:\[ \{ &#34;key1&#34;:&#34;value1&#34;, &#34;key2&#34;:&#34;value2&#34; \} \] \}, &#34;maxCountPerUser&#34;: 1(integer, optional, -1 means UNLIMITED), &#34;maxCount&#34;: 1(integer, optional, -1 means UNLIMITED, unset when itemType is CODE) }&lt;/code&gt;&lt;/pre&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: created item data&lt;/li&gt;&lt;/ul&gt;&lt;h2&gt;Restrictions for item extension and localization extension and inventory config custom attributes&lt;/h2&gt; 1. Cannot use &lt;b&gt;&#34;.&#34;&lt;/b&gt; as the key name - &lt;pre&gt;{ &#34;data.2&#34;: &#34;value&#34; }&lt;/pre&gt; 2. Cannot use &lt;b&gt;&#34;$&#34;&lt;/b&gt; as the prefix in key names - &lt;pre&gt;{ &#34;$data&#34;: &#34;value&#34; }&lt;/pre&gt;
   */
  createItem(data, queryParams) {
    const params = { ...queryParams };
    const url = "/platform/admin/namespaces/{namespace}/items".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.post(url, data, { params });
    return import_sdk24.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, FullItemInfo, "FullItemInfo");
  }
  /**
   * &lt;b&gt;[Not supported yet in AGS Shared Cloud]&lt;/b&gt;This API is used to sync an in game item in game namespace to publisher namespace, only INGAMEITEM, CODE, COINS and SEASON are supported&lt;p&gt;The synced item has an additional field targetItemId besides targetNamespace, mostly this item should not modified manually again. &lt;p&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: item data&lt;/li&gt;&lt;/ul&gt;
   */
  updateItem(data, queryParams) {
    const params = { ...queryParams };
    const url = "/platform/admin/namespaces/{namespace}/items".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.put(url, data, { params });
    return import_sdk24.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, FullItemInfo, "FullItemInfo");
  }
  /**
   * This API is used to get items.&lt;p&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: the list of items info&lt;/li&gt;&lt;/ul&gt;
   */
  getItemsByIds(queryParams) {
    const params = { activeOnly: true, ...queryParams };
    const url = "/platform/admin/namespaces/{namespace}/items/byIds".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.get(url, { params });
    return import_sdk24.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, FullItemInfoArray, "FullItemInfoArray");
  }
  /**
   * This API is used to get the item by sku.&lt;p&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: the item with sku&lt;/li&gt;&lt;/ul&gt;
   */
  getItemsBySku(queryParams) {
    const params = { activeOnly: true, ...queryParams };
    const url = "/platform/admin/namespaces/{namespace}/items/bySku".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.get(url, { params });
    return import_sdk24.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, FullItemInfo, "FullItemInfo");
  }
  /**
   * This API is used to search items by keyword in title, description and long description within a store.&lt;p&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: the list of items&lt;/li&gt;&lt;/ul&gt;
   */
  getItemsSearch(queryParams) {
    const params = { activeOnly: true, limit: 20, sortBy: "name:asc,createdAt:asc", ...queryParams };
    const url = "/platform/admin/namespaces/{namespace}/items/search".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.get(url, { params });
    return import_sdk24.Validate.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      FullItemPagingSlicedResult,
      "FullItemPagingSlicedResult"
    );
  }
  /**
   * This API is used to get the item by appId.&lt;p&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: the item with that appId&lt;/li&gt;&lt;/ul&gt;
   */
  getItemsByAppId(queryParams) {
    const params = { activeOnly: true, ...queryParams };
    const url = "/platform/admin/namespaces/{namespace}/items/byAppId".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.get(url, { params });
    return import_sdk24.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, FullItemInfo, "FullItemInfo");
  }
  /**
   * This API is used to delete an item permanently.&lt;p&gt;force: the default value should be: false. When the value is: &lt;li&gt;&lt;i&gt;false:&lt;i&gt;only the items in the draft store that have never been published yet can be removed.&lt;/li&gt;&lt;li&gt;&lt;i&gt;true:&lt;i&gt;the item in the draft store(even been published before) can be removed.&lt;/li&gt;
   */
  deleteItem_ByItemId(itemId, queryParams) {
    const params = { ...queryParams };
    const url = "/platform/admin/namespaces/{namespace}/items/{itemId}".replace("{namespace}", this.namespace).replace("{itemId}", itemId);
    const resultPromise = this.axiosInstance.delete(url, { params });
    return import_sdk24.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, import_zod181.z.unknown(), "z.unknown()");
  }
  /**
   * This API is used to get an item.&lt;p&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: item data&lt;/li&gt;&lt;/ul&gt;
   */
  getItem_ByItemId(itemId, queryParams) {
    const params = { activeOnly: true, ...queryParams };
    const url = "/platform/admin/namespaces/{namespace}/items/{itemId}".replace("{namespace}", this.namespace).replace("{itemId}", itemId);
    const resultPromise = this.axiosInstance.get(url, { params });
    return import_sdk24.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, FullItemInfo, "FullItemInfo");
  }
  /**
   * This API is used to update an item.&lt;p&gt;An item update example:&lt;p&gt;&lt;pre&gt;&lt;code&gt;{ &#34;categoryPath&#34;: &#34;/games&#34;, &#34;localizations&#34;: \{ &#34;en&#34;: \{ &#34;title&#34;:&#34;required&#34;, &#34;description&#34;:&#34;optional&#34;, &#34;longDescription&#34;:&#34;optional&#34;, &#34;localExt&#34;: \{ &#34;properties&#34;:\[ \{ &#34;key1&#34;:&#34;value1&#34;, &#34;key2&#34;:&#34;value2&#34; \} \], &#34;functions&#34;:\[ \{ &#34;key1&#34;:&#34;value1&#34;, &#34;key2&#34;:&#34;value2&#34; \} \] \} \} \}, &#34;images&#34;: \[ \{ &#34;as&#34;:&#34;optional, image for&#34;, &#34;caption&#34;:&#34;optional&#34;, &#34;height&#34;:10, &#34;width&#34;:10, &#34;imageUrl&#34;:&#34;http://img-url-required&#34;, &#34;smallImageUrl&#34;:&#34;http://small-img-url-required&#34; \} \], &#34;thumbnailUrl&#34;: &#34;optional, thumbnail url&#34;, &#34;status&#34;: &#34;ACTIVE&#34;, &#34;listable&#34;: true, &#34;purchasable&#34;: true, &#34;itemType&#34;: &#34;APP(allowed: [APP,COINS,INGAMEITEM,CODE,BUNDLE])&#34;, &#34;name&#34;: &#34;optional&#34;, &#34;entitlementType&#34;: &#34;DURABLE(allowed:[DURABLE,CONSUMABLE], should be CONSUMABLE when item type is COINS)&#34;, &#34;useCount&#34;: 1(optional, required if the entitlement type is consumable), &#34;stackable&#34;: false, &#34;appId&#34;: &#34;optional, required if itemType is APP&#34;, &#34;baseAppId&#34;: &#34;optional, set value of game app id if you want to link to a game&#34;, &#34;appType&#34;: &#34;GAME(optional, required if itemType is APP)&#34;, &#34;seasonType&#34;: &#34;PASS(optional, required if itemType is SEASON)&#34;, &#34;sku&#34;: &#34;optional, commonly unique item code&#34;, &#34;targetCurrencyCode&#34;: &#34;optional, required if itemType is COINS&#34;, &#34;targetNamespace&#34;: &#34;optional, required when itemType is INGAMEITEM, the targetNamespace will only take effect when the item created belongs to the publisher namespace&#34;, &#34;regionData&#34;: \{ &#34;US(store&#39;s default region is required)&#34;: \[ \{ &#34;price&#34;:10, &#34;discountPercentage&#34;:0(integer, optional, range[0,100], discountedPrice = price\*((100 - discountPercentage) \* 0.01), if it is not 0, will use it to calculate discounted price), &#34;discountAmount&#34;:0(integer, optional, range[0,itemPrice], will use it to calculate discounted price if discountPercentage is 0), &#34;currencyCode&#34;:&#34;code(required, example: USD)&#34;, &#34;currencyNamespace&#34;:&#34;test-ns-required(allow publisher namespace if namespace is publisher namespace, allow publisher and game namespace if namespace is not publisher namespace)&#34;, &#34;trialPrice&#34;:5(required while fixedTrialCycles set, should &gt;=0 and &lt;= price, will same as price if not present), &#34;purchaseAt&#34;:&#34;optional yyyy-MM-dd&#39;T&#39;HH:mm:ss.SSS&#39;Z&#39;&#34;, &#34;expireAt&#34;:&#34;optional yyyy-MM-dd&#39;T&#39;HH:mm:ss.SSS&#39;Z&#39;&#34;, &#34;discountPurchaseAt&#34;:&#34;optional yyyy-MM-dd&#39;T&#39;HH:mm:ss.SSS&#39;Z&#39;&#34;, &#34;discountExpireAt&#34;:&#34;optional yyyy-MM-dd&#39;T&#39;HH:mm:ss.SSS&#39;Z&#39;&#34; \} \] \}, &#34;itemIds&#34;: \[ &#34;itemId&#34; \], &#34;itemQty&#34;: \{ &#34;itemId&#34;:1 \}, &#34;recurring&#34;: \{ &#34;cycle&#34;:&#34;MONTHLY(allowed: [WEEKLY,MONTHLY,QUARTERLY,YEARLY])&#34;, &#34;fixedFreeDays&#34;:0(integer, fixed free days, 0 means not set), &#34;fixedTrialCycles&#34;:0(integer, fixed trial cycles, 0 means not set, will not take effect if fixedFreeDays set), &#34;graceDays&#34;:7(integer, recurring grace days, retry recurring charge within configured days if charge fail, default 7) \}, &#34;tags&#34;: \[ &#34;exampleTag24&#34; \], &#34;features&#34;: \[ &#34;feature&#34; \], &#34;clazz&#34;: &#34;weapon&#34;, &#34;boothName&#34;: &#34;C_campaign1&#34;, &#34;displayOrder&#34;: 1000, &#34;ext&#34;: \{ &#34;properties&#34;:\[ \{ &#34;key1&#34;:&#34;value1&#34;, &#34;key2&#34;:&#34;value2&#34; \} \], &#34;functions&#34;:\[ \{ &#34;key1&#34;:&#34;value1&#34;, &#34;key2&#34;:&#34;value2&#34; \} \] \}, &#34;maxCountPerUser&#34;: 1(integer, optional, -1 means UNLIMITED), &#34;maxCount&#34;: 1(integer, optional, -1 means UNLIMITED, new value should &gt;= old value if both old value and new value is limited, unset when item type is CODE) }&lt;/code&gt;&lt;/pre&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: updated item data&lt;/li&gt;&lt;/ul&gt;&lt;h2&gt;Restrictions for item extension and localization extension&lt;/h2&gt; 1. Cannot use &lt;b&gt;&#34;.&#34;&lt;/b&gt; as the key name - &lt;pre&gt;{ &#34;data.2&#34;: &#34;value&#34; }&lt;/pre&gt; 2. Cannot use &lt;b&gt;&#34;$&#34;&lt;/b&gt; as the prefix in key names - &lt;pre&gt;{ &#34;$data&#34;: &#34;value&#34; }&lt;/pre&gt;
   */
  updateItem_ByItemId(itemId, data, queryParams) {
    const params = { ...queryParams };
    const url = "/platform/admin/namespaces/{namespace}/items/{itemId}".replace("{namespace}", this.namespace).replace("{itemId}", itemId);
    const resultPromise = this.axiosInstance.put(url, data, { params });
    return import_sdk24.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, FullItemInfo, "FullItemInfo");
  }
  /**
   * This API is used to query items by criteria within a store.&lt;p&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: the list of items&lt;/li&gt;&lt;/ul&gt;
   */
  getItemsByCriteria(queryParams) {
    const params = { activeOnly: true, limit: 20, sortBy: ["name:asc", "displayOrder:asc"], ...queryParams };
    const url = "/platform/admin/namespaces/{namespace}/items/byCriteria".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.get(url, { params });
    return import_sdk24.Validate.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      FullItemPagingSlicedResult,
      "FullItemPagingSlicedResult"
    );
  }
  /**
   * This API is used to update region data of items in bulk &lt;br /&gt;
   */
  updateItemRegiondata(data, queryParams) {
    const params = { ...queryParams };
    const url = "/platform/admin/namespaces/{namespace}/items/regiondata".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.put(url, data, { params });
    return import_sdk24.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, import_zod181.z.unknown(), "z.unknown()");
  }
  /**
   * This API is used to get an app info.&lt;p&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: app data&lt;/li&gt;&lt;/ul&gt;
   */
  getApp_ByItemId(itemId, queryParams) {
    const params = { activeOnly: true, ...queryParams };
    const url = "/platform/admin/namespaces/{namespace}/items/{itemId}/app".replace("{namespace}", this.namespace).replace("{itemId}", itemId);
    const resultPromise = this.axiosInstance.get(url, { params });
    return import_sdk24.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, FullAppInfo, "FullAppInfo");
  }
  /**
   * This API is used to update an app.&lt;p&gt;An app update example:&lt;p&gt;&lt;pre&gt;&lt;code&gt;{ &#34;developer&#34;: &#34;accelbyte&#34;, &#34;publisher&#34;: &#34;accelbyte&#34;, &#34;websiteUrl&#34;: &#34;http://accelbyte.io&#34;, &#34;forumUrl&#34;: &#34;http://accelbyte.io&#34;, &#34;platforms&#34;: \[&#34;Windows(allowed values: Windows, MacOS, Linux, IOS, Android)&#34;\], &#34;platformRequirements&#34;: \{ &#34;Windows&#34;: \[ \{ &#34;label&#34;:&#34;minimum(can be minimum or recommended)&#34;, &#34;osVersion&#34;:&#34;os version&#34;, &#34;processor&#34;:&#34;processor&#34;, &#34;ram&#34;:&#34;RAM&#34;, &#34;graphics&#34;:&#34;graphics&#34;, &#34;directXVersion&#34;:&#34;directXVersion&#34;, &#34;diskSpace&#34;:&#34;diskSpace&#34;, &#34;soundCard&#34;:&#34;soundCard&#34;, &#34;additionals&#34;:&#34;additionals&#34; \} \] \}, &#34;carousel&#34;: \[ \{ &#34;type&#34;:&#34;image(allowed values: image, video)&#34;, &#34;videoSource&#34;:&#34;generic(allowed values:generic, youtube, viemo)&#34;, &#34;url&#34;:&#34;url&#34;, &#34;alt&#34;:&#34;alternative url or text&#34;, &#34;thumbnailUrl&#34;:&#34;thumbnail url&#34;, &#34;previewUrl&#34;:&#34;preview url&#34;, \} \], &#34;localizations&#34;: \{ &#34;en&#34;: \{ &#34;slogan&#34;:&#34;slogan&#34;, &#34;announcement&#34;:&#34;announcement&#34;, \} \}, &#34;primaryGenre&#34;: &#34;Action&#34;, &#34;genres&#34;: \[&#34;Action&#34;, &#34;Adventure&#34;\], &#34;players&#34;: \[&#34;Single&#34;\], &#34;releaseDate&#34;: &#34;optional yyyy-MM-dd&#39;T&#39;HH:mm:ss.SSS&#39;Z&#39;&#34; }&lt;/code&gt;&lt;/pre&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: updated app data&lt;/li&gt;&lt;/ul&gt;
   */
  updateApp_ByItemId(itemId, data, queryParams) {
    const params = { ...queryParams };
    const url = "/platform/admin/namespaces/{namespace}/items/{itemId}/app".replace("{namespace}", this.namespace).replace("{itemId}", itemId);
    const resultPromise = this.axiosInstance.put(url, data, { params });
    return import_sdk24.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, FullAppInfo, "FullAppInfo");
  }
  /**
   * This API is used to get an item by sku in specific locale. If item not exist in specific region, default region item will return.&lt;p&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: item data&lt;/li&gt;&lt;/ul&gt;
   */
  getItemsBySkuLocale(queryParams) {
    const params = { activeOnly: true, ...queryParams };
    const url = "/platform/admin/namespaces/{namespace}/items/bySku/locale".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.get(url, { params });
    return import_sdk24.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, PopulatedItemInfo, "PopulatedItemInfo");
  }
  /**
   * &lt;b&gt;[SERVICE COMMUNICATION ONLY]&lt;/b&gt; This API is used to get the itemId by sku.&lt;p&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: the itemId with sku&lt;/li&gt;&lt;/ul&gt;
   */
  getItemsItemIdBySku(queryParams) {
    const params = { activeOnly: true, ...queryParams };
    const url = "/platform/admin/namespaces/{namespace}/items/itemId/bySku".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.get(url, { params });
    return import_sdk24.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, ItemId, "ItemId");
  }
  /**
   * This API is used to bulk get locale items. If item not exist in specific region, default region item will return.&lt;p&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: the list of items info&lt;/li&gt;&lt;/ul&gt;
   */
  getItemsLocaleByIds(queryParams) {
    const params = { activeOnly: true, ...queryParams };
    const url = "/platform/admin/namespaces/{namespace}/items/locale/byIds".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.get(url, { params });
    return import_sdk24.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, ItemInfoArray, "ItemInfoArray");
  }
  /**
   * This API is used to get an list of itemId by list of sku.&lt;p&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: item data&lt;/li&gt;&lt;/ul&gt;
   */
  getItemsItemIdBySkus(queryParams) {
    const params = { ...queryParams };
    const url = "/platform/admin/namespaces/{namespace}/items/itemId/bySkus".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.get(url, { params });
    return import_sdk24.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, ItemIdArray, "ItemIdArray");
  }
  /**
   * This API is used to query uncategorized items within a store.&lt;p&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: the list of uncategorized items&lt;/li&gt;&lt;/ul&gt;
   */
  getItemsUncategorized(queryParams) {
    const params = { activeOnly: true, limit: 20, sortBy: ["name:asc"], ...queryParams };
    const url = "/platform/admin/namespaces/{namespace}/items/uncategorized".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.get(url, { params });
    return import_sdk24.Validate.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      FullItemPagingSlicedResult,
      "FullItemPagingSlicedResult"
    );
  }
  /**
   * This API is used to query items by criteria within a store.&lt;p&gt;The behaviour for itemStatus query parameter:&lt;li&gt;TRUE: Show only ACTIVE items&lt;/li&gt;&lt;li&gt;FALSE: Show only INACTIVE items&lt;/li&gt;&lt;li&gt;Not provided: show both ACTIVE and INACTIVE items&lt;/li&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: the list of items&lt;/li&gt;&lt;/ul&gt;
   */
  getItemsByCriteria_v2(queryParams) {
    const params = { limit: 20, sortBy: ["name:asc", "displayOrder:asc"], ...queryParams };
    const url = "/platform/v2/admin/namespaces/{namespace}/items/byCriteria".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.get(url, { params });
    return import_sdk24.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, FullItemPagingResult, "FullItemPagingResult");
  }
  /**
   * This API is used to get estimated prices of a flexible pricing bundle
   */
  getItemsEstimatedPrice(queryParams) {
    const params = { ...queryParams };
    const url = "/platform/admin/namespaces/{namespace}/items/estimatedPrice".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.get(url, { params });
    return import_sdk24.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, EstimatedPriceInfo, "EstimatedPriceInfo");
  }
  /**
   * Enable an item.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: updated item&lt;/li&gt;&lt;/ul&gt;
   */
  updateEnable_ByItemId(itemId, queryParams) {
    const params = { ...queryParams };
    const url = "/platform/admin/namespaces/{namespace}/items/{itemId}/enable".replace("{namespace}", this.namespace).replace("{itemId}", itemId);
    const resultPromise = this.axiosInstance.put(url, null, { params });
    return import_sdk24.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, FullItemInfo, "FullItemInfo");
  }
  /**
   * This API is used to get an item in specific locale. If item not exist in specific region, default region item will return.&lt;p&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: item data&lt;/li&gt;&lt;/ul&gt;
   */
  getLocale_ByItemId(itemId, queryParams) {
    const params = { activeOnly: true, ...queryParams };
    const url = "/platform/admin/namespaces/{namespace}/items/{itemId}/locale".replace("{namespace}", this.namespace).replace("{itemId}", itemId);
    const resultPromise = this.axiosInstance.get(url, { params });
    return import_sdk24.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, PopulatedItemInfo, "PopulatedItemInfo");
  }
  /**
   * &lt;b&gt;[SERVICE COMMUNICATION ONLY]&lt;/b&gt; This api is used for returning a published item while the item is maxCount limited, it will increase the sale available count if orderNo already acquired.
   */
  updateReturn_ByItemId(itemId, data) {
    const params = {};
    const url = "/platform/admin/namespaces/{namespace}/items/{itemId}/return".replace("{namespace}", this.namespace).replace("{itemId}", itemId);
    const resultPromise = this.axiosInstance.put(url, data, { params });
    return import_sdk24.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, import_zod181.z.unknown(), "z.unknown()");
  }
  /**
   * Get available predicate types.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: available predicate types&lt;/li&gt;&lt;/ul&gt;
   */
  getItemsPredicateTypes() {
    const params = {};
    const url = "/platform/admin/namespaces/{namespace}/items/predicate/types".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.get(url, { params });
    return import_sdk24.Validate.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      AvailablePredicateArray,
      "AvailablePredicateArray"
    );
  }
  /**
   * &lt;b&gt;[SERVICE COMMUNICATION ONLY]&lt;/b&gt; This api is used for acquiring a published item while the item is maxCount limited, it will decrease the sale available count.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: acquire result&lt;/li&gt;&lt;/ul&gt;
   */
  updateAcquire_ByItemId(itemId, data) {
    const params = {};
    const url = "/platform/admin/namespaces/{namespace}/items/{itemId}/acquire".replace("{namespace}", this.namespace).replace("{itemId}", itemId);
    const resultPromise = this.axiosInstance.put(url, data, { params });
    return import_sdk24.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, ItemAcquireResult, "ItemAcquireResult");
  }
  /**
   * Disable an item.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: updated item&lt;/li&gt;&lt;/ul&gt;
   */
  updateDisable_ByItemId(itemId, queryParams) {
    const params = { ...queryParams };
    const url = "/platform/admin/namespaces/{namespace}/items/{itemId}/disable".replace("{namespace}", this.namespace).replace("{itemId}", itemId);
    const resultPromise = this.axiosInstance.put(url, null, { params });
    return import_sdk24.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, FullItemInfo, "FullItemInfo");
  }
  /**
   * Get item dynamic data for published item.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: item dynamic data&lt;/li&gt;&lt;/ul&gt;
   */
  getDynamic_ByItemId(itemId) {
    const params = {};
    const url = "/platform/admin/namespaces/{namespace}/items/{itemId}/dynamic".replace("{namespace}", this.namespace).replace("{itemId}", itemId);
    const resultPromise = this.axiosInstance.get(url, { params });
    return import_sdk24.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, ItemDynamicDataInfo, "ItemDynamicDataInfo");
  }
  /**
   * &lt;b&gt;[SERVICE COMMUNICATION ONLY]&lt;/b&gt; This API is used to list basic items by features.&lt;p&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: the list of basic items&lt;/li&gt;&lt;/ul&gt;
   */
  getItemsByFeaturesBasic(queryParams) {
    const params = { activeOnly: true, ...queryParams };
    const url = "/platform/admin/namespaces/{namespace}/items/byFeatures/basic".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.get(url, { params });
    return import_sdk24.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, BasicItemArray, "BasicItemArray");
  }
  /**
   * Remove a feature from an item.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: updated item&lt;/li&gt;&lt;/ul&gt;
   */
  deleteFeature_ByItemId_ByFeature(itemId, feature, queryParams) {
    const params = { ...queryParams };
    const url = "/platform/admin/namespaces/{namespace}/items/{itemId}/features/{feature}".replace("{namespace}", this.namespace).replace("{itemId}", itemId).replace("{feature}", feature);
    const resultPromise = this.axiosInstance.delete(url, { params });
    return import_sdk24.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, FullItemInfo, "FullItemInfo");
  }
  /**
   * Add a feature to an item.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: updated item&lt;/li&gt;&lt;/ul&gt;
   */
  updateFeature_ByItemId_ByFeature(itemId, feature, queryParams) {
    const params = { ...queryParams };
    const url = "/platform/admin/namespaces/{namespace}/items/{itemId}/features/{feature}".replace("{namespace}", this.namespace).replace("{itemId}", itemId).replace("{feature}", feature);
    const resultPromise = this.axiosInstance.put(url, null, { params });
    return import_sdk24.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, FullItemInfo, "FullItemInfo");
  }
  /**
   * This API is used to update item purchase condition
   */
  updatePurchaseCondition_ByItemId(itemId, data, queryParams) {
    const params = { ...queryParams };
    const url = "/platform/admin/namespaces/{namespace}/items/{itemId}/purchase/condition".replace("{namespace}", this.namespace).replace("{itemId}", itemId);
    const resultPromise = this.axiosInstance.put(url, data, { params });
    return import_sdk24.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, FullItemInfo, "FullItemInfo");
  }
  /**
   * This API is used to validate user purchase condition
   */
  createItemPurchaseConditionValidate(data, queryParams) {
    const params = { ...queryParams };
    const url = "/platform/admin/namespaces/{namespace}/items/purchase/conditions/validate".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.post(url, data, { params });
    return import_sdk24.Validate.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      ItemPurchaseConditionValidateResultArray,
      "ItemPurchaseConditionValidateResultArray"
    );
  }
};

// src/generated-admin/endpoints/KeyGroupAdmin$.ts
var import_sdk25 = require("@accelbyte/sdk");

// src/generated-definitions/KeyGroupDynamicInfo.ts
var import_zod182 = require("zod");
var KeyGroupDynamicInfo = import_zod182.z.object({
  availableSaleCount: import_zod182.z.number().int(),
  quantity: import_zod182.z.number().int(),
  saleCount: import_zod182.z.number().int()
});

// src/generated-definitions/KeyGroupInfo.ts
var import_zod183 = require("zod");
var KeyGroupInfo = import_zod183.z.object({
  boothName: import_zod183.z.string(),
  createdAt: import_zod183.z.string(),
  description: import_zod183.z.string().nullish(),
  id: import_zod183.z.string(),
  name: import_zod183.z.string(),
  namespace: import_zod183.z.string(),
  status: import_zod183.z.enum(["ACTIVE", "INACTIVE"]),
  tags: import_zod183.z.array(import_zod183.z.string()).nullish(),
  updatedAt: import_zod183.z.string()
});

// src/generated-definitions/KeyGroupPagingSlicedResult.ts
var import_zod184 = require("zod");
var KeyGroupPagingSlicedResult = import_zod184.z.object({ data: import_zod184.z.array(KeyGroupInfo), paging: Paging.nullish() });

// src/generated-definitions/KeyPagingSliceResult.ts
var import_zod186 = require("zod");

// src/generated-definitions/KeyInfo.ts
var import_zod185 = require("zod");
var KeyInfo = import_zod185.z.object({
  acquireOrderNo: import_zod185.z.string().nullish(),
  acquireUserId: import_zod185.z.string().nullish(),
  createdAt: import_zod185.z.string(),
  id: import_zod185.z.string(),
  keyFile: import_zod185.z.string(),
  keyGroupId: import_zod185.z.string(),
  namespace: import_zod185.z.string(),
  status: import_zod185.z.enum(["ACQUIRED", "ACTIVE"]),
  updatedAt: import_zod185.z.string(),
  value: import_zod185.z.string()
});

// src/generated-definitions/KeyPagingSliceResult.ts
var KeyPagingSliceResult = import_zod186.z.object({ data: import_zod186.z.array(KeyInfo), paging: Paging.nullish() });

// src/generated-admin/endpoints/KeyGroupAdmin$.ts
var KeyGroupAdmin$ = class {
  // @ts-ignore
  // prettier-ignore
  constructor(axiosInstance, namespace, useSchemaValidation = true) {
    this.axiosInstance = axiosInstance;
    this.namespace = namespace;
    this.useSchemaValidation = useSchemaValidation;
  }
  /**
   * Query key groups, if name is presented, it&#39;s fuzzy match.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: slice of key group&lt;/li&gt;&lt;/ul&gt;
   */
  getKeygroups(queryParams) {
    const params = { limit: 20, ...queryParams };
    const url = "/platform/admin/namespaces/{namespace}/keygroups".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.get(url, { params });
    return import_sdk25.Validate.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      KeyGroupPagingSlicedResult,
      "KeyGroupPagingSlicedResult"
    );
  }
  /**
   * Create key group.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: created key group&lt;/li&gt;&lt;/ul&gt;
   */
  createKeygroup(data) {
    const params = {};
    const url = "/platform/admin/namespaces/{namespace}/keygroups".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.post(url, data, { params });
    return import_sdk25.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, KeyGroupInfo, "KeyGroupInfo");
  }
  /**
   * @deprecated
   * Get key group.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: key group info&lt;/li&gt;&lt;/ul&gt;
   */
  getKeygroupsByBoothName(queryParams) {
    const params = { ...queryParams };
    const url = "/platform/admin/namespaces/{namespace}/keygroups/byBoothName".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.get(url, { params });
    return import_sdk25.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, KeyGroupInfo, "KeyGroupInfo");
  }
  /**
   * Get key group.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: key group info&lt;/li&gt;&lt;/ul&gt;
   */
  getKeygroup_ByKeyGroupId(keyGroupId) {
    const params = {};
    const url = "/platform/admin/namespaces/{namespace}/keygroups/{keyGroupId}".replace("{namespace}", this.namespace).replace("{keyGroupId}", keyGroupId);
    const resultPromise = this.axiosInstance.get(url, { params });
    return import_sdk25.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, KeyGroupInfo, "KeyGroupInfo");
  }
  /**
   * Update key group.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: updated key group&lt;/li&gt;&lt;/ul&gt;
   */
  updateKeygroup_ByKeyGroupId(keyGroupId, data) {
    const params = {};
    const url = "/platform/admin/namespaces/{namespace}/keygroups/{keyGroupId}".replace("{namespace}", this.namespace).replace("{keyGroupId}", keyGroupId);
    const resultPromise = this.axiosInstance.put(url, data, { params });
    return import_sdk25.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, KeyGroupInfo, "KeyGroupInfo");
  }
  /**
   * This API is used to list keys of a key group.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: keys&lt;/li&gt;&lt;/ul&gt;
   */
  getKeys_ByKeyGroupId(keyGroupId, queryParams) {
    const params = { limit: 20, ...queryParams };
    const url = "/platform/admin/namespaces/{namespace}/keygroups/{keyGroupId}/keys".replace("{namespace}", this.namespace).replace("{keyGroupId}", keyGroupId);
    const resultPromise = this.axiosInstance.get(url, { params });
    return import_sdk25.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, KeyPagingSliceResult, "KeyPagingSliceResult");
  }
  /**
   * This API is used to upload keys with csv format to a key group.&lt;p&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: item data&lt;/li&gt;&lt;/ul&gt;
   */
  createKey_ByKeyGroupId(keyGroupId, data) {
    const params = {};
    const url = "/platform/admin/namespaces/{namespace}/keygroups/{keyGroupId}/keys".replace("{namespace}", this.namespace).replace("{keyGroupId}", keyGroupId);
    const resultPromise = this.axiosInstance.post(url, data, { params });
    return import_sdk25.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, BulkOperationResult, "BulkOperationResult");
  }
  /**
   * Get key group dynamic.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: key group info&lt;/li&gt;&lt;/ul&gt;
   */
  getDynamic_ByKeyGroupId(keyGroupId) {
    const params = {};
    const url = "/platform/admin/namespaces/{namespace}/keygroups/{keyGroupId}/dynamic".replace("{namespace}", this.namespace).replace("{keyGroupId}", keyGroupId);
    const resultPromise = this.axiosInstance.get(url, { params });
    return import_sdk25.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, KeyGroupDynamicInfo, "KeyGroupDynamicInfo");
  }
};

// src/generated-admin/endpoints/OrderAdmin$.ts
var import_sdk26 = require("@accelbyte/sdk");
var import_zod200 = require("zod");

// src/generated-definitions/OrderGrantInfo.ts
var import_zod187 = require("zod");
var OrderGrantInfo = import_zod187.z.object({ credits: import_zod187.z.array(CreditSummary).nullish(), entitlements: import_zod187.z.array(EntitlementSummary).nullish() });

// src/generated-definitions/OrderHistoryInfoArray.ts
var import_zod189 = require("zod");

// src/generated-definitions/OrderHistoryInfo.ts
var import_zod188 = require("zod");
var OrderHistoryInfo = import_zod188.z.object({
  action: import_zod188.z.enum([
    "CHARGEBACK",
    "CHARGEBACK_REVERSED",
    "CHARGED",
    "CLOSE",
    "DELETED",
    "FULFILLED",
    "FULFILL_FAILED",
    "INIT",
    "REFUNDED",
    "REFUNDING",
    "REFUND_FAILED",
    "SET_STATUS"
  ]),
  createdAt: import_zod188.z.string(),
  namespace: import_zod188.z.string(),
  operator: import_zod188.z.string(),
  orderNo: import_zod188.z.string(),
  reason: import_zod188.z.string().nullish(),
  updatedAt: import_zod188.z.string(),
  userId: import_zod188.z.string()
});

// src/generated-definitions/OrderHistoryInfoArray.ts
var OrderHistoryInfoArray = import_zod189.z.array(OrderHistoryInfo);

// src/generated-definitions/OrderInfo.ts
var import_zod195 = require("zod");

// src/generated-definitions/DeductionDetail.ts
var import_zod192 = require("zod");

// src/generated-definitions/DiscountCodeDeductionDetail.ts
var import_zod191 = require("zod");

// src/generated-definitions/DiscountCodeInfo.ts
var import_zod190 = require("zod");
var DiscountCodeInfo = import_zod190.z.object({
  campaignId: import_zod190.z.string().nullish(),
  campaignName: import_zod190.z.string().nullish(),
  code: import_zod190.z.string().nullish(),
  deduction: import_zod190.z.number().int().nullish(),
  discountConfig: DiscountConfig.nullish()
});

// src/generated-definitions/DiscountCodeDeductionDetail.ts
var DiscountCodeDeductionDetail = import_zod191.z.object({
  discountAmountCodes: import_zod191.z.array(DiscountCodeInfo).nullish(),
  discountPercentageCodes: import_zod191.z.array(DiscountCodeInfo).nullish(),
  totalAmountDeduction: import_zod191.z.number().int().nullish(),
  totalDeduction: import_zod191.z.number().int().nullish(),
  totalPercentageDeduction: import_zod191.z.number().int().nullish()
});

// src/generated-definitions/DeductionDetail.ts
var DeductionDetail = import_zod192.z.object({
  deductionType: import_zod192.z.enum(["DISCOUNT_CODE", "PAYMENT_DISCOUNT_CODE"]).nullish(),
  discountCodeDeductionDetail: DiscountCodeDeductionDetail.nullish(),
  discountProviderName: import_zod192.z.string().nullish()
});

// src/generated-definitions/OrderBundleItemInfo.ts
var import_zod193 = require("zod");
var OrderBundleItemInfo = import_zod193.z.object({
  discountedPrice: import_zod193.z.number().int(),
  itemId: import_zod193.z.string(),
  itemName: import_zod193.z.string(),
  itemSku: import_zod193.z.string(),
  price: import_zod193.z.number().int(),
  purchased: import_zod193.z.boolean().nullish(),
  quantity: import_zod193.z.number().int().nullish()
});

// src/generated-definitions/OrderCreationOptions.ts
var import_zod194 = require("zod");
var OrderCreationOptions = import_zod194.z.object({ skipPriceValidation: import_zod194.z.boolean().nullish() });

// src/generated-definitions/OrderInfo.ts
var OrderInfo = import_zod195.z.object({
  chargebackReversedTime: import_zod195.z.string().nullish(),
  chargebackTime: import_zod195.z.string().nullish(),
  chargedTime: import_zod195.z.string().nullish(),
  createdAt: import_zod195.z.string(),
  createdTime: import_zod195.z.string().nullish(),
  creationOptions: OrderCreationOptions.nullish(),
  currency: CurrencySummary,
  deduction: import_zod195.z.number().int(),
  deductionDetails: import_zod195.z.array(DeductionDetail).nullish(),
  discountedPrice: import_zod195.z.number().int(),
  expireTime: import_zod195.z.string().nullish(),
  ext: import_zod195.z.record(import_zod195.z.any()).nullish(),
  fulfilledTime: import_zod195.z.string().nullish(),
  itemId: import_zod195.z.string(),
  itemSnapshot: ItemSnapshot.nullish(),
  language: import_zod195.z.string().nullish(),
  namespace: import_zod195.z.string(),
  orderBundleItemInfos: import_zod195.z.array(OrderBundleItemInfo).nullish(),
  orderNo: import_zod195.z.string(),
  paymentMethod: import_zod195.z.string().nullish(),
  paymentMethodFee: import_zod195.z.number().int().nullish(),
  paymentOrderNo: import_zod195.z.string().nullish(),
  paymentProvider: import_zod195.z.enum(["ADYEN", "ALIPAY", "CHECKOUT", "NEONPAY", "PAYPAL", "STRIPE", "WALLET", "WXPAY", "XSOLLA"]).nullish(),
  paymentProviderFee: import_zod195.z.number().int().nullish(),
  paymentRemainSeconds: import_zod195.z.number().int(),
  paymentStationUrl: import_zod195.z.string().nullish(),
  price: import_zod195.z.number().int(),
  quantity: import_zod195.z.number().int(),
  refundedTime: import_zod195.z.string().nullish(),
  region: import_zod195.z.string().nullish(),
  salesTax: import_zod195.z.number().int().nullish(),
  sandbox: import_zod195.z.boolean(),
  status: import_zod195.z.enum([
    "CHARGEBACK",
    "CHARGEBACK_REVERSED",
    "CHARGED",
    "CLOSED",
    "DELETED",
    "FULFILLED",
    "FULFILL_FAILED",
    "INIT",
    "REFUNDED",
    "REFUNDING",
    "REFUND_FAILED"
  ]),
  statusReason: import_zod195.z.string().nullish(),
  subtotalPrice: import_zod195.z.number().int().nullish(),
  tax: import_zod195.z.number().int().nullish(),
  totalPrice: import_zod195.z.number().int().nullish(),
  totalTax: import_zod195.z.number().int().nullish(),
  updatedAt: import_zod195.z.string(),
  userId: import_zod195.z.string(),
  vat: import_zod195.z.number().int().nullish()
});

// src/generated-definitions/OrderPagingResult.ts
var import_zod196 = require("zod");
var OrderPagingResult = import_zod196.z.object({ data: import_zod196.z.array(OrderInfo), paging: Paging.nullish(), total: import_zod196.z.number().int().nullish() });

// src/generated-definitions/OrderPagingSlicedResult.ts
var import_zod197 = require("zod");
var OrderPagingSlicedResult = import_zod197.z.object({ data: import_zod197.z.array(OrderInfo), paging: Paging.nullish() });

// src/generated-definitions/OrderStatistics.ts
var import_zod198 = require("zod");
var OrderStatistics = import_zod198.z.object({ statusCount: import_zod198.z.record(import_zod198.z.number().int()), total: import_zod198.z.number().int() });

// src/generated-definitions/PurchasedItemCount.ts
var import_zod199 = require("zod");
var PurchasedItemCount = import_zod199.z.object({ count: import_zod199.z.number().int().nullish() });

// src/generated-admin/endpoints/OrderAdmin$.ts
var OrderAdmin$ = class {
  // @ts-ignore
  // prettier-ignore
  constructor(axiosInstance, namespace, useSchemaValidation = true) {
    this.axiosInstance = axiosInstance;
    this.namespace = namespace;
    this.useSchemaValidation = useSchemaValidation;
  }
  /**
   * Query orders.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: query orders&lt;/li&gt;&lt;/ul&gt;
   */
  getOrders(queryParams) {
    const params = { limit: 20, sortBy: "createdTime:desc", ...queryParams };
    const url = "/platform/admin/namespaces/{namespace}/orders".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.get(url, { params });
    return import_sdk26.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, OrderPagingResult, "OrderPagingResult");
  }
  /**
   * Get Order Statistics.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: order statistics&lt;/li&gt;&lt;/ul&gt;
   */
  getOrdersStats() {
    const params = {};
    const url = "/platform/admin/namespaces/{namespace}/orders/stats".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.get(url, { params });
    return import_sdk26.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, OrderStatistics, "OrderStatistics");
  }
  /**
   * Get order by orderNo.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: order instance&lt;/li&gt;&lt;/ul&gt;
   */
  getOrder_ByOrderNo(orderNo) {
    const params = {};
    const url = "/platform/admin/namespaces/{namespace}/orders/{orderNo}".replace("{namespace}", this.namespace).replace("{orderNo}", orderNo);
    const resultPromise = this.axiosInstance.get(url, { params });
    return import_sdk26.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, OrderInfo, "OrderInfo");
  }
  /**
   * Query user orders.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: get order&lt;/li&gt;&lt;/ul&gt;
   */
  getOrders_ByUserId(userId, queryParams) {
    const params = { limit: 20, ...queryParams };
    const url = "/platform/admin/namespaces/{namespace}/users/{userId}/orders".replace("{namespace}", this.namespace).replace("{userId}", userId);
    const resultPromise = this.axiosInstance.get(url, { params });
    return import_sdk26.Validate.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      OrderPagingSlicedResult,
      "OrderPagingSlicedResult"
    );
  }
  /**
   * Admin Create an order. The result contains the checkout link and payment token. User with permission SANDBOX will create sandbox order that not real paid for xsolla/alipay and not validate price for wxpay.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;It will be forbidden while the user is banned: ORDER_INITIATE or ORDER_AND_PAYMENT&lt;/li&gt;&lt;li&gt;sandbox default value is &lt;b&gt;false&lt;/b&gt;&lt;/li&gt;&lt;li&gt;platform default value is &lt;b&gt;Other&lt;/b&gt;&lt;/li&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: created order&lt;/li&gt;&lt;/ul&gt;&lt;h2&gt;Restrictions for ext field&lt;/h2&gt; 1. Cannot use &lt;b&gt;&#34;.&#34;&lt;/b&gt; as the key name - &lt;pre&gt;{ &#34;data.2&#34;: &#34;value&#34; }&lt;/pre&gt; 2. Cannot use &lt;b&gt;&#34;$&#34;&lt;/b&gt; as the prefix in key names - &lt;pre&gt;{ &#34;$data&#34;: &#34;value&#34; }&lt;/pre&gt;
   */
  createOrder_ByUserId(userId, data) {
    const params = {};
    const url = "/platform/admin/namespaces/{namespace}/users/{userId}/orders".replace("{namespace}", this.namespace).replace("{userId}", userId);
    const resultPromise = this.axiosInstance.post(url, data, { params });
    return import_sdk26.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, OrderInfo, "OrderInfo");
  }
  /**
   * Refund order by orderNo.
   */
  updateRefund_ByOrderNo(orderNo, data) {
    const params = {};
    const url = "/platform/admin/namespaces/{namespace}/orders/{orderNo}/refund".replace("{namespace}", this.namespace).replace("{orderNo}", orderNo);
    const resultPromise = this.axiosInstance.put(url, data, { params });
    return import_sdk26.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, OrderInfo, "OrderInfo");
  }
  /**
   * Get an order.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: get order&lt;/li&gt;&lt;/ul&gt;
   */
  getOrder_ByUserId_ByOrderNo(userId, orderNo) {
    const params = {};
    const url = "/platform/admin/namespaces/{namespace}/users/{userId}/orders/{orderNo}".replace("{namespace}", this.namespace).replace("{userId}", userId).replace("{orderNo}", orderNo);
    const resultPromise = this.axiosInstance.get(url, { params });
    return import_sdk26.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, OrderInfo, "OrderInfo");
  }
  /**
   * Update order status.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: updated order&lt;/li&gt;&lt;/ul&gt;
   */
  updateOrder_ByUserId_ByOrderNo(userId, orderNo, data) {
    const params = {};
    const url = "/platform/admin/namespaces/{namespace}/users/{userId}/orders/{orderNo}".replace("{namespace}", this.namespace).replace("{userId}", userId).replace("{orderNo}", orderNo);
    const resultPromise = this.axiosInstance.put(url, data, { params });
    return import_sdk26.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, OrderInfo, "OrderInfo");
  }
  /**
   * This API is used to get the count of purchased item which is the order target.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: Item purchased count&lt;/li&gt;&lt;/ul&gt;
   */
  getOrdersCountOfItem_ByUserId(userId, queryParams) {
    const params = { ...queryParams };
    const url = "/platform/admin/namespaces/{namespace}/users/{userId}/orders/countOfItem".replace("{namespace}", this.namespace).replace("{userId}", userId);
    const resultPromise = this.axiosInstance.get(url, { params });
    return import_sdk26.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, PurchasedItemCount, "PurchasedItemCount");
  }
  /**
   * @deprecated
   * Get user order grant that fulfilled by this order.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: get order grant&lt;/li&gt;&lt;/ul&gt;
   */
  getGrant_ByUserId_ByOrderNo(userId, orderNo) {
    const params = {};
    const url = "/platform/admin/namespaces/{namespace}/users/{userId}/orders/{orderNo}/grant".replace("{namespace}", this.namespace).replace("{userId}", userId).replace("{orderNo}", orderNo);
    const resultPromise = this.axiosInstance.get(url, { params });
    return import_sdk26.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, OrderGrantInfo, "OrderGrantInfo");
  }
  /**
   * Fulfill an order if the order is charged but fulfill failed.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: fulfilled order&lt;/li&gt;&lt;/ul&gt;
   */
  updateFulfill_ByUserId_ByOrderNo(userId, orderNo) {
    const params = {};
    const url = "/platform/admin/namespaces/{namespace}/users/{userId}/orders/{orderNo}/fulfill".replace("{namespace}", this.namespace).replace("{userId}", userId).replace("{orderNo}", orderNo);
    const resultPromise = this.axiosInstance.put(url, null, { params });
    return import_sdk26.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, OrderInfo, "OrderInfo");
  }
  /**
   * Get user order history.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: get order history&lt;/li&gt;&lt;/ul&gt;
   */
  getHistory_ByUserId_ByOrderNo(userId, orderNo) {
    const params = {};
    const url = "/platform/admin/namespaces/{namespace}/users/{userId}/orders/{orderNo}/history".replace("{namespace}", this.namespace).replace("{userId}", userId).replace("{orderNo}", orderNo);
    const resultPromise = this.axiosInstance.get(url, { params });
    return import_sdk26.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, OrderHistoryInfoArray, "OrderHistoryInfoArray");
  }
  /**
   * Download user order receipt by orderNo.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: order receipt pdf&lt;/li&gt;&lt;/ul&gt;
   */
  getReceiptPdf_ByUserId_ByOrderNo(userId, orderNo) {
    const params = {};
    const url = "/platform/admin/namespaces/{namespace}/users/{userId}/orders/{orderNo}/receipt.pdf".replace("{namespace}", this.namespace).replace("{userId}", userId).replace("{orderNo}", orderNo);
    const resultPromise = this.axiosInstance.get(url, { params });
    return import_sdk26.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, import_zod200.z.unknown(), "z.unknown()");
  }
  /**
   * &lt;b&gt;[SERVICE COMMUNICATION ONLY]&lt;/b&gt; This API is used as a web hook for payment notification from justice payment service.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: Process result&lt;/li&gt;&lt;/ul&gt;
   */
  createNotification_ByUserId_ByOrderNo(userId, orderNo, data) {
    const params = {};
    const url = "/platform/admin/namespaces/{namespace}/users/{userId}/orders/{orderNo}/notifications".replace("{namespace}", this.namespace).replace("{userId}", userId).replace("{orderNo}", orderNo);
    const resultPromise = this.axiosInstance.post(url, data, { params });
    return import_sdk26.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, import_zod200.z.unknown(), "z.unknown()");
  }
};

// src/generated-admin/endpoints/OrderDedicatedAdmin$.ts
var import_sdk27 = require("@accelbyte/sdk");

// src/generated-definitions/OrderSyncResult.ts
var import_zod203 = require("zod");

// src/generated-definitions/Order.ts
var import_zod202 = require("zod");

// src/generated-definitions/PaymentData.ts
var import_zod201 = require("zod");
var PaymentData = import_zod201.z.object({
  discountAmount: import_zod201.z.number().int().nullish(),
  discountCode: import_zod201.z.string().nullish(),
  subtotalPrice: import_zod201.z.number().int().nullish(),
  tax: import_zod201.z.number().int().nullish(),
  totalPrice: import_zod201.z.number().int().nullish()
});

// src/generated-definitions/Order.ts
var Order = import_zod202.z.object({
  chargebackReversedTime: import_zod202.z.string().nullish(),
  chargebackTime: import_zod202.z.string().nullish(),
  charged: import_zod202.z.boolean().nullish(),
  chargedTime: import_zod202.z.string().nullish(),
  countItemId: import_zod202.z.string().nullish(),
  countNamespace: import_zod202.z.string().nullish(),
  countUserId: import_zod202.z.string().nullish(),
  createdAt: import_zod202.z.string().nullish(),
  createdTime: import_zod202.z.string().nullish(),
  creationOptions: OrderCreationOptions.nullish(),
  currency: CurrencySummary.nullish(),
  deduction: import_zod202.z.number().int().nullish(),
  deductionDetails: import_zod202.z.array(DeductionDetail).nullish(),
  discountedPrice: import_zod202.z.number().int().nullish(),
  expireTime: import_zod202.z.string().nullish(),
  ext: import_zod202.z.record(import_zod202.z.any()).nullish(),
  finalPrice: import_zod202.z.number().int().nullish(),
  free: import_zod202.z.boolean().nullish(),
  fulfilledTime: import_zod202.z.string().nullish(),
  itemId: import_zod202.z.string().nullish(),
  itemSnapshot: ItemSnapshot.nullish(),
  language: import_zod202.z.string().nullish(),
  namespace: import_zod202.z.string().nullish(),
  orderBundleItemInfos: import_zod202.z.array(OrderBundleItemInfo).nullish(),
  orderNo: import_zod202.z.string().nullish(),
  paymentData: PaymentData.nullish(),
  paymentMethod: import_zod202.z.string().nullish(),
  paymentMethodFee: import_zod202.z.number().int().nullish(),
  paymentOrderNo: import_zod202.z.string().nullish(),
  paymentProvider: import_zod202.z.enum(["ADYEN", "ALIPAY", "CHECKOUT", "NEONPAY", "PAYPAL", "STRIPE", "WALLET", "WXPAY", "XSOLLA"]).nullish(),
  paymentProviderFee: import_zod202.z.number().int().nullish(),
  paymentRemainSeconds: import_zod202.z.number().int().nullish(),
  paymentStationUrl: import_zod202.z.string().nullish(),
  price: import_zod202.z.number().int().nullish(),
  quantity: import_zod202.z.number().int().nullish(),
  refundedTime: import_zod202.z.string().nullish(),
  region: import_zod202.z.string().nullish(),
  returnUrl: import_zod202.z.string().nullish(),
  rvn: import_zod202.z.number().int().nullish(),
  salesTax: import_zod202.z.number().int().nullish(),
  sandbox: import_zod202.z.boolean().nullish(),
  status: import_zod202.z.enum([
    "CHARGEBACK",
    "CHARGEBACK_REVERSED",
    "CHARGED",
    "CLOSED",
    "DELETED",
    "FULFILLED",
    "FULFILL_FAILED",
    "INIT",
    "REFUNDED",
    "REFUNDING",
    "REFUND_FAILED"
  ]).nullish(),
  statusReason: import_zod202.z.string().nullish(),
  subtotalPrice: import_zod202.z.number().int().nullish(),
  tax: import_zod202.z.number().int().nullish(),
  totalPrice: import_zod202.z.number().int().nullish(),
  totalTax: import_zod202.z.number().int().nullish(),
  updatedAt: import_zod202.z.string().nullish(),
  userId: import_zod202.z.string().nullish(),
  vat: import_zod202.z.number().int().nullish()
});

// src/generated-definitions/OrderSyncResult.ts
var OrderSyncResult = import_zod203.z.object({ nextEvaluatedKey: import_zod203.z.string().nullish(), orders: import_zod203.z.array(Order).nullish() });

// src/generated-admin/endpoints/OrderDedicatedAdmin$.ts
var OrderDedicatedAdmin$ = class {
  // @ts-ignore
  // prettier-ignore
  constructor(axiosInstance, namespace, useSchemaValidation = true) {
    this.axiosInstance = axiosInstance;
    this.namespace = namespace;
    this.useSchemaValidation = useSchemaValidation;
  }
  /**
   * &lt;b&gt;[Not supported yet in AGS Shared Cloud]&lt;/b&gt;Sync orders. If response contains nextEvaluatedKey, please use it as query param in the next call to fetch the next batch, a batch has 1000 elements or less.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: sync orders&lt;/li&gt;&lt;/ul&gt;
   */
  getOrders(queryParams) {
    const params = { ...queryParams };
    const url = "/platform/admin/orders";
    const resultPromise = this.axiosInstance.get(url, { params });
    return import_sdk27.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, OrderSyncResult, "OrderSyncResult");
  }
};

// src/generated-admin/endpoints/PaymentAdmin$.ts
var import_sdk28 = require("@accelbyte/sdk");
var import_zod212 = require("zod");

// src/generated-definitions/NotificationProcessResult.ts
var import_zod204 = require("zod");
var NotificationProcessResult = import_zod204.z.object({
  code: import_zod204.z.string().nullish(),
  customParam: import_zod204.z.record(import_zod204.z.any()).nullish(),
  severity: import_zod204.z.number().int().nullish(),
  status: import_zod204.z.enum(["ERROR", "IGNORED", "PROCESSED", "WARN"]).nullish()
});

// src/generated-definitions/PaymentNotificationPagingSlicedResult.ts
var import_zod206 = require("zod");

// src/generated-definitions/PaymentNotificationInfo.ts
var import_zod205 = require("zod");
var PaymentNotificationInfo = import_zod205.z.object({
  createdAt: import_zod205.z.string(),
  externalId: import_zod205.z.string().nullish(),
  id: import_zod205.z.string(),
  namespace: import_zod205.z.string(),
  notification: import_zod205.z.record(import_zod205.z.any()),
  notificationSource: import_zod205.z.enum(["ADYEN", "ALIPAY", "CHECKOUT", "NEONPAY", "PAYPAL", "STRIPE", "WALLET", "WXPAY", "XSOLLA"]),
  notificationType: import_zod205.z.string(),
  paymentOrderNo: import_zod205.z.string(),
  status: import_zod205.z.enum(["ERROR", "IGNORED", "PROCESSED", "WARN"]),
  statusReason: import_zod205.z.string().nullish(),
  updatedAt: import_zod205.z.string()
});

// src/generated-definitions/PaymentNotificationPagingSlicedResult.ts
var PaymentNotificationPagingSlicedResult = import_zod206.z.object({ data: import_zod206.z.array(PaymentNotificationInfo), paging: Paging.nullish() });

// src/generated-definitions/PaymentOrderChargeStatus.ts
var import_zod207 = require("zod");
var PaymentOrderChargeStatus = import_zod207.z.object({
  charging: import_zod207.z.boolean().nullish(),
  status: import_zod207.z.enum([
    "AUTHORISED",
    "AUTHORISE_FAILED",
    "CHARGEBACK",
    "CHARGEBACK_REVERSED",
    "CHARGED",
    "CHARGE_FAILED",
    "DELETED",
    "INIT",
    "NOTIFICATION_OF_CHARGEBACK",
    "REFUNDED",
    "REFUNDING",
    "REFUND_FAILED",
    "REQUEST_FOR_INFORMATION"
  ]).nullish()
});

// src/generated-definitions/PaymentOrderInfo.ts
var import_zod210 = require("zod");

// src/generated-definitions/Transaction.ts
var import_zod209 = require("zod");

// src/generated-definitions/AdditionalData.ts
var import_zod208 = require("zod");
var AdditionalData = import_zod208.z.object({ cardSummary: import_zod208.z.string().nullish() });

// src/generated-definitions/Transaction.ts
var Transaction = import_zod209.z.object({
  additionalData: AdditionalData.nullish(),
  amount: import_zod209.z.number().int().nullish(),
  currency: CurrencySummary.nullish(),
  extMessage: import_zod209.z.string().nullish(),
  extStatusCode: import_zod209.z.string().nullish(),
  extTxId: import_zod209.z.string().nullish(),
  merchantId: import_zod209.z.string().nullish(),
  notified: import_zod209.z.boolean().nullish(),
  paymentData: PaymentData.nullish(),
  paymentMethod: import_zod209.z.string().nullish(),
  paymentMethodFee: import_zod209.z.number().int().nullish(),
  paymentProviderFee: import_zod209.z.number().int().nullish(),
  provider: import_zod209.z.enum(["ADYEN", "ALIPAY", "CHECKOUT", "NEONPAY", "PAYPAL", "STRIPE", "WALLET", "WXPAY", "XSOLLA"]).nullish(),
  salesTax: import_zod209.z.number().int().nullish(),
  status: import_zod209.z.enum(["FAILED", "FINISHED"]).nullish(),
  tax: import_zod209.z.number().int().nullish(),
  txEndTime: import_zod209.z.string().nullish(),
  txId: import_zod209.z.string().nullish(),
  type: import_zod209.z.enum([
    "AUTHORISATION",
    "CHARGE",
    "CHARGEBACK",
    "CHARGEBACK_REVERSED",
    "CHARGE_FAILED",
    "NOTIFICATION_OF_CHARGEBACK",
    "REFUND",
    "REFUND_FAILED",
    "REQUEST_FOR_INFORMATION"
  ]).nullish(),
  vat: import_zod209.z.number().int().nullish()
});

// src/generated-definitions/PaymentOrderInfo.ts
var PaymentOrderInfo = import_zod210.z.object({
  authorisedTime: import_zod210.z.string().nullish(),
  channel: import_zod210.z.enum(["EXTERNAL", "INTERNAL"]),
  chargebackReversedTime: import_zod210.z.string().nullish(),
  chargebackTime: import_zod210.z.string().nullish(),
  chargedTime: import_zod210.z.string().nullish(),
  charging: import_zod210.z.boolean().nullish(),
  createdAt: import_zod210.z.string(),
  createdTime: import_zod210.z.string().nullish(),
  currency: CurrencySummary,
  customParameters: import_zod210.z.record(import_zod210.z.any()).nullish(),
  description: import_zod210.z.string().nullish(),
  extOrderNo: import_zod210.z.string(),
  extUserId: import_zod210.z.string().nullish(),
  itemType: import_zod210.z.enum(["APP", "BUNDLE", "CODE", "COINS", "EXTENSION", "INGAMEITEM", "LOOTBOX", "MEDIA", "OPTIONBOX", "SEASON", "SUBSCRIPTION"]).nullish(),
  language: import_zod210.z.string().nullish(),
  metadata: import_zod210.z.record(import_zod210.z.string()).nullish(),
  namespace: import_zod210.z.string(),
  notifyUrl: import_zod210.z.string().nullish(),
  omitNotification: import_zod210.z.boolean().nullish(),
  paymentMethod: import_zod210.z.string().nullish(),
  paymentMethodFee: import_zod210.z.number().int().nullish(),
  paymentOrderNo: import_zod210.z.string(),
  paymentProvider: import_zod210.z.enum(["ADYEN", "ALIPAY", "CHECKOUT", "NEONPAY", "PAYPAL", "STRIPE", "WALLET", "WXPAY", "XSOLLA"]).nullish(),
  paymentProviderFee: import_zod210.z.number().int().nullish(),
  paymentStationUrl: import_zod210.z.string().nullish(),
  price: import_zod210.z.number().int(),
  recurringPaymentOrderNo: import_zod210.z.string().nullish(),
  refundedTime: import_zod210.z.string().nullish(),
  region: import_zod210.z.string().nullish(),
  returnUrl: import_zod210.z.string().nullish(),
  salesTax: import_zod210.z.number().int().nullish(),
  sandbox: import_zod210.z.boolean(),
  sku: import_zod210.z.string().nullish(),
  status: import_zod210.z.enum([
    "AUTHORISED",
    "AUTHORISE_FAILED",
    "CHARGEBACK",
    "CHARGEBACK_REVERSED",
    "CHARGED",
    "CHARGE_FAILED",
    "DELETED",
    "INIT",
    "NOTIFICATION_OF_CHARGEBACK",
    "REFUNDED",
    "REFUNDING",
    "REFUND_FAILED",
    "REQUEST_FOR_INFORMATION"
  ]),
  statusReason: import_zod210.z.string().nullish(),
  subscriptionId: import_zod210.z.string().nullish(),
  subtotalPrice: import_zod210.z.number().int().nullish(),
  targetNamespace: import_zod210.z.string().nullish(),
  targetUserId: import_zod210.z.string().nullish(),
  tax: import_zod210.z.number().int().nullish(),
  title: import_zod210.z.string(),
  totalPrice: import_zod210.z.number().int().nullish(),
  totalTax: import_zod210.z.number().int().nullish(),
  transactions: import_zod210.z.array(Transaction).nullish(),
  updatedAt: import_zod210.z.string(),
  userId: import_zod210.z.string(),
  vat: import_zod210.z.number().int().nullish()
});

// src/generated-definitions/PaymentOrderPagingSlicedResult.ts
var import_zod211 = require("zod");
var PaymentOrderPagingSlicedResult = import_zod211.z.object({ data: import_zod211.z.array(PaymentOrderInfo), paging: Paging.nullish() });

// src/generated-admin/endpoints/PaymentAdmin$.ts
var PaymentAdmin$ = class {
  // @ts-ignore
  // prettier-ignore
  constructor(axiosInstance, namespace, useSchemaValidation = true) {
    this.axiosInstance = axiosInstance;
    this.namespace = namespace;
    this.useSchemaValidation = useSchemaValidation;
  }
  /**
   * &lt;b&gt;[Not supported yet in AGS Shared Cloud]&lt;/b&gt;Query payment orders.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: query payment orders&lt;/li&gt;&lt;/ul&gt;
   */
  getPaymentOrders(queryParams) {
    const params = { limit: 20, ...queryParams };
    const url = "/platform/admin/namespaces/{namespace}/payment/orders".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.get(url, { params });
    return import_sdk28.Validate.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      PaymentOrderPagingSlicedResult,
      "PaymentOrderPagingSlicedResult"
    );
  }
  /**
   * &lt;b&gt;[Not supported yet in AGS Shared Cloud]&lt;/b&gt;Query payment notifications.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: Payment notifications&lt;/li&gt;&lt;/ul&gt;
   */
  getPaymentNotifications(queryParams) {
    const params = { limit: 20, ...queryParams };
    const url = "/platform/admin/namespaces/{namespace}/payment/notifications".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.get(url, { params });
    return import_sdk28.Validate.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      PaymentNotificationPagingSlicedResult,
      "PaymentNotificationPagingSlicedResult"
    );
  }
  /**
   * &lt;b&gt;[Not supported yet in AGS Shared Cloud]&lt;/b&gt;List external order No by external transaction id.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: payment orders&lt;/li&gt;&lt;/ul&gt;
   */
  getPaymentOrdersByExtTxId(queryParams) {
    const params = { ...queryParams };
    const url = "/platform/admin/namespaces/{namespace}/payment/orders/byExtTxId".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.get(url, { params });
    return import_sdk28.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, import_zod212.z.unknown(), "z.unknown()");
  }
  /**
   * &lt;b&gt;[Not supported yet in AGS Shared Cloud]&lt;/b&gt;&lt;b&gt;[SERVICE COMMUNICATION ONLY]&lt;/b&gt; This API is used to create payment order from justice service. The result contains the payment station url.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;It will be forbidden while the user is banned: PAYMENT_INITIATE or ORDER_AND_PAYMENT&lt;/li&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: created order&lt;/li&gt;&lt;/ul&gt;&lt;h2&gt;Restrictions for custom parameters and meta data&lt;/h2&gt; 1. Cannot use &lt;b&gt;&#34;.&#34;&lt;/b&gt; as the key name - &lt;pre&gt;{ &#34;data.2&#34;: &#34;value&#34; }&lt;/pre&gt; 2. Cannot use &lt;b&gt;&#34;$&#34;&lt;/b&gt; as the prefix in key names - &lt;pre&gt;{ &#34;$data&#34;: &#34;value&#34; }&lt;/pre&gt;
   */
  createPaymentOrder_ByUserId(userId, data) {
    const params = {};
    const url = "/platform/admin/namespaces/{namespace}/users/{userId}/payment/orders".replace("{namespace}", this.namespace).replace("{userId}", userId);
    const resultPromise = this.axiosInstance.post(url, data, { params });
    return import_sdk28.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, PaymentOrderInfo, "PaymentOrderInfo");
  }
  /**
   * &lt;b&gt;[Not supported yet in AGS Shared Cloud]&lt;/b&gt;Get payment order by paymentOrderNo.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: payment order instance&lt;/li&gt;&lt;/ul&gt;
   */
  getPaymentOrder_ByPaymentOrderNo(paymentOrderNo) {
    const params = {};
    const url = "/platform/admin/namespaces/{namespace}/payment/orders/{paymentOrderNo}".replace("{namespace}", this.namespace).replace("{paymentOrderNo}", paymentOrderNo);
    const resultPromise = this.axiosInstance.get(url, { params });
    return import_sdk28.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, PaymentOrderInfo, "PaymentOrderInfo");
  }
  /**
   * &lt;b&gt;[Not supported yet in AGS Shared Cloud]&lt;/b&gt;&lt;b&gt;[TEST FACILITY ONLY] Forbidden in live environment. &lt;/b&gt; Charge payment order without payment flow for unpaid payment order, usually for test usage to simulate real currency payment process.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: payment order instance&lt;/li&gt;&lt;/ul&gt;
   */
  updatePaymentOrder_ByPaymentOrderNo(paymentOrderNo, data) {
    const params = {};
    const url = "/platform/admin/namespaces/{namespace}/payment/orders/{paymentOrderNo}".replace("{namespace}", this.namespace).replace("{paymentOrderNo}", paymentOrderNo);
    const resultPromise = this.axiosInstance.put(url, data, { params });
    return import_sdk28.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, PaymentOrderInfo, "PaymentOrderInfo");
  }
  /**
   * &lt;b&gt;[Not supported yet in AGS Shared Cloud]&lt;/b&gt;Get payment order charge status.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: payment order charge status&lt;/li&gt;&lt;/ul&gt;
   */
  getStatusPayment_ByPaymentOrderNo(paymentOrderNo) {
    const params = {};
    const url = "/platform/admin/namespaces/{namespace}/payment/orders/{paymentOrderNo}/status".replace("{namespace}", this.namespace).replace("{paymentOrderNo}", paymentOrderNo);
    const resultPromise = this.axiosInstance.get(url, { params });
    return import_sdk28.Validate.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      PaymentOrderChargeStatus,
      "PaymentOrderChargeStatus"
    );
  }
  /**
   * &lt;b&gt;[Not supported yet in AGS Shared Cloud]&lt;/b&gt;&lt;b&gt;[TEST FACILITY ONLY] Forbidden in live environment. &lt;/b&gt; Simulate payment notification on sandbox payment order, usually for test usage to simulate real currency payment notification.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: notification process result&lt;/li&gt;&lt;/ul&gt;
   */
  updateSimulateNotificationPayment_ByPaymentOrderNo(paymentOrderNo, data) {
    const params = {};
    const url = "/platform/admin/namespaces/{namespace}/payment/orders/{paymentOrderNo}/simulate-notification".replace("{namespace}", this.namespace).replace("{paymentOrderNo}", paymentOrderNo);
    const resultPromise = this.axiosInstance.put(url, data, { params });
    return import_sdk28.Validate.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      NotificationProcessResult,
      "NotificationProcessResult"
    );
  }
  /**
   * &lt;b&gt;[Not supported yet in AGS Shared Cloud]&lt;/b&gt;&lt;b&gt;[SERVICE COMMUNICATION ONLY]&lt;/b&gt; This API is used to refund order by paymentOrderNo from justice service.
   */
  updateRefundPayment_ByUserId_ByPaymentOrderNo(userId, paymentOrderNo, data) {
    const params = {};
    const url = "/platform/admin/namespaces/{namespace}/users/{userId}/payment/orders/{paymentOrderNo}/refund".replace("{namespace}", this.namespace).replace("{userId}", userId).replace("{paymentOrderNo}", paymentOrderNo);
    const resultPromise = this.axiosInstance.put(url, data, { params });
    return import_sdk28.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, PaymentOrderInfo, "PaymentOrderInfo");
  }
};

// src/generated-admin/endpoints/PaymentCallbackConfigAdmin$.ts
var import_sdk29 = require("@accelbyte/sdk");

// src/generated-definitions/PaymentCallbackConfigInfo.ts
var import_zod213 = require("zod");
var PaymentCallbackConfigInfo = import_zod213.z.object({
  dryRun: import_zod213.z.boolean().nullish(),
  namespace: import_zod213.z.string(),
  notifyUrl: import_zod213.z.string().nullish(),
  privateKey: import_zod213.z.string().nullish()
});

// src/generated-admin/endpoints/PaymentCallbackConfigAdmin$.ts
var PaymentCallbackConfigAdmin$ = class {
  // @ts-ignore
  // prettier-ignore
  constructor(axiosInstance, namespace, useSchemaValidation = true) {
    this.axiosInstance = axiosInstance;
    this.namespace = namespace;
    this.useSchemaValidation = useSchemaValidation;
  }
  /**
   * &lt;b&gt;[Not supported yet in AGS Shared Cloud]&lt;/b&gt;Get payment callback configuration.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: Payment callback config&lt;/li&gt;&lt;/ul&gt;
   */
  getPaymentConfigCallback() {
    const params = {};
    const url = "/platform/admin/namespaces/{namespace}/payment/config/callback".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.get(url, { params });
    return import_sdk29.Validate.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      PaymentCallbackConfigInfo,
      "PaymentCallbackConfigInfo"
    );
  }
  /**
   * &lt;b&gt;[Not supported yet in AGS Shared Cloud]&lt;/b&gt;Update payment callback configuration.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: Payment callback config&lt;/li&gt;&lt;/ul&gt;
   */
  updatePaymentConfigCallback(data) {
    const params = {};
    const url = "/platform/admin/namespaces/{namespace}/payment/config/callback".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.put(url, data, { params });
    return import_sdk29.Validate.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      PaymentCallbackConfigInfo,
      "PaymentCallbackConfigInfo"
    );
  }
};

// src/generated-admin/endpoints/PaymentConfigAdmin$.ts
var import_sdk30 = require("@accelbyte/sdk");
var import_zod228 = require("zod");

// src/generated-definitions/PaymentDomainWhitelistConfigInfo.ts
var import_zod214 = require("zod");
var PaymentDomainWhitelistConfigInfo = import_zod214.z.object({ domains: import_zod214.z.array(import_zod214.z.string()), namespace: import_zod214.z.string() });

// src/generated-definitions/PaymentMerchantConfigInfo.ts
var import_zod224 = require("zod");

// src/generated-definitions/AdyenConfig.ts
var import_zod215 = require("zod");
var AdyenConfig = import_zod215.z.object({
  allowedPaymentMethods: import_zod215.z.array(import_zod215.z.string()).nullish(),
  apiKey: import_zod215.z.string().nullish(),
  authoriseAsCapture: import_zod215.z.boolean().nullish(),
  blockedPaymentMethods: import_zod215.z.array(import_zod215.z.string()).nullish(),
  clientKey: import_zod215.z.string().nullish(),
  dropInSettings: import_zod215.z.string().nullish(),
  liveEndpointUrlPrefix: import_zod215.z.string().nullish(),
  merchantAccount: import_zod215.z.string().nullish(),
  notificationHmacKey: import_zod215.z.string().nullish(),
  notificationPassword: import_zod215.z.string().nullish(),
  notificationUsername: import_zod215.z.string().nullish(),
  returnUrl: import_zod215.z.string().nullish(),
  settings: import_zod215.z.string().nullish()
});

// src/generated-definitions/AliPayConfig.ts
var import_zod216 = require("zod");
var AliPayConfig = import_zod216.z.object({
  appId: import_zod216.z.string().nullish(),
  privateKey: import_zod216.z.string().nullish(),
  publicKey: import_zod216.z.string().nullish(),
  returnUrl: import_zod216.z.string().nullish()
});

// src/generated-definitions/CheckoutConfig.ts
var import_zod217 = require("zod");
var CheckoutConfig = import_zod217.z.object({ publicKey: import_zod217.z.string().nullish(), secretKey: import_zod217.z.string().nullish() });

// src/generated-definitions/NeonPayConfig.ts
var import_zod218 = require("zod");
var NeonPayConfig = import_zod218.z.object({ apiKey: import_zod218.z.string().nullish(), webhookSecretKey: import_zod218.z.string().nullish() });

// src/generated-definitions/PayPalConfig.ts
var import_zod219 = require("zod");
var PayPalConfig = import_zod219.z.object({
  clientID: import_zod219.z.string().nullish(),
  clientSecret: import_zod219.z.string().nullish(),
  returnUrl: import_zod219.z.string().nullish(),
  webHookId: import_zod219.z.string().nullish()
});

// src/generated-definitions/StripeConfig.ts
var import_zod220 = require("zod");
var StripeConfig = import_zod220.z.object({
  allowedPaymentMethodTypes: import_zod220.z.array(import_zod220.z.string()).nullish(),
  publishableKey: import_zod220.z.string().nullish(),
  secretKey: import_zod220.z.string().nullish(),
  webhookSecret: import_zod220.z.string().nullish()
});

// src/generated-definitions/WxPayConfigInfo.ts
var import_zod221 = require("zod");
var WxPayConfigInfo = import_zod221.z.object({
  appId: import_zod221.z.string().nullish(),
  certPath: import_zod221.z.string().nullish(),
  key: import_zod221.z.string().nullish(),
  mchid: import_zod221.z.string().nullish(),
  returnUrl: import_zod221.z.string().nullish()
});

// src/generated-definitions/XsollaConfig.ts
var import_zod222 = require("zod");
var XsollaConfig = import_zod222.z.object({
  apiKey: import_zod222.z.string().nullish(),
  flowCompletionUrl: import_zod222.z.string().nullish(),
  merchantId: import_zod222.z.number().int().nullish(),
  projectId: import_zod222.z.number().int().nullish(),
  projectSecretKey: import_zod222.z.string().nullish()
});

// src/generated-definitions/XsollaPaywallConfig.ts
var import_zod223 = require("zod");
var XsollaPaywallConfig = import_zod223.z.object({
  device: import_zod223.z.enum(["DESKTOP", "MOBILE"]),
  showCloseButton: import_zod223.z.boolean(),
  size: import_zod223.z.enum(["LARGE", "MEDIUM", "SMALL"]),
  theme: import_zod223.z.enum(["DARK", "DEFAULT", "DEFAULT_DARK"])
});

// src/generated-definitions/PaymentMerchantConfigInfo.ts
var PaymentMerchantConfigInfo = import_zod224.z.object({
  adyenConfig: AdyenConfig.nullish(),
  adyenSandboxConfig: AdyenConfig.nullish(),
  aliPayConfig: AliPayConfig.nullish(),
  aliPaySandboxConfig: AliPayConfig.nullish(),
  checkoutConfig: CheckoutConfig.nullish(),
  checkoutSandboxConfig: CheckoutConfig.nullish(),
  createdAt: import_zod224.z.string(),
  id: import_zod224.z.string(),
  neonPayConfig: NeonPayConfig.nullish(),
  neonPaySandboxConfig: NeonPayConfig.nullish(),
  payPalConfig: PayPalConfig.nullish(),
  payPalSandboxConfig: PayPalConfig.nullish(),
  stripeConfig: StripeConfig.nullish(),
  stripeSandboxConfig: StripeConfig.nullish(),
  updatedAt: import_zod224.z.string(),
  wxPayConfig: WxPayConfigInfo.nullish(),
  xsollaConfig: XsollaConfig.nullish(),
  xsollaPaywallConfig: XsollaPaywallConfig.nullish()
});

// src/generated-definitions/PaymentProviderConfigInfo.ts
var import_zod225 = require("zod");
var PaymentProviderConfigInfo = import_zod225.z.object({
  aggregate: import_zod225.z.enum(["ADYEN", "CHECKOUT", "NEONPAY", "STRIPE", "XSOLLA"]).nullish(),
  id: import_zod225.z.string(),
  namespace: import_zod225.z.string(),
  paymentMerchantConfigId: import_zod225.z.string().nullish(),
  region: import_zod225.z.string(),
  sandboxTaxJarApiToken: import_zod225.z.string().nullish(),
  specials: import_zod225.z.array(import_zod225.z.enum(["ADYEN", "ALIPAY", "CHECKOUT", "NEONPAY", "PAYPAL", "STRIPE", "WALLET", "WXPAY", "XSOLLA"])).nullish(),
  taxJarApiToken: import_zod225.z.string().nullish(),
  taxJarEnabled: import_zod225.z.boolean().nullish(),
  useGlobalTaxJarApiToken: import_zod225.z.boolean().nullish()
});

// src/generated-definitions/PaymentProviderConfigPagingSlicedResult.ts
var import_zod226 = require("zod");
var PaymentProviderConfigPagingSlicedResult = import_zod226.z.object({ data: import_zod226.z.array(PaymentProviderConfigInfo), paging: Paging.nullish() });

// src/generated-definitions/PaymentTaxConfigInfo.ts
var import_zod227 = require("zod");
var PaymentTaxConfigInfo = import_zod227.z.object({
  sandboxTaxJarApiToken: import_zod227.z.string().nullish(),
  taxJarApiToken: import_zod227.z.string().nullish(),
  taxJarEnabled: import_zod227.z.boolean().nullish(),
  taxJarProductCodesMapping: import_zod227.z.record(import_zod227.z.string()).nullish()
});

// src/generated-admin/endpoints/PaymentConfigAdmin$.ts
var PaymentConfigAdmin$ = class {
  // @ts-ignore
  // prettier-ignore
  constructor(axiosInstance, namespace, useSchemaValidation = true) {
    this.axiosInstance = axiosInstance;
    this.namespace = namespace;
    this.useSchemaValidation = useSchemaValidation;
  }
  /**
   * &lt;b&gt;[Not supported yet in AGS Shared Cloud]&lt;/b&gt;Get payment global tax config.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: payment provider list&lt;/li&gt;&lt;/ul&gt;
   */
  getPaymentConfigTax() {
    const params = {};
    const url = "/platform/admin/payment/config/tax";
    const resultPromise = this.axiosInstance.get(url, { params });
    return import_sdk30.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, PaymentTaxConfigInfo, "PaymentTaxConfigInfo");
  }
  /**
   * &lt;b&gt;[Not supported yet in AGS Shared Cloud]&lt;/b&gt;Update payment tax config.&lt;br&gt;&lt;pre&gt;&lt;p&gt;&lt;strong&gt;Request Body Parameters:&lt;/strong&gt;&lt;/p&gt;&lt;pre&gt;&lt;table&gt;&lt;tr&gt;&lt;td&gt;Parameter&lt;/td&gt;&lt;td&gt;Type&lt;/td&gt;&lt;td&gt;Required&lt;/td&gt;&lt;td&gt;Description&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;taxJarEnabled&lt;/td&gt;&lt;td&gt;Boolean&lt;/td&gt;&lt;td&gt;false&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;taxJarApiToken&lt;/td&gt;&lt;td&gt;String&lt;/td&gt;&lt;td&gt;false&lt;/td&gt;&lt;td&gt;required, when taxJarEnabled is true and there is no existing token&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;sandboxTaxJarApiToken&lt;/td&gt;&lt;td&gt;String&lt;/td&gt;&lt;td&gt;false&lt;/td&gt;&lt;td&gt;optional&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;taxJarProductCodesMapping&lt;/td&gt;&lt;td&gt;Map&lt;/td&gt;&lt;td&gt;No&lt;/td&gt;&lt;td&gt;key is item type(APP|COINS|INGAMEITEM|BUNDLE|CODE|SUBSCRIPTION) and value is product tax code: https://developers.taxjar.com/api/reference/?ruby#get-list-tax-categories&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/pre&gt;&lt;/ol&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: payment global tax config&lt;/li&gt;&lt;/ul&gt;
   */
  updatePaymentConfigTax(data) {
    const params = {};
    const url = "/platform/admin/payment/config/tax";
    const resultPromise = this.axiosInstance.put(url, data, { params });
    return import_sdk30.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, PaymentTaxConfigInfo, "PaymentTaxConfigInfo");
  }
  /**
   * &lt;b&gt;[Not supported yet in AGS Shared Cloud]&lt;/b&gt;Query payment provider config.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: payment provider config list&lt;/li&gt;&lt;/ul&gt;
   */
  getPaymentConfigProvider(queryParams) {
    const params = { limit: 20, ...queryParams };
    const url = "/platform/admin/payment/config/provider";
    const resultPromise = this.axiosInstance.get(url, { params });
    return import_sdk30.Validate.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      PaymentProviderConfigPagingSlicedResult,
      "PaymentProviderConfigPagingSlicedResult"
    );
  }
  /**
   * &lt;b&gt;[Not supported yet in AGS Shared Cloud]&lt;/b&gt;Create payment provider config.&lt;br&gt;&lt;pre&gt;&lt;p&gt;&lt;strong&gt;Request Body Parameters:&lt;/strong&gt;&lt;/p&gt;&lt;pre&gt;&lt;table&gt;&lt;tr&gt;&lt;td&gt;Parameter&lt;/td&gt;&lt;td&gt;Type&lt;/td&gt;&lt;td&gt;Required&lt;/td&gt;&lt;td&gt;Description&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;namespace&lt;/td&gt;&lt;td&gt;String&lt;/td&gt;&lt;td&gt;Yes&lt;/td&gt;&lt;td&gt;namespace, * indicates all namespace&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;region&lt;/td&gt;&lt;td&gt;String&lt;/td&gt;&lt;td&gt;Yes&lt;/td&gt;&lt;td&gt;region, * indicates all regions&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;aggregate&lt;/td&gt;&lt;td&gt;String&lt;/td&gt;&lt;td&gt;No&lt;/td&gt;&lt;td&gt;aggregate payment provider, such as XSOLLA, ADYEN, STRIPE&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;specials&lt;/td&gt;&lt;td&gt;List&lt;/td&gt;&lt;td&gt;No&lt;/td&gt;&lt;td&gt;special payment provider, such as ALIPAY, WXPAY&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/pre&gt;payment provider applied has priority: &lt;ol&gt;&lt;li&gt;namespace and region match&lt;/li&gt;&lt;li&gt;namespace matches and region is *&lt;/li&gt;&lt;li&gt;region matches and namespace is *&lt;/li&gt;&lt;li&gt;namespace and region are *&lt;/li&gt;&lt;/ol&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: payment provider config&lt;/li&gt;&lt;/ul&gt;
   */
  createPaymentConfigProvider(data) {
    const params = {};
    const url = "/platform/admin/payment/config/provider";
    const resultPromise = this.axiosInstance.post(url, data, { params });
    return import_sdk30.Validate.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      PaymentProviderConfigInfo,
      "PaymentProviderConfigInfo"
    );
  }
  /**
   * &lt;b&gt;[Not supported yet in AGS Shared Cloud]&lt;/b&gt;Get payment merchant config by id.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: payment merchant config info&lt;/li&gt;&lt;/ul&gt;
   */
  getPaymentConfigMerchant_ById(id) {
    const params = {};
    const url = "/platform/admin/payment/config/merchant/{id}".replace("{id}", id);
    const resultPromise = this.axiosInstance.get(url, { params });
    return import_sdk30.Validate.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      PaymentMerchantConfigInfo,
      "PaymentMerchantConfigInfo"
    );
  }
  /**
   * &lt;b&gt;[Not supported yet in AGS Shared Cloud]&lt;/b&gt;Delete payment provider config.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: payment provider config&lt;/li&gt;&lt;/ul&gt;
   */
  deletePaymentConfigProvider_ById(id) {
    const params = {};
    const url = "/platform/admin/payment/config/provider/{id}".replace("{id}", id);
    const resultPromise = this.axiosInstance.delete(url, { params });
    return import_sdk30.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, import_zod228.z.unknown(), "z.unknown()");
  }
  /**
   * &lt;b&gt;[Not supported yet in AGS Shared Cloud]&lt;/b&gt;Update payment provider config.&lt;br&gt;&lt;pre&gt;&lt;p&gt;&lt;strong&gt;Request Body Parameters:&lt;/strong&gt;&lt;/p&gt;&lt;pre&gt;&lt;table&gt;&lt;tr&gt;&lt;td&gt;Parameter&lt;/td&gt;&lt;td&gt;Type&lt;/td&gt;&lt;td&gt;Required&lt;/td&gt;&lt;td&gt;Description&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;namespace&lt;/td&gt;&lt;td&gt;String&lt;/td&gt;&lt;td&gt;Yes&lt;/td&gt;&lt;td&gt;namespace, * indicates all namespace&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;region&lt;/td&gt;&lt;td&gt;String&lt;/td&gt;&lt;td&gt;Yes&lt;/td&gt;&lt;td&gt;region, * indicates all regions&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;aggregate&lt;/td&gt;&lt;td&gt;String&lt;/td&gt;&lt;td&gt;No&lt;/td&gt;&lt;td&gt;aggregate payment provider, such as XSOLLA, ADYEN, STRIPE&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;specials&lt;/td&gt;&lt;td&gt;List&lt;/td&gt;&lt;td&gt;No&lt;/td&gt;&lt;td&gt;special payment provider, such as ALIPAY, WXPAY&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/pre&gt;payment provider applied has priority: &lt;ol&gt;&lt;li&gt;namespace and region match&lt;/li&gt;&lt;li&gt;namespace matches and region is *&lt;/li&gt;&lt;li&gt;region matches and namespace is *&lt;/li&gt;&lt;li&gt;namespace and region are *&lt;/li&gt;&lt;/ol&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: payment provider config&lt;/li&gt;&lt;/ul&gt;
   */
  updatePaymentConfigProvider_ById(id, data) {
    const params = {};
    const url = "/platform/admin/payment/config/provider/{id}".replace("{id}", id);
    const resultPromise = this.axiosInstance.put(url, data, { params });
    return import_sdk30.Validate.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      PaymentProviderConfigInfo,
      "PaymentProviderConfigInfo"
    );
  }
  /**
   * &lt;b&gt;[Not supported yet in AGS Shared Cloud]&lt;/b&gt;Debug matched payment merchant config.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: payment merchant config info&lt;/li&gt;&lt;/ul&gt;
   */
  getPaymentConfigMerchantMatched(queryParams) {
    const params = { namespace: "*", region: "*", ...queryParams };
    const url = "/platform/admin/payment/config/merchant/matched";
    const resultPromise = this.axiosInstance.get(url, { params });
    return import_sdk30.Validate.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      PaymentMerchantConfigInfo,
      "PaymentMerchantConfigInfo"
    );
  }
  /**
   * &lt;b&gt;[Not supported yet in AGS Shared Cloud]&lt;/b&gt;Debug matched payment provider config.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: payment provider config&lt;/li&gt;&lt;/ul&gt;
   */
  getPaymentConfigProviderMatched(queryParams) {
    const params = { namespace: "*", region: "*", ...queryParams };
    const url = "/platform/admin/payment/config/provider/matched";
    const resultPromise = this.axiosInstance.get(url, { params });
    return import_sdk30.Validate.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      PaymentProviderConfigInfo,
      "PaymentProviderConfigInfo"
    );
  }
  /**
   * &lt;b&gt;[Not supported yet in AGS Shared Cloud]&lt;/b&gt;Get special payment providers, such as ALIPAY, WXPAY.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: payment provider list&lt;/li&gt;&lt;/ul&gt;
   */
  getPaymentConfigProviderSpecial() {
    const params = {};
    const url = "/platform/admin/payment/config/provider/special";
    const resultPromise = this.axiosInstance.get(url, { params });
    return import_sdk30.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, import_zod228.z.unknown(), "z.unknown()");
  }
  /**
   * &lt;b&gt;[Not supported yet in AGS Shared Cloud]&lt;/b&gt;Get aggregate payment providers, such as XSOLLA, ADYEN.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: payment provider list&lt;/li&gt;&lt;/ul&gt;
   */
  getPaymentConfigProviderAggregate() {
    const params = {};
    const url = "/platform/admin/payment/config/provider/aggregate";
    const resultPromise = this.axiosInstance.get(url, { params });
    return import_sdk30.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, import_zod228.z.unknown(), "z.unknown()");
  }
  /**
   * &lt;b&gt;[Not supported yet in AGS Shared Cloud]&lt;/b&gt;Update adyen config.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: updated payment merchant config&lt;/li&gt;&lt;/ul&gt;
   */
  updateAdyenconfigPayment_ById(id, data, queryParams) {
    const params = { sandbox: true, ...queryParams };
    const url = "/platform/admin/payment/config/merchant/{id}/adyenconfig".replace("{id}", id);
    const resultPromise = this.axiosInstance.put(url, data, { params });
    return import_sdk30.Validate.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      PaymentMerchantConfigInfo,
      "PaymentMerchantConfigInfo"
    );
  }
  /**
   * &lt;b&gt;[Not supported yet in AGS Shared Cloud]&lt;/b&gt;Update wxpay configuration.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: updated payment merchant config&lt;/li&gt;&lt;/ul&gt;
   */
  updateWxpayconfigPayment_ById(id, data, queryParams) {
    const params = { ...queryParams };
    const url = "/platform/admin/payment/config/merchant/{id}/wxpayconfig".replace("{id}", id);
    const resultPromise = this.axiosInstance.put(url, data, { params });
    return import_sdk30.Validate.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      PaymentMerchantConfigInfo,
      "PaymentMerchantConfigInfo"
    );
  }
  /**
   * &lt;b&gt;[Not supported yet in AGS Shared Cloud]&lt;/b&gt;Test adyen configuration. &lt;h4&gt;Check List:&lt;/h4&gt; &lt;ul&gt;&lt;li&gt;apiKey&lt;/li&gt;&lt;li&gt;merchantAccount&lt;/li&gt;&lt;/ul&gt;&lt;h4&gt;Non-check list:&lt;/h4&gt;&lt;ul&gt;&lt;li&gt;notificationHmacKey&lt;/li&gt;&lt;li&gt;notificationUsername&lt;/li&gt;&lt;li&gt;notificationPassword&lt;/li&gt;&lt;li&gt;liveEndpointUrlPrefix&lt;/li&gt;&lt;li&gt;allowedPaymentMethods&lt;/li&gt;&lt;li&gt;blockedPaymentMethods&lt;/li&gt;&lt;li&gt;settings&lt;/li&gt;&lt;/ul&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: test adyen config&lt;/li&gt;&lt;/ul&gt;
   */
  createPaymentConfigMerchantAdyenconfigTest(data, queryParams) {
    const params = { sandbox: true, ...queryParams };
    const url = "/platform/admin/payment/config/merchant/adyenconfig/test";
    const resultPromise = this.axiosInstance.post(url, data, { params });
    return import_sdk30.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, TestResult, "TestResult");
  }
  /**
   * &lt;b&gt;[Not supported yet in AGS Shared Cloud]&lt;/b&gt;Test WxPay configuration. Reference: &lt;a href=&#34;https://pay.weixin.qq.com/wiki/doc/api/native.php?chapter=9_1&#34;&gt;WxPay Document&lt;/a&gt;.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: test WxPay config&lt;/li&gt;&lt;/ul&gt;
   */
  createPaymentConfigMerchantWxpayconfigTest(data) {
    const params = {};
    const url = "/platform/admin/payment/config/merchant/wxpayconfig/test";
    const resultPromise = this.axiosInstance.post(url, data, { params });
    return import_sdk30.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, TestResult, "TestResult");
  }
  /**
   * &lt;b&gt;[Not supported yet in AGS Shared Cloud]&lt;/b&gt;Update alipay configuration.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: updated payment merchant config&lt;/li&gt;&lt;/ul&gt;
   */
  updateAlipayconfigPayment_ById(id, data, queryParams) {
    const params = { sandbox: true, ...queryParams };
    const url = "/platform/admin/payment/config/merchant/{id}/alipayconfig".replace("{id}", id);
    const resultPromise = this.axiosInstance.put(url, data, { params });
    return import_sdk30.Validate.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      PaymentMerchantConfigInfo,
      "PaymentMerchantConfigInfo"
    );
  }
  /**
   * &lt;b&gt;[Not supported yet in AGS Shared Cloud]&lt;/b&gt;Update PayPal config.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: updated payment merchant config&lt;/li&gt;&lt;/ul&gt;
   */
  updatePaypalconfigPayment_ById(id, data, queryParams) {
    const params = { sandbox: true, ...queryParams };
    const url = "/platform/admin/payment/config/merchant/{id}/paypalconfig".replace("{id}", id);
    const resultPromise = this.axiosInstance.put(url, data, { params });
    return import_sdk30.Validate.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      PaymentMerchantConfigInfo,
      "PaymentMerchantConfigInfo"
    );
  }
  /**
   * &lt;b&gt;[Not supported yet in AGS Shared Cloud]&lt;/b&gt;Update stripe config.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: updated payment merchant config&lt;/li&gt;&lt;/ul&gt;
   */
  updateStripeconfigPayment_ById(id, data, queryParams) {
    const params = { sandbox: true, ...queryParams };
    const url = "/platform/admin/payment/config/merchant/{id}/stripeconfig".replace("{id}", id);
    const resultPromise = this.axiosInstance.put(url, data, { params });
    return import_sdk30.Validate.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      PaymentMerchantConfigInfo,
      "PaymentMerchantConfigInfo"
    );
  }
  /**
   * &lt;b&gt;[Not supported yet in AGS Shared Cloud]&lt;/b&gt;Update xsolla configuration. Reference: &lt;a href=&#34;https://developers.xsolla.com/?#simple-checkout&#34;&gt;Xsolla Document&lt;/a&gt;.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: updated payment merchant config&lt;/li&gt;&lt;/ul&gt;
   */
  updateXsollaconfigPayment_ById(id, data, queryParams) {
    const params = { ...queryParams };
    const url = "/platform/admin/payment/config/merchant/{id}/xsollaconfig".replace("{id}", id);
    const resultPromise = this.axiosInstance.put(url, data, { params });
    return import_sdk30.Validate.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      PaymentMerchantConfigInfo,
      "PaymentMerchantConfigInfo"
    );
  }
  /**
   * &lt;b&gt;[Not supported yet in AGS Shared Cloud]&lt;/b&gt;Test AliPay configuration.Reference: &lt;a href=&#34;https://docs.open.alipay.com/270/alipay.trade.page.pay&#34;&gt;Alipay Document&lt;/a&gt;.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: test result&lt;/li&gt;&lt;/ul&gt;
   */
  createPaymentConfigMerchantAlipayconfigTest(data, queryParams) {
    const params = { sandbox: true, ...queryParams };
    const url = "/platform/admin/payment/config/merchant/alipayconfig/test";
    const resultPromise = this.axiosInstance.post(url, data, { params });
    return import_sdk30.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, TestResult, "TestResult");
  }
  /**
   * &lt;b&gt;[Not supported yet in AGS Shared Cloud]&lt;/b&gt;Test PayPal configuration. &lt;h4&gt;Check List:&lt;/h4&gt; &lt;ul&gt;&lt;li&gt;clientID&lt;/li&gt;&lt;li&gt;clientSecret&lt;/li&gt;&lt;/ul&gt;&lt;h4&gt;Non-check list:&lt;/h4&gt;&lt;ul&gt;&lt;li&gt;webHookId&lt;/li&gt;&lt;/ul&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: test result&lt;/li&gt;&lt;/ul&gt;
   */
  createPaymentConfigMerchantPaypalconfigTest(data, queryParams) {
    const params = { sandbox: true, ...queryParams };
    const url = "/platform/admin/payment/config/merchant/paypalconfig/test";
    const resultPromise = this.axiosInstance.post(url, data, { params });
    return import_sdk30.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, TestResult, "TestResult");
  }
  /**
   * &lt;b&gt;[Not supported yet in AGS Shared Cloud]&lt;/b&gt;Test stripe configuration. &lt;h4&gt;Check List:&lt;/h4&gt; &lt;ul&gt;&lt;li&gt;secretKey&lt;/li&gt;&lt;li&gt;allowedPaymentMethodTypes&lt;/li&gt;&lt;/ul&gt;&lt;h4&gt;Non-check list:&lt;/h4&gt;&lt;ul&gt;&lt;li&gt;publishableKey&lt;/li&gt;&lt;li&gt;webhookSecret&lt;/li&gt;&lt;/ul&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: test adyen config&lt;/li&gt;&lt;/ul&gt;
   */
  createPaymentConfigMerchantStripeconfigTest(data, queryParams) {
    const params = { sandbox: true, ...queryParams };
    const url = "/platform/admin/payment/config/merchant/stripeconfig/test";
    const resultPromise = this.axiosInstance.post(url, data, { params });
    return import_sdk30.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, TestResult, "TestResult");
  }
  /**
   * &lt;b&gt;[Not supported yet in AGS Shared Cloud]&lt;/b&gt;Check xsolla configuration, Reference: &lt;a href=&#34;https://developers.xsolla.com/?#simple-checkout&#34;&gt;Xsolla Document&lt;/a&gt;.&lt;h4&gt;Check List:&lt;/h4&gt; &lt;ul&gt;&lt;li&gt;merchantId&lt;/li&gt;&lt;li&gt;projectId&lt;/li&gt;&lt;li&gt;apiKey&lt;/li&gt;&lt;/ul&gt;&lt;h4&gt;Non-check list:&lt;/h4&gt;&lt;ul&gt;&lt;li&gt;projectSecretKey&lt;/li&gt;&lt;/ul&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: test result&lt;/li&gt;&lt;/ul&gt;
   */
  createPaymentConfigMerchantXsollaconfigTest(data) {
    const params = {};
    const url = "/platform/admin/payment/config/merchant/xsollaconfig/test";
    const resultPromise = this.axiosInstance.post(url, data, { params });
    return import_sdk30.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, TestResult, "TestResult");
  }
  /**
   * &lt;b&gt;[Not supported yet in AGS Shared Cloud]&lt;/b&gt;Update Neon Pay config.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: updated payment merchant config&lt;/li&gt;&lt;/ul&gt;
   */
  updateNeonpayconfigPayment_ById(id, data, queryParams) {
    const params = { sandbox: true, ...queryParams };
    const url = "/platform/admin/payment/config/merchant/{id}/neonpayconfig".replace("{id}", id);
    const resultPromise = this.axiosInstance.put(url, data, { params });
    return import_sdk30.Validate.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      PaymentMerchantConfigInfo,
      "PaymentMerchantConfigInfo"
    );
  }
  /**
   * &lt;b&gt;[Not supported yet in AGS Shared Cloud]&lt;/b&gt;Check Neon Pay configuration, Reference: &lt;a href=&#34;https://docs.neonpay.com/docs/checkout&#34;&gt;Neon Pay Document&lt;/a&gt;.&lt;h4&gt;Check List:&lt;/h4&gt; &lt;ul&gt;&lt;li&gt;apiKey&lt;/li&gt;&lt;li&gt;webhookSecretKey&lt;/li&gt;&lt;/ul&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: test result&lt;/li&gt;&lt;/ul&gt;
   */
  createPaymentConfigMerchantNeonpayconfigTest(data, queryParams) {
    const params = { sandbox: true, ...queryParams };
    const url = "/platform/admin/payment/config/merchant/neonpayconfig/test";
    const resultPromise = this.axiosInstance.post(url, data, { params });
    return import_sdk30.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, TestResult, "TestResult");
  }
  /**
   * &lt;b&gt;[Not supported yet in AGS Shared Cloud]&lt;/b&gt;Update checkout.com config.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: updated payment merchant config&lt;/li&gt;&lt;/ul&gt;
   */
  updateCheckoutconfigPayment_ById(id, data, queryParams) {
    const params = { sandbox: true, ...queryParams };
    const url = "/platform/admin/payment/config/merchant/{id}/checkoutconfig".replace("{id}", id);
    const resultPromise = this.axiosInstance.put(url, data, { params });
    return import_sdk30.Validate.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      PaymentMerchantConfigInfo,
      "PaymentMerchantConfigInfo"
    );
  }
  /**
   * &lt;b&gt;[Not supported yet in AGS Shared Cloud]&lt;/b&gt;Update xsolla UI configuration.Reference: &lt;a href=&#34;https://developers.xsolla.com/api.html#ui-integrations&#34;&gt;Xsolla Document&lt;/a&gt;.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: updated payment merchant config&lt;/li&gt;&lt;/ul&gt;
   */
  updateXsollauiconfigPayment_ById(id, data) {
    const params = {};
    const url = "/platform/admin/payment/config/merchant/{id}/xsollauiconfig".replace("{id}", id);
    const resultPromise = this.axiosInstance.put(url, data, { params });
    return import_sdk30.Validate.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      PaymentMerchantConfigInfo,
      "PaymentMerchantConfigInfo"
    );
  }
  /**
   * &lt;b&gt;[Not supported yet in AGS Shared Cloud]&lt;/b&gt;Test checkout.com configuration. &lt;h4&gt;Check List:&lt;/h4&gt; &lt;ul&gt;&lt;li&gt;publicKey&lt;/li&gt;&lt;li&gt;secretKey&lt;/li&gt;&lt;/ul&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: test result&lt;/li&gt;&lt;/ul&gt;
   */
  createPaymentConfigMerchantCheckoutconfigTest(data, queryParams) {
    const params = { sandbox: true, ...queryParams };
    const url = "/platform/admin/payment/config/merchant/checkoutconfig/test";
    const resultPromise = this.axiosInstance.post(url, data, { params });
    return import_sdk30.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, TestResult, "TestResult");
  }
  /**
   * &lt;b&gt;[Not supported yet in AGS Shared Cloud]&lt;/b&gt;Get payment domain whitelist config by namespace.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: payment domain whitelist config info&lt;/li&gt;&lt;/ul&gt;
   */
  getPaymentConfigDomains() {
    const params = {};
    const url = "/platform/admin/namespaces/{namespace}/payment/config/domains".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.get(url, { params });
    return import_sdk30.Validate.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      PaymentDomainWhitelistConfigInfo,
      "PaymentDomainWhitelistConfigInfo"
    );
  }
  /**
   * &lt;b&gt;[Not supported yet in AGS Shared Cloud]&lt;/b&gt;Update payment provider config by namespace.&lt;br&gt;&lt;pre&gt;&lt;p&gt;&lt;strong&gt;Request Body Parameters:&lt;/strong&gt;&lt;/p&gt;&lt;pre&gt;&lt;table&gt;&lt;tr&gt;&lt;td&gt;Parameter&lt;/td&gt;&lt;td&gt;Type&lt;/td&gt;&lt;td&gt;Required&lt;/td&gt;&lt;td&gt;Description&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;domains&lt;/td&gt;&lt;td&gt;String&lt;/td&gt;&lt;td&gt;Yes&lt;/td&gt;&lt;td&gt;list of domains to whitelist for the return URL.&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/pre&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Validation&lt;/i&gt;: the domain should include the protocol (http/https), but the whitelist check will only compare the host part (www.example.com)&lt;/li&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: payment domain whitelist config&lt;/li&gt;&lt;/ul&gt;
   */
  updatePaymentConfigDomain(data) {
    const params = {};
    const url = "/platform/admin/namespaces/{namespace}/payment/config/domains".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.put(url, data, { params });
    return import_sdk30.Validate.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      PaymentDomainWhitelistConfigInfo,
      "PaymentDomainWhitelistConfigInfo"
    );
  }
  /**
   * &lt;b&gt;[Not supported yet in AGS Shared Cloud]&lt;/b&gt;Test adyen configuration in payment merchant config. Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: test adyen config&lt;/li&gt;&lt;/ul&gt;
   */
  getAdyenconfigTestPayment_ById(id, queryParams) {
    const params = { sandbox: true, ...queryParams };
    const url = "/platform/admin/payment/config/merchant/{id}/adyenconfig/test".replace("{id}", id);
    const resultPromise = this.axiosInstance.get(url, { params });
    return import_sdk30.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, TestResult, "TestResult");
  }
  /**
   * &lt;b&gt;[Not supported yet in AGS Shared Cloud]&lt;/b&gt;Upload wxpay cert file.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: updated payment merchant config&lt;/li&gt;&lt;/ul&gt;
   */
  updateWxpayconfigCertPayment_ById(id, data) {
    const params = {};
    const url = "/platform/admin/payment/config/merchant/{id}/wxpayconfig/cert".replace("{id}", id);
    const resultPromise = this.axiosInstance.put(url, data, { params });
    return import_sdk30.Validate.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      PaymentMerchantConfigInfo,
      "PaymentMerchantConfigInfo"
    );
  }
  /**
   * &lt;b&gt;[Not supported yet in AGS Shared Cloud]&lt;/b&gt;Test WxPay configuration in payment merchant config. Reference: &lt;a href=&#34;https://pay.weixin.qq.com/wiki/doc/api/native.php?chapter=9_1&#34;&gt;WxPay Document&lt;/a&gt;.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: test WxPay config&lt;/li&gt;&lt;/ul&gt;
   */
  getWxpayconfigTestPayment_ById(id) {
    const params = {};
    const url = "/platform/admin/payment/config/merchant/{id}/wxpayconfig/test".replace("{id}", id);
    const resultPromise = this.axiosInstance.get(url, { params });
    return import_sdk30.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, TestResult, "TestResult");
  }
  /**
   * &lt;b&gt;[Not supported yet in AGS Shared Cloud]&lt;/b&gt;Test AliPay configuration in payment merchant config. Reference: &lt;a href=&#34;https://docs.open.alipay.com/270/alipay.trade.page.pay&#34;&gt;Alipay Document&lt;/a&gt;.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: test alipay config&lt;/li&gt;&lt;/ul&gt;
   */
  getAlipayconfigTestPayment_ById(id, queryParams) {
    const params = { sandbox: true, ...queryParams };
    const url = "/platform/admin/payment/config/merchant/{id}/alipayconfig/test".replace("{id}", id);
    const resultPromise = this.axiosInstance.get(url, { params });
    return import_sdk30.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, TestResult, "TestResult");
  }
  /**
   * &lt;b&gt;[Not supported yet in AGS Shared Cloud]&lt;/b&gt;Test PayPal configuration in payment merchant config. Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: test result&lt;/li&gt;&lt;/ul&gt;
   */
  getPaypalconfigTestPayment_ById(id, queryParams) {
    const params = { sandbox: true, ...queryParams };
    const url = "/platform/admin/payment/config/merchant/{id}/paypalconfig/test".replace("{id}", id);
    const resultPromise = this.axiosInstance.get(url, { params });
    return import_sdk30.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, TestResult, "TestResult");
  }
  /**
   * &lt;b&gt;[Not supported yet in AGS Shared Cloud]&lt;/b&gt;Test stripe configuration in payment merchant config. Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: test adyen config&lt;/li&gt;&lt;/ul&gt;
   */
  getStripeconfigTestPayment_ById(id, queryParams) {
    const params = { sandbox: true, ...queryParams };
    const url = "/platform/admin/payment/config/merchant/{id}/stripeconfig/test".replace("{id}", id);
    const resultPromise = this.axiosInstance.get(url, { params });
    return import_sdk30.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, TestResult, "TestResult");
  }
  /**
   * &lt;b&gt;[Not supported yet in AGS Shared Cloud]&lt;/b&gt;Test xsolla configuration in payment merchant config. Reference: &lt;a href=&#34;https://developers.xsolla.com/?#simple-checkout&#34;&gt;Xsolla Document&lt;/a&gt;.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: test xsolla config&lt;/li&gt;&lt;/ul&gt;
   */
  getXsollaconfigTestPayment_ById(id) {
    const params = {};
    const url = "/platform/admin/payment/config/merchant/{id}/xsollaconfig/test".replace("{id}", id);
    const resultPromise = this.axiosInstance.get(url, { params });
    return import_sdk30.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, TestResult, "TestResult");
  }
  /**
   * &lt;b&gt;[Not supported yet in AGS Shared Cloud]&lt;/b&gt;Test Neon Pay configuration in payment merchant config. Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: test result&lt;/li&gt;&lt;/ul&gt;
   */
  getNeonpayconfigTestPayment_ById(id, queryParams) {
    const params = { sandbox: true, ...queryParams };
    const url = "/platform/admin/payment/config/merchant/{id}/neonpayconfig/test".replace("{id}", id);
    const resultPromise = this.axiosInstance.get(url, { params });
    return import_sdk30.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, TestResult, "TestResult");
  }
  /**
   * &lt;b&gt;[Not supported yet in AGS Shared Cloud]&lt;/b&gt;Test checkout.com configuration in payment merchant config. Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: test result&lt;/li&gt;&lt;/ul&gt;
   */
  getCheckoutconfigTestPayment_ById(id, queryParams) {
    const params = { sandbox: true, ...queryParams };
    const url = "/platform/admin/payment/config/merchant/{id}/checkoutconfig/test".replace("{id}", id);
    const resultPromise = this.axiosInstance.get(url, { params });
    return import_sdk30.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, TestResult, "TestResult");
  }
};

// src/generated-admin/endpoints/PaymentDedicatedAdmin$.ts
var import_sdk31 = require("@accelbyte/sdk");

// src/generated-definitions/PaymentOrderCreateResult.ts
var import_zod229 = require("zod");
var PaymentOrderCreateResult = import_zod229.z.object({
  createdTime: import_zod229.z.string(),
  namespace: import_zod229.z.string(),
  paymentOrderNo: import_zod229.z.string(),
  paymentStationUrl: import_zod229.z.string().nullish(),
  status: import_zod229.z.enum([
    "AUTHORISED",
    "AUTHORISE_FAILED",
    "CHARGEBACK",
    "CHARGEBACK_REVERSED",
    "CHARGED",
    "CHARGE_FAILED",
    "DELETED",
    "INIT",
    "NOTIFICATION_OF_CHARGEBACK",
    "REFUNDED",
    "REFUNDING",
    "REFUND_FAILED",
    "REQUEST_FOR_INFORMATION"
  ]),
  targetNamespace: import_zod229.z.string().nullish(),
  targetUserId: import_zod229.z.string().nullish()
});

// src/generated-definitions/PaymentOrderRefundResult.ts
var import_zod230 = require("zod");
var PaymentOrderRefundResult = import_zod230.z.object({
  createdTime: import_zod230.z.string(),
  namespace: import_zod230.z.string(),
  paymentOrderNo: import_zod230.z.string(),
  refundedTime: import_zod230.z.string().nullish(),
  status: import_zod230.z.enum([
    "AUTHORISED",
    "AUTHORISE_FAILED",
    "CHARGEBACK",
    "CHARGEBACK_REVERSED",
    "CHARGED",
    "CHARGE_FAILED",
    "DELETED",
    "INIT",
    "NOTIFICATION_OF_CHARGEBACK",
    "REFUNDED",
    "REFUNDING",
    "REFUND_FAILED",
    "REQUEST_FOR_INFORMATION"
  ]),
  targetNamespace: import_zod230.z.string().nullish(),
  targetUserId: import_zod230.z.string().nullish()
});

// src/generated-definitions/PaymentOrderSyncResult.ts
var import_zod233 = require("zod");

// src/generated-definitions/PaymentOrder.ts
var import_zod232 = require("zod");

// src/generated-definitions/PaymentOrderNeonPayConfig.ts
var import_zod231 = require("zod");
var PaymentOrderNeonPayConfig = import_zod231.z.object({ cancelUrl: import_zod231.z.string(), successUrl: import_zod231.z.string() });

// src/generated-definitions/PaymentOrder.ts
var PaymentOrder = import_zod232.z.object({
  authorisedTime: import_zod232.z.string().nullish(),
  channel: import_zod232.z.enum(["EXTERNAL", "INTERNAL"]).nullish(),
  chargebackReversedTime: import_zod232.z.string().nullish(),
  chargebackTime: import_zod232.z.string().nullish(),
  chargedTime: import_zod232.z.string().nullish(),
  charging: import_zod232.z.boolean().nullish(),
  checkoutUrl: import_zod232.z.string().nullish(),
  checkoutUrlExpiredAt: import_zod232.z.string().nullish(),
  checkoutUrlValid: import_zod232.z.boolean().nullish(),
  createdAt: import_zod232.z.string().nullish(),
  createdTime: import_zod232.z.string().nullish(),
  currency: CurrencySummary.nullish(),
  customParameters: import_zod232.z.record(import_zod232.z.any()).nullish(),
  description: import_zod232.z.string().nullish(),
  extOrderNo: import_zod232.z.string().nullish(),
  extUserId: import_zod232.z.string().nullish(),
  itemType: import_zod232.z.enum(["APP", "BUNDLE", "CODE", "COINS", "EXTENSION", "INGAMEITEM", "LOOTBOX", "MEDIA", "OPTIONBOX", "SEASON", "SUBSCRIPTION"]).nullish(),
  language: import_zod232.z.string().nullish(),
  metadata: import_zod232.z.record(import_zod232.z.string()).nullish(),
  namespace: import_zod232.z.string().nullish(),
  neonPayConfig: PaymentOrderNeonPayConfig.nullish(),
  notifyUrl: import_zod232.z.string().nullish(),
  omitNotification: import_zod232.z.boolean().nullish(),
  paymentData: PaymentData.nullish(),
  paymentMethod: import_zod232.z.string().nullish(),
  paymentMethodFee: import_zod232.z.number().int().nullish(),
  paymentOrderNo: import_zod232.z.string().nullish(),
  paymentProvider: import_zod232.z.enum(["ADYEN", "ALIPAY", "CHECKOUT", "NEONPAY", "PAYPAL", "STRIPE", "WALLET", "WXPAY", "XSOLLA"]).nullish(),
  paymentProviderFee: import_zod232.z.number().int().nullish(),
  paymentStationUrl: import_zod232.z.string().nullish(),
  platform: import_zod232.z.string().nullish(),
  price: import_zod232.z.number().int().nullish(),
  recurringPaymentOrderNo: import_zod232.z.string().nullish(),
  refundedTime: import_zod232.z.string().nullish(),
  region: import_zod232.z.string().nullish(),
  returnUrl: import_zod232.z.string().nullish(),
  rvn: import_zod232.z.number().int().nullish(),
  salesTax: import_zod232.z.number().int().nullish(),
  sandbox: import_zod232.z.boolean().nullish(),
  sku: import_zod232.z.string().nullish(),
  state: import_zod232.z.string().nullish(),
  status: import_zod232.z.enum([
    "AUTHORISED",
    "AUTHORISE_FAILED",
    "CHARGEBACK",
    "CHARGEBACK_REVERSED",
    "CHARGED",
    "CHARGE_FAILED",
    "DELETED",
    "INIT",
    "NOTIFICATION_OF_CHARGEBACK",
    "REFUNDED",
    "REFUNDING",
    "REFUND_FAILED",
    "REQUEST_FOR_INFORMATION"
  ]).nullish(),
  statusReason: import_zod232.z.string().nullish(),
  subscriptionId: import_zod232.z.string().nullish(),
  subtotalPrice: import_zod232.z.number().int().nullish(),
  targetNamespace: import_zod232.z.string().nullish(),
  targetUserId: import_zod232.z.string().nullish(),
  tax: import_zod232.z.number().int().nullish(),
  title: import_zod232.z.string().nullish(),
  totalPrice: import_zod232.z.number().int().nullish(),
  totalTax: import_zod232.z.number().int().nullish(),
  transactions: import_zod232.z.array(Transaction).nullish(),
  updatedAt: import_zod232.z.string().nullish(),
  userId: import_zod232.z.string().nullish(),
  vat: import_zod232.z.number().int().nullish(),
  zipCode: import_zod232.z.string().nullish()
});

// src/generated-definitions/PaymentOrderSyncResult.ts
var PaymentOrderSyncResult = import_zod233.z.object({ nextEvaluatedKey: import_zod233.z.string().nullish(), paymentOrders: import_zod233.z.array(PaymentOrder).nullish() });

// src/generated-admin/endpoints/PaymentDedicatedAdmin$.ts
var PaymentDedicatedAdmin$ = class {
  // @ts-ignore
  // prettier-ignore
  constructor(axiosInstance, namespace, useSchemaValidation = true) {
    this.axiosInstance = axiosInstance;
    this.namespace = namespace;
    this.useSchemaValidation = useSchemaValidation;
  }
  /**
   * &lt;b&gt;[Not supported yet in AGS Shared Cloud]&lt;/b&gt;Sync payment orders. If response contains nextEvaluatedKey, please use it as query param in the next call to fetch the next batch, a batch has 1000 elements or less.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: sync payment orders&lt;/li&gt;&lt;/ul&gt;
   */
  getPaymentOrders(queryParams) {
    const params = { ...queryParams };
    const url = "/platform/admin/payment/orders";
    const resultPromise = this.axiosInstance.get(url, { params });
    return import_sdk31.Validate.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      PaymentOrderSyncResult,
      "PaymentOrderSyncResult"
    );
  }
  /**
   * &lt;b&gt;[Not supported yet in AGS Shared Cloud]&lt;/b&gt;&lt;p&gt;This API is used to create payment order from non justice service. e.g. from dedicated server, the result contains the payment station url.&lt;/p&gt;&lt;p&gt;&lt;strong&gt;Path Parameter:&lt;/strong&gt;&lt;/p&gt;&lt;pre&gt;&lt;table&gt;&lt;tr&gt;&lt;td&gt;Parameter&lt;/td&gt;&lt;td&gt;Type&lt;/td&gt;&lt;td&gt;Required&lt;/td&gt;&lt;td&gt;Description&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;namespace&lt;/td&gt;&lt;td&gt;String&lt;/td&gt;&lt;td&gt;Yes&lt;/td&gt;&lt;td&gt;Namespace that payment order resides in, should be publisher namespace if it&#39;s a Steam like platform that share &lt;br&gt;payment config cross namespaces, otherwise it&#39;s the game namespace&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;p&gt;&lt;strong&gt;Request Body Parameters:&lt;/strong&gt;&lt;/p&gt;&lt;pre&gt;&lt;table&gt;&lt;tr&gt;&lt;td&gt;Parameter&lt;/td&gt;&lt;td&gt;Type&lt;/td&gt;&lt;td&gt;Required&lt;/td&gt;&lt;td&gt;Description&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;extOrderNo&lt;/td&gt;&lt;td&gt;String&lt;/td&gt;&lt;td&gt;Yes&lt;/td&gt;&lt;td&gt;External order number, it should be unique in invoker order system&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;sku&lt;/td&gt;&lt;td&gt;String&lt;/td&gt;&lt;td&gt;No&lt;/td&gt;&lt;td&gt;Item identity&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;targetNamespace&lt;/td&gt;&lt;td&gt;String&lt;/td&gt;&lt;td&gt;Yes&lt;/td&gt;&lt;td&gt;The game namespace&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;targetUserId&lt;/td&gt;&lt;td&gt;String&lt;/td&gt;&lt;td&gt;Yes&lt;/td&gt;&lt;td&gt;User id for the order owner in game namespace&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;extUserId&lt;/td&gt;&lt;td&gt;String&lt;/td&gt;&lt;td&gt;No&lt;/td&gt;&lt;td&gt;External user id, can be user character id &lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;price&lt;/td&gt;&lt;td&gt;int&lt;/td&gt;&lt;td&gt;Yes&lt;/td&gt;&lt;td&gt;price which should be greater than 0&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;title&lt;/td&gt;&lt;td&gt;String&lt;/td&gt;&lt;td&gt;Yes&lt;/td&gt;&lt;td&gt;Item title&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;description&lt;/td&gt;&lt;td&gt;String&lt;/td&gt;&lt;td&gt;Yes&lt;/td&gt;&lt;td&gt;Item description&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;currencyCode&lt;/td&gt;&lt;td&gt;String&lt;/td&gt;&lt;td&gt;No&lt;/td&gt;&lt;td&gt;Currency code, default is USD&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;currencyNamespace&lt;/td&gt;&lt;td&gt;String&lt;/td&gt;&lt;td&gt;No&lt;/td&gt;&lt;td&gt;Currency namespace, default is publisher namespace&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;region&lt;/td&gt;&lt;td&gt;String&lt;/td&gt;&lt;td&gt;No&lt;/td&gt;&lt;td&gt;Country of the user, will get from user info if not present&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;language&lt;/td&gt;&lt;td&gt;String&lt;/td&gt;&lt;td&gt;No&lt;/td&gt;&lt;td&gt;Language of the user&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;sandbox&lt;/td&gt;&lt;td&gt;Boolean&lt;/td&gt;&lt;td&gt;No&lt;/td&gt;&lt;td&gt;set to true will create sandbox order that not real paid for xsolla/alipay and will not validate &lt;br&gt;price for wxpay.&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;returnUrl&lt;/td&gt;&lt;td&gt;String&lt;/td&gt;&lt;td&gt;No&lt;/td&gt;&lt;td&gt;customized return url for redirect once payment finished, leave unset to use configuration in &lt;br&gt;namespace&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;notifyUrl&lt;/td&gt;&lt;td&gt;String&lt;/td&gt;&lt;td&gt;No&lt;/td&gt;&lt;td&gt;customized notify url for payment web hook, leave unset to use configuration in namespace&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;customParameters&lt;/td&gt;&lt;td&gt;String&lt;/td&gt;&lt;td&gt;No&lt;/td&gt;&lt;td&gt;Custom parameters&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;Request Body Example:&lt;/strong&gt;&lt;/p&gt;&lt;pre&gt;&lt;code style=&#39;overflow: auto&#39;&gt;{ &#34;extOrderNo&#34;: &#34;123456789&#34;, &#34;sku&#34;: &#34;sku&#34;, &#34;targetNamespace&#34;: &#34;game1&#34;, &#34;targetUserId&#34;: &#34;94451623768940d58416ca33ca767ec3&#34;, &#34;extUserId&#34;: &#34;678&#34;, &#34;title&#34;: &#34;Frostmourne&#34;, &#34;description\&#34;: &#34;Here was power. Here was despair&#34;, &#34;price&#34;: 100, &#34;region&#34;: &#34;CN&#34;, &#34;language&#34;: &#34;zh-CN&#34;, &#34;currencyCode&#34;: &#34;USD&#34;, &#34;currencyNamespace&#34;: &#34;accelbyte&#34; }&lt;/pre&gt;&lt;/code&gt;&lt;h4&gt;Payment Notification:&lt;/h4&gt;&lt;p&gt;After user complete the payment, it will send notification to configured web hook, http status code should return 200 or 204 once you resolve notification successfully, otherwise payment system will retry notification in interval&lt;/p&gt;&lt;p&gt;&lt;strong&gt;Payment notification parameter:&lt;/strong&gt;&lt;/p&gt;&lt;pre&gt;&lt;table&gt;&lt;tr&gt;&lt;td&gt;Parameter&lt;/td&gt;&lt;td&gt;Type&lt;/td&gt;&lt;td&gt;Required&lt;/td&gt;&lt;td&gt;Description&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;payload&lt;/td&gt;&lt;td&gt;String&lt;/td&gt;&lt;td&gt;Yes&lt;/td&gt;&lt;td&gt;Payment notification payload in json string &lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;sign&lt;/td&gt;&lt;td&gt;String&lt;/td&gt;&lt;td&gt;Yes&lt;/td&gt;&lt;td&gt;sha1 hex signature for payload and private key&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;Payment notification parameter Example:&lt;/strong&gt;&lt;/p&gt;&lt;pre&gt;&lt;code style=&#39;overflow: auto&#39;&gt;{ &#34;payload&#34;: &#34;{ \&#34;type\&#34;: \&#34;payment\&#34;, \&#34;nonceStr\&#34;: \&#34;34c1dcf3eb58455eb161465bbfc0b590\&#34;, \&#34;paymentOrderNo\&#34;: \&#34;18081239088\&#34;, \&#34;namespace\&#34;: \&#34;accelbyte\&#34;, \&#34;targetNamespace\&#34;: \&#34;game1\&#34;, \&#34;targetUserId\&#34;: \&#34;94451623768940d58416ca33ca767ec3\&#34;, \&#34;extOrderNo\&#34;: \&#34;123456789\&#34;, \&#34;sku\&#34;: \&#34;sku\&#34;, \&#34;extUserId\&#34;: \&#34;678\&#34;, \&#34;price\&#34;: 100, \&#34;paymentProvider\&#34;: \&#34;XSOLLA\&#34;, \&#34;vat\&#34;: 0, \&#34;salesTax\&#34;: 0, \&#34;paymentProviderFee\&#34;: 0, \&#34;paymentMethodFee\&#34;: 0, \&#34;currency\&#34;: { \&#34;currencyCode\&#34;: \&#34;USD\&#34;, \&#34;currencySymbol\&#34;: \&#34;$\&#34;, \&#34;currencyType\&#34;: \&#34;REAL\&#34;, \&#34;namespace\&#34;: \&#34;accelbyte\&#34;, \&#34;decimals\&#34;: 2 }, \&#34;status\&#34;: \&#34;CHARGED\&#34;, \&#34;createdTime\&#34;: \&#34;2018-07-28T00:39:16.274Z\&#34;, \&#34;chargedTime\&#34;: \&#34;2018-07-28T00:39:16.274Z\&#34; }&#34;, &#34;sign&#34;:&#34;e31fb92516cc9faaf50ad70343e1293acec6f3d5&#34; }&lt;/pre&gt;&lt;/code&gt;&lt;p&gt;&lt;strong&gt;Payment notification payload parameter list:&lt;/strong&gt;&lt;/p&gt;&lt;pre&gt;&lt;table&gt;&lt;tr&gt;&lt;td&gt;Parameter&lt;/td&gt;&lt;td&gt;Type&lt;/td&gt;&lt;td&gt;Required&lt;/td&gt;&lt;td&gt;Description&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;type&lt;/td&gt;&lt;td&gt;String&lt;/td&gt;&lt;td&gt;Yes&lt;/td&gt;&lt;td&gt;Notification type: &#39;payment&#39;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;paymentOrderNo&lt;/td&gt;&lt;td&gt;String&lt;/td&gt;&lt;td&gt;Yes&lt;/td&gt;&lt;td&gt;Payment system generated order number&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;extOrderNo&lt;/td&gt;&lt;td&gt;String&lt;/td&gt;&lt;td&gt;No&lt;/td&gt;&lt;td&gt;External order number that passed by invoker&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;namespace&lt;/td&gt;&lt;td&gt;String&lt;/td&gt;&lt;td&gt;Yes&lt;/td&gt;&lt;td&gt;Namespace that related payment order resides in&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;targetNamespace&lt;/td&gt;&lt;td&gt;String&lt;/td&gt;&lt;td&gt;Yes&lt;/td&gt;&lt;td&gt;The game namespace&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;targetUserId&lt;/td&gt;&lt;td&gt;String&lt;/td&gt;&lt;td&gt;Yes&lt;/td&gt;&lt;td&gt;The user id in game namespace&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;sku&lt;/td&gt;&lt;td&gt;String&lt;/td&gt;&lt;td&gt;No&lt;/td&gt;&lt;td&gt;Item identify, it will return if pass it when create payment&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;extUserId&lt;/td&gt;&lt;td&gt;String&lt;/td&gt;&lt;td&gt;No&lt;/td&gt;&lt;td&gt;External user id, can be character id, it will return if pass it when create payment&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;price&lt;/td&gt;&lt;td&gt;int&lt;/td&gt;&lt;td&gt;Yes&lt;/td&gt;&lt;td&gt;Price of item&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;paymentProvider&lt;/td&gt;&lt;td&gt;String&lt;/td&gt;&lt;td&gt;Yes&lt;/td&gt;&lt;td&gt;Payment provider, allowed values: xsolla/alipay/wxpay/wallet&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;vat&lt;/td&gt;&lt;td&gt;int&lt;/td&gt;&lt;td&gt;Yes&lt;/td&gt;&lt;td&gt;Payment order VAT&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;salesTax&lt;/td&gt;&lt;td&gt;int&lt;/td&gt;&lt;td&gt;Yes&lt;/td&gt;&lt;td&gt;Payment order sales tax&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;paymentProviderFee&lt;/td&gt;&lt;td&gt;int&lt;/td&gt;&lt;td&gt;Yes&lt;/td&gt;&lt;td&gt;Payment provider fee&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;paymentMethodFee&lt;/td&gt;&lt;td&gt;int&lt;/td&gt;&lt;td&gt;Yes&lt;/td&gt;&lt;td&gt;Payment method fee&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;currency&lt;/td&gt;&lt;td&gt;Map&lt;/td&gt;&lt;td&gt;Yes&lt;/td&gt;&lt;td&gt;Payment order currency info&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;status&lt;/td&gt;&lt;td&gt;String&lt;/td&gt;&lt;td&gt;Yes&lt;/td&gt;&lt;td&gt;Payment order status&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;statusReason&lt;/td&gt;&lt;td&gt;String&lt;/td&gt;&lt;td&gt;No&lt;/td&gt;&lt;td&gt;Payment order status reason&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;createdTime&lt;/td&gt;&lt;td&gt;Datetime&lt;/td&gt;&lt;td&gt;No&lt;/td&gt;&lt;td&gt;The time of the order created&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;chargedTime&lt;/td&gt;&lt;td&gt;Datetime&lt;/td&gt;&lt;td&gt;No&lt;/td&gt;&lt;td&gt;The time of the order charged&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;customParameters&lt;/td&gt;&lt;td&gt;Map&lt;/td&gt;&lt;td&gt;No&lt;/td&gt;&lt;td&gt;custom parameters, will return if pass it when create payment&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;nonceStr&lt;/td&gt;&lt;td&gt;String&lt;/td&gt;&lt;td&gt;Yes&lt;/td&gt;&lt;td&gt;Random string, max length is 32, can be timestamp or uuid&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;Currency info parameter list:&lt;/strong&gt;&lt;/p&gt;&lt;pre&gt;&lt;table&gt;&lt;tr&gt;&lt;td&gt;Parameter&lt;/td&gt;&lt;td&gt;Type&lt;/td&gt;&lt;td&gt;Required&lt;/td&gt;&lt;td&gt;Description&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;currencyCode&lt;/td&gt;&lt;td&gt;String&lt;/td&gt;&lt;td&gt;Yes&lt;/td&gt;&lt;td&gt;Currency Code&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;currencySymbol&lt;/td&gt;&lt;td&gt;String&lt;/td&gt;&lt;td&gt;Yes&lt;/td&gt;&lt;td&gt;Currency Symbol&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;currencyType&lt;/td&gt;&lt;td&gt;String&lt;/td&gt;&lt;td&gt;Yes&lt;/td&gt;&lt;td&gt;Currency type(REAL/VIRTUAL)&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;namespace&lt;/td&gt;&lt;td&gt;String&lt;/td&gt;&lt;td&gt;Yes&lt;/td&gt;&lt;td&gt;Currency namespace&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;decimals&lt;/td&gt;&lt;td&gt;int&lt;/td&gt;&lt;td&gt;Yes&lt;/td&gt;&lt;td&gt;Currency decimals&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/pre&gt;&lt;h4&gt;Encryption Rule:&lt;/h4&gt;&lt;p&gt;Concat payload json string and private key and then do sha1Hex.&lt;/p&gt;&lt;h4&gt;Other detail info:&lt;/h4&gt; &lt;ul&gt;&lt;li&gt;&lt;i&gt;Token type&lt;/i&gt;: client token&lt;/li&gt;&lt;li&gt;&lt;i&gt;Optional permission(user with this permission will create sandbox order)&lt;/i&gt;: resource=&#34;SANDBOX&#34;, action=1 (CREATE)&lt;/li&gt;&lt;li&gt;It will be forbidden while the target user is banned: PAYMENT_INITIATE or ORDER_AND_PAYMENT&lt;/li&gt;&lt;li&gt;&lt;b&gt;cross namespace allowed&lt;/b&gt;&lt;/li&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: created payment order info&lt;/li&gt;&lt;/ul&gt;
   */
  createPaymentOrder(data) {
    const params = {};
    const url = "/platform/admin/namespaces/{namespace}/payment/orders".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.post(url, data, { params });
    return import_sdk31.Validate.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      PaymentOrderCreateResult,
      "PaymentOrderCreateResult"
    );
  }
  /**
   * &lt;b&gt;[Not supported yet in AGS Shared Cloud]&lt;/b&gt;&lt;p&gt;This API is used to refund payment order by paymentOrderNo from non justice service. e.g. dedicated server. &lt;ul&gt;&lt;li&gt;if the status field of response json is &#34;REFUNDED&#34;, usually wallet paid, it indicates payment order already refunded&lt;/li&gt;&lt;li&gt;if the status field of response json is &#34;REFUNDING&#34;, usually real money paid, platform will send notification to registered notify url once refund successfully&lt;/li&gt; &lt;/ul&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;Path Parameter:&lt;/strong&gt;&lt;/p&gt;&lt;pre&gt;&lt;table&gt;&lt;tr&gt;&lt;td&gt;Parameter&lt;/td&gt;&lt;td&gt;Type&lt;/td&gt;&lt;td&gt;Required&lt;/td&gt;&lt;td&gt;Description&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;namespace&lt;/td&gt;&lt;td&gt;String&lt;/td&gt;&lt;td&gt;Yes&lt;/td&gt;&lt;td&gt;Namespace that payment order resides in&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;paymentOrderNo&lt;/td&gt;&lt;td&gt;String&lt;/td&gt;&lt;td&gt;Yes&lt;/td&gt;&lt;td&gt;Payment order number&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;Request Body Parameters:&lt;/strong&gt;&lt;/p&gt;&lt;pre&gt;&lt;table&gt;&lt;tr&gt;&lt;td&gt;Parameter&lt;/td&gt;&lt;td&gt;Type&lt;/td&gt;&lt;td&gt;Required&lt;/td&gt;&lt;td&gt;Description&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;description&lt;/td&gt;&lt;td&gt;String&lt;/td&gt;&lt;td&gt;Yes&lt;/td&gt;&lt;td&gt;Refund description&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;Request Body Example:&lt;/strong&gt;&lt;/p&gt;&lt;pre&gt;&lt;code style=&#39;overflow: auto&#39;&gt;{ &#34;description&#34;: &#34;Repeated item.&#34; }&lt;/pre&gt;&lt;/code&gt;&lt;h4&gt;Refund Notification:&lt;/h4&gt;&lt;p&gt;It will send notification to configured web hook after refund successfully, http status code should return 200 or 204 once you resolve notification successfully, otherwise payment system will retry notification in interval&lt;/p&gt;&lt;p&gt;&lt;strong&gt;Refund notification parameter:&lt;/strong&gt;&lt;/p&gt;&lt;pre&gt;&lt;table&gt;&lt;tr&gt;&lt;td&gt;Parameter&lt;/td&gt;&lt;td&gt;Type&lt;/td&gt;&lt;td&gt;Required&lt;/td&gt;&lt;td&gt;Description&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;payload&lt;/td&gt;&lt;td&gt;String&lt;/td&gt;&lt;td&gt;Yes&lt;/td&gt;&lt;td&gt;Refund notification payload in json string &lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;sign&lt;/td&gt;&lt;td&gt;String&lt;/td&gt;&lt;td&gt;Yes&lt;/td&gt;&lt;td&gt;sha1 hex signature for payload and private key&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;Refund notification Example:&lt;/strong&gt;&lt;/p&gt;&lt;pre&gt;&lt;code style=&#39;overflow: auto&#39;&gt;{ &#34;payload&#34;: &#34;{ \&#34;type\&#34;: \&#34;payment\&#34;, \&#34;nonceStr\&#34;: \&#34;34c1dcf3eb58455eb161465bbfc0b590\&#34;, \&#34;paymentOrderNo\&#34;: \&#34;18081239088\&#34;, \&#34;namespace\&#34;: \&#34;accelbyte\&#34;, \&#34;targetNamespace\&#34;: \&#34;game1\&#34;, \&#34;targetUserId\&#34;: \&#34;94451623768940d58416ca33ca767ec3\&#34;, \&#34;extOrderNo\&#34;: \&#34;123456789\&#34;, \&#34;sku\&#34;: \&#34;sku\&#34;, \&#34;extUserId\&#34;: \&#34;678\&#34;, \&#34;price\&#34;: 100, \&#34;paymentProvider\&#34;: \&#34;XSOLLA\&#34;, \&#34;vat\&#34;: 0, \&#34;salesTax\&#34;: 0, \&#34;paymentProviderFee\&#34;: 0, \&#34;paymentMethodFee\&#34;: 0, \&#34;currency\&#34;: { \&#34;currencyCode\&#34;: \&#34;USD\&#34;, \&#34;currencySymbol\&#34;: \&#34;$\&#34;, \&#34;currencyType\&#34;: \&#34;REAL\&#34;, \&#34;namespace\&#34;: \&#34;accelbyte\&#34;, \&#34;decimals\&#34;: 2 }, \&#34;status\&#34;: \&#34;REFUNDED\&#34;, \&#34;createdTime\&#34;: \&#34;2018-07-28T00:39:16.274Z\&#34;, \&#34;chargedTime\&#34;: \&#34;2018-07-28T00:39:16.274Z\&#34;, \&#34;refundedTime\&#34;: \&#34;2018-07-28T00:39:16.274Z\&#34; }&#34;, &#34;sign&#34;:&#34;e31fb92516cc9faaf50ad70343e1293acec6f3d5&#34; }&lt;/pre&gt;&lt;/code&gt;&lt;p&gt;&lt;strong&gt;Refund notification payload parameter list:&lt;/strong&gt;&lt;/p&gt;&lt;pre&gt;&lt;table&gt;&lt;tr&gt;&lt;td&gt;Parameter&lt;/td&gt;&lt;td&gt;Type&lt;/td&gt;&lt;td&gt;Required&lt;/td&gt;&lt;td&gt;Description&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;type&lt;/td&gt;&lt;td&gt;String&lt;/td&gt;&lt;td&gt;Yes&lt;/td&gt;&lt;td&gt;Notification type: &#39;payment&#39;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;paymentOrderNo&lt;/td&gt;&lt;td&gt;String&lt;/td&gt;&lt;td&gt;Yes&lt;/td&gt;&lt;td&gt;Payment system generated order number&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;extOrderNo&lt;/td&gt;&lt;td&gt;String&lt;/td&gt;&lt;td&gt;No&lt;/td&gt;&lt;td&gt;External order number that passed by invoker&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;namespace&lt;/td&gt;&lt;td&gt;String&lt;/td&gt;&lt;td&gt;Yes&lt;/td&gt;&lt;td&gt;Namespace that related payment order resides in&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;targetNamespace&lt;/td&gt;&lt;td&gt;String&lt;/td&gt;&lt;td&gt;Yes&lt;/td&gt;&lt;td&gt;The game namespace&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;targetUserId&lt;/td&gt;&lt;td&gt;String&lt;/td&gt;&lt;td&gt;Yes&lt;/td&gt;&lt;td&gt;The user id in game namespace&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;sku&lt;/td&gt;&lt;td&gt;String&lt;/td&gt;&lt;td&gt;No&lt;/td&gt;&lt;td&gt;Item identify, it will return if pass it when create payment&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;extUserId&lt;/td&gt;&lt;td&gt;String&lt;/td&gt;&lt;td&gt;No&lt;/td&gt;&lt;td&gt;External user id, can be character id, it will return if pass it when create payment&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;price&lt;/td&gt;&lt;td&gt;int&lt;/td&gt;&lt;td&gt;Yes&lt;/td&gt;&lt;td&gt;Price of item&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;paymentProvider&lt;/td&gt;&lt;td&gt;String&lt;/td&gt;&lt;td&gt;Yes&lt;/td&gt;&lt;td&gt;Payment provider: xsolla/alipay/wxpay/wallet&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;vat&lt;/td&gt;&lt;td&gt;int&lt;/td&gt;&lt;td&gt;Yes&lt;/td&gt;&lt;td&gt;Payment order VAT&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;salesTax&lt;/td&gt;&lt;td&gt;int&lt;/td&gt;&lt;td&gt;Yes&lt;/td&gt;&lt;td&gt;Payment order sales tax&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;paymentProviderFee&lt;/td&gt;&lt;td&gt;int&lt;/td&gt;&lt;td&gt;Yes&lt;/td&gt;&lt;td&gt;Payment provider fee&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;paymentMethodFee&lt;/td&gt;&lt;td&gt;int&lt;/td&gt;&lt;td&gt;Yes&lt;/td&gt;&lt;td&gt;Payment method fee&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;currency&lt;/td&gt;&lt;td&gt;Map&lt;/td&gt;&lt;td&gt;Yes&lt;/td&gt;&lt;td&gt;Payment order currency info&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;status&lt;/td&gt;&lt;td&gt;String&lt;/td&gt;&lt;td&gt;Yes&lt;/td&gt;&lt;td&gt;Payment order status&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;statusReason&lt;/td&gt;&lt;td&gt;String&lt;/td&gt;&lt;td&gt;No&lt;/td&gt;&lt;td&gt;Payment order refund status reason&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;createdTime&lt;/td&gt;&lt;td&gt;Datetime&lt;/td&gt;&lt;td&gt;No&lt;/td&gt;&lt;td&gt;The time of the order created&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;chargedTime&lt;/td&gt;&lt;td&gt;Datetime&lt;/td&gt;&lt;td&gt;No&lt;/td&gt;&lt;td&gt;The time of the order charged&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;refundedTime&lt;/td&gt;&lt;td&gt;Datetime&lt;/td&gt;&lt;td&gt;No&lt;/td&gt;&lt;td&gt;The time of the order refunded&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;customParameters&lt;/td&gt;&lt;td&gt;Map&lt;/td&gt;&lt;td&gt;No&lt;/td&gt;&lt;td&gt;custom parameters, will return if pass it when create payment&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;nonceStr&lt;/td&gt;&lt;td&gt;String&lt;/td&gt;&lt;td&gt;Yes&lt;/td&gt;&lt;td&gt;Random string, max length is 32, &lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;Currency info parameter list:&lt;/strong&gt;&lt;/p&gt;&lt;pre&gt;&lt;table&gt;&lt;tr&gt;&lt;td&gt;Parameter&lt;/td&gt;&lt;td&gt;Type&lt;/td&gt;&lt;td&gt;Required&lt;/td&gt;&lt;td&gt;Description&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;currencyCode&lt;/td&gt;&lt;td&gt;String&lt;/td&gt;&lt;td&gt;Yes&lt;/td&gt;&lt;td&gt;Currency Code&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;currencySymbol&lt;/td&gt;&lt;td&gt;String&lt;/td&gt;&lt;td&gt;Yes&lt;/td&gt;&lt;td&gt;Currency Symbol&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;currencyType&lt;/td&gt;&lt;td&gt;String&lt;/td&gt;&lt;td&gt;Yes&lt;/td&gt;&lt;td&gt;Currency type(REAL/VIRTUAL)&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;namespace&lt;/td&gt;&lt;td&gt;String&lt;/td&gt;&lt;td&gt;Yes&lt;/td&gt;&lt;td&gt;Currency namespace&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;decimals&lt;/td&gt;&lt;td&gt;int&lt;/td&gt;&lt;td&gt;Yes&lt;/td&gt;&lt;td&gt;Currency decimals&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/pre&gt;&lt;h4&gt;Encryption Rule:&lt;/h4&gt;&lt;p&gt;Concat payload json string and private key and then do sha1Hex.&lt;/p&gt;&lt;h4&gt;Other detail info:&lt;/h4&gt; &lt;ul&gt;&lt;li&gt;&lt;i&gt;Token type&lt;/i&gt;: client token&lt;/li&gt;&lt;li&gt;&lt;b&gt;cross namespace allowed&lt;/b&gt;&lt;/li&gt;&lt;/ul&gt;
   */
  updateRefundPayment_ByPaymentOrderNo(paymentOrderNo, data) {
    const params = {};
    const url = "/platform/admin/namespaces/{namespace}/payment/orders/{paymentOrderNo}/refund".replace("{namespace}", this.namespace).replace("{paymentOrderNo}", paymentOrderNo);
    const resultPromise = this.axiosInstance.put(url, data, { params });
    return import_sdk31.Validate.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      PaymentOrderRefundResult,
      "PaymentOrderRefundResult"
    );
  }
};

// src/generated-admin/endpoints/PlatformAccountClosureAdmin$.ts
var import_sdk32 = require("@accelbyte/sdk");

// src/generated-definitions/PlatformAccountClosureHistoryInfoArray.ts
var import_zod239 = require("zod");

// src/generated-definitions/PlatformAccountClosureHistoryInfo.ts
var import_zod238 = require("zod");

// src/generated-definitions/SimpleEntitlement.ts
var import_zod234 = require("zod");
var SimpleEntitlement = import_zod234.z.object({
  entitlementId: import_zod234.z.string().nullish(),
  grantedCode: import_zod234.z.string().nullish(),
  itemId: import_zod234.z.string().nullish(),
  itemNamespace: import_zod234.z.string().nullish(),
  name: import_zod234.z.string().nullish(),
  namespace: import_zod234.z.string().nullish(),
  origin: import_zod234.z.string().nullish(),
  sku: import_zod234.z.string().nullish(),
  useCount: import_zod234.z.number().int().nullish()
});

// src/generated-definitions/SimpleUserDlc.ts
var import_zod235 = require("zod");
var SimpleUserDlc = import_zod235.z.object({ dlcId: import_zod235.z.string().nullish() });

// src/generated-definitions/SimpleWallet.ts
var import_zod237 = require("zod");

// src/generated-definitions/TimeLimitedBalance.ts
var import_zod236 = require("zod");
var TimeLimitedBalance = import_zod236.z.object({
  balance: import_zod236.z.number().int().nullish(),
  balanceSource: import_zod236.z.string().nullish(),
  expireAt: import_zod236.z.string().nullish()
});

// src/generated-definitions/SimpleWallet.ts
var SimpleWallet = import_zod237.z.object({
  balance: import_zod237.z.number().int().nullish(),
  balanceOrigin: import_zod237.z.string().nullish(),
  currencyCode: import_zod237.z.string().nullish(),
  timeLimitedBalances: import_zod237.z.array(TimeLimitedBalance).nullish(),
  walletId: import_zod237.z.string().nullish()
});

// src/generated-definitions/PlatformAccountClosureHistoryInfo.ts
var PlatformAccountClosureHistoryInfo = import_zod238.z.object({
  entitlements: import_zod238.z.array(SimpleEntitlement).nullish(),
  id: import_zod238.z.string(),
  namespace: import_zod238.z.string(),
  platform: import_zod238.z.string(),
  progression: import_zod238.z.enum(["IN_PROGRESS", "SUCCESS"]),
  userDlcS: import_zod238.z.array(SimpleUserDlc).nullish(),
  userId: import_zod238.z.string(),
  wallets: import_zod238.z.array(SimpleWallet).nullish()
});

// src/generated-definitions/PlatformAccountClosureHistoryInfoArray.ts
var PlatformAccountClosureHistoryInfoArray = import_zod239.z.array(PlatformAccountClosureHistoryInfo);

// src/generated-admin/endpoints/PlatformAccountClosureAdmin$.ts
var PlatformAccountClosureAdmin$ = class {
  // @ts-ignore
  // prettier-ignore
  constructor(axiosInstance, namespace, useSchemaValidation = true) {
    this.axiosInstance = axiosInstance;
    this.namespace = namespace;
    this.useSchemaValidation = useSchemaValidation;
  }
  /**
   * Get user platform account closure history.&lt;br&gt;
   */
  getPlatformClosureHistory_ByUserId(userId) {
    const params = {};
    const url = "/platform/admin/namespaces/{namespace}/users/{userId}/platform/closure/history".replace("{namespace}", this.namespace).replace("{userId}", userId);
    const resultPromise = this.axiosInstance.get(url, { params });
    return import_sdk32.Validate.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      PlatformAccountClosureHistoryInfoArray,
      "PlatformAccountClosureHistoryInfoArray"
    );
  }
};

// src/generated-admin/endpoints/PlatformAdmin$.ts
var import_sdk33 = require("@accelbyte/sdk");

// src/generated-definitions/PlatformOwnership.ts
var import_zod240 = require("zod");
var PlatformOwnership = import_zod240.z.object({ owned: import_zod240.z.boolean() });

// src/generated-admin/endpoints/PlatformAdmin$.ts
var PlatformAdmin$ = class {
  // @ts-ignore
  // prettier-ignore
  constructor(axiosInstance, namespace, useSchemaValidation = true) {
    this.axiosInstance = axiosInstance;
    this.namespace = namespace;
    this.useSchemaValidation = useSchemaValidation;
  }
  /**
   * Get Xbox entitlement ownership by product sku.
   */
  createOwnershipXblPlatform_ByProductSku(productSku, data) {
    const params = {};
    const url = "/platform/admin/namespaces/{namespace}/platforms/xbl/entitlements/{productSku}/ownership".replace("{namespace}", this.namespace).replace("{productSku}", productSku);
    const resultPromise = this.axiosInstance.post(url, data, { params });
    return import_sdk33.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, PlatformOwnership, "PlatformOwnership");
  }
  /**
   * Get user psn entitlement ownership by entitlement label.
   */
  createOwnershipPsnPlatform_ByEntitlementLabel(entitlementLabel, data) {
    const params = {};
    const url = "/platform/admin/namespaces/{namespace}/platforms/psn/entitlements/{entitlementLabel}/ownership".replace("{namespace}", this.namespace).replace("{entitlementLabel}", entitlementLabel);
    const resultPromise = this.axiosInstance.post(url, data, { params });
    return import_sdk33.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, Ownership, "Ownership");
  }
};

// src/generated-admin/endpoints/RevocationAdmin$.ts
var import_sdk34 = require("@accelbyte/sdk");
var import_zod253 = require("zod");

// src/generated-definitions/RevocationConfigInfo.ts
var import_zod245 = require("zod");

// src/generated-definitions/EntitlementRevocationConfig.ts
var import_zod243 = require("zod");

// src/generated-definitions/ConsumableEntitlementRevocationConfig.ts
var import_zod241 = require("zod");
var ConsumableEntitlementRevocationConfig = import_zod241.z.object({
  enabled: import_zod241.z.boolean().nullish(),
  strategy: import_zod241.z.enum(["CUSTOM", "REVOKE_OR_REPORT"]).nullish()
});

// src/generated-definitions/DurableEntitlementRevocationConfig.ts
var import_zod242 = require("zod");
var DurableEntitlementRevocationConfig = import_zod242.z.object({
  enabled: import_zod242.z.boolean().nullish(),
  strategy: import_zod242.z.enum(["CUSTOM", "REVOKE_OR_REPORT"]).nullish()
});

// src/generated-definitions/EntitlementRevocationConfig.ts
var EntitlementRevocationConfig = import_zod243.z.object({
  consumable: ConsumableEntitlementRevocationConfig.nullish(),
  durable: DurableEntitlementRevocationConfig.nullish()
});

// src/generated-definitions/WalletRevocationConfig.ts
var import_zod244 = require("zod");
var WalletRevocationConfig = import_zod244.z.object({
  enabled: import_zod244.z.boolean().nullish(),
  strategy: import_zod244.z.enum(["ALWAYS_REVOKE", "CUSTOM", "REVOKE_OR_REPORT"]).nullish()
});

// src/generated-definitions/RevocationConfigInfo.ts
var RevocationConfigInfo = import_zod245.z.object({
  entitlement: EntitlementRevocationConfig.nullish(),
  namespace: import_zod245.z.string().nullish(),
  wallet: WalletRevocationConfig.nullish()
});

// src/generated-definitions/RevocationHistoryPagingSlicedResult.ts
var import_zod252 = require("zod");

// src/generated-definitions/RevocationHistoryInfo.ts
var import_zod251 = require("zod");

// src/generated-definitions/RevocationError.ts
var import_zod246 = require("zod");
var RevocationError = import_zod246.z.object({
  code: import_zod246.z.number().int().nullish(),
  httpStatus: import_zod246.z.number().int().nullish(),
  message: import_zod246.z.string().nullish()
});

// src/generated-definitions/RevokeEntry.ts
var import_zod250 = require("zod");

// src/generated-definitions/RevokeCurrency.ts
var import_zod247 = require("zod");
var RevokeCurrency = import_zod247.z.object({
  balanceOrigin: import_zod247.z.enum(["Epic", "GooglePlay", "IOS", "Nintendo", "Oculus", "Other", "Playstation", "Steam", "System", "Twitch", "Xbox"]).nullish(),
  currencyCode: import_zod247.z.string().nullish(),
  namespace: import_zod247.z.string().nullish()
});

// src/generated-definitions/RevokeEntitlement.ts
var import_zod248 = require("zod");
var RevokeEntitlement = import_zod248.z.object({ entitlementId: import_zod248.z.string().nullish() });

// src/generated-definitions/RevokeItem.ts
var import_zod249 = require("zod");
var RevokeItem = import_zod249.z.object({
  entitlementOrigin: import_zod249.z.enum(["Epic", "GooglePlay", "IOS", "Nintendo", "Oculus", "Other", "Playstation", "Steam", "System", "Twitch", "Xbox"]).nullish(),
  itemIdentity: import_zod249.z.string().nullish(),
  itemIdentityType: import_zod249.z.enum(["ITEM_ID", "ITEM_SKU"]).nullish(),
  origin: import_zod249.z.enum(["Epic", "GooglePlay", "IOS", "Nintendo", "Oculus", "Other", "Playstation", "Steam", "System", "Twitch", "Xbox"]).nullish()
});

// src/generated-definitions/RevokeEntry.ts
var RevokeEntry = import_zod250.z.object({
  currency: RevokeCurrency.nullish(),
  entitlement: RevokeEntitlement.nullish(),
  item: RevokeItem.nullish(),
  quantity: import_zod250.z.number().int().nullish(),
  type: import_zod250.z.enum(["CURRENCY", "ENTITLEMENT", "ITEM"]).nullish()
});

// src/generated-definitions/RevocationHistoryInfo.ts
var RevocationHistoryInfo = import_zod251.z.object({
  createdAt: import_zod251.z.string().nullish(),
  creditRevocations: import_zod251.z.array(CreditRevocation).nullish(),
  entitlementRevocations: import_zod251.z.array(EntitlementRevocation).nullish(),
  id: import_zod251.z.string().nullish(),
  itemRevocations: import_zod251.z.array(ItemRevocation).nullish(),
  meta: import_zod251.z.record(import_zod251.z.any()).nullish(),
  namespace: import_zod251.z.string().nullish(),
  revocationErrors: import_zod251.z.array(RevocationError).nullish(),
  revokeEntries: import_zod251.z.array(RevokeEntry).nullish(),
  source: import_zod251.z.string().nullish(),
  status: import_zod251.z.enum(["FAIL", "SUCCESS"]).nullish(),
  transactionId: import_zod251.z.string().nullish(),
  updatedAt: import_zod251.z.string().nullish(),
  userId: import_zod251.z.string().nullish()
});

// src/generated-definitions/RevocationHistoryPagingSlicedResult.ts
var RevocationHistoryPagingSlicedResult = import_zod252.z.object({ data: import_zod252.z.array(RevocationHistoryInfo), paging: Paging.nullish() });

// src/generated-admin/endpoints/RevocationAdmin$.ts
var RevocationAdmin$ = class {
  // @ts-ignore
  // prettier-ignore
  constructor(axiosInstance, namespace, useSchemaValidation = true) {
    this.axiosInstance = axiosInstance;
    this.namespace = namespace;
    this.useSchemaValidation = useSchemaValidation;
  }
  /**
   * Delete revocation config.
   */
  deleteRevocationConfig() {
    const params = {};
    const url = "/platform/admin/namespaces/{namespace}/revocation/config".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.delete(url, { params });
    return import_sdk34.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, import_zod253.z.unknown(), "z.unknown()");
  }
  /**
   * Get revocation configuration.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: Revocation config&lt;/li&gt;&lt;/ul&gt;
   */
  getRevocationConfig() {
    const params = {};
    const url = "/platform/admin/namespaces/{namespace}/revocation/config".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.get(url, { params });
    return import_sdk34.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, RevocationConfigInfo, "RevocationConfigInfo");
  }
  /**
   * Update revocation configuration.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: Revocation config&lt;/li&gt;&lt;/ul&gt;
   */
  updateRevocationConfig(data) {
    const params = {};
    const url = "/platform/admin/namespaces/{namespace}/revocation/config".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.put(url, data, { params });
    return import_sdk34.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, RevocationConfigInfo, "RevocationConfigInfo");
  }
  /**
   * Query revocation histories in a namespace.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: query revocation history&lt;/li&gt;&lt;/ul&gt;
   */
  getRevocationHistory(queryParams) {
    const params = { limit: 20, ...queryParams };
    const url = "/platform/admin/namespaces/{namespace}/revocation/history".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.get(url, { params });
    return import_sdk34.Validate.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      RevocationHistoryPagingSlicedResult,
      "RevocationHistoryPagingSlicedResult"
    );
  }
  /**
   * Do revocation.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: revocation results&lt;/li&gt;&lt;/ul&gt;
   */
  updateRevocation_ByUserId(userId, data) {
    const params = {};
    const url = "/platform/admin/namespaces/{namespace}/users/{userId}/revocation".replace("{namespace}", this.namespace).replace("{userId}", userId);
    const resultPromise = this.axiosInstance.put(url, data, { params });
    return import_sdk34.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, RevocationResult, "RevocationResult");
  }
};

// src/generated-admin/endpoints/RewardAdmin$.ts
var import_sdk35 = require("@accelbyte/sdk");
var import_zod259 = require("zod");

// src/generated-definitions/ConditionMatchResult.ts
var import_zod254 = require("zod");
var ConditionMatchResult = import_zod254.z.object({
  matched: import_zod254.z.boolean().nullish(),
  matchedConditions: import_zod254.z.array(import_zod254.z.any()).nullish(),
  notMatchReason: import_zod254.z.string().nullish()
});

// src/generated-definitions/RewardInfo.ts
var import_zod257 = require("zod");

// src/generated-definitions/RewardCondition.ts
var import_zod256 = require("zod");

// src/generated-definitions/RewardItem.ts
var import_zod255 = require("zod");
var RewardItem = import_zod255.z.object({
  duration: import_zod255.z.number().int().nullish(),
  endDate: import_zod255.z.string().nullish(),
  identityType: import_zod255.z.enum(["ITEM_ID", "ITEM_SKU"]).nullish(),
  itemId: import_zod255.z.string().nullish(),
  quantity: import_zod255.z.number().int().nullish(),
  sku: import_zod255.z.string().nullish()
});

// src/generated-definitions/RewardCondition.ts
var RewardCondition = import_zod256.z.object({
  condition: import_zod256.z.string().nullish(),
  conditionName: import_zod256.z.string().nullish(),
  eventName: import_zod256.z.string().nullish(),
  rewardItems: import_zod256.z.array(RewardItem).nullish()
});

// src/generated-definitions/RewardInfo.ts
var RewardInfo = import_zod257.z.object({
  createdAt: import_zod257.z.string().nullish(),
  description: import_zod257.z.string().nullish(),
  eventTopic: import_zod257.z.string(),
  maxAwarded: import_zod257.z.number().int().nullish(),
  maxAwardedPerUser: import_zod257.z.number().int().nullish(),
  namespace: import_zod257.z.string(),
  namespaceExpression: import_zod257.z.string().nullish(),
  rewardCode: import_zod257.z.string().nullish(),
  rewardConditions: import_zod257.z.array(RewardCondition).nullish(),
  rewardId: import_zod257.z.string(),
  updatedAt: import_zod257.z.string().nullish(),
  userIdExpression: import_zod257.z.string().nullish()
});

// src/generated-definitions/RewardPagingSlicedResult.ts
var import_zod258 = require("zod");
var RewardPagingSlicedResult = import_zod258.z.object({ data: import_zod258.z.array(RewardInfo), paging: Paging.nullish() });

// src/generated-admin/endpoints/RewardAdmin$.ts
var RewardAdmin$ = class {
  // @ts-ignore
  // prettier-ignore
  constructor(axiosInstance, namespace, useSchemaValidation = true) {
    this.axiosInstance = axiosInstance;
    this.namespace = namespace;
    this.useSchemaValidation = useSchemaValidation;
  }
  /**
   * This API is used to create a reward.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: created reward data&lt;/li&gt;&lt;li&gt;&lt;i&gt;Acceptable values for rewardItem&#39;s identityType are&lt;/i&gt;: ITEM_ID or ITEM_SKU&lt;/li&gt;&lt;/ul&gt;
   */
  createReward(data) {
    const params = {};
    const url = "/platform/admin/namespaces/{namespace}/rewards".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.post(url, data, { params });
    return import_sdk35.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, RewardInfo, "RewardInfo");
  }
  /**
   * Export reward configurations for a given namespace into file. At current, only JSON file is supported.
   */
  getRewardsExport() {
    const params = {};
    const url = "/platform/admin/namespaces/{namespace}/rewards/export".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.get(url, { params });
    return import_sdk35.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, import_zod259.z.unknown(), "z.unknown()");
  }
  /**
   * Import reward configurations for a given namespace from file. At current, only JSON file is supported.
   */
  createRewardImport(data, queryParams) {
    const params = { ...queryParams };
    const url = "/platform/admin/namespaces/{namespace}/rewards/import".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.post(url, data, { params });
    return import_sdk35.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, import_zod259.z.unknown(), "z.unknown()");
  }
  /**
   * This API is used to delete a reward by reward Id. &lt;p&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: the deleted reward data&lt;/li&gt;&lt;/ul&gt;
   */
  deleteReward_ByRewardId(rewardId) {
    const params = {};
    const url = "/platform/admin/namespaces/{namespace}/rewards/{rewardId}".replace("{namespace}", this.namespace).replace("{rewardId}", rewardId);
    const resultPromise = this.axiosInstance.delete(url, { params });
    return import_sdk35.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, RewardInfo, "RewardInfo");
  }
  /**
   * This API is used to get reward by reward Id.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: reward instance&lt;/li&gt;&lt;/ul&gt;
   */
  getReward_ByRewardId(rewardId) {
    const params = {};
    const url = "/platform/admin/namespaces/{namespace}/rewards/{rewardId}".replace("{namespace}", this.namespace).replace("{rewardId}", rewardId);
    const resultPromise = this.axiosInstance.get(url, { params });
    return import_sdk35.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, RewardInfo, "RewardInfo");
  }
  /**
   * This API is used to update a reward.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: reward instance&lt;/li&gt;&lt;li&gt;&lt;i&gt;Acceptable values for rewardItem&#39;s identityType are&lt;/i&gt;: ITEM_ID or ITEM_SKU&lt;/li&gt;&lt;/ul&gt;
   */
  updateReward_ByRewardId(rewardId, data) {
    const params = {};
    const url = "/platform/admin/namespaces/{namespace}/rewards/{rewardId}".replace("{namespace}", this.namespace).replace("{rewardId}", rewardId);
    const resultPromise = this.axiosInstance.put(url, data, { params });
    return import_sdk35.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, RewardInfo, "RewardInfo");
  }
  /**
   * This API is used to query rewards by criteria.&lt;p&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: the list of rewards&lt;/li&gt;&lt;/ul&gt;
   */
  getRewardsByCriteria(queryParams) {
    const params = { limit: 20, sortBy: ["namespace:asc", "rewardCode:asc"], ...queryParams };
    const url = "/platform/admin/namespaces/{namespace}/rewards/byCriteria".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.get(url, { params });
    return import_sdk35.Validate.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      RewardPagingSlicedResult,
      "RewardPagingSlicedResult"
    );
  }
  /**
   * &lt;b&gt;[TEST FACILITY ONLY] Forbidden in live environment. &lt;/b&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: match result&lt;/li&gt;&lt;/ul&gt;
   */
  updateMatch_ByRewardId(rewardId, data) {
    const params = {};
    const url = "/platform/admin/namespaces/{namespace}/rewards/{rewardId}/match".replace("{namespace}", this.namespace).replace("{rewardId}", rewardId);
    const resultPromise = this.axiosInstance.put(url, data, { params });
    return import_sdk35.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, ConditionMatchResult, "ConditionMatchResult");
  }
  /**
   * &lt;b&gt;[TEST FACILITY ONLY] Forbidden in live environment. &lt;/b&gt; This API is used to delete a reward condition record by reward Id and condition Name (optional). &lt;p&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: 204 No Content &lt;/li&gt;&lt;/ul&gt;
   */
  deleteRecord_ByRewardId(rewardId, data) {
    const params = {};
    const url = "/platform/admin/namespaces/{namespace}/rewards/{rewardId}/record".replace("{namespace}", this.namespace).replace("{rewardId}", rewardId);
    const resultPromise = this.axiosInstance.delete(url, { data, params });
    return import_sdk35.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, import_zod259.z.unknown(), "z.unknown()");
  }
};

// src/generated-admin/endpoints/SectionAdmin$.ts
var import_sdk36 = require("@accelbyte/sdk");
var import_zod265 = require("zod");

// src/generated-definitions/FullSectionInfo.ts
var import_zod263 = require("zod");

// src/generated-definitions/FixedPeriodRotationConfig.ts
var import_zod260 = require("zod");
var FixedPeriodRotationConfig = import_zod260.z.object({
  backfillType: import_zod260.z.enum(["CUSTOM", "NONE"]).nullish(),
  duration: import_zod260.z.number().int().nullish(),
  itemCount: import_zod260.z.number().int().nullish(),
  rule: import_zod260.z.enum(["SEQUENCE"]).nullish()
});

// src/generated-definitions/ItemNaming.ts
var import_zod261 = require("zod");
var ItemNaming = import_zod261.z.object({
  categoryPath: import_zod261.z.string().nullish(),
  itemId: import_zod261.z.string(),
  itemType: import_zod261.z.enum([
    "APP",
    "BUNDLE",
    "CODE",
    "COINS",
    "EXTENSION",
    "INGAMEITEM",
    "LOOTBOX",
    "MEDIA",
    "OPTIONBOX",
    "SEASON",
    "SUBSCRIPTION"
  ]),
  name: import_zod261.z.string(),
  namespace: import_zod261.z.string(),
  seasonType: import_zod261.z.enum(["PASS", "TIER"]).nullish(),
  sku: import_zod261.z.string().nullish(),
  status: import_zod261.z.enum(["ACTIVE", "INACTIVE"]).nullish()
});

// src/generated-definitions/SectionItem.ts
var import_zod262 = require("zod");
var SectionItem = import_zod262.z.object({ id: import_zod262.z.string(), sku: import_zod262.z.string().nullish() });

// src/generated-definitions/FullSectionInfo.ts
var FullSectionInfo = import_zod263.z.object({
  active: import_zod263.z.boolean(),
  createdAt: import_zod263.z.string(),
  displayOrder: import_zod263.z.number().int().nullish(),
  endDate: import_zod263.z.string(),
  ext: import_zod263.z.record(import_zod263.z.any()).nullish(),
  fixedPeriodRotationConfig: FixedPeriodRotationConfig.nullish(),
  itemNamings: import_zod263.z.array(ItemNaming).nullish(),
  items: import_zod263.z.array(SectionItem).nullish(),
  localizations: import_zod263.z.record(Localization),
  name: import_zod263.z.string(),
  namespace: import_zod263.z.string(),
  rotationType: import_zod263.z.enum(["CUSTOM", "FIXED_PERIOD", "NONE"]).nullish(),
  sectionId: import_zod263.z.string(),
  startDate: import_zod263.z.string(),
  updatedAt: import_zod263.z.string(),
  viewId: import_zod263.z.string().nullish(),
  viewName: import_zod263.z.string().nullish()
});

// src/generated-definitions/SectionPagingSlicedResult.ts
var import_zod264 = require("zod");
var SectionPagingSlicedResult = import_zod264.z.object({ data: import_zod264.z.array(FullSectionInfo), paging: Paging.nullish() });

// src/generated-admin/endpoints/SectionAdmin$.ts
var SectionAdmin$ = class {
  // @ts-ignore
  // prettier-ignore
  constructor(axiosInstance, namespace, useSchemaValidation = true) {
    this.axiosInstance = axiosInstance;
    this.namespace = namespace;
    this.useSchemaValidation = useSchemaValidation;
  }
  /**
   * This API is used to query sections.&lt;p&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: paginated sections&lt;/li&gt;&lt;/ul&gt;
   */
  getSections(queryParams) {
    const params = { limit: 20, ...queryParams };
    const url = "/platform/admin/namespaces/{namespace}/sections".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.get(url, { params });
    return import_sdk36.Validate.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      SectionPagingSlicedResult,
      "SectionPagingSlicedResult"
    );
  }
  /**
   * This API is used to create a section.&lt;p&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: created a section&lt;/li&gt;&lt;/ul&gt;&lt;h2&gt;Restrictions for section extension and localization extension&lt;/h2&gt; 1. Cannot use &lt;b&gt;&#34;.&#34;&lt;/b&gt; as the key name - &lt;pre&gt;{ &#34;data.2&#34;: &#34;value&#34; }&lt;/pre&gt; 2. Cannot use &lt;b&gt;&#34;$&#34;&lt;/b&gt; as the prefix in key names - &lt;pre&gt;{ &#34;$data&#34;: &#34;value&#34; }&lt;/pre&gt;
   */
  createSection(data, queryParams) {
    const params = { ...queryParams };
    const url = "/platform/admin/namespaces/{namespace}/sections".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.post(url, data, { params });
    return import_sdk36.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, FullSectionInfo, "FullSectionInfo");
  }
  /**
   * This API is used to delete s section.
   */
  deleteSection_BySectionId(sectionId, queryParams) {
    const params = { ...queryParams };
    const url = "/platform/admin/namespaces/{namespace}/sections/{sectionId}".replace("{namespace}", this.namespace).replace("{sectionId}", sectionId);
    const resultPromise = this.axiosInstance.delete(url, { params });
    return import_sdk36.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, import_zod265.z.unknown(), "z.unknown()");
  }
  /**
   * This API is used to get a section.&lt;p&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: section data&lt;/li&gt;&lt;/ul&gt;
   */
  getSection_BySectionId(sectionId, queryParams) {
    const params = { ...queryParams };
    const url = "/platform/admin/namespaces/{namespace}/sections/{sectionId}".replace("{namespace}", this.namespace).replace("{sectionId}", sectionId);
    const resultPromise = this.axiosInstance.get(url, { params });
    return import_sdk36.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, FullSectionInfo, "FullSectionInfo");
  }
  /**
   * This API is used to update s section.&lt;p&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: updated section data&lt;/li&gt;&lt;/ul&gt;&lt;h2&gt;Restrictions for section extension and localization extension&lt;/h2&gt; 1. Cannot use &lt;b&gt;&#34;.&#34;&lt;/b&gt; as the key name - &lt;pre&gt;{ &#34;data.2&#34;: &#34;value&#34; }&lt;/pre&gt; 2. Cannot use &lt;b&gt;&#34;$&#34;&lt;/b&gt; as the prefix in key names - &lt;pre&gt;{ &#34;$data&#34;: &#34;value&#34; }&lt;/pre&gt;
   */
  updateSection_BySectionId(sectionId, data, queryParams) {
    const params = { ...queryParams };
    const url = "/platform/admin/namespaces/{namespace}/sections/{sectionId}".replace("{namespace}", this.namespace).replace("{sectionId}", sectionId);
    const resultPromise = this.axiosInstance.put(url, data, { params });
    return import_sdk36.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, FullSectionInfo, "FullSectionInfo");
  }
  /**
   * This API is used to purge expired section.
   */
  deleteSectionPurgeExpired(queryParams) {
    const params = { ...queryParams };
    const url = "/platform/admin/namespaces/{namespace}/sections/purge/expired".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.delete(url, { params });
    return import_sdk36.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, import_zod265.z.unknown(), "z.unknown()");
  }
};

// src/generated-admin/endpoints/ServicePluginConfigAdmin$.ts
var import_sdk37 = require("@accelbyte/sdk");
var import_zod275 = require("zod");

// src/generated-definitions/GrpcServerInfo.ts
var import_zod267 = require("zod");

// src/generated-definitions/TlsConfig.ts
var import_zod266 = require("zod");
var TlsConfig = import_zod266.z.object({ rootCertFileBytes: import_zod266.z.array(import_zod266.z.string()).nullish(), rootCertFileName: import_zod266.z.string().nullish() });

// src/generated-definitions/GrpcServerInfo.ts
var GrpcServerInfo = import_zod267.z.object({
  address: import_zod267.z.string().nullish(),
  connectionTypeEnum: import_zod267.z.enum(["INSECURE", "TLS"]).nullish(),
  status: import_zod267.z.string().nullish(),
  tlsConfig: TlsConfig.nullish()
});

// src/generated-definitions/LootBoxPluginConfigInfo.ts
var import_zod271 = require("zod");

// src/generated-definitions/AppConfig.ts
var import_zod268 = require("zod");
var AppConfig = import_zod268.z.object({ appName: import_zod268.z.string() });

// src/generated-definitions/PublicCustomConfigInfo.ts
var import_zod270 = require("zod");

// src/generated-definitions/BaseTlsConfig.ts
var import_zod269 = require("zod");
var BaseTlsConfig = import_zod269.z.object({ rootCertFileName: import_zod269.z.string().nullish() });

// src/generated-definitions/PublicCustomConfigInfo.ts
var PublicCustomConfigInfo = import_zod270.z.object({
  connectionType: import_zod270.z.enum(["INSECURE", "TLS"]),
  grpcServerAddress: import_zod270.z.string(),
  tlsConfig: BaseTlsConfig.nullish()
});

// src/generated-definitions/LootBoxPluginConfigInfo.ts
var LootBoxPluginConfigInfo = import_zod271.z.object({
  appConfig: AppConfig.nullish(),
  customConfig: PublicCustomConfigInfo.nullish(),
  extendType: import_zod271.z.enum(["APP", "CUSTOM"]).nullish(),
  namespace: import_zod271.z.string()
});

// src/generated-definitions/RevocationPluginConfigInfo.ts
var import_zod272 = require("zod");
var RevocationPluginConfigInfo = import_zod272.z.object({
  appConfig: AppConfig.nullish(),
  customConfig: PublicCustomConfigInfo.nullish(),
  extendType: import_zod272.z.enum(["APP", "CUSTOM"]).nullish(),
  namespace: import_zod272.z.string()
});

// src/generated-definitions/SectionPluginConfigInfo.ts
var import_zod273 = require("zod");
var SectionPluginConfigInfo = import_zod273.z.object({
  appConfig: AppConfig.nullish(),
  customConfig: PublicCustomConfigInfo.nullish(),
  extendType: import_zod273.z.enum(["APP", "CUSTOM"]).nullish(),
  namespace: import_zod273.z.string()
});

// src/generated-definitions/ServicePluginConfigInfo.ts
var import_zod274 = require("zod");
var ServicePluginConfigInfo = import_zod274.z.object({ grpcServerAddress: import_zod274.z.string().nullish(), namespace: import_zod274.z.string().nullish() });

// src/generated-admin/endpoints/ServicePluginConfigAdmin$.ts
var ServicePluginConfigAdmin$ = class {
  // @ts-ignore
  // prettier-ignore
  constructor(axiosInstance, namespace, useSchemaValidation = true) {
    this.axiosInstance = axiosInstance;
    this.namespace = namespace;
    this.useSchemaValidation = useSchemaValidation;
  }
  /**
   * @deprecated
   * Delete service plugin config
   */
  deleteConfigServicePlugin() {
    const params = {};
    const url = "/platform/admin/namespaces/{namespace}/configs/servicePlugin".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.delete(url, { params });
    return import_sdk37.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, import_zod275.z.unknown(), "z.unknown()");
  }
  /**
   * @deprecated
   * Get service plugin config
   */
  getConfigsServicePlugin() {
    const params = {};
    const url = "/platform/admin/namespaces/{namespace}/configs/servicePlugin".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.get(url, { params });
    return import_sdk37.Validate.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      ServicePluginConfigInfo,
      "ServicePluginConfigInfo"
    );
  }
  /**
   * @deprecated
   * Update catalog config. Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: updated service plugin config&lt;/li&gt;&lt;/ul&gt;
   */
  updateConfigServicePlugin(data) {
    const params = {};
    const url = "/platform/admin/namespaces/{namespace}/configs/servicePlugin".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.put(url, data, { params });
    return import_sdk37.Validate.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      ServicePluginConfigInfo,
      "ServicePluginConfigInfo"
    );
  }
  /**
   * Delete service plugin config.
   */
  deleteCatalogPluginLootbox() {
    const params = {};
    const url = "/platform/admin/namespaces/{namespace}/catalog/plugins/lootbox".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.delete(url, { params });
    return import_sdk37.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, import_zod275.z.unknown(), "z.unknown()");
  }
  /**
   * Get lootbox plugin config.
   */
  getCatalogPluginsLootbox() {
    const params = {};
    const url = "/platform/admin/namespaces/{namespace}/catalog/plugins/lootbox".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.get(url, { params });
    return import_sdk37.Validate.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      LootBoxPluginConfigInfo,
      "LootBoxPluginConfigInfo"
    );
  }
  /**
   * Update lootbox plugin config. Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: updated service plugin config&lt;/li&gt;&lt;/ul&gt;
   */
  updateCatalogPluginLootbox(data) {
    const params = {};
    const url = "/platform/admin/namespaces/{namespace}/catalog/plugins/lootbox".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.put(url, data, { params });
    return import_sdk37.Validate.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      LootBoxPluginConfigInfo,
      "LootBoxPluginConfigInfo"
    );
  }
  /**
   * Delete section plugin config.
   */
  deleteCatalogPluginSection() {
    const params = {};
    const url = "/platform/admin/namespaces/{namespace}/catalog/plugins/section".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.delete(url, { params });
    return import_sdk37.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, import_zod275.z.unknown(), "z.unknown()");
  }
  /**
   * Get section plugin config.
   */
  getCatalogPluginsSection() {
    const params = {};
    const url = "/platform/admin/namespaces/{namespace}/catalog/plugins/section".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.get(url, { params });
    return import_sdk37.Validate.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      SectionPluginConfigInfo,
      "SectionPluginConfigInfo"
    );
  }
  /**
   * Update section config. Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: updated service plugin config&lt;/li&gt;&lt;/ul&gt;
   */
  updateCatalogPluginSection(data) {
    const params = {};
    const url = "/platform/admin/namespaces/{namespace}/catalog/plugins/section".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.put(url, data, { params });
    return import_sdk37.Validate.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      SectionPluginConfigInfo,
      "SectionPluginConfigInfo"
    );
  }
  /**
   * Delete service plugin config.
   */
  deleteRevocationPluginRevocation() {
    const params = {};
    const url = "/platform/admin/namespaces/{namespace}/revocation/plugins/revocation".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.delete(url, { params });
    return import_sdk37.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, import_zod275.z.unknown(), "z.unknown()");
  }
  /**
   * Get revocation plugin config.
   */
  getRevocationPluginsRevocation() {
    const params = {};
    const url = "/platform/admin/namespaces/{namespace}/revocation/plugins/revocation".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.get(url, { params });
    return import_sdk37.Validate.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      RevocationPluginConfigInfo,
      "RevocationPluginConfigInfo"
    );
  }
  /**
   * Update revocation plugin config. Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: updated service plugin config&lt;/li&gt;&lt;/ul&gt;
   */
  updateRevocationPluginRevocation(data) {
    const params = {};
    const url = "/platform/admin/namespaces/{namespace}/revocation/plugins/revocation".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.put(url, data, { params });
    return import_sdk37.Validate.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      RevocationPluginConfigInfo,
      "RevocationPluginConfigInfo"
    );
  }
  /**
   * Get lootbox plugin gRPC info.
   */
  getCatalogPluginsLootboxGrpcInfo(queryParams) {
    const params = { ...queryParams };
    const url = "/platform/admin/namespaces/{namespace}/catalog/plugins/lootbox/grpcInfo".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.get(url, { params });
    return import_sdk37.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, GrpcServerInfo, "GrpcServerInfo");
  }
  /**
   * Upload lootbox plugin custom config tls cert.Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: updated service plugin config&lt;/li&gt;&lt;/ul&gt;
   */
  updateCatalogPluginLootboxCustomConfigCert(data) {
    const params = {};
    const url = "/platform/admin/namespaces/{namespace}/catalog/plugins/lootbox/customConfig/cert".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.put(url, data, { params });
    return import_sdk37.Validate.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      LootBoxPluginConfigInfo,
      "LootBoxPluginConfigInfo"
    );
  }
  /**
   * Upload section plugin custom config tls cert.Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: updated service plugin config&lt;/li&gt;&lt;/ul&gt;
   */
  updateCatalogPluginSectionCustomConfigCert(data) {
    const params = {};
    const url = "/platform/admin/namespaces/{namespace}/catalog/plugins/section/customConfig/cert".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.put(url, data, { params });
    return import_sdk37.Validate.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      SectionPluginConfigInfo,
      "SectionPluginConfigInfo"
    );
  }
  /**
   * Upload revocation plugin custom config tls cert.Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: updated service plugin config&lt;/li&gt;&lt;/ul&gt;
   */
  updateRevocationPluginRevocationRevocationCustomConfigCert(data) {
    const params = {};
    const url = "/platform/admin/namespaces/{namespace}/revocation/plugins/revocation/revocation/customConfig/cert".replace(
      "{namespace}",
      this.namespace
    );
    const resultPromise = this.axiosInstance.put(url, data, { params });
    return import_sdk37.Validate.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      RevocationPluginConfigInfo,
      "RevocationPluginConfigInfo"
    );
  }
};

// src/generated-admin/endpoints/SessionPlatformAdmin$.ts
var import_sdk38 = require("@accelbyte/sdk");
var import_zod276 = require("zod");
var SessionPlatformAdmin$ = class {
  // @ts-ignore
  // prettier-ignore
  constructor(axiosInstance, namespace, useSchemaValidation = true) {
    this.axiosInstance = axiosInstance;
    this.namespace = namespace;
    this.useSchemaValidation = useSchemaValidation;
  }
  /**
   * This API is used to register/update a session on xbox.
   */
  updateSessionXbl_ByUserId(userId, data) {
    const params = {};
    const url = "/platform/admin/namespaces/{namespace}/users/{userId}/session/xbl".replace("{namespace}", this.namespace).replace("{userId}", userId);
    const resultPromise = this.axiosInstance.put(url, data, { params });
    return import_sdk38.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, import_zod276.z.unknown(), "z.unknown()");
  }
};

// src/generated-admin/endpoints/StoreAdmin$.ts
var import_sdk39 = require("@accelbyte/sdk");
var import_zod292 = require("zod");

// src/generated-definitions/CatalogConfigInfo.ts
var import_zod277 = require("zod");
var CatalogConfigInfo = import_zod277.z.object({ enableInventoryCheck: import_zod277.z.boolean() });

// src/generated-definitions/CatalogDefinitionInfoArray.ts
var import_zod279 = require("zod");

// src/generated-definitions/CatalogDefinitionInfo.ts
var import_zod278 = require("zod");
var CatalogDefinitionInfo = import_zod278.z.object({
  field: import_zod278.z.string(),
  itemType: import_zod278.z.enum(["APP", "BUNDLE", "CODE", "COINS", "EXTENSION", "INGAMEITEM", "LOOTBOX", "MEDIA", "OPTIONBOX", "SEASON", "SUBSCRIPTION"]).nullish(),
  name: import_zod278.z.string(),
  required: import_zod278.z.boolean()
});

// src/generated-definitions/CatalogDefinitionInfoArray.ts
var CatalogDefinitionInfoArray = import_zod279.z.array(CatalogDefinitionInfo);

// src/generated-definitions/ImportStoreHistoryPagingResult.ts
var import_zod288 = require("zod");

// src/generated-definitions/ImportStoreHistoryInfo.ts
var import_zod287 = require("zod");

// src/generated-definitions/ImportStoreError.ts
var import_zod286 = require("zod");

// src/generated-definitions/ImportErrorDetails.ts
var import_zod280 = require("zod");
var ImportErrorDetails = import_zod280.z.object({
  errorCode: import_zod280.z.number().int().nullish(),
  errorField: import_zod280.z.string().nullish(),
  errorMessage: import_zod280.z.string().nullish(),
  errorValue: import_zod280.z.string().nullish(),
  messageVariables: import_zod280.z.record(import_zod280.z.string()).nullish()
});

// src/generated-definitions/ImportStoreAppInfo.ts
var import_zod281 = require("zod");
var ImportStoreAppInfo = import_zod281.z.object({ itemId: import_zod281.z.string().nullish() });

// src/generated-definitions/ImportStoreCategoryInfo.ts
var import_zod282 = require("zod");
var ImportStoreCategoryInfo = import_zod282.z.object({
  categoryId: import_zod282.z.string().nullish(),
  categoryPath: import_zod282.z.string().nullish(),
  namespace: import_zod282.z.string().nullish()
});

// src/generated-definitions/ImportStoreItemInfo.ts
var import_zod283 = require("zod");
var ImportStoreItemInfo = import_zod283.z.object({
  categoryPath: import_zod283.z.string().nullish(),
  itemId: import_zod283.z.string().nullish(),
  itemType: import_zod283.z.enum([
    "APP",
    "BUNDLE",
    "CODE",
    "COINS",
    "EXTENSION",
    "INGAMEITEM",
    "LOOTBOX",
    "MEDIA",
    "OPTIONBOX",
    "SEASON",
    "SUBSCRIPTION"
  ]),
  localizations: import_zod283.z.record(Localization).nullish(),
  name: import_zod283.z.string().nullish(),
  sku: import_zod283.z.string().nullish()
});

// src/generated-definitions/ImportStoreSectionInfo.ts
var import_zod284 = require("zod");
var ImportStoreSectionInfo = import_zod284.z.object({ name: import_zod284.z.string().nullish(), sectionId: import_zod284.z.string().nullish() });

// src/generated-definitions/ImportStoreViewInfo.ts
var import_zod285 = require("zod");
var ImportStoreViewInfo = import_zod285.z.object({ name: import_zod285.z.string().nullish(), viewId: import_zod285.z.string().nullish() });

// src/generated-definitions/ImportStoreError.ts
var ImportStoreError = import_zod286.z.object({
  app: ImportStoreAppInfo.nullish(),
  category: ImportStoreCategoryInfo.nullish(),
  errors: import_zod286.z.array(ImportErrorDetails).nullish(),
  item: ImportStoreItemInfo.nullish(),
  section: ImportStoreSectionInfo.nullish(),
  type: import_zod286.z.enum(["APP", "CATEGORY", "ITEM", "SECTION", "STORE", "VIEW"]).nullish(),
  view: ImportStoreViewInfo.nullish()
});

// src/generated-definitions/ImportStoreHistoryInfo.ts
var ImportStoreHistoryInfo = import_zod287.z.object({
  createdAt: import_zod287.z.string(),
  errors: import_zod287.z.array(ImportStoreError).nullish(),
  id: import_zod287.z.string(),
  importFileFormat: import_zod287.z.enum(["CSV", "JSON"]),
  initiatedBy: import_zod287.z.string(),
  namespace: import_zod287.z.string(),
  note: import_zod287.z.string().nullish(),
  storeId: import_zod287.z.string(),
  success: import_zod287.z.boolean()
});

// src/generated-definitions/ImportStoreHistoryPagingResult.ts
var ImportStoreHistoryPagingResult = import_zod288.z.object({
  data: import_zod288.z.array(ImportStoreHistoryInfo),
  paging: Paging.nullish(),
  total: import_zod288.z.number().int().nullish()
});

// src/generated-definitions/ImportStoreResult.ts
var import_zod289 = require("zod");
var ImportStoreResult = import_zod289.z.object({
  errors: import_zod289.z.array(ImportStoreError).nullish(),
  storeInfo: StoreInfo.nullish(),
  success: import_zod289.z.boolean().nullish()
});

// src/generated-definitions/StoreBackupInfo.ts
var import_zod290 = require("zod");
var StoreBackupInfo = import_zod290.z.object({
  autoBackup: import_zod290.z.boolean(),
  createdAt: import_zod290.z.string(),
  id: import_zod290.z.string(),
  name: import_zod290.z.string(),
  storeId: import_zod290.z.string(),
  updatedAt: import_zod290.z.string()
});

// src/generated-definitions/StoreInfoArray.ts
var import_zod291 = require("zod");
var StoreInfoArray = import_zod291.z.array(StoreInfo);

// src/generated-admin/endpoints/StoreAdmin$.ts
var StoreAdmin$ = class {
  // @ts-ignore
  // prettier-ignore
  constructor(axiosInstance, namespace, useSchemaValidation = true) {
    this.axiosInstance = axiosInstance;
    this.namespace = namespace;
    this.useSchemaValidation = useSchemaValidation;
  }
  /**
   * This API is used to list stores in a namespace.&lt;p&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: the list of stores&lt;/li&gt;&lt;/ul&gt;
   */
  getStores() {
    const params = {};
    const url = "/platform/admin/namespaces/{namespace}/stores".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.get(url, { params });
    return import_sdk39.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, StoreInfoArray, "StoreInfoArray");
  }
  /**
   * This API is used to create a non published store in a namespace.&lt;p&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: created store data&lt;/li&gt;&lt;/ul&gt;
   */
  createStore(data) {
    const params = {};
    const url = "/platform/admin/namespaces/{namespace}/stores".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.post(url, data, { params });
    return import_sdk39.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, StoreInfo, "StoreInfo");
  }
  /**
   * @deprecated
   * This API is used to import a store.&lt;p&gt;This api has been deprecated, pls use /v2/admin/namespaces/{namespace}/stores/import to import store.&lt;br&gt;
   */
  updateStoreImport(data, queryParams) {
    const params = { ...queryParams };
    const url = "/platform/admin/namespaces/{namespace}/stores/import".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.put(url, data, { params });
    return import_sdk39.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, StoreInfo, "StoreInfo");
  }
  /**
   * Get catalog config.
   */
  getCatalogConfigs() {
    const params = {};
    const url = "/platform/admin/namespaces/{namespace}/catalog/configs".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.get(url, { params });
    return import_sdk39.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, CatalogConfigInfo, "CatalogConfigInfo");
  }
  /**
   * Update catalog config. Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: updated catalog config&lt;/li&gt;&lt;/ul&gt;
   */
  updateCatalogConfig(data) {
    const params = {};
    const url = "/platform/admin/namespaces/{namespace}/catalog/configs".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.put(url, data, { params });
    return import_sdk39.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, CatalogConfigInfo, "CatalogConfigInfo");
  }
  /**
   * This API is used to delete a store. Only non published store can be deleted.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: store&lt;/li&gt;&lt;/ul&gt;
   */
  deleteStore_ByStoreId(storeId) {
    const params = {};
    const url = "/platform/admin/namespaces/{namespace}/stores/{storeId}".replace("{namespace}", this.namespace).replace("{storeId}", storeId);
    const resultPromise = this.axiosInstance.delete(url, { params });
    return import_sdk39.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, StoreInfo, "StoreInfo");
  }
  /**
   * This API is used to get a store.&lt;p&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: store data&lt;/li&gt;&lt;/ul&gt;
   */
  getStore_ByStoreId(storeId) {
    const params = {};
    const url = "/platform/admin/namespaces/{namespace}/stores/{storeId}".replace("{namespace}", this.namespace).replace("{storeId}", storeId);
    const resultPromise = this.axiosInstance.get(url, { params });
    return import_sdk39.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, StoreInfo, "StoreInfo");
  }
  /**
   * This API is used to Update a store basic info.&lt;p&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: updated store data&lt;/li&gt;&lt;/ul&gt;
   */
  updateStore_ByStoreId(storeId, data) {
    const params = {};
    const url = "/platform/admin/namespaces/{namespace}/stores/{storeId}".replace("{namespace}", this.namespace).replace("{storeId}", storeId);
    const resultPromise = this.axiosInstance.put(url, data, { params });
    return import_sdk39.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, StoreInfo, "StoreInfo");
  }
  /**
   * This API is used to delete published store including category and items before release to public.&lt;p&gt;&lt;b&gt;Warning: Please do not use this API once published to public user.&lt;/b&gt;
   */
  deleteStorePublished() {
    const params = {};
    const url = "/platform/admin/namespaces/{namespace}/stores/published".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.delete(url, { params });
    return import_sdk39.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, StoreInfo, "StoreInfo");
  }
  /**
   * This API is used to get a published store basic info, exclude category and item information.&lt;p&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: store data&lt;/li&gt;&lt;/ul&gt;
   */
  getStoresPublished() {
    const params = {};
    const url = "/platform/admin/namespaces/{namespace}/stores/published".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.get(url, { params });
    return import_sdk39.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, StoreInfo, "StoreInfo");
  }
  /**
   * This API is used to import a store.
   */
  updateStoreImport_v2(data, queryParams) {
    const params = { strictMode: true, ...queryParams };
    const url = "/platform/v2/admin/namespaces/{namespace}/stores/import".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.put(url, data, { params });
    return import_sdk39.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, ImportStoreResult, "ImportStoreResult");
  }
  /**
   * This API is used to export a store to CSV format
   */
  createStoreExportByCsv(data) {
    const params = {};
    const url = "/platform/admin/namespaces/{namespace}/stores/exportByCSV".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.post(url, data, { params });
    return import_sdk39.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, import_zod292.z.unknown(), "z.unknown()");
  }
  /**
   * This API is used to clone a store. Usually clone a draft store to published store because published store can&#39;t directly edit content.&lt;p&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: clone store info&lt;/li&gt;&lt;/ul&gt;
   */
  updateClone_ByStoreId(storeId, queryParams) {
    const params = { ...queryParams };
    const url = "/platform/admin/namespaces/{namespace}/stores/{storeId}/clone".replace("{namespace}", this.namespace).replace("{storeId}", storeId);
    const resultPromise = this.axiosInstance.put(url, null, { params });
    return import_sdk39.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, StoreInfo, "StoreInfo");
  }
  /**
   * @deprecated
   * This API is used to export a store.&lt;p&gt;This api has been deprecated, pls use /v2/admin/namespaces/{namespace}/stores/export to export store.&lt;br&gt;
   */
  getExport_ByStoreId(storeId) {
    const params = {};
    const url = "/platform/admin/namespaces/{namespace}/stores/{storeId}/export".replace("{namespace}", this.namespace).replace("{storeId}", storeId);
    const resultPromise = this.axiosInstance.get(url, { params });
    return import_sdk39.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, import_zod292.z.unknown(), "z.unknown()");
  }
  /**
   * This API is used to get a store&#39;s backup. &lt;p&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: store backup info&lt;/li&gt;&lt;/ul&gt;
   */
  getStoresPublishedBackup() {
    const params = {};
    const url = "/platform/admin/namespaces/{namespace}/stores/published/backup".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.get(url, { params });
    return import_sdk39.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, StoreBackupInfo, "StoreBackupInfo");
  }
  /**
   * This API is used to get catalog definition for import/export store by CSV&lt;p&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: catalog definition&lt;/li&gt;&lt;/ul&gt;
   */
  getStoresCatalogDefinition(queryParams) {
    const params = { ...queryParams };
    const url = "/platform/admin/namespaces/{namespace}/stores/catalogDefinition".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.get(url, { params });
    return import_sdk39.Validate.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      CatalogDefinitionInfoArray,
      "CatalogDefinitionInfoArray"
    );
  }
  /**
   * This API is used to rollback a published store. &lt;p&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: updated store info&lt;/li&gt;&lt;/ul&gt;
   */
  updateStorePublishedRollback() {
    const params = {};
    const url = "/platform/admin/namespaces/{namespace}/stores/published/rollback".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.put(url, null, { params });
    return import_sdk39.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, StoreInfo, "StoreInfo");
  }
  /**
   * This API is used to export a whole or partial store.
   */
  createExport_ByStoreId_v2(storeId, data) {
    const params = {};
    const url = "/platform/v2/admin/namespaces/{namespace}/stores/{storeId}/export".replace("{namespace}", this.namespace).replace("{storeId}", storeId);
    const resultPromise = this.axiosInstance.post(url, data, { params });
    return import_sdk39.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, import_zod292.z.unknown(), "z.unknown()");
  }
  /**
   * This API is used to download store csv templates for store importing by CSV feature
   */
  getStoresDownloadCsvTemplates() {
    const params = {};
    const url = "/platform/admin/namespaces/{namespace}/stores/downloadCSVTemplates".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.get(url, { params });
    return import_sdk39.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, import_zod292.z.unknown(), "z.unknown()");
  }
  /**
   * This API is used to import a store by CSV format.
   */
  createImportByCsv_ByStoreId(storeId, data) {
    const params = {};
    const url = "/platform/admin/namespaces/{namespace}/stores/{storeId}/importByCSV".replace("{namespace}", this.namespace).replace("{storeId}", storeId);
    const resultPromise = this.axiosInstance.post(url, data, { params });
    return import_sdk39.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, ImportStoreResult, "ImportStoreResult");
  }
  /**
   * This API is used to query import store history
   */
  getImportHistory_ByStoreId(storeId, queryParams) {
    const params = { limit: 20, sortBy: "createdAt:desc", ...queryParams };
    const url = "/platform/admin/namespaces/{namespace}/stores/{storeId}/import/history".replace("{namespace}", this.namespace).replace("{storeId}", storeId);
    const resultPromise = this.axiosInstance.get(url, { params });
    return import_sdk39.Validate.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      ImportStoreHistoryPagingResult,
      "ImportStoreHistoryPagingResult"
    );
  }
};

// src/generated-admin/endpoints/SubscriptionAdmin$.ts
var import_sdk40 = require("@accelbyte/sdk");
var import_zod302 = require("zod");

// src/generated-definitions/BillingHistoryPagingSlicedResult.ts
var import_zod295 = require("zod");

// src/generated-definitions/BillingHistoryInfo.ts
var import_zod294 = require("zod");

// src/generated-definitions/BillingAccount.ts
var import_zod293 = require("zod");
var BillingAccount = import_zod293.z.object({
  additionalData: AdditionalData.nullish(),
  paymentMethod: import_zod293.z.string().nullish(),
  paymentProvider: import_zod293.z.enum(["ADYEN", "ALIPAY", "CHECKOUT", "NEONPAY", "PAYPAL", "STRIPE", "WALLET", "WXPAY", "XSOLLA"]).nullish()
});

// src/generated-definitions/BillingHistoryInfo.ts
var BillingHistoryInfo = import_zod294.z.object({
  amount: import_zod294.z.number().int(),
  billingAccount: BillingAccount.nullish(),
  changeBillingAccount: import_zod294.z.boolean().nullish(),
  createdAt: import_zod294.z.string(),
  currency: CurrencySummary,
  description: import_zod294.z.string().nullish(),
  extTxId: import_zod294.z.string().nullish(),
  itemId: import_zod294.z.string(),
  namespace: import_zod294.z.string(),
  paymentOrderNo: import_zod294.z.string().nullish(),
  recurringOrderNo: import_zod294.z.string(),
  retryAttempted: import_zod294.z.number().int().nullish(),
  sandbox: import_zod294.z.boolean(),
  sku: import_zod294.z.string().nullish(),
  status: import_zod294.z.enum(["CHARGED", "CHARGE_FAILED", "INIT", "REFUNDED", "REFUND_FAILED"]),
  statusReason: import_zod294.z.string().nullish(),
  subscriptionId: import_zod294.z.string(),
  subtotalPrice: import_zod294.z.number().int().nullish(),
  title: import_zod294.z.string(),
  totalPrice: import_zod294.z.number().int().nullish(),
  totalTax: import_zod294.z.number().int().nullish(),
  txEndTime: import_zod294.z.string().nullish(),
  updatedAt: import_zod294.z.string(),
  userId: import_zod294.z.string()
});

// src/generated-definitions/BillingHistoryPagingSlicedResult.ts
var BillingHistoryPagingSlicedResult = import_zod295.z.object({ data: import_zod295.z.array(BillingHistoryInfo), paging: Paging.nullish() });

// src/generated-definitions/RecurringChargeResult.ts
var import_zod296 = require("zod");
var RecurringChargeResult = import_zod296.z.object({ code: import_zod296.z.string().nullish(), detail: import_zod296.z.string().nullish(), triggered: import_zod296.z.boolean() });

// src/generated-definitions/Subscribable.ts
var import_zod297 = require("zod");
var Subscribable = import_zod297.z.object({ subscribable: import_zod297.z.boolean() });

// src/generated-definitions/SubscriptionActivityPagingSlicedResult.ts
var import_zod299 = require("zod");

// src/generated-definitions/SubscriptionActivityInfo.ts
var import_zod298 = require("zod");
var SubscriptionActivityInfo = import_zod298.z.object({
  action: import_zod298.z.enum(["CANCEL", "CHANGE_BILLING_ACCOUNT", "GRANT_DAYS", "IMMEDIATE_CANCEL", "RESUBSCRIBE", "SUBSCRIBE"]),
  chargedCycles: import_zod298.z.number().int(),
  createdAt: import_zod298.z.string(),
  currentCycle: import_zod298.z.number().int(),
  grantDays: import_zod298.z.number().int().nullish(),
  inFixedCycleTrial: import_zod298.z.boolean().nullish(),
  inFixedFreeDays: import_zod298.z.boolean().nullish(),
  namespace: import_zod298.z.string(),
  operator: import_zod298.z.string(),
  reason: import_zod298.z.string().nullish(),
  subscribedBy: import_zod298.z.enum(["PLATFORM", "USER"]),
  subscriptionId: import_zod298.z.string(),
  trialedCycles: import_zod298.z.number().int().nullish(),
  updatedAt: import_zod298.z.string(),
  userId: import_zod298.z.string()
});

// src/generated-definitions/SubscriptionActivityPagingSlicedResult.ts
var SubscriptionActivityPagingSlicedResult = import_zod299.z.object({ data: import_zod299.z.array(SubscriptionActivityInfo), paging: Paging.nullish() });

// src/generated-definitions/SubscriptionInfo.ts
var import_zod300 = require("zod");
var SubscriptionInfo = import_zod300.z.object({
  billingAccount: BillingAccount.nullish(),
  chargeStatus: import_zod300.z.enum(["CHARGED", "CHARGE_FAILED", "NEVER", "RECURRING_CHARGING", "SETUP"]),
  chargedCycles: import_zod300.z.number().int().nullish(),
  createdAt: import_zod300.z.string(),
  currency: CurrencySummary.nullish(),
  currentCycle: import_zod300.z.number().int().nullish(),
  currentPeriodEnd: import_zod300.z.string().nullish(),
  currentPeriodStart: import_zod300.z.string().nullish(),
  description: import_zod300.z.string().nullish(),
  end: import_zod300.z.string().nullish(),
  entitlements: import_zod300.z.array(EntitlementSummary).nullish(),
  firstSubscribe: import_zod300.z.boolean().nullish(),
  id: import_zod300.z.string(),
  inFixedCycleTrial: import_zod300.z.boolean(),
  inFixedFreeDays: import_zod300.z.boolean(),
  itemId: import_zod300.z.string(),
  itemSnapshot: ItemSnapshot.nullish(),
  language: import_zod300.z.string().nullish(),
  namespace: import_zod300.z.string(),
  nextBillingDate: import_zod300.z.string().nullish(),
  paid: import_zod300.z.boolean().nullish(),
  paymentFlowRequired: import_zod300.z.boolean(),
  paymentOrderNo: import_zod300.z.string().nullish(),
  paymentStationUrl: import_zod300.z.string().nullish(),
  price: import_zod300.z.number().int().nullish(),
  recurring: Recurring,
  region: import_zod300.z.string().nullish(),
  retryAttempted: import_zod300.z.number().int().nullish(),
  returnUrl: import_zod300.z.string().nullish(),
  sandbox: import_zod300.z.boolean().nullish(),
  sku: import_zod300.z.string().nullish(),
  source: import_zod300.z.string().nullish(),
  start: import_zod300.z.string().nullish(),
  status: import_zod300.z.enum(["ACTIVE", "CANCELLED", "EXPIRED", "INIT"]),
  subscribedAt: import_zod300.z.string().nullish(),
  subscribedBy: import_zod300.z.enum(["PLATFORM", "USER"]).nullish(),
  title: import_zod300.z.string().nullish(),
  trialPrice: import_zod300.z.number().int().nullish(),
  trialedCycles: import_zod300.z.number().int().nullish(),
  unsubscribeReason: import_zod300.z.string().nullish(),
  unsubscribedAt: import_zod300.z.string().nullish(),
  updatedAt: import_zod300.z.string(),
  userId: import_zod300.z.string()
});

// src/generated-definitions/SubscriptionPagingSlicedResult.ts
var import_zod301 = require("zod");
var SubscriptionPagingSlicedResult = import_zod301.z.object({ data: import_zod301.z.array(SubscriptionInfo), paging: Paging.nullish() });

// src/generated-admin/endpoints/SubscriptionAdmin$.ts
var SubscriptionAdmin$ = class {
  // @ts-ignore
  // prettier-ignore
  constructor(axiosInstance, namespace, useSchemaValidation = true) {
    this.axiosInstance = axiosInstance;
    this.namespace = namespace;
    this.useSchemaValidation = useSchemaValidation;
  }
  /**
   * Query subscriptions.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: paginated subscriptions&lt;/li&gt;&lt;/ul&gt;
   */
  getSubscriptions(queryParams) {
    const params = { limit: 20, ...queryParams };
    const url = "/platform/admin/namespaces/{namespace}/subscriptions".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.get(url, { params });
    return import_sdk40.Validate.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      SubscriptionPagingSlicedResult,
      "SubscriptionPagingSlicedResult"
    );
  }
  /**
   * Query user subscriptions.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: paginated subscription&lt;/li&gt;&lt;/ul&gt;
   */
  getSubscriptions_ByUserId(userId, queryParams) {
    const params = { limit: 20, ...queryParams };
    const url = "/platform/admin/namespaces/{namespace}/users/{userId}/subscriptions".replace("{namespace}", this.namespace).replace("{userId}", userId);
    const resultPromise = this.axiosInstance.get(url, { params });
    return import_sdk40.Validate.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      SubscriptionPagingSlicedResult,
      "SubscriptionPagingSlicedResult"
    );
  }
  /**
   * Get user subscription activity.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: paginated subscription activity&lt;/li&gt;&lt;/ul&gt;
   */
  getSubscriptionsActivities_ByUserId(userId, queryParams) {
    const params = { limit: 20, ...queryParams };
    const url = "/platform/admin/namespaces/{namespace}/users/{userId}/subscriptions/activities".replace("{namespace}", this.namespace).replace("{userId}", userId);
    const resultPromise = this.axiosInstance.get(url, { params });
    return import_sdk40.Validate.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      SubscriptionActivityPagingSlicedResult,
      "SubscriptionActivityPagingSlicedResult"
    );
  }
  /**
   * &lt;b&gt;[TEST FACILITY ONLY] Forbidden in live environment. &lt;/b&gt; Recurring charge subscription, it will trigger recurring charge if the USER subscription status is ACTIVE, nextBillingDate is before now and no fail recurring charge within X(default 12) hours.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: recurring charge result&lt;/li&gt;&lt;/ul&gt;
   */
  updateRecurring_BySubscriptionId(subscriptionId) {
    const params = {};
    const url = "/platform/admin/namespaces/{namespace}/subscriptions/{subscriptionId}/recurring".replace("{namespace}", this.namespace).replace("{subscriptionId}", subscriptionId);
    const resultPromise = this.axiosInstance.put(url, null, { params });
    return import_sdk40.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, RecurringChargeResult, "RecurringChargeResult");
  }
  /**
   * &lt;b&gt;[TEST FACILITY ONLY] Forbidden in live environment. &lt;/b&gt; Delete user subscription.
   */
  deleteSubscription_ByUserId_BySubscriptionId(userId, subscriptionId) {
    const params = {};
    const url = "/platform/admin/namespaces/{namespace}/users/{userId}/subscriptions/{subscriptionId}".replace("{namespace}", this.namespace).replace("{userId}", userId).replace("{subscriptionId}", subscriptionId);
    const resultPromise = this.axiosInstance.delete(url, { params });
    return import_sdk40.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, import_zod302.z.unknown(), "z.unknown()");
  }
  /**
   * Get user subscription.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: subscription&lt;/li&gt;&lt;/ul&gt;
   */
  getSubscription_ByUserId_BySubscriptionId(userId, subscriptionId) {
    const params = {};
    const url = "/platform/admin/namespaces/{namespace}/users/{userId}/subscriptions/{subscriptionId}".replace("{namespace}", this.namespace).replace("{userId}", userId).replace("{subscriptionId}", subscriptionId);
    const resultPromise = this.axiosInstance.get(url, { params });
    return import_sdk40.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, SubscriptionInfo, "SubscriptionInfo");
  }
  /**
   * Free subscribe by platform, can used by other justice service to redeem/reward the subscription.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: result subscription&lt;/li&gt;&lt;/ul&gt;
   */
  createSubscriptionPlatformSubscribe_ByUserId(userId, data) {
    const params = {};
    const url = "/platform/admin/namespaces/{namespace}/users/{userId}/subscriptions/platformSubscribe".replace("{namespace}", this.namespace).replace("{userId}", userId);
    const resultPromise = this.axiosInstance.post(url, data, { params });
    return import_sdk40.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, SubscriptionInfo, "SubscriptionInfo");
  }
  /**
   * Check user subscription subscribable by itemId, ACTIVE USER subscription can&#39;t do subscribe again.&lt;p&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: subscribable info&lt;/li&gt;&lt;/ul&gt;
   */
  getSubscriptionsSubscribableByItemId_ByUserId(userId, queryParams) {
    const params = { ...queryParams };
    const url = "/platform/admin/namespaces/{namespace}/users/{userId}/subscriptions/subscribable/byItemId".replace("{namespace}", this.namespace).replace("{userId}", userId);
    const resultPromise = this.axiosInstance.get(url, { params });
    return import_sdk40.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, Subscribable, "Subscribable");
  }
  /**
   * Grant days to a subscription, if grantDays is positive, it will add free days and push the next billing date by the amount of day.&lt;br&gt;if the grantDays is negative or zero, it only apply to active/cancelled subscription, remove days will decrease current period end, and move the next billing date closer.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: updated subscription&lt;/li&gt;&lt;/ul&gt;
   */
  updateGrant_ByUserId_BySubscriptionId(userId, subscriptionId, data) {
    const params = {};
    const url = "/platform/admin/namespaces/{namespace}/users/{userId}/subscriptions/{subscriptionId}/grant".replace("{namespace}", this.namespace).replace("{userId}", userId).replace("{subscriptionId}", subscriptionId);
    const resultPromise = this.axiosInstance.put(url, data, { params });
    return import_sdk40.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, SubscriptionInfo, "SubscriptionInfo");
  }
  /**
   * Cancel a subscription, only ACTIVE subscription can be cancelled. &lt;b&gt;Ensure successfully cancel, recommend at least 1 day before current period ends, otherwise it may be charging or charged.&lt;/b&gt;&lt;br&gt;Set immediate true, the subscription will be terminated immediately, otherwise till the end of current billing cycle.&lt;br&gt;Set force true, will ignore the error if subscription is during recurring charging.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: cancelled subscription&lt;/li&gt;&lt;/ul&gt;
   */
  updateCancel_ByUserId_BySubscriptionId(userId, subscriptionId, data, queryParams) {
    const params = { ...queryParams };
    const url = "/platform/admin/namespaces/{namespace}/users/{userId}/subscriptions/{subscriptionId}/cancel".replace("{namespace}", this.namespace).replace("{userId}", userId).replace("{subscriptionId}", subscriptionId);
    const resultPromise = this.axiosInstance.put(url, data, { params });
    return import_sdk40.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, SubscriptionInfo, "SubscriptionInfo");
  }
  /**
   * Get user subscription billing histories.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: paginated subscription billing history&lt;/li&gt;&lt;/ul&gt;
   */
  getHistory_ByUserId_BySubscriptionId(userId, subscriptionId, queryParams) {
    const params = { limit: 20, ...queryParams };
    const url = "/platform/admin/namespaces/{namespace}/users/{userId}/subscriptions/{subscriptionId}/history".replace("{namespace}", this.namespace).replace("{userId}", userId).replace("{subscriptionId}", subscriptionId);
    const resultPromise = this.axiosInstance.get(url, { params });
    return import_sdk40.Validate.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      BillingHistoryPagingSlicedResult,
      "BillingHistoryPagingSlicedResult"
    );
  }
  /**
   * &lt;b&gt;[SERVICE COMMUNICATION ONLY]&lt;/b&gt; This API is used as a web hook for payment notification from justice payment service.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: Process result&lt;/li&gt;&lt;/ul&gt;
   */
  createNotification_ByUserId_BySubscriptionId(userId, subscriptionId, data) {
    const params = {};
    const url = "/platform/admin/namespaces/{namespace}/users/{userId}/subscriptions/{subscriptionId}/notifications".replace("{namespace}", this.namespace).replace("{userId}", userId).replace("{subscriptionId}", subscriptionId);
    const resultPromise = this.axiosInstance.post(url, data, { params });
    return import_sdk40.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, import_zod302.z.unknown(), "z.unknown()");
  }
};

// src/generated-admin/endpoints/TicketAdmin$.ts
var import_sdk41 = require("@accelbyte/sdk");
var import_zod307 = require("zod");

// src/generated-definitions/TicketAcquireResult.ts
var import_zod303 = require("zod");
var TicketAcquireResult = import_zod303.z.object({ values: import_zod303.z.array(import_zod303.z.string()).nullish() });

// src/generated-definitions/TicketBoothId.ts
var import_zod304 = require("zod");
var TicketBoothId = import_zod304.z.object({ id: import_zod304.z.string(), type: import_zod304.z.enum(["CAMPAIGN", "KEYGROUP"]) });

// src/generated-definitions/TicketDynamicInfo.ts
var import_zod305 = require("zod");
var TicketDynamicInfo = import_zod305.z.object({ availableSaleCount: import_zod305.z.number().int() });

// src/generated-definitions/TicketSaleIncrementResult.ts
var import_zod306 = require("zod");
var TicketSaleIncrementResult = import_zod306.z.object({ maxSaleCount: import_zod306.z.number().int(), success: import_zod306.z.boolean() });

// src/generated-admin/endpoints/TicketAdmin$.ts
var TicketAdmin$ = class {
  // @ts-ignore
  // prettier-ignore
  constructor(axiosInstance, namespace, useSchemaValidation = true) {
    this.axiosInstance = axiosInstance;
    this.namespace = namespace;
    this.useSchemaValidation = useSchemaValidation;
  }
  /**
   * &lt;b&gt;[SERVICE COMMUNICATION ONLY]&lt;/b&gt; Get ticket(code/key) dynamic based on booth name.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: ticket dynamic&lt;/li&gt;&lt;/ul&gt;
   */
  getTicket_ByBoothName(boothName) {
    const params = {};
    const url = "/platform/admin/namespaces/{namespace}/tickets/{boothName}".replace("{namespace}", this.namespace).replace("{boothName}", boothName);
    const resultPromise = this.axiosInstance.get(url, { params });
    return import_sdk41.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, TicketDynamicInfo, "TicketDynamicInfo");
  }
  /**
   * Get ticket(code/key) booth ID.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: ticket booth id&lt;/li&gt;&lt;/ul&gt;
   */
  getId_ByBoothName(boothName) {
    const params = {};
    const url = "/platform/admin/namespaces/{namespace}/tickets/{boothName}/id".replace("{namespace}", this.namespace).replace("{boothName}", boothName);
    const resultPromise = this.axiosInstance.get(url, { params });
    return import_sdk41.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, TicketBoothId, "TicketBoothId");
  }
  /**
   * &lt;b&gt;[SERVICE COMMUNICATION ONLY]&lt;/b&gt; Decrease ticket(code/key) sale if requested orderNo is already increased.
   */
  updateDecrement_ByBoothName(boothName, data) {
    const params = {};
    const url = "/platform/admin/namespaces/{namespace}/tickets/{boothName}/decrement".replace("{namespace}", this.namespace).replace("{boothName}", boothName);
    const resultPromise = this.axiosInstance.put(url, data, { params });
    return import_sdk41.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, import_zod307.z.unknown(), "z.unknown()");
  }
  /**
   * &lt;b&gt;[SERVICE COMMUNICATION ONLY]&lt;/b&gt; increase ticket(code/key) sale.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: Ticket sale increment result&lt;/li&gt;&lt;/ul&gt;
   */
  updateIncrement_ByBoothName(boothName, data) {
    const params = {};
    const url = "/platform/admin/namespaces/{namespace}/tickets/{boothName}/increment".replace("{namespace}", this.namespace).replace("{boothName}", boothName);
    const resultPromise = this.axiosInstance.put(url, data, { params });
    return import_sdk41.Validate.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      TicketSaleIncrementResult,
      "TicketSaleIncrementResult"
    );
  }
  /**
   * &lt;b&gt;[SERVICE COMMUNICATION ONLY]&lt;/b&gt; Acquire ticket(code/key) based on booth name.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: acquire result&lt;/li&gt;&lt;/ul&gt;
   */
  createTicket_ByUserId_ByBoothName(userId, boothName, data) {
    const params = {};
    const url = "/platform/admin/namespaces/{namespace}/users/{userId}/tickets/{boothName}".replace("{namespace}", this.namespace).replace("{userId}", userId).replace("{boothName}", boothName);
    const resultPromise = this.axiosInstance.post(url, data, { params });
    return import_sdk41.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, TicketAcquireResult, "TicketAcquireResult");
  }
};

// src/generated-admin/endpoints/TradeActionAdmin$.ts
var import_sdk42 = require("@accelbyte/sdk");

// src/generated-definitions/TradeActionPagingSlicedResult.ts
var import_zod315 = require("zod");

// src/generated-definitions/TradeChainActionHistoryInfo.ts
var import_zod314 = require("zod");

// src/generated-definitions/Action.ts
var import_zod313 = require("zod");

// src/generated-definitions/Operation.ts
var import_zod312 = require("zod");

// src/generated-definitions/CreditPayload.ts
var import_zod308 = require("zod");
var CreditPayload = import_zod308.z.object({
  balanceOrigin: import_zod308.z.enum(["Epic", "GooglePlay", "IOS", "Nintendo", "Oculus", "Other", "Playstation", "Steam", "System", "Twitch", "Xbox"]).nullish(),
  count: import_zod308.z.number().int(),
  currencyCode: import_zod308.z.string(),
  expireAt: import_zod308.z.string().nullish()
});

// src/generated-definitions/DebitPayload.ts
var import_zod309 = require("zod");
var DebitPayload = import_zod309.z.object({
  count: import_zod309.z.number().int(),
  currencyCode: import_zod309.z.string(),
  walletPlatform: import_zod309.z.enum(["Epic", "GooglePlay", "IOS", "Nintendo", "Oculus", "Other", "Playstation", "Steam", "Xbox"])
});

// src/generated-definitions/FulFillItemPayload.ts
var import_zod310 = require("zod");
var FulFillItemPayload = import_zod310.z.object({
  count: import_zod310.z.number().int(),
  entitlementCollectionId: import_zod310.z.string().nullish(),
  entitlementOrigin: import_zod310.z.enum(["Epic", "GooglePlay", "IOS", "Nintendo", "Oculus", "Other", "Playstation", "Steam", "System", "Twitch", "Xbox"]).nullish(),
  itemIdentity: import_zod310.z.string(),
  itemIdentityType: import_zod310.z.enum(["ITEM_ID", "ITEM_SKU"])
});

// src/generated-definitions/RevokeEntitlementPayload.ts
var import_zod311 = require("zod");
var RevokeEntitlementPayload = import_zod311.z.object({ count: import_zod311.z.number().int().nullish(), entitlementId: import_zod311.z.string() });

// src/generated-definitions/Operation.ts
var Operation = import_zod312.z.object({
  creditPayload: CreditPayload.nullish(),
  debitPayload: DebitPayload.nullish(),
  fulFillItemPayload: FulFillItemPayload.nullish(),
  resultId: import_zod312.z.string().nullish(),
  revokeEntitlementPayload: RevokeEntitlementPayload.nullish(),
  status: import_zod312.z.enum(["FAILED", "INIT", "SKIPPED", "SUCCESS"]).nullish(),
  statusReason: import_zod312.z.string().nullish(),
  type: import_zod312.z.enum(["CREDIT_WALLET", "DEBIT_WALLET", "FULFILL_ITEM", "REVOKE_ENTITLEMENT"])
});

// src/generated-definitions/Action.ts
var Action = import_zod313.z.object({
  operations: import_zod313.z.array(Operation).nullish(),
  status: import_zod313.z.enum(["FAILED", "INIT", "SKIPPED", "SUCCESS"]).nullish(),
  statusReason: import_zod313.z.string().nullish(),
  userId: import_zod313.z.string().nullish()
});

// src/generated-definitions/TradeChainActionHistoryInfo.ts
var TradeChainActionHistoryInfo = import_zod314.z.object({
  actions: import_zod314.z.array(Action).nullish(),
  metadata: import_zod314.z.record(import_zod314.z.any()).nullish(),
  namespace: import_zod314.z.string().nullish(),
  status: import_zod314.z.enum(["FAILED", "INIT", "SUCCESS"]).nullish(),
  statusReason: import_zod314.z.string().nullish(),
  transactionId: import_zod314.z.string().nullish(),
  type: import_zod314.z.string().nullish(),
  userIds: import_zod314.z.array(import_zod314.z.string()).nullish()
});

// src/generated-definitions/TradeActionPagingSlicedResult.ts
var TradeActionPagingSlicedResult = import_zod315.z.object({ data: import_zod315.z.array(TradeChainActionHistoryInfo), paging: Paging.nullish() });

// src/generated-admin/endpoints/TradeActionAdmin$.ts
var TradeActionAdmin$ = class {
  // @ts-ignore
  // prettier-ignore
  constructor(axiosInstance, namespace, useSchemaValidation = true) {
    this.axiosInstance = axiosInstance;
    this.namespace = namespace;
    this.useSchemaValidation = useSchemaValidation;
  }
  /**
   * This API is used to create a chained operations&lt;p&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: chain action history&lt;/li&gt;&lt;li&gt;&lt;i&gt;FULFILL_ITEM operation supported item type&lt;/i&gt;: INGAMEITEM,LOOTBOX,OPTIONBOX&lt;/li&gt;&lt;/ul&gt;&lt;h2&gt;Restrictions for metadata&lt;/h2&gt; 1. Cannot use &lt;b&gt;&#34;.&#34;&lt;/b&gt; as the key name - &lt;pre&gt;{ &#34;data.2&#34;: &#34;value&#34; }&lt;/pre&gt; 2. Cannot use &lt;b&gt;&#34;$&#34;&lt;/b&gt; as the prefix in key names - &lt;pre&gt;{ &#34;$data&#34;: &#34;value&#34; }&lt;/pre&gt;
   */
  createTradeCommit(data) {
    const params = {};
    const url = "/platform/admin/namespaces/{namespace}/trade/commit".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.post(url, data, { params });
    return import_sdk42.Validate.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      TradeChainActionHistoryInfo,
      "TradeChainActionHistoryInfo"
    );
  }
  /**
   * This API is used to fetch a specific trade history using transaction ID&lt;p&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: trade history based on transaction ID&lt;/li&gt;&lt;/ul&gt;
   */
  getTrade_ByTransactionId(transactionId) {
    const params = {};
    const url = "/platform/admin/namespaces/{namespace}/trade/{transactionId}".replace("{namespace}", this.namespace).replace("{transactionId}", transactionId);
    const resultPromise = this.axiosInstance.get(url, { params });
    return import_sdk42.Validate.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      TradeChainActionHistoryInfo,
      "TradeChainActionHistoryInfo"
    );
  }
  /**
   * This API is used to fetch trade history based on the provided criteria&lt;p&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: trade history list based on criteria&lt;/li&gt;&lt;/ul&gt;
   */
  getTradeHistoryByCriteria(queryParams) {
    const params = { limit: 20, ...queryParams };
    const url = "/platform/admin/namespaces/{namespace}/trade/history/byCriteria".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.get(url, { params });
    return import_sdk42.Validate.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      TradeActionPagingSlicedResult,
      "TradeActionPagingSlicedResult"
    );
  }
};

// src/generated-admin/endpoints/ViewAdmin$.ts
var import_sdk43 = require("@accelbyte/sdk");
var import_zod319 = require("zod");

// src/generated-definitions/FullViewInfo.ts
var import_zod316 = require("zod");
var FullViewInfo = import_zod316.z.object({
  createdAt: import_zod316.z.string(),
  displayOrder: import_zod316.z.number().int(),
  localizations: import_zod316.z.record(Localization),
  name: import_zod316.z.string(),
  namespace: import_zod316.z.string(),
  updatedAt: import_zod316.z.string(),
  viewId: import_zod316.z.string()
});

// src/generated-definitions/ListViewInfoArray.ts
var import_zod318 = require("zod");

// src/generated-definitions/ListViewInfo.ts
var import_zod317 = require("zod");
var ListViewInfo = import_zod317.z.object({
  createdAt: import_zod317.z.string(),
  displayOrder: import_zod317.z.number().int(),
  name: import_zod317.z.string(),
  namespace: import_zod317.z.string(),
  updatedAt: import_zod317.z.string(),
  viewId: import_zod317.z.string()
});

// src/generated-definitions/ListViewInfoArray.ts
var ListViewInfoArray = import_zod318.z.array(ListViewInfo);

// src/generated-admin/endpoints/ViewAdmin$.ts
var ViewAdmin$ = class {
  // @ts-ignore
  // prettier-ignore
  constructor(axiosInstance, namespace, useSchemaValidation = true) {
    this.axiosInstance = axiosInstance;
    this.namespace = namespace;
    this.useSchemaValidation = useSchemaValidation;
  }
  /**
   * This API is used to list all views.&lt;p&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: the list of views&lt;/li&gt;&lt;/ul&gt;
   */
  getViews(queryParams) {
    const params = { ...queryParams };
    const url = "/platform/admin/namespaces/{namespace}/views".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.get(url, { params });
    return import_sdk43.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, ListViewInfoArray, "ListViewInfoArray");
  }
  /**
   * This API is used to create a view.&lt;p&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: created a view&lt;/li&gt;&lt;/ul&gt;&lt;h2&gt;Restrictions for localization extension&lt;/h2&gt; 1. Cannot use &lt;b&gt;&#34;.&#34;&lt;/b&gt; as the key name - &lt;pre&gt;{ &#34;data.2&#34;: &#34;value&#34; }&lt;/pre&gt; 2. Cannot use &lt;b&gt;&#34;$&#34;&lt;/b&gt; as the prefix in key names - &lt;pre&gt;{ &#34;$data&#34;: &#34;value&#34; }&lt;/pre&gt;
   */
  createView(data, queryParams) {
    const params = { ...queryParams };
    const url = "/platform/admin/namespaces/{namespace}/views".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.post(url, data, { params });
    return import_sdk43.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, FullViewInfo, "FullViewInfo");
  }
  /**
   * This API is used to delete a view.It will also delete all the related sections
   */
  deleteView_ByViewId(viewId, queryParams) {
    const params = { ...queryParams };
    const url = "/platform/admin/namespaces/{namespace}/views/{viewId}".replace("{namespace}", this.namespace).replace("{viewId}", viewId);
    const resultPromise = this.axiosInstance.delete(url, { params });
    return import_sdk43.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, import_zod319.z.unknown(), "z.unknown()");
  }
  /**
   * This API is used to get a view.&lt;p&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: view data&lt;/li&gt;&lt;/ul&gt;
   */
  getView_ByViewId(viewId, queryParams) {
    const params = { ...queryParams };
    const url = "/platform/admin/namespaces/{namespace}/views/{viewId}".replace("{namespace}", this.namespace).replace("{viewId}", viewId);
    const resultPromise = this.axiosInstance.get(url, { params });
    return import_sdk43.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, FullViewInfo, "FullViewInfo");
  }
  /**
   * This API is used to update a view.&lt;p&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: updated view data&lt;/li&gt;&lt;/ul&gt;&lt;h2&gt;Restrictions for localization extension&lt;/h2&gt; 1. Cannot use &lt;b&gt;&#34;.&#34;&lt;/b&gt; as the key name - &lt;pre&gt;{ &#34;data.2&#34;: &#34;value&#34; }&lt;/pre&gt; 2. Cannot use &lt;b&gt;&#34;$&#34;&lt;/b&gt; as the prefix in key names - &lt;pre&gt;{ &#34;$data&#34;: &#34;value&#34; }&lt;/pre&gt;
   */
  updateView_ByViewId(viewId, data, queryParams) {
    const params = { ...queryParams };
    const url = "/platform/admin/namespaces/{namespace}/views/{viewId}".replace("{namespace}", this.namespace).replace("{viewId}", viewId);
    const resultPromise = this.axiosInstance.put(url, data, { params });
    return import_sdk43.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, FullViewInfo, "FullViewInfo");
  }
};

// src/generated-admin/endpoints/WalletAdmin$.ts
var import_sdk44 = require("@accelbyte/sdk");
var import_zod337 = require("zod");

// src/generated-definitions/BulkCreditResult.ts
var import_zod322 = require("zod");

// src/generated-definitions/CreditResult.ts
var import_zod321 = require("zod");

// src/generated-definitions/CreditRequest.ts
var import_zod320 = require("zod");
var CreditRequest = import_zod320.z.object({
  amount: import_zod320.z.number().int(),
  expireAt: import_zod320.z.string().nullish(),
  metadata: import_zod320.z.record(import_zod320.z.any()).nullish(),
  origin: import_zod320.z.enum(["Epic", "GooglePlay", "IOS", "Nintendo", "Oculus", "Other", "Playstation", "Steam", "System", "Twitch", "Xbox"]).nullish(),
  reason: import_zod320.z.string().nullish(),
  source: import_zod320.z.enum([
    "ACHIEVEMENT",
    "CONSUME_ENTITLEMENT",
    "DLC",
    "GIFT",
    "IAP",
    "IAP_CHARGEBACK_REVERSED",
    "OTHER",
    "PROMOTION",
    "PURCHASE",
    "REDEEM_CODE",
    "REFERRAL_BONUS",
    "REFUND",
    "REWARD",
    "SELL_BACK",
    "TRADE"
  ]).nullish()
});

// src/generated-definitions/CreditResult.ts
var CreditResult = import_zod321.z.object({
  creditRequest: CreditRequest.nullish(),
  currencyCode: import_zod321.z.string().nullish(),
  reason: import_zod321.z.string().nullish(),
  userId: import_zod321.z.string().nullish()
});

// src/generated-definitions/BulkCreditResult.ts
var BulkCreditResult = import_zod322.z.object({
  failList: import_zod322.z.array(CreditResult).nullish(),
  status: import_zod322.z.enum(["FAIL", "PARTIAL_SUCCESS", "SUCCESS"]).nullish(),
  successList: import_zod322.z.array(CreditResult).nullish()
});

// src/generated-definitions/BulkDebitResult.ts
var import_zod325 = require("zod");

// src/generated-definitions/DebitResult.ts
var import_zod324 = require("zod");

// src/generated-definitions/DebitByCurrencyCodeRequest.ts
var import_zod323 = require("zod");
var DebitByCurrencyCodeRequest = import_zod323.z.object({
  allowOverdraft: import_zod323.z.boolean().nullish(),
  amount: import_zod323.z.number().int(),
  balanceOrigin: import_zod323.z.enum(["Epic", "GooglePlay", "IOS", "Nintendo", "Oculus", "Other", "Playstation", "Steam", "System", "Twitch", "Xbox"]).nullish(),
  balanceSource: import_zod323.z.enum(["DLC_REVOCATION", "EXPIRATION", "IAP_REVOCATION", "ORDER_REVOCATION", "OTHER", "PAYMENT", "TRADE"]).nullish(),
  metadata: import_zod323.z.record(import_zod323.z.any()).nullish(),
  reason: import_zod323.z.string().nullish()
});

// src/generated-definitions/DebitResult.ts
var DebitResult = import_zod324.z.object({
  currencyCode: import_zod324.z.string().nullish(),
  reason: import_zod324.z.string().nullish(),
  request: DebitByCurrencyCodeRequest.nullish(),
  userId: import_zod324.z.string().nullish()
});

// src/generated-definitions/BulkDebitResult.ts
var BulkDebitResult = import_zod325.z.object({
  failList: import_zod325.z.array(DebitResult).nullish(),
  status: import_zod325.z.enum(["FAIL", "PARTIAL_SUCCESS", "SUCCESS"]).nullish(),
  successList: import_zod325.z.array(DebitResult).nullish()
});

// src/generated-definitions/CurrencyWalletArray.ts
var import_zod328 = require("zod");

// src/generated-definitions/CurrencyWallet.ts
var import_zod327 = require("zod");

// src/generated-definitions/WalletInfo.ts
var import_zod326 = require("zod");
var WalletInfo = import_zod326.z.object({
  balance: import_zod326.z.number().int(),
  balanceOrigin: import_zod326.z.string(),
  createdAt: import_zod326.z.string(),
  currencyCode: import_zod326.z.string(),
  currencySymbol: import_zod326.z.string(),
  id: import_zod326.z.string(),
  namespace: import_zod326.z.string(),
  status: import_zod326.z.enum(["ACTIVE", "INACTIVE"]),
  timeLimitedBalances: import_zod326.z.array(TimeLimitedBalance).nullish(),
  totalPermanentBalance: import_zod326.z.number().int().nullish(),
  totalTimeLimitedBalance: import_zod326.z.number().int().nullish(),
  updatedAt: import_zod326.z.string(),
  userId: import_zod326.z.string()
});

// src/generated-definitions/CurrencyWallet.ts
var CurrencyWallet = import_zod327.z.object({
  balance: import_zod327.z.number().int(),
  currencyCode: import_zod327.z.string(),
  currencySymbol: import_zod327.z.string(),
  namespace: import_zod327.z.string(),
  totalPermanentBalance: import_zod327.z.number().int().nullish(),
  totalTimeLimitedBalance: import_zod327.z.number().int().nullish(),
  userId: import_zod327.z.string(),
  walletInfos: import_zod327.z.array(WalletInfo).nullish()
});

// src/generated-definitions/CurrencyWalletArray.ts
var CurrencyWalletArray = import_zod328.z.array(CurrencyWallet);

// src/generated-definitions/DetailedWalletTransactionPagingSlicedResult.ts
var import_zod330 = require("zod");

// src/generated-definitions/DetailedWalletTransactionInfo.ts
var import_zod329 = require("zod");
var DetailedWalletTransactionInfo = import_zod329.z.object({
  amount: import_zod329.z.number().int(),
  balanceSource: import_zod329.z.string().nullish(),
  createdAt: import_zod329.z.string(),
  currencyCode: import_zod329.z.string(),
  namespace: import_zod329.z.string(),
  operator: import_zod329.z.string(),
  reason: import_zod329.z.string().nullish(),
  updatedAt: import_zod329.z.string(),
  userId: import_zod329.z.string(),
  walletAction: import_zod329.z.enum(["CREDIT", "DEBIT", "PAYMENT"]).nullish(),
  walletId: import_zod329.z.string()
});

// src/generated-definitions/DetailedWalletTransactionPagingSlicedResult.ts
var DetailedWalletTransactionPagingSlicedResult = import_zod330.z.object({
  data: import_zod330.z.array(DetailedWalletTransactionInfo),
  paging: Paging.nullish()
});

// src/generated-definitions/PlatformWallet.ts
var import_zod331 = require("zod");
var PlatformWallet = import_zod331.z.object({
  balance: import_zod331.z.number().int(),
  currencyCode: import_zod331.z.string(),
  currencySymbol: import_zod331.z.string(),
  id: import_zod331.z.string().nullish(),
  namespace: import_zod331.z.string(),
  status: import_zod331.z.enum(["ACTIVE", "INACTIVE"]).nullish(),
  transactionId: import_zod331.z.string().nullish(),
  userId: import_zod331.z.string(),
  walletInfos: import_zod331.z.array(WalletInfo).nullish(),
  walletStatus: import_zod331.z.enum(["ACTIVE", "INACTIVE"]).nullish()
});

// src/generated-definitions/PlatformWalletConfigInfo.ts
var import_zod332 = require("zod");
var PlatformWalletConfigInfo = import_zod332.z.object({
  allowedBalanceOrigins: import_zod332.z.array(import_zod332.z.string()),
  createdAt: import_zod332.z.string().nullish(),
  id: import_zod332.z.string().nullish(),
  namespace: import_zod332.z.string(),
  platform: import_zod332.z.string(),
  updatedAt: import_zod332.z.string().nullish()
});

// src/generated-definitions/WalletPagingSlicedResult.ts
var import_zod333 = require("zod");
var WalletPagingSlicedResult = import_zod333.z.object({ data: import_zod333.z.array(WalletInfo), paging: Paging.nullish() });

// src/generated-definitions/WalletTransactionPagingSlicedResult.ts
var import_zod336 = require("zod");

// src/generated-definitions/WalletTransactionInfo.ts
var import_zod335 = require("zod");

// src/generated-definitions/TransactionAmountDetails.ts
var import_zod334 = require("zod");
var TransactionAmountDetails = import_zod334.z.object({
  amount: import_zod334.z.number().int().nullish(),
  expireAt: import_zod334.z.string().nullish(),
  origin: import_zod334.z.string().nullish(),
  walletId: import_zod334.z.string().nullish()
});

// src/generated-definitions/WalletTransactionInfo.ts
var WalletTransactionInfo = import_zod335.z.object({
  amount: import_zod335.z.number().int(),
  balanceSource: import_zod335.z.string().nullish(),
  createdAt: import_zod335.z.string(),
  currencyCode: import_zod335.z.string(),
  metadata: import_zod335.z.record(import_zod335.z.any()).nullish(),
  namespace: import_zod335.z.string(),
  operator: import_zod335.z.string(),
  reason: import_zod335.z.string().nullish(),
  transactionAmountDetails: import_zod335.z.array(TransactionAmountDetails).nullish(),
  updatedAt: import_zod335.z.string(),
  userId: import_zod335.z.string(),
  walletAction: import_zod335.z.enum(["CREDIT", "DEBIT", "PAYMENT"]).nullish()
});

// src/generated-definitions/WalletTransactionPagingSlicedResult.ts
var WalletTransactionPagingSlicedResult = import_zod336.z.object({ data: import_zod336.z.array(WalletTransactionInfo), paging: Paging.nullish() });

// src/generated-admin/endpoints/WalletAdmin$.ts
var WalletAdmin$ = class {
  // @ts-ignore
  // prettier-ignore
  constructor(axiosInstance, namespace, useSchemaValidation = true) {
    this.axiosInstance = axiosInstance;
    this.namespace = namespace;
    this.useSchemaValidation = useSchemaValidation;
  }
  /**
   * @deprecated
   * Query wallets.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: paginated wallets info&lt;/li&gt;&lt;/ul&gt;
   */
  getWallets(queryParams) {
    const params = { limit: 20, ...queryParams };
    const url = "/platform/admin/namespaces/{namespace}/wallets".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.get(url, { params });
    return import_sdk44.Validate.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      WalletPagingSlicedResult,
      "WalletPagingSlicedResult"
    );
  }
  /**
   * Debit different users&#39; wallets.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: bulk credit result&lt;/li&gt;&lt;/ul&gt;
   */
  createWalletDebit(data) {
    const params = {};
    const url = "/platform/admin/namespaces/{namespace}/wallets/debit".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.post(url, data, { params });
    return import_sdk44.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, BulkDebitResult, "BulkDebitResult");
  }
  /**
   * Credit different users&#39; wallets.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: bulk credit result&lt;/li&gt;&lt;/ul&gt;
   */
  createWalletCredit(data) {
    const params = {};
    const url = "/platform/admin/namespaces/{namespace}/wallets/credit".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.post(url, data, { params });
    return import_sdk44.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, BulkCreditResult, "BulkCreditResult");
  }
  /**
   * @deprecated
   * get a wallet by wallet id.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: wallet info&lt;/li&gt;&lt;/ul&gt;
   */
  getWallet_ByWalletId(walletId) {
    const params = {};
    const url = "/platform/admin/namespaces/{namespace}/wallets/{walletId}".replace("{namespace}", this.namespace).replace("{walletId}", walletId);
    const resultPromise = this.axiosInstance.get(url, { params });
    return import_sdk44.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, WalletInfo, "WalletInfo");
  }
  /**
   * @deprecated
   * get a user wallet.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: wallet info&lt;/li&gt;&lt;/ul&gt;
   */
  getWallet_ByUserId_ByWalletId(userId, walletId) {
    const params = {};
    const url = "/platform/admin/namespaces/{namespace}/users/{userId}/wallets/{walletId}".replace("{namespace}", this.namespace).replace("{userId}", userId).replace("{walletId}", walletId);
    const resultPromise = this.axiosInstance.get(url, { params });
    return import_sdk44.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, WalletInfo, "WalletInfo");
  }
  /**
   * Get platform wallet config list.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: wallet info&lt;/li&gt;&lt;/ul&gt;
   */
  getWalletConfig_ByPlatform(platform) {
    const params = {};
    const url = "/platform/admin/namespaces/{namespace}/platforms/{platform}/wallet/config".replace("{namespace}", this.namespace).replace("{platform}", platform);
    const resultPromise = this.axiosInstance.get(url, { params });
    return import_sdk44.Validate.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      PlatformWalletConfigInfo,
      "PlatformWalletConfigInfo"
    );
  }
  /**
   * Update platform wallet config.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: platform wallet config&lt;/li&gt;&lt;/ul&gt;
   */
  updateWalletConfig_ByPlatform(platform, data) {
    const params = {};
    const url = "/platform/admin/namespaces/{namespace}/platforms/{platform}/wallet/config".replace("{namespace}", this.namespace).replace("{platform}", platform);
    const resultPromise = this.axiosInstance.put(url, data, { params });
    return import_sdk44.Validate.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      PlatformWalletConfigInfo,
      "PlatformWalletConfigInfo"
    );
  }
  /**
   * @deprecated
   * Debit a user wallet.
   */
  updateDebit_ByUserId_ByWalletId(userId, walletId, data) {
    const params = {};
    const url = "/platform/admin/namespaces/{namespace}/users/{userId}/wallets/{walletId}/debit".replace("{namespace}", this.namespace).replace("{userId}", userId).replace("{walletId}", walletId);
    const resultPromise = this.axiosInstance.put(url, data, { params });
    return import_sdk44.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, WalletInfo, "WalletInfo");
  }
  /**
   * Reset platform wallet config to default config.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: platform wallet config&lt;/li&gt;&lt;/ul&gt;
   */
  updateWalletConfigReset_ByPlatform(platform) {
    const params = {};
    const url = "/platform/admin/namespaces/{namespace}/platforms/{platform}/wallet/config/reset".replace("{namespace}", this.namespace).replace("{platform}", platform);
    const resultPromise = this.axiosInstance.put(url, null, { params });
    return import_sdk44.Validate.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      PlatformWalletConfigInfo,
      "PlatformWalletConfigInfo"
    );
  }
  /**
   * @deprecated
   * enable a user wallet.
   */
  updateEnable_ByUserId_ByWalletId(userId, walletId) {
    const params = {};
    const url = "/platform/admin/namespaces/{namespace}/users/{userId}/wallets/{walletId}/enable".replace("{namespace}", this.namespace).replace("{userId}", userId).replace("{walletId}", walletId);
    const resultPromise = this.axiosInstance.put(url, null, { params });
    return import_sdk44.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, import_zod337.z.unknown(), "z.unknown()");
  }
  /**
   * @deprecated
   * disable a user wallet.
   */
  updateDisable_ByUserId_ByWalletId(userId, walletId) {
    const params = {};
    const url = "/platform/admin/namespaces/{namespace}/users/{userId}/wallets/{walletId}/disable".replace("{namespace}", this.namespace).replace("{userId}", userId).replace("{walletId}", walletId);
    const resultPromise = this.axiosInstance.put(url, null, { params });
    return import_sdk44.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, import_zod337.z.unknown(), "z.unknown()");
  }
  /**
   * Get user currency wallet summary.&lt;br&gt;Other detail info: &lt;ul&gt;(READ)&lt;/li&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: currency wallet summary&lt;/li&gt;&lt;/ul&gt;
   */
  getWalletsCurrenciesSummary_ByUserId(userId) {
    const params = {};
    const url = "/platform/admin/namespaces/{namespace}/users/{userId}/wallets/currencies/summary".replace("{namespace}", this.namespace).replace("{userId}", userId);
    const resultPromise = this.axiosInstance.get(url, { params });
    return import_sdk44.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, CurrencyWalletArray, "CurrencyWalletArray");
  }
  /**
   * @deprecated
   * &lt;b&gt;[SERVICE COMMUNICATION ONLY]&lt;/b&gt; Check wallet by balance origin and currency code whether it&#39;s inactive.
   */
  getCheck_ByUserId_ByCurrencyCode(userId, currencyCode, queryParams) {
    const params = { ...queryParams };
    const url = "/platform/admin/namespaces/{namespace}/users/{userId}/wallets/{currencyCode}/check".replace("{namespace}", this.namespace).replace("{userId}", userId).replace("{currencyCode}", currencyCode);
    const resultPromise = this.axiosInstance.get(url, { params });
    return import_sdk44.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, import_zod337.z.unknown(), "z.unknown()");
  }
  /**
   * Credit a user wallet by currency code and balance origin, if wallet not exists, it will create a new wallet.&lt;br&gt;Other detail info: &lt;ul&gt;(UPDATE)&lt;/li&gt;&lt;/ul&gt;
   */
  updateCredit_ByUserId_ByCurrencyCode(userId, currencyCode, data) {
    const params = {};
    const url = "/platform/admin/namespaces/{namespace}/users/{userId}/wallets/{currencyCode}/credit".replace("{namespace}", this.namespace).replace("{userId}", userId).replace("{currencyCode}", currencyCode);
    const resultPromise = this.axiosInstance.put(url, data, { params });
    return import_sdk44.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, WalletInfo, "WalletInfo");
  }
  /**
   * Pay with user wallet by currency code and client platform.
   */
  updatePayment_ByUserId_ByCurrencyCode(userId, currencyCode, data) {
    const params = {};
    const url = "/platform/admin/namespaces/{namespace}/users/{userId}/wallets/{currencyCode}/payment".replace("{namespace}", this.namespace).replace("{userId}", userId).replace("{currencyCode}", currencyCode);
    const resultPromise = this.axiosInstance.put(url, data, { params });
    return import_sdk44.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, PlatformWallet, "PlatformWallet");
  }
  /**
   * @deprecated
   * List user wallet transactions ordered by create time desc.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;/li&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: wallet transaction info&lt;/li&gt;&lt;/ul&gt;
   */
  getTransactions_ByUserId_ByWalletId(userId, walletId, queryParams) {
    const params = { limit: 20, ...queryParams };
    const url = "/platform/admin/namespaces/{namespace}/users/{userId}/wallets/{walletId}/transactions".replace("{namespace}", this.namespace).replace("{userId}", userId).replace("{walletId}", walletId);
    const resultPromise = this.axiosInstance.get(url, { params });
    return import_sdk44.Validate.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      DetailedWalletTransactionPagingSlicedResult,
      "DetailedWalletTransactionPagingSlicedResult"
    );
  }
  /**
   * Checks if the user has enough balance based on the provided criteria.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: boolean value indicating if the user has enough balance&lt;/li&gt;&lt;/ul&gt;
   */
  createBalanceCheck_ByUserId_ByCurrencyCode(userId, currencyCode, data) {
    const params = {};
    const url = "/platform/admin/namespaces/{namespace}/users/{userId}/wallets/{currencyCode}/balanceCheck".replace("{namespace}", this.namespace).replace("{userId}", userId).replace("{currencyCode}", currencyCode);
    const resultPromise = this.axiosInstance.post(url, data, { params });
    return import_sdk44.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, import_zod337.z.unknown(), "z.unknown()");
  }
  /**
   * Debit a user wallet by currency code, default is debit system wallet.
   */
  updateDebitWallet_ByUserId_ByCurrencyCode(userId, currencyCode, data) {
    const params = {};
    const url = "/platform/admin/namespaces/{namespace}/users/{userId}/wallets/currencies/{currencyCode}/debit".replace("{namespace}", this.namespace).replace("{userId}", userId).replace("{currencyCode}", currencyCode);
    const resultPromise = this.axiosInstance.put(url, data, { params });
    return import_sdk44.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, WalletInfo, "WalletInfo");
  }
  /**
   * Pay with user wallet by currency code and client platform.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;/ul&gt;&lt;h2&gt;Restrictions for metadata&lt;/h2&gt; 1. Cannot use &lt;b&gt;&#34;.&#34;&lt;/b&gt; as the key name - &lt;pre&gt;{ &#34;data.2&#34;: &#34;value&#34; }&lt;/pre&gt; 2. Cannot use &lt;b&gt;&#34;$&#34;&lt;/b&gt; as the prefix in key names - &lt;pre&gt;{ &#34;$data&#34;: &#34;value&#34; }&lt;/pre&gt;
   */
  updateDebitByWalletPlatform_ByUserId_ByCurrencyCode(userId, currencyCode, data) {
    const params = {};
    const url = "/platform/admin/namespaces/{namespace}/users/{userId}/wallets/{currencyCode}/debitByWalletPlatform".replace("{namespace}", this.namespace).replace("{userId}", userId).replace("{currencyCode}", currencyCode);
    const resultPromise = this.axiosInstance.put(url, data, { params });
    return import_sdk44.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, PlatformWallet, "PlatformWallet");
  }
  /**
   * List user currency transactions ordered by create time desc.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;/li&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: currency transaction info&lt;/li&gt;&lt;/ul&gt;
   */
  getTransactionsWallets_ByUserId_ByCurrencyCode(userId, currencyCode, queryParams) {
    const params = { limit: 20, ...queryParams };
    const url = "/platform/admin/namespaces/{namespace}/users/{userId}/wallets/currencies/{currencyCode}/transactions".replace("{namespace}", this.namespace).replace("{userId}", userId).replace("{currencyCode}", currencyCode);
    const resultPromise = this.axiosInstance.get(url, { params });
    return import_sdk44.Validate.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      WalletTransactionPagingSlicedResult,
      "WalletTransactionPagingSlicedResult"
    );
  }
};

// src/generated-admin/EntitlementAdminApi.ts
var import_sdk45 = require("@accelbyte/sdk");
function EntitlementAdminApi(sdk, args) {
  const sdkAssembly = sdk.assembly();
  const namespace = args?.coreConfig?.namespace ?? sdkAssembly.coreConfig.namespace;
  const useSchemaValidation = args?.coreConfig?.useSchemaValidation ?? sdkAssembly.coreConfig.useSchemaValidation;
  let axiosInstance = sdkAssembly.axiosInstance;
  const requestConfigOverrides = args?.axiosConfig?.request;
  const baseURLOverride = args?.coreConfig?.baseURL;
  const interceptorsOverride = args?.axiosConfig?.interceptors ?? [];
  if (requestConfigOverrides || baseURLOverride || interceptorsOverride.length > 0) {
    const requestConfig = import_sdk45.ApiUtils.mergeAxiosConfigs(sdkAssembly.axiosInstance.defaults, {
      ...baseURLOverride ? { baseURL: baseURLOverride } : {},
      ...requestConfigOverrides
    });
    axiosInstance = import_sdk45.Network.create(requestConfig);
    for (const interceptor of interceptorsOverride) {
      if (interceptor.type === "request") {
        axiosInstance.interceptors.request.use(interceptor.onRequest, interceptor.onError);
      }
      if (interceptor.type === "response") {
        axiosInstance.interceptors.response.use(interceptor.onSuccess, interceptor.onError);
      }
    }
  }
  async function getEntitlements(queryParams) {
    const $ = new EntitlementAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getEntitlements(queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function createEntitlementGrant(data) {
    const $ = new EntitlementAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.createEntitlementGrant(data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function createEntitlementRevoke(data) {
    const $ = new EntitlementAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.createEntitlementRevoke(data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getEntitlementsByItemIds(queryParams) {
    const $ = new EntitlementAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getEntitlementsByItemIds(queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getEntitlementsConfigInfo(queryParams) {
    const $ = new EntitlementAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getEntitlementsConfigInfo(queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getEntitlements_ByUserId(userId, queryParams) {
    const $ = new EntitlementAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getEntitlements_ByUserId(userId, queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function createEntitlement_ByUserId(userId, data) {
    const $ = new EntitlementAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.createEntitlement_ByUserId(userId, data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getEntitlement_ByEntitlementId(entitlementId) {
    const $ = new EntitlementAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getEntitlement_ByEntitlementId(entitlementId);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getEntitlementsBySku_ByUserId(userId, queryParams) {
    const $ = new EntitlementAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getEntitlementsBySku_ByUserId(userId, queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function updateEntitlementRevoke_ByUserId(userId) {
    const $ = new EntitlementAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.updateEntitlementRevoke_ByUserId(userId);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getEntitlementsByAppId_ByUserId(userId, queryParams) {
    const $ = new EntitlementAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getEntitlementsByAppId_ByUserId(userId, queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getEntitlementsByItemId_ByUserId(userId, queryParams) {
    const $ = new EntitlementAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getEntitlementsByItemId_ByUserId(userId, queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getEntitlementsByAppType_ByUserId(userId, queryParams) {
    const $ = new EntitlementAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getEntitlementsByAppType_ByUserId(userId, queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getEntitlementsByItemIds_ByUserId(userId, queryParams) {
    const $ = new EntitlementAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getEntitlementsByItemIds_ByUserId(userId, queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getEntitlementConfig_ByPlatform(platform) {
    const $ = new EntitlementAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getEntitlementConfig_ByPlatform(platform);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function updateEntitlementConfig_ByPlatform(platform, data) {
    const $ = new EntitlementAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.updateEntitlementConfig_ByPlatform(platform, data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function updateEntitlementRevokeById_ByUserId(userId, queryParams) {
    const $ = new EntitlementAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.updateEntitlementRevokeById_ByUserId(userId, queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getEntitlementsOwnershipAny_ByUserId(userId, queryParams) {
    const $ = new EntitlementAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getEntitlementsOwnershipAny_ByUserId(userId, queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getEntitlement_ByUserId_ByEntitlementId(userId, entitlementId) {
    const $ = new EntitlementAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getEntitlement_ByUserId_ByEntitlementId(userId, entitlementId);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function updateEntitlement_ByUserId_ByEntitlementId(userId, entitlementId, data) {
    const $ = new EntitlementAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.updateEntitlement_ByUserId_ByEntitlementId(userId, entitlementId, data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getEntitlementsOwnershipAnyOf_ByUserId(userId, queryParams) {
    const $ = new EntitlementAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getEntitlementsOwnershipAnyOf_ByUserId(userId, queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getEntitlementsOwnershipBySku_ByUserId(userId, queryParams) {
    const $ = new EntitlementAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getEntitlementsOwnershipBySku_ByUserId(userId, queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function updateEntitlementConfigEntitlementOriginEnable() {
    const $ = new EntitlementAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.updateEntitlementConfigEntitlementOriginEnable();
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getEntitlementsOwnershipByAppId_ByUserId(userId, queryParams) {
    const $ = new EntitlementAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getEntitlementsOwnershipByAppId_ByUserId(userId, queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getEntitlementsOwnershipByItemId_ByUserId(userId, queryParams) {
    const $ = new EntitlementAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getEntitlementsOwnershipByItemId_ByUserId(userId, queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getEntitlementsOwnershipByItemIds_ByUserId(userId, queryParams) {
    const $ = new EntitlementAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getEntitlementsOwnershipByItemIds_ByUserId(userId, queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function updateSell_ByUserId_ByEntitlementId(userId, entitlementId, data) {
    const $ = new EntitlementAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.updateSell_ByUserId_ByEntitlementId(userId, entitlementId, data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function updateEnable_ByUserId_ByEntitlementId(userId, entitlementId) {
    const $ = new EntitlementAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.updateEnable_ByUserId_ByEntitlementId(userId, entitlementId);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function updateRevoke_ByUserId_ByEntitlementId(userId, entitlementId, data) {
    const $ = new EntitlementAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.updateRevoke_ByUserId_ByEntitlementId(userId, entitlementId, data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function updateDisable_ByUserId_ByEntitlementId(userId, entitlementId) {
    const $ = new EntitlementAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.updateDisable_ByUserId_ByEntitlementId(userId, entitlementId);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getHistory_ByUserId_ByEntitlementId(userId, entitlementId) {
    const $ = new EntitlementAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getHistory_ByUserId_ByEntitlementId(userId, entitlementId);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function updateDecrement_ByUserId_ByEntitlementId(userId, entitlementId, data) {
    const $ = new EntitlementAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.updateDecrement_ByUserId_ByEntitlementId(userId, entitlementId, data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function updateRevokeByUseCount_ByUserId_ByEntitlementId(userId, entitlementId, data) {
    const $ = new EntitlementAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.updateRevokeByUseCount_ByUserId_ByEntitlementId(userId, entitlementId, data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function createRevokeByUseCount_ByUserId_ByEntitlementId(userId, entitlementId, data) {
    const $ = new EntitlementAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.createRevokeByUseCount_ByUserId_ByEntitlementId(userId, entitlementId, data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getRevokeByUseCountPreCheck_ByUserId_ByEntitlementId(userId, entitlementId, queryParams) {
    const $ = new EntitlementAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getRevokeByUseCountPreCheck_ByUserId_ByEntitlementId(userId, entitlementId, queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  return {
    /**
     * Query entitlements.&lt;p&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: entitlement list&lt;/li&gt;&lt;/ul&gt;
     */
    getEntitlements,
    /**
     * Grant entitlements to multiple users, skipped granting will be treated as fail.&lt;br&gt;&lt;br&gt;Notes: &lt;br&gt;&lt;br&gt;Support Item Types:&lt;ul&gt;&lt;li&gt;&lt;i&gt;APP&lt;/i&gt;&lt;/li&gt;&lt;li&gt;&lt;i&gt;INGAMEITEM&lt;/i&gt;&lt;/li&gt;&lt;li&gt;&lt;i&gt;CODE&lt;/i&gt;&lt;/li&gt;&lt;li&gt;&lt;i&gt;SUBSCRIPTION&lt;/i&gt;&lt;/li&gt;&lt;li&gt;&lt;i&gt;MEDIA&lt;/i&gt;&lt;/li&gt;&lt;li&gt;&lt;i&gt;OPTIONBOX&lt;/i&gt;&lt;/li&gt;&lt;li&gt;&lt;i&gt;LOOTBOX&lt;/i&gt;&lt;/li&gt;&lt;/ul&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: bulk grant entitlements result&lt;/li&gt;&lt;/ul&gt;
     */
    createEntitlementGrant,
    /**
     * Revoke entitlements, skipped revocation will be treated as fail.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: bulk revoke entitlements result&lt;/li&gt;&lt;/ul&gt;
     */
    createEntitlementRevoke,
    /**
     * Query entitlements by Item Ids.&lt;p&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: entitlement list&lt;/li&gt;&lt;/ul&gt;
     */
    getEntitlementsByItemIds,
    /**
     * Get entitlement config info.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: entitlement info&lt;/li&gt;&lt;/ul&gt;
     */
    getEntitlementsConfigInfo,
    /**
     * Query entitlements for a specific user.&lt;p&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: entitlement list&lt;/li&gt;&lt;/ul&gt;
     */
    getEntitlements_ByUserId,
    /**
     * Grant user entitlement.&lt;br&gt;&lt;br&gt;Notes: &lt;br&gt;&lt;br&gt;will skip un-supported item if input un-supported item types, please use /admin/namespaces/{namespace}/users/{userId}/fulfillment endpoint if want to fulfill other item type, like coin item&lt;br&gt;&lt;br&gt;Support Item Types:&lt;ul&gt;&lt;li&gt;&lt;i&gt;APP&lt;/i&gt;&lt;/li&gt;&lt;li&gt;&lt;i&gt;INGAMEITEM&lt;/i&gt;&lt;/li&gt;&lt;li&gt;&lt;i&gt;CODE&lt;/i&gt;&lt;/li&gt;&lt;li&gt;&lt;i&gt;SUBSCRIPTION&lt;/i&gt;&lt;/li&gt;&lt;li&gt;&lt;i&gt;MEDIA&lt;/i&gt;&lt;/li&gt;&lt;li&gt;&lt;i&gt;OPTIONBOX&lt;/i&gt;&lt;/li&gt;&lt;li&gt;&lt;i&gt;LOOTBOX&lt;/i&gt;&lt;/li&gt;&lt;/ul&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: granted entitlement&lt;/li&gt;&lt;/ul&gt;
     */
    createEntitlement_ByUserId,
    /**
     * Get entitlement.&lt;p&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: entitlement&lt;/li&gt;&lt;/ul&gt;
     */
    getEntitlement_ByEntitlementId,
    /**
     * Get user entitlement by sku.
     */
    getEntitlementsBySku_ByUserId,
    /**
     * Revoke all entitlements of a user (This API is for testing purpose only)&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: revoked entitlements count&lt;/li&gt;&lt;/ul&gt;
     */
    updateEntitlementRevoke_ByUserId,
    /**
     * Get user app entitlement by appId.
     */
    getEntitlementsByAppId_ByUserId,
    /**
     * Get user entitlement by itemId.
     */
    getEntitlementsByItemId_ByUserId,
    /**
     * Query app entitlements by appType.&lt;p&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: app entitlement pagination&lt;/li&gt;&lt;/ul&gt;
     */
    getEntitlementsByAppType_ByUserId,
    /**
     * Get user entitlements by itemIds.
     */
    getEntitlementsByItemIds_ByUserId,
    /**
     * Get platform entitlement config list.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: entitlement info&lt;/li&gt;&lt;/ul&gt;
     */
    getEntitlementConfig_ByPlatform,
    /**
     * Update platform entitlement config.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: platform entitlement config&lt;/li&gt;&lt;/ul&gt;
     */
    updateEntitlementConfig_ByPlatform,
    /**
     * Revoke user&#39;s entitlements by ids.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: revoke entitlements count&lt;/li&gt;&lt;/ul&gt;
     */
    updateEntitlementRevokeById_ByUserId,
    /**
     * Exists any user active entitlement of specified itemIds, skus and appIds
     */
    getEntitlementsOwnershipAny_ByUserId,
    /**
     * Get user entitlement.&lt;p&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: entitlement&lt;/li&gt;&lt;/ul&gt;
     */
    getEntitlement_ByUserId_ByEntitlementId,
    /**
     * Update user entitlement. If update CONSUMABLE entitlement useCount to 0, the status will be CONSUMED.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: updated entitlement&lt;/li&gt;&lt;/ul&gt;
     */
    updateEntitlement_ByUserId_ByEntitlementId,
    /**
     * Exists any user active entitlement of specified items.
     */
    getEntitlementsOwnershipAnyOf_ByUserId,
    /**
     * Get user entitlement ownership by sku.
     */
    getEntitlementsOwnershipBySku_ByUserId,
    /**
     * Enable Entitlement origin feature.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: entitlement info&lt;/li&gt;&lt;/ul&gt;
     */
    updateEntitlementConfigEntitlementOriginEnable,
    /**
     * Get user app entitlement ownership by appId.
     */
    getEntitlementsOwnershipByAppId_ByUserId,
    /**
     * Get user entitlement ownership by itemId.
     */
    getEntitlementsOwnershipByItemId_ByUserId,
    /**
     * Get user entitlement ownership by itemIds.
     */
    getEntitlementsOwnershipByItemIds_ByUserId,
    /**
     * Sell user entitlement. If the entitlement is consumable, useCount is 0, the status will be CONSUMED. If the entitlement is durable, the status will be SOLD. Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: entitlement&lt;/li&gt;&lt;/ul&gt;
     */
    updateSell_ByUserId_ByEntitlementId,
    /**
     * Enable user entitlement.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: enable entitlement&lt;/li&gt;&lt;/ul&gt;
     */
    updateEnable_ByUserId_ByEntitlementId,
    /**
     * Revoke user entitlement.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: revoke entitlement&lt;/li&gt;&lt;/ul&gt;
     */
    updateRevoke_ByUserId_ByEntitlementId,
    /**
     * Disable user entitlement if entitlement, only active entitlement can be disable, disabled entitlement can&#39;t consume.&lt;br&gt;&lt;b&gt;Like revoke, it will lose the entitlement ownership, except disabled entitlement can enable.&lt;/b&gt;&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: disable entitlement&lt;/li&gt;&lt;/ul&gt;
     */
    updateDisable_ByUserId_ByEntitlementId,
    /**
     * Get user entitlement histories.&lt;p&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: list of entitlement history&lt;/li&gt;&lt;/ul&gt;
     */
    getHistory_ByUserId_ByEntitlementId,
    /**
     * Consume user entitlement. If the entitlement useCount is 0, the status will be CONSUMED.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: consumed entitlement&lt;/li&gt;&lt;/ul&gt;
     */
    updateDecrement_ByUserId_ByEntitlementId,
    /**
     * @deprecated
     * Revoke specified use count of user entitlement. please use /{entitlementId}/revoke/byUseCount endpoint instead of this endpoint&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: revoke entitlement&lt;/li&gt;&lt;/ul&gt;
     */
    updateRevokeByUseCount_ByUserId_ByEntitlementId,
    /**
     * Revoke specified count of user entitlement.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: The revoked entitlement&lt;/li&gt;&lt;/ul&gt;
     */
    createRevokeByUseCount_ByUserId_ByEntitlementId,
    /**
     * Checks if specified use count of user entitlement can be revoked without actually revoking it.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: true if revokable, false otherwise&lt;/li&gt;&lt;/ul&gt;
     */
    getRevokeByUseCountPreCheck_ByUserId_ByEntitlementId
  };
}

// src/generated-admin/FulfillmentAdminApi.ts
var import_sdk46 = require("@accelbyte/sdk");
function FulfillmentAdminApi(sdk, args) {
  const sdkAssembly = sdk.assembly();
  const namespace = args?.coreConfig?.namespace ?? sdkAssembly.coreConfig.namespace;
  const useSchemaValidation = args?.coreConfig?.useSchemaValidation ?? sdkAssembly.coreConfig.useSchemaValidation;
  let axiosInstance = sdkAssembly.axiosInstance;
  const requestConfigOverrides = args?.axiosConfig?.request;
  const baseURLOverride = args?.coreConfig?.baseURL;
  const interceptorsOverride = args?.axiosConfig?.interceptors ?? [];
  if (requestConfigOverrides || baseURLOverride || interceptorsOverride.length > 0) {
    const requestConfig = import_sdk46.ApiUtils.mergeAxiosConfigs(sdkAssembly.axiosInstance.defaults, {
      ...baseURLOverride ? { baseURL: baseURLOverride } : {},
      ...requestConfigOverrides
    });
    axiosInstance = import_sdk46.Network.create(requestConfig);
    for (const interceptor of interceptorsOverride) {
      if (interceptor.type === "request") {
        axiosInstance.interceptors.request.use(interceptor.onRequest, interceptor.onError);
      }
      if (interceptor.type === "response") {
        axiosInstance.interceptors.response.use(interceptor.onSuccess, interceptor.onError);
      }
    }
  }
  async function getFulfillments_v2(queryParams) {
    const $ = new FulfillmentAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getFulfillments_v2(queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getFulfillmentHistory(queryParams) {
    const $ = new FulfillmentAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getFulfillmentHistory(queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function createFulfillment_ByUserId(userId, data) {
    const $ = new FulfillmentAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.createFulfillment_ByUserId(userId, data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function createFulfillmentCode_ByUserId(userId, data) {
    const $ = new FulfillmentAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.createFulfillmentCode_ByUserId(userId, data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function createFulfillmentReward_ByUserId(userId, data) {
    const $ = new FulfillmentAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.createFulfillmentReward_ByUserId(userId, data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function createFulfillmentPreCheck_ByUserId(userId, data) {
    const $ = new FulfillmentAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.createFulfillmentPreCheck_ByUserId(userId, data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function createFulfillmentReward_ByUserId_v2(userId, data) {
    const $ = new FulfillmentAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.createFulfillmentReward_ByUserId_v2(userId, data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function updateFulfillment_ByUserId_ByTransactionId_v2(userId, transactionId, data) {
    const $ = new FulfillmentAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.updateFulfillment_ByUserId_ByTransactionId_v2(userId, transactionId, data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function updateRetry_ByUserId_ByTransactionId_v2(userId, transactionId) {
    const $ = new FulfillmentAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.updateRetry_ByUserId_ByTransactionId_v2(userId, transactionId);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function updateRevoke_ByUserId_ByTransactionId_v2(userId, transactionId) {
    const $ = new FulfillmentAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.updateRevoke_ByUserId_ByTransactionId_v2(userId, transactionId);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  return {
    /**
     * &lt;b&gt;[Not supported yet in AGS Shared Cloud]&lt;/b&gt; Query fulfillments in a namespace.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: list of fulfillment info:&lt;ul&gt;&lt;li&gt;storeId in items can be ignored&lt;/li&gt;&lt;li&gt;error in successList will always be null&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;/ul&gt;
     */
    getFulfillments_v2,
    /**
     * Query fulfillment histories in a namespace.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: query fulfillment history&lt;/li&gt;&lt;/ul&gt;
     */
    getFulfillmentHistory,
    /**
     * Fulfill item.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: fulfillment result&lt;/li&gt;&lt;/ul&gt;
     */
    createFulfillment_ByUserId,
    /**
     * Redeem campaign code.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: fulfillment result&lt;/li&gt;&lt;/ul&gt;
     */
    createFulfillmentCode_ByUserId,
    /**
     * &lt;b&gt;[SERVICE COMMUNICATION ONLY]&lt;/b&gt; Fulfill rewards.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: fulfillment result&lt;/li&gt;&lt;/ul&gt;
     */
    createFulfillmentReward_ByUserId,
    /**
     * Retrieve and check fulfillment items based on the provided request.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: list of fulfillment items&lt;/li&gt;&lt;/ul&gt;
     */
    createFulfillmentPreCheck_ByUserId,
    /**
     * &lt;b&gt;[SERVICE COMMUNICATION ONLY]&lt;/b&gt; Fulfill rewards.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: fulfillment result&lt;/li&gt;&lt;li&gt;&lt;i&gt;rewards Item unsupported Type&lt;/i&gt;: SUBSCRIPTION&lt;/ul&gt;
     */
    createFulfillmentReward_ByUserId_v2,
    /**
     * &lt;b&gt;[Not supported yet in AGS Shared Cloud]&lt;/b&gt; Fulfill items by transactionId.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Request body&lt;/i&gt;: storeId, region, language, and entitlementCollectionId can be ignored.&lt;/li&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: fulfillment v2 result, storeId field can be ignored.&lt;/li&gt;&lt;/ul&gt;
     */
    updateFulfillment_ByUserId_ByTransactionId_v2,
    /**
     * &lt;b&gt;[Not supported yet in AGS Shared Cloud]&lt;/b&gt; Retry fulfill items by transactionId without sending the original payload.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: fulfillment v2 result, storeId field can be ignored.&lt;/li&gt;&lt;/ul&gt;
     */
    updateRetry_ByUserId_ByTransactionId_v2,
    /**
     * &lt;b&gt;[Not supported yet in AGS Shared Cloud]&lt;/b&gt; Revoke items by transactionId.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: revoke fulfillment v2 result, storeId field can be ignored.&lt;/li&gt;&lt;/ul&gt;
     */
    updateRevoke_ByUserId_ByTransactionId_v2
  };
}

// src/generated-admin/FulfillmentScriptAdminApi.ts
var import_sdk47 = require("@accelbyte/sdk");
function FulfillmentScriptAdminApi(sdk, args) {
  const sdkAssembly = sdk.assembly();
  const namespace = args?.coreConfig?.namespace ?? sdkAssembly.coreConfig.namespace;
  const useSchemaValidation = args?.coreConfig?.useSchemaValidation ?? sdkAssembly.coreConfig.useSchemaValidation;
  let axiosInstance = sdkAssembly.axiosInstance;
  const requestConfigOverrides = args?.axiosConfig?.request;
  const baseURLOverride = args?.coreConfig?.baseURL;
  const interceptorsOverride = args?.axiosConfig?.interceptors ?? [];
  if (requestConfigOverrides || baseURLOverride || interceptorsOverride.length > 0) {
    const requestConfig = import_sdk47.ApiUtils.mergeAxiosConfigs(sdkAssembly.axiosInstance.defaults, {
      ...baseURLOverride ? { baseURL: baseURLOverride } : {},
      ...requestConfigOverrides
    });
    axiosInstance = import_sdk47.Network.create(requestConfig);
    for (const interceptor of interceptorsOverride) {
      if (interceptor.type === "request") {
        axiosInstance.interceptors.request.use(interceptor.onRequest, interceptor.onError);
      }
      if (interceptor.type === "response") {
        axiosInstance.interceptors.response.use(interceptor.onSuccess, interceptor.onError);
      }
    }
  }
  async function getFulfillmentScripts() {
    const $ = new FulfillmentScriptAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getFulfillmentScripts();
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function deleteFulfillmentScript_ById(id) {
    const $ = new FulfillmentScriptAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.deleteFulfillmentScript_ById(id);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getFulfillmentScript_ById(id) {
    const $ = new FulfillmentScriptAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getFulfillmentScript_ById(id);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function patchFulfillmentScript_ById(id, data) {
    const $ = new FulfillmentScriptAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.patchFulfillmentScript_ById(id, data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function createFulfillmentScript_ById(id, data) {
    const $ = new FulfillmentScriptAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.createFulfillmentScript_ById(id, data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  return {
    /**
     * &lt;b&gt;[Not supported yet in AGS Shared Cloud]&lt;/b&gt;List all fulfillment scripts.
     */
    getFulfillmentScripts,
    /**
     * &lt;b&gt;[Not supported yet in AGS Shared Cloud]&lt;/b&gt;Delete fulfillment script.
     */
    deleteFulfillmentScript_ById,
    /**
     * &lt;b&gt;[Not supported yet in AGS Shared Cloud]&lt;/b&gt;Get fulfillment script by id.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: get fulfillment script&lt;/li&gt;&lt;/ul&gt;
     */
    getFulfillmentScript_ById,
    /**
     * &lt;b&gt;[Not supported yet in AGS Shared Cloud]&lt;/b&gt;Update fulfillment script.
     */
    patchFulfillmentScript_ById,
    /**
     * &lt;b&gt;[Not supported yet in AGS Shared Cloud]&lt;/b&gt;Create fulfillment script.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;/ul&gt;Fulfillment scripts are used for adding custom fulfillment logic based on &lt;b&gt;ITEM_TYPE&lt;/b&gt;: [MEDIA,INGAMEITEM] for now, and the custom scripts only cover grantDays.&lt;br&gt;Example for grantDays: &lt;br&gt;&lt;code&gt;order &amp;&amp; ((order.currency &amp;&amp; order.currency.currencyCode) == &#39;LP&#39; || order.isFree) ? 30 : -1&lt;/code&gt;&lt;br&gt;
     */
    createFulfillmentScript_ById
  };
}

// src/generated-admin/IapAdminApi.ts
var import_sdk48 = require("@accelbyte/sdk");
function IapAdminApi(sdk, args) {
  const sdkAssembly = sdk.assembly();
  const namespace = args?.coreConfig?.namespace ?? sdkAssembly.coreConfig.namespace;
  const useSchemaValidation = args?.coreConfig?.useSchemaValidation ?? sdkAssembly.coreConfig.useSchemaValidation;
  let axiosInstance = sdkAssembly.axiosInstance;
  const requestConfigOverrides = args?.axiosConfig?.request;
  const baseURLOverride = args?.coreConfig?.baseURL;
  const interceptorsOverride = args?.axiosConfig?.interceptors ?? [];
  if (requestConfigOverrides || baseURLOverride || interceptorsOverride.length > 0) {
    const requestConfig = import_sdk48.ApiUtils.mergeAxiosConfigs(sdkAssembly.axiosInstance.defaults, {
      ...baseURLOverride ? { baseURL: baseURLOverride } : {},
      ...requestConfigOverrides
    });
    axiosInstance = import_sdk48.Network.create(requestConfig);
    for (const interceptor of interceptorsOverride) {
      if (interceptor.type === "request") {
        axiosInstance.interceptors.request.use(interceptor.onRequest, interceptor.onError);
      }
      if (interceptor.type === "response") {
        axiosInstance.interceptors.response.use(interceptor.onSuccess, interceptor.onError);
      }
    }
  }
  async function deleteIapConfigXbl() {
    const $ = new IapAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.deleteIapConfigXbl();
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getIapConfigXbl() {
    const $ = new IapAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getIapConfigXbl();
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function updateIapConfigXbl(data) {
    const $ = new IapAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.updateIapConfigXbl(data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function deleteIapConfigItem() {
    const $ = new IapAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.deleteIapConfigItem();
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getIapConfigItem() {
    const $ = new IapAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getIapConfigItem();
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function updateIapConfigItem(data) {
    const $ = new IapAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.updateIapConfigItem(data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function deleteIapConfigApple() {
    const $ = new IapAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.deleteIapConfigApple();
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getIapConfigApple() {
    const $ = new IapAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getIapConfigApple();
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function updateIapConfigApple(data) {
    const $ = new IapAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.updateIapConfigApple(data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function deleteIapConfigSteam() {
    const $ = new IapAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.deleteIapConfigSteam();
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getIapConfigSteam() {
    const $ = new IapAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getIapConfigSteam();
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function updateIapConfigSteam(data) {
    const $ = new IapAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.updateIapConfigSteam(data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function deleteIapConfigGoogle() {
    const $ = new IapAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.deleteIapConfigGoogle();
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getIapConfigGoogle() {
    const $ = new IapAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getIapConfigGoogle();
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function updateIapConfigGoogle(data) {
    const $ = new IapAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.updateIapConfigGoogle(data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function deleteIapConfigOculu() {
    const $ = new IapAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.deleteIapConfigOculu();
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getIapConfigOculus() {
    const $ = new IapAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getIapConfigOculus();
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function updateIapConfigOculu(data) {
    const $ = new IapAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.updateIapConfigOculu(data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function deleteIapConfigTwitch() {
    const $ = new IapAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.deleteIapConfigTwitch();
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getIapConfigTwitch() {
    const $ = new IapAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getIapConfigTwitch();
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function updateIapConfigTwitch(data) {
    const $ = new IapAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.updateIapConfigTwitch(data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getIap_ByUserId(userId, queryParams) {
    const $ = new IapAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getIap_ByUserId(userId, queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function updateIapConfigXblCert(data) {
    const $ = new IapAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.updateIapConfigXblCert(data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function deleteIapConfigEpicgame() {
    const $ = new IapAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.deleteIapConfigEpicgame();
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getIapConfigEpicgames() {
    const $ = new IapAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getIapConfigEpicgames();
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function updateIapConfigEpicgame(data) {
    const $ = new IapAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.updateIapConfigEpicgame(data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function updateIapConfigAppleCert(data) {
    const $ = new IapAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.updateIapConfigAppleCert(data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function updateIapConfigGoogleCert(data) {
    const $ = new IapAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.updateIapConfigGoogleCert(data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function deleteIapConfigPlaystation() {
    const $ = new IapAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.deleteIapConfigPlaystation();
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getIapConfigPlaystation() {
    const $ = new IapAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getIapConfigPlaystation();
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function updateIapConfigPlaystation(data) {
    const $ = new IapAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.updateIapConfigPlaystation(data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getIapAll_ByUserId(userId) {
    const $ = new IapAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getIapAll_ByUserId(userId);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getIapConfigPlaystationValidate() {
    const $ = new IapAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getIapConfigPlaystationValidate();
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function updateIapConfigPlaystationValidate(data) {
    const $ = new IapAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.updateIapConfigPlaystationValidate(data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function updateIapMockReceipt_ByUserId(userId, data) {
    const $ = new IapAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.updateIapMockReceipt_ByUserId(userId, data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getIapConsumeHistory_ByUserId(userId, queryParams) {
    const $ = new IapAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getIapConsumeHistory_ByUserId(userId, queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  return {
    /**
     * Delete xbl iap config.
     */
    deleteIapConfigXbl,
    /**
     * Get xbox iap config.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: xbox iap config&lt;/li&gt;&lt;/ul&gt;
     */
    getIapConfigXbl,
    /**
     * Update xbl iap config. Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: updated xbl iap config&lt;/li&gt;&lt;/ul&gt;
     */
    updateIapConfigXbl,
    /**
     * delete a iap item config.
     */
    deleteIapConfigItem,
    /**
     * Get iap item config.
     */
    getIapConfigItem,
    /**
     * Update iap item config. Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: updated iap item config&lt;/li&gt;&lt;/ul&gt;
     */
    updateIapConfigItem,
    /**
     * Delete apple iap config.
     */
    deleteIapConfigApple,
    /**
     * Get apple iap config.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: apple iap config&lt;/li&gt;&lt;/ul&gt;
     */
    getIapConfigApple,
    /**
     * Update apple iap config. Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: updated apple iap config&lt;/li&gt;&lt;/ul&gt;
     */
    updateIapConfigApple,
    /**
     * Delete steam iap config.
     */
    deleteIapConfigSteam,
    /**
     * Get steam iap config.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: steam iap config&lt;/li&gt;&lt;/ul&gt;
     */
    getIapConfigSteam,
    /**
     * Update steam iap config. Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: updated steam iap config&lt;/li&gt;&lt;/ul&gt;
     */
    updateIapConfigSteam,
    /**
     * Delete google iap config.
     */
    deleteIapConfigGoogle,
    /**
     * Get google iap config.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: google iap config&lt;/li&gt;&lt;/ul&gt;
     */
    getIapConfigGoogle,
    /**
     * Update google iap config. Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: updated google iap config&lt;/li&gt;&lt;/ul&gt;
     */
    updateIapConfigGoogle,
    /**
     * Delete oculus iap config.
     */
    deleteIapConfigOculu,
    /**
     * Get oculus iap config.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: steam iap config&lt;/li&gt;&lt;/ul&gt;
     */
    getIapConfigOculus,
    /**
     * Update oculus iap config. Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: updated steam iap config&lt;/li&gt;&lt;/ul&gt;
     */
    updateIapConfigOculu,
    /**
     * Delete twitch iap config.
     */
    deleteIapConfigTwitch,
    /**
     * Get twitch iap config.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: twitch iap config&lt;/li&gt;&lt;/ul&gt;
     */
    getIapConfigTwitch,
    /**
     * Update twitch iap config. Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: updated twitch iap config&lt;/li&gt;&lt;/ul&gt;
     */
    updateIapConfigTwitch,
    /**
     * Query IAP orders.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: paginated iap orders&lt;/li&gt;&lt;/ul&gt;
     */
    getIap_ByUserId,
    /**
     * Upload xbl business partner cert file.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: updated xbl iap config&lt;/li&gt;&lt;/ul&gt;
     */
    updateIapConfigXblCert,
    /**
     * Delete epic games iap config.
     */
    deleteIapConfigEpicgame,
    /**
     * Get epic games iap config.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: epic games iap config&lt;/li&gt;&lt;/ul&gt;
     */
    getIapConfigEpicgames,
    /**
     * Update epic games iap config. Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: updated epic games iap config&lt;/li&gt;&lt;/ul&gt;
     */
    updateIapConfigEpicgame,
    /**
     * Upload Apple Store p8 file.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: updated apple iap config&lt;/li&gt;&lt;/ul&gt;
     */
    updateIapConfigAppleCert,
    /**
     * Upload google play p12 file.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: updated google iap config&lt;/li&gt;&lt;/ul&gt;
     */
    updateIapConfigGoogleCert,
    /**
     * Delete playstation iap config.
     */
    deleteIapConfigPlaystation,
    /**
     * Get playstation iap config.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: playstation iap config&lt;/li&gt;&lt;/ul&gt;
     */
    getIapConfigPlaystation,
    /**
     * Update playstation iap config. Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: updated playstation iap config&lt;/li&gt;&lt;/ul&gt;
     */
    updateIapConfigPlaystation,
    /**
     * Query all user IAP orders.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: list of iap orders&lt;/li&gt;&lt;/ul&gt;
     */
    getIapAll_ByUserId,
    /**
     * Validate playstation iap config. Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: Test Results&lt;/li&gt;&lt;/ul&gt;
     */
    getIapConfigPlaystationValidate,
    /**
     * Validate playstation iap config. Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: Test Results&lt;/li&gt;&lt;/ul&gt;
     */
    updateIapConfigPlaystationValidate,
    /**
     * &lt;b&gt;[TEST FACILITY ONLY] Forbidden in live environment. &lt;/b&gt; Mock fulfill iap item without validate receipt.Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: &lt;/li&gt;&lt;/ul&gt;
     */
    updateIapMockReceipt_ByUserId,
    /**
     * Query IAP consume history.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: paginated iap consume history&lt;/li&gt;&lt;/ul&gt;
     */
    getIapConsumeHistory_ByUserId
  };
}

// src/generated-admin/IapNotificationAdminApi.ts
var import_sdk49 = require("@accelbyte/sdk");
function IapNotificationAdminApi(sdk, args) {
  const sdkAssembly = sdk.assembly();
  const namespace = args?.coreConfig?.namespace ?? sdkAssembly.coreConfig.namespace;
  const useSchemaValidation = args?.coreConfig?.useSchemaValidation ?? sdkAssembly.coreConfig.useSchemaValidation;
  let axiosInstance = sdkAssembly.axiosInstance;
  const requestConfigOverrides = args?.axiosConfig?.request;
  const baseURLOverride = args?.coreConfig?.baseURL;
  const interceptorsOverride = args?.axiosConfig?.interceptors ?? [];
  if (requestConfigOverrides || baseURLOverride || interceptorsOverride.length > 0) {
    const requestConfig = import_sdk49.ApiUtils.mergeAxiosConfigs(sdkAssembly.axiosInstance.defaults, {
      ...baseURLOverride ? { baseURL: baseURLOverride } : {},
      ...requestConfigOverrides
    });
    axiosInstance = import_sdk49.Network.create(requestConfig);
    for (const interceptor of interceptorsOverride) {
      if (interceptor.type === "request") {
        axiosInstance.interceptors.request.use(interceptor.onRequest, interceptor.onError);
      }
      if (interceptor.type === "response") {
        axiosInstance.interceptors.response.use(interceptor.onSuccess, interceptor.onError);
      }
    }
  }
  async function getIapNotifications(queryParams) {
    const $ = new IapNotificationAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getIapNotifications(queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  return {
    /**
     * Query third party notifications.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: Third Party Platform notifications&lt;/li&gt;&lt;/ul&gt;
     */
    getIapNotifications
  };
}

// src/generated-admin/IapSubscriptionAdminApi.ts
var import_sdk50 = require("@accelbyte/sdk");
function IapSubscriptionAdminApi(sdk, args) {
  const sdkAssembly = sdk.assembly();
  const namespace = args?.coreConfig?.namespace ?? sdkAssembly.coreConfig.namespace;
  const useSchemaValidation = args?.coreConfig?.useSchemaValidation ?? sdkAssembly.coreConfig.useSchemaValidation;
  let axiosInstance = sdkAssembly.axiosInstance;
  const requestConfigOverrides = args?.axiosConfig?.request;
  const baseURLOverride = args?.coreConfig?.baseURL;
  const interceptorsOverride = args?.axiosConfig?.interceptors ?? [];
  if (requestConfigOverrides || baseURLOverride || interceptorsOverride.length > 0) {
    const requestConfig = import_sdk50.ApiUtils.mergeAxiosConfigs(sdkAssembly.axiosInstance.defaults, {
      ...baseURLOverride ? { baseURL: baseURLOverride } : {},
      ...requestConfigOverrides
    });
    axiosInstance = import_sdk50.Network.create(requestConfig);
    for (const interceptor of interceptorsOverride) {
      if (interceptor.type === "request") {
        axiosInstance.interceptors.request.use(interceptor.onRequest, interceptor.onError);
      }
      if (interceptor.type === "response") {
        axiosInstance.interceptors.response.use(interceptor.onSuccess, interceptor.onError);
      }
    }
  }
  async function getIapSubscriptions(queryParams) {
    const $ = new IapSubscriptionAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getIapSubscriptions(queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getIapSubscriptions_ByUserId(userId, queryParams) {
    const $ = new IapSubscriptionAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getIapSubscriptions_ByUserId(userId, queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getIapSubscription_ByUserId_ById(userId, id) {
    const $ = new IapSubscriptionAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getIapSubscription_ByUserId_ById(userId, id);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function updateSyncIap_ByUserId_ById(userId, id) {
    const $ = new IapSubscriptionAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.updateSyncIap_ByUserId_ById(userId, id);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getIapSubscriptionsTransactions_ByUserId(userId, queryParams) {
    const $ = new IapSubscriptionAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getIapSubscriptionsTransactions_ByUserId(userId, queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getIapSubscriptionTransaction_ByUserId_ById(userId, id) {
    const $ = new IapSubscriptionAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getIapSubscriptionTransaction_ByUserId_ById(userId, id);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function updateSyncSubscriptionIap_ByUserId_ById(userId, id) {
    const $ = new IapSubscriptionAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.updateSyncSubscriptionIap_ByUserId_ById(userId, id);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getHistoriesSubscriptionsIap_ByUserId_ById(userId, id, queryParams) {
    const $ = new IapSubscriptionAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getHistoriesSubscriptionsIap_ByUserId_ById(userId, id, queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getOwnershipByGroupIdSubscriptionsIap_ByUserId_ByPlatform(userId, platform, queryParams) {
    const $ = new IapSubscriptionAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getOwnershipByGroupIdSubscriptionsIap_ByUserId_ByPlatform(userId, platform, queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getOwnershipByProductIdSubscriptionsIap_ByUserId_ByPlatform(userId, platform, queryParams) {
    const $ = new IapSubscriptionAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getOwnershipByProductIdSubscriptionsIap_ByUserId_ByPlatform(userId, platform, queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  return {
    /**
     * Query subscriptions, default sort by updatedAt Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: &lt;/li&gt;&lt;/ul&gt;
     */
    getIapSubscriptions,
    /**
     * Query user subscription, default sort by updatedAtOther detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: &lt;/li&gt;&lt;/ul&gt;
     */
    getIapSubscriptions_ByUserId,
    /**
     * Admin get user subscription details.Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: &lt;/li&gt;&lt;/ul&gt;
     */
    getIapSubscription_ByUserId_ById,
    /**
     * Sync Subscription Status
     */
    updateSyncIap_ByUserId_ById,
    /**
     * Admin query user subscription transactions, default sort by startAt timeOther detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: &lt;/li&gt;&lt;/ul&gt;
     */
    getIapSubscriptionsTransactions_ByUserId,
    /**
     * Admin get user subscription details.Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: &lt;/li&gt;&lt;/ul&gt;
     */
    getIapSubscriptionTransaction_ByUserId_ById,
    /**
     * Sync Subscription Status
     */
    updateSyncSubscriptionIap_ByUserId_ById,
    /**
     * Get Subscription Transaction Update History
     */
    getHistoriesSubscriptionsIap_ByUserId_ById,
    /**
     * Get user third party subscription by subscription group id.
     */
    getOwnershipByGroupIdSubscriptionsIap_ByUserId_ByPlatform,
    /**
     * Get user third party subscription by subscription product id.
     */
    getOwnershipByProductIdSubscriptionsIap_ByUserId_ByPlatform
  };
}

// src/generated-admin/InvoiceAdminApi.ts
var import_sdk51 = require("@accelbyte/sdk");
function InvoiceAdminApi(sdk, args) {
  const sdkAssembly = sdk.assembly();
  const namespace = args?.coreConfig?.namespace ?? sdkAssembly.coreConfig.namespace;
  const useSchemaValidation = args?.coreConfig?.useSchemaValidation ?? sdkAssembly.coreConfig.useSchemaValidation;
  let axiosInstance = sdkAssembly.axiosInstance;
  const requestConfigOverrides = args?.axiosConfig?.request;
  const baseURLOverride = args?.coreConfig?.baseURL;
  const interceptorsOverride = args?.axiosConfig?.interceptors ?? [];
  if (requestConfigOverrides || baseURLOverride || interceptorsOverride.length > 0) {
    const requestConfig = import_sdk51.ApiUtils.mergeAxiosConfigs(sdkAssembly.axiosInstance.defaults, {
      ...baseURLOverride ? { baseURL: baseURLOverride } : {},
      ...requestConfigOverrides
    });
    axiosInstance = import_sdk51.Network.create(requestConfig);
    for (const interceptor of interceptorsOverride) {
      if (interceptor.type === "request") {
        axiosInstance.interceptors.request.use(interceptor.onRequest, interceptor.onError);
      }
      if (interceptor.type === "response") {
        axiosInstance.interceptors.response.use(interceptor.onSuccess, interceptor.onError);
      }
    }
  }
  async function getInvoiceSummary(queryParams) {
    const $ = new InvoiceAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getInvoiceSummary(queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getInvoiceDetailsCsv(queryParams) {
    const $ = new InvoiceAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getInvoiceDetailsCsv(queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  return {
    /**
     * Generate invoice summary.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: query orders&lt;/li&gt;&lt;/ul&gt;
     */
    getInvoiceSummary,
    /**
     * Download invoice details as a csv file.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: invoice details csv file&lt;/li&gt;&lt;/ul&gt;
     */
    getInvoiceDetailsCsv
  };
}

// src/generated-admin/ItemAdminApi.ts
var import_sdk52 = require("@accelbyte/sdk");
function ItemAdminApi(sdk, args) {
  const sdkAssembly = sdk.assembly();
  const namespace = args?.coreConfig?.namespace ?? sdkAssembly.coreConfig.namespace;
  const useSchemaValidation = args?.coreConfig?.useSchemaValidation ?? sdkAssembly.coreConfig.useSchemaValidation;
  let axiosInstance = sdkAssembly.axiosInstance;
  const requestConfigOverrides = args?.axiosConfig?.request;
  const baseURLOverride = args?.coreConfig?.baseURL;
  const interceptorsOverride = args?.axiosConfig?.interceptors ?? [];
  if (requestConfigOverrides || baseURLOverride || interceptorsOverride.length > 0) {
    const requestConfig = import_sdk52.ApiUtils.mergeAxiosConfigs(sdkAssembly.axiosInstance.defaults, {
      ...baseURLOverride ? { baseURL: baseURLOverride } : {},
      ...requestConfigOverrides
    });
    axiosInstance = import_sdk52.Network.create(requestConfig);
    for (const interceptor of interceptorsOverride) {
      if (interceptor.type === "request") {
        axiosInstance.interceptors.request.use(interceptor.onRequest, interceptor.onError);
      }
      if (interceptor.type === "response") {
        axiosInstance.interceptors.response.use(interceptor.onSuccess, interceptor.onError);
      }
    }
  }
  async function getItemsConfigs() {
    const $ = new ItemAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getItemsConfigs();
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function createItemConfig(data) {
    const $ = new ItemAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.createItemConfig(data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function deleteItemConfig_ById(id) {
    const $ = new ItemAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.deleteItemConfig_ById(id);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getItemConfig_ById(id) {
    const $ = new ItemAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getItemConfig_ById(id);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function updateItemConfig_ById(id, data) {
    const $ = new ItemAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.updateItemConfig_ById(id, data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getItemsConfigsSearch(queryParams) {
    const $ = new ItemAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getItemsConfigsSearch(queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function createItem(data, queryParams) {
    const $ = new ItemAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.createItem(data, queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function updateItem(data, queryParams) {
    const $ = new ItemAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.updateItem(data, queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getItemsByIds(queryParams) {
    const $ = new ItemAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getItemsByIds(queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getItemsBySku(queryParams) {
    const $ = new ItemAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getItemsBySku(queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getItemsSearch(queryParams) {
    const $ = new ItemAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getItemsSearch(queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getItemsByAppId(queryParams) {
    const $ = new ItemAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getItemsByAppId(queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function deleteItem_ByItemId(itemId, queryParams) {
    const $ = new ItemAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.deleteItem_ByItemId(itemId, queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getItem_ByItemId(itemId, queryParams) {
    const $ = new ItemAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getItem_ByItemId(itemId, queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function updateItem_ByItemId(itemId, data, queryParams) {
    const $ = new ItemAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.updateItem_ByItemId(itemId, data, queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getItemsByCriteria(queryParams) {
    const $ = new ItemAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getItemsByCriteria(queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function updateItemRegiondata(data, queryParams) {
    const $ = new ItemAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.updateItemRegiondata(data, queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getApp_ByItemId(itemId, queryParams) {
    const $ = new ItemAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getApp_ByItemId(itemId, queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function updateApp_ByItemId(itemId, data, queryParams) {
    const $ = new ItemAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.updateApp_ByItemId(itemId, data, queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getItemsBySkuLocale(queryParams) {
    const $ = new ItemAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getItemsBySkuLocale(queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getItemsItemIdBySku(queryParams) {
    const $ = new ItemAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getItemsItemIdBySku(queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getItemsLocaleByIds(queryParams) {
    const $ = new ItemAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getItemsLocaleByIds(queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getItemsItemIdBySkus(queryParams) {
    const $ = new ItemAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getItemsItemIdBySkus(queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getItemsUncategorized(queryParams) {
    const $ = new ItemAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getItemsUncategorized(queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getItemsByCriteria_v2(queryParams) {
    const $ = new ItemAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getItemsByCriteria_v2(queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getItemsEstimatedPrice(queryParams) {
    const $ = new ItemAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getItemsEstimatedPrice(queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function updateEnable_ByItemId(itemId, queryParams) {
    const $ = new ItemAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.updateEnable_ByItemId(itemId, queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getLocale_ByItemId(itemId, queryParams) {
    const $ = new ItemAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getLocale_ByItemId(itemId, queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function updateReturn_ByItemId(itemId, data) {
    const $ = new ItemAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.updateReturn_ByItemId(itemId, data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getItemsPredicateTypes() {
    const $ = new ItemAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getItemsPredicateTypes();
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function updateAcquire_ByItemId(itemId, data) {
    const $ = new ItemAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.updateAcquire_ByItemId(itemId, data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function updateDisable_ByItemId(itemId, queryParams) {
    const $ = new ItemAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.updateDisable_ByItemId(itemId, queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getDynamic_ByItemId(itemId) {
    const $ = new ItemAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getDynamic_ByItemId(itemId);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getItemsByFeaturesBasic(queryParams) {
    const $ = new ItemAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getItemsByFeaturesBasic(queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function deleteFeature_ByItemId_ByFeature(itemId, feature, queryParams) {
    const $ = new ItemAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.deleteFeature_ByItemId_ByFeature(itemId, feature, queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function updateFeature_ByItemId_ByFeature(itemId, feature, queryParams) {
    const $ = new ItemAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.updateFeature_ByItemId_ByFeature(itemId, feature, queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function updatePurchaseCondition_ByItemId(itemId, data, queryParams) {
    const $ = new ItemAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.updatePurchaseCondition_ByItemId(itemId, data, queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function createItemPurchaseConditionValidate(data, queryParams) {
    const $ = new ItemAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.createItemPurchaseConditionValidate(data, queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  return {
    /**
     * &lt;b&gt;[Not supported yet in AGS Shared Cloud]&lt;/b&gt;This API is used to get all item type configs.&lt;p&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: the list of items&lt;/li&gt;&lt;/ul&gt;
     */
    getItemsConfigs,
    /**
     * &lt;b&gt;[Not supported yet in AGS Shared Cloud]&lt;/b&gt;This API is used to create an item type config.&lt;p&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: item type config data&lt;/li&gt;&lt;/ul&gt;
     */
    createItemConfig,
    /**
     * &lt;b&gt;[Not supported yet in AGS Shared Cloud]&lt;/b&gt;This API is used to delete an item type config permanently.
     */
    deleteItemConfig_ById,
    /**
     * &lt;b&gt;[Not supported yet in AGS Shared Cloud]&lt;/b&gt;This API is used to get an item type config.&lt;p&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: item type config data&lt;/li&gt;&lt;/ul&gt;
     */
    getItemConfig_ById,
    /**
     * &lt;b&gt;[Not supported yet in AGS Shared Cloud]&lt;/b&gt;This API is used to update an item type config.&lt;p&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: item type config data&lt;/li&gt;&lt;/ul&gt;
     */
    updateItemConfig_ById,
    /**
     * &lt;b&gt;[Not supported yet in AGS Shared Cloud]&lt;/b&gt;This API is used to get an item type config.&lt;p&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: item type config data&lt;/li&gt;&lt;/ul&gt;
     */
    getItemsConfigsSearch,
    /**
     * This API is used to create an item. APP item only can created in publisher namespace.&lt;p&gt;An item create example:&lt;p&gt;&lt;pre&gt;&lt;code&gt;{ &#34;categoryPath&#34;: &#34;/games&#34;, &#34;localizations&#34;: \{ &#34;en&#34;: \{ &#34;title&#34;:&#34;required&#34;, &#34;description&#34;:&#34;optional&#34;, &#34;longDescription&#34;:&#34;optional&#34;, &#34;localExt&#34;: \{ &#34;properties&#34;:\[ \{ &#34;key1&#34;:&#34;value1&#34;, &#34;key2&#34;:&#34;value2&#34; \} \], &#34;functions&#34;:\[ \{ &#34;key1&#34;:&#34;value1&#34;, &#34;key2&#34;:&#34;value2&#34; \} \] \} \} \}, &#34;images&#34;: \[ \{ &#34;as&#34;:&#34;optional, image for&#34;, &#34;caption&#34;:&#34;optional&#34;, &#34;height&#34;:10, &#34;width&#34;:10, &#34;imageUrl&#34;:&#34;http://img-url-required&#34;, &#34;smallImageUrl&#34;:&#34;http://small-img-url-required&#34; \} \], &#34;thumbnailUrl&#34;: &#34;optional, thumbnail url&#34;, &#34;status&#34;: &#34;ACTIVE&#34;, &#34;listable&#34;: true, &#34;purchasable&#34;: true, &#34;itemType&#34;: &#34;APP(allowed: [APP,COINS,INGAMEITEM,CODE,BUNDLE])&#34;, &#34;name&#34;: &#34;required, also will be used as entitlement name&#34;, &#34;entitlementType&#34;: &#34;DURABLE(allowed:[DURABLE,CONSUMABLE], should be CONSUMABLE when item type is COINS)&#34;, &#34;useCount&#34;: 1(optional, required if the entitlement type is consumable), &#34;stackable&#34;: false, &#34;appId&#34;: &#34;optional, required if itemType is APP&#34;, &#34;appType&#34;: &#34;GAME(optional, required if itemType is APP)&#34;, &#34;seasonType&#34;: &#34;PASS(optional, required if itemType is SEASON)&#34;, &#34;baseAppId&#34;: &#34;optional, set value of game app id if you want to link to a game&#34;, &#34;targetCurrencyCode&#34;: &#34;optional, required if itemType is COINS&#34;, &#34;targetNamespace&#34;: &#34;optional, required when itemType is INGAMEITEM, the targetNamespace will only take effect when the item created belongs to the publisher namespace&#34;, &#34;sku&#34;: &#34;optional, commonly unique item code&#34;, &#34;regionData&#34;: \{ &#34;US(store&#39;s default region is required)&#34;: \[ \{ &#34;price&#34;:10, &#34;discountPercentage&#34;: 0(integer, optional, range[0,100], discountedPrice = price \* ((100 - discountPercentage) \* 0.01), will use it to calculate discounted price if it is not 0), &#34;discountAmount&#34;:0(integer, optional, range[0,itemPrice], will use it to calculate discounted price if discountPercentage is 0), &#34;currencyCode&#34;:&#34;code(required, example: USD)&#34;, &#34;currencyNamespace&#34;:&#34;test-ns-required(allow publisher namespace if namespace is publisher namespace, allow publisher and game namespace if namespace is not publisher namespace)&#34;, &#34;trialPrice&#34;:5(required while fixedTrialCycles set, should &gt;=0 and &lt;= price, will same as price if not present), &#34;purchaseAt&#34;:&#34;optional yyyy-MM-dd&#39;T&#39;HH:mm:ss.SSS&#39;Z&#39;&#34;, &#34;expireAt&#34;:&#34;optional yyyy-MM-dd&#39;T&#39;HH:mm:ss.SSS&#39;Z&#39;&#34;, &#34;discountPurchaseAt&#34;:&#34;optional yyyy-MM-dd&#39;T&#39;HH:mm:ss.SSS&#39;Z&#39;&#34;, &#34;discountExpireAt&#34;:&#34;optional yyyy-MM-dd&#39;T&#39;HH:mm:ss.SSS&#39;Z&#39;&#34; \} \] \}, &#34;itemIds&#34;: \[ &#34;itemId&#34; \], &#34;itemQty&#34;: \{ &#34;itemId&#34;:1 \}, &#34;recurring&#34;: \{ &#34;cycle&#34;:&#34;MONTHLY(allowed: [WEEKLY,MONTHLY,QUARTERLY,YEARLY])&#34;, &#34;fixedFreeDays&#34;:0(integer, fixed free days, 0 means not set), &#34;fixedTrialCycles&#34;:0(integer, fixed trial cycles, 0 means not set, will not take effect if fixedFreeDays set), &#34;graceDays&#34;:7(integer, recurring grace days, retry recurring charge within configured days if charge fail, default 7) \}, &#34;tags&#34;: \[ &#34;exampleTag24&#34; \], &#34;features&#34;: \[ &#34;feature&#34; \], &#34;clazz&#34;: &#34;weapon&#34;, &#34;boothName&#34;: &#34;C_campaign1&#34;, &#34;displayOrder&#34;: 1000, &#34;ext&#34;: \{ &#34;properties&#34;:\[ \{ &#34;key1&#34;:&#34;value1&#34;, &#34;key2&#34;:&#34;value2&#34; \} \], &#34;functions&#34;:\[ \{ &#34;key1&#34;:&#34;value1&#34;, &#34;key2&#34;:&#34;value2&#34; \} \] \}, &#34;maxCountPerUser&#34;: 1(integer, optional, -1 means UNLIMITED), &#34;maxCount&#34;: 1(integer, optional, -1 means UNLIMITED, unset when itemType is CODE) }&lt;/code&gt;&lt;/pre&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: created item data&lt;/li&gt;&lt;/ul&gt;&lt;h2&gt;Restrictions for item extension and localization extension and inventory config custom attributes&lt;/h2&gt; 1. Cannot use &lt;b&gt;&#34;.&#34;&lt;/b&gt; as the key name - &lt;pre&gt;{ &#34;data.2&#34;: &#34;value&#34; }&lt;/pre&gt; 2. Cannot use &lt;b&gt;&#34;$&#34;&lt;/b&gt; as the prefix in key names - &lt;pre&gt;{ &#34;$data&#34;: &#34;value&#34; }&lt;/pre&gt;
     */
    createItem,
    /**
     * &lt;b&gt;[Not supported yet in AGS Shared Cloud]&lt;/b&gt;This API is used to sync an in game item in game namespace to publisher namespace, only INGAMEITEM, CODE, COINS and SEASON are supported&lt;p&gt;The synced item has an additional field targetItemId besides targetNamespace, mostly this item should not modified manually again. &lt;p&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: item data&lt;/li&gt;&lt;/ul&gt;
     */
    updateItem,
    /**
     * This API is used to get items.&lt;p&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: the list of items info&lt;/li&gt;&lt;/ul&gt;
     */
    getItemsByIds,
    /**
     * This API is used to get the item by sku.&lt;p&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: the item with sku&lt;/li&gt;&lt;/ul&gt;
     */
    getItemsBySku,
    /**
     * This API is used to search items by keyword in title, description and long description within a store.&lt;p&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: the list of items&lt;/li&gt;&lt;/ul&gt;
     */
    getItemsSearch,
    /**
     * This API is used to get the item by appId.&lt;p&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: the item with that appId&lt;/li&gt;&lt;/ul&gt;
     */
    getItemsByAppId,
    /**
     * This API is used to delete an item permanently.&lt;p&gt;force: the default value should be: false. When the value is: &lt;li&gt;&lt;i&gt;false:&lt;i&gt;only the items in the draft store that have never been published yet can be removed.&lt;/li&gt;&lt;li&gt;&lt;i&gt;true:&lt;i&gt;the item in the draft store(even been published before) can be removed.&lt;/li&gt;
     */
    deleteItem_ByItemId,
    /**
     * This API is used to get an item.&lt;p&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: item data&lt;/li&gt;&lt;/ul&gt;
     */
    getItem_ByItemId,
    /**
     * This API is used to update an item.&lt;p&gt;An item update example:&lt;p&gt;&lt;pre&gt;&lt;code&gt;{ &#34;categoryPath&#34;: &#34;/games&#34;, &#34;localizations&#34;: \{ &#34;en&#34;: \{ &#34;title&#34;:&#34;required&#34;, &#34;description&#34;:&#34;optional&#34;, &#34;longDescription&#34;:&#34;optional&#34;, &#34;localExt&#34;: \{ &#34;properties&#34;:\[ \{ &#34;key1&#34;:&#34;value1&#34;, &#34;key2&#34;:&#34;value2&#34; \} \], &#34;functions&#34;:\[ \{ &#34;key1&#34;:&#34;value1&#34;, &#34;key2&#34;:&#34;value2&#34; \} \] \} \} \}, &#34;images&#34;: \[ \{ &#34;as&#34;:&#34;optional, image for&#34;, &#34;caption&#34;:&#34;optional&#34;, &#34;height&#34;:10, &#34;width&#34;:10, &#34;imageUrl&#34;:&#34;http://img-url-required&#34;, &#34;smallImageUrl&#34;:&#34;http://small-img-url-required&#34; \} \], &#34;thumbnailUrl&#34;: &#34;optional, thumbnail url&#34;, &#34;status&#34;: &#34;ACTIVE&#34;, &#34;listable&#34;: true, &#34;purchasable&#34;: true, &#34;itemType&#34;: &#34;APP(allowed: [APP,COINS,INGAMEITEM,CODE,BUNDLE])&#34;, &#34;name&#34;: &#34;optional&#34;, &#34;entitlementType&#34;: &#34;DURABLE(allowed:[DURABLE,CONSUMABLE], should be CONSUMABLE when item type is COINS)&#34;, &#34;useCount&#34;: 1(optional, required if the entitlement type is consumable), &#34;stackable&#34;: false, &#34;appId&#34;: &#34;optional, required if itemType is APP&#34;, &#34;baseAppId&#34;: &#34;optional, set value of game app id if you want to link to a game&#34;, &#34;appType&#34;: &#34;GAME(optional, required if itemType is APP)&#34;, &#34;seasonType&#34;: &#34;PASS(optional, required if itemType is SEASON)&#34;, &#34;sku&#34;: &#34;optional, commonly unique item code&#34;, &#34;targetCurrencyCode&#34;: &#34;optional, required if itemType is COINS&#34;, &#34;targetNamespace&#34;: &#34;optional, required when itemType is INGAMEITEM, the targetNamespace will only take effect when the item created belongs to the publisher namespace&#34;, &#34;regionData&#34;: \{ &#34;US(store&#39;s default region is required)&#34;: \[ \{ &#34;price&#34;:10, &#34;discountPercentage&#34;:0(integer, optional, range[0,100], discountedPrice = price\*((100 - discountPercentage) \* 0.01), if it is not 0, will use it to calculate discounted price), &#34;discountAmount&#34;:0(integer, optional, range[0,itemPrice], will use it to calculate discounted price if discountPercentage is 0), &#34;currencyCode&#34;:&#34;code(required, example: USD)&#34;, &#34;currencyNamespace&#34;:&#34;test-ns-required(allow publisher namespace if namespace is publisher namespace, allow publisher and game namespace if namespace is not publisher namespace)&#34;, &#34;trialPrice&#34;:5(required while fixedTrialCycles set, should &gt;=0 and &lt;= price, will same as price if not present), &#34;purchaseAt&#34;:&#34;optional yyyy-MM-dd&#39;T&#39;HH:mm:ss.SSS&#39;Z&#39;&#34;, &#34;expireAt&#34;:&#34;optional yyyy-MM-dd&#39;T&#39;HH:mm:ss.SSS&#39;Z&#39;&#34;, &#34;discountPurchaseAt&#34;:&#34;optional yyyy-MM-dd&#39;T&#39;HH:mm:ss.SSS&#39;Z&#39;&#34;, &#34;discountExpireAt&#34;:&#34;optional yyyy-MM-dd&#39;T&#39;HH:mm:ss.SSS&#39;Z&#39;&#34; \} \] \}, &#34;itemIds&#34;: \[ &#34;itemId&#34; \], &#34;itemQty&#34;: \{ &#34;itemId&#34;:1 \}, &#34;recurring&#34;: \{ &#34;cycle&#34;:&#34;MONTHLY(allowed: [WEEKLY,MONTHLY,QUARTERLY,YEARLY])&#34;, &#34;fixedFreeDays&#34;:0(integer, fixed free days, 0 means not set), &#34;fixedTrialCycles&#34;:0(integer, fixed trial cycles, 0 means not set, will not take effect if fixedFreeDays set), &#34;graceDays&#34;:7(integer, recurring grace days, retry recurring charge within configured days if charge fail, default 7) \}, &#34;tags&#34;: \[ &#34;exampleTag24&#34; \], &#34;features&#34;: \[ &#34;feature&#34; \], &#34;clazz&#34;: &#34;weapon&#34;, &#34;boothName&#34;: &#34;C_campaign1&#34;, &#34;displayOrder&#34;: 1000, &#34;ext&#34;: \{ &#34;properties&#34;:\[ \{ &#34;key1&#34;:&#34;value1&#34;, &#34;key2&#34;:&#34;value2&#34; \} \], &#34;functions&#34;:\[ \{ &#34;key1&#34;:&#34;value1&#34;, &#34;key2&#34;:&#34;value2&#34; \} \] \}, &#34;maxCountPerUser&#34;: 1(integer, optional, -1 means UNLIMITED), &#34;maxCount&#34;: 1(integer, optional, -1 means UNLIMITED, new value should &gt;= old value if both old value and new value is limited, unset when item type is CODE) }&lt;/code&gt;&lt;/pre&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: updated item data&lt;/li&gt;&lt;/ul&gt;&lt;h2&gt;Restrictions for item extension and localization extension&lt;/h2&gt; 1. Cannot use &lt;b&gt;&#34;.&#34;&lt;/b&gt; as the key name - &lt;pre&gt;{ &#34;data.2&#34;: &#34;value&#34; }&lt;/pre&gt; 2. Cannot use &lt;b&gt;&#34;$&#34;&lt;/b&gt; as the prefix in key names - &lt;pre&gt;{ &#34;$data&#34;: &#34;value&#34; }&lt;/pre&gt;
     */
    updateItem_ByItemId,
    /**
     * This API is used to query items by criteria within a store.&lt;p&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: the list of items&lt;/li&gt;&lt;/ul&gt;
     */
    getItemsByCriteria,
    /**
     * This API is used to update region data of items in bulk &lt;br /&gt;
     */
    updateItemRegiondata,
    /**
     * This API is used to get an app info.&lt;p&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: app data&lt;/li&gt;&lt;/ul&gt;
     */
    getApp_ByItemId,
    /**
     * This API is used to update an app.&lt;p&gt;An app update example:&lt;p&gt;&lt;pre&gt;&lt;code&gt;{ &#34;developer&#34;: &#34;accelbyte&#34;, &#34;publisher&#34;: &#34;accelbyte&#34;, &#34;websiteUrl&#34;: &#34;http://accelbyte.io&#34;, &#34;forumUrl&#34;: &#34;http://accelbyte.io&#34;, &#34;platforms&#34;: \[&#34;Windows(allowed values: Windows, MacOS, Linux, IOS, Android)&#34;\], &#34;platformRequirements&#34;: \{ &#34;Windows&#34;: \[ \{ &#34;label&#34;:&#34;minimum(can be minimum or recommended)&#34;, &#34;osVersion&#34;:&#34;os version&#34;, &#34;processor&#34;:&#34;processor&#34;, &#34;ram&#34;:&#34;RAM&#34;, &#34;graphics&#34;:&#34;graphics&#34;, &#34;directXVersion&#34;:&#34;directXVersion&#34;, &#34;diskSpace&#34;:&#34;diskSpace&#34;, &#34;soundCard&#34;:&#34;soundCard&#34;, &#34;additionals&#34;:&#34;additionals&#34; \} \] \}, &#34;carousel&#34;: \[ \{ &#34;type&#34;:&#34;image(allowed values: image, video)&#34;, &#34;videoSource&#34;:&#34;generic(allowed values:generic, youtube, viemo)&#34;, &#34;url&#34;:&#34;url&#34;, &#34;alt&#34;:&#34;alternative url or text&#34;, &#34;thumbnailUrl&#34;:&#34;thumbnail url&#34;, &#34;previewUrl&#34;:&#34;preview url&#34;, \} \], &#34;localizations&#34;: \{ &#34;en&#34;: \{ &#34;slogan&#34;:&#34;slogan&#34;, &#34;announcement&#34;:&#34;announcement&#34;, \} \}, &#34;primaryGenre&#34;: &#34;Action&#34;, &#34;genres&#34;: \[&#34;Action&#34;, &#34;Adventure&#34;\], &#34;players&#34;: \[&#34;Single&#34;\], &#34;releaseDate&#34;: &#34;optional yyyy-MM-dd&#39;T&#39;HH:mm:ss.SSS&#39;Z&#39;&#34; }&lt;/code&gt;&lt;/pre&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: updated app data&lt;/li&gt;&lt;/ul&gt;
     */
    updateApp_ByItemId,
    /**
     * This API is used to get an item by sku in specific locale. If item not exist in specific region, default region item will return.&lt;p&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: item data&lt;/li&gt;&lt;/ul&gt;
     */
    getItemsBySkuLocale,
    /**
     * &lt;b&gt;[SERVICE COMMUNICATION ONLY]&lt;/b&gt; This API is used to get the itemId by sku.&lt;p&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: the itemId with sku&lt;/li&gt;&lt;/ul&gt;
     */
    getItemsItemIdBySku,
    /**
     * This API is used to bulk get locale items. If item not exist in specific region, default region item will return.&lt;p&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: the list of items info&lt;/li&gt;&lt;/ul&gt;
     */
    getItemsLocaleByIds,
    /**
     * This API is used to get an list of itemId by list of sku.&lt;p&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: item data&lt;/li&gt;&lt;/ul&gt;
     */
    getItemsItemIdBySkus,
    /**
     * This API is used to query uncategorized items within a store.&lt;p&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: the list of uncategorized items&lt;/li&gt;&lt;/ul&gt;
     */
    getItemsUncategorized,
    /**
     * This API is used to query items by criteria within a store.&lt;p&gt;The behaviour for itemStatus query parameter:&lt;li&gt;TRUE: Show only ACTIVE items&lt;/li&gt;&lt;li&gt;FALSE: Show only INACTIVE items&lt;/li&gt;&lt;li&gt;Not provided: show both ACTIVE and INACTIVE items&lt;/li&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: the list of items&lt;/li&gt;&lt;/ul&gt;
     */
    getItemsByCriteria_v2,
    /**
     * This API is used to get estimated prices of a flexible pricing bundle
     */
    getItemsEstimatedPrice,
    /**
     * Enable an item.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: updated item&lt;/li&gt;&lt;/ul&gt;
     */
    updateEnable_ByItemId,
    /**
     * This API is used to get an item in specific locale. If item not exist in specific region, default region item will return.&lt;p&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: item data&lt;/li&gt;&lt;/ul&gt;
     */
    getLocale_ByItemId,
    /**
     * &lt;b&gt;[SERVICE COMMUNICATION ONLY]&lt;/b&gt; This api is used for returning a published item while the item is maxCount limited, it will increase the sale available count if orderNo already acquired.
     */
    updateReturn_ByItemId,
    /**
     * Get available predicate types.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: available predicate types&lt;/li&gt;&lt;/ul&gt;
     */
    getItemsPredicateTypes,
    /**
     * &lt;b&gt;[SERVICE COMMUNICATION ONLY]&lt;/b&gt; This api is used for acquiring a published item while the item is maxCount limited, it will decrease the sale available count.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: acquire result&lt;/li&gt;&lt;/ul&gt;
     */
    updateAcquire_ByItemId,
    /**
     * Disable an item.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: updated item&lt;/li&gt;&lt;/ul&gt;
     */
    updateDisable_ByItemId,
    /**
     * Get item dynamic data for published item.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: item dynamic data&lt;/li&gt;&lt;/ul&gt;
     */
    getDynamic_ByItemId,
    /**
     * &lt;b&gt;[SERVICE COMMUNICATION ONLY]&lt;/b&gt; This API is used to list basic items by features.&lt;p&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: the list of basic items&lt;/li&gt;&lt;/ul&gt;
     */
    getItemsByFeaturesBasic,
    /**
     * Remove a feature from an item.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: updated item&lt;/li&gt;&lt;/ul&gt;
     */
    deleteFeature_ByItemId_ByFeature,
    /**
     * Add a feature to an item.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: updated item&lt;/li&gt;&lt;/ul&gt;
     */
    updateFeature_ByItemId_ByFeature,
    /**
     * This API is used to update item purchase condition
     */
    updatePurchaseCondition_ByItemId,
    /**
     * This API is used to validate user purchase condition
     */
    createItemPurchaseConditionValidate
  };
}

// src/generated-admin/KeyGroupAdminApi.ts
var import_sdk53 = require("@accelbyte/sdk");
function KeyGroupAdminApi(sdk, args) {
  const sdkAssembly = sdk.assembly();
  const namespace = args?.coreConfig?.namespace ?? sdkAssembly.coreConfig.namespace;
  const useSchemaValidation = args?.coreConfig?.useSchemaValidation ?? sdkAssembly.coreConfig.useSchemaValidation;
  let axiosInstance = sdkAssembly.axiosInstance;
  const requestConfigOverrides = args?.axiosConfig?.request;
  const baseURLOverride = args?.coreConfig?.baseURL;
  const interceptorsOverride = args?.axiosConfig?.interceptors ?? [];
  if (requestConfigOverrides || baseURLOverride || interceptorsOverride.length > 0) {
    const requestConfig = import_sdk53.ApiUtils.mergeAxiosConfigs(sdkAssembly.axiosInstance.defaults, {
      ...baseURLOverride ? { baseURL: baseURLOverride } : {},
      ...requestConfigOverrides
    });
    axiosInstance = import_sdk53.Network.create(requestConfig);
    for (const interceptor of interceptorsOverride) {
      if (interceptor.type === "request") {
        axiosInstance.interceptors.request.use(interceptor.onRequest, interceptor.onError);
      }
      if (interceptor.type === "response") {
        axiosInstance.interceptors.response.use(interceptor.onSuccess, interceptor.onError);
      }
    }
  }
  async function getKeygroups(queryParams) {
    const $ = new KeyGroupAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getKeygroups(queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function createKeygroup(data) {
    const $ = new KeyGroupAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.createKeygroup(data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getKeygroupsByBoothName(queryParams) {
    const $ = new KeyGroupAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getKeygroupsByBoothName(queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getKeygroup_ByKeyGroupId(keyGroupId) {
    const $ = new KeyGroupAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getKeygroup_ByKeyGroupId(keyGroupId);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function updateKeygroup_ByKeyGroupId(keyGroupId, data) {
    const $ = new KeyGroupAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.updateKeygroup_ByKeyGroupId(keyGroupId, data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getKeys_ByKeyGroupId(keyGroupId, queryParams) {
    const $ = new KeyGroupAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getKeys_ByKeyGroupId(keyGroupId, queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function createKey_ByKeyGroupId(keyGroupId, data) {
    const $ = new KeyGroupAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.createKey_ByKeyGroupId(keyGroupId, data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getDynamic_ByKeyGroupId(keyGroupId) {
    const $ = new KeyGroupAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getDynamic_ByKeyGroupId(keyGroupId);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  return {
    /**
     * Query key groups, if name is presented, it&#39;s fuzzy match.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: slice of key group&lt;/li&gt;&lt;/ul&gt;
     */
    getKeygroups,
    /**
     * Create key group.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: created key group&lt;/li&gt;&lt;/ul&gt;
     */
    createKeygroup,
    /**
     * @deprecated
     * Get key group.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: key group info&lt;/li&gt;&lt;/ul&gt;
     */
    getKeygroupsByBoothName,
    /**
     * Get key group.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: key group info&lt;/li&gt;&lt;/ul&gt;
     */
    getKeygroup_ByKeyGroupId,
    /**
     * Update key group.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: updated key group&lt;/li&gt;&lt;/ul&gt;
     */
    updateKeygroup_ByKeyGroupId,
    /**
     * This API is used to list keys of a key group.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: keys&lt;/li&gt;&lt;/ul&gt;
     */
    getKeys_ByKeyGroupId,
    /**
     * This API is used to upload keys with csv format to a key group.&lt;p&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: item data&lt;/li&gt;&lt;/ul&gt;
     */
    createKey_ByKeyGroupId,
    /**
     * Get key group dynamic.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: key group info&lt;/li&gt;&lt;/ul&gt;
     */
    getDynamic_ByKeyGroupId
  };
}

// src/generated-admin/OrderAdminApi.ts
var import_sdk54 = require("@accelbyte/sdk");
function OrderAdminApi(sdk, args) {
  const sdkAssembly = sdk.assembly();
  const namespace = args?.coreConfig?.namespace ?? sdkAssembly.coreConfig.namespace;
  const useSchemaValidation = args?.coreConfig?.useSchemaValidation ?? sdkAssembly.coreConfig.useSchemaValidation;
  let axiosInstance = sdkAssembly.axiosInstance;
  const requestConfigOverrides = args?.axiosConfig?.request;
  const baseURLOverride = args?.coreConfig?.baseURL;
  const interceptorsOverride = args?.axiosConfig?.interceptors ?? [];
  if (requestConfigOverrides || baseURLOverride || interceptorsOverride.length > 0) {
    const requestConfig = import_sdk54.ApiUtils.mergeAxiosConfigs(sdkAssembly.axiosInstance.defaults, {
      ...baseURLOverride ? { baseURL: baseURLOverride } : {},
      ...requestConfigOverrides
    });
    axiosInstance = import_sdk54.Network.create(requestConfig);
    for (const interceptor of interceptorsOverride) {
      if (interceptor.type === "request") {
        axiosInstance.interceptors.request.use(interceptor.onRequest, interceptor.onError);
      }
      if (interceptor.type === "response") {
        axiosInstance.interceptors.response.use(interceptor.onSuccess, interceptor.onError);
      }
    }
  }
  async function getOrders(queryParams) {
    const $ = new OrderAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getOrders(queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getOrdersStats() {
    const $ = new OrderAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getOrdersStats();
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getOrder_ByOrderNo(orderNo) {
    const $ = new OrderAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getOrder_ByOrderNo(orderNo);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getOrders_ByUserId(userId, queryParams) {
    const $ = new OrderAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getOrders_ByUserId(userId, queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function createOrder_ByUserId(userId, data) {
    const $ = new OrderAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.createOrder_ByUserId(userId, data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function updateRefund_ByOrderNo(orderNo, data) {
    const $ = new OrderAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.updateRefund_ByOrderNo(orderNo, data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getOrder_ByUserId_ByOrderNo(userId, orderNo) {
    const $ = new OrderAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getOrder_ByUserId_ByOrderNo(userId, orderNo);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function updateOrder_ByUserId_ByOrderNo(userId, orderNo, data) {
    const $ = new OrderAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.updateOrder_ByUserId_ByOrderNo(userId, orderNo, data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getOrdersCountOfItem_ByUserId(userId, queryParams) {
    const $ = new OrderAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getOrdersCountOfItem_ByUserId(userId, queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getGrant_ByUserId_ByOrderNo(userId, orderNo) {
    const $ = new OrderAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getGrant_ByUserId_ByOrderNo(userId, orderNo);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function updateFulfill_ByUserId_ByOrderNo(userId, orderNo) {
    const $ = new OrderAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.updateFulfill_ByUserId_ByOrderNo(userId, orderNo);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getHistory_ByUserId_ByOrderNo(userId, orderNo) {
    const $ = new OrderAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getHistory_ByUserId_ByOrderNo(userId, orderNo);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getReceiptPdf_ByUserId_ByOrderNo(userId, orderNo) {
    const $ = new OrderAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getReceiptPdf_ByUserId_ByOrderNo(userId, orderNo);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function createNotification_ByUserId_ByOrderNo(userId, orderNo, data) {
    const $ = new OrderAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.createNotification_ByUserId_ByOrderNo(userId, orderNo, data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  return {
    /**
     * Query orders.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: query orders&lt;/li&gt;&lt;/ul&gt;
     */
    getOrders,
    /**
     * Get Order Statistics.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: order statistics&lt;/li&gt;&lt;/ul&gt;
     */
    getOrdersStats,
    /**
     * Get order by orderNo.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: order instance&lt;/li&gt;&lt;/ul&gt;
     */
    getOrder_ByOrderNo,
    /**
     * Query user orders.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: get order&lt;/li&gt;&lt;/ul&gt;
     */
    getOrders_ByUserId,
    /**
     * Admin Create an order. The result contains the checkout link and payment token. User with permission SANDBOX will create sandbox order that not real paid for xsolla/alipay and not validate price for wxpay.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;It will be forbidden while the user is banned: ORDER_INITIATE or ORDER_AND_PAYMENT&lt;/li&gt;&lt;li&gt;sandbox default value is &lt;b&gt;false&lt;/b&gt;&lt;/li&gt;&lt;li&gt;platform default value is &lt;b&gt;Other&lt;/b&gt;&lt;/li&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: created order&lt;/li&gt;&lt;/ul&gt;&lt;h2&gt;Restrictions for ext field&lt;/h2&gt; 1. Cannot use &lt;b&gt;&#34;.&#34;&lt;/b&gt; as the key name - &lt;pre&gt;{ &#34;data.2&#34;: &#34;value&#34; }&lt;/pre&gt; 2. Cannot use &lt;b&gt;&#34;$&#34;&lt;/b&gt; as the prefix in key names - &lt;pre&gt;{ &#34;$data&#34;: &#34;value&#34; }&lt;/pre&gt;
     */
    createOrder_ByUserId,
    /**
     * Refund order by orderNo.
     */
    updateRefund_ByOrderNo,
    /**
     * Get an order.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: get order&lt;/li&gt;&lt;/ul&gt;
     */
    getOrder_ByUserId_ByOrderNo,
    /**
     * Update order status.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: updated order&lt;/li&gt;&lt;/ul&gt;
     */
    updateOrder_ByUserId_ByOrderNo,
    /**
     * This API is used to get the count of purchased item which is the order target.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: Item purchased count&lt;/li&gt;&lt;/ul&gt;
     */
    getOrdersCountOfItem_ByUserId,
    /**
     * @deprecated
     * Get user order grant that fulfilled by this order.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: get order grant&lt;/li&gt;&lt;/ul&gt;
     */
    getGrant_ByUserId_ByOrderNo,
    /**
     * Fulfill an order if the order is charged but fulfill failed.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: fulfilled order&lt;/li&gt;&lt;/ul&gt;
     */
    updateFulfill_ByUserId_ByOrderNo,
    /**
     * Get user order history.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: get order history&lt;/li&gt;&lt;/ul&gt;
     */
    getHistory_ByUserId_ByOrderNo,
    /**
     * Download user order receipt by orderNo.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: order receipt pdf&lt;/li&gt;&lt;/ul&gt;
     */
    getReceiptPdf_ByUserId_ByOrderNo,
    /**
     * &lt;b&gt;[SERVICE COMMUNICATION ONLY]&lt;/b&gt; This API is used as a web hook for payment notification from justice payment service.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: Process result&lt;/li&gt;&lt;/ul&gt;
     */
    createNotification_ByUserId_ByOrderNo
  };
}

// src/generated-admin/OrderDedicatedAdminApi.ts
var import_sdk55 = require("@accelbyte/sdk");
function OrderDedicatedAdminApi(sdk, args) {
  const sdkAssembly = sdk.assembly();
  const namespace = args?.coreConfig?.namespace ?? sdkAssembly.coreConfig.namespace;
  const useSchemaValidation = args?.coreConfig?.useSchemaValidation ?? sdkAssembly.coreConfig.useSchemaValidation;
  let axiosInstance = sdkAssembly.axiosInstance;
  const requestConfigOverrides = args?.axiosConfig?.request;
  const baseURLOverride = args?.coreConfig?.baseURL;
  const interceptorsOverride = args?.axiosConfig?.interceptors ?? [];
  if (requestConfigOverrides || baseURLOverride || interceptorsOverride.length > 0) {
    const requestConfig = import_sdk55.ApiUtils.mergeAxiosConfigs(sdkAssembly.axiosInstance.defaults, {
      ...baseURLOverride ? { baseURL: baseURLOverride } : {},
      ...requestConfigOverrides
    });
    axiosInstance = import_sdk55.Network.create(requestConfig);
    for (const interceptor of interceptorsOverride) {
      if (interceptor.type === "request") {
        axiosInstance.interceptors.request.use(interceptor.onRequest, interceptor.onError);
      }
      if (interceptor.type === "response") {
        axiosInstance.interceptors.response.use(interceptor.onSuccess, interceptor.onError);
      }
    }
  }
  async function getOrders(queryParams) {
    const $ = new OrderDedicatedAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getOrders(queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  return {
    /**
     * &lt;b&gt;[Not supported yet in AGS Shared Cloud]&lt;/b&gt;Sync orders. If response contains nextEvaluatedKey, please use it as query param in the next call to fetch the next batch, a batch has 1000 elements or less.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: sync orders&lt;/li&gt;&lt;/ul&gt;
     */
    getOrders
  };
}

// src/generated-admin/PaymentAdminApi.ts
var import_sdk56 = require("@accelbyte/sdk");
function PaymentAdminApi(sdk, args) {
  const sdkAssembly = sdk.assembly();
  const namespace = args?.coreConfig?.namespace ?? sdkAssembly.coreConfig.namespace;
  const useSchemaValidation = args?.coreConfig?.useSchemaValidation ?? sdkAssembly.coreConfig.useSchemaValidation;
  let axiosInstance = sdkAssembly.axiosInstance;
  const requestConfigOverrides = args?.axiosConfig?.request;
  const baseURLOverride = args?.coreConfig?.baseURL;
  const interceptorsOverride = args?.axiosConfig?.interceptors ?? [];
  if (requestConfigOverrides || baseURLOverride || interceptorsOverride.length > 0) {
    const requestConfig = import_sdk56.ApiUtils.mergeAxiosConfigs(sdkAssembly.axiosInstance.defaults, {
      ...baseURLOverride ? { baseURL: baseURLOverride } : {},
      ...requestConfigOverrides
    });
    axiosInstance = import_sdk56.Network.create(requestConfig);
    for (const interceptor of interceptorsOverride) {
      if (interceptor.type === "request") {
        axiosInstance.interceptors.request.use(interceptor.onRequest, interceptor.onError);
      }
      if (interceptor.type === "response") {
        axiosInstance.interceptors.response.use(interceptor.onSuccess, interceptor.onError);
      }
    }
  }
  async function getPaymentOrders(queryParams) {
    const $ = new PaymentAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getPaymentOrders(queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getPaymentNotifications(queryParams) {
    const $ = new PaymentAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getPaymentNotifications(queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getPaymentOrdersByExtTxId(queryParams) {
    const $ = new PaymentAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getPaymentOrdersByExtTxId(queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function createPaymentOrder_ByUserId(userId, data) {
    const $ = new PaymentAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.createPaymentOrder_ByUserId(userId, data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getPaymentOrder_ByPaymentOrderNo(paymentOrderNo) {
    const $ = new PaymentAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getPaymentOrder_ByPaymentOrderNo(paymentOrderNo);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function updatePaymentOrder_ByPaymentOrderNo(paymentOrderNo, data) {
    const $ = new PaymentAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.updatePaymentOrder_ByPaymentOrderNo(paymentOrderNo, data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getStatusPayment_ByPaymentOrderNo(paymentOrderNo) {
    const $ = new PaymentAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getStatusPayment_ByPaymentOrderNo(paymentOrderNo);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function updateSimulateNotificationPayment_ByPaymentOrderNo(paymentOrderNo, data) {
    const $ = new PaymentAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.updateSimulateNotificationPayment_ByPaymentOrderNo(paymentOrderNo, data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function updateRefundPayment_ByUserId_ByPaymentOrderNo(userId, paymentOrderNo, data) {
    const $ = new PaymentAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.updateRefundPayment_ByUserId_ByPaymentOrderNo(userId, paymentOrderNo, data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  return {
    /**
     * &lt;b&gt;[Not supported yet in AGS Shared Cloud]&lt;/b&gt;Query payment orders.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: query payment orders&lt;/li&gt;&lt;/ul&gt;
     */
    getPaymentOrders,
    /**
     * &lt;b&gt;[Not supported yet in AGS Shared Cloud]&lt;/b&gt;Query payment notifications.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: Payment notifications&lt;/li&gt;&lt;/ul&gt;
     */
    getPaymentNotifications,
    /**
     * &lt;b&gt;[Not supported yet in AGS Shared Cloud]&lt;/b&gt;List external order No by external transaction id.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: payment orders&lt;/li&gt;&lt;/ul&gt;
     */
    getPaymentOrdersByExtTxId,
    /**
     * &lt;b&gt;[Not supported yet in AGS Shared Cloud]&lt;/b&gt;&lt;b&gt;[SERVICE COMMUNICATION ONLY]&lt;/b&gt; This API is used to create payment order from justice service. The result contains the payment station url.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;It will be forbidden while the user is banned: PAYMENT_INITIATE or ORDER_AND_PAYMENT&lt;/li&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: created order&lt;/li&gt;&lt;/ul&gt;&lt;h2&gt;Restrictions for custom parameters and meta data&lt;/h2&gt; 1. Cannot use &lt;b&gt;&#34;.&#34;&lt;/b&gt; as the key name - &lt;pre&gt;{ &#34;data.2&#34;: &#34;value&#34; }&lt;/pre&gt; 2. Cannot use &lt;b&gt;&#34;$&#34;&lt;/b&gt; as the prefix in key names - &lt;pre&gt;{ &#34;$data&#34;: &#34;value&#34; }&lt;/pre&gt;
     */
    createPaymentOrder_ByUserId,
    /**
     * &lt;b&gt;[Not supported yet in AGS Shared Cloud]&lt;/b&gt;Get payment order by paymentOrderNo.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: payment order instance&lt;/li&gt;&lt;/ul&gt;
     */
    getPaymentOrder_ByPaymentOrderNo,
    /**
     * &lt;b&gt;[Not supported yet in AGS Shared Cloud]&lt;/b&gt;&lt;b&gt;[TEST FACILITY ONLY] Forbidden in live environment. &lt;/b&gt; Charge payment order without payment flow for unpaid payment order, usually for test usage to simulate real currency payment process.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: payment order instance&lt;/li&gt;&lt;/ul&gt;
     */
    updatePaymentOrder_ByPaymentOrderNo,
    /**
     * &lt;b&gt;[Not supported yet in AGS Shared Cloud]&lt;/b&gt;Get payment order charge status.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: payment order charge status&lt;/li&gt;&lt;/ul&gt;
     */
    getStatusPayment_ByPaymentOrderNo,
    /**
     * &lt;b&gt;[Not supported yet in AGS Shared Cloud]&lt;/b&gt;&lt;b&gt;[TEST FACILITY ONLY] Forbidden in live environment. &lt;/b&gt; Simulate payment notification on sandbox payment order, usually for test usage to simulate real currency payment notification.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: notification process result&lt;/li&gt;&lt;/ul&gt;
     */
    updateSimulateNotificationPayment_ByPaymentOrderNo,
    /**
     * &lt;b&gt;[Not supported yet in AGS Shared Cloud]&lt;/b&gt;&lt;b&gt;[SERVICE COMMUNICATION ONLY]&lt;/b&gt; This API is used to refund order by paymentOrderNo from justice service.
     */
    updateRefundPayment_ByUserId_ByPaymentOrderNo
  };
}

// src/generated-admin/PaymentCallbackConfigAdminApi.ts
var import_sdk57 = require("@accelbyte/sdk");
function PaymentCallbackConfigAdminApi(sdk, args) {
  const sdkAssembly = sdk.assembly();
  const namespace = args?.coreConfig?.namespace ?? sdkAssembly.coreConfig.namespace;
  const useSchemaValidation = args?.coreConfig?.useSchemaValidation ?? sdkAssembly.coreConfig.useSchemaValidation;
  let axiosInstance = sdkAssembly.axiosInstance;
  const requestConfigOverrides = args?.axiosConfig?.request;
  const baseURLOverride = args?.coreConfig?.baseURL;
  const interceptorsOverride = args?.axiosConfig?.interceptors ?? [];
  if (requestConfigOverrides || baseURLOverride || interceptorsOverride.length > 0) {
    const requestConfig = import_sdk57.ApiUtils.mergeAxiosConfigs(sdkAssembly.axiosInstance.defaults, {
      ...baseURLOverride ? { baseURL: baseURLOverride } : {},
      ...requestConfigOverrides
    });
    axiosInstance = import_sdk57.Network.create(requestConfig);
    for (const interceptor of interceptorsOverride) {
      if (interceptor.type === "request") {
        axiosInstance.interceptors.request.use(interceptor.onRequest, interceptor.onError);
      }
      if (interceptor.type === "response") {
        axiosInstance.interceptors.response.use(interceptor.onSuccess, interceptor.onError);
      }
    }
  }
  async function getPaymentConfigCallback() {
    const $ = new PaymentCallbackConfigAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getPaymentConfigCallback();
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function updatePaymentConfigCallback(data) {
    const $ = new PaymentCallbackConfigAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.updatePaymentConfigCallback(data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  return {
    /**
     * &lt;b&gt;[Not supported yet in AGS Shared Cloud]&lt;/b&gt;Get payment callback configuration.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: Payment callback config&lt;/li&gt;&lt;/ul&gt;
     */
    getPaymentConfigCallback,
    /**
     * &lt;b&gt;[Not supported yet in AGS Shared Cloud]&lt;/b&gt;Update payment callback configuration.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: Payment callback config&lt;/li&gt;&lt;/ul&gt;
     */
    updatePaymentConfigCallback
  };
}

// src/generated-admin/PaymentConfigAdminApi.ts
var import_sdk58 = require("@accelbyte/sdk");
function PaymentConfigAdminApi(sdk, args) {
  const sdkAssembly = sdk.assembly();
  const namespace = args?.coreConfig?.namespace ?? sdkAssembly.coreConfig.namespace;
  const useSchemaValidation = args?.coreConfig?.useSchemaValidation ?? sdkAssembly.coreConfig.useSchemaValidation;
  let axiosInstance = sdkAssembly.axiosInstance;
  const requestConfigOverrides = args?.axiosConfig?.request;
  const baseURLOverride = args?.coreConfig?.baseURL;
  const interceptorsOverride = args?.axiosConfig?.interceptors ?? [];
  if (requestConfigOverrides || baseURLOverride || interceptorsOverride.length > 0) {
    const requestConfig = import_sdk58.ApiUtils.mergeAxiosConfigs(sdkAssembly.axiosInstance.defaults, {
      ...baseURLOverride ? { baseURL: baseURLOverride } : {},
      ...requestConfigOverrides
    });
    axiosInstance = import_sdk58.Network.create(requestConfig);
    for (const interceptor of interceptorsOverride) {
      if (interceptor.type === "request") {
        axiosInstance.interceptors.request.use(interceptor.onRequest, interceptor.onError);
      }
      if (interceptor.type === "response") {
        axiosInstance.interceptors.response.use(interceptor.onSuccess, interceptor.onError);
      }
    }
  }
  async function getPaymentConfigTax() {
    const $ = new PaymentConfigAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getPaymentConfigTax();
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function updatePaymentConfigTax(data) {
    const $ = new PaymentConfigAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.updatePaymentConfigTax(data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getPaymentConfigProvider(queryParams) {
    const $ = new PaymentConfigAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getPaymentConfigProvider(queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function createPaymentConfigProvider(data) {
    const $ = new PaymentConfigAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.createPaymentConfigProvider(data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getPaymentConfigMerchant_ById(id) {
    const $ = new PaymentConfigAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getPaymentConfigMerchant_ById(id);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function deletePaymentConfigProvider_ById(id) {
    const $ = new PaymentConfigAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.deletePaymentConfigProvider_ById(id);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function updatePaymentConfigProvider_ById(id, data) {
    const $ = new PaymentConfigAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.updatePaymentConfigProvider_ById(id, data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getPaymentConfigMerchantMatched(queryParams) {
    const $ = new PaymentConfigAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getPaymentConfigMerchantMatched(queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getPaymentConfigProviderMatched(queryParams) {
    const $ = new PaymentConfigAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getPaymentConfigProviderMatched(queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getPaymentConfigProviderSpecial() {
    const $ = new PaymentConfigAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getPaymentConfigProviderSpecial();
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getPaymentConfigProviderAggregate() {
    const $ = new PaymentConfigAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getPaymentConfigProviderAggregate();
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function updateAdyenconfigPayment_ById(id, data, queryParams) {
    const $ = new PaymentConfigAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.updateAdyenconfigPayment_ById(id, data, queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function updateWxpayconfigPayment_ById(id, data, queryParams) {
    const $ = new PaymentConfigAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.updateWxpayconfigPayment_ById(id, data, queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function createPaymentConfigMerchantAdyenconfigTest(data, queryParams) {
    const $ = new PaymentConfigAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.createPaymentConfigMerchantAdyenconfigTest(data, queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function createPaymentConfigMerchantWxpayconfigTest(data) {
    const $ = new PaymentConfigAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.createPaymentConfigMerchantWxpayconfigTest(data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function updateAlipayconfigPayment_ById(id, data, queryParams) {
    const $ = new PaymentConfigAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.updateAlipayconfigPayment_ById(id, data, queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function updatePaypalconfigPayment_ById(id, data, queryParams) {
    const $ = new PaymentConfigAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.updatePaypalconfigPayment_ById(id, data, queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function updateStripeconfigPayment_ById(id, data, queryParams) {
    const $ = new PaymentConfigAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.updateStripeconfigPayment_ById(id, data, queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function updateXsollaconfigPayment_ById(id, data, queryParams) {
    const $ = new PaymentConfigAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.updateXsollaconfigPayment_ById(id, data, queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function createPaymentConfigMerchantAlipayconfigTest(data, queryParams) {
    const $ = new PaymentConfigAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.createPaymentConfigMerchantAlipayconfigTest(data, queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function createPaymentConfigMerchantPaypalconfigTest(data, queryParams) {
    const $ = new PaymentConfigAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.createPaymentConfigMerchantPaypalconfigTest(data, queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function createPaymentConfigMerchantStripeconfigTest(data, queryParams) {
    const $ = new PaymentConfigAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.createPaymentConfigMerchantStripeconfigTest(data, queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function createPaymentConfigMerchantXsollaconfigTest(data) {
    const $ = new PaymentConfigAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.createPaymentConfigMerchantXsollaconfigTest(data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function updateNeonpayconfigPayment_ById(id, data, queryParams) {
    const $ = new PaymentConfigAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.updateNeonpayconfigPayment_ById(id, data, queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function createPaymentConfigMerchantNeonpayconfigTest(data, queryParams) {
    const $ = new PaymentConfigAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.createPaymentConfigMerchantNeonpayconfigTest(data, queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function updateCheckoutconfigPayment_ById(id, data, queryParams) {
    const $ = new PaymentConfigAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.updateCheckoutconfigPayment_ById(id, data, queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function updateXsollauiconfigPayment_ById(id, data) {
    const $ = new PaymentConfigAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.updateXsollauiconfigPayment_ById(id, data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function createPaymentConfigMerchantCheckoutconfigTest(data, queryParams) {
    const $ = new PaymentConfigAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.createPaymentConfigMerchantCheckoutconfigTest(data, queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getPaymentConfigDomains() {
    const $ = new PaymentConfigAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getPaymentConfigDomains();
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function updatePaymentConfigDomain(data) {
    const $ = new PaymentConfigAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.updatePaymentConfigDomain(data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getAdyenconfigTestPayment_ById(id, queryParams) {
    const $ = new PaymentConfigAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getAdyenconfigTestPayment_ById(id, queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function updateWxpayconfigCertPayment_ById(id, data) {
    const $ = new PaymentConfigAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.updateWxpayconfigCertPayment_ById(id, data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getWxpayconfigTestPayment_ById(id) {
    const $ = new PaymentConfigAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getWxpayconfigTestPayment_ById(id);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getAlipayconfigTestPayment_ById(id, queryParams) {
    const $ = new PaymentConfigAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getAlipayconfigTestPayment_ById(id, queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getPaypalconfigTestPayment_ById(id, queryParams) {
    const $ = new PaymentConfigAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getPaypalconfigTestPayment_ById(id, queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getStripeconfigTestPayment_ById(id, queryParams) {
    const $ = new PaymentConfigAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getStripeconfigTestPayment_ById(id, queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getXsollaconfigTestPayment_ById(id) {
    const $ = new PaymentConfigAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getXsollaconfigTestPayment_ById(id);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getNeonpayconfigTestPayment_ById(id, queryParams) {
    const $ = new PaymentConfigAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getNeonpayconfigTestPayment_ById(id, queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getCheckoutconfigTestPayment_ById(id, queryParams) {
    const $ = new PaymentConfigAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getCheckoutconfigTestPayment_ById(id, queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  return {
    /**
     * &lt;b&gt;[Not supported yet in AGS Shared Cloud]&lt;/b&gt;Get payment global tax config.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: payment provider list&lt;/li&gt;&lt;/ul&gt;
     */
    getPaymentConfigTax,
    /**
     * &lt;b&gt;[Not supported yet in AGS Shared Cloud]&lt;/b&gt;Update payment tax config.&lt;br&gt;&lt;pre&gt;&lt;p&gt;&lt;strong&gt;Request Body Parameters:&lt;/strong&gt;&lt;/p&gt;&lt;pre&gt;&lt;table&gt;&lt;tr&gt;&lt;td&gt;Parameter&lt;/td&gt;&lt;td&gt;Type&lt;/td&gt;&lt;td&gt;Required&lt;/td&gt;&lt;td&gt;Description&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;taxJarEnabled&lt;/td&gt;&lt;td&gt;Boolean&lt;/td&gt;&lt;td&gt;false&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;taxJarApiToken&lt;/td&gt;&lt;td&gt;String&lt;/td&gt;&lt;td&gt;false&lt;/td&gt;&lt;td&gt;required, when taxJarEnabled is true and there is no existing token&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;sandboxTaxJarApiToken&lt;/td&gt;&lt;td&gt;String&lt;/td&gt;&lt;td&gt;false&lt;/td&gt;&lt;td&gt;optional&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;taxJarProductCodesMapping&lt;/td&gt;&lt;td&gt;Map&lt;/td&gt;&lt;td&gt;No&lt;/td&gt;&lt;td&gt;key is item type(APP|COINS|INGAMEITEM|BUNDLE|CODE|SUBSCRIPTION) and value is product tax code: https://developers.taxjar.com/api/reference/?ruby#get-list-tax-categories&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/pre&gt;&lt;/ol&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: payment global tax config&lt;/li&gt;&lt;/ul&gt;
     */
    updatePaymentConfigTax,
    /**
     * &lt;b&gt;[Not supported yet in AGS Shared Cloud]&lt;/b&gt;Query payment provider config.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: payment provider config list&lt;/li&gt;&lt;/ul&gt;
     */
    getPaymentConfigProvider,
    /**
     * &lt;b&gt;[Not supported yet in AGS Shared Cloud]&lt;/b&gt;Create payment provider config.&lt;br&gt;&lt;pre&gt;&lt;p&gt;&lt;strong&gt;Request Body Parameters:&lt;/strong&gt;&lt;/p&gt;&lt;pre&gt;&lt;table&gt;&lt;tr&gt;&lt;td&gt;Parameter&lt;/td&gt;&lt;td&gt;Type&lt;/td&gt;&lt;td&gt;Required&lt;/td&gt;&lt;td&gt;Description&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;namespace&lt;/td&gt;&lt;td&gt;String&lt;/td&gt;&lt;td&gt;Yes&lt;/td&gt;&lt;td&gt;namespace, * indicates all namespace&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;region&lt;/td&gt;&lt;td&gt;String&lt;/td&gt;&lt;td&gt;Yes&lt;/td&gt;&lt;td&gt;region, * indicates all regions&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;aggregate&lt;/td&gt;&lt;td&gt;String&lt;/td&gt;&lt;td&gt;No&lt;/td&gt;&lt;td&gt;aggregate payment provider, such as XSOLLA, ADYEN, STRIPE&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;specials&lt;/td&gt;&lt;td&gt;List&lt;/td&gt;&lt;td&gt;No&lt;/td&gt;&lt;td&gt;special payment provider, such as ALIPAY, WXPAY&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/pre&gt;payment provider applied has priority: &lt;ol&gt;&lt;li&gt;namespace and region match&lt;/li&gt;&lt;li&gt;namespace matches and region is *&lt;/li&gt;&lt;li&gt;region matches and namespace is *&lt;/li&gt;&lt;li&gt;namespace and region are *&lt;/li&gt;&lt;/ol&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: payment provider config&lt;/li&gt;&lt;/ul&gt;
     */
    createPaymentConfigProvider,
    /**
     * &lt;b&gt;[Not supported yet in AGS Shared Cloud]&lt;/b&gt;Get payment merchant config by id.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: payment merchant config info&lt;/li&gt;&lt;/ul&gt;
     */
    getPaymentConfigMerchant_ById,
    /**
     * &lt;b&gt;[Not supported yet in AGS Shared Cloud]&lt;/b&gt;Delete payment provider config.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: payment provider config&lt;/li&gt;&lt;/ul&gt;
     */
    deletePaymentConfigProvider_ById,
    /**
     * &lt;b&gt;[Not supported yet in AGS Shared Cloud]&lt;/b&gt;Update payment provider config.&lt;br&gt;&lt;pre&gt;&lt;p&gt;&lt;strong&gt;Request Body Parameters:&lt;/strong&gt;&lt;/p&gt;&lt;pre&gt;&lt;table&gt;&lt;tr&gt;&lt;td&gt;Parameter&lt;/td&gt;&lt;td&gt;Type&lt;/td&gt;&lt;td&gt;Required&lt;/td&gt;&lt;td&gt;Description&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;namespace&lt;/td&gt;&lt;td&gt;String&lt;/td&gt;&lt;td&gt;Yes&lt;/td&gt;&lt;td&gt;namespace, * indicates all namespace&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;region&lt;/td&gt;&lt;td&gt;String&lt;/td&gt;&lt;td&gt;Yes&lt;/td&gt;&lt;td&gt;region, * indicates all regions&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;aggregate&lt;/td&gt;&lt;td&gt;String&lt;/td&gt;&lt;td&gt;No&lt;/td&gt;&lt;td&gt;aggregate payment provider, such as XSOLLA, ADYEN, STRIPE&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;specials&lt;/td&gt;&lt;td&gt;List&lt;/td&gt;&lt;td&gt;No&lt;/td&gt;&lt;td&gt;special payment provider, such as ALIPAY, WXPAY&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/pre&gt;payment provider applied has priority: &lt;ol&gt;&lt;li&gt;namespace and region match&lt;/li&gt;&lt;li&gt;namespace matches and region is *&lt;/li&gt;&lt;li&gt;region matches and namespace is *&lt;/li&gt;&lt;li&gt;namespace and region are *&lt;/li&gt;&lt;/ol&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: payment provider config&lt;/li&gt;&lt;/ul&gt;
     */
    updatePaymentConfigProvider_ById,
    /**
     * &lt;b&gt;[Not supported yet in AGS Shared Cloud]&lt;/b&gt;Debug matched payment merchant config.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: payment merchant config info&lt;/li&gt;&lt;/ul&gt;
     */
    getPaymentConfigMerchantMatched,
    /**
     * &lt;b&gt;[Not supported yet in AGS Shared Cloud]&lt;/b&gt;Debug matched payment provider config.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: payment provider config&lt;/li&gt;&lt;/ul&gt;
     */
    getPaymentConfigProviderMatched,
    /**
     * &lt;b&gt;[Not supported yet in AGS Shared Cloud]&lt;/b&gt;Get special payment providers, such as ALIPAY, WXPAY.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: payment provider list&lt;/li&gt;&lt;/ul&gt;
     */
    getPaymentConfigProviderSpecial,
    /**
     * &lt;b&gt;[Not supported yet in AGS Shared Cloud]&lt;/b&gt;Get aggregate payment providers, such as XSOLLA, ADYEN.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: payment provider list&lt;/li&gt;&lt;/ul&gt;
     */
    getPaymentConfigProviderAggregate,
    /**
     * &lt;b&gt;[Not supported yet in AGS Shared Cloud]&lt;/b&gt;Update adyen config.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: updated payment merchant config&lt;/li&gt;&lt;/ul&gt;
     */
    updateAdyenconfigPayment_ById,
    /**
     * &lt;b&gt;[Not supported yet in AGS Shared Cloud]&lt;/b&gt;Update wxpay configuration.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: updated payment merchant config&lt;/li&gt;&lt;/ul&gt;
     */
    updateWxpayconfigPayment_ById,
    /**
     * &lt;b&gt;[Not supported yet in AGS Shared Cloud]&lt;/b&gt;Test adyen configuration. &lt;h4&gt;Check List:&lt;/h4&gt; &lt;ul&gt;&lt;li&gt;apiKey&lt;/li&gt;&lt;li&gt;merchantAccount&lt;/li&gt;&lt;/ul&gt;&lt;h4&gt;Non-check list:&lt;/h4&gt;&lt;ul&gt;&lt;li&gt;notificationHmacKey&lt;/li&gt;&lt;li&gt;notificationUsername&lt;/li&gt;&lt;li&gt;notificationPassword&lt;/li&gt;&lt;li&gt;liveEndpointUrlPrefix&lt;/li&gt;&lt;li&gt;allowedPaymentMethods&lt;/li&gt;&lt;li&gt;blockedPaymentMethods&lt;/li&gt;&lt;li&gt;settings&lt;/li&gt;&lt;/ul&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: test adyen config&lt;/li&gt;&lt;/ul&gt;
     */
    createPaymentConfigMerchantAdyenconfigTest,
    /**
     * &lt;b&gt;[Not supported yet in AGS Shared Cloud]&lt;/b&gt;Test WxPay configuration. Reference: &lt;a href=&#34;https://pay.weixin.qq.com/wiki/doc/api/native.php?chapter=9_1&#34;&gt;WxPay Document&lt;/a&gt;.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: test WxPay config&lt;/li&gt;&lt;/ul&gt;
     */
    createPaymentConfigMerchantWxpayconfigTest,
    /**
     * &lt;b&gt;[Not supported yet in AGS Shared Cloud]&lt;/b&gt;Update alipay configuration.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: updated payment merchant config&lt;/li&gt;&lt;/ul&gt;
     */
    updateAlipayconfigPayment_ById,
    /**
     * &lt;b&gt;[Not supported yet in AGS Shared Cloud]&lt;/b&gt;Update PayPal config.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: updated payment merchant config&lt;/li&gt;&lt;/ul&gt;
     */
    updatePaypalconfigPayment_ById,
    /**
     * &lt;b&gt;[Not supported yet in AGS Shared Cloud]&lt;/b&gt;Update stripe config.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: updated payment merchant config&lt;/li&gt;&lt;/ul&gt;
     */
    updateStripeconfigPayment_ById,
    /**
     * &lt;b&gt;[Not supported yet in AGS Shared Cloud]&lt;/b&gt;Update xsolla configuration. Reference: &lt;a href=&#34;https://developers.xsolla.com/?#simple-checkout&#34;&gt;Xsolla Document&lt;/a&gt;.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: updated payment merchant config&lt;/li&gt;&lt;/ul&gt;
     */
    updateXsollaconfigPayment_ById,
    /**
     * &lt;b&gt;[Not supported yet in AGS Shared Cloud]&lt;/b&gt;Test AliPay configuration.Reference: &lt;a href=&#34;https://docs.open.alipay.com/270/alipay.trade.page.pay&#34;&gt;Alipay Document&lt;/a&gt;.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: test result&lt;/li&gt;&lt;/ul&gt;
     */
    createPaymentConfigMerchantAlipayconfigTest,
    /**
     * &lt;b&gt;[Not supported yet in AGS Shared Cloud]&lt;/b&gt;Test PayPal configuration. &lt;h4&gt;Check List:&lt;/h4&gt; &lt;ul&gt;&lt;li&gt;clientID&lt;/li&gt;&lt;li&gt;clientSecret&lt;/li&gt;&lt;/ul&gt;&lt;h4&gt;Non-check list:&lt;/h4&gt;&lt;ul&gt;&lt;li&gt;webHookId&lt;/li&gt;&lt;/ul&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: test result&lt;/li&gt;&lt;/ul&gt;
     */
    createPaymentConfigMerchantPaypalconfigTest,
    /**
     * &lt;b&gt;[Not supported yet in AGS Shared Cloud]&lt;/b&gt;Test stripe configuration. &lt;h4&gt;Check List:&lt;/h4&gt; &lt;ul&gt;&lt;li&gt;secretKey&lt;/li&gt;&lt;li&gt;allowedPaymentMethodTypes&lt;/li&gt;&lt;/ul&gt;&lt;h4&gt;Non-check list:&lt;/h4&gt;&lt;ul&gt;&lt;li&gt;publishableKey&lt;/li&gt;&lt;li&gt;webhookSecret&lt;/li&gt;&lt;/ul&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: test adyen config&lt;/li&gt;&lt;/ul&gt;
     */
    createPaymentConfigMerchantStripeconfigTest,
    /**
     * &lt;b&gt;[Not supported yet in AGS Shared Cloud]&lt;/b&gt;Check xsolla configuration, Reference: &lt;a href=&#34;https://developers.xsolla.com/?#simple-checkout&#34;&gt;Xsolla Document&lt;/a&gt;.&lt;h4&gt;Check List:&lt;/h4&gt; &lt;ul&gt;&lt;li&gt;merchantId&lt;/li&gt;&lt;li&gt;projectId&lt;/li&gt;&lt;li&gt;apiKey&lt;/li&gt;&lt;/ul&gt;&lt;h4&gt;Non-check list:&lt;/h4&gt;&lt;ul&gt;&lt;li&gt;projectSecretKey&lt;/li&gt;&lt;/ul&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: test result&lt;/li&gt;&lt;/ul&gt;
     */
    createPaymentConfigMerchantXsollaconfigTest,
    /**
     * &lt;b&gt;[Not supported yet in AGS Shared Cloud]&lt;/b&gt;Update Neon Pay config.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: updated payment merchant config&lt;/li&gt;&lt;/ul&gt;
     */
    updateNeonpayconfigPayment_ById,
    /**
     * &lt;b&gt;[Not supported yet in AGS Shared Cloud]&lt;/b&gt;Check Neon Pay configuration, Reference: &lt;a href=&#34;https://docs.neonpay.com/docs/checkout&#34;&gt;Neon Pay Document&lt;/a&gt;.&lt;h4&gt;Check List:&lt;/h4&gt; &lt;ul&gt;&lt;li&gt;apiKey&lt;/li&gt;&lt;li&gt;webhookSecretKey&lt;/li&gt;&lt;/ul&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: test result&lt;/li&gt;&lt;/ul&gt;
     */
    createPaymentConfigMerchantNeonpayconfigTest,
    /**
     * &lt;b&gt;[Not supported yet in AGS Shared Cloud]&lt;/b&gt;Update checkout.com config.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: updated payment merchant config&lt;/li&gt;&lt;/ul&gt;
     */
    updateCheckoutconfigPayment_ById,
    /**
     * &lt;b&gt;[Not supported yet in AGS Shared Cloud]&lt;/b&gt;Update xsolla UI configuration.Reference: &lt;a href=&#34;https://developers.xsolla.com/api.html#ui-integrations&#34;&gt;Xsolla Document&lt;/a&gt;.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: updated payment merchant config&lt;/li&gt;&lt;/ul&gt;
     */
    updateXsollauiconfigPayment_ById,
    /**
     * &lt;b&gt;[Not supported yet in AGS Shared Cloud]&lt;/b&gt;Test checkout.com configuration. &lt;h4&gt;Check List:&lt;/h4&gt; &lt;ul&gt;&lt;li&gt;publicKey&lt;/li&gt;&lt;li&gt;secretKey&lt;/li&gt;&lt;/ul&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: test result&lt;/li&gt;&lt;/ul&gt;
     */
    createPaymentConfigMerchantCheckoutconfigTest,
    /**
     * &lt;b&gt;[Not supported yet in AGS Shared Cloud]&lt;/b&gt;Get payment domain whitelist config by namespace.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: payment domain whitelist config info&lt;/li&gt;&lt;/ul&gt;
     */
    getPaymentConfigDomains,
    /**
     * &lt;b&gt;[Not supported yet in AGS Shared Cloud]&lt;/b&gt;Update payment provider config by namespace.&lt;br&gt;&lt;pre&gt;&lt;p&gt;&lt;strong&gt;Request Body Parameters:&lt;/strong&gt;&lt;/p&gt;&lt;pre&gt;&lt;table&gt;&lt;tr&gt;&lt;td&gt;Parameter&lt;/td&gt;&lt;td&gt;Type&lt;/td&gt;&lt;td&gt;Required&lt;/td&gt;&lt;td&gt;Description&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;domains&lt;/td&gt;&lt;td&gt;String&lt;/td&gt;&lt;td&gt;Yes&lt;/td&gt;&lt;td&gt;list of domains to whitelist for the return URL.&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/pre&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Validation&lt;/i&gt;: the domain should include the protocol (http/https), but the whitelist check will only compare the host part (www.example.com)&lt;/li&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: payment domain whitelist config&lt;/li&gt;&lt;/ul&gt;
     */
    updatePaymentConfigDomain,
    /**
     * &lt;b&gt;[Not supported yet in AGS Shared Cloud]&lt;/b&gt;Test adyen configuration in payment merchant config. Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: test adyen config&lt;/li&gt;&lt;/ul&gt;
     */
    getAdyenconfigTestPayment_ById,
    /**
     * &lt;b&gt;[Not supported yet in AGS Shared Cloud]&lt;/b&gt;Upload wxpay cert file.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: updated payment merchant config&lt;/li&gt;&lt;/ul&gt;
     */
    updateWxpayconfigCertPayment_ById,
    /**
     * &lt;b&gt;[Not supported yet in AGS Shared Cloud]&lt;/b&gt;Test WxPay configuration in payment merchant config. Reference: &lt;a href=&#34;https://pay.weixin.qq.com/wiki/doc/api/native.php?chapter=9_1&#34;&gt;WxPay Document&lt;/a&gt;.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: test WxPay config&lt;/li&gt;&lt;/ul&gt;
     */
    getWxpayconfigTestPayment_ById,
    /**
     * &lt;b&gt;[Not supported yet in AGS Shared Cloud]&lt;/b&gt;Test AliPay configuration in payment merchant config. Reference: &lt;a href=&#34;https://docs.open.alipay.com/270/alipay.trade.page.pay&#34;&gt;Alipay Document&lt;/a&gt;.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: test alipay config&lt;/li&gt;&lt;/ul&gt;
     */
    getAlipayconfigTestPayment_ById,
    /**
     * &lt;b&gt;[Not supported yet in AGS Shared Cloud]&lt;/b&gt;Test PayPal configuration in payment merchant config. Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: test result&lt;/li&gt;&lt;/ul&gt;
     */
    getPaypalconfigTestPayment_ById,
    /**
     * &lt;b&gt;[Not supported yet in AGS Shared Cloud]&lt;/b&gt;Test stripe configuration in payment merchant config. Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: test adyen config&lt;/li&gt;&lt;/ul&gt;
     */
    getStripeconfigTestPayment_ById,
    /**
     * &lt;b&gt;[Not supported yet in AGS Shared Cloud]&lt;/b&gt;Test xsolla configuration in payment merchant config. Reference: &lt;a href=&#34;https://developers.xsolla.com/?#simple-checkout&#34;&gt;Xsolla Document&lt;/a&gt;.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: test xsolla config&lt;/li&gt;&lt;/ul&gt;
     */
    getXsollaconfigTestPayment_ById,
    /**
     * &lt;b&gt;[Not supported yet in AGS Shared Cloud]&lt;/b&gt;Test Neon Pay configuration in payment merchant config. Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: test result&lt;/li&gt;&lt;/ul&gt;
     */
    getNeonpayconfigTestPayment_ById,
    /**
     * &lt;b&gt;[Not supported yet in AGS Shared Cloud]&lt;/b&gt;Test checkout.com configuration in payment merchant config. Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: test result&lt;/li&gt;&lt;/ul&gt;
     */
    getCheckoutconfigTestPayment_ById
  };
}

// src/generated-admin/PaymentDedicatedAdminApi.ts
var import_sdk59 = require("@accelbyte/sdk");
function PaymentDedicatedAdminApi(sdk, args) {
  const sdkAssembly = sdk.assembly();
  const namespace = args?.coreConfig?.namespace ?? sdkAssembly.coreConfig.namespace;
  const useSchemaValidation = args?.coreConfig?.useSchemaValidation ?? sdkAssembly.coreConfig.useSchemaValidation;
  let axiosInstance = sdkAssembly.axiosInstance;
  const requestConfigOverrides = args?.axiosConfig?.request;
  const baseURLOverride = args?.coreConfig?.baseURL;
  const interceptorsOverride = args?.axiosConfig?.interceptors ?? [];
  if (requestConfigOverrides || baseURLOverride || interceptorsOverride.length > 0) {
    const requestConfig = import_sdk59.ApiUtils.mergeAxiosConfigs(sdkAssembly.axiosInstance.defaults, {
      ...baseURLOverride ? { baseURL: baseURLOverride } : {},
      ...requestConfigOverrides
    });
    axiosInstance = import_sdk59.Network.create(requestConfig);
    for (const interceptor of interceptorsOverride) {
      if (interceptor.type === "request") {
        axiosInstance.interceptors.request.use(interceptor.onRequest, interceptor.onError);
      }
      if (interceptor.type === "response") {
        axiosInstance.interceptors.response.use(interceptor.onSuccess, interceptor.onError);
      }
    }
  }
  async function getPaymentOrders(queryParams) {
    const $ = new PaymentDedicatedAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getPaymentOrders(queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function createPaymentOrder(data) {
    const $ = new PaymentDedicatedAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.createPaymentOrder(data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function updateRefundPayment_ByPaymentOrderNo(paymentOrderNo, data) {
    const $ = new PaymentDedicatedAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.updateRefundPayment_ByPaymentOrderNo(paymentOrderNo, data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  return {
    /**
     * &lt;b&gt;[Not supported yet in AGS Shared Cloud]&lt;/b&gt;Sync payment orders. If response contains nextEvaluatedKey, please use it as query param in the next call to fetch the next batch, a batch has 1000 elements or less.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: sync payment orders&lt;/li&gt;&lt;/ul&gt;
     */
    getPaymentOrders,
    /**
     * &lt;b&gt;[Not supported yet in AGS Shared Cloud]&lt;/b&gt;&lt;p&gt;This API is used to create payment order from non justice service. e.g. from dedicated server, the result contains the payment station url.&lt;/p&gt;&lt;p&gt;&lt;strong&gt;Path Parameter:&lt;/strong&gt;&lt;/p&gt;&lt;pre&gt;&lt;table&gt;&lt;tr&gt;&lt;td&gt;Parameter&lt;/td&gt;&lt;td&gt;Type&lt;/td&gt;&lt;td&gt;Required&lt;/td&gt;&lt;td&gt;Description&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;namespace&lt;/td&gt;&lt;td&gt;String&lt;/td&gt;&lt;td&gt;Yes&lt;/td&gt;&lt;td&gt;Namespace that payment order resides in, should be publisher namespace if it&#39;s a Steam like platform that share &lt;br&gt;payment config cross namespaces, otherwise it&#39;s the game namespace&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;p&gt;&lt;strong&gt;Request Body Parameters:&lt;/strong&gt;&lt;/p&gt;&lt;pre&gt;&lt;table&gt;&lt;tr&gt;&lt;td&gt;Parameter&lt;/td&gt;&lt;td&gt;Type&lt;/td&gt;&lt;td&gt;Required&lt;/td&gt;&lt;td&gt;Description&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;extOrderNo&lt;/td&gt;&lt;td&gt;String&lt;/td&gt;&lt;td&gt;Yes&lt;/td&gt;&lt;td&gt;External order number, it should be unique in invoker order system&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;sku&lt;/td&gt;&lt;td&gt;String&lt;/td&gt;&lt;td&gt;No&lt;/td&gt;&lt;td&gt;Item identity&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;targetNamespace&lt;/td&gt;&lt;td&gt;String&lt;/td&gt;&lt;td&gt;Yes&lt;/td&gt;&lt;td&gt;The game namespace&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;targetUserId&lt;/td&gt;&lt;td&gt;String&lt;/td&gt;&lt;td&gt;Yes&lt;/td&gt;&lt;td&gt;User id for the order owner in game namespace&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;extUserId&lt;/td&gt;&lt;td&gt;String&lt;/td&gt;&lt;td&gt;No&lt;/td&gt;&lt;td&gt;External user id, can be user character id &lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;price&lt;/td&gt;&lt;td&gt;int&lt;/td&gt;&lt;td&gt;Yes&lt;/td&gt;&lt;td&gt;price which should be greater than 0&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;title&lt;/td&gt;&lt;td&gt;String&lt;/td&gt;&lt;td&gt;Yes&lt;/td&gt;&lt;td&gt;Item title&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;description&lt;/td&gt;&lt;td&gt;String&lt;/td&gt;&lt;td&gt;Yes&lt;/td&gt;&lt;td&gt;Item description&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;currencyCode&lt;/td&gt;&lt;td&gt;String&lt;/td&gt;&lt;td&gt;No&lt;/td&gt;&lt;td&gt;Currency code, default is USD&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;currencyNamespace&lt;/td&gt;&lt;td&gt;String&lt;/td&gt;&lt;td&gt;No&lt;/td&gt;&lt;td&gt;Currency namespace, default is publisher namespace&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;region&lt;/td&gt;&lt;td&gt;String&lt;/td&gt;&lt;td&gt;No&lt;/td&gt;&lt;td&gt;Country of the user, will get from user info if not present&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;language&lt;/td&gt;&lt;td&gt;String&lt;/td&gt;&lt;td&gt;No&lt;/td&gt;&lt;td&gt;Language of the user&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;sandbox&lt;/td&gt;&lt;td&gt;Boolean&lt;/td&gt;&lt;td&gt;No&lt;/td&gt;&lt;td&gt;set to true will create sandbox order that not real paid for xsolla/alipay and will not validate &lt;br&gt;price for wxpay.&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;returnUrl&lt;/td&gt;&lt;td&gt;String&lt;/td&gt;&lt;td&gt;No&lt;/td&gt;&lt;td&gt;customized return url for redirect once payment finished, leave unset to use configuration in &lt;br&gt;namespace&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;notifyUrl&lt;/td&gt;&lt;td&gt;String&lt;/td&gt;&lt;td&gt;No&lt;/td&gt;&lt;td&gt;customized notify url for payment web hook, leave unset to use configuration in namespace&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;customParameters&lt;/td&gt;&lt;td&gt;String&lt;/td&gt;&lt;td&gt;No&lt;/td&gt;&lt;td&gt;Custom parameters&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;Request Body Example:&lt;/strong&gt;&lt;/p&gt;&lt;pre&gt;&lt;code style=&#39;overflow: auto&#39;&gt;{ &#34;extOrderNo&#34;: &#34;123456789&#34;, &#34;sku&#34;: &#34;sku&#34;, &#34;targetNamespace&#34;: &#34;game1&#34;, &#34;targetUserId&#34;: &#34;94451623768940d58416ca33ca767ec3&#34;, &#34;extUserId&#34;: &#34;678&#34;, &#34;title&#34;: &#34;Frostmourne&#34;, &#34;description\&#34;: &#34;Here was power. Here was despair&#34;, &#34;price&#34;: 100, &#34;region&#34;: &#34;CN&#34;, &#34;language&#34;: &#34;zh-CN&#34;, &#34;currencyCode&#34;: &#34;USD&#34;, &#34;currencyNamespace&#34;: &#34;accelbyte&#34; }&lt;/pre&gt;&lt;/code&gt;&lt;h4&gt;Payment Notification:&lt;/h4&gt;&lt;p&gt;After user complete the payment, it will send notification to configured web hook, http status code should return 200 or 204 once you resolve notification successfully, otherwise payment system will retry notification in interval&lt;/p&gt;&lt;p&gt;&lt;strong&gt;Payment notification parameter:&lt;/strong&gt;&lt;/p&gt;&lt;pre&gt;&lt;table&gt;&lt;tr&gt;&lt;td&gt;Parameter&lt;/td&gt;&lt;td&gt;Type&lt;/td&gt;&lt;td&gt;Required&lt;/td&gt;&lt;td&gt;Description&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;payload&lt;/td&gt;&lt;td&gt;String&lt;/td&gt;&lt;td&gt;Yes&lt;/td&gt;&lt;td&gt;Payment notification payload in json string &lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;sign&lt;/td&gt;&lt;td&gt;String&lt;/td&gt;&lt;td&gt;Yes&lt;/td&gt;&lt;td&gt;sha1 hex signature for payload and private key&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;Payment notification parameter Example:&lt;/strong&gt;&lt;/p&gt;&lt;pre&gt;&lt;code style=&#39;overflow: auto&#39;&gt;{ &#34;payload&#34;: &#34;{ \&#34;type\&#34;: \&#34;payment\&#34;, \&#34;nonceStr\&#34;: \&#34;34c1dcf3eb58455eb161465bbfc0b590\&#34;, \&#34;paymentOrderNo\&#34;: \&#34;18081239088\&#34;, \&#34;namespace\&#34;: \&#34;accelbyte\&#34;, \&#34;targetNamespace\&#34;: \&#34;game1\&#34;, \&#34;targetUserId\&#34;: \&#34;94451623768940d58416ca33ca767ec3\&#34;, \&#34;extOrderNo\&#34;: \&#34;123456789\&#34;, \&#34;sku\&#34;: \&#34;sku\&#34;, \&#34;extUserId\&#34;: \&#34;678\&#34;, \&#34;price\&#34;: 100, \&#34;paymentProvider\&#34;: \&#34;XSOLLA\&#34;, \&#34;vat\&#34;: 0, \&#34;salesTax\&#34;: 0, \&#34;paymentProviderFee\&#34;: 0, \&#34;paymentMethodFee\&#34;: 0, \&#34;currency\&#34;: { \&#34;currencyCode\&#34;: \&#34;USD\&#34;, \&#34;currencySymbol\&#34;: \&#34;$\&#34;, \&#34;currencyType\&#34;: \&#34;REAL\&#34;, \&#34;namespace\&#34;: \&#34;accelbyte\&#34;, \&#34;decimals\&#34;: 2 }, \&#34;status\&#34;: \&#34;CHARGED\&#34;, \&#34;createdTime\&#34;: \&#34;2018-07-28T00:39:16.274Z\&#34;, \&#34;chargedTime\&#34;: \&#34;2018-07-28T00:39:16.274Z\&#34; }&#34;, &#34;sign&#34;:&#34;e31fb92516cc9faaf50ad70343e1293acec6f3d5&#34; }&lt;/pre&gt;&lt;/code&gt;&lt;p&gt;&lt;strong&gt;Payment notification payload parameter list:&lt;/strong&gt;&lt;/p&gt;&lt;pre&gt;&lt;table&gt;&lt;tr&gt;&lt;td&gt;Parameter&lt;/td&gt;&lt;td&gt;Type&lt;/td&gt;&lt;td&gt;Required&lt;/td&gt;&lt;td&gt;Description&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;type&lt;/td&gt;&lt;td&gt;String&lt;/td&gt;&lt;td&gt;Yes&lt;/td&gt;&lt;td&gt;Notification type: &#39;payment&#39;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;paymentOrderNo&lt;/td&gt;&lt;td&gt;String&lt;/td&gt;&lt;td&gt;Yes&lt;/td&gt;&lt;td&gt;Payment system generated order number&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;extOrderNo&lt;/td&gt;&lt;td&gt;String&lt;/td&gt;&lt;td&gt;No&lt;/td&gt;&lt;td&gt;External order number that passed by invoker&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;namespace&lt;/td&gt;&lt;td&gt;String&lt;/td&gt;&lt;td&gt;Yes&lt;/td&gt;&lt;td&gt;Namespace that related payment order resides in&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;targetNamespace&lt;/td&gt;&lt;td&gt;String&lt;/td&gt;&lt;td&gt;Yes&lt;/td&gt;&lt;td&gt;The game namespace&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;targetUserId&lt;/td&gt;&lt;td&gt;String&lt;/td&gt;&lt;td&gt;Yes&lt;/td&gt;&lt;td&gt;The user id in game namespace&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;sku&lt;/td&gt;&lt;td&gt;String&lt;/td&gt;&lt;td&gt;No&lt;/td&gt;&lt;td&gt;Item identify, it will return if pass it when create payment&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;extUserId&lt;/td&gt;&lt;td&gt;String&lt;/td&gt;&lt;td&gt;No&lt;/td&gt;&lt;td&gt;External user id, can be character id, it will return if pass it when create payment&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;price&lt;/td&gt;&lt;td&gt;int&lt;/td&gt;&lt;td&gt;Yes&lt;/td&gt;&lt;td&gt;Price of item&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;paymentProvider&lt;/td&gt;&lt;td&gt;String&lt;/td&gt;&lt;td&gt;Yes&lt;/td&gt;&lt;td&gt;Payment provider, allowed values: xsolla/alipay/wxpay/wallet&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;vat&lt;/td&gt;&lt;td&gt;int&lt;/td&gt;&lt;td&gt;Yes&lt;/td&gt;&lt;td&gt;Payment order VAT&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;salesTax&lt;/td&gt;&lt;td&gt;int&lt;/td&gt;&lt;td&gt;Yes&lt;/td&gt;&lt;td&gt;Payment order sales tax&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;paymentProviderFee&lt;/td&gt;&lt;td&gt;int&lt;/td&gt;&lt;td&gt;Yes&lt;/td&gt;&lt;td&gt;Payment provider fee&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;paymentMethodFee&lt;/td&gt;&lt;td&gt;int&lt;/td&gt;&lt;td&gt;Yes&lt;/td&gt;&lt;td&gt;Payment method fee&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;currency&lt;/td&gt;&lt;td&gt;Map&lt;/td&gt;&lt;td&gt;Yes&lt;/td&gt;&lt;td&gt;Payment order currency info&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;status&lt;/td&gt;&lt;td&gt;String&lt;/td&gt;&lt;td&gt;Yes&lt;/td&gt;&lt;td&gt;Payment order status&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;statusReason&lt;/td&gt;&lt;td&gt;String&lt;/td&gt;&lt;td&gt;No&lt;/td&gt;&lt;td&gt;Payment order status reason&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;createdTime&lt;/td&gt;&lt;td&gt;Datetime&lt;/td&gt;&lt;td&gt;No&lt;/td&gt;&lt;td&gt;The time of the order created&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;chargedTime&lt;/td&gt;&lt;td&gt;Datetime&lt;/td&gt;&lt;td&gt;No&lt;/td&gt;&lt;td&gt;The time of the order charged&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;customParameters&lt;/td&gt;&lt;td&gt;Map&lt;/td&gt;&lt;td&gt;No&lt;/td&gt;&lt;td&gt;custom parameters, will return if pass it when create payment&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;nonceStr&lt;/td&gt;&lt;td&gt;String&lt;/td&gt;&lt;td&gt;Yes&lt;/td&gt;&lt;td&gt;Random string, max length is 32, can be timestamp or uuid&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;Currency info parameter list:&lt;/strong&gt;&lt;/p&gt;&lt;pre&gt;&lt;table&gt;&lt;tr&gt;&lt;td&gt;Parameter&lt;/td&gt;&lt;td&gt;Type&lt;/td&gt;&lt;td&gt;Required&lt;/td&gt;&lt;td&gt;Description&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;currencyCode&lt;/td&gt;&lt;td&gt;String&lt;/td&gt;&lt;td&gt;Yes&lt;/td&gt;&lt;td&gt;Currency Code&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;currencySymbol&lt;/td&gt;&lt;td&gt;String&lt;/td&gt;&lt;td&gt;Yes&lt;/td&gt;&lt;td&gt;Currency Symbol&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;currencyType&lt;/td&gt;&lt;td&gt;String&lt;/td&gt;&lt;td&gt;Yes&lt;/td&gt;&lt;td&gt;Currency type(REAL/VIRTUAL)&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;namespace&lt;/td&gt;&lt;td&gt;String&lt;/td&gt;&lt;td&gt;Yes&lt;/td&gt;&lt;td&gt;Currency namespace&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;decimals&lt;/td&gt;&lt;td&gt;int&lt;/td&gt;&lt;td&gt;Yes&lt;/td&gt;&lt;td&gt;Currency decimals&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/pre&gt;&lt;h4&gt;Encryption Rule:&lt;/h4&gt;&lt;p&gt;Concat payload json string and private key and then do sha1Hex.&lt;/p&gt;&lt;h4&gt;Other detail info:&lt;/h4&gt; &lt;ul&gt;&lt;li&gt;&lt;i&gt;Token type&lt;/i&gt;: client token&lt;/li&gt;&lt;li&gt;&lt;i&gt;Optional permission(user with this permission will create sandbox order)&lt;/i&gt;: resource=&#34;SANDBOX&#34;, action=1 (CREATE)&lt;/li&gt;&lt;li&gt;It will be forbidden while the target user is banned: PAYMENT_INITIATE or ORDER_AND_PAYMENT&lt;/li&gt;&lt;li&gt;&lt;b&gt;cross namespace allowed&lt;/b&gt;&lt;/li&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: created payment order info&lt;/li&gt;&lt;/ul&gt;
     */
    createPaymentOrder,
    /**
     * &lt;b&gt;[Not supported yet in AGS Shared Cloud]&lt;/b&gt;&lt;p&gt;This API is used to refund payment order by paymentOrderNo from non justice service. e.g. dedicated server. &lt;ul&gt;&lt;li&gt;if the status field of response json is &#34;REFUNDED&#34;, usually wallet paid, it indicates payment order already refunded&lt;/li&gt;&lt;li&gt;if the status field of response json is &#34;REFUNDING&#34;, usually real money paid, platform will send notification to registered notify url once refund successfully&lt;/li&gt; &lt;/ul&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;Path Parameter:&lt;/strong&gt;&lt;/p&gt;&lt;pre&gt;&lt;table&gt;&lt;tr&gt;&lt;td&gt;Parameter&lt;/td&gt;&lt;td&gt;Type&lt;/td&gt;&lt;td&gt;Required&lt;/td&gt;&lt;td&gt;Description&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;namespace&lt;/td&gt;&lt;td&gt;String&lt;/td&gt;&lt;td&gt;Yes&lt;/td&gt;&lt;td&gt;Namespace that payment order resides in&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;paymentOrderNo&lt;/td&gt;&lt;td&gt;String&lt;/td&gt;&lt;td&gt;Yes&lt;/td&gt;&lt;td&gt;Payment order number&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;Request Body Parameters:&lt;/strong&gt;&lt;/p&gt;&lt;pre&gt;&lt;table&gt;&lt;tr&gt;&lt;td&gt;Parameter&lt;/td&gt;&lt;td&gt;Type&lt;/td&gt;&lt;td&gt;Required&lt;/td&gt;&lt;td&gt;Description&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;description&lt;/td&gt;&lt;td&gt;String&lt;/td&gt;&lt;td&gt;Yes&lt;/td&gt;&lt;td&gt;Refund description&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;Request Body Example:&lt;/strong&gt;&lt;/p&gt;&lt;pre&gt;&lt;code style=&#39;overflow: auto&#39;&gt;{ &#34;description&#34;: &#34;Repeated item.&#34; }&lt;/pre&gt;&lt;/code&gt;&lt;h4&gt;Refund Notification:&lt;/h4&gt;&lt;p&gt;It will send notification to configured web hook after refund successfully, http status code should return 200 or 204 once you resolve notification successfully, otherwise payment system will retry notification in interval&lt;/p&gt;&lt;p&gt;&lt;strong&gt;Refund notification parameter:&lt;/strong&gt;&lt;/p&gt;&lt;pre&gt;&lt;table&gt;&lt;tr&gt;&lt;td&gt;Parameter&lt;/td&gt;&lt;td&gt;Type&lt;/td&gt;&lt;td&gt;Required&lt;/td&gt;&lt;td&gt;Description&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;payload&lt;/td&gt;&lt;td&gt;String&lt;/td&gt;&lt;td&gt;Yes&lt;/td&gt;&lt;td&gt;Refund notification payload in json string &lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;sign&lt;/td&gt;&lt;td&gt;String&lt;/td&gt;&lt;td&gt;Yes&lt;/td&gt;&lt;td&gt;sha1 hex signature for payload and private key&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;Refund notification Example:&lt;/strong&gt;&lt;/p&gt;&lt;pre&gt;&lt;code style=&#39;overflow: auto&#39;&gt;{ &#34;payload&#34;: &#34;{ \&#34;type\&#34;: \&#34;payment\&#34;, \&#34;nonceStr\&#34;: \&#34;34c1dcf3eb58455eb161465bbfc0b590\&#34;, \&#34;paymentOrderNo\&#34;: \&#34;18081239088\&#34;, \&#34;namespace\&#34;: \&#34;accelbyte\&#34;, \&#34;targetNamespace\&#34;: \&#34;game1\&#34;, \&#34;targetUserId\&#34;: \&#34;94451623768940d58416ca33ca767ec3\&#34;, \&#34;extOrderNo\&#34;: \&#34;123456789\&#34;, \&#34;sku\&#34;: \&#34;sku\&#34;, \&#34;extUserId\&#34;: \&#34;678\&#34;, \&#34;price\&#34;: 100, \&#34;paymentProvider\&#34;: \&#34;XSOLLA\&#34;, \&#34;vat\&#34;: 0, \&#34;salesTax\&#34;: 0, \&#34;paymentProviderFee\&#34;: 0, \&#34;paymentMethodFee\&#34;: 0, \&#34;currency\&#34;: { \&#34;currencyCode\&#34;: \&#34;USD\&#34;, \&#34;currencySymbol\&#34;: \&#34;$\&#34;, \&#34;currencyType\&#34;: \&#34;REAL\&#34;, \&#34;namespace\&#34;: \&#34;accelbyte\&#34;, \&#34;decimals\&#34;: 2 }, \&#34;status\&#34;: \&#34;REFUNDED\&#34;, \&#34;createdTime\&#34;: \&#34;2018-07-28T00:39:16.274Z\&#34;, \&#34;chargedTime\&#34;: \&#34;2018-07-28T00:39:16.274Z\&#34;, \&#34;refundedTime\&#34;: \&#34;2018-07-28T00:39:16.274Z\&#34; }&#34;, &#34;sign&#34;:&#34;e31fb92516cc9faaf50ad70343e1293acec6f3d5&#34; }&lt;/pre&gt;&lt;/code&gt;&lt;p&gt;&lt;strong&gt;Refund notification payload parameter list:&lt;/strong&gt;&lt;/p&gt;&lt;pre&gt;&lt;table&gt;&lt;tr&gt;&lt;td&gt;Parameter&lt;/td&gt;&lt;td&gt;Type&lt;/td&gt;&lt;td&gt;Required&lt;/td&gt;&lt;td&gt;Description&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;type&lt;/td&gt;&lt;td&gt;String&lt;/td&gt;&lt;td&gt;Yes&lt;/td&gt;&lt;td&gt;Notification type: &#39;payment&#39;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;paymentOrderNo&lt;/td&gt;&lt;td&gt;String&lt;/td&gt;&lt;td&gt;Yes&lt;/td&gt;&lt;td&gt;Payment system generated order number&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;extOrderNo&lt;/td&gt;&lt;td&gt;String&lt;/td&gt;&lt;td&gt;No&lt;/td&gt;&lt;td&gt;External order number that passed by invoker&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;namespace&lt;/td&gt;&lt;td&gt;String&lt;/td&gt;&lt;td&gt;Yes&lt;/td&gt;&lt;td&gt;Namespace that related payment order resides in&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;targetNamespace&lt;/td&gt;&lt;td&gt;String&lt;/td&gt;&lt;td&gt;Yes&lt;/td&gt;&lt;td&gt;The game namespace&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;targetUserId&lt;/td&gt;&lt;td&gt;String&lt;/td&gt;&lt;td&gt;Yes&lt;/td&gt;&lt;td&gt;The user id in game namespace&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;sku&lt;/td&gt;&lt;td&gt;String&lt;/td&gt;&lt;td&gt;No&lt;/td&gt;&lt;td&gt;Item identify, it will return if pass it when create payment&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;extUserId&lt;/td&gt;&lt;td&gt;String&lt;/td&gt;&lt;td&gt;No&lt;/td&gt;&lt;td&gt;External user id, can be character id, it will return if pass it when create payment&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;price&lt;/td&gt;&lt;td&gt;int&lt;/td&gt;&lt;td&gt;Yes&lt;/td&gt;&lt;td&gt;Price of item&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;paymentProvider&lt;/td&gt;&lt;td&gt;String&lt;/td&gt;&lt;td&gt;Yes&lt;/td&gt;&lt;td&gt;Payment provider: xsolla/alipay/wxpay/wallet&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;vat&lt;/td&gt;&lt;td&gt;int&lt;/td&gt;&lt;td&gt;Yes&lt;/td&gt;&lt;td&gt;Payment order VAT&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;salesTax&lt;/td&gt;&lt;td&gt;int&lt;/td&gt;&lt;td&gt;Yes&lt;/td&gt;&lt;td&gt;Payment order sales tax&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;paymentProviderFee&lt;/td&gt;&lt;td&gt;int&lt;/td&gt;&lt;td&gt;Yes&lt;/td&gt;&lt;td&gt;Payment provider fee&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;paymentMethodFee&lt;/td&gt;&lt;td&gt;int&lt;/td&gt;&lt;td&gt;Yes&lt;/td&gt;&lt;td&gt;Payment method fee&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;currency&lt;/td&gt;&lt;td&gt;Map&lt;/td&gt;&lt;td&gt;Yes&lt;/td&gt;&lt;td&gt;Payment order currency info&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;status&lt;/td&gt;&lt;td&gt;String&lt;/td&gt;&lt;td&gt;Yes&lt;/td&gt;&lt;td&gt;Payment order status&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;statusReason&lt;/td&gt;&lt;td&gt;String&lt;/td&gt;&lt;td&gt;No&lt;/td&gt;&lt;td&gt;Payment order refund status reason&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;createdTime&lt;/td&gt;&lt;td&gt;Datetime&lt;/td&gt;&lt;td&gt;No&lt;/td&gt;&lt;td&gt;The time of the order created&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;chargedTime&lt;/td&gt;&lt;td&gt;Datetime&lt;/td&gt;&lt;td&gt;No&lt;/td&gt;&lt;td&gt;The time of the order charged&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;refundedTime&lt;/td&gt;&lt;td&gt;Datetime&lt;/td&gt;&lt;td&gt;No&lt;/td&gt;&lt;td&gt;The time of the order refunded&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;customParameters&lt;/td&gt;&lt;td&gt;Map&lt;/td&gt;&lt;td&gt;No&lt;/td&gt;&lt;td&gt;custom parameters, will return if pass it when create payment&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;nonceStr&lt;/td&gt;&lt;td&gt;String&lt;/td&gt;&lt;td&gt;Yes&lt;/td&gt;&lt;td&gt;Random string, max length is 32, &lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;Currency info parameter list:&lt;/strong&gt;&lt;/p&gt;&lt;pre&gt;&lt;table&gt;&lt;tr&gt;&lt;td&gt;Parameter&lt;/td&gt;&lt;td&gt;Type&lt;/td&gt;&lt;td&gt;Required&lt;/td&gt;&lt;td&gt;Description&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;currencyCode&lt;/td&gt;&lt;td&gt;String&lt;/td&gt;&lt;td&gt;Yes&lt;/td&gt;&lt;td&gt;Currency Code&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;currencySymbol&lt;/td&gt;&lt;td&gt;String&lt;/td&gt;&lt;td&gt;Yes&lt;/td&gt;&lt;td&gt;Currency Symbol&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;currencyType&lt;/td&gt;&lt;td&gt;String&lt;/td&gt;&lt;td&gt;Yes&lt;/td&gt;&lt;td&gt;Currency type(REAL/VIRTUAL)&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;namespace&lt;/td&gt;&lt;td&gt;String&lt;/td&gt;&lt;td&gt;Yes&lt;/td&gt;&lt;td&gt;Currency namespace&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;decimals&lt;/td&gt;&lt;td&gt;int&lt;/td&gt;&lt;td&gt;Yes&lt;/td&gt;&lt;td&gt;Currency decimals&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/pre&gt;&lt;h4&gt;Encryption Rule:&lt;/h4&gt;&lt;p&gt;Concat payload json string and private key and then do sha1Hex.&lt;/p&gt;&lt;h4&gt;Other detail info:&lt;/h4&gt; &lt;ul&gt;&lt;li&gt;&lt;i&gt;Token type&lt;/i&gt;: client token&lt;/li&gt;&lt;li&gt;&lt;b&gt;cross namespace allowed&lt;/b&gt;&lt;/li&gt;&lt;/ul&gt;
     */
    updateRefundPayment_ByPaymentOrderNo
  };
}

// src/generated-admin/PlatformAccountClosureAdminApi.ts
var import_sdk60 = require("@accelbyte/sdk");
function PlatformAccountClosureAdminApi(sdk, args) {
  const sdkAssembly = sdk.assembly();
  const namespace = args?.coreConfig?.namespace ?? sdkAssembly.coreConfig.namespace;
  const useSchemaValidation = args?.coreConfig?.useSchemaValidation ?? sdkAssembly.coreConfig.useSchemaValidation;
  let axiosInstance = sdkAssembly.axiosInstance;
  const requestConfigOverrides = args?.axiosConfig?.request;
  const baseURLOverride = args?.coreConfig?.baseURL;
  const interceptorsOverride = args?.axiosConfig?.interceptors ?? [];
  if (requestConfigOverrides || baseURLOverride || interceptorsOverride.length > 0) {
    const requestConfig = import_sdk60.ApiUtils.mergeAxiosConfigs(sdkAssembly.axiosInstance.defaults, {
      ...baseURLOverride ? { baseURL: baseURLOverride } : {},
      ...requestConfigOverrides
    });
    axiosInstance = import_sdk60.Network.create(requestConfig);
    for (const interceptor of interceptorsOverride) {
      if (interceptor.type === "request") {
        axiosInstance.interceptors.request.use(interceptor.onRequest, interceptor.onError);
      }
      if (interceptor.type === "response") {
        axiosInstance.interceptors.response.use(interceptor.onSuccess, interceptor.onError);
      }
    }
  }
  async function getPlatformClosureHistory_ByUserId(userId) {
    const $ = new PlatformAccountClosureAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getPlatformClosureHistory_ByUserId(userId);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  return {
    /**
     * Get user platform account closure history.&lt;br&gt;
     */
    getPlatformClosureHistory_ByUserId
  };
}

// src/generated-admin/PlatformAdminApi.ts
var import_sdk61 = require("@accelbyte/sdk");
function PlatformAdminApi(sdk, args) {
  const sdkAssembly = sdk.assembly();
  const namespace = args?.coreConfig?.namespace ?? sdkAssembly.coreConfig.namespace;
  const useSchemaValidation = args?.coreConfig?.useSchemaValidation ?? sdkAssembly.coreConfig.useSchemaValidation;
  let axiosInstance = sdkAssembly.axiosInstance;
  const requestConfigOverrides = args?.axiosConfig?.request;
  const baseURLOverride = args?.coreConfig?.baseURL;
  const interceptorsOverride = args?.axiosConfig?.interceptors ?? [];
  if (requestConfigOverrides || baseURLOverride || interceptorsOverride.length > 0) {
    const requestConfig = import_sdk61.ApiUtils.mergeAxiosConfigs(sdkAssembly.axiosInstance.defaults, {
      ...baseURLOverride ? { baseURL: baseURLOverride } : {},
      ...requestConfigOverrides
    });
    axiosInstance = import_sdk61.Network.create(requestConfig);
    for (const interceptor of interceptorsOverride) {
      if (interceptor.type === "request") {
        axiosInstance.interceptors.request.use(interceptor.onRequest, interceptor.onError);
      }
      if (interceptor.type === "response") {
        axiosInstance.interceptors.response.use(interceptor.onSuccess, interceptor.onError);
      }
    }
  }
  async function createOwnershipXblPlatform_ByProductSku(productSku, data) {
    const $ = new PlatformAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.createOwnershipXblPlatform_ByProductSku(productSku, data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function createOwnershipPsnPlatform_ByEntitlementLabel(entitlementLabel, data) {
    const $ = new PlatformAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.createOwnershipPsnPlatform_ByEntitlementLabel(entitlementLabel, data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  return {
    /**
     * Get Xbox entitlement ownership by product sku.
     */
    createOwnershipXblPlatform_ByProductSku,
    /**
     * Get user psn entitlement ownership by entitlement label.
     */
    createOwnershipPsnPlatform_ByEntitlementLabel
  };
}

// src/generated-admin/RevocationAdminApi.ts
var import_sdk62 = require("@accelbyte/sdk");
function RevocationAdminApi(sdk, args) {
  const sdkAssembly = sdk.assembly();
  const namespace = args?.coreConfig?.namespace ?? sdkAssembly.coreConfig.namespace;
  const useSchemaValidation = args?.coreConfig?.useSchemaValidation ?? sdkAssembly.coreConfig.useSchemaValidation;
  let axiosInstance = sdkAssembly.axiosInstance;
  const requestConfigOverrides = args?.axiosConfig?.request;
  const baseURLOverride = args?.coreConfig?.baseURL;
  const interceptorsOverride = args?.axiosConfig?.interceptors ?? [];
  if (requestConfigOverrides || baseURLOverride || interceptorsOverride.length > 0) {
    const requestConfig = import_sdk62.ApiUtils.mergeAxiosConfigs(sdkAssembly.axiosInstance.defaults, {
      ...baseURLOverride ? { baseURL: baseURLOverride } : {},
      ...requestConfigOverrides
    });
    axiosInstance = import_sdk62.Network.create(requestConfig);
    for (const interceptor of interceptorsOverride) {
      if (interceptor.type === "request") {
        axiosInstance.interceptors.request.use(interceptor.onRequest, interceptor.onError);
      }
      if (interceptor.type === "response") {
        axiosInstance.interceptors.response.use(interceptor.onSuccess, interceptor.onError);
      }
    }
  }
  async function deleteRevocationConfig() {
    const $ = new RevocationAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.deleteRevocationConfig();
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getRevocationConfig() {
    const $ = new RevocationAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getRevocationConfig();
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function updateRevocationConfig(data) {
    const $ = new RevocationAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.updateRevocationConfig(data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getRevocationHistory(queryParams) {
    const $ = new RevocationAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getRevocationHistory(queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function updateRevocation_ByUserId(userId, data) {
    const $ = new RevocationAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.updateRevocation_ByUserId(userId, data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  return {
    /**
     * Delete revocation config.
     */
    deleteRevocationConfig,
    /**
     * Get revocation configuration.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: Revocation config&lt;/li&gt;&lt;/ul&gt;
     */
    getRevocationConfig,
    /**
     * Update revocation configuration.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: Revocation config&lt;/li&gt;&lt;/ul&gt;
     */
    updateRevocationConfig,
    /**
     * Query revocation histories in a namespace.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: query revocation history&lt;/li&gt;&lt;/ul&gt;
     */
    getRevocationHistory,
    /**
     * Do revocation.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: revocation results&lt;/li&gt;&lt;/ul&gt;
     */
    updateRevocation_ByUserId
  };
}

// src/generated-admin/RewardAdminApi.ts
var import_sdk63 = require("@accelbyte/sdk");
function RewardAdminApi(sdk, args) {
  const sdkAssembly = sdk.assembly();
  const namespace = args?.coreConfig?.namespace ?? sdkAssembly.coreConfig.namespace;
  const useSchemaValidation = args?.coreConfig?.useSchemaValidation ?? sdkAssembly.coreConfig.useSchemaValidation;
  let axiosInstance = sdkAssembly.axiosInstance;
  const requestConfigOverrides = args?.axiosConfig?.request;
  const baseURLOverride = args?.coreConfig?.baseURL;
  const interceptorsOverride = args?.axiosConfig?.interceptors ?? [];
  if (requestConfigOverrides || baseURLOverride || interceptorsOverride.length > 0) {
    const requestConfig = import_sdk63.ApiUtils.mergeAxiosConfigs(sdkAssembly.axiosInstance.defaults, {
      ...baseURLOverride ? { baseURL: baseURLOverride } : {},
      ...requestConfigOverrides
    });
    axiosInstance = import_sdk63.Network.create(requestConfig);
    for (const interceptor of interceptorsOverride) {
      if (interceptor.type === "request") {
        axiosInstance.interceptors.request.use(interceptor.onRequest, interceptor.onError);
      }
      if (interceptor.type === "response") {
        axiosInstance.interceptors.response.use(interceptor.onSuccess, interceptor.onError);
      }
    }
  }
  async function createReward(data) {
    const $ = new RewardAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.createReward(data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getRewardsExport() {
    const $ = new RewardAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getRewardsExport();
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function createRewardImport(data, queryParams) {
    const $ = new RewardAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.createRewardImport(data, queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function deleteReward_ByRewardId(rewardId) {
    const $ = new RewardAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.deleteReward_ByRewardId(rewardId);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getReward_ByRewardId(rewardId) {
    const $ = new RewardAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getReward_ByRewardId(rewardId);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function updateReward_ByRewardId(rewardId, data) {
    const $ = new RewardAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.updateReward_ByRewardId(rewardId, data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getRewardsByCriteria(queryParams) {
    const $ = new RewardAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getRewardsByCriteria(queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function updateMatch_ByRewardId(rewardId, data) {
    const $ = new RewardAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.updateMatch_ByRewardId(rewardId, data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function deleteRecord_ByRewardId(rewardId, data) {
    const $ = new RewardAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.deleteRecord_ByRewardId(rewardId, data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  return {
    /**
     * This API is used to create a reward.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: created reward data&lt;/li&gt;&lt;li&gt;&lt;i&gt;Acceptable values for rewardItem&#39;s identityType are&lt;/i&gt;: ITEM_ID or ITEM_SKU&lt;/li&gt;&lt;/ul&gt;
     */
    createReward,
    /**
     * Export reward configurations for a given namespace into file. At current, only JSON file is supported.
     */
    getRewardsExport,
    /**
     * Import reward configurations for a given namespace from file. At current, only JSON file is supported.
     */
    createRewardImport,
    /**
     * This API is used to delete a reward by reward Id. &lt;p&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: the deleted reward data&lt;/li&gt;&lt;/ul&gt;
     */
    deleteReward_ByRewardId,
    /**
     * This API is used to get reward by reward Id.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: reward instance&lt;/li&gt;&lt;/ul&gt;
     */
    getReward_ByRewardId,
    /**
     * This API is used to update a reward.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: reward instance&lt;/li&gt;&lt;li&gt;&lt;i&gt;Acceptable values for rewardItem&#39;s identityType are&lt;/i&gt;: ITEM_ID or ITEM_SKU&lt;/li&gt;&lt;/ul&gt;
     */
    updateReward_ByRewardId,
    /**
     * This API is used to query rewards by criteria.&lt;p&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: the list of rewards&lt;/li&gt;&lt;/ul&gt;
     */
    getRewardsByCriteria,
    /**
     * &lt;b&gt;[TEST FACILITY ONLY] Forbidden in live environment. &lt;/b&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: match result&lt;/li&gt;&lt;/ul&gt;
     */
    updateMatch_ByRewardId,
    /**
     * &lt;b&gt;[TEST FACILITY ONLY] Forbidden in live environment. &lt;/b&gt; This API is used to delete a reward condition record by reward Id and condition Name (optional). &lt;p&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: 204 No Content &lt;/li&gt;&lt;/ul&gt;
     */
    deleteRecord_ByRewardId
  };
}

// src/generated-admin/SectionAdminApi.ts
var import_sdk64 = require("@accelbyte/sdk");
function SectionAdminApi(sdk, args) {
  const sdkAssembly = sdk.assembly();
  const namespace = args?.coreConfig?.namespace ?? sdkAssembly.coreConfig.namespace;
  const useSchemaValidation = args?.coreConfig?.useSchemaValidation ?? sdkAssembly.coreConfig.useSchemaValidation;
  let axiosInstance = sdkAssembly.axiosInstance;
  const requestConfigOverrides = args?.axiosConfig?.request;
  const baseURLOverride = args?.coreConfig?.baseURL;
  const interceptorsOverride = args?.axiosConfig?.interceptors ?? [];
  if (requestConfigOverrides || baseURLOverride || interceptorsOverride.length > 0) {
    const requestConfig = import_sdk64.ApiUtils.mergeAxiosConfigs(sdkAssembly.axiosInstance.defaults, {
      ...baseURLOverride ? { baseURL: baseURLOverride } : {},
      ...requestConfigOverrides
    });
    axiosInstance = import_sdk64.Network.create(requestConfig);
    for (const interceptor of interceptorsOverride) {
      if (interceptor.type === "request") {
        axiosInstance.interceptors.request.use(interceptor.onRequest, interceptor.onError);
      }
      if (interceptor.type === "response") {
        axiosInstance.interceptors.response.use(interceptor.onSuccess, interceptor.onError);
      }
    }
  }
  async function getSections(queryParams) {
    const $ = new SectionAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getSections(queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function createSection(data, queryParams) {
    const $ = new SectionAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.createSection(data, queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function deleteSection_BySectionId(sectionId, queryParams) {
    const $ = new SectionAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.deleteSection_BySectionId(sectionId, queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getSection_BySectionId(sectionId, queryParams) {
    const $ = new SectionAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getSection_BySectionId(sectionId, queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function updateSection_BySectionId(sectionId, data, queryParams) {
    const $ = new SectionAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.updateSection_BySectionId(sectionId, data, queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function deleteSectionPurgeExpired(queryParams) {
    const $ = new SectionAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.deleteSectionPurgeExpired(queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  return {
    /**
     * This API is used to query sections.&lt;p&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: paginated sections&lt;/li&gt;&lt;/ul&gt;
     */
    getSections,
    /**
     * This API is used to create a section.&lt;p&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: created a section&lt;/li&gt;&lt;/ul&gt;&lt;h2&gt;Restrictions for section extension and localization extension&lt;/h2&gt; 1. Cannot use &lt;b&gt;&#34;.&#34;&lt;/b&gt; as the key name - &lt;pre&gt;{ &#34;data.2&#34;: &#34;value&#34; }&lt;/pre&gt; 2. Cannot use &lt;b&gt;&#34;$&#34;&lt;/b&gt; as the prefix in key names - &lt;pre&gt;{ &#34;$data&#34;: &#34;value&#34; }&lt;/pre&gt;
     */
    createSection,
    /**
     * This API is used to delete s section.
     */
    deleteSection_BySectionId,
    /**
     * This API is used to get a section.&lt;p&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: section data&lt;/li&gt;&lt;/ul&gt;
     */
    getSection_BySectionId,
    /**
     * This API is used to update s section.&lt;p&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: updated section data&lt;/li&gt;&lt;/ul&gt;&lt;h2&gt;Restrictions for section extension and localization extension&lt;/h2&gt; 1. Cannot use &lt;b&gt;&#34;.&#34;&lt;/b&gt; as the key name - &lt;pre&gt;{ &#34;data.2&#34;: &#34;value&#34; }&lt;/pre&gt; 2. Cannot use &lt;b&gt;&#34;$&#34;&lt;/b&gt; as the prefix in key names - &lt;pre&gt;{ &#34;$data&#34;: &#34;value&#34; }&lt;/pre&gt;
     */
    updateSection_BySectionId,
    /**
     * This API is used to purge expired section.
     */
    deleteSectionPurgeExpired
  };
}

// src/generated-admin/ServicePluginConfigAdminApi.ts
var import_sdk65 = require("@accelbyte/sdk");
function ServicePluginConfigAdminApi(sdk, args) {
  const sdkAssembly = sdk.assembly();
  const namespace = args?.coreConfig?.namespace ?? sdkAssembly.coreConfig.namespace;
  const useSchemaValidation = args?.coreConfig?.useSchemaValidation ?? sdkAssembly.coreConfig.useSchemaValidation;
  let axiosInstance = sdkAssembly.axiosInstance;
  const requestConfigOverrides = args?.axiosConfig?.request;
  const baseURLOverride = args?.coreConfig?.baseURL;
  const interceptorsOverride = args?.axiosConfig?.interceptors ?? [];
  if (requestConfigOverrides || baseURLOverride || interceptorsOverride.length > 0) {
    const requestConfig = import_sdk65.ApiUtils.mergeAxiosConfigs(sdkAssembly.axiosInstance.defaults, {
      ...baseURLOverride ? { baseURL: baseURLOverride } : {},
      ...requestConfigOverrides
    });
    axiosInstance = import_sdk65.Network.create(requestConfig);
    for (const interceptor of interceptorsOverride) {
      if (interceptor.type === "request") {
        axiosInstance.interceptors.request.use(interceptor.onRequest, interceptor.onError);
      }
      if (interceptor.type === "response") {
        axiosInstance.interceptors.response.use(interceptor.onSuccess, interceptor.onError);
      }
    }
  }
  async function deleteConfigServicePlugin() {
    const $ = new ServicePluginConfigAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.deleteConfigServicePlugin();
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getConfigsServicePlugin() {
    const $ = new ServicePluginConfigAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getConfigsServicePlugin();
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function updateConfigServicePlugin(data) {
    const $ = new ServicePluginConfigAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.updateConfigServicePlugin(data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function deleteCatalogPluginLootbox() {
    const $ = new ServicePluginConfigAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.deleteCatalogPluginLootbox();
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getCatalogPluginsLootbox() {
    const $ = new ServicePluginConfigAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getCatalogPluginsLootbox();
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function updateCatalogPluginLootbox(data) {
    const $ = new ServicePluginConfigAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.updateCatalogPluginLootbox(data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function deleteCatalogPluginSection() {
    const $ = new ServicePluginConfigAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.deleteCatalogPluginSection();
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getCatalogPluginsSection() {
    const $ = new ServicePluginConfigAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getCatalogPluginsSection();
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function updateCatalogPluginSection(data) {
    const $ = new ServicePluginConfigAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.updateCatalogPluginSection(data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function deleteRevocationPluginRevocation() {
    const $ = new ServicePluginConfigAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.deleteRevocationPluginRevocation();
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getRevocationPluginsRevocation() {
    const $ = new ServicePluginConfigAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getRevocationPluginsRevocation();
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function updateRevocationPluginRevocation(data) {
    const $ = new ServicePluginConfigAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.updateRevocationPluginRevocation(data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getCatalogPluginsLootboxGrpcInfo(queryParams) {
    const $ = new ServicePluginConfigAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getCatalogPluginsLootboxGrpcInfo(queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function updateCatalogPluginLootboxCustomConfigCert(data) {
    const $ = new ServicePluginConfigAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.updateCatalogPluginLootboxCustomConfigCert(data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function updateCatalogPluginSectionCustomConfigCert(data) {
    const $ = new ServicePluginConfigAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.updateCatalogPluginSectionCustomConfigCert(data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function updateRevocationPluginRevocationRevocationCustomConfigCert(data) {
    const $ = new ServicePluginConfigAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.updateRevocationPluginRevocationRevocationCustomConfigCert(data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  return {
    /**
     * @deprecated
     * Delete service plugin config
     */
    deleteConfigServicePlugin,
    /**
     * @deprecated
     * Get service plugin config
     */
    getConfigsServicePlugin,
    /**
     * @deprecated
     * Update catalog config. Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: updated service plugin config&lt;/li&gt;&lt;/ul&gt;
     */
    updateConfigServicePlugin,
    /**
     * Delete service plugin config.
     */
    deleteCatalogPluginLootbox,
    /**
     * Get lootbox plugin config.
     */
    getCatalogPluginsLootbox,
    /**
     * Update lootbox plugin config. Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: updated service plugin config&lt;/li&gt;&lt;/ul&gt;
     */
    updateCatalogPluginLootbox,
    /**
     * Delete section plugin config.
     */
    deleteCatalogPluginSection,
    /**
     * Get section plugin config.
     */
    getCatalogPluginsSection,
    /**
     * Update section config. Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: updated service plugin config&lt;/li&gt;&lt;/ul&gt;
     */
    updateCatalogPluginSection,
    /**
     * Delete service plugin config.
     */
    deleteRevocationPluginRevocation,
    /**
     * Get revocation plugin config.
     */
    getRevocationPluginsRevocation,
    /**
     * Update revocation plugin config. Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: updated service plugin config&lt;/li&gt;&lt;/ul&gt;
     */
    updateRevocationPluginRevocation,
    /**
     * Get lootbox plugin gRPC info.
     */
    getCatalogPluginsLootboxGrpcInfo,
    /**
     * Upload lootbox plugin custom config tls cert.Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: updated service plugin config&lt;/li&gt;&lt;/ul&gt;
     */
    updateCatalogPluginLootboxCustomConfigCert,
    /**
     * Upload section plugin custom config tls cert.Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: updated service plugin config&lt;/li&gt;&lt;/ul&gt;
     */
    updateCatalogPluginSectionCustomConfigCert,
    /**
     * Upload revocation plugin custom config tls cert.Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: updated service plugin config&lt;/li&gt;&lt;/ul&gt;
     */
    updateRevocationPluginRevocationRevocationCustomConfigCert
  };
}

// src/generated-admin/SessionPlatformAdminApi.ts
var import_sdk66 = require("@accelbyte/sdk");
function SessionPlatformAdminApi(sdk, args) {
  const sdkAssembly = sdk.assembly();
  const namespace = args?.coreConfig?.namespace ?? sdkAssembly.coreConfig.namespace;
  const useSchemaValidation = args?.coreConfig?.useSchemaValidation ?? sdkAssembly.coreConfig.useSchemaValidation;
  let axiosInstance = sdkAssembly.axiosInstance;
  const requestConfigOverrides = args?.axiosConfig?.request;
  const baseURLOverride = args?.coreConfig?.baseURL;
  const interceptorsOverride = args?.axiosConfig?.interceptors ?? [];
  if (requestConfigOverrides || baseURLOverride || interceptorsOverride.length > 0) {
    const requestConfig = import_sdk66.ApiUtils.mergeAxiosConfigs(sdkAssembly.axiosInstance.defaults, {
      ...baseURLOverride ? { baseURL: baseURLOverride } : {},
      ...requestConfigOverrides
    });
    axiosInstance = import_sdk66.Network.create(requestConfig);
    for (const interceptor of interceptorsOverride) {
      if (interceptor.type === "request") {
        axiosInstance.interceptors.request.use(interceptor.onRequest, interceptor.onError);
      }
      if (interceptor.type === "response") {
        axiosInstance.interceptors.response.use(interceptor.onSuccess, interceptor.onError);
      }
    }
  }
  async function updateSessionXbl_ByUserId(userId, data) {
    const $ = new SessionPlatformAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.updateSessionXbl_ByUserId(userId, data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  return {
    /**
     * This API is used to register/update a session on xbox.
     */
    updateSessionXbl_ByUserId
  };
}

// src/generated-admin/StoreAdminApi.ts
var import_sdk67 = require("@accelbyte/sdk");
function StoreAdminApi(sdk, args) {
  const sdkAssembly = sdk.assembly();
  const namespace = args?.coreConfig?.namespace ?? sdkAssembly.coreConfig.namespace;
  const useSchemaValidation = args?.coreConfig?.useSchemaValidation ?? sdkAssembly.coreConfig.useSchemaValidation;
  let axiosInstance = sdkAssembly.axiosInstance;
  const requestConfigOverrides = args?.axiosConfig?.request;
  const baseURLOverride = args?.coreConfig?.baseURL;
  const interceptorsOverride = args?.axiosConfig?.interceptors ?? [];
  if (requestConfigOverrides || baseURLOverride || interceptorsOverride.length > 0) {
    const requestConfig = import_sdk67.ApiUtils.mergeAxiosConfigs(sdkAssembly.axiosInstance.defaults, {
      ...baseURLOverride ? { baseURL: baseURLOverride } : {},
      ...requestConfigOverrides
    });
    axiosInstance = import_sdk67.Network.create(requestConfig);
    for (const interceptor of interceptorsOverride) {
      if (interceptor.type === "request") {
        axiosInstance.interceptors.request.use(interceptor.onRequest, interceptor.onError);
      }
      if (interceptor.type === "response") {
        axiosInstance.interceptors.response.use(interceptor.onSuccess, interceptor.onError);
      }
    }
  }
  async function getStores() {
    const $ = new StoreAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getStores();
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function createStore(data) {
    const $ = new StoreAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.createStore(data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function updateStoreImport(data, queryParams) {
    const $ = new StoreAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.updateStoreImport(data, queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getCatalogConfigs() {
    const $ = new StoreAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getCatalogConfigs();
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function updateCatalogConfig(data) {
    const $ = new StoreAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.updateCatalogConfig(data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function deleteStore_ByStoreId(storeId) {
    const $ = new StoreAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.deleteStore_ByStoreId(storeId);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getStore_ByStoreId(storeId) {
    const $ = new StoreAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getStore_ByStoreId(storeId);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function updateStore_ByStoreId(storeId, data) {
    const $ = new StoreAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.updateStore_ByStoreId(storeId, data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function deleteStorePublished() {
    const $ = new StoreAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.deleteStorePublished();
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getStoresPublished() {
    const $ = new StoreAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getStoresPublished();
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function updateStoreImport_v2(data, queryParams) {
    const $ = new StoreAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.updateStoreImport_v2(data, queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function createStoreExportByCsv(data) {
    const $ = new StoreAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.createStoreExportByCsv(data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function updateClone_ByStoreId(storeId, queryParams) {
    const $ = new StoreAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.updateClone_ByStoreId(storeId, queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getExport_ByStoreId(storeId) {
    const $ = new StoreAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getExport_ByStoreId(storeId);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getStoresPublishedBackup() {
    const $ = new StoreAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getStoresPublishedBackup();
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getStoresCatalogDefinition(queryParams) {
    const $ = new StoreAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getStoresCatalogDefinition(queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function updateStorePublishedRollback() {
    const $ = new StoreAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.updateStorePublishedRollback();
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function createExport_ByStoreId_v2(storeId, data) {
    const $ = new StoreAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.createExport_ByStoreId_v2(storeId, data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getStoresDownloadCsvTemplates() {
    const $ = new StoreAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getStoresDownloadCsvTemplates();
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function createImportByCsv_ByStoreId(storeId, data) {
    const $ = new StoreAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.createImportByCsv_ByStoreId(storeId, data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getImportHistory_ByStoreId(storeId, queryParams) {
    const $ = new StoreAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getImportHistory_ByStoreId(storeId, queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  return {
    /**
     * This API is used to list stores in a namespace.&lt;p&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: the list of stores&lt;/li&gt;&lt;/ul&gt;
     */
    getStores,
    /**
     * This API is used to create a non published store in a namespace.&lt;p&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: created store data&lt;/li&gt;&lt;/ul&gt;
     */
    createStore,
    /**
     * @deprecated
     * This API is used to import a store.&lt;p&gt;This api has been deprecated, pls use /v2/admin/namespaces/{namespace}/stores/import to import store.&lt;br&gt;
     */
    updateStoreImport,
    /**
     * Get catalog config.
     */
    getCatalogConfigs,
    /**
     * Update catalog config. Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: updated catalog config&lt;/li&gt;&lt;/ul&gt;
     */
    updateCatalogConfig,
    /**
     * This API is used to delete a store. Only non published store can be deleted.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: store&lt;/li&gt;&lt;/ul&gt;
     */
    deleteStore_ByStoreId,
    /**
     * This API is used to get a store.&lt;p&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: store data&lt;/li&gt;&lt;/ul&gt;
     */
    getStore_ByStoreId,
    /**
     * This API is used to Update a store basic info.&lt;p&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: updated store data&lt;/li&gt;&lt;/ul&gt;
     */
    updateStore_ByStoreId,
    /**
     * This API is used to delete published store including category and items before release to public.&lt;p&gt;&lt;b&gt;Warning: Please do not use this API once published to public user.&lt;/b&gt;
     */
    deleteStorePublished,
    /**
     * This API is used to get a published store basic info, exclude category and item information.&lt;p&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: store data&lt;/li&gt;&lt;/ul&gt;
     */
    getStoresPublished,
    /**
     * This API is used to import a store.
     */
    updateStoreImport_v2,
    /**
     * This API is used to export a store to CSV format
     */
    createStoreExportByCsv,
    /**
     * This API is used to clone a store. Usually clone a draft store to published store because published store can&#39;t directly edit content.&lt;p&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: clone store info&lt;/li&gt;&lt;/ul&gt;
     */
    updateClone_ByStoreId,
    /**
     * @deprecated
     * This API is used to export a store.&lt;p&gt;This api has been deprecated, pls use /v2/admin/namespaces/{namespace}/stores/export to export store.&lt;br&gt;
     */
    getExport_ByStoreId,
    /**
     * This API is used to get a store&#39;s backup. &lt;p&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: store backup info&lt;/li&gt;&lt;/ul&gt;
     */
    getStoresPublishedBackup,
    /**
     * This API is used to get catalog definition for import/export store by CSV&lt;p&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: catalog definition&lt;/li&gt;&lt;/ul&gt;
     */
    getStoresCatalogDefinition,
    /**
     * This API is used to rollback a published store. &lt;p&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: updated store info&lt;/li&gt;&lt;/ul&gt;
     */
    updateStorePublishedRollback,
    /**
     * This API is used to export a whole or partial store.
     */
    createExport_ByStoreId_v2,
    /**
     * This API is used to download store csv templates for store importing by CSV feature
     */
    getStoresDownloadCsvTemplates,
    /**
     * This API is used to import a store by CSV format.
     */
    createImportByCsv_ByStoreId,
    /**
     * This API is used to query import store history
     */
    getImportHistory_ByStoreId
  };
}

// src/generated-admin/SubscriptionAdminApi.ts
var import_sdk68 = require("@accelbyte/sdk");
function SubscriptionAdminApi(sdk, args) {
  const sdkAssembly = sdk.assembly();
  const namespace = args?.coreConfig?.namespace ?? sdkAssembly.coreConfig.namespace;
  const useSchemaValidation = args?.coreConfig?.useSchemaValidation ?? sdkAssembly.coreConfig.useSchemaValidation;
  let axiosInstance = sdkAssembly.axiosInstance;
  const requestConfigOverrides = args?.axiosConfig?.request;
  const baseURLOverride = args?.coreConfig?.baseURL;
  const interceptorsOverride = args?.axiosConfig?.interceptors ?? [];
  if (requestConfigOverrides || baseURLOverride || interceptorsOverride.length > 0) {
    const requestConfig = import_sdk68.ApiUtils.mergeAxiosConfigs(sdkAssembly.axiosInstance.defaults, {
      ...baseURLOverride ? { baseURL: baseURLOverride } : {},
      ...requestConfigOverrides
    });
    axiosInstance = import_sdk68.Network.create(requestConfig);
    for (const interceptor of interceptorsOverride) {
      if (interceptor.type === "request") {
        axiosInstance.interceptors.request.use(interceptor.onRequest, interceptor.onError);
      }
      if (interceptor.type === "response") {
        axiosInstance.interceptors.response.use(interceptor.onSuccess, interceptor.onError);
      }
    }
  }
  async function getSubscriptions(queryParams) {
    const $ = new SubscriptionAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getSubscriptions(queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getSubscriptions_ByUserId(userId, queryParams) {
    const $ = new SubscriptionAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getSubscriptions_ByUserId(userId, queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getSubscriptionsActivities_ByUserId(userId, queryParams) {
    const $ = new SubscriptionAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getSubscriptionsActivities_ByUserId(userId, queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function updateRecurring_BySubscriptionId(subscriptionId) {
    const $ = new SubscriptionAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.updateRecurring_BySubscriptionId(subscriptionId);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function deleteSubscription_ByUserId_BySubscriptionId(userId, subscriptionId) {
    const $ = new SubscriptionAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.deleteSubscription_ByUserId_BySubscriptionId(userId, subscriptionId);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getSubscription_ByUserId_BySubscriptionId(userId, subscriptionId) {
    const $ = new SubscriptionAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getSubscription_ByUserId_BySubscriptionId(userId, subscriptionId);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function createSubscriptionPlatformSubscribe_ByUserId(userId, data) {
    const $ = new SubscriptionAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.createSubscriptionPlatformSubscribe_ByUserId(userId, data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getSubscriptionsSubscribableByItemId_ByUserId(userId, queryParams) {
    const $ = new SubscriptionAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getSubscriptionsSubscribableByItemId_ByUserId(userId, queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function updateGrant_ByUserId_BySubscriptionId(userId, subscriptionId, data) {
    const $ = new SubscriptionAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.updateGrant_ByUserId_BySubscriptionId(userId, subscriptionId, data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function updateCancel_ByUserId_BySubscriptionId(userId, subscriptionId, data, queryParams) {
    const $ = new SubscriptionAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.updateCancel_ByUserId_BySubscriptionId(userId, subscriptionId, data, queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getHistory_ByUserId_BySubscriptionId(userId, subscriptionId, queryParams) {
    const $ = new SubscriptionAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getHistory_ByUserId_BySubscriptionId(userId, subscriptionId, queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function createNotification_ByUserId_BySubscriptionId(userId, subscriptionId, data) {
    const $ = new SubscriptionAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.createNotification_ByUserId_BySubscriptionId(userId, subscriptionId, data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  return {
    /**
     * Query subscriptions.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: paginated subscriptions&lt;/li&gt;&lt;/ul&gt;
     */
    getSubscriptions,
    /**
     * Query user subscriptions.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: paginated subscription&lt;/li&gt;&lt;/ul&gt;
     */
    getSubscriptions_ByUserId,
    /**
     * Get user subscription activity.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: paginated subscription activity&lt;/li&gt;&lt;/ul&gt;
     */
    getSubscriptionsActivities_ByUserId,
    /**
     * &lt;b&gt;[TEST FACILITY ONLY] Forbidden in live environment. &lt;/b&gt; Recurring charge subscription, it will trigger recurring charge if the USER subscription status is ACTIVE, nextBillingDate is before now and no fail recurring charge within X(default 12) hours.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: recurring charge result&lt;/li&gt;&lt;/ul&gt;
     */
    updateRecurring_BySubscriptionId,
    /**
     * &lt;b&gt;[TEST FACILITY ONLY] Forbidden in live environment. &lt;/b&gt; Delete user subscription.
     */
    deleteSubscription_ByUserId_BySubscriptionId,
    /**
     * Get user subscription.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: subscription&lt;/li&gt;&lt;/ul&gt;
     */
    getSubscription_ByUserId_BySubscriptionId,
    /**
     * Free subscribe by platform, can used by other justice service to redeem/reward the subscription.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: result subscription&lt;/li&gt;&lt;/ul&gt;
     */
    createSubscriptionPlatformSubscribe_ByUserId,
    /**
     * Check user subscription subscribable by itemId, ACTIVE USER subscription can&#39;t do subscribe again.&lt;p&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: subscribable info&lt;/li&gt;&lt;/ul&gt;
     */
    getSubscriptionsSubscribableByItemId_ByUserId,
    /**
     * Grant days to a subscription, if grantDays is positive, it will add free days and push the next billing date by the amount of day.&lt;br&gt;if the grantDays is negative or zero, it only apply to active/cancelled subscription, remove days will decrease current period end, and move the next billing date closer.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: updated subscription&lt;/li&gt;&lt;/ul&gt;
     */
    updateGrant_ByUserId_BySubscriptionId,
    /**
     * Cancel a subscription, only ACTIVE subscription can be cancelled. &lt;b&gt;Ensure successfully cancel, recommend at least 1 day before current period ends, otherwise it may be charging or charged.&lt;/b&gt;&lt;br&gt;Set immediate true, the subscription will be terminated immediately, otherwise till the end of current billing cycle.&lt;br&gt;Set force true, will ignore the error if subscription is during recurring charging.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: cancelled subscription&lt;/li&gt;&lt;/ul&gt;
     */
    updateCancel_ByUserId_BySubscriptionId,
    /**
     * Get user subscription billing histories.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: paginated subscription billing history&lt;/li&gt;&lt;/ul&gt;
     */
    getHistory_ByUserId_BySubscriptionId,
    /**
     * &lt;b&gt;[SERVICE COMMUNICATION ONLY]&lt;/b&gt; This API is used as a web hook for payment notification from justice payment service.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: Process result&lt;/li&gt;&lt;/ul&gt;
     */
    createNotification_ByUserId_BySubscriptionId
  };
}

// src/generated-admin/TicketAdminApi.ts
var import_sdk69 = require("@accelbyte/sdk");
function TicketAdminApi(sdk, args) {
  const sdkAssembly = sdk.assembly();
  const namespace = args?.coreConfig?.namespace ?? sdkAssembly.coreConfig.namespace;
  const useSchemaValidation = args?.coreConfig?.useSchemaValidation ?? sdkAssembly.coreConfig.useSchemaValidation;
  let axiosInstance = sdkAssembly.axiosInstance;
  const requestConfigOverrides = args?.axiosConfig?.request;
  const baseURLOverride = args?.coreConfig?.baseURL;
  const interceptorsOverride = args?.axiosConfig?.interceptors ?? [];
  if (requestConfigOverrides || baseURLOverride || interceptorsOverride.length > 0) {
    const requestConfig = import_sdk69.ApiUtils.mergeAxiosConfigs(sdkAssembly.axiosInstance.defaults, {
      ...baseURLOverride ? { baseURL: baseURLOverride } : {},
      ...requestConfigOverrides
    });
    axiosInstance = import_sdk69.Network.create(requestConfig);
    for (const interceptor of interceptorsOverride) {
      if (interceptor.type === "request") {
        axiosInstance.interceptors.request.use(interceptor.onRequest, interceptor.onError);
      }
      if (interceptor.type === "response") {
        axiosInstance.interceptors.response.use(interceptor.onSuccess, interceptor.onError);
      }
    }
  }
  async function getTicket_ByBoothName(boothName) {
    const $ = new TicketAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getTicket_ByBoothName(boothName);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getId_ByBoothName(boothName) {
    const $ = new TicketAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getId_ByBoothName(boothName);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function updateDecrement_ByBoothName(boothName, data) {
    const $ = new TicketAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.updateDecrement_ByBoothName(boothName, data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function updateIncrement_ByBoothName(boothName, data) {
    const $ = new TicketAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.updateIncrement_ByBoothName(boothName, data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function createTicket_ByUserId_ByBoothName(userId, boothName, data) {
    const $ = new TicketAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.createTicket_ByUserId_ByBoothName(userId, boothName, data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  return {
    /**
     * &lt;b&gt;[SERVICE COMMUNICATION ONLY]&lt;/b&gt; Get ticket(code/key) dynamic based on booth name.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: ticket dynamic&lt;/li&gt;&lt;/ul&gt;
     */
    getTicket_ByBoothName,
    /**
     * Get ticket(code/key) booth ID.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: ticket booth id&lt;/li&gt;&lt;/ul&gt;
     */
    getId_ByBoothName,
    /**
     * &lt;b&gt;[SERVICE COMMUNICATION ONLY]&lt;/b&gt; Decrease ticket(code/key) sale if requested orderNo is already increased.
     */
    updateDecrement_ByBoothName,
    /**
     * &lt;b&gt;[SERVICE COMMUNICATION ONLY]&lt;/b&gt; increase ticket(code/key) sale.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: Ticket sale increment result&lt;/li&gt;&lt;/ul&gt;
     */
    updateIncrement_ByBoothName,
    /**
     * &lt;b&gt;[SERVICE COMMUNICATION ONLY]&lt;/b&gt; Acquire ticket(code/key) based on booth name.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: acquire result&lt;/li&gt;&lt;/ul&gt;
     */
    createTicket_ByUserId_ByBoothName
  };
}

// src/generated-admin/TradeActionAdminApi.ts
var import_sdk70 = require("@accelbyte/sdk");
function TradeActionAdminApi(sdk, args) {
  const sdkAssembly = sdk.assembly();
  const namespace = args?.coreConfig?.namespace ?? sdkAssembly.coreConfig.namespace;
  const useSchemaValidation = args?.coreConfig?.useSchemaValidation ?? sdkAssembly.coreConfig.useSchemaValidation;
  let axiosInstance = sdkAssembly.axiosInstance;
  const requestConfigOverrides = args?.axiosConfig?.request;
  const baseURLOverride = args?.coreConfig?.baseURL;
  const interceptorsOverride = args?.axiosConfig?.interceptors ?? [];
  if (requestConfigOverrides || baseURLOverride || interceptorsOverride.length > 0) {
    const requestConfig = import_sdk70.ApiUtils.mergeAxiosConfigs(sdkAssembly.axiosInstance.defaults, {
      ...baseURLOverride ? { baseURL: baseURLOverride } : {},
      ...requestConfigOverrides
    });
    axiosInstance = import_sdk70.Network.create(requestConfig);
    for (const interceptor of interceptorsOverride) {
      if (interceptor.type === "request") {
        axiosInstance.interceptors.request.use(interceptor.onRequest, interceptor.onError);
      }
      if (interceptor.type === "response") {
        axiosInstance.interceptors.response.use(interceptor.onSuccess, interceptor.onError);
      }
    }
  }
  async function createTradeCommit(data) {
    const $ = new TradeActionAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.createTradeCommit(data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getTrade_ByTransactionId(transactionId) {
    const $ = new TradeActionAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getTrade_ByTransactionId(transactionId);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getTradeHistoryByCriteria(queryParams) {
    const $ = new TradeActionAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getTradeHistoryByCriteria(queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  return {
    /**
     * This API is used to create a chained operations&lt;p&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: chain action history&lt;/li&gt;&lt;li&gt;&lt;i&gt;FULFILL_ITEM operation supported item type&lt;/i&gt;: INGAMEITEM,LOOTBOX,OPTIONBOX&lt;/li&gt;&lt;/ul&gt;&lt;h2&gt;Restrictions for metadata&lt;/h2&gt; 1. Cannot use &lt;b&gt;&#34;.&#34;&lt;/b&gt; as the key name - &lt;pre&gt;{ &#34;data.2&#34;: &#34;value&#34; }&lt;/pre&gt; 2. Cannot use &lt;b&gt;&#34;$&#34;&lt;/b&gt; as the prefix in key names - &lt;pre&gt;{ &#34;$data&#34;: &#34;value&#34; }&lt;/pre&gt;
     */
    createTradeCommit,
    /**
     * This API is used to fetch a specific trade history using transaction ID&lt;p&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: trade history based on transaction ID&lt;/li&gt;&lt;/ul&gt;
     */
    getTrade_ByTransactionId,
    /**
     * This API is used to fetch trade history based on the provided criteria&lt;p&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: trade history list based on criteria&lt;/li&gt;&lt;/ul&gt;
     */
    getTradeHistoryByCriteria
  };
}

// src/generated-admin/ViewAdminApi.ts
var import_sdk71 = require("@accelbyte/sdk");
function ViewAdminApi(sdk, args) {
  const sdkAssembly = sdk.assembly();
  const namespace = args?.coreConfig?.namespace ?? sdkAssembly.coreConfig.namespace;
  const useSchemaValidation = args?.coreConfig?.useSchemaValidation ?? sdkAssembly.coreConfig.useSchemaValidation;
  let axiosInstance = sdkAssembly.axiosInstance;
  const requestConfigOverrides = args?.axiosConfig?.request;
  const baseURLOverride = args?.coreConfig?.baseURL;
  const interceptorsOverride = args?.axiosConfig?.interceptors ?? [];
  if (requestConfigOverrides || baseURLOverride || interceptorsOverride.length > 0) {
    const requestConfig = import_sdk71.ApiUtils.mergeAxiosConfigs(sdkAssembly.axiosInstance.defaults, {
      ...baseURLOverride ? { baseURL: baseURLOverride } : {},
      ...requestConfigOverrides
    });
    axiosInstance = import_sdk71.Network.create(requestConfig);
    for (const interceptor of interceptorsOverride) {
      if (interceptor.type === "request") {
        axiosInstance.interceptors.request.use(interceptor.onRequest, interceptor.onError);
      }
      if (interceptor.type === "response") {
        axiosInstance.interceptors.response.use(interceptor.onSuccess, interceptor.onError);
      }
    }
  }
  async function getViews(queryParams) {
    const $ = new ViewAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getViews(queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function createView(data, queryParams) {
    const $ = new ViewAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.createView(data, queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function deleteView_ByViewId(viewId, queryParams) {
    const $ = new ViewAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.deleteView_ByViewId(viewId, queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getView_ByViewId(viewId, queryParams) {
    const $ = new ViewAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getView_ByViewId(viewId, queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function updateView_ByViewId(viewId, data, queryParams) {
    const $ = new ViewAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.updateView_ByViewId(viewId, data, queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  return {
    /**
     * This API is used to list all views.&lt;p&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: the list of views&lt;/li&gt;&lt;/ul&gt;
     */
    getViews,
    /**
     * This API is used to create a view.&lt;p&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: created a view&lt;/li&gt;&lt;/ul&gt;&lt;h2&gt;Restrictions for localization extension&lt;/h2&gt; 1. Cannot use &lt;b&gt;&#34;.&#34;&lt;/b&gt; as the key name - &lt;pre&gt;{ &#34;data.2&#34;: &#34;value&#34; }&lt;/pre&gt; 2. Cannot use &lt;b&gt;&#34;$&#34;&lt;/b&gt; as the prefix in key names - &lt;pre&gt;{ &#34;$data&#34;: &#34;value&#34; }&lt;/pre&gt;
     */
    createView,
    /**
     * This API is used to delete a view.It will also delete all the related sections
     */
    deleteView_ByViewId,
    /**
     * This API is used to get a view.&lt;p&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: view data&lt;/li&gt;&lt;/ul&gt;
     */
    getView_ByViewId,
    /**
     * This API is used to update a view.&lt;p&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: updated view data&lt;/li&gt;&lt;/ul&gt;&lt;h2&gt;Restrictions for localization extension&lt;/h2&gt; 1. Cannot use &lt;b&gt;&#34;.&#34;&lt;/b&gt; as the key name - &lt;pre&gt;{ &#34;data.2&#34;: &#34;value&#34; }&lt;/pre&gt; 2. Cannot use &lt;b&gt;&#34;$&#34;&lt;/b&gt; as the prefix in key names - &lt;pre&gt;{ &#34;$data&#34;: &#34;value&#34; }&lt;/pre&gt;
     */
    updateView_ByViewId
  };
}

// src/generated-admin/WalletAdminApi.ts
var import_sdk72 = require("@accelbyte/sdk");
function WalletAdminApi(sdk, args) {
  const sdkAssembly = sdk.assembly();
  const namespace = args?.coreConfig?.namespace ?? sdkAssembly.coreConfig.namespace;
  const useSchemaValidation = args?.coreConfig?.useSchemaValidation ?? sdkAssembly.coreConfig.useSchemaValidation;
  let axiosInstance = sdkAssembly.axiosInstance;
  const requestConfigOverrides = args?.axiosConfig?.request;
  const baseURLOverride = args?.coreConfig?.baseURL;
  const interceptorsOverride = args?.axiosConfig?.interceptors ?? [];
  if (requestConfigOverrides || baseURLOverride || interceptorsOverride.length > 0) {
    const requestConfig = import_sdk72.ApiUtils.mergeAxiosConfigs(sdkAssembly.axiosInstance.defaults, {
      ...baseURLOverride ? { baseURL: baseURLOverride } : {},
      ...requestConfigOverrides
    });
    axiosInstance = import_sdk72.Network.create(requestConfig);
    for (const interceptor of interceptorsOverride) {
      if (interceptor.type === "request") {
        axiosInstance.interceptors.request.use(interceptor.onRequest, interceptor.onError);
      }
      if (interceptor.type === "response") {
        axiosInstance.interceptors.response.use(interceptor.onSuccess, interceptor.onError);
      }
    }
  }
  async function getWallets(queryParams) {
    const $ = new WalletAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getWallets(queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function createWalletDebit(data) {
    const $ = new WalletAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.createWalletDebit(data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function createWalletCredit(data) {
    const $ = new WalletAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.createWalletCredit(data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getWallet_ByWalletId(walletId) {
    const $ = new WalletAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getWallet_ByWalletId(walletId);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getWallet_ByUserId_ByWalletId(userId, walletId) {
    const $ = new WalletAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getWallet_ByUserId_ByWalletId(userId, walletId);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getWalletConfig_ByPlatform(platform) {
    const $ = new WalletAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getWalletConfig_ByPlatform(platform);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function updateWalletConfig_ByPlatform(platform, data) {
    const $ = new WalletAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.updateWalletConfig_ByPlatform(platform, data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function updateDebit_ByUserId_ByWalletId(userId, walletId, data) {
    const $ = new WalletAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.updateDebit_ByUserId_ByWalletId(userId, walletId, data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function updateWalletConfigReset_ByPlatform(platform) {
    const $ = new WalletAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.updateWalletConfigReset_ByPlatform(platform);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function updateEnable_ByUserId_ByWalletId(userId, walletId) {
    const $ = new WalletAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.updateEnable_ByUserId_ByWalletId(userId, walletId);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function updateDisable_ByUserId_ByWalletId(userId, walletId) {
    const $ = new WalletAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.updateDisable_ByUserId_ByWalletId(userId, walletId);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getWalletsCurrenciesSummary_ByUserId(userId) {
    const $ = new WalletAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getWalletsCurrenciesSummary_ByUserId(userId);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getCheck_ByUserId_ByCurrencyCode(userId, currencyCode, queryParams) {
    const $ = new WalletAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getCheck_ByUserId_ByCurrencyCode(userId, currencyCode, queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function updateCredit_ByUserId_ByCurrencyCode(userId, currencyCode, data) {
    const $ = new WalletAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.updateCredit_ByUserId_ByCurrencyCode(userId, currencyCode, data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function updatePayment_ByUserId_ByCurrencyCode(userId, currencyCode, data) {
    const $ = new WalletAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.updatePayment_ByUserId_ByCurrencyCode(userId, currencyCode, data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getTransactions_ByUserId_ByWalletId(userId, walletId, queryParams) {
    const $ = new WalletAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getTransactions_ByUserId_ByWalletId(userId, walletId, queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function createBalanceCheck_ByUserId_ByCurrencyCode(userId, currencyCode, data) {
    const $ = new WalletAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.createBalanceCheck_ByUserId_ByCurrencyCode(userId, currencyCode, data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function updateDebitWallet_ByUserId_ByCurrencyCode(userId, currencyCode, data) {
    const $ = new WalletAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.updateDebitWallet_ByUserId_ByCurrencyCode(userId, currencyCode, data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function updateDebitByWalletPlatform_ByUserId_ByCurrencyCode(userId, currencyCode, data) {
    const $ = new WalletAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.updateDebitByWalletPlatform_ByUserId_ByCurrencyCode(userId, currencyCode, data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getTransactionsWallets_ByUserId_ByCurrencyCode(userId, currencyCode, queryParams) {
    const $ = new WalletAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getTransactionsWallets_ByUserId_ByCurrencyCode(userId, currencyCode, queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  return {
    /**
     * @deprecated
     * Query wallets.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: paginated wallets info&lt;/li&gt;&lt;/ul&gt;
     */
    getWallets,
    /**
     * Debit different users&#39; wallets.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: bulk credit result&lt;/li&gt;&lt;/ul&gt;
     */
    createWalletDebit,
    /**
     * Credit different users&#39; wallets.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: bulk credit result&lt;/li&gt;&lt;/ul&gt;
     */
    createWalletCredit,
    /**
     * @deprecated
     * get a wallet by wallet id.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: wallet info&lt;/li&gt;&lt;/ul&gt;
     */
    getWallet_ByWalletId,
    /**
     * @deprecated
     * get a user wallet.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: wallet info&lt;/li&gt;&lt;/ul&gt;
     */
    getWallet_ByUserId_ByWalletId,
    /**
     * Get platform wallet config list.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: wallet info&lt;/li&gt;&lt;/ul&gt;
     */
    getWalletConfig_ByPlatform,
    /**
     * Update platform wallet config.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: platform wallet config&lt;/li&gt;&lt;/ul&gt;
     */
    updateWalletConfig_ByPlatform,
    /**
     * @deprecated
     * Debit a user wallet.
     */
    updateDebit_ByUserId_ByWalletId,
    /**
     * Reset platform wallet config to default config.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: platform wallet config&lt;/li&gt;&lt;/ul&gt;
     */
    updateWalletConfigReset_ByPlatform,
    /**
     * @deprecated
     * enable a user wallet.
     */
    updateEnable_ByUserId_ByWalletId,
    /**
     * @deprecated
     * disable a user wallet.
     */
    updateDisable_ByUserId_ByWalletId,
    /**
     * Get user currency wallet summary.&lt;br&gt;Other detail info: &lt;ul&gt;(READ)&lt;/li&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: currency wallet summary&lt;/li&gt;&lt;/ul&gt;
     */
    getWalletsCurrenciesSummary_ByUserId,
    /**
     * @deprecated
     * &lt;b&gt;[SERVICE COMMUNICATION ONLY]&lt;/b&gt; Check wallet by balance origin and currency code whether it&#39;s inactive.
     */
    getCheck_ByUserId_ByCurrencyCode,
    /**
     * Credit a user wallet by currency code and balance origin, if wallet not exists, it will create a new wallet.&lt;br&gt;Other detail info: &lt;ul&gt;(UPDATE)&lt;/li&gt;&lt;/ul&gt;
     */
    updateCredit_ByUserId_ByCurrencyCode,
    /**
     * Pay with user wallet by currency code and client platform.
     */
    updatePayment_ByUserId_ByCurrencyCode,
    /**
     * @deprecated
     * List user wallet transactions ordered by create time desc.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;/li&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: wallet transaction info&lt;/li&gt;&lt;/ul&gt;
     */
    getTransactions_ByUserId_ByWalletId,
    /**
     * Checks if the user has enough balance based on the provided criteria.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: boolean value indicating if the user has enough balance&lt;/li&gt;&lt;/ul&gt;
     */
    createBalanceCheck_ByUserId_ByCurrencyCode,
    /**
     * Debit a user wallet by currency code, default is debit system wallet.
     */
    updateDebitWallet_ByUserId_ByCurrencyCode,
    /**
     * Pay with user wallet by currency code and client platform.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;/ul&gt;&lt;h2&gt;Restrictions for metadata&lt;/h2&gt; 1. Cannot use &lt;b&gt;&#34;.&#34;&lt;/b&gt; as the key name - &lt;pre&gt;{ &#34;data.2&#34;: &#34;value&#34; }&lt;/pre&gt; 2. Cannot use &lt;b&gt;&#34;$&#34;&lt;/b&gt; as the prefix in key names - &lt;pre&gt;{ &#34;$data&#34;: &#34;value&#34; }&lt;/pre&gt;
     */
    updateDebitByWalletPlatform_ByUserId_ByCurrencyCode,
    /**
     * List user currency transactions ordered by create time desc.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;/li&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: currency transaction info&lt;/li&gt;&lt;/ul&gt;
     */
    getTransactionsWallets_ByUserId_ByCurrencyCode
  };
}

// src/generated-definitions/ActionRequest.ts
var import_zod339 = require("zod");

// src/generated-definitions/OperationRequest.ts
var import_zod338 = require("zod");
var OperationRequest = import_zod338.z.object({
  creditPayload: CreditPayload.nullish(),
  debitPayload: DebitPayload.nullish(),
  fulFillItemPayload: FulFillItemPayload.nullish(),
  revokeEntitlementPayload: RevokeEntitlementPayload.nullish(),
  type: import_zod338.z.enum(["CREDIT_WALLET", "DEBIT_WALLET", "FULFILL_ITEM", "REVOKE_ENTITLEMENT"]).nullish()
});

// src/generated-definitions/ActionRequest.ts
var ActionRequest = import_zod339.z.object({ operations: import_zod339.z.array(OperationRequest).nullish(), userId: import_zod339.z.string().nullish() });

// src/generated-definitions/AdditionalDataEntitlement.ts
var import_zod341 = require("zod");

// src/generated-definitions/ClientTransaction.ts
var import_zod340 = require("zod");
var ClientTransaction = import_zod340.z.object({ amountConsumed: import_zod340.z.number().int().nullish(), clientTransactionId: import_zod340.z.string().nullish() });

// src/generated-definitions/AdditionalDataEntitlement.ts
var AdditionalDataEntitlement = import_zod341.z.object({
  clientTransaction: import_zod341.z.array(ClientTransaction).nullish(),
  entitlementId: import_zod341.z.string().nullish(),
  usageCount: import_zod341.z.number().int().nullish()
});

// src/generated-definitions/AdminEntitlementDecrement.ts
var import_zod342 = require("zod");
var AdminEntitlementDecrement = import_zod342.z.object({
  metadata: import_zod342.z.record(import_zod342.z.any()).nullish(),
  options: import_zod342.z.array(import_zod342.z.string()).nullish(),
  platform: import_zod342.z.string().nullish(),
  requestId: import_zod342.z.string().nullish(),
  useCount: import_zod342.z.number().int().nullish()
});

// src/generated-definitions/AdminEntitlementSoldRequest.ts
var import_zod343 = require("zod");
var AdminEntitlementSoldRequest = import_zod343.z.object({
  platform: import_zod343.z.string().nullish(),
  requestId: import_zod343.z.string().nullish(),
  useCount: import_zod343.z.number().int().nullish()
});

// src/generated-definitions/AdminOrderCreate.ts
var import_zod344 = require("zod");
var AdminOrderCreate = import_zod344.z.object({
  currencyCode: import_zod344.z.string(),
  currencyNamespace: import_zod344.z.string().nullish(),
  discountCodes: import_zod344.z.array(import_zod344.z.string()).nullish(),
  discountedPrice: import_zod344.z.number().int(),
  entitlementPlatform: import_zod344.z.enum(["Epic", "GooglePlay", "IOS", "Nintendo", "Oculus", "Other", "Playstation", "Steam", "Xbox"]).nullish(),
  ext: import_zod344.z.record(import_zod344.z.any()).nullish(),
  itemId: import_zod344.z.string(),
  language: import_zod344.z.string().nullish(),
  options: OrderCreationOptions.nullish(),
  platform: import_zod344.z.enum(["Epic", "GooglePlay", "IOS", "Nintendo", "Oculus", "Other", "Playstation", "Steam", "Xbox"]).nullish(),
  price: import_zod344.z.number().int().nullish(),
  quantity: import_zod344.z.number().int(),
  region: import_zod344.z.string(),
  returnUrl: import_zod344.z.string().nullish(),
  sandbox: import_zod344.z.boolean().nullish(),
  sectionId: import_zod344.z.string().nullish()
});

// src/generated-definitions/AppInfo.ts
var import_zod345 = require("zod");
var AppInfo = import_zod345.z.object({
  announcement: import_zod345.z.string().nullish(),
  carousel: import_zod345.z.array(Slide).nullish(),
  developer: import_zod345.z.string().nullish(),
  forumUrl: import_zod345.z.string().nullish(),
  genres: import_zod345.z.array(
    import_zod345.z.enum([
      "Action",
      "Adventure",
      "Casual",
      "FreeToPlay",
      "Indie",
      "MassivelyMultiplayer",
      "RPG",
      "Racing",
      "Simulation",
      "Sports",
      "Strategy"
    ])
  ).nullish(),
  itemId: import_zod345.z.string(),
  language: import_zod345.z.string().nullish(),
  namespace: import_zod345.z.string(),
  platformRequirements: import_zod345.z.record(import_zod345.z.array(Requirement)).nullish(),
  platforms: import_zod345.z.array(import_zod345.z.enum(["Android", "IOS", "Linux", "MacOS", "Windows"])).nullish(),
  players: import_zod345.z.array(import_zod345.z.enum(["Coop", "CrossPlatformMulti", "LocalCoop", "MMO", "Multi", "Single"])).nullish(),
  primaryGenre: import_zod345.z.enum([
    "Action",
    "Adventure",
    "Casual",
    "FreeToPlay",
    "Indie",
    "MassivelyMultiplayer",
    "RPG",
    "Racing",
    "Simulation",
    "Sports",
    "Strategy"
  ]).nullish(),
  publisher: import_zod345.z.string().nullish(),
  region: import_zod345.z.string().nullish(),
  releaseDate: import_zod345.z.string().nullish(),
  slogan: import_zod345.z.string().nullish(),
  websiteUrl: import_zod345.z.string().nullish()
});

// src/generated-definitions/AppleIapConfigRequest.ts
var import_zod346 = require("zod");
var AppleIapConfigRequest = import_zod346.z.object({
  appAppleId: import_zod346.z.number().int().nullish(),
  bundleId: import_zod346.z.string(),
  issuerId: import_zod346.z.string().nullish(),
  keyId: import_zod346.z.string().nullish(),
  password: import_zod346.z.string().nullish(),
  version: import_zod346.z.enum(["V1", "V2"]).nullish()
});

// src/generated-definitions/AppleIapConfigVersionInfo.ts
var import_zod347 = require("zod");
var AppleIapConfigVersionInfo = import_zod347.z.object({ version: import_zod347.z.enum(["V1", "V2"]).nullish() });

// src/generated-definitions/AppleIapReceipt.ts
var import_zod348 = require("zod");
var AppleIapReceipt = import_zod348.z.object({
  excludeOldTransactions: import_zod348.z.boolean().nullish(),
  language: import_zod348.z.string().nullish(),
  productId: import_zod348.z.string(),
  receiptData: import_zod348.z.string(),
  region: import_zod348.z.string().nullish(),
  transactionId: import_zod348.z.string()
});

// src/generated-definitions/AppleIapRequest.ts
var import_zod349 = require("zod");
var AppleIapRequest = import_zod349.z.object({ transactionId: import_zod349.z.string() });

// src/generated-definitions/AppUpdate.ts
var import_zod350 = require("zod");
var AppUpdate = import_zod350.z.object({
  carousel: import_zod350.z.array(Slide).nullish(),
  developer: import_zod350.z.string().nullish(),
  forumUrl: import_zod350.z.string().nullish(),
  genres: import_zod350.z.array(
    import_zod350.z.enum([
      "Action",
      "Adventure",
      "Casual",
      "FreeToPlay",
      "Indie",
      "MassivelyMultiplayer",
      "RPG",
      "Racing",
      "Simulation",
      "Sports",
      "Strategy"
    ])
  ).nullish(),
  localizations: import_zod350.z.record(AppLocalization).nullish(),
  platformRequirements: import_zod350.z.record(import_zod350.z.array(Requirement)).nullish(),
  platforms: import_zod350.z.array(import_zod350.z.enum(["Android", "IOS", "Linux", "MacOS", "Windows"])).nullish(),
  players: import_zod350.z.array(import_zod350.z.enum(["Coop", "CrossPlatformMulti", "LocalCoop", "MMO", "Multi", "Single"])).nullish(),
  primaryGenre: import_zod350.z.enum([
    "Action",
    "Adventure",
    "Casual",
    "FreeToPlay",
    "Indie",
    "MassivelyMultiplayer",
    "RPG",
    "Racing",
    "Simulation",
    "Sports",
    "Strategy"
  ]).nullish(),
  publisher: import_zod350.z.string().nullish(),
  releaseDate: import_zod350.z.string().nullish(),
  websiteUrl: import_zod350.z.string().nullish()
});

// src/generated-definitions/BaseCustomConfig.ts
var import_zod351 = require("zod");
var BaseCustomConfig = import_zod351.z.object({ connectionType: import_zod351.z.enum(["INSECURE", "TLS"]), grpcServerAddress: import_zod351.z.string() });

// src/generated-definitions/BinarySchema.ts
var import_zod352 = require("zod");
var BinarySchema = import_zod352.z.any();

// src/generated-definitions/BulkCreditRequest.ts
var import_zod353 = require("zod");
var BulkCreditRequest = import_zod353.z.object({
  creditRequest: CreditRequest.nullish(),
  currencyCode: import_zod353.z.string().nullish(),
  userIds: import_zod353.z.array(import_zod353.z.string()).nullish()
});

// src/generated-definitions/BulkDebitRequest.ts
var import_zod354 = require("zod");
var BulkDebitRequest = import_zod354.z.object({
  currencyCode: import_zod354.z.string().nullish(),
  request: DebitByCurrencyCodeRequest.nullish(),
  userIds: import_zod354.z.array(import_zod354.z.string()).nullish()
});

// src/generated-definitions/BulkEntitlementGrantRequest.ts
var import_zod355 = require("zod");
var BulkEntitlementGrantRequest = import_zod355.z.object({
  entitlementGrantList: import_zod355.z.array(EntitlementGrant).nullish(),
  userIds: import_zod355.z.array(import_zod355.z.string()).nullish()
});

// src/generated-definitions/BulkRegionDataChangeRequest.ts
var import_zod357 = require("zod");

// src/generated-definitions/RegionDataChange.ts
var import_zod356 = require("zod");
var RegionDataChange = import_zod356.z.object({
  itemIdentities: import_zod356.z.array(import_zod356.z.string()).nullish(),
  itemIdentityType: import_zod356.z.enum(["ITEM_ID", "ITEM_SKU"]),
  regionData: import_zod356.z.record(import_zod356.z.array(RegionDataItem)).nullish()
});

// src/generated-definitions/BulkRegionDataChangeRequest.ts
var BulkRegionDataChangeRequest = import_zod357.z.object({ changes: import_zod357.z.array(RegionDataChange).nullish() });

// src/generated-definitions/CampaignBatchNameChange.ts
var import_zod358 = require("zod");
var CampaignBatchNameChange = import_zod358.z.object({ newName: import_zod358.z.string().nullish(), oldName: import_zod358.z.string().nullish() });

// src/generated-definitions/CampaignCreate.ts
var import_zod359 = require("zod");
var CampaignCreate = import_zod359.z.object({
  description: import_zod359.z.string().nullish(),
  discountConfig: DiscountConfig.nullish(),
  items: import_zod359.z.array(RedeemableItem).nullish(),
  maxRedeemCountPerCampaignPerUser: import_zod359.z.number().int().nullish(),
  maxRedeemCountPerCode: import_zod359.z.number().int().nullish(),
  maxRedeemCountPerCodePerUser: import_zod359.z.number().int().nullish(),
  maxSaleCount: import_zod359.z.number().int().nullish(),
  name: import_zod359.z.string(),
  redeemEnd: import_zod359.z.string().nullish(),
  redeemStart: import_zod359.z.string().nullish(),
  redeemType: import_zod359.z.enum(["DISCOUNT", "ITEM"]).nullish(),
  status: import_zod359.z.enum(["ACTIVE", "INACTIVE"]).nullish(),
  tags: import_zod359.z.array(import_zod359.z.string()).nullish(),
  type: import_zod359.z.enum(["REDEMPTION"]).nullish()
});

// src/generated-definitions/CampaignUpdate.ts
var import_zod360 = require("zod");
var CampaignUpdate = import_zod360.z.object({
  description: import_zod360.z.string().nullish(),
  discountConfig: DiscountConfig.nullish(),
  items: import_zod360.z.array(RedeemableItem).nullish(),
  maxRedeemCountPerCampaignPerUser: import_zod360.z.number().int().nullish(),
  maxRedeemCountPerCode: import_zod360.z.number().int().nullish(),
  maxRedeemCountPerCodePerUser: import_zod360.z.number().int().nullish(),
  maxSaleCount: import_zod360.z.number().int().nullish(),
  name: import_zod360.z.string(),
  redeemEnd: import_zod360.z.string().nullish(),
  redeemStart: import_zod360.z.string().nullish(),
  redeemType: import_zod360.z.enum(["DISCOUNT", "ITEM"]).nullish(),
  status: import_zod360.z.enum(["ACTIVE", "INACTIVE"]).nullish(),
  tags: import_zod360.z.array(import_zod360.z.string()).nullish()
});

// src/generated-definitions/CancelRequest.ts
var import_zod361 = require("zod");
var CancelRequest = import_zod361.z.object({ immediate: import_zod361.z.boolean().nullish(), reason: import_zod361.z.string().nullish() });

// src/generated-definitions/CatalogConfigUpdate.ts
var import_zod362 = require("zod");
var CatalogConfigUpdate = import_zod362.z.object({ enableInventoryCheck: import_zod362.z.boolean() });

// src/generated-definitions/CategoryCreate.ts
var import_zod363 = require("zod");
var CategoryCreate = import_zod363.z.object({ categoryPath: import_zod363.z.string(), localizationDisplayNames: import_zod363.z.record(import_zod363.z.string()) });

// src/generated-definitions/CategoryInfo.ts
var import_zod364 = require("zod");
var CategoryInfo = import_zod364.z.object({
  categoryPath: import_zod364.z.string(),
  createdAt: import_zod364.z.string(),
  displayName: import_zod364.z.string(),
  namespace: import_zod364.z.string(),
  parentCategoryPath: import_zod364.z.string(),
  root: import_zod364.z.boolean().nullish(),
  updatedAt: import_zod364.z.string()
});

// src/generated-definitions/CategoryInfoArray.ts
var import_zod365 = require("zod");
var CategoryInfoArray = import_zod365.z.array(CategoryInfo);

// src/generated-definitions/CategoryUpdate.ts
var import_zod366 = require("zod");
var CategoryUpdate = import_zod366.z.object({ localizationDisplayNames: import_zod366.z.record(import_zod366.z.string()) });

// src/generated-definitions/CodeCreate.ts
var import_zod367 = require("zod");
var CodeCreate = import_zod367.z.object({
  batchName: import_zod367.z.string().nullish(),
  codeValue: import_zod367.z.string().nullish(),
  quantity: import_zod367.z.number().int().nullish()
});

// src/generated-definitions/CurrencyCreate.ts
var import_zod368 = require("zod");
var CurrencyCreate = import_zod368.z.object({
  currencyCode: import_zod368.z.string(),
  currencySymbol: import_zod368.z.string().nullish(),
  currencyType: import_zod368.z.enum(["REAL", "VIRTUAL"]).nullish(),
  decimals: import_zod368.z.number().int().nullish(),
  localizationDescriptions: import_zod368.z.record(import_zod368.z.string()).nullish()
});

// src/generated-definitions/CurrencyUpdate.ts
var import_zod369 = require("zod");
var CurrencyUpdate = import_zod369.z.object({ localizationDescriptions: import_zod369.z.record(import_zod369.z.string()).nullish() });

// src/generated-definitions/Customization.ts
var import_zod370 = require("zod");
var Customization = import_zod370.z.object({ settings: import_zod370.z.string().nullish() });

// src/generated-definitions/DebitByWalletPlatformRequest.ts
var import_zod371 = require("zod");
var DebitByWalletPlatformRequest = import_zod371.z.object({
  amount: import_zod371.z.number().int(),
  debitBalanceSource: import_zod371.z.enum(["DLC_REVOCATION", "EXPIRATION", "IAP_REVOCATION", "ORDER_REVOCATION", "OTHER", "PAYMENT", "TRADE"]).nullish(),
  metadata: import_zod371.z.record(import_zod371.z.any()).nullish(),
  reason: import_zod371.z.string().nullish(),
  walletPlatform: import_zod371.z.enum(["Epic", "GooglePlay", "IOS", "Nintendo", "Oculus", "Other", "Playstation", "Steam", "Xbox"]).nullish()
});

// src/generated-definitions/DebitRequest.ts
var import_zod372 = require("zod");
var DebitRequest = import_zod372.z.object({
  amount: import_zod372.z.number().int(),
  balanceSource: import_zod372.z.enum(["DLC_REVOCATION", "EXPIRATION", "IAP_REVOCATION", "ORDER_REVOCATION", "OTHER", "PAYMENT", "TRADE"]).nullish(),
  metadata: import_zod372.z.record(import_zod372.z.any()).nullish(),
  reason: import_zod372.z.string().nullish()
});

// src/generated-definitions/DeleteRewardConditionRequest.ts
var import_zod373 = require("zod");
var DeleteRewardConditionRequest = import_zod373.z.object({ conditionName: import_zod373.z.string().nullish(), userId: import_zod373.z.string().nullish() });

// src/generated-definitions/DlcConfigRewardShortInfo.ts
var import_zod374 = require("zod");
var DlcConfigRewardShortInfo = import_zod374.z.object({
  data: import_zod374.z.record(import_zod374.z.array(import_zod374.z.string())).nullish(),
  dlcType: import_zod374.z.enum(["EPICGAMES", "OCULUS", "PSN", "STEAM", "XBOX"]).nullish()
});

// src/generated-definitions/DlcItemConfigUpdate.ts
var import_zod375 = require("zod");
var DlcItemConfigUpdate = import_zod375.z.object({ data: import_zod375.z.array(DlcItem).nullish() });

// src/generated-definitions/EntitlementPlatformConfigUpdate.ts
var import_zod376 = require("zod");
var EntitlementPlatformConfigUpdate = import_zod376.z.object({
  allowedPlatformOrigins: import_zod376.z.array(import_zod376.z.enum(["Epic", "GooglePlay", "IOS", "Nintendo", "Oculus", "Other", "Playstation", "Steam", "System", "Twitch", "Xbox"])).nullish()
});

// src/generated-definitions/EntitlementRevokeRequest.ts
var import_zod377 = require("zod");
var EntitlementRevokeRequest = import_zod377.z.object({ metadata: import_zod377.z.record(import_zod377.z.any()).nullish() });

// src/generated-definitions/EntitlementSoldRequest.ts
var import_zod378 = require("zod");
var EntitlementSoldRequest = import_zod378.z.object({ requestId: import_zod378.z.string().nullish(), useCount: import_zod378.z.number().int().nullish() });

// src/generated-definitions/EntitlementSplitRequest.ts
var import_zod380 = require("zod");

// src/generated-definitions/PublicEntitlementMetadata.ts
var import_zod379 = require("zod");
var PublicEntitlementMetadata = import_zod379.z.object({ operationSource: import_zod379.z.enum(["INVENTORY"]).nullish() });

// src/generated-definitions/EntitlementSplitRequest.ts
var EntitlementSplitRequest = import_zod380.z.object({ metadata: PublicEntitlementMetadata.nullish(), useCount: import_zod380.z.number().int().nullish() });

// src/generated-definitions/EntitlementSplitResult.ts
var import_zod381 = require("zod");
var EntitlementSplitResult = import_zod381.z.object({ source: EntitlementInfo.nullish(), target: EntitlementInfo.nullish() });

// src/generated-definitions/EntitlementTransferRequest.ts
var import_zod382 = require("zod");
var EntitlementTransferRequest = import_zod382.z.object({
  entitlementId: import_zod382.z.string().nullish(),
  metadata: PublicEntitlementMetadata.nullish(),
  useCount: import_zod382.z.number().int().nullish()
});

// src/generated-definitions/EntitlementTransferResult.ts
var import_zod383 = require("zod");
var EntitlementTransferResult = import_zod383.z.object({ source: EntitlementInfo.nullish(), target: EntitlementInfo.nullish() });

// src/generated-definitions/EntitlementUpdate.ts
var import_zod384 = require("zod");
var EntitlementUpdate = import_zod384.z.object({
  collectionId: import_zod384.z.string().nullish(),
  endDate: import_zod384.z.string().nullish(),
  nullFieldList: import_zod384.z.array(import_zod384.z.string()).nullish(),
  origin: import_zod384.z.enum(["Epic", "GooglePlay", "IOS", "Nintendo", "Oculus", "Other", "Playstation", "Steam", "System", "Twitch", "Xbox"]).nullish(),
  reason: import_zod384.z.string().nullish(),
  startDate: import_zod384.z.string().nullish(),
  status: import_zod384.z.enum(["ACTIVE", "CONSUMED", "INACTIVE", "REVOKED", "SOLD"]).nullish(),
  useCount: import_zod384.z.number().int().nullish()
});

// src/generated-definitions/EpicGamesDlcSyncRequest.ts
var import_zod385 = require("zod");
var EpicGamesDlcSyncRequest = import_zod385.z.object({ epicGamesJwtToken: import_zod385.z.string().nullish() });

// src/generated-definitions/EpicGamesIapConfigRequest.ts
var import_zod386 = require("zod");
var EpicGamesIapConfigRequest = import_zod386.z.object({ sandboxId: import_zod386.z.string() });

// src/generated-definitions/EpicGamesReconcileRequest.ts
var import_zod387 = require("zod");
var EpicGamesReconcileRequest = import_zod387.z.object({ epicGamesJwtToken: import_zod387.z.string().nullish() });

// src/generated-definitions/EpicGamesReconcileResult.ts
var import_zod388 = require("zod");
var EpicGamesReconcileResult = import_zod388.z.object({
  epicGamesItemId: import_zod388.z.string().nullish(),
  itemId: import_zod388.z.string().nullish(),
  sku: import_zod388.z.string().nullish(),
  status: import_zod388.z.enum(["FAILED", "FULFILLED", "VERIFIED"]).nullish(),
  transactionId: import_zod388.z.string().nullish()
});

// src/generated-definitions/EpicGamesReconcileResultArray.ts
var import_zod389 = require("zod");
var EpicGamesReconcileResultArray = import_zod389.z.array(EpicGamesReconcileResult);

// src/generated-definitions/ErrorEntity.ts
var import_zod391 = require("zod");

// src/generated-definitions/Permission.ts
var import_zod390 = require("zod");
var Permission = import_zod390.z.object({ action: import_zod390.z.number().int().nullish(), resource: import_zod390.z.string().nullish() });

// src/generated-definitions/ErrorEntity.ts
var ErrorEntity = import_zod391.z.object({
  devStackTrace: import_zod391.z.string().nullish(),
  errorCode: import_zod391.z.number().int(),
  errorMessage: import_zod391.z.string(),
  messageVariables: import_zod391.z.record(import_zod391.z.string()).nullish(),
  requiredPermission: Permission.nullish()
});

// src/generated-definitions/EstimatedPriceInfoArray.ts
var import_zod392 = require("zod");
var EstimatedPriceInfoArray = import_zod392.z.array(EstimatedPriceInfo);

// src/generated-definitions/EventAdditionalData.ts
var import_zod393 = require("zod");
var EventAdditionalData = import_zod393.z.object({ entitlement: import_zod393.z.array(AdditionalDataEntitlement).nullish(), purpose: import_zod393.z.string().nullish() });

// src/generated-definitions/EventPayload.ts
var import_zod394 = require("zod");
var EventPayload = import_zod394.z.object({ payload: import_zod394.z.record(import_zod394.z.any()).nullish() });

// src/generated-definitions/ExportStoreRequest.ts
var import_zod395 = require("zod");
var ExportStoreRequest = import_zod395.z.object({ itemIds: import_zod395.z.array(import_zod395.z.string()).nullish() });

// src/generated-definitions/ExportStoreToCsvRequest.ts
var import_zod396 = require("zod");
var ExportStoreToCsvRequest = import_zod396.z.object({
  catalogType: import_zod396.z.enum(["APP", "CATEGORY", "ITEM", "SECTION", "VIEW"]),
  fieldsToBeIncluded: import_zod396.z.array(import_zod396.z.string()).nullish(),
  idsToBeExported: import_zod396.z.array(import_zod396.z.string()).nullish(),
  storeId: import_zod396.z.string().nullish()
});

// src/generated-definitions/ExternalPaymentOrderCreate.ts
var import_zod397 = require("zod");
var ExternalPaymentOrderCreate = import_zod397.z.object({
  currencyCode: import_zod397.z.string().nullish(),
  currencyNamespace: import_zod397.z.string().nullish(),
  customParameters: import_zod397.z.record(import_zod397.z.any()).nullish(),
  description: import_zod397.z.string(),
  extOrderNo: import_zod397.z.string(),
  extUserId: import_zod397.z.string().nullish(),
  itemType: import_zod397.z.enum(["APP", "BUNDLE", "CODE", "COINS", "EXTENSION", "INGAMEITEM", "LOOTBOX", "MEDIA", "OPTIONBOX", "SEASON", "SUBSCRIPTION"]).nullish(),
  language: import_zod397.z.string().nullish(),
  metadata: import_zod397.z.record(import_zod397.z.string()).nullish(),
  notifyUrl: import_zod397.z.string().nullish(),
  omitNotification: import_zod397.z.boolean().nullish(),
  platform: import_zod397.z.string().nullish(),
  price: import_zod397.z.number().int(),
  recurringPaymentOrderNo: import_zod397.z.string().nullish(),
  region: import_zod397.z.string().nullish(),
  returnUrl: import_zod397.z.string().nullish(),
  sandbox: import_zod397.z.boolean().nullish(),
  sku: import_zod397.z.string().nullish(),
  subscriptionId: import_zod397.z.string().nullish(),
  targetNamespace: import_zod397.z.string(),
  targetUserId: import_zod397.z.string(),
  title: import_zod397.z.string()
});

// src/generated-definitions/FieldValidationError.ts
var import_zod398 = require("zod");
var FieldValidationError = import_zod398.z.object({
  errorCode: import_zod398.z.string().nullish(),
  errorField: import_zod398.z.string().nullish(),
  errorMessage: import_zod398.z.string().nullish(),
  errorValue: import_zod398.z.string().nullish(),
  messageVariables: import_zod398.z.record(import_zod398.z.string()).nullish()
});

// src/generated-definitions/FulfillCodeRequest.ts
var import_zod399 = require("zod");
var FulfillCodeRequest = import_zod399.z.object({ code: import_zod399.z.string(), language: import_zod399.z.string().nullish(), region: import_zod399.z.string().nullish() });

// src/generated-definitions/FulfillmentRequest.ts
var import_zod401 = require("zod");

// src/generated-definitions/OrderSummary.ts
var import_zod400 = require("zod");
var OrderSummary = import_zod400.z.object({ currency: CurrencySummary.nullish(), ext: import_zod400.z.record(import_zod400.z.any()).nullish(), free: import_zod400.z.boolean().nullish() });

// src/generated-definitions/FulfillmentRequest.ts
var FulfillmentRequest = import_zod401.z.object({
  duration: import_zod401.z.number().int().nullish(),
  endDate: import_zod401.z.string().nullish(),
  entitlementCollectionId: import_zod401.z.string().nullish(),
  entitlementOrigin: import_zod401.z.enum(["Epic", "GooglePlay", "IOS", "Nintendo", "Oculus", "Other", "Playstation", "Steam", "System", "Twitch", "Xbox"]).nullish(),
  itemId: import_zod401.z.string().nullish(),
  itemSku: import_zod401.z.string().nullish(),
  language: import_zod401.z.string().nullish(),
  metadata: import_zod401.z.record(import_zod401.z.any()).nullish(),
  order: OrderSummary.nullish(),
  orderNo: import_zod401.z.string().nullish(),
  origin: import_zod401.z.enum(["Epic", "GooglePlay", "IOS", "Nintendo", "Oculus", "Other", "Playstation", "Steam", "System", "Twitch", "Xbox"]).nullish(),
  overrideBundleItemQty: import_zod401.z.record(import_zod401.z.number().int()).nullish(),
  quantity: import_zod401.z.number().int(),
  region: import_zod401.z.string().nullish(),
  source: import_zod401.z.enum([
    "ACHIEVEMENT",
    "CONSUME_ENTITLEMENT",
    "DLC",
    "EXPIRATION",
    "GIFT",
    "IAP",
    "IAP_CHARGEBACK_REVERSED",
    "ORDER_REVOCATION",
    "OTHER",
    "PAYMENT",
    "PROMOTION",
    "PURCHASE",
    "REDEEM_CODE",
    "REFERRAL_BONUS",
    "REWARD",
    "SELL_BACK"
  ]).nullish(),
  startDate: import_zod401.z.string().nullish(),
  storeId: import_zod401.z.string().nullish()
});

// src/generated-definitions/FulfillmentScriptCreate.ts
var import_zod402 = require("zod");
var FulfillmentScriptCreate = import_zod402.z.object({ grantDays: import_zod402.z.string().nullish() });

// src/generated-definitions/FulfillmentScriptUpdate.ts
var import_zod403 = require("zod");
var FulfillmentScriptUpdate = import_zod403.z.object({ grantDays: import_zod403.z.string().nullish() });

// src/generated-definitions/FulfillmentV2Request.ts
var import_zod405 = require("zod");

// src/generated-definitions/FulfillmentV2RequestItem.ts
var import_zod404 = require("zod");
var FulfillmentV2RequestItem = import_zod404.z.object({
  duration: import_zod404.z.number().int().nullish(),
  endDate: import_zod404.z.string().nullish(),
  entitlementCollectionId: import_zod404.z.string().nullish(),
  entitlementOrigin: import_zod404.z.enum(["Epic", "GooglePlay", "IOS", "Nintendo", "Oculus", "Other", "Playstation", "Steam", "System", "Twitch", "Xbox"]).nullish(),
  itemId: import_zod404.z.string().nullish(),
  itemSku: import_zod404.z.string().nullish(),
  language: import_zod404.z.string().nullish(),
  metadata: import_zod404.z.record(import_zod404.z.any()).nullish(),
  orderNo: import_zod404.z.string().nullish(),
  origin: import_zod404.z.enum(["Epic", "GooglePlay", "IOS", "Nintendo", "Oculus", "Other", "Playstation", "Steam", "System", "Twitch", "Xbox"]).nullish(),
  quantity: import_zod404.z.number().int(),
  region: import_zod404.z.string().nullish(),
  source: import_zod404.z.enum([
    "ACHIEVEMENT",
    "CONSUME_ENTITLEMENT",
    "DLC",
    "EXPIRATION",
    "GIFT",
    "IAP",
    "IAP_CHARGEBACK_REVERSED",
    "ORDER_REVOCATION",
    "OTHER",
    "PAYMENT",
    "PROMOTION",
    "PURCHASE",
    "REDEEM_CODE",
    "REFERRAL_BONUS",
    "REWARD",
    "SELL_BACK"
  ]).nullish(),
  startDate: import_zod404.z.string().nullish(),
  storeId: import_zod404.z.string().nullish()
});

// src/generated-definitions/FulfillmentV2Request.ts
var FulfillmentV2Request = import_zod405.z.object({ items: import_zod405.z.array(FulfillmentV2RequestItem).nullish() });

// src/generated-definitions/GoogleIapConfigRequest.ts
var import_zod406 = require("zod");
var GoogleIapConfigRequest = import_zod406.z.object({
  applicationName: import_zod406.z.string(),
  notificationTokenAudience: import_zod406.z.string().nullish(),
  notificationTokenEmail: import_zod406.z.string().nullish(),
  serviceAccountId: import_zod406.z.string()
});

// src/generated-definitions/GoogleIapReceipt.ts
var import_zod407 = require("zod");
var GoogleIapReceipt = import_zod407.z.object({
  autoAck: import_zod407.z.boolean().nullish(),
  autoConsume: import_zod407.z.boolean().nullish(),
  language: import_zod407.z.string().nullish(),
  orderId: import_zod407.z.string(),
  packageName: import_zod407.z.string(),
  productId: import_zod407.z.string().nullish(),
  purchaseTime: import_zod407.z.number().int().nullish(),
  purchaseToken: import_zod407.z.string(),
  region: import_zod407.z.string().nullish(),
  subscriptionPurchase: import_zod407.z.boolean().nullish()
});

// src/generated-definitions/GoogleReceiptResolveResult.ts
var import_zod408 = require("zod");
var GoogleReceiptResolveResult = import_zod408.z.object({ needConsume: import_zod408.z.boolean().nullish() });

// src/generated-definitions/GrantSubscriptionDaysRequest.ts
var import_zod409 = require("zod");
var GrantSubscriptionDaysRequest = import_zod409.z.object({ grantDays: import_zod409.z.number().int(), reason: import_zod409.z.string().nullish() });

// src/generated-definitions/HierarchicalCategoryInfo.ts
var import_zod410 = require("zod");
var HierarchicalCategoryInfo = import_zod410.z.lazy(
  () => import_zod410.z.object({
    categoryPath: import_zod410.z.string(),
    childCategories: import_zod410.z.array(HierarchicalCategoryInfo),
    createdAt: import_zod410.z.string(),
    displayName: import_zod410.z.string(),
    namespace: import_zod410.z.string(),
    parentCategoryPath: import_zod410.z.string(),
    root: import_zod410.z.boolean().nullish(),
    updatedAt: import_zod410.z.string()
  })
);

// src/generated-definitions/HierarchicalCategoryInfoArray.ts
var import_zod411 = require("zod");
var HierarchicalCategoryInfoArray = import_zod411.z.array(HierarchicalCategoryInfo);

// src/generated-definitions/IapItemConfigUpdate.ts
var import_zod412 = require("zod");
var IapItemConfigUpdate = import_zod412.z.object({ data: import_zod412.z.array(IapItemEntry).nullish() });

// src/generated-definitions/IapItemFlatEntry.ts
var import_zod413 = require("zod");
var IapItemFlatEntry = import_zod413.z.object({
  itemIdentity: import_zod413.z.string().nullish(),
  itemIdentityType: import_zod413.z.enum(["ITEM_ID", "ITEM_SKU"]).nullish(),
  platform: import_zod413.z.enum(["APPLE", "EPICGAMES", "GOOGLE", "OCULUS", "PLAYSTATION", "STADIA", "STEAM", "TWITCH", "XBOX"]).nullish(),
  platformProductId: import_zod413.z.string().nullish()
});

// src/generated-definitions/IapItemMappingInfo.ts
var import_zod414 = require("zod");
var IapItemMappingInfo = import_zod414.z.object({ data: import_zod414.z.array(IapItemFlatEntry).nullish() });

// src/generated-definitions/InGameItemSync.ts
var import_zod415 = require("zod");
var InGameItemSync = import_zod415.z.object({ categoryPath: import_zod415.z.string(), targetItemId: import_zod415.z.string(), targetNamespace: import_zod415.z.string() });

// src/generated-definitions/ItemAcquireRequest.ts
var import_zod416 = require("zod");
var ItemAcquireRequest = import_zod416.z.object({ count: import_zod416.z.number().int(), orderNo: import_zod416.z.string() });

// src/generated-definitions/ItemCreate.ts
var import_zod418 = require("zod");

// src/generated-definitions/RegionDataItemDto.ts
var import_zod417 = require("zod");
var RegionDataItemDto = import_zod417.z.object({
  currencyCode: import_zod417.z.string(),
  currencyNamespace: import_zod417.z.string(),
  currencyType: import_zod417.z.enum(["REAL", "VIRTUAL"]),
  discountAmount: import_zod417.z.number().int().nullish(),
  discountExpireAt: import_zod417.z.string().nullish(),
  discountPercentage: import_zod417.z.number().int().nullish(),
  discountPurchaseAt: import_zod417.z.string().nullish(),
  expireAt: import_zod417.z.string().nullish(),
  price: import_zod417.z.number().int(),
  purchaseAt: import_zod417.z.string().nullish(),
  trialPrice: import_zod417.z.number().int().nullish()
});

// src/generated-definitions/ItemCreate.ts
var ItemCreate = import_zod418.z.object({
  appId: import_zod418.z.string().nullish(),
  appType: import_zod418.z.enum(["DEMO", "DLC", "GAME", "SOFTWARE"]).nullish(),
  baseAppId: import_zod418.z.string().nullish(),
  boothName: import_zod418.z.string().nullish(),
  categoryPath: import_zod418.z.string(),
  clazz: import_zod418.z.string().nullish(),
  displayOrder: import_zod418.z.number().int().nullish(),
  entitlementType: import_zod418.z.enum(["CONSUMABLE", "DURABLE"]),
  ext: import_zod418.z.record(import_zod418.z.any()).nullish(),
  features: import_zod418.z.array(import_zod418.z.string()).nullish(),
  flexible: import_zod418.z.boolean().nullish(),
  images: import_zod418.z.array(Image).nullish(),
  inventoryConfig: InventoryConfig.nullish(),
  itemIds: import_zod418.z.array(import_zod418.z.string()).nullish(),
  itemQty: import_zod418.z.record(import_zod418.z.number().int()).nullish(),
  itemType: import_zod418.z.enum([
    "APP",
    "BUNDLE",
    "CODE",
    "COINS",
    "EXTENSION",
    "INGAMEITEM",
    "LOOTBOX",
    "MEDIA",
    "OPTIONBOX",
    "SEASON",
    "SUBSCRIPTION"
  ]),
  listable: import_zod418.z.boolean().nullish(),
  localizations: import_zod418.z.record(Localization),
  lootBoxConfig: LootBoxConfig.nullish(),
  maxCount: import_zod418.z.number().int().nullish(),
  maxCountPerUser: import_zod418.z.number().int().nullish(),
  name: import_zod418.z.string(),
  optionBoxConfig: OptionBoxConfig.nullish(),
  purchasable: import_zod418.z.boolean().nullish(),
  recurring: Recurring.nullish(),
  regionData: import_zod418.z.record(import_zod418.z.array(RegionDataItemDto)),
  saleConfig: SaleConfig.nullish(),
  seasonType: import_zod418.z.enum(["PASS", "TIER"]).nullish(),
  sectionExclusive: import_zod418.z.boolean().nullish(),
  sellable: import_zod418.z.boolean().nullish(),
  sku: import_zod418.z.string().nullish(),
  stackable: import_zod418.z.boolean().nullish(),
  status: import_zod418.z.enum(["ACTIVE", "INACTIVE"]),
  tags: import_zod418.z.array(import_zod418.z.string()).nullish(),
  targetCurrencyCode: import_zod418.z.string().nullish(),
  targetNamespace: import_zod418.z.string().nullish(),
  thumbnailUrl: import_zod418.z.string().nullish(),
  useCount: import_zod418.z.number().int().nullish()
});

// src/generated-definitions/ItemPagingSlicedResult.ts
var import_zod419 = require("zod");
var ItemPagingSlicedResult = import_zod419.z.object({ data: import_zod419.z.array(ItemInfo), paging: Paging.nullish() });

// src/generated-definitions/ItemPurchaseConditionValidateRequest.ts
var import_zod420 = require("zod");
var ItemPurchaseConditionValidateRequest = import_zod420.z.object({ itemIds: import_zod420.z.array(import_zod420.z.string()).nullish() });

// src/generated-definitions/ItemReturnRequest.ts
var import_zod421 = require("zod");
var ItemReturnRequest = import_zod421.z.object({ orderNo: import_zod421.z.string() });

// src/generated-definitions/ItemTypeConfigCreate.ts
var import_zod422 = require("zod");
var ItemTypeConfigCreate = import_zod422.z.object({
  clazz: import_zod422.z.string().nullish(),
  dryRun: import_zod422.z.boolean().nullish(),
  fulfillmentUrl: import_zod422.z.string(),
  itemType: import_zod422.z.enum([
    "APP",
    "BUNDLE",
    "CODE",
    "COINS",
    "EXTENSION",
    "INGAMEITEM",
    "LOOTBOX",
    "MEDIA",
    "OPTIONBOX",
    "SEASON",
    "SUBSCRIPTION"
  ]),
  purchaseConditionUrl: import_zod422.z.string().nullish()
});

// src/generated-definitions/ItemTypeConfigUpdate.ts
var import_zod423 = require("zod");
var ItemTypeConfigUpdate = import_zod423.z.object({
  clazz: import_zod423.z.string().nullish(),
  dryRun: import_zod423.z.boolean().nullish(),
  fulfillmentUrl: import_zod423.z.string(),
  purchaseConditionUrl: import_zod423.z.string().nullish()
});

// src/generated-definitions/ItemUpdate.ts
var import_zod424 = require("zod");
var ItemUpdate = import_zod424.z.object({
  appId: import_zod424.z.string().nullish(),
  appType: import_zod424.z.enum(["DEMO", "DLC", "GAME", "SOFTWARE"]).nullish(),
  baseAppId: import_zod424.z.string().nullish(),
  boothName: import_zod424.z.string().nullish(),
  categoryPath: import_zod424.z.string().nullish(),
  clazz: import_zod424.z.string().nullish(),
  displayOrder: import_zod424.z.number().int().nullish(),
  entitlementType: import_zod424.z.enum(["CONSUMABLE", "DURABLE"]),
  ext: import_zod424.z.record(import_zod424.z.any()).nullish(),
  features: import_zod424.z.array(import_zod424.z.string()).nullish(),
  flexible: import_zod424.z.boolean().nullish(),
  images: import_zod424.z.array(Image).nullish(),
  inventoryConfig: InventoryConfig.nullish(),
  itemIds: import_zod424.z.array(import_zod424.z.string()).nullish(),
  itemQty: import_zod424.z.record(import_zod424.z.number().int()).nullish(),
  itemType: import_zod424.z.enum([
    "APP",
    "BUNDLE",
    "CODE",
    "COINS",
    "EXTENSION",
    "INGAMEITEM",
    "LOOTBOX",
    "MEDIA",
    "OPTIONBOX",
    "SEASON",
    "SUBSCRIPTION"
  ]),
  listable: import_zod424.z.boolean().nullish(),
  localizations: import_zod424.z.record(Localization).nullish(),
  lootBoxConfig: LootBoxConfig.nullish(),
  maxCount: import_zod424.z.number().int().nullish(),
  maxCountPerUser: import_zod424.z.number().int().nullish(),
  name: import_zod424.z.string().nullish(),
  optionBoxConfig: OptionBoxConfig.nullish(),
  purchasable: import_zod424.z.boolean().nullish(),
  recurring: Recurring.nullish(),
  regionData: import_zod424.z.record(import_zod424.z.array(RegionDataItemDto)).nullish(),
  saleConfig: SaleConfig.nullish(),
  seasonType: import_zod424.z.enum(["PASS", "TIER"]).nullish(),
  sectionExclusive: import_zod424.z.boolean().nullish(),
  sellable: import_zod424.z.boolean().nullish(),
  sku: import_zod424.z.string().nullish(),
  stackable: import_zod424.z.boolean().nullish(),
  status: import_zod424.z.enum(["ACTIVE", "INACTIVE"]).nullish(),
  tags: import_zod424.z.array(import_zod424.z.string()).nullish(),
  targetCurrencyCode: import_zod424.z.string().nullish(),
  targetNamespace: import_zod424.z.string().nullish(),
  thumbnailUrl: import_zod424.z.string().nullish(),
  useCount: import_zod424.z.number().int().nullish()
});

// src/generated-definitions/KeyGroupCreate.ts
var import_zod425 = require("zod");
var KeyGroupCreate = import_zod425.z.object({
  description: import_zod425.z.string().nullish(),
  name: import_zod425.z.string(),
  status: import_zod425.z.enum(["ACTIVE", "INACTIVE"]).nullish(),
  tags: import_zod425.z.array(import_zod425.z.string()).nullish()
});

// src/generated-definitions/KeyGroupUpdate.ts
var import_zod426 = require("zod");
var KeyGroupUpdate = import_zod426.z.object({
  description: import_zod426.z.string().nullish(),
  name: import_zod426.z.string(),
  status: import_zod426.z.enum(["ACTIVE", "INACTIVE"]).nullish(),
  tags: import_zod426.z.array(import_zod426.z.string()).nullish()
});

// src/generated-definitions/LootBoxPluginConfigUpdate.ts
var import_zod427 = require("zod");
var LootBoxPluginConfigUpdate = import_zod427.z.object({
  appConfig: AppConfig.nullish(),
  customConfig: BaseCustomConfig.nullish(),
  extendType: import_zod427.z.enum(["APP", "CUSTOM"])
});

// src/generated-definitions/MockIapReceipt.ts
var import_zod428 = require("zod");
var MockIapReceipt = import_zod428.z.object({
  itemIdentityType: import_zod428.z.enum(["ITEM_ID", "ITEM_SKU"]).nullish(),
  language: import_zod428.z.string().nullish(),
  productId: import_zod428.z.string(),
  region: import_zod428.z.string().nullish(),
  transactionId: import_zod428.z.string().nullish(),
  type: import_zod428.z.enum(["APPLE", "EPICGAMES", "GOOGLE", "OCULUS", "PLAYSTATION", "STADIA", "STEAM", "TWITCH", "XBOX"])
});

// src/generated-definitions/OculusIapConfigRequest.ts
var import_zod429 = require("zod");
var OculusIapConfigRequest = import_zod429.z.object({ appId: import_zod429.z.string(), appSecret: import_zod429.z.string().nullish() });

// src/generated-definitions/OculusReconcileResult.ts
var import_zod430 = require("zod");
var OculusReconcileResult = import_zod430.z.object({
  iapOrderStatus: import_zod430.z.enum(["FAILED", "FULFILLED", "VERIFIED"]).nullish(),
  itemIdentity: import_zod430.z.string().nullish(),
  itemIdentityType: import_zod430.z.enum(["ITEM_ID", "ITEM_SKU"]).nullish(),
  oculusItemSku: import_zod430.z.string().nullish(),
  transactionId: import_zod430.z.string().nullish()
});

// src/generated-definitions/OculusReconcileResultArray.ts
var import_zod431 = require("zod");
var OculusReconcileResultArray = import_zod431.z.array(OculusReconcileResult);

// src/generated-definitions/OrderCreate.ts
var import_zod432 = require("zod");
var OrderCreate = import_zod432.z.object({
  currencyCode: import_zod432.z.string(),
  discountCodes: import_zod432.z.array(import_zod432.z.string()).nullish(),
  discountedPrice: import_zod432.z.number().int(),
  ext: import_zod432.z.record(import_zod432.z.any()).nullish(),
  itemId: import_zod432.z.string(),
  language: import_zod432.z.string().nullish(),
  price: import_zod432.z.number().int().nullish(),
  quantity: import_zod432.z.number().int(),
  region: import_zod432.z.string().nullish(),
  returnUrl: import_zod432.z.string().nullish(),
  sectionId: import_zod432.z.string().nullish()
});

// src/generated-definitions/OrderDiscountPreviewRequest.ts
var import_zod433 = require("zod");
var OrderDiscountPreviewRequest = import_zod433.z.object({
  currencyCode: import_zod433.z.string(),
  discountCodes: import_zod433.z.array(import_zod433.z.string()).nullish(),
  discountedPrice: import_zod433.z.number().int(),
  itemId: import_zod433.z.string(),
  price: import_zod433.z.number().int().nullish(),
  quantity: import_zod433.z.number().int()
});

// src/generated-definitions/OrderDiscountPreviewResponse.ts
var import_zod434 = require("zod");
var OrderDiscountPreviewResponse = import_zod434.z.object({
  deduction: import_zod434.z.number().int(),
  deductionDetails: import_zod434.z.array(DeductionDetail).nullish(),
  discountedPrice: import_zod434.z.number().int(),
  finalPrice: import_zod434.z.number().int().nullish(),
  itemId: import_zod434.z.string(),
  price: import_zod434.z.number().int().nullish(),
  quantity: import_zod434.z.number().int()
});

// src/generated-definitions/OrderRefundCreate.ts
var import_zod435 = require("zod");
var OrderRefundCreate = import_zod435.z.object({ description: import_zod435.z.string() });

// src/generated-definitions/OrderUpdate.ts
var import_zod436 = require("zod");
var OrderUpdate = import_zod436.z.object({
  status: import_zod436.z.enum([
    "CHARGEBACK",
    "CHARGEBACK_REVERSED",
    "CHARGED",
    "CLOSED",
    "DELETED",
    "FULFILLED",
    "FULFILL_FAILED",
    "INIT",
    "REFUNDED",
    "REFUNDING",
    "REFUND_FAILED"
  ]),
  statusReason: import_zod436.z.string()
});

// src/generated-definitions/OwnershipToken.ts
var import_zod437 = require("zod");
var OwnershipToken = import_zod437.z.object({ ownershipToken: import_zod437.z.string().nullish() });

// src/generated-definitions/PaymentAccount.ts
var import_zod438 = require("zod");
var PaymentAccount = import_zod438.z.object({ id: import_zod438.z.string(), name: import_zod438.z.string(), type: import_zod438.z.enum(["card", "paypal"]) });

// src/generated-definitions/PaymentAccountArray.ts
var import_zod439 = require("zod");
var PaymentAccountArray = import_zod439.z.array(PaymentAccount);

// src/generated-definitions/PaymentCallbackConfigUpdate.ts
var import_zod440 = require("zod");
var PaymentCallbackConfigUpdate = import_zod440.z.object({
  dryRun: import_zod440.z.boolean().nullish(),
  notifyUrl: import_zod440.z.string().nullish(),
  privateKey: import_zod440.z.string().nullish()
});

// src/generated-definitions/PaymentDomainWhitelistConfigEdit.ts
var import_zod441 = require("zod");
var PaymentDomainWhitelistConfigEdit = import_zod441.z.object({ domains: import_zod441.z.array(import_zod441.z.string()) });

// src/generated-definitions/PaymentMethod.ts
var import_zod442 = require("zod");
var PaymentMethod = import_zod442.z.object({
  name: import_zod442.z.string(),
  paymentProvider: import_zod442.z.enum(["ADYEN", "ALIPAY", "CHECKOUT", "NEONPAY", "PAYPAL", "STRIPE", "WALLET", "WXPAY", "XSOLLA"])
});

// src/generated-definitions/PaymentMethodArray.ts
var import_zod443 = require("zod");
var PaymentMethodArray = import_zod443.z.array(PaymentMethod);

// src/generated-definitions/PaymentOrderChargeRequest.ts
var import_zod444 = require("zod");
var PaymentOrderChargeRequest = import_zod444.z.object({
  extTxId: import_zod444.z.string().nullish(),
  paymentMethod: import_zod444.z.string().nullish(),
  paymentProvider: import_zod444.z.enum(["ADYEN", "ALIPAY", "CHECKOUT", "NEONPAY", "PAYPAL", "STRIPE", "WALLET", "WXPAY", "XSOLLA"])
});

// src/generated-definitions/PaymentOrderCreate.ts
var import_zod445 = require("zod");
var PaymentOrderCreate = import_zod445.z.object({
  currencyCode: import_zod445.z.string().nullish(),
  currencyNamespace: import_zod445.z.string().nullish(),
  customParameters: import_zod445.z.record(import_zod445.z.any()).nullish(),
  description: import_zod445.z.string(),
  extOrderNo: import_zod445.z.string(),
  extUserId: import_zod445.z.string().nullish(),
  itemType: import_zod445.z.enum(["APP", "BUNDLE", "CODE", "COINS", "EXTENSION", "INGAMEITEM", "LOOTBOX", "MEDIA", "OPTIONBOX", "SEASON", "SUBSCRIPTION"]).nullish(),
  language: import_zod445.z.string().nullish(),
  metadata: import_zod445.z.record(import_zod445.z.string()).nullish(),
  notifyUrl: import_zod445.z.string().nullish(),
  omitNotification: import_zod445.z.boolean().nullish(),
  platform: import_zod445.z.string().nullish(),
  price: import_zod445.z.number().int(),
  recurringPaymentOrderNo: import_zod445.z.string().nullish(),
  region: import_zod445.z.string().nullish(),
  returnUrl: import_zod445.z.string().nullish(),
  sandbox: import_zod445.z.boolean().nullish(),
  sku: import_zod445.z.string().nullish(),
  subscriptionId: import_zod445.z.string().nullish(),
  title: import_zod445.z.string()
});

// src/generated-definitions/PaymentOrderDetails.ts
var import_zod446 = require("zod");
var PaymentOrderDetails = import_zod446.z.object({
  charging: import_zod446.z.boolean(),
  currencyCode: import_zod446.z.string(),
  currencySymbol: import_zod446.z.string(),
  description: import_zod446.z.string().nullish(),
  displayName: import_zod446.z.string().nullish(),
  price: import_zod446.z.string(),
  region: import_zod446.z.string().nullish(),
  sandbox: import_zod446.z.boolean(),
  title: import_zod446.z.string()
});

// src/generated-definitions/PaymentOrderNotifySimulation.ts
var import_zod447 = require("zod");
var PaymentOrderNotifySimulation = import_zod447.z.object({
  amount: import_zod447.z.number().int().nullish(),
  currencyCode: import_zod447.z.string(),
  notifyType: import_zod447.z.enum(["CHARGE", "REFUND"]),
  paymentProvider: import_zod447.z.enum(["ADYEN", "ALIPAY", "CHECKOUT", "NEONPAY", "PAYPAL", "STRIPE", "WALLET", "WXPAY", "XSOLLA"]),
  salesTax: import_zod447.z.number().int().nullish(),
  vat: import_zod447.z.number().int().nullish()
});

// src/generated-definitions/PaymentOrderPaidResult.ts
var import_zod448 = require("zod");
var PaymentOrderPaidResult = import_zod448.z.object({ charging: import_zod448.z.boolean(), success: import_zod448.z.boolean() });

// src/generated-definitions/PaymentOrderRefund.ts
var import_zod449 = require("zod");
var PaymentOrderRefund = import_zod449.z.object({ description: import_zod449.z.string() });

// src/generated-definitions/PaymentProcessResult.ts
var import_zod450 = require("zod");
var PaymentProcessResult = import_zod450.z.object({
  pending: import_zod450.z.boolean(),
  reason: import_zod450.z.string().nullish(),
  redirectUrl: import_zod450.z.string().nullish(),
  success: import_zod450.z.boolean()
});

// src/generated-definitions/PaymentProviderConfigEdit.ts
var import_zod451 = require("zod");
var PaymentProviderConfigEdit = import_zod451.z.object({
  aggregate: import_zod451.z.enum(["ADYEN", "CHECKOUT", "NEONPAY", "STRIPE", "XSOLLA"]).nullish(),
  namespace: import_zod451.z.string(),
  region: import_zod451.z.string(),
  sandboxTaxJarApiToken: import_zod451.z.string().nullish(),
  specials: import_zod451.z.array(import_zod451.z.enum(["ADYEN", "ALIPAY", "CHECKOUT", "NEONPAY", "PAYPAL", "STRIPE", "WALLET", "WXPAY", "XSOLLA"])).nullish(),
  taxJarApiToken: import_zod451.z.string().nullish(),
  taxJarEnabled: import_zod451.z.boolean().nullish(),
  useGlobalTaxJarApiToken: import_zod451.z.boolean().nullish()
});

// src/generated-definitions/PaymentRequest.ts
var import_zod452 = require("zod");
var PaymentRequest = import_zod452.z.object({
  amount: import_zod452.z.number().int(),
  metadata: import_zod452.z.record(import_zod452.z.any()).nullish(),
  walletPlatform: import_zod452.z.enum(["Epic", "GooglePlay", "IOS", "Nintendo", "Oculus", "Other", "Playstation", "Steam", "Xbox"]).nullish()
});

// src/generated-definitions/PaymentTaxConfigEdit.ts
var import_zod453 = require("zod");
var PaymentTaxConfigEdit = import_zod453.z.object({
  sandboxTaxJarApiToken: import_zod453.z.string().nullish(),
  taxJarApiToken: import_zod453.z.string().nullish(),
  taxJarEnabled: import_zod453.z.boolean().nullish(),
  taxJarProductCodesMapping: import_zod453.z.record(import_zod453.z.string()).nullish()
});

// src/generated-definitions/PaymentToken.ts
var import_zod454 = require("zod");
var PaymentToken = import_zod454.z.object({ token: import_zod454.z.string().nullish() });

// src/generated-definitions/PaymentUrl.ts
var import_zod455 = require("zod");
var PaymentUrl = import_zod455.z.object({
  paymentProvider: import_zod455.z.enum(["ADYEN", "ALIPAY", "CHECKOUT", "NEONPAY", "PAYPAL", "STRIPE", "WALLET", "WXPAY", "XSOLLA"]),
  paymentType: import_zod455.z.enum(["LINK", "QR_CODE"]),
  paymentUrl: import_zod455.z.string().nullish(),
  returnUrl: import_zod455.z.string().nullish(),
  sessionData: import_zod455.z.string().nullish(),
  sessionId: import_zod455.z.string().nullish()
});

// src/generated-definitions/PaymentUrlCreate.ts
var import_zod456 = require("zod");
var PaymentUrlCreate = import_zod456.z.object({
  neonPayConfig: PaymentOrderNeonPayConfig.nullish(),
  paymentOrderNo: import_zod456.z.string(),
  paymentProvider: import_zod456.z.enum(["ADYEN", "ALIPAY", "CHECKOUT", "NEONPAY", "PAYPAL", "STRIPE", "WALLET", "WXPAY", "XSOLLA"]),
  returnUrl: import_zod456.z.string().nullish(),
  ui: import_zod456.z.string().nullish(),
  zipCode: import_zod456.z.string().nullish()
});

// src/generated-definitions/PlatformDlcConfigUpdate.ts
var import_zod457 = require("zod");
var PlatformDlcConfigUpdate = import_zod457.z.object({ data: import_zod457.z.array(PlatformDlcEntry).nullish() });

// src/generated-definitions/PlatformSubscribeRequest.ts
var import_zod458 = require("zod");
var PlatformSubscribeRequest = import_zod458.z.object({
  grantDays: import_zod458.z.number().int(),
  itemId: import_zod458.z.string(),
  language: import_zod458.z.string().nullish(),
  reason: import_zod458.z.string().nullish(),
  region: import_zod458.z.string().nullish(),
  source: import_zod458.z.string().nullish()
});

// src/generated-definitions/PlatformWalletConfigUpdate.ts
var import_zod459 = require("zod");
var PlatformWalletConfigUpdate = import_zod459.z.object({
  allowedBalanceOrigins: import_zod459.z.array(import_zod459.z.enum(["Epic", "GooglePlay", "IOS", "Nintendo", "Oculus", "Other", "Playstation", "Steam", "System", "Twitch", "Xbox"])).nullish()
});

// src/generated-definitions/PlayStationDlcSyncMultiServiceLabelsRequest.ts
var import_zod460 = require("zod");
var PlayStationDlcSyncMultiServiceLabelsRequest = import_zod460.z.object({ serviceLabels: import_zod460.z.array(import_zod460.z.number().int()).nullish() });

// src/generated-definitions/PlayStationDlcSyncRequest.ts
var import_zod461 = require("zod");
var PlayStationDlcSyncRequest = import_zod461.z.object({ serviceLabel: import_zod461.z.number().int().nullish() });

// src/generated-definitions/PlaystationIapConfigRequest.ts
var import_zod462 = require("zod");
var PlaystationIapConfigRequest = import_zod462.z.object({
  backOfficeServerClientId: import_zod462.z.string().nullish(),
  backOfficeServerClientSecret: import_zod462.z.string().nullish(),
  enableStreamJob: import_zod462.z.boolean().nullish(),
  environment: import_zod462.z.string(),
  streamName: import_zod462.z.string().nullish(),
  streamPartnerName: import_zod462.z.string().nullish()
});

// src/generated-definitions/PlayStationMultiServiceLabelsReconcileRequest.ts
var import_zod463 = require("zod");
var PlayStationMultiServiceLabelsReconcileRequest = import_zod463.z.object({
  currencyCode: import_zod463.z.string().nullish(),
  price: import_zod463.z.number().nullish(),
  productId: import_zod463.z.string().nullish(),
  serviceLabels: import_zod463.z.array(import_zod463.z.number().int()).nullish()
});

// src/generated-definitions/PlayStationReconcileRequest.ts
var import_zod464 = require("zod");
var PlayStationReconcileRequest = import_zod464.z.object({
  currencyCode: import_zod464.z.string().nullish(),
  price: import_zod464.z.number().nullish(),
  productId: import_zod464.z.string().nullish(),
  serviceLabel: import_zod464.z.number().int().nullish()
});

// src/generated-definitions/PlayStationReconcileResult.ts
var import_zod465 = require("zod");
var PlayStationReconcileResult = import_zod465.z.object({
  itemId: import_zod465.z.string().nullish(),
  psnItemId: import_zod465.z.string().nullish(),
  sku: import_zod465.z.string().nullish(),
  status: import_zod465.z.enum(["FAILED", "FULFILLED", "VERIFIED"]).nullish(),
  transactionId: import_zod465.z.string().nullish()
});

// src/generated-definitions/PlayStationReconcileResultArray.ts
var import_zod466 = require("zod");
var PlayStationReconcileResultArray = import_zod466.z.array(PlayStationReconcileResult);

// src/generated-definitions/PreCheckFulfillmentRequest.ts
var import_zod467 = require("zod");
var PreCheckFulfillmentRequest = import_zod467.z.object({
  itemId: import_zod467.z.string().nullish(),
  itemSku: import_zod467.z.string().nullish(),
  quantity: import_zod467.z.number().int()
});

// src/generated-definitions/PsnEntitlementOwnershipRequest.ts
var import_zod468 = require("zod");
var PsnEntitlementOwnershipRequest = import_zod468.z.object({ accessToken: import_zod468.z.string().nullish(), serviceLabel: import_zod468.z.number().int().nullish() });

// src/generated-definitions/PublicEntitlementDecrement.ts
var import_zod469 = require("zod");
var PublicEntitlementDecrement = import_zod469.z.object({
  metadata: PublicEntitlementMetadata.nullish(),
  options: import_zod469.z.array(import_zod469.z.string()).nullish(),
  requestId: import_zod469.z.string().nullish(),
  useCount: import_zod469.z.number().int().nullish()
});

// src/generated-definitions/PublicEntitlementHistoryInfo.ts
var import_zod470 = require("zod");
var PublicEntitlementHistoryInfo = import_zod470.z.object({
  action: import_zod470.z.enum(["DECREMENT", "DISABLE", "ENABLE", "GRANT", "REVOKE", "SELL_BACK", "UPDATE"]),
  clazz: import_zod470.z.enum(["APP", "CODE", "ENTITLEMENT", "LOOTBOX", "MEDIA", "OPTIONBOX", "SUBSCRIPTION"]).nullish(),
  createdAt: import_zod470.z.string(),
  entitlementId: import_zod470.z.string(),
  itemId: import_zod470.z.string().nullish(),
  namespace: import_zod470.z.string(),
  origin: import_zod470.z.enum(["Epic", "GooglePlay", "IOS", "Nintendo", "Oculus", "Other", "Playstation", "Steam", "System", "Twitch", "Xbox"]).nullish(),
  reason: import_zod470.z.string().nullish(),
  sku: import_zod470.z.string().nullish(),
  updatedAt: import_zod470.z.string(),
  useCount: import_zod470.z.number().int().nullish(),
  useCountChange: import_zod470.z.number().int().nullish(),
  userId: import_zod470.z.string()
});

// src/generated-definitions/PurchaseConditionUpdate.ts
var import_zod471 = require("zod");
var PurchaseConditionUpdate = import_zod471.z.object({ purchaseCondition: PurchaseCondition.nullish() });

// src/generated-definitions/RedeemRequest.ts
var import_zod472 = require("zod");
var RedeemRequest = import_zod472.z.object({ code: import_zod472.z.string(), orderNo: import_zod472.z.string().nullish() });

// src/generated-definitions/RevocationConfigUpdate.ts
var import_zod473 = require("zod");
var RevocationConfigUpdate = import_zod473.z.object({
  entitlement: EntitlementRevocationConfig.nullish(),
  wallet: WalletRevocationConfig.nullish()
});

// src/generated-definitions/RevocationPluginConfigUpdate.ts
var import_zod474 = require("zod");
var RevocationPluginConfigUpdate = import_zod474.z.object({
  appConfig: AppConfig.nullish(),
  customConfig: BaseCustomConfig.nullish(),
  extendType: import_zod474.z.enum(["APP", "CUSTOM"])
});

// src/generated-definitions/RevocationRequest.ts
var import_zod475 = require("zod");
var RevocationRequest = import_zod475.z.object({
  meta: import_zod475.z.record(import_zod475.z.any()).nullish(),
  reason: import_zod475.z.string().nullish(),
  revokeEntries: import_zod475.z.array(RevokeEntry).nullish(),
  source: import_zod475.z.enum(["DLC", "IAP", "ORDER", "OTHER"]).nullish(),
  transactionId: import_zod475.z.string().nullish()
});

// src/generated-definitions/RevokeUseCountRequest.ts
var import_zod476 = require("zod");
var RevokeUseCountRequest = import_zod476.z.object({ reason: import_zod476.z.string().nullish(), useCount: import_zod476.z.number().int().nullish() });

// src/generated-definitions/RewardCreate.ts
var import_zod477 = require("zod");
var RewardCreate = import_zod477.z.object({
  description: import_zod477.z.string().nullish(),
  eventTopic: import_zod477.z.string(),
  maxAwarded: import_zod477.z.number().int().nullish(),
  maxAwardedPerUser: import_zod477.z.number().int().nullish(),
  namespaceExpression: import_zod477.z.string().nullish(),
  rewardCode: import_zod477.z.string(),
  rewardConditions: import_zod477.z.array(RewardCondition).nullish(),
  userIdExpression: import_zod477.z.string().nullish()
});

// src/generated-definitions/RewardsRequest.ts
var import_zod478 = require("zod");
var RewardsRequest = import_zod478.z.object({
  entitlementCollectionId: import_zod478.z.string().nullish(),
  entitlementOrigin: import_zod478.z.enum(["Epic", "GooglePlay", "IOS", "Nintendo", "Oculus", "Other", "Playstation", "Steam", "System", "Twitch", "Xbox"]).nullish(),
  metadata: import_zod478.z.record(import_zod478.z.any()).nullish(),
  origin: import_zod478.z.enum(["Epic", "GooglePlay", "IOS", "Nintendo", "Oculus", "Other", "Playstation", "Steam", "System", "Twitch", "Xbox"]).nullish(),
  rewards: import_zod478.z.array(PlatformReward),
  source: import_zod478.z.enum([
    "ACHIEVEMENT",
    "CONSUME_ENTITLEMENT",
    "DLC",
    "EXPIRATION",
    "GIFT",
    "IAP",
    "IAP_CHARGEBACK_REVERSED",
    "ORDER_REVOCATION",
    "OTHER",
    "PAYMENT",
    "PROMOTION",
    "PURCHASE",
    "REDEEM_CODE",
    "REFERRAL_BONUS",
    "REWARD",
    "SELL_BACK"
  ]).nullish(),
  transactionId: import_zod478.z.string().nullish()
});

// src/generated-definitions/RewardUpdate.ts
var import_zod479 = require("zod");
var RewardUpdate = import_zod479.z.object({
  description: import_zod479.z.string().nullish(),
  eventTopic: import_zod479.z.string(),
  maxAwarded: import_zod479.z.number().int().nullish(),
  maxAwardedPerUser: import_zod479.z.number().int().nullish(),
  namespaceExpression: import_zod479.z.string().nullish(),
  rewardCode: import_zod479.z.string(),
  rewardConditions: import_zod479.z.array(RewardCondition).nullish(),
  userIdExpression: import_zod479.z.string().nullish()
});

// src/generated-definitions/SectionCreate.ts
var import_zod480 = require("zod");
var SectionCreate = import_zod480.z.object({
  active: import_zod480.z.boolean().nullish(),
  displayOrder: import_zod480.z.number().int().nullish(),
  endDate: import_zod480.z.string(),
  ext: import_zod480.z.record(import_zod480.z.any()).nullish(),
  fixedPeriodRotationConfig: FixedPeriodRotationConfig.nullish(),
  items: import_zod480.z.array(SectionItem).nullish(),
  localizations: import_zod480.z.record(Localization),
  name: import_zod480.z.string(),
  rotationType: import_zod480.z.enum(["CUSTOM", "FIXED_PERIOD", "NONE"]).nullish(),
  startDate: import_zod480.z.string(),
  viewId: import_zod480.z.string().nullish()
});

// src/generated-definitions/SectionInfo.ts
var import_zod481 = require("zod");
var SectionInfo = import_zod481.z.object({
  active: import_zod481.z.boolean(),
  createdAt: import_zod481.z.string(),
  currentRotationExpireAt: import_zod481.z.string().nullish(),
  currentRotationItems: import_zod481.z.array(ItemInfo).nullish(),
  description: import_zod481.z.string().nullish(),
  displayOrder: import_zod481.z.number().int().nullish(),
  endDate: import_zod481.z.string(),
  ext: import_zod481.z.record(import_zod481.z.any()).nullish(),
  localExt: import_zod481.z.record(import_zod481.z.any()).nullish(),
  longDescription: import_zod481.z.string().nullish(),
  name: import_zod481.z.string(),
  namespace: import_zod481.z.string(),
  sectionId: import_zod481.z.string(),
  startDate: import_zod481.z.string(),
  title: import_zod481.z.string(),
  updatedAt: import_zod481.z.string(),
  viewId: import_zod481.z.string()
});

// src/generated-definitions/SectionInfoArray.ts
var import_zod482 = require("zod");
var SectionInfoArray = import_zod482.z.array(SectionInfo);

// src/generated-definitions/SectionPluginConfigUpdate.ts
var import_zod483 = require("zod");
var SectionPluginConfigUpdate = import_zod483.z.object({
  appConfig: AppConfig.nullish(),
  customConfig: BaseCustomConfig.nullish(),
  extendType: import_zod483.z.enum(["APP", "CUSTOM"])
});

// src/generated-definitions/SectionUpdate.ts
var import_zod484 = require("zod");
var SectionUpdate = import_zod484.z.object({
  active: import_zod484.z.boolean().nullish(),
  displayOrder: import_zod484.z.number().int().nullish(),
  endDate: import_zod484.z.string(),
  ext: import_zod484.z.record(import_zod484.z.any()).nullish(),
  fixedPeriodRotationConfig: FixedPeriodRotationConfig.nullish(),
  items: import_zod484.z.array(SectionItem).nullish(),
  localizations: import_zod484.z.record(Localization),
  name: import_zod484.z.string(),
  rotationType: import_zod484.z.enum(["CUSTOM", "FIXED_PERIOD", "NONE"]).nullish(),
  startDate: import_zod484.z.string(),
  viewId: import_zod484.z.string().nullish()
});

// src/generated-definitions/ServicePluginConfigUpdate.ts
var import_zod485 = require("zod");
var ServicePluginConfigUpdate = import_zod485.z.object({ grpcServerAddress: import_zod485.z.string().nullish() });

// src/generated-definitions/SimpleDlcRewardItem.ts
var import_zod486 = require("zod");
var SimpleDlcRewardItem = import_zod486.z.object({ itemName: import_zod486.z.string().nullish() });

// src/generated-definitions/SimpleUserDlcRewardContent.ts
var import_zod487 = require("zod");
var SimpleUserDlcRewardContent = import_zod487.z.object({
  currency: PlatformRewardCurrency.nullish(),
  item: SimpleDlcRewardItem.nullish(),
  obtainedAt: import_zod487.z.string().nullish(),
  quantity: import_zod487.z.number().int().nullish(),
  type: import_zod487.z.enum(["CURRENCY", "ITEM"]).nullish()
});

// src/generated-definitions/SimpleUserDlcRewardContentsResponse.ts
var import_zod488 = require("zod");
var SimpleUserDlcRewardContentsResponse = import_zod488.z.object({ data: import_zod488.z.array(SimpleUserDlcRewardContent).nullish() });

// src/generated-definitions/SteamAchievement.ts
var import_zod489 = require("zod");
var SteamAchievement = import_zod489.z.object({ id: import_zod489.z.string().nullish(), value: import_zod489.z.number().int().nullish() });

// src/generated-definitions/SteamAchievementUpdateRequest.ts
var import_zod490 = require("zod");
var SteamAchievementUpdateRequest = import_zod490.z.object({
  achievements: import_zod490.z.array(SteamAchievement).nullish(),
  steamUserId: import_zod490.z.string().nullish()
});

// src/generated-definitions/SteamDlcSyncRequest.ts
var import_zod491 = require("zod");
var SteamDlcSyncRequest = import_zod491.z.object({ appId: import_zod491.z.string().nullish(), steamId: import_zod491.z.string() });

// src/generated-definitions/SteamIapConfigRequest.ts
var import_zod492 = require("zod");
var SteamIapConfigRequest = import_zod492.z.object({ appId: import_zod492.z.string(), publisherAuthenticationKey: import_zod492.z.string().nullish() });

// src/generated-definitions/SteamSyncRequest.ts
var import_zod493 = require("zod");
var SteamSyncRequest = import_zod493.z.object({
  appId: import_zod493.z.string(),
  currencyCode: import_zod493.z.string().nullish(),
  language: import_zod493.z.string().nullish(),
  price: import_zod493.z.number().nullish(),
  productId: import_zod493.z.string().nullish(),
  region: import_zod493.z.string().nullish(),
  steamId: import_zod493.z.string()
});

// src/generated-definitions/StoreCreate.ts
var import_zod494 = require("zod");
var StoreCreate = import_zod494.z.object({
  defaultLanguage: import_zod494.z.string().nullish(),
  defaultRegion: import_zod494.z.string().nullish(),
  description: import_zod494.z.string().nullish(),
  supportedLanguages: import_zod494.z.array(import_zod494.z.string()).nullish(),
  supportedRegions: import_zod494.z.array(import_zod494.z.string()).nullish(),
  title: import_zod494.z.string()
});

// src/generated-definitions/StoreUpdate.ts
var import_zod495 = require("zod");
var StoreUpdate = import_zod495.z.object({
  defaultLanguage: import_zod495.z.string().nullish(),
  defaultRegion: import_zod495.z.string().nullish(),
  description: import_zod495.z.string().nullish(),
  supportedLanguages: import_zod495.z.array(import_zod495.z.string()).nullish(),
  supportedRegions: import_zod495.z.array(import_zod495.z.string()).nullish(),
  title: import_zod495.z.string()
});

// src/generated-definitions/StreamEvent.ts
var import_zod497 = require("zod");

// src/generated-definitions/StreamEventBody.ts
var import_zod496 = require("zod");
var StreamEventBody = import_zod496.z.object({
  account: import_zod496.z.string().nullish(),
  additionalData: EventAdditionalData.nullish(),
  originalTitleName: import_zod496.z.string().nullish(),
  paymentProductSKU: import_zod496.z.string().nullish(),
  purchaseDate: import_zod496.z.string().nullish(),
  sourceOrderItemId: import_zod496.z.string().nullish(),
  titleName: import_zod496.z.string().nullish()
});

// src/generated-definitions/StreamEvent.ts
var StreamEvent = import_zod497.z.object({
  body: StreamEventBody.nullish(),
  eventDomain: import_zod497.z.string().nullish(),
  eventSource: import_zod497.z.string().nullish(),
  eventType: import_zod497.z.string().nullish(),
  eventVersion: import_zod497.z.number().int().nullish(),
  id: import_zod497.z.string().nullish(),
  timestamp: import_zod497.z.string().nullish()
});

// src/generated-definitions/SubscribeRequest.ts
var import_zod498 = require("zod");
var SubscribeRequest = import_zod498.z.object({
  currencyCode: import_zod498.z.string(),
  itemId: import_zod498.z.string(),
  language: import_zod498.z.string().nullish(),
  region: import_zod498.z.string().nullish(),
  returnUrl: import_zod498.z.string().nullish(),
  source: import_zod498.z.string().nullish()
});

// src/generated-definitions/TaxResult.ts
var import_zod499 = require("zod");
var TaxResult = import_zod499.z.object({
  enableTax: import_zod499.z.boolean().nullish(),
  formattedTax: import_zod499.z.string().nullish(),
  state: import_zod499.z.string().nullish(),
  tax: import_zod499.z.number().int().nullish()
});

// src/generated-definitions/TicketAcquireRequest.ts
var import_zod500 = require("zod");
var TicketAcquireRequest = import_zod500.z.object({ count: import_zod500.z.number().int(), orderNo: import_zod500.z.string() });

// src/generated-definitions/TicketSaleDecrementRequest.ts
var import_zod501 = require("zod");
var TicketSaleDecrementRequest = import_zod501.z.object({ orderNo: import_zod501.z.string() });

// src/generated-definitions/TicketSaleIncrementRequest.ts
var import_zod502 = require("zod");
var TicketSaleIncrementRequest = import_zod502.z.object({ count: import_zod502.z.number().int(), orderNo: import_zod502.z.string() });

// src/generated-definitions/TradeChainedActionCommitRequest.ts
var import_zod503 = require("zod");
var TradeChainedActionCommitRequest = import_zod503.z.object({
  actions: import_zod503.z.array(ActionRequest).nullish(),
  metadata: import_zod503.z.record(import_zod503.z.any()).nullish(),
  needPreCheck: import_zod503.z.boolean().nullish(),
  transactionId: import_zod503.z.string().nullish(),
  type: import_zod503.z.string().nullish()
});

// src/generated-definitions/TradeNotification.ts
var import_zod504 = require("zod");
var TradeNotification = import_zod504.z.object({
  additionalData: AdditionalData.nullish(),
  authorisedTime: import_zod504.z.string().nullish(),
  chargebackReversedTime: import_zod504.z.string().nullish(),
  chargebackTime: import_zod504.z.string().nullish(),
  chargedTime: import_zod504.z.string().nullish(),
  createdTime: import_zod504.z.string().nullish(),
  currency: CurrencySummary,
  customParameters: import_zod504.z.record(import_zod504.z.any()).nullish(),
  extOrderNo: import_zod504.z.string(),
  extTxId: import_zod504.z.string().nullish(),
  extUserId: import_zod504.z.string().nullish(),
  issuedAt: import_zod504.z.string(),
  metadata: import_zod504.z.record(import_zod504.z.string()).nullish(),
  namespace: import_zod504.z.string(),
  nonceStr: import_zod504.z.string(),
  paymentData: PaymentData.nullish(),
  paymentMethod: import_zod504.z.string().nullish(),
  paymentMethodFee: import_zod504.z.number().int().nullish(),
  paymentOrderNo: import_zod504.z.string(),
  paymentProvider: import_zod504.z.enum(["ADYEN", "ALIPAY", "CHECKOUT", "NEONPAY", "PAYPAL", "STRIPE", "WALLET", "WXPAY", "XSOLLA"]),
  paymentProviderFee: import_zod504.z.number().int().nullish(),
  paymentStationUrl: import_zod504.z.string().nullish(),
  price: import_zod504.z.number().int(),
  refundedTime: import_zod504.z.string().nullish(),
  salesTax: import_zod504.z.number().int().nullish(),
  sandbox: import_zod504.z.boolean(),
  sku: import_zod504.z.string().nullish(),
  status: import_zod504.z.enum([
    "AUTHORISED",
    "AUTHORISE_FAILED",
    "CHARGEBACK",
    "CHARGEBACK_REVERSED",
    "CHARGED",
    "CHARGE_FAILED",
    "DELETED",
    "INIT",
    "NOTIFICATION_OF_CHARGEBACK",
    "REFUNDED",
    "REFUNDING",
    "REFUND_FAILED",
    "REQUEST_FOR_INFORMATION"
  ]),
  statusReason: import_zod504.z.string().nullish(),
  subscriptionId: import_zod504.z.string().nullish(),
  subtotalPrice: import_zod504.z.number().int().nullish(),
  targetNamespace: import_zod504.z.string().nullish(),
  targetUserId: import_zod504.z.string().nullish(),
  tax: import_zod504.z.number().int().nullish(),
  totalPrice: import_zod504.z.number().int().nullish(),
  totalTax: import_zod504.z.number().int().nullish(),
  txEndTime: import_zod504.z.string().nullish(),
  type: import_zod504.z.string(),
  userId: import_zod504.z.string().nullish(),
  vat: import_zod504.z.number().int().nullish()
});

// src/generated-definitions/TwitchIapConfigRequest.ts
var import_zod505 = require("zod");
var TwitchIapConfigRequest = import_zod505.z.object({
  clientId: import_zod505.z.string().nullish(),
  clientSecret: import_zod505.z.string().nullish(),
  organizationId: import_zod505.z.string().nullish()
});

// src/generated-definitions/TwitchSyncRequest.ts
var import_zod506 = require("zod");
var TwitchSyncRequest = import_zod506.z.object({ gameId: import_zod506.z.string().nullish(), language: import_zod506.z.string().nullish(), region: import_zod506.z.string().nullish() });

// src/generated-definitions/TwitchSyncResult.ts
var import_zod507 = require("zod");
var TwitchSyncResult = import_zod507.z.object({
  iapOrderStatus: import_zod507.z.enum(["FAILED", "FULFILLED", "VERIFIED"]).nullish(),
  itemSku: import_zod507.z.string().nullish(),
  transactionId: import_zod507.z.string().nullish()
});

// src/generated-definitions/TwitchSyncResultArray.ts
var import_zod508 = require("zod");
var TwitchSyncResultArray = import_zod508.z.array(TwitchSyncResult);

// src/generated-definitions/UserEntitlementHistoryPagingSlicedResult.ts
var import_zod509 = require("zod");
var UserEntitlementHistoryPagingSlicedResult = import_zod509.z.object({ data: import_zod509.z.array(PublicEntitlementHistoryInfo), paging: Paging.nullish() });

// src/generated-definitions/UserEntitlementHistoryPagingSlicedResultArray.ts
var import_zod510 = require("zod");
var UserEntitlementHistoryPagingSlicedResultArray = import_zod510.z.array(UserEntitlementHistoryPagingSlicedResult);

// src/generated-definitions/ValidationErrorEntity.ts
var import_zod511 = require("zod");
var ValidationErrorEntity = import_zod511.z.object({
  errorCode: import_zod511.z.number().int(),
  errorMessage: import_zod511.z.string(),
  errors: import_zod511.z.array(FieldValidationError).nullish()
});

// src/generated-definitions/ViewCreate.ts
var import_zod512 = require("zod");
var ViewCreate = import_zod512.z.object({ displayOrder: import_zod512.z.number().int(), localizations: import_zod512.z.record(Localization), name: import_zod512.z.string() });

// src/generated-definitions/ViewInfo.ts
var import_zod513 = require("zod");
var ViewInfo = import_zod513.z.object({
  createdAt: import_zod513.z.string(),
  description: import_zod513.z.string().nullish(),
  displayOrder: import_zod513.z.number().int(),
  localExt: import_zod513.z.record(import_zod513.z.any()).nullish(),
  longDescription: import_zod513.z.string().nullish(),
  name: import_zod513.z.string(),
  namespace: import_zod513.z.string(),
  title: import_zod513.z.string(),
  updatedAt: import_zod513.z.string(),
  viewId: import_zod513.z.string()
});

// src/generated-definitions/ViewInfoArray.ts
var import_zod514 = require("zod");
var ViewInfoArray = import_zod514.z.array(ViewInfo);

// src/generated-definitions/ViewUpdate.ts
var import_zod515 = require("zod");
var ViewUpdate = import_zod515.z.object({
  displayOrder: import_zod515.z.number().int().nullish(),
  localizations: import_zod515.z.record(Localization).nullish(),
  name: import_zod515.z.string()
});

// src/generated-definitions/WxPayConfigRequest.ts
var import_zod516 = require("zod");
var WxPayConfigRequest = import_zod516.z.object({
  appId: import_zod516.z.string().nullish(),
  key: import_zod516.z.string().nullish(),
  mchid: import_zod516.z.string().nullish(),
  returnUrl: import_zod516.z.string().nullish()
});

// src/generated-definitions/XblAchievementUpdateRequest.ts
var import_zod518 = require("zod");

// src/generated-definitions/XboxAchievement.ts
var import_zod517 = require("zod");
var XboxAchievement = import_zod517.z.object({ id: import_zod517.z.string().nullish(), percentComplete: import_zod517.z.number().int().nullish() });

// src/generated-definitions/XblAchievementUpdateRequest.ts
var XblAchievementUpdateRequest = import_zod518.z.object({
  achievements: import_zod518.z.array(XboxAchievement).nullish(),
  serviceConfigId: import_zod518.z.string().nullish(),
  titleId: import_zod518.z.string().nullish(),
  xboxUserId: import_zod518.z.string().nullish()
});

// src/generated-definitions/XblDlcSyncRequest.ts
var import_zod519 = require("zod");
var XblDlcSyncRequest = import_zod519.z.object({ xstsToken: import_zod519.z.string().nullish() });

// src/generated-definitions/XblEntitlementOwnershipRequest.ts
var import_zod520 = require("zod");
var XblEntitlementOwnershipRequest = import_zod520.z.object({ delegationToken: import_zod520.z.string().nullish(), sandboxId: import_zod520.z.string().nullish() });

// src/generated-definitions/XblIapConfigRequest.ts
var import_zod521 = require("zod");
var XblIapConfigRequest = import_zod521.z.object({ relyingPartyCert: import_zod521.z.string() });

// src/generated-definitions/XblReconcileRequest.ts
var import_zod522 = require("zod");
var XblReconcileRequest = import_zod522.z.object({
  currencyCode: import_zod522.z.string().nullish(),
  price: import_zod522.z.number().nullish(),
  productId: import_zod522.z.string().nullish(),
  xstsToken: import_zod522.z.string().nullish()
});

// src/generated-definitions/XblReconcileResult.ts
var import_zod523 = require("zod");
var XblReconcileResult = import_zod523.z.object({
  iapOrderStatus: import_zod523.z.enum(["FAILED", "FULFILLED", "VERIFIED"]).nullish(),
  itemId: import_zod523.z.string().nullish(),
  sku: import_zod523.z.string().nullish(),
  transactionId: import_zod523.z.string().nullish(),
  xboxProductId: import_zod523.z.string().nullish()
});

// src/generated-definitions/XblReconcileResultArray.ts
var import_zod524 = require("zod");
var XblReconcileResultArray = import_zod524.z.array(XblReconcileResult);

// src/generated-definitions/XblUserSessionRequest.ts
var import_zod525 = require("zod");
var XblUserSessionRequest = import_zod525.z.object({
  gameSessionId: import_zod525.z.string(),
  payload: import_zod525.z.record(import_zod525.z.any()),
  scid: import_zod525.z.string(),
  sessionTemplateName: import_zod525.z.string()
});

// src/generated-definitions/XsollaPaywallConfigRequest.ts
var import_zod526 = require("zod");
var XsollaPaywallConfigRequest = import_zod526.z.object({
  device: import_zod526.z.enum(["DESKTOP", "MOBILE"]).nullish(),
  showCloseButton: import_zod526.z.boolean().nullish(),
  size: import_zod526.z.enum(["LARGE", "MEDIUM", "SMALL"]).nullish(),
  theme: import_zod526.z.enum(["DARK", "DEFAULT", "DEFAULT_DARK"]).nullish()
});

// src/generated-public/CategoryApi.ts
var import_sdk74 = require("@accelbyte/sdk");

// src/generated-public/endpoints/Category$.ts
var import_sdk73 = require("@accelbyte/sdk");
var Category$ = class {
  // @ts-ignore
  // prettier-ignore
  constructor(axiosInstance, namespace, useSchemaValidation = true) {
    this.axiosInstance = axiosInstance;
    this.namespace = namespace;
    this.useSchemaValidation = useSchemaValidation;
  }
  /**
   * This API is used to get root categories.&lt;p&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Optional permission&lt;/i&gt;: resource=&#34;PREVIEW&#34;, action=1(CREATE) (user with this permission can view draft store category)&lt;/li&gt;&lt;li&gt;&lt;i&gt;Optional permission&lt;/i&gt;: resource=&#34;SANDBOX&#34;, action=1(CREATE) (user with this permission can view draft store category)&lt;/li&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: root category data&lt;/li&gt;&lt;/ul&gt;
   */
  getCategories(queryParams) {
    const params = { ...queryParams };
    const url = "/platform/public/namespaces/{namespace}/categories".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.get(url, { params });
    return import_sdk73.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, CategoryInfoArray, "CategoryInfoArray");
  }
  /**
   * This API is used to download store&#39;s structured categories.&lt;p&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Optional permission&lt;/i&gt;: resource=&#34;PREVIEW&#34;, action=1(CREATE) (user with this permission can view draft store content)&lt;/li&gt;&lt;li&gt;&lt;i&gt;Optional permission&lt;/i&gt;: resource=&#34;SANDBOX&#34;, action=1(CREATE) (user with this permission can view draft store content)&lt;/li&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: structured categories&lt;/li&gt;&lt;/ul&gt;
   */
  getCategoriesDownload(queryParams) {
    const params = { ...queryParams };
    const url = "/platform/public/namespaces/{namespace}/categories/download".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.get(url, { params });
    return import_sdk73.Validate.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      HierarchicalCategoryInfoArray,
      "HierarchicalCategoryInfoArray"
    );
  }
  /**
   * This API is used to get category by category path.&lt;p&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Optional permission&lt;/i&gt;: resource=&#34;PREVIEW&#34;, action=1(CREATE) (user with this permission can view draft store category)&lt;/li&gt;&lt;li&gt;&lt;i&gt;Optional permission&lt;/i&gt;: resource=&#34;SANDBOX&#34;, action=1 (CREATE)(user with this permission can view draft store category)&lt;/li&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: category data&lt;/li&gt;&lt;/ul&gt;
   */
  getCategory_ByCategoryPath(categoryPath, queryParams) {
    const params = { ...queryParams };
    const url = "/platform/public/namespaces/{namespace}/categories/{categoryPath}".replace("{namespace}", this.namespace).replace("{categoryPath}", categoryPath);
    const resultPromise = this.axiosInstance.get(url, { params });
    return import_sdk73.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, CategoryInfo, "CategoryInfo");
  }
  /**
   * This API is used to get child categories by category path.&lt;p&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Optional permission&lt;/i&gt;: resource=&#34;PREVIEW&#34;, action=1(CREATE) (user with this permission can view draft store category)&lt;/li&gt;&lt;li&gt;&lt;i&gt;Optional permission&lt;/i&gt;: resource=&#34;SANDBOX&#34;, action=1(CREATE) (user with this permission can view draft store category)&lt;/li&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: list of child categories data&lt;/li&gt;&lt;/ul&gt;
   */
  getChildren_ByCategoryPath(categoryPath, queryParams) {
    const params = { ...queryParams };
    const url = "/platform/public/namespaces/{namespace}/categories/{categoryPath}/children".replace("{namespace}", this.namespace).replace("{categoryPath}", categoryPath);
    const resultPromise = this.axiosInstance.get(url, { params });
    return import_sdk73.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, CategoryInfoArray, "CategoryInfoArray");
  }
  /**
   * This API is used to get descendant categories by category path.&lt;p&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Optional permission&lt;/i&gt;: resource=&#34;PREVIEW&#34;, action=1(CREATE) (user with this permission can view draft store category)&lt;/li&gt;&lt;li&gt;&lt;i&gt;Optional permission&lt;/i&gt;: resource=&#34;SANDBOX&#34;, action=1(CREATE) (user with this permission can view draft store category)&lt;/li&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: list of descendant categories data&lt;/li&gt;&lt;/ul&gt;
   */
  getDescendants_ByCategoryPath(categoryPath, queryParams) {
    const params = { ...queryParams };
    const url = "/platform/public/namespaces/{namespace}/categories/{categoryPath}/descendants".replace("{namespace}", this.namespace).replace("{categoryPath}", categoryPath);
    const resultPromise = this.axiosInstance.get(url, { params });
    return import_sdk73.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, CategoryInfoArray, "CategoryInfoArray");
  }
};

// src/generated-public/CategoryApi.ts
function CategoryApi(sdk, args) {
  const sdkAssembly = sdk.assembly();
  const namespace = args?.coreConfig?.namespace ?? sdkAssembly.coreConfig.namespace;
  const useSchemaValidation = args?.coreConfig?.useSchemaValidation ?? sdkAssembly.coreConfig.useSchemaValidation;
  let axiosInstance = sdkAssembly.axiosInstance;
  const requestConfigOverrides = args?.axiosConfig?.request;
  const baseURLOverride = args?.coreConfig?.baseURL;
  const interceptorsOverride = args?.axiosConfig?.interceptors ?? [];
  if (requestConfigOverrides || baseURLOverride || interceptorsOverride.length > 0) {
    const requestConfig = import_sdk74.ApiUtils.mergeAxiosConfigs(sdkAssembly.axiosInstance.defaults, {
      ...baseURLOverride ? { baseURL: baseURLOverride } : {},
      ...requestConfigOverrides
    });
    axiosInstance = import_sdk74.Network.create(requestConfig);
    for (const interceptor of interceptorsOverride) {
      if (interceptor.type === "request") {
        axiosInstance.interceptors.request.use(interceptor.onRequest, interceptor.onError);
      }
      if (interceptor.type === "response") {
        axiosInstance.interceptors.response.use(interceptor.onSuccess, interceptor.onError);
      }
    }
  }
  async function getCategories(queryParams) {
    const $ = new Category$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getCategories(queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getCategoriesDownload(queryParams) {
    const $ = new Category$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getCategoriesDownload(queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getCategory_ByCategoryPath(categoryPath, queryParams) {
    const $ = new Category$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getCategory_ByCategoryPath(categoryPath, queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getChildren_ByCategoryPath(categoryPath, queryParams) {
    const $ = new Category$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getChildren_ByCategoryPath(categoryPath, queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getDescendants_ByCategoryPath(categoryPath, queryParams) {
    const $ = new Category$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getDescendants_ByCategoryPath(categoryPath, queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  return {
    /**
     * This API is used to get root categories.&lt;p&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Optional permission&lt;/i&gt;: resource=&#34;PREVIEW&#34;, action=1(CREATE) (user with this permission can view draft store category)&lt;/li&gt;&lt;li&gt;&lt;i&gt;Optional permission&lt;/i&gt;: resource=&#34;SANDBOX&#34;, action=1(CREATE) (user with this permission can view draft store category)&lt;/li&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: root category data&lt;/li&gt;&lt;/ul&gt;
     */
    getCategories,
    /**
     * This API is used to download store&#39;s structured categories.&lt;p&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Optional permission&lt;/i&gt;: resource=&#34;PREVIEW&#34;, action=1(CREATE) (user with this permission can view draft store content)&lt;/li&gt;&lt;li&gt;&lt;i&gt;Optional permission&lt;/i&gt;: resource=&#34;SANDBOX&#34;, action=1(CREATE) (user with this permission can view draft store content)&lt;/li&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: structured categories&lt;/li&gt;&lt;/ul&gt;
     */
    getCategoriesDownload,
    /**
     * This API is used to get category by category path.&lt;p&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Optional permission&lt;/i&gt;: resource=&#34;PREVIEW&#34;, action=1(CREATE) (user with this permission can view draft store category)&lt;/li&gt;&lt;li&gt;&lt;i&gt;Optional permission&lt;/i&gt;: resource=&#34;SANDBOX&#34;, action=1 (CREATE)(user with this permission can view draft store category)&lt;/li&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: category data&lt;/li&gt;&lt;/ul&gt;
     */
    getCategory_ByCategoryPath,
    /**
     * This API is used to get child categories by category path.&lt;p&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Optional permission&lt;/i&gt;: resource=&#34;PREVIEW&#34;, action=1(CREATE) (user with this permission can view draft store category)&lt;/li&gt;&lt;li&gt;&lt;i&gt;Optional permission&lt;/i&gt;: resource=&#34;SANDBOX&#34;, action=1(CREATE) (user with this permission can view draft store category)&lt;/li&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: list of child categories data&lt;/li&gt;&lt;/ul&gt;
     */
    getChildren_ByCategoryPath,
    /**
     * This API is used to get descendant categories by category path.&lt;p&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Optional permission&lt;/i&gt;: resource=&#34;PREVIEW&#34;, action=1(CREATE) (user with this permission can view draft store category)&lt;/li&gt;&lt;li&gt;&lt;i&gt;Optional permission&lt;/i&gt;: resource=&#34;SANDBOX&#34;, action=1(CREATE) (user with this permission can view draft store category)&lt;/li&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: list of descendant categories data&lt;/li&gt;&lt;/ul&gt;
     */
    getDescendants_ByCategoryPath
  };
}

// src/generated-public/CurrencyApi.ts
var import_sdk76 = require("@accelbyte/sdk");

// src/generated-public/endpoints/Currency$.ts
var import_sdk75 = require("@accelbyte/sdk");
var Currency$ = class {
  // @ts-ignore
  // prettier-ignore
  constructor(axiosInstance, namespace, useSchemaValidation = true) {
    this.axiosInstance = axiosInstance;
    this.namespace = namespace;
    this.useSchemaValidation = useSchemaValidation;
  }
  /**
   * List currencies of a namespace.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: Currency List&lt;/li&gt;&lt;/ul&gt;
   */
  getCurrencies(queryParams) {
    const params = { ...queryParams };
    const url = "/platform/public/namespaces/{namespace}/currencies".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.get(url, { params });
    return import_sdk75.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, CurrencyInfoArray, "CurrencyInfoArray");
  }
};

// src/generated-public/CurrencyApi.ts
function CurrencyApi(sdk, args) {
  const sdkAssembly = sdk.assembly();
  const namespace = args?.coreConfig?.namespace ?? sdkAssembly.coreConfig.namespace;
  const useSchemaValidation = args?.coreConfig?.useSchemaValidation ?? sdkAssembly.coreConfig.useSchemaValidation;
  let axiosInstance = sdkAssembly.axiosInstance;
  const requestConfigOverrides = args?.axiosConfig?.request;
  const baseURLOverride = args?.coreConfig?.baseURL;
  const interceptorsOverride = args?.axiosConfig?.interceptors ?? [];
  if (requestConfigOverrides || baseURLOverride || interceptorsOverride.length > 0) {
    const requestConfig = import_sdk76.ApiUtils.mergeAxiosConfigs(sdkAssembly.axiosInstance.defaults, {
      ...baseURLOverride ? { baseURL: baseURLOverride } : {},
      ...requestConfigOverrides
    });
    axiosInstance = import_sdk76.Network.create(requestConfig);
    for (const interceptor of interceptorsOverride) {
      if (interceptor.type === "request") {
        axiosInstance.interceptors.request.use(interceptor.onRequest, interceptor.onError);
      }
      if (interceptor.type === "response") {
        axiosInstance.interceptors.response.use(interceptor.onSuccess, interceptor.onError);
      }
    }
  }
  async function getCurrencies(queryParams) {
    const $ = new Currency$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getCurrencies(queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  return {
    /**
     * List currencies of a namespace.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: Currency List&lt;/li&gt;&lt;/ul&gt;
     */
    getCurrencies
  };
}

// src/generated-public/DlcApi.ts
var import_sdk78 = require("@accelbyte/sdk");

// src/generated-public/endpoints/Dlc$.ts
var import_sdk77 = require("@accelbyte/sdk");
var import_zod527 = require("zod");
var Dlc$ = class {
  // @ts-ignore
  // prettier-ignore
  constructor(axiosInstance, namespace, useSchemaValidation = true) {
    this.axiosInstance = axiosInstance;
    this.namespace = namespace;
    this.useSchemaValidation = useSchemaValidation;
  }
  /**
   * Get user dlc reward contents. If includeAllNamespaces is false, will only return the dlc synced from the current namespace&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: user dlc&lt;/li&gt;&lt;/ul&gt;
   */
  getUsersMeDlcContent(queryParams) {
    const params = { ...queryParams };
    const url = "/platform/public/users/me/dlc/content";
    const resultPromise = this.axiosInstance.get(url, { params });
    return import_sdk77.Validate.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      SimpleUserDlcRewardContentsResponse,
      "SimpleUserDlcRewardContentsResponse"
    );
  }
  /**
   * Get dlc reward simple map, only return the sku of durable item reward.
   */
  getDlcRewardsDurableMap(queryParams) {
    const params = { ...queryParams };
    const url = "/platform/public/namespaces/{namespace}/dlc/rewards/durable/map".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.get(url, { params });
    return import_sdk77.Validate.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      DlcConfigRewardShortInfo,
      "DlcConfigRewardShortInfo"
    );
  }
  /**
   * Synchronize with dlc entitlements in PSN Store.Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: result of synchronization&lt;/li&gt;&lt;/ul&gt;
   */
  updateDlcPsnSync_ByUserId(userId, data) {
    const params = {};
    const url = "/platform/public/namespaces/{namespace}/users/{userId}/dlc/psn/sync".replace("{namespace}", this.namespace).replace("{userId}", userId);
    const resultPromise = this.axiosInstance.put(url, data, { params });
    return import_sdk77.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, import_zod527.z.unknown(), "z.unknown()");
  }
  /**
   * Sync Xbox inventory&#39;s dlc items
   */
  updateDlcXblSync_ByUserId(userId, data) {
    const params = {};
    const url = "/platform/public/namespaces/{namespace}/users/{userId}/dlc/xbl/sync".replace("{namespace}", this.namespace).replace("{userId}", userId);
    const resultPromise = this.axiosInstance.put(url, data, { params });
    return import_sdk77.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, import_zod527.z.unknown(), "z.unknown()");
  }
  /**
   * Sync steam dlc
   */
  updateDlcSteamSync_ByUserId(userId, data) {
    const params = {};
    const url = "/platform/public/namespaces/{namespace}/users/{userId}/dlc/steam/sync".replace("{namespace}", this.namespace).replace("{userId}", userId);
    const resultPromise = this.axiosInstance.put(url, data, { params });
    return import_sdk77.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, import_zod527.z.unknown(), "z.unknown()");
  }
  /**
   * Sync oculus dlc
   */
  updateDlcOculuSync_ByUserId(userId) {
    const params = {};
    const url = "/platform/public/namespaces/{namespace}/users/{userId}/dlc/oculus/sync".replace("{namespace}", this.namespace).replace("{userId}", userId);
    const resultPromise = this.axiosInstance.put(url, null, { params });
    return import_sdk77.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, import_zod527.z.unknown(), "z.unknown()");
  }
  /**
   * Sync epic games dlc items
   */
  updateDlcEpicgameSync_ByUserId(userId, data) {
    const params = {};
    const url = "/platform/public/namespaces/{namespace}/users/{userId}/dlc/epicgames/sync".replace("{namespace}", this.namespace).replace("{userId}", userId);
    const resultPromise = this.axiosInstance.put(url, data, { params });
    return import_sdk77.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, import_zod527.z.unknown(), "z.unknown()");
  }
  /**
   * Synchronize with dlc entitlements in PSN Store with multiple service labels.Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: result of synchronization&lt;/li&gt;&lt;/ul&gt;
   */
  updateDlcPsnSyncMultiServiceLabel_ByUserId(userId, data) {
    const params = {};
    const url = "/platform/public/namespaces/{namespace}/users/{userId}/dlc/psn/sync/multiServiceLabels".replace("{namespace}", this.namespace).replace("{userId}", userId);
    const resultPromise = this.axiosInstance.put(url, data, { params });
    return import_sdk77.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, import_zod527.z.unknown(), "z.unknown()");
  }
};

// src/generated-public/DlcApi.ts
function DlcApi(sdk, args) {
  const sdkAssembly = sdk.assembly();
  const namespace = args?.coreConfig?.namespace ?? sdkAssembly.coreConfig.namespace;
  const useSchemaValidation = args?.coreConfig?.useSchemaValidation ?? sdkAssembly.coreConfig.useSchemaValidation;
  let axiosInstance = sdkAssembly.axiosInstance;
  const requestConfigOverrides = args?.axiosConfig?.request;
  const baseURLOverride = args?.coreConfig?.baseURL;
  const interceptorsOverride = args?.axiosConfig?.interceptors ?? [];
  if (requestConfigOverrides || baseURLOverride || interceptorsOverride.length > 0) {
    const requestConfig = import_sdk78.ApiUtils.mergeAxiosConfigs(sdkAssembly.axiosInstance.defaults, {
      ...baseURLOverride ? { baseURL: baseURLOverride } : {},
      ...requestConfigOverrides
    });
    axiosInstance = import_sdk78.Network.create(requestConfig);
    for (const interceptor of interceptorsOverride) {
      if (interceptor.type === "request") {
        axiosInstance.interceptors.request.use(interceptor.onRequest, interceptor.onError);
      }
      if (interceptor.type === "response") {
        axiosInstance.interceptors.response.use(interceptor.onSuccess, interceptor.onError);
      }
    }
  }
  async function getUsersMeDlcContent(queryParams) {
    const $ = new Dlc$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getUsersMeDlcContent(queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getDlcRewardsDurableMap(queryParams) {
    const $ = new Dlc$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getDlcRewardsDurableMap(queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function updateDlcPsnSync_ByUserId(userId, data) {
    const $ = new Dlc$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.updateDlcPsnSync_ByUserId(userId, data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function updateDlcXblSync_ByUserId(userId, data) {
    const $ = new Dlc$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.updateDlcXblSync_ByUserId(userId, data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function updateDlcSteamSync_ByUserId(userId, data) {
    const $ = new Dlc$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.updateDlcSteamSync_ByUserId(userId, data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function updateDlcOculuSync_ByUserId(userId) {
    const $ = new Dlc$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.updateDlcOculuSync_ByUserId(userId);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function updateDlcEpicgameSync_ByUserId(userId, data) {
    const $ = new Dlc$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.updateDlcEpicgameSync_ByUserId(userId, data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function updateDlcPsnSyncMultiServiceLabel_ByUserId(userId, data) {
    const $ = new Dlc$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.updateDlcPsnSyncMultiServiceLabel_ByUserId(userId, data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  return {
    /**
     * Get user dlc reward contents. If includeAllNamespaces is false, will only return the dlc synced from the current namespace&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: user dlc&lt;/li&gt;&lt;/ul&gt;
     */
    getUsersMeDlcContent,
    /**
     * Get dlc reward simple map, only return the sku of durable item reward.
     */
    getDlcRewardsDurableMap,
    /**
     * Synchronize with dlc entitlements in PSN Store.Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: result of synchronization&lt;/li&gt;&lt;/ul&gt;
     */
    updateDlcPsnSync_ByUserId,
    /**
     * Sync Xbox inventory&#39;s dlc items
     */
    updateDlcXblSync_ByUserId,
    /**
     * Sync steam dlc
     */
    updateDlcSteamSync_ByUserId,
    /**
     * Sync oculus dlc
     */
    updateDlcOculuSync_ByUserId,
    /**
     * Sync epic games dlc items
     */
    updateDlcEpicgameSync_ByUserId,
    /**
     * Synchronize with dlc entitlements in PSN Store with multiple service labels.Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: result of synchronization&lt;/li&gt;&lt;/ul&gt;
     */
    updateDlcPsnSyncMultiServiceLabel_ByUserId
  };
}

// src/generated-public/endpoints/Entitlement$.ts
var import_sdk79 = require("@accelbyte/sdk");
var Entitlement$ = class {
  // @ts-ignore
  // prettier-ignore
  constructor(axiosInstance, namespace, useSchemaValidation = true) {
    this.axiosInstance = axiosInstance;
    this.namespace = namespace;
    this.useSchemaValidation = useSchemaValidation;
  }
  /**
   * Query user entitlements for a specific user.&lt;p&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: entitlement list&lt;/li&gt;&lt;/ul&gt;
   */
  getEntitlements_ByUserId(userId, queryParams) {
    const params = { limit: 20, ...queryParams };
    const url = "/platform/public/namespaces/{namespace}/users/{userId}/entitlements".replace("{namespace}", this.namespace).replace("{userId}", userId);
    const resultPromise = this.axiosInstance.get(url, { params });
    return import_sdk79.Validate.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      EntitlementPagingSlicedResult,
      "EntitlementPagingSlicedResult"
    );
  }
  /**
   * Get user entitlements by ids..&lt;p&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: entitlement list&lt;/li&gt;&lt;/ul&gt;
   */
  getEntitlementsByIds_ByUserId(userId, queryParams) {
    const params = { availablePlatformOnly: true, ...queryParams };
    const url = "/platform/public/namespaces/{namespace}/users/{userId}/entitlements/byIds".replace("{namespace}", this.namespace).replace("{userId}", userId);
    const resultPromise = this.axiosInstance.get(url, { params });
    return import_sdk79.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, EntitlementInfoArray, "EntitlementInfoArray");
  }
  /**
   * @deprecated
   * Get user entitlement by sku.
   */
  getEntitlementsBySku_ByUserId(userId, queryParams) {
    const params = { ...queryParams };
    const url = "/platform/public/namespaces/{namespace}/users/{userId}/entitlements/bySku".replace("{namespace}", this.namespace).replace("{userId}", userId);
    const resultPromise = this.axiosInstance.get(url, { params });
    return import_sdk79.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, EntitlementInfo, "EntitlementInfo");
  }
  /**
   * Get user app entitlement by appId.
   */
  getEntitlementsByAppId_ByUserId(userId, queryParams) {
    const params = { ...queryParams };
    const url = "/platform/public/namespaces/{namespace}/users/{userId}/entitlements/byAppId".replace("{namespace}", this.namespace).replace("{userId}", userId);
    const resultPromise = this.axiosInstance.get(url, { params });
    return import_sdk79.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, AppEntitlementInfo, "AppEntitlementInfo");
  }
  /**
   * Get user entitlement history&lt;p&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: user entitlement history list&lt;/li&gt;&lt;/ul&gt;
   */
  getEntitlementsHistory_ByUserId(userId, queryParams) {
    const params = { limit: 20, ...queryParams };
    const url = "/platform/public/namespaces/{namespace}/users/{userId}/entitlements/history".replace("{namespace}", this.namespace).replace("{userId}", userId);
    const resultPromise = this.axiosInstance.get(url, { params });
    return import_sdk79.Validate.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      UserEntitlementHistoryPagingSlicedResultArray,
      "UserEntitlementHistoryPagingSlicedResultArray"
    );
  }
  /**
   * Exists any my active entitlement of specified itemIds, skus and appIds
   */
  getUsersMeEntitlementsOwnershipAny(queryParams) {
    const params = { ...queryParams };
    const url = "/platform/public/namespaces/{namespace}/users/me/entitlements/ownership/any".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.get(url, { params });
    return import_sdk79.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, Ownership, "Ownership");
  }
  /**
   * @deprecated
   * Get user entitlement by itemId.
   */
  getEntitlementsByItemId_ByUserId(userId, queryParams) {
    const params = { ...queryParams };
    const url = "/platform/public/namespaces/{namespace}/users/{userId}/entitlements/byItemId".replace("{namespace}", this.namespace).replace("{userId}", userId);
    const resultPromise = this.axiosInstance.get(url, { params });
    return import_sdk79.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, EntitlementInfo, "EntitlementInfo");
  }
  /**
   * Gets an entitlement ownership token of specified itemIds, skus and appIds&lt;p&gt;The decoded ownership token header like below:&lt;p&gt;&lt;pre&gt;&lt;code&gt;{ &#34;kid&#34;: &#34;9fd4cd5f991cebe3323605cd12d3b8bfdfc73fa4&#34;, &#34;typ&#34;: &#34;JWT&#34;, &#34;alg&#34;: &#34;RS256&#34; } &lt;/code&gt;&lt;/pre&gt;That you can get the jwks by api &lt;baseUrl&gt;/platform/jwks, if the configured private key is same as IAM, &lt;p&gt;you can also get jwks from IAM endpoint. &lt;p&gt;The decoded ownership token payload like below:&lt;p&gt;&lt;pre&gt;&lt;code&gt;{ &#34;namespace&#34;: &#34;accelbyte&#34;, &#34;entitlements&#34;: [ { &#34;itemId&#34;: &#34;4c1296291f604c199f7bb7f0ee02e5f8&#34;, &#34;appType&#34;: null, &#34;appId&#34;: null, &#34;namespace&#34;: &#34;accelbyte&#34;, &#34;itemNamespace&#34;: &#34;accelbyte&#34;, &#34;sku&#34;: &#34;prime-plus&#34; }, { &#34;itemId&#34;: &#34;e8f4974cf45c4e1f8d4f0c6990c518bd&#34;, &#34;appType&#34;: &#34;GAME&#34;, &#34;appId&#34;: &#34;omeganebula&#34;, &#34;namespace&#34;: &#34;accelbyte&#34;, &#34;itemNamespace&#34;: &#34;accelbyte&#34;, &#34;sku&#34;: &#34;APPG005ON&#34; } ], &#34;sub&#34;: &#34;66459eb6a4e44e6fb0040bd20c1079a5&#34;, &#34;exp&#34;: 1619624360, &#34;iat&#34;: 1619624060 } &lt;/code&gt;&lt;/pre&gt;&lt;b&gt;if there&#39;s no active entitlement for the specific params, the entitlements section will be omitted&lt;/b&gt;.
   */
  getUsersMeEntitlementsOwnershipToken(queryParams) {
    const params = { ...queryParams };
    const url = "/platform/public/namespaces/{namespace}/users/me/entitlements/ownershipToken".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.get(url, { params });
    return import_sdk79.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, OwnershipToken, "OwnershipToken");
  }
  /**
   * Query app entitlements by appType.&lt;p&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: app entitlement pagination&lt;/li&gt;&lt;/ul&gt;
   */
  getEntitlementsByAppType_ByUserId(userId, queryParams) {
    const params = { limit: 20, ...queryParams };
    const url = "/platform/public/namespaces/{namespace}/users/{userId}/entitlements/byAppType".replace("{namespace}", this.namespace).replace("{userId}", userId);
    const resultPromise = this.axiosInstance.get(url, { params });
    return import_sdk79.Validate.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      AppEntitlementPagingSlicedResult,
      "AppEntitlementPagingSlicedResult"
    );
  }
  /**
   * Get my entitlement ownership by sku.&lt;p&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Path&#39;s namespace&lt;/i&gt; : &lt;ul&gt;&lt;li&gt;can be filled with &lt;b&gt;publisher namespace&lt;/b&gt; in order to get &lt;b&gt;publisher namespace entitlement ownership by sku&lt;/b&gt;&lt;/li&gt;&lt;li&gt;can be filled with &lt;b&gt;game namespace&lt;/b&gt; in order to get &lt;b&gt;game namespace entitlement ownership by sku&lt;/b&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;/ul&gt;
   */
  getUsersMeEntitlementsOwnershipBySku(queryParams) {
    const params = { ...queryParams };
    const url = "/platform/public/namespaces/{namespace}/users/me/entitlements/ownership/bySku".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.get(url, { params });
    return import_sdk79.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, TimedOwnership, "TimedOwnership");
  }
  /**
   * Get my app entitlement ownership by appId.&lt;p&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Path&#39;s namespace&lt;/i&gt; : &lt;ul&gt;&lt;li&gt;can be filled with &lt;b&gt;publisher namespace&lt;/b&gt; in order to get &lt;b&gt;publisher namespace app entitlement ownership&lt;/b&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;/ul&gt;
   */
  getUsersMeEntitlementsOwnershipByAppId(queryParams) {
    const params = { ...queryParams };
    const url = "/platform/public/namespaces/{namespace}/users/me/entitlements/ownership/byAppId".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.get(url, { params });
    return import_sdk79.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, Ownership, "Ownership");
  }
  /**
   * Get my entitlement ownership by itemId.&lt;p&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Path&#39;s namespace&lt;/i&gt; : &lt;ul&gt;&lt;li&gt;can be filled with &lt;b&gt;publisher namespace&lt;/b&gt; in order to get &lt;b&gt;publisher namespace entitlement ownership by sku&lt;/b&gt;&lt;/li&gt;&lt;li&gt;can be filled with &lt;b&gt;game namespace&lt;/b&gt; in order to get &lt;b&gt;game namespace entitlement ownership by sku&lt;/b&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;/ul&gt;
   */
  getUsersMeEntitlementsOwnershipByItemId(queryParams) {
    const params = { ...queryParams };
    const url = "/platform/public/namespaces/{namespace}/users/me/entitlements/ownership/byItemId".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.get(url, { params });
    return import_sdk79.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, TimedOwnership, "TimedOwnership");
  }
  /**
   * Exists any user active entitlement of specified itemIds, skus and appIds
   */
  getEntitlementsOwnershipAny_ByUserId(userId, queryParams) {
    const params = { ...queryParams };
    const url = "/platform/public/namespaces/{namespace}/users/{userId}/entitlements/ownership/any".replace("{namespace}", this.namespace).replace("{userId}", userId);
    const resultPromise = this.axiosInstance.get(url, { params });
    return import_sdk79.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, Ownership, "Ownership");
  }
  /**
   * Get user entitlement.&lt;p&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: entitlement&lt;/li&gt;&lt;/ul&gt;
   */
  getEntitlement_ByUserId_ByEntitlementId(userId, entitlementId) {
    const params = {};
    const url = "/platform/public/namespaces/{namespace}/users/{userId}/entitlements/{entitlementId}".replace("{namespace}", this.namespace).replace("{userId}", userId).replace("{entitlementId}", entitlementId);
    const resultPromise = this.axiosInstance.get(url, { params });
    return import_sdk79.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, EntitlementInfo, "EntitlementInfo");
  }
  /**
   * Get user entitlement ownership by sku.
   */
  getEntitlementsOwnershipBySku_ByUserId(userId, queryParams) {
    const params = { ...queryParams };
    const url = "/platform/public/namespaces/{namespace}/users/{userId}/entitlements/ownership/bySku".replace("{namespace}", this.namespace).replace("{userId}", userId);
    const resultPromise = this.axiosInstance.get(url, { params });
    return import_sdk79.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, TimedOwnership, "TimedOwnership");
  }
  /**
   * Get user app entitlement ownership by appId.
   */
  getEntitlementsOwnershipByAppId_ByUserId(userId, queryParams) {
    const params = { ...queryParams };
    const url = "/platform/public/namespaces/{namespace}/users/{userId}/entitlements/ownership/byAppId".replace("{namespace}", this.namespace).replace("{userId}", userId);
    const resultPromise = this.axiosInstance.get(url, { params });
    return import_sdk79.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, Ownership, "Ownership");
  }
  /**
   * Get user entitlement ownership by itemId.
   */
  getEntitlementsOwnershipByItemId_ByUserId(userId, queryParams) {
    const params = { ...queryParams };
    const url = "/platform/public/namespaces/{namespace}/users/{userId}/entitlements/ownership/byItemId".replace("{namespace}", this.namespace).replace("{userId}", userId);
    const resultPromise = this.axiosInstance.get(url, { params });
    return import_sdk79.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, TimedOwnership, "TimedOwnership");
  }
  /**
   * Get user entitlement ownership by itemIds.
   */
  getEntitlementsOwnershipByItemIds_ByUserId(userId, queryParams) {
    const params = { ...queryParams };
    const url = "/platform/public/namespaces/{namespace}/users/{userId}/entitlements/ownership/byItemIds".replace("{namespace}", this.namespace).replace("{userId}", userId);
    const resultPromise = this.axiosInstance.get(url, { params });
    return import_sdk79.Validate.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      EntitlementOwnershipArray,
      "EntitlementOwnershipArray"
    );
  }
  /**
   * Sell user entitlement. If the entitlement is consumable, useCount is 0, the status will be CONSUMED. If the entitlement is durable, the status will be SOLD. Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: entitlement&lt;/li&gt;&lt;/ul&gt;
   */
  updateSell_ByUserId_ByEntitlementId(userId, entitlementId, data) {
    const params = {};
    const url = "/platform/public/namespaces/{namespace}/users/{userId}/entitlements/{entitlementId}/sell".replace("{namespace}", this.namespace).replace("{userId}", userId).replace("{entitlementId}", entitlementId);
    const resultPromise = this.axiosInstance.put(url, data, { params });
    return import_sdk79.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, EntitlementSoldResult, "EntitlementSoldResult");
  }
  /**
   * Split a specified use count of entitlement and create a new entitlement with splitting use count.Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: entitlement&lt;/li&gt;&lt;/ul&gt;
   */
  updateSplit_ByUserId_ByEntitlementId(userId, entitlementId, data) {
    const params = {};
    const url = "/platform/public/namespaces/{namespace}/users/{userId}/entitlements/{entitlementId}/split".replace("{namespace}", this.namespace).replace("{userId}", userId).replace("{entitlementId}", entitlementId);
    const resultPromise = this.axiosInstance.put(url, data, { params });
    return import_sdk79.Validate.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      EntitlementSplitResult,
      "EntitlementSplitResult"
    );
  }
  /**
   * Transfer a specified use count from entitlement A to B..Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: entitlement&lt;/li&gt;&lt;/ul&gt;
   */
  updateTransfer_ByUserId_ByEntitlementId(userId, entitlementId, data) {
    const params = {};
    const url = "/platform/public/namespaces/{namespace}/users/{userId}/entitlements/{entitlementId}/transfer".replace("{namespace}", this.namespace).replace("{userId}", userId).replace("{entitlementId}", entitlementId);
    const resultPromise = this.axiosInstance.put(url, data, { params });
    return import_sdk79.Validate.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      EntitlementTransferResult,
      "EntitlementTransferResult"
    );
  }
  /**
   * Consume user entitlement. If the entitlement useCount is 0, the status will be CONSUMED. Client should pass item id in options if entitlement clazz is OPTIONBOX&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: consumed entitlement&lt;/li&gt;&lt;/ul&gt;
   */
  updateDecrement_ByUserId_ByEntitlementId(userId, entitlementId, data) {
    const params = {};
    const url = "/platform/public/namespaces/{namespace}/users/{userId}/entitlements/{entitlementId}/decrement".replace("{namespace}", this.namespace).replace("{userId}", userId).replace("{entitlementId}", entitlementId);
    const resultPromise = this.axiosInstance.put(url, data, { params });
    return import_sdk79.Validate.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      EntitlementDecrementResult,
      "EntitlementDecrementResult"
    );
  }
};

// src/generated-public/endpoints/Fulfillment$.ts
var import_sdk80 = require("@accelbyte/sdk");
var Fulfillment$ = class {
  // @ts-ignore
  // prettier-ignore
  constructor(axiosInstance, namespace, useSchemaValidation = true) {
    this.axiosInstance = axiosInstance;
    this.namespace = namespace;
    this.useSchemaValidation = useSchemaValidation;
  }
  /**
   * Redeem campaign code, this api have rate limit, default: only allow request once per user in 2 seconds&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: fulfillment result&lt;/li&gt;&lt;/ul&gt;
   */
  createFulfillmentCode_ByUserId(userId, data) {
    const params = {};
    const url = "/platform/public/namespaces/{namespace}/users/{userId}/fulfillment/code".replace("{namespace}", this.namespace).replace("{userId}", userId);
    const resultPromise = this.axiosInstance.post(url, data, { params });
    return import_sdk80.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, FulfillmentResult, "FulfillmentResult");
  }
};

// src/generated-public/endpoints/Iap$.ts
var import_sdk81 = require("@accelbyte/sdk");
var import_zod528 = require("zod");
var Iap$ = class {
  // @ts-ignore
  // prettier-ignore
  constructor(axiosInstance, namespace, useSchemaValidation = true) {
    this.axiosInstance = axiosInstance;
    this.namespace = namespace;
    this.useSchemaValidation = useSchemaValidation;
  }
  /**
   * Get iap item mapping.
   */
  getIapItemMapping(queryParams) {
    const params = { ...queryParams };
    const url = "/platform/public/namespaces/{namespace}/iap/item/mapping".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.get(url, { params });
    return import_sdk81.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, IapItemMappingInfo, "IapItemMappingInfo");
  }
  /**
   * Get apple config version.
   */
  getIapAppleConfigVersion() {
    const params = {};
    const url = "/platform/public/namespaces/{namespace}/iap/apple/config/version".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.get(url, { params });
    return import_sdk81.Validate.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      AppleIapConfigVersionInfo,
      "AppleIapConfigVersionInfo"
    );
  }
  /**
   * Sync my game twitch drops entitlements.
   */
  updateUserMeIapTwitchSync(data) {
    const params = {};
    const url = "/platform/public/namespaces/{namespace}/users/me/iap/twitch/sync".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.put(url, data, { params });
    return import_sdk81.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, TwitchSyncResultArray, "TwitchSyncResultArray");
  }
  /**
   * Synchronize with entitlements in PSN Store.Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: result of synchronization&lt;/li&gt;&lt;/ul&gt;
   */
  updateIapPsnSync_ByUserId(userId, data) {
    const params = {};
    const url = "/platform/public/namespaces/{namespace}/users/{userId}/iap/psn/sync".replace("{namespace}", this.namespace).replace("{userId}", userId);
    const resultPromise = this.axiosInstance.put(url, data, { params });
    return import_sdk81.Validate.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      PlayStationReconcileResultArray,
      "PlayStationReconcileResultArray"
    );
  }
  /**
   * Sync Xbox inventory&#39;s items.Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: &lt;/li&gt;&lt;/ul&gt;
   */
  updateIapXblSync_ByUserId(userId, data) {
    const params = {};
    const url = "/platform/public/namespaces/{namespace}/users/{userId}/iap/xbl/sync".replace("{namespace}", this.namespace).replace("{userId}", userId);
    const resultPromise = this.axiosInstance.put(url, data, { params });
    return import_sdk81.Validate.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      XblReconcileResultArray,
      "XblReconcileResultArray"
    );
  }
  /**
   * Sync steam inventory&#39;s items.Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: &lt;/li&gt;&lt;/ul&gt;
   */
  updateIapSteamSync_ByUserId(userId, data) {
    const params = {};
    const url = "/platform/public/namespaces/{namespace}/users/{userId}/iap/steam/sync".replace("{namespace}", this.namespace).replace("{userId}", userId);
    const resultPromise = this.axiosInstance.put(url, data, { params });
    return import_sdk81.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, import_zod528.z.unknown(), "z.unknown()");
  }
  /**
   * Sync Oculus entitlements.Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: &lt;/li&gt;&lt;/ul&gt;
   */
  updateIapOculuSync_ByUserId(userId) {
    const params = {};
    const url = "/platform/public/namespaces/{namespace}/users/{userId}/iap/oculus/sync".replace("{namespace}", this.namespace).replace("{userId}", userId);
    const resultPromise = this.axiosInstance.put(url, null, { params });
    return import_sdk81.Validate.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      OculusReconcileResultArray,
      "OculusReconcileResultArray"
    );
  }
  /**
   * Sync twitch drops entitlements.Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: &lt;/li&gt;&lt;/ul&gt;
   */
  updateIapTwitchSync_ByUserId(userId, data) {
    const params = {};
    const url = "/platform/public/namespaces/{namespace}/users/{userId}/iap/twitch/sync".replace("{namespace}", this.namespace).replace("{userId}", userId);
    const resultPromise = this.axiosInstance.put(url, data, { params });
    return import_sdk81.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, import_zod528.z.unknown(), "z.unknown()");
  }
  /**
   * Verify apple iap receipt and fulfill item. don&#39;t support subscriptionOther detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: &lt;/li&gt;&lt;/ul&gt;
   */
  updateIapAppleReceipt_ByUserId(userId, data) {
    const params = {};
    const url = "/platform/public/namespaces/{namespace}/users/{userId}/iap/apple/receipt".replace("{namespace}", this.namespace).replace("{userId}", userId);
    const resultPromise = this.axiosInstance.put(url, data, { params });
    return import_sdk81.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, import_zod528.z.unknown(), "z.unknown()");
  }
  /**
   * Sync epic games inventory&#39;s items.Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: &lt;/li&gt;&lt;/ul&gt;
   */
  updateIapEpicgameSync_ByUserId(userId, data) {
    const params = {};
    const url = "/platform/public/namespaces/{namespace}/users/{userId}/iap/epicgames/sync".replace("{namespace}", this.namespace).replace("{userId}", userId);
    const resultPromise = this.axiosInstance.put(url, data, { params });
    return import_sdk81.Validate.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      EpicGamesReconcileResultArray,
      "EpicGamesReconcileResultArray"
    );
  }
  /**
   * Verify google iap receipt and fulfill item.Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: &lt;/li&gt;&lt;/ul&gt;
   */
  updateIapGoogleReceipt_ByUserId(userId, data) {
    const params = {};
    const url = "/platform/public/namespaces/{namespace}/users/{userId}/iap/google/receipt".replace("{namespace}", this.namespace).replace("{userId}", userId);
    const resultPromise = this.axiosInstance.put(url, data, { params });
    return import_sdk81.Validate.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      GoogleReceiptResolveResult,
      "GoogleReceiptResolveResult"
    );
  }
  /**
   * Verify apple iap transaction and fulfill item, support subscriptionOther detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: &lt;/li&gt;&lt;/ul&gt;
   */
  updateIapAppleReceipt_ByUserId_v2(userId, data) {
    const params = {};
    const url = "/platform/v2/public/namespaces/{namespace}/users/{userId}/iap/apple/receipt".replace("{namespace}", this.namespace).replace("{userId}", userId);
    const resultPromise = this.axiosInstance.put(url, data, { params });
    return import_sdk81.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, import_zod528.z.unknown(), "z.unknown()");
  }
  /**
   * Synchronize with entitlements in PSN Store with multiple service labels.Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: result of synchronization&lt;/li&gt;&lt;/ul&gt;
   */
  updateIapPsnSyncMultiServiceLabel_ByUserId(userId, data) {
    const params = {};
    const url = "/platform/public/namespaces/{namespace}/users/{userId}/iap/psn/sync/multiServiceLabels".replace("{namespace}", this.namespace).replace("{userId}", userId);
    const resultPromise = this.axiosInstance.put(url, data, { params });
    return import_sdk81.Validate.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      PlayStationReconcileResultArray,
      "PlayStationReconcileResultArray"
    );
  }
};

// src/generated-public/endpoints/IapSubscription$.ts
var import_sdk82 = require("@accelbyte/sdk");
var IapSubscription$ = class {
  // @ts-ignore
  // prettier-ignore
  constructor(axiosInstance, namespace, useSchemaValidation = true) {
    this.axiosInstance = axiosInstance;
    this.namespace = namespace;
    this.useSchemaValidation = useSchemaValidation;
  }
  /**
   * Query user subscription, default sort by updatedAtOther detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: &lt;/li&gt;&lt;/ul&gt;
   */
  getIapSubscriptionPlatform_ByUserId_ByPlatform(userId, platform, queryParams) {
    const params = { limit: 20, ...queryParams };
    const url = "/platform/public/namespaces/{namespace}/users/{userId}/iap/subscriptions/platforms/{platform}".replace("{namespace}", this.namespace).replace("{userId}", userId).replace("{platform}", platform);
    const resultPromise = this.axiosInstance.get(url, { params });
    return import_sdk82.Validate.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      ThirdPartyUserSubscriptionPagingSlicedResult,
      "ThirdPartyUserSubscriptionPagingSlicedResult"
    );
  }
};

// src/generated-public/endpoints/Item$.ts
var import_sdk83 = require("@accelbyte/sdk");
var Item$ = class {
  // @ts-ignore
  // prettier-ignore
  constructor(axiosInstance, namespace, useSchemaValidation = true) {
    this.axiosInstance = axiosInstance;
    this.namespace = namespace;
    this.useSchemaValidation = useSchemaValidation;
  }
  /**
   * This API is used to get the item by sku.&lt;p&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Optional permission&lt;/i&gt;: resource=&#34;PREVIEW&#34;, action=1(CREATE) (user with this permission can view draft store item)&lt;/li&gt;&lt;li&gt;&lt;i&gt;Optional permission&lt;/i&gt;: resource=&#34;SANDBOX&#34;, action=1(CREATE) (user with this permission can view draft store item)&lt;/li&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: the item with sku&lt;/li&gt;&lt;/ul&gt;
   */
  getItemsBySku(queryParams) {
    const params = { ...queryParams };
    const url = "/platform/public/namespaces/{namespace}/items/bySku".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.get(url, { params });
    return import_sdk83.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, ItemInfo, "ItemInfo");
  }
  /**
   * This API is used to search items by keyword in title, description and long description, It&#39;s language constrained, also if item not exist in specific region, default region item will return.&lt;p&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Optional permission&lt;/i&gt;: resource=&#34;PREVIEW&#34;, action=1(CREATE) (user with this permission can view draft store item)&lt;/li&gt;&lt;li&gt;&lt;i&gt;Optional permission&lt;/i&gt;: resource=&#34;SANDBOX&#34;, action=1(CREATE) (user with this permission can view draft store item)&lt;/li&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: the list of items&lt;/li&gt;&lt;/ul&gt;
   */
  getItemsSearch(queryParams) {
    const params = { limit: 20, ...queryParams };
    const url = "/platform/public/namespaces/{namespace}/items/search".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.get(url, { params });
    return import_sdk83.Validate.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      ItemPagingSlicedResult,
      "ItemPagingSlicedResult"
    );
  }
  /**
   * This API is used to get item by appId.&lt;p&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Optional permission&lt;/i&gt;: resource=&#34;PREVIEW&#34;, action=1(CREATE) (user with this permission can view draft store item)&lt;/li&gt;&lt;li&gt;&lt;i&gt;Optional permission&lt;/i&gt;: resource=&#34;SANDBOX&#34;, action=1(CREATE) (user with this permission can view draft store item)&lt;/li&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: the item with that appId&lt;/li&gt;&lt;/ul&gt;
   */
  getItemsByAppId(queryParams) {
    const params = { ...queryParams };
    const url = "/platform/public/namespaces/{namespace}/items/byAppId".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.get(url, { params });
    return import_sdk83.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, ItemInfo, "ItemInfo");
  }
  /**
   * This API is used to query items by criteria within a store. If item not exist in specific region, default region item will return.&lt;p&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Optional permission&lt;/i&gt;: resource=&#34;PREVIEW&#34;, action=1(CREATE) (user with this permission can view draft store item)&lt;/li&gt;&lt;li&gt;&lt;i&gt;Optional permission&lt;/i&gt;: resource=&#34;SANDBOX&#34;, action=1(CREATE) (user with this permission can view draft store item)&lt;/li&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: the list of items&lt;/li&gt;&lt;/ul&gt;
   */
  getItemsByCriteria(queryParams) {
    const params = { limit: 20, sortBy: ["name:asc", "displayOrder:asc"], ...queryParams };
    const url = "/platform/public/namespaces/{namespace}/items/byCriteria".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.get(url, { params });
    return import_sdk83.Validate.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      ItemPagingSlicedResult,
      "ItemPagingSlicedResult"
    );
  }
  /**
   * This API is used to bulk get locale items. If item not exist in specific region, default region item will return.&lt;p&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Optional permission&lt;/i&gt;: resource=&#34;PREVIEW&#34;, action=1(CREATE) (user with this permission can view draft store items)&lt;/li&gt;&lt;li&gt;&lt;i&gt;Optional permission&lt;/i&gt;: resource=&#34;SANDBOX&#34;, action=1(CREATE) (user with this permission can view draft store items)&lt;/li&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: the list of items info&lt;/li&gt;&lt;/ul&gt;
   */
  getItemsLocaleByIds(queryParams) {
    const params = { ...queryParams };
    const url = "/platform/public/namespaces/{namespace}/items/locale/byIds".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.get(url, { params });
    return import_sdk83.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, ItemInfoArray, "ItemInfoArray");
  }
  /**
   * This API is used to get estimated prices of item
   */
  getItemsEstimatedPrice(queryParams) {
    const params = { ...queryParams };
    const url = "/platform/public/namespaces/{namespace}/items/estimatedPrice".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.get(url, { params });
    return import_sdk83.Validate.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      EstimatedPriceInfoArray,
      "EstimatedPriceInfoArray"
    );
  }
  /**
   * This API is used to get an item in locale. If item not exist in specific region, default region item will return.&lt;p&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Optional permission&lt;/i&gt;: resource=&#34;PREVIEW&#34;, action=1(CREATE) (user with this permission can view draft store item)&lt;/li&gt;&lt;li&gt;&lt;i&gt;Optional permission&lt;/i&gt;: resource=&#34;SANDBOX&#34;, action=1(CREATE) (user with this permission can view draft store item)&lt;/li&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: item data&lt;/li&gt;&lt;/ul&gt;
   */
  getLocale_ByItemId(itemId, queryParams) {
    const params = { ...queryParams };
    const url = "/platform/public/namespaces/{namespace}/items/{itemId}/locale".replace("{namespace}", this.namespace).replace("{itemId}", itemId);
    const resultPromise = this.axiosInstance.get(url, { params });
    return import_sdk83.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, PopulatedItemInfo, "PopulatedItemInfo");
  }
  /**
   * Get item dynamic data for a published item.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: item dynamic data&lt;/li&gt;&lt;/ul&gt;
   */
  getDynamic_ByItemId(itemId) {
    const params = {};
    const url = "/platform/public/namespaces/{namespace}/items/{itemId}/dynamic".replace("{namespace}", this.namespace).replace("{itemId}", itemId);
    const resultPromise = this.axiosInstance.get(url, { params });
    return import_sdk83.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, ItemDynamicDataInfo, "ItemDynamicDataInfo");
  }
  /**
   * This API is used to get an app in locale. If app not exist in specific region, default region app will return.&lt;p&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Optional permission&lt;/i&gt;: resource=&#34;PREVIEW&#34;, action=1(CREATE) (user with this permission can view draft store app)&lt;/li&gt;&lt;li&gt;&lt;i&gt;Optional permission&lt;/i&gt;: resource=&#34;SANDBOX&#34;, action=1(CREATE) (user with this permission can view draft store app)&lt;/li&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: app data&lt;/li&gt;&lt;/ul&gt;
   */
  getAppLocale_ByItemId(itemId, queryParams) {
    const params = { ...queryParams };
    const url = "/platform/public/namespaces/{namespace}/items/{itemId}/app/locale".replace("{namespace}", this.namespace).replace("{itemId}", itemId);
    const resultPromise = this.axiosInstance.get(url, { params });
    return import_sdk83.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, AppInfo, "AppInfo");
  }
  /**
   * This API is used to validate user item purchase condition
   */
  createItemPurchaseConditionValidate(data) {
    const params = {};
    const url = "/platform/public/namespaces/{namespace}/items/purchase/conditions/validate".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.post(url, data, { params });
    return import_sdk83.Validate.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      ItemPurchaseConditionValidateResultArray,
      "ItemPurchaseConditionValidateResultArray"
    );
  }
};

// src/generated-public/endpoints/Order$.ts
var import_sdk84 = require("@accelbyte/sdk");
var import_zod529 = require("zod");
var Order$ = class {
  // @ts-ignore
  // prettier-ignore
  constructor(axiosInstance, namespace, useSchemaValidation = true) {
    this.axiosInstance = axiosInstance;
    this.namespace = namespace;
    this.useSchemaValidation = useSchemaValidation;
  }
  /**
   * Query user orders.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: get order&lt;/li&gt;&lt;/ul&gt;
   */
  getOrders_ByUserId(userId, queryParams) {
    const params = { limit: 20, ...queryParams };
    const url = "/platform/public/namespaces/{namespace}/users/{userId}/orders".replace("{namespace}", this.namespace).replace("{userId}", userId);
    const resultPromise = this.axiosInstance.get(url, { params });
    return import_sdk84.Validate.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      OrderPagingSlicedResult,
      "OrderPagingSlicedResult"
    );
  }
  /**
   * Create an order. The result contains the checkout link and payment token. User with permission SANDBOX will create sandbox order that not real paid for xsolla/alipay and not validate price for wxpay.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Optional permission(user with this permission will create sandbox order)&lt;/i&gt;: resource=&#34;SANDBOX&#34;, action=1 (CREATE)&lt;/li&gt;&lt;li&gt;It will be forbidden while the user is banned: ORDER_INITIATE or ORDER_AND_PAYMENT&lt;/li&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: created order&lt;/li&gt;&lt;/ul&gt;&lt;h2&gt;Restrictions for ext field&lt;/h2&gt; 1. Cannot use &lt;b&gt;&#34;.&#34;&lt;/b&gt; as the key name - &lt;pre&gt;{ &#34;data.2&#34;: &#34;value&#34; }&lt;/pre&gt; 2. Cannot use &lt;b&gt;&#34;$&#34;&lt;/b&gt; as the prefix in key names - &lt;pre&gt;{ &#34;$data&#34;: &#34;value&#34; }&lt;/pre&gt;
   */
  createOrder_ByUserId(userId, data) {
    const params = {};
    const url = "/platform/public/namespaces/{namespace}/users/{userId}/orders".replace("{namespace}", this.namespace).replace("{userId}", userId);
    const resultPromise = this.axiosInstance.post(url, data, { params });
    return import_sdk84.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, OrderInfo, "OrderInfo");
  }
  /**
   * Get user order.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: get order&lt;/li&gt;&lt;/ul&gt;
   */
  getOrder_ByUserId_ByOrderNo(userId, orderNo) {
    const params = {};
    const url = "/platform/public/namespaces/{namespace}/users/{userId}/orders/{orderNo}".replace("{namespace}", this.namespace).replace("{userId}", userId).replace("{orderNo}", orderNo);
    const resultPromise = this.axiosInstance.get(url, { params });
    return import_sdk84.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, OrderInfo, "OrderInfo");
  }
  /**
   * Cancel user order.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;/li&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: cancelled order&lt;/li&gt;&lt;/ul&gt;
   */
  updateCancel_ByUserId_ByOrderNo(userId, orderNo) {
    const params = {};
    const url = "/platform/public/namespaces/{namespace}/users/{userId}/orders/{orderNo}/cancel".replace("{namespace}", this.namespace).replace("{userId}", userId).replace("{orderNo}", orderNo);
    const resultPromise = this.axiosInstance.put(url, null, { params });
    return import_sdk84.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, OrderInfo, "OrderInfo");
  }
  /**
   * Preview order price with discount code, this api is used to auto calc order price with discount code.Notes: this api don&#39;t do full order validation, only check discount code and calc final order price.Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: previewed order&lt;/li&gt;&lt;/ul&gt;
   */
  createOrderDiscountPreview_ByUserId(userId, data) {
    const params = {};
    const url = "/platform/public/namespaces/{namespace}/users/{userId}/orders/discount/preview".replace("{namespace}", this.namespace).replace("{userId}", userId);
    const resultPromise = this.axiosInstance.post(url, data, { params });
    return import_sdk84.Validate.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      OrderDiscountPreviewResponse,
      "OrderDiscountPreviewResponse"
    );
  }
  /**
   * Get user order histories.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: get order history&lt;/li&gt;&lt;/ul&gt;
   */
  getHistory_ByUserId_ByOrderNo(userId, orderNo) {
    const params = {};
    const url = "/platform/public/namespaces/{namespace}/users/{userId}/orders/{orderNo}/history".replace("{namespace}", this.namespace).replace("{userId}", userId).replace("{orderNo}", orderNo);
    const resultPromise = this.axiosInstance.get(url, { params });
    return import_sdk84.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, OrderHistoryInfoArray, "OrderHistoryInfoArray");
  }
  /**
   * Download user order receipt by orderNo.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: order receipt pdf&lt;/li&gt;&lt;/ul&gt;
   */
  getReceiptPdf_ByUserId_ByOrderNo(userId, orderNo) {
    const params = {};
    const url = "/platform/public/namespaces/{namespace}/users/{userId}/orders/{orderNo}/receipt.pdf".replace("{namespace}", this.namespace).replace("{userId}", userId).replace("{orderNo}", orderNo);
    const resultPromise = this.axiosInstance.get(url, { params });
    return import_sdk84.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, import_zod529.z.unknown(), "z.unknown()");
  }
};

// src/generated-public/endpoints/PaymentAccount$.ts
var import_sdk85 = require("@accelbyte/sdk");
var import_zod530 = require("zod");
var PaymentAccount$ = class {
  // @ts-ignore
  // prettier-ignore
  constructor(axiosInstance, namespace, useSchemaValidation = true) {
    this.axiosInstance = axiosInstance;
    this.namespace = namespace;
    this.useSchemaValidation = useSchemaValidation;
  }
  /**
   * &lt;b&gt;[Not supported yet in AGS Shared Cloud]&lt;/b&gt;Get payment accounts.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: Payment account list&lt;/li&gt;&lt;/ul&gt;
   */
  getPaymentAccounts_ByUserId(userId) {
    const params = {};
    const url = "/platform/public/namespaces/{namespace}/users/{userId}/payment/accounts".replace("{namespace}", this.namespace).replace("{userId}", userId);
    const resultPromise = this.axiosInstance.get(url, { params });
    return import_sdk85.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, PaymentAccountArray, "PaymentAccountArray");
  }
  /**
   * &lt;b&gt;[Not supported yet in AGS Shared Cloud]&lt;/b&gt;Delete payment account.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;:&lt;/li&gt;&lt;/ul&gt;
   */
  deletePaymentAccount_ByUserId_ByType_ById(userId, type, id) {
    const params = {};
    const url = "/platform/public/namespaces/{namespace}/users/{userId}/payment/accounts/{type}/{id}".replace("{namespace}", this.namespace).replace("{userId}", userId).replace("{type}", type).replace("{id}", id);
    const resultPromise = this.axiosInstance.delete(url, { params });
    return import_sdk85.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, import_zod530.z.unknown(), "z.unknown()");
  }
};

// src/generated-public/endpoints/PaymentStation$.ts
var import_sdk86 = require("@accelbyte/sdk");
var import_zod531 = require("zod");
var PaymentStation$ = class {
  // @ts-ignore
  // prettier-ignore
  constructor(axiosInstance, namespace, useSchemaValidation = true) {
    this.axiosInstance = axiosInstance;
    this.namespace = namespace;
    this.useSchemaValidation = useSchemaValidation;
  }
  /**
   * &lt;b&gt;[Not supported yet in AGS Shared Cloud]&lt;/b&gt;Check and get a payment order&#39;s should pay tax.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: tax result&lt;/li&gt;&lt;/ul&gt;
   */
  getPaymentTax(queryParams) {
    const params = { ...queryParams };
    const url = "/platform/public/namespaces/{namespace}/payment/tax".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.get(url, { params });
    return import_sdk86.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, TaxResult, "TaxResult");
  }
  /**
   * &lt;b&gt;[Not supported yet in AGS Shared Cloud]&lt;/b&gt;Get payment url.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;For Neon Pay payment provider, the &#39;neonPayConfig&#39; field can be used to provide success and cancel URL. If &#39;neonPayConfig&#39; field is not present, the &#39;returnUrl&#39; will be used for both success and cancel URL.&lt;/li&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: Get payment link&lt;/li&gt;&lt;/ul&gt;
   */
  createPaymentLink(data) {
    const params = {};
    const url = "/platform/public/namespaces/{namespace}/payment/link".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.post(url, data, { params });
    return import_sdk86.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, PaymentUrl, "PaymentUrl");
  }
  /**
   * &lt;b&gt;[Not supported yet in AGS Shared Cloud]&lt;/b&gt;Get qrcode.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: QRCode image stream&lt;/li&gt;&lt;/ul&gt;
   */
  getPaymentQrcode(queryParams) {
    const params = { ...queryParams };
    const url = "/platform/public/namespaces/{namespace}/payment/qrcode".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.get(url, { params });
    return import_sdk86.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, BinarySchema, "BinarySchema");
  }
  /**
   * &lt;b&gt;[Not supported yet in AGS Shared Cloud]&lt;/b&gt;Get payment methods.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: Payment method list&lt;/li&gt;&lt;/ul&gt;
   */
  getPaymentMethods(queryParams) {
    const params = { ...queryParams };
    const url = "/platform/public/namespaces/{namespace}/payment/methods".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.get(url, { params });
    return import_sdk86.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, PaymentMethodArray, "PaymentMethodArray");
  }
  /**
   * &lt;b&gt;[Not supported yet in AGS Shared Cloud]&lt;/b&gt;Normalize payment return url for payment provider&lt;br&gt;Payment response: &lt;table&gt;&lt;tr&gt;&lt;td&gt;Field&lt;/td&gt;&lt;td&gt;Type&lt;/td&gt;&lt;td&gt;Required&lt;/td&gt;&lt;td&gt;Description&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;orderNo&lt;/td&gt;&lt;td&gt;String&lt;/td&gt;&lt;td&gt;Yes&lt;/td&gt;&lt;td&gt;order no&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;paymentStatus&lt;/td&gt;&lt;td&gt;String&lt;/td&gt;&lt;td&gt;Yes&lt;/td&gt;&lt;td&gt;&lt;ul&gt;&lt;li&gt;DONE: The payment was successfully completed.&lt;/li&gt;&lt;li&gt;CANCELLED: The payment was cancelled by the shopper before completion, or the shopper returned to the merchant&#39;s site before completing the transaction.&lt;/li&gt;&lt;li&gt;PENDING: Inform the shopper that you&#39;ve received their order, and are waiting for the payment to be completed. When the shopper has completed the payment you will receive a successful AUTHORISATION.&lt;/li&gt;&lt;li&gt;RECEIVED: Inform the shopper that you&#39;ve received their order, and are waiting for the payment to clear.&lt;/li&gt;&lt;li&gt;UNKNOWN: An error occurred during the payment processing.&lt;/li&gt;&lt;li&gt;FAILED: Shopper paid failed because of various reasons.&lt;/li&gt;&lt;/ul&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;reason&lt;/td&gt;&lt;td&gt;String&lt;/td&gt;&lt;td&gt;No&lt;/td&gt;&lt;td&gt;payment status reason&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;xsolla&lt;/i&gt;: parameters &#39;user_id&#39;, &#39;foreinginvoice&#39;, &#39;invoice_id&#39; and &#39;status&#39; will be automatically added to the link&lt;/li&gt;&lt;li&gt;&lt;i&gt;adyen&lt;/i&gt;: https://docs.adyen.com/developers/checkout/web-sdk&lt;/li&gt;&lt;/ul&gt;
   */
  getPaymentReturnurl(queryParams) {
    const params = { ...queryParams };
    const url = "/platform/public/namespaces/{namespace}/payment/returnurl".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.get(url, { params });
    return import_sdk86.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, import_zod531.z.unknown(), "z.unknown()");
  }
  /**
   * &lt;b&gt;[Not supported yet in AGS Shared Cloud]&lt;/b&gt;Get payment provider public config, at current only Strip provide public config.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: Public config&lt;/li&gt;&lt;/ul&gt;
   */
  getPaymentPublicconfig(queryParams) {
    const params = { ...queryParams };
    const url = "/platform/public/namespaces/{namespace}/payment/publicconfig".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.get(url, { params });
    return import_sdk86.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, import_zod531.z.unknown(), "z.unknown()");
  }
  /**
   * @deprecated
   * &lt;b&gt;[Not supported yet in AGS Shared Cloud]&lt;/b&gt;Get payment provider customization, at current only Adyen provide customization. This api has been deprecated, pls use /public/namespaces/{namespace}/payment/publicconfig to get adyen config&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: customization&lt;/li&gt;&lt;/ul&gt;
   */
  getPaymentCustomization(queryParams) {
    const params = { ...queryParams };
    const url = "/platform/public/namespaces/{namespace}/payment/customization".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.get(url, { params });
    return import_sdk86.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, Customization, "Customization");
  }
  /**
   * &lt;b&gt;[Not supported yet in AGS Shared Cloud]&lt;/b&gt;Do payment(For now, this only support checkout.com).&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: Payment process result&lt;/li&gt;&lt;/ul&gt;
   */
  createPayPayment_ByPaymentOrderNo(paymentOrderNo, data, queryParams) {
    const params = { paymentProvider: "CHECKOUT", ...queryParams };
    const url = "/platform/public/namespaces/{namespace}/payment/orders/{paymentOrderNo}/pay".replace("{namespace}", this.namespace).replace("{paymentOrderNo}", paymentOrderNo);
    const resultPromise = this.axiosInstance.post(url, data, { params });
    return import_sdk86.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, PaymentProcessResult, "PaymentProcessResult");
  }
  /**
   * &lt;b&gt;[Not supported yet in AGS Shared Cloud]&lt;/b&gt;Get payment order info.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: Payment order details&lt;/li&gt;&lt;/ul&gt;
   */
  getInfoPayment_ByPaymentOrderNo(paymentOrderNo) {
    const params = {};
    const url = "/platform/public/namespaces/{namespace}/payment/orders/{paymentOrderNo}/info".replace("{namespace}", this.namespace).replace("{paymentOrderNo}", paymentOrderNo);
    const resultPromise = this.axiosInstance.get(url, { params });
    return import_sdk86.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, PaymentOrderDetails, "PaymentOrderDetails");
  }
  /**
   * &lt;b&gt;[Not supported yet in AGS Shared Cloud]&lt;/b&gt;Check payment order paid status.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: Payment order paid result&lt;/li&gt;&lt;/ul&gt;
   */
  getStatusPayment_ByPaymentOrderNo(paymentOrderNo) {
    const params = {};
    const url = "/platform/public/namespaces/{namespace}/payment/orders/{paymentOrderNo}/status".replace("{namespace}", this.namespace).replace("{paymentOrderNo}", paymentOrderNo);
    const resultPromise = this.axiosInstance.get(url, { params });
    return import_sdk86.Validate.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      PaymentOrderPaidResult,
      "PaymentOrderPaidResult"
    );
  }
};

// src/generated-public/endpoints/Reward$.ts
var import_sdk87 = require("@accelbyte/sdk");
var Reward$ = class {
  // @ts-ignore
  // prettier-ignore
  constructor(axiosInstance, namespace, useSchemaValidation = true) {
    this.axiosInstance = axiosInstance;
    this.namespace = namespace;
    this.useSchemaValidation = useSchemaValidation;
  }
  /**
   * This API is used to get reward by reward code.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: reward instance&lt;/li&gt;&lt;/ul&gt;
   */
  getRewardsByCode(queryParams) {
    const params = { ...queryParams };
    const url = "/platform/public/namespaces/{namespace}/rewards/byCode".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.get(url, { params });
    return import_sdk87.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, RewardInfo, "RewardInfo");
  }
  /**
   * This API is used to get reward by reward Id.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: reward instance&lt;/li&gt;&lt;/ul&gt;
   */
  getReward_ByRewardId(rewardId) {
    const params = {};
    const url = "/platform/public/namespaces/{namespace}/rewards/{rewardId}".replace("{namespace}", this.namespace).replace("{rewardId}", rewardId);
    const resultPromise = this.axiosInstance.get(url, { params });
    return import_sdk87.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, RewardInfo, "RewardInfo");
  }
  /**
   * This API is used to query rewards by criteria.&lt;p&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: the list of rewards&lt;/li&gt;&lt;/ul&gt;
   */
  getRewardsByCriteria(queryParams) {
    const params = { limit: 20, sortBy: ["namespace:asc", "rewardCode:asc"], ...queryParams };
    const url = "/platform/public/namespaces/{namespace}/rewards/byCriteria".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.get(url, { params });
    return import_sdk87.Validate.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      RewardPagingSlicedResult,
      "RewardPagingSlicedResult"
    );
  }
};

// src/generated-public/endpoints/Section$.ts
var import_sdk88 = require("@accelbyte/sdk");
var Section$ = class {
  // @ts-ignore
  // prettier-ignore
  constructor(axiosInstance, namespace, useSchemaValidation = true) {
    this.axiosInstance = axiosInstance;
    this.namespace = namespace;
    this.useSchemaValidation = useSchemaValidation;
  }
  /**
   * This API is used to list active section contents.&lt;p&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Optional permission&lt;/i&gt;: resource=&#34;PREVIEW&#34;, action=1(CREATE) (user with this permission can view draft store sections)&lt;/li&gt;&lt;li&gt;&lt;i&gt;Optional permission&lt;/i&gt;: resource=&#34;SANDBOX&#34;, action=1(CREATE) (user with this permission can view draft store sections)&lt;/li&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: active section contents&lt;/li&gt;&lt;/ul&gt;
   */
  getSections_ByUserId(userId, queryParams) {
    const params = { ...queryParams };
    const url = "/platform/public/namespaces/{namespace}/users/{userId}/sections".replace("{namespace}", this.namespace).replace("{userId}", userId);
    const resultPromise = this.axiosInstance.get(url, { params });
    return import_sdk88.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, SectionInfoArray, "SectionInfoArray");
  }
};

// src/generated-public/endpoints/Store$.ts
var import_sdk89 = require("@accelbyte/sdk");
var Store$ = class {
  // @ts-ignore
  // prettier-ignore
  constructor(axiosInstance, namespace, useSchemaValidation = true) {
    this.axiosInstance = axiosInstance;
    this.namespace = namespace;
    this.useSchemaValidation = useSchemaValidation;
  }
  /**
   * This API is used to list all stores in a namespace.&lt;p&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Optional permission&lt;/i&gt;: resource=&#34;PREVIEW&#34;, action=1(CREATE) (user with this permission can view draft store)&lt;/li&gt;&lt;li&gt;&lt;i&gt;Optional permission&lt;/i&gt;: resource=&#34;SANDBOX&#34;, action=1(CREATE) (user with this permission can view draft store)&lt;/li&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: the list of stores&lt;/li&gt;&lt;/ul&gt;
   */
  getStores() {
    const params = {};
    const url = "/platform/public/namespaces/{namespace}/stores".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.get(url, { params });
    return import_sdk89.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, StoreInfoArray, "StoreInfoArray");
  }
};

// src/generated-public/endpoints/Subscription$.ts
var import_sdk90 = require("@accelbyte/sdk");
var import_zod532 = require("zod");
var Subscription$ = class {
  // @ts-ignore
  // prettier-ignore
  constructor(axiosInstance, namespace, useSchemaValidation = true) {
    this.axiosInstance = axiosInstance;
    this.namespace = namespace;
    this.useSchemaValidation = useSchemaValidation;
  }
  /**
   * Query user subscriptions.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: paginated subscription&lt;/li&gt;&lt;/ul&gt;
   */
  getSubscriptions_ByUserId(userId, queryParams) {
    const params = { limit: 20, ...queryParams };
    const url = "/platform/public/namespaces/{namespace}/users/{userId}/subscriptions".replace("{namespace}", this.namespace).replace("{userId}", userId);
    const resultPromise = this.axiosInstance.get(url, { params });
    return import_sdk90.Validate.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      SubscriptionPagingSlicedResult,
      "SubscriptionPagingSlicedResult"
    );
  }
  /**
   * Subscribe a subscription. Support both real and virtual payment. Need go through payment flow using the paymentOrderNo if paymentFlowRequired true.&lt;br&gt;&lt;b&gt;ACTIVE USER subscription can&#39;t do subscribe again.&lt;/b&gt;&lt;br&gt;&lt;b&gt;The next billing date will be X(default 4) hours before the current period ends if correctly subscribed.&lt;/b&gt;&lt;br&gt;User with permission SANDBOX will create sandbox subscription that not real paid.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Optional permission(user with this permission will create sandbox subscription)&lt;/i&gt;: resource=&#34;SANDBOX&#34;, action=1 (CREATE)&lt;/li&gt;&lt;li&gt;It will be forbidden while the user is banned: ORDER_INITIATE or ORDER_AND_PAYMENT&lt;/li&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: created subscription&lt;/li&gt;&lt;/ul&gt;
   */
  createSubscription_ByUserId(userId, data) {
    const params = {};
    const url = "/platform/public/namespaces/{namespace}/users/{userId}/subscriptions".replace("{namespace}", this.namespace).replace("{userId}", userId);
    const resultPromise = this.axiosInstance.post(url, data, { params });
    return import_sdk90.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, import_zod532.z.unknown(), "z.unknown()");
  }
  /**
   * Get user subscription.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: subscription&lt;/li&gt;&lt;/ul&gt;
   */
  getSubscription_ByUserId_BySubscriptionId(userId, subscriptionId) {
    const params = {};
    const url = "/platform/public/namespaces/{namespace}/users/{userId}/subscriptions/{subscriptionId}".replace("{namespace}", this.namespace).replace("{userId}", userId).replace("{subscriptionId}", subscriptionId);
    const resultPromise = this.axiosInstance.get(url, { params });
    return import_sdk90.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, SubscriptionInfo, "SubscriptionInfo");
  }
  /**
   * Check user subscription subscribable by itemId, ACTIVE USER subscription can&#39;t do subscribe again.&lt;p&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: subscribable info&lt;/li&gt;&lt;/ul&gt;
   */
  getSubscriptionsSubscribableByItemId_ByUserId(userId, queryParams) {
    const params = { ...queryParams };
    const url = "/platform/public/namespaces/{namespace}/users/{userId}/subscriptions/subscribable/byItemId".replace("{namespace}", this.namespace).replace("{userId}", userId);
    const resultPromise = this.axiosInstance.get(url, { params });
    return import_sdk90.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, Subscribable, "Subscribable");
  }
  /**
   * Cancel a subscription, only ACTIVE subscription can be cancelled. &lt;b&gt;Ensure successfully cancel, recommend at least 1 day before current period ends, otherwise it may be charging or charged.&lt;/b&gt;&lt;br&gt;Set immediate true, the subscription will be terminated immediately, otherwise till the end of current billing cycle.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: cancelled subscription&lt;/li&gt;&lt;/ul&gt;
   */
  updateCancel_ByUserId_BySubscriptionId(userId, subscriptionId, data) {
    const params = {};
    const url = "/platform/public/namespaces/{namespace}/users/{userId}/subscriptions/{subscriptionId}/cancel".replace("{namespace}", this.namespace).replace("{userId}", userId).replace("{subscriptionId}", subscriptionId);
    const resultPromise = this.axiosInstance.put(url, data, { params });
    return import_sdk90.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, SubscriptionInfo, "SubscriptionInfo");
  }
  /**
   * Get user subscription billing histories.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: paginated subscription history&lt;/li&gt;&lt;/ul&gt;
   */
  getHistory_ByUserId_BySubscriptionId(userId, subscriptionId, queryParams) {
    const params = { limit: 20, ...queryParams };
    const url = "/platform/public/namespaces/{namespace}/users/{userId}/subscriptions/{subscriptionId}/history".replace("{namespace}", this.namespace).replace("{userId}", userId).replace("{subscriptionId}", subscriptionId);
    const resultPromise = this.axiosInstance.get(url, { params });
    return import_sdk90.Validate.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      BillingHistoryPagingSlicedResult,
      "BillingHistoryPagingSlicedResult"
    );
  }
  /**
   * Request to change a subscription billing account, this will guide user to payment station. The actual change will happen at the 0 payment notification successfully handled.&lt;br&gt;Only ACTIVE USER subscription with real currency billing account can be changed.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: updated subscription&lt;/li&gt;&lt;/ul&gt;
   */
  updateBillingAccount_ByUserId_BySubscriptionId(userId, subscriptionId) {
    const params = {};
    const url = "/platform/public/namespaces/{namespace}/users/{userId}/subscriptions/{subscriptionId}/billingAccount".replace("{namespace}", this.namespace).replace("{userId}", userId).replace("{subscriptionId}", subscriptionId);
    const resultPromise = this.axiosInstance.put(url, null, { params });
    return import_sdk90.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, SubscriptionInfo, "SubscriptionInfo");
  }
};

// src/generated-public/endpoints/View$.ts
var import_sdk91 = require("@accelbyte/sdk");
var View$ = class {
  // @ts-ignore
  // prettier-ignore
  constructor(axiosInstance, namespace, useSchemaValidation = true) {
    this.axiosInstance = axiosInstance;
    this.namespace = namespace;
    this.useSchemaValidation = useSchemaValidation;
  }
  /**
   * This API is used to get all views.&lt;p&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Optional permission&lt;/i&gt;: resource=&#34;PREVIEW&#34;, action=1(CREATE) (user with this permission can view draft store views)&lt;/li&gt;&lt;li&gt;&lt;i&gt;Optional permission&lt;/i&gt;: resource=&#34;SANDBOX&#34;, action=1(CREATE) (user with this permission can view draft store views)&lt;/li&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: all views&lt;/li&gt;&lt;/ul&gt;
   */
  getViews_ByUserId(userId, queryParams) {
    const params = { ...queryParams };
    const url = "/platform/public/namespaces/{namespace}/users/{userId}/views".replace("{namespace}", this.namespace).replace("{userId}", userId);
    const resultPromise = this.axiosInstance.get(url, { params });
    return import_sdk91.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, ViewInfoArray, "ViewInfoArray");
  }
};

// src/generated-public/endpoints/Wallet$.ts
var import_sdk92 = require("@accelbyte/sdk");
var Wallet$ = class {
  // @ts-ignore
  // prettier-ignore
  constructor(axiosInstance, namespace, useSchemaValidation = true) {
    this.axiosInstance = axiosInstance;
    this.namespace = namespace;
    this.useSchemaValidation = useSchemaValidation;
  }
  /**
   * get my wallet by currency code and namespace.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: wallet info&lt;/li&gt;&lt;li&gt;&lt;i&gt;Path&#39;s namespace&lt;/i&gt; : &lt;ul&gt; &lt;li&gt;can be filled with &lt;b&gt;publisher namespace&lt;/b&gt; in order to get &lt;b&gt;publisher user wallet&lt;/b&gt;&lt;/li&gt; &lt;li&gt;can be filled with &lt;b&gt;game namespace&lt;/b&gt; in order to get &lt;b&gt;game user wallet&lt;/b&gt;&lt;/li&gt; &lt;/ul&gt;&lt;/li&gt;&lt;/ul&gt;
   */
  getUserMeWallet_ByCurrencyCode(currencyCode) {
    const params = {};
    const url = "/platform/public/namespaces/{namespace}/users/me/wallets/{currencyCode}".replace("{namespace}", this.namespace).replace("{currencyCode}", currencyCode);
    const resultPromise = this.axiosInstance.get(url, { params });
    return import_sdk92.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, PlatformWallet, "PlatformWallet");
  }
  /**
   * get a wallet by currency code.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: wallet info&lt;/li&gt;&lt;/ul&gt;
   */
  getWallet_ByUserId_ByCurrencyCode(userId, currencyCode) {
    const params = {};
    const url = "/platform/public/namespaces/{namespace}/users/{userId}/wallets/{currencyCode}".replace("{namespace}", this.namespace).replace("{userId}", userId).replace("{currencyCode}", currencyCode);
    const resultPromise = this.axiosInstance.get(url, { params });
    return import_sdk92.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, PlatformWallet, "PlatformWallet");
  }
  /**
   * List wallet transactions by currency code ordered by create time desc.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: currency transaction info&lt;/li&gt;&lt;/ul&gt;
   */
  getTransactions_ByUserId_ByCurrencyCode(userId, currencyCode, queryParams) {
    const params = { limit: 20, ...queryParams };
    const url = "/platform/public/namespaces/{namespace}/users/{userId}/wallets/{currencyCode}/transactions".replace("{namespace}", this.namespace).replace("{userId}", userId).replace("{currencyCode}", currencyCode);
    const resultPromise = this.axiosInstance.get(url, { params });
    return import_sdk92.Validate.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      WalletTransactionPagingSlicedResult,
      "WalletTransactionPagingSlicedResult"
    );
  }
};

// src/generated-public/EntitlementApi.ts
var import_sdk93 = require("@accelbyte/sdk");
function EntitlementApi(sdk, args) {
  const sdkAssembly = sdk.assembly();
  const namespace = args?.coreConfig?.namespace ?? sdkAssembly.coreConfig.namespace;
  const useSchemaValidation = args?.coreConfig?.useSchemaValidation ?? sdkAssembly.coreConfig.useSchemaValidation;
  let axiosInstance = sdkAssembly.axiosInstance;
  const requestConfigOverrides = args?.axiosConfig?.request;
  const baseURLOverride = args?.coreConfig?.baseURL;
  const interceptorsOverride = args?.axiosConfig?.interceptors ?? [];
  if (requestConfigOverrides || baseURLOverride || interceptorsOverride.length > 0) {
    const requestConfig = import_sdk93.ApiUtils.mergeAxiosConfigs(sdkAssembly.axiosInstance.defaults, {
      ...baseURLOverride ? { baseURL: baseURLOverride } : {},
      ...requestConfigOverrides
    });
    axiosInstance = import_sdk93.Network.create(requestConfig);
    for (const interceptor of interceptorsOverride) {
      if (interceptor.type === "request") {
        axiosInstance.interceptors.request.use(interceptor.onRequest, interceptor.onError);
      }
      if (interceptor.type === "response") {
        axiosInstance.interceptors.response.use(interceptor.onSuccess, interceptor.onError);
      }
    }
  }
  async function getEntitlements_ByUserId(userId, queryParams) {
    const $ = new Entitlement$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getEntitlements_ByUserId(userId, queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getEntitlementsByIds_ByUserId(userId, queryParams) {
    const $ = new Entitlement$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getEntitlementsByIds_ByUserId(userId, queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getEntitlementsBySku_ByUserId(userId, queryParams) {
    const $ = new Entitlement$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getEntitlementsBySku_ByUserId(userId, queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getEntitlementsByAppId_ByUserId(userId, queryParams) {
    const $ = new Entitlement$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getEntitlementsByAppId_ByUserId(userId, queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getEntitlementsHistory_ByUserId(userId, queryParams) {
    const $ = new Entitlement$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getEntitlementsHistory_ByUserId(userId, queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getUsersMeEntitlementsOwnershipAny(queryParams) {
    const $ = new Entitlement$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getUsersMeEntitlementsOwnershipAny(queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getEntitlementsByItemId_ByUserId(userId, queryParams) {
    const $ = new Entitlement$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getEntitlementsByItemId_ByUserId(userId, queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getUsersMeEntitlementsOwnershipToken(queryParams) {
    const $ = new Entitlement$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getUsersMeEntitlementsOwnershipToken(queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getEntitlementsByAppType_ByUserId(userId, queryParams) {
    const $ = new Entitlement$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getEntitlementsByAppType_ByUserId(userId, queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getUsersMeEntitlementsOwnershipBySku(queryParams) {
    const $ = new Entitlement$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getUsersMeEntitlementsOwnershipBySku(queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getUsersMeEntitlementsOwnershipByAppId(queryParams) {
    const $ = new Entitlement$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getUsersMeEntitlementsOwnershipByAppId(queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getUsersMeEntitlementsOwnershipByItemId(queryParams) {
    const $ = new Entitlement$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getUsersMeEntitlementsOwnershipByItemId(queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getEntitlementsOwnershipAny_ByUserId(userId, queryParams) {
    const $ = new Entitlement$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getEntitlementsOwnershipAny_ByUserId(userId, queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getEntitlement_ByUserId_ByEntitlementId(userId, entitlementId) {
    const $ = new Entitlement$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getEntitlement_ByUserId_ByEntitlementId(userId, entitlementId);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getEntitlementsOwnershipBySku_ByUserId(userId, queryParams) {
    const $ = new Entitlement$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getEntitlementsOwnershipBySku_ByUserId(userId, queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getEntitlementsOwnershipByAppId_ByUserId(userId, queryParams) {
    const $ = new Entitlement$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getEntitlementsOwnershipByAppId_ByUserId(userId, queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getEntitlementsOwnershipByItemId_ByUserId(userId, queryParams) {
    const $ = new Entitlement$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getEntitlementsOwnershipByItemId_ByUserId(userId, queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getEntitlementsOwnershipByItemIds_ByUserId(userId, queryParams) {
    const $ = new Entitlement$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getEntitlementsOwnershipByItemIds_ByUserId(userId, queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function updateSell_ByUserId_ByEntitlementId(userId, entitlementId, data) {
    const $ = new Entitlement$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.updateSell_ByUserId_ByEntitlementId(userId, entitlementId, data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function updateSplit_ByUserId_ByEntitlementId(userId, entitlementId, data) {
    const $ = new Entitlement$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.updateSplit_ByUserId_ByEntitlementId(userId, entitlementId, data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function updateTransfer_ByUserId_ByEntitlementId(userId, entitlementId, data) {
    const $ = new Entitlement$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.updateTransfer_ByUserId_ByEntitlementId(userId, entitlementId, data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function updateDecrement_ByUserId_ByEntitlementId(userId, entitlementId, data) {
    const $ = new Entitlement$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.updateDecrement_ByUserId_ByEntitlementId(userId, entitlementId, data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  return {
    /**
     * Query user entitlements for a specific user.&lt;p&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: entitlement list&lt;/li&gt;&lt;/ul&gt;
     */
    getEntitlements_ByUserId,
    /**
     * Get user entitlements by ids..&lt;p&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: entitlement list&lt;/li&gt;&lt;/ul&gt;
     */
    getEntitlementsByIds_ByUserId,
    /**
     * @deprecated
     * Get user entitlement by sku.
     */
    getEntitlementsBySku_ByUserId,
    /**
     * Get user app entitlement by appId.
     */
    getEntitlementsByAppId_ByUserId,
    /**
     * Get user entitlement history&lt;p&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: user entitlement history list&lt;/li&gt;&lt;/ul&gt;
     */
    getEntitlementsHistory_ByUserId,
    /**
     * Exists any my active entitlement of specified itemIds, skus and appIds
     */
    getUsersMeEntitlementsOwnershipAny,
    /**
     * @deprecated
     * Get user entitlement by itemId.
     */
    getEntitlementsByItemId_ByUserId,
    /**
     * Gets an entitlement ownership token of specified itemIds, skus and appIds&lt;p&gt;The decoded ownership token header like below:&lt;p&gt;&lt;pre&gt;&lt;code&gt;{ &#34;kid&#34;: &#34;9fd4cd5f991cebe3323605cd12d3b8bfdfc73fa4&#34;, &#34;typ&#34;: &#34;JWT&#34;, &#34;alg&#34;: &#34;RS256&#34; } &lt;/code&gt;&lt;/pre&gt;That you can get the jwks by api &lt;baseUrl&gt;/platform/jwks, if the configured private key is same as IAM, &lt;p&gt;you can also get jwks from IAM endpoint. &lt;p&gt;The decoded ownership token payload like below:&lt;p&gt;&lt;pre&gt;&lt;code&gt;{ &#34;namespace&#34;: &#34;accelbyte&#34;, &#34;entitlements&#34;: [ { &#34;itemId&#34;: &#34;4c1296291f604c199f7bb7f0ee02e5f8&#34;, &#34;appType&#34;: null, &#34;appId&#34;: null, &#34;namespace&#34;: &#34;accelbyte&#34;, &#34;itemNamespace&#34;: &#34;accelbyte&#34;, &#34;sku&#34;: &#34;prime-plus&#34; }, { &#34;itemId&#34;: &#34;e8f4974cf45c4e1f8d4f0c6990c518bd&#34;, &#34;appType&#34;: &#34;GAME&#34;, &#34;appId&#34;: &#34;omeganebula&#34;, &#34;namespace&#34;: &#34;accelbyte&#34;, &#34;itemNamespace&#34;: &#34;accelbyte&#34;, &#34;sku&#34;: &#34;APPG005ON&#34; } ], &#34;sub&#34;: &#34;66459eb6a4e44e6fb0040bd20c1079a5&#34;, &#34;exp&#34;: 1619624360, &#34;iat&#34;: 1619624060 } &lt;/code&gt;&lt;/pre&gt;&lt;b&gt;if there&#39;s no active entitlement for the specific params, the entitlements section will be omitted&lt;/b&gt;.
     */
    getUsersMeEntitlementsOwnershipToken,
    /**
     * Query app entitlements by appType.&lt;p&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: app entitlement pagination&lt;/li&gt;&lt;/ul&gt;
     */
    getEntitlementsByAppType_ByUserId,
    /**
     * Get my entitlement ownership by sku.&lt;p&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Path&#39;s namespace&lt;/i&gt; : &lt;ul&gt;&lt;li&gt;can be filled with &lt;b&gt;publisher namespace&lt;/b&gt; in order to get &lt;b&gt;publisher namespace entitlement ownership by sku&lt;/b&gt;&lt;/li&gt;&lt;li&gt;can be filled with &lt;b&gt;game namespace&lt;/b&gt; in order to get &lt;b&gt;game namespace entitlement ownership by sku&lt;/b&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;/ul&gt;
     */
    getUsersMeEntitlementsOwnershipBySku,
    /**
     * Get my app entitlement ownership by appId.&lt;p&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Path&#39;s namespace&lt;/i&gt; : &lt;ul&gt;&lt;li&gt;can be filled with &lt;b&gt;publisher namespace&lt;/b&gt; in order to get &lt;b&gt;publisher namespace app entitlement ownership&lt;/b&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;/ul&gt;
     */
    getUsersMeEntitlementsOwnershipByAppId,
    /**
     * Get my entitlement ownership by itemId.&lt;p&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Path&#39;s namespace&lt;/i&gt; : &lt;ul&gt;&lt;li&gt;can be filled with &lt;b&gt;publisher namespace&lt;/b&gt; in order to get &lt;b&gt;publisher namespace entitlement ownership by sku&lt;/b&gt;&lt;/li&gt;&lt;li&gt;can be filled with &lt;b&gt;game namespace&lt;/b&gt; in order to get &lt;b&gt;game namespace entitlement ownership by sku&lt;/b&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;/ul&gt;
     */
    getUsersMeEntitlementsOwnershipByItemId,
    /**
     * Exists any user active entitlement of specified itemIds, skus and appIds
     */
    getEntitlementsOwnershipAny_ByUserId,
    /**
     * Get user entitlement.&lt;p&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: entitlement&lt;/li&gt;&lt;/ul&gt;
     */
    getEntitlement_ByUserId_ByEntitlementId,
    /**
     * Get user entitlement ownership by sku.
     */
    getEntitlementsOwnershipBySku_ByUserId,
    /**
     * Get user app entitlement ownership by appId.
     */
    getEntitlementsOwnershipByAppId_ByUserId,
    /**
     * Get user entitlement ownership by itemId.
     */
    getEntitlementsOwnershipByItemId_ByUserId,
    /**
     * Get user entitlement ownership by itemIds.
     */
    getEntitlementsOwnershipByItemIds_ByUserId,
    /**
     * Sell user entitlement. If the entitlement is consumable, useCount is 0, the status will be CONSUMED. If the entitlement is durable, the status will be SOLD. Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: entitlement&lt;/li&gt;&lt;/ul&gt;
     */
    updateSell_ByUserId_ByEntitlementId,
    /**
     * Split a specified use count of entitlement and create a new entitlement with splitting use count.Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: entitlement&lt;/li&gt;&lt;/ul&gt;
     */
    updateSplit_ByUserId_ByEntitlementId,
    /**
     * Transfer a specified use count from entitlement A to B..Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: entitlement&lt;/li&gt;&lt;/ul&gt;
     */
    updateTransfer_ByUserId_ByEntitlementId,
    /**
     * Consume user entitlement. If the entitlement useCount is 0, the status will be CONSUMED. Client should pass item id in options if entitlement clazz is OPTIONBOX&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: consumed entitlement&lt;/li&gt;&lt;/ul&gt;
     */
    updateDecrement_ByUserId_ByEntitlementId
  };
}

// src/generated-public/FulfillmentApi.ts
var import_sdk94 = require("@accelbyte/sdk");
function FulfillmentApi(sdk, args) {
  const sdkAssembly = sdk.assembly();
  const namespace = args?.coreConfig?.namespace ?? sdkAssembly.coreConfig.namespace;
  const useSchemaValidation = args?.coreConfig?.useSchemaValidation ?? sdkAssembly.coreConfig.useSchemaValidation;
  let axiosInstance = sdkAssembly.axiosInstance;
  const requestConfigOverrides = args?.axiosConfig?.request;
  const baseURLOverride = args?.coreConfig?.baseURL;
  const interceptorsOverride = args?.axiosConfig?.interceptors ?? [];
  if (requestConfigOverrides || baseURLOverride || interceptorsOverride.length > 0) {
    const requestConfig = import_sdk94.ApiUtils.mergeAxiosConfigs(sdkAssembly.axiosInstance.defaults, {
      ...baseURLOverride ? { baseURL: baseURLOverride } : {},
      ...requestConfigOverrides
    });
    axiosInstance = import_sdk94.Network.create(requestConfig);
    for (const interceptor of interceptorsOverride) {
      if (interceptor.type === "request") {
        axiosInstance.interceptors.request.use(interceptor.onRequest, interceptor.onError);
      }
      if (interceptor.type === "response") {
        axiosInstance.interceptors.response.use(interceptor.onSuccess, interceptor.onError);
      }
    }
  }
  async function createFulfillmentCode_ByUserId(userId, data) {
    const $ = new Fulfillment$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.createFulfillmentCode_ByUserId(userId, data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  return {
    /**
     * Redeem campaign code, this api have rate limit, default: only allow request once per user in 2 seconds&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: fulfillment result&lt;/li&gt;&lt;/ul&gt;
     */
    createFulfillmentCode_ByUserId
  };
}

// src/generated-public/IapApi.ts
var import_sdk95 = require("@accelbyte/sdk");
function IapApi(sdk, args) {
  const sdkAssembly = sdk.assembly();
  const namespace = args?.coreConfig?.namespace ?? sdkAssembly.coreConfig.namespace;
  const useSchemaValidation = args?.coreConfig?.useSchemaValidation ?? sdkAssembly.coreConfig.useSchemaValidation;
  let axiosInstance = sdkAssembly.axiosInstance;
  const requestConfigOverrides = args?.axiosConfig?.request;
  const baseURLOverride = args?.coreConfig?.baseURL;
  const interceptorsOverride = args?.axiosConfig?.interceptors ?? [];
  if (requestConfigOverrides || baseURLOverride || interceptorsOverride.length > 0) {
    const requestConfig = import_sdk95.ApiUtils.mergeAxiosConfigs(sdkAssembly.axiosInstance.defaults, {
      ...baseURLOverride ? { baseURL: baseURLOverride } : {},
      ...requestConfigOverrides
    });
    axiosInstance = import_sdk95.Network.create(requestConfig);
    for (const interceptor of interceptorsOverride) {
      if (interceptor.type === "request") {
        axiosInstance.interceptors.request.use(interceptor.onRequest, interceptor.onError);
      }
      if (interceptor.type === "response") {
        axiosInstance.interceptors.response.use(interceptor.onSuccess, interceptor.onError);
      }
    }
  }
  async function getIapItemMapping(queryParams) {
    const $ = new Iap$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getIapItemMapping(queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getIapAppleConfigVersion() {
    const $ = new Iap$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getIapAppleConfigVersion();
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function updateUserMeIapTwitchSync(data) {
    const $ = new Iap$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.updateUserMeIapTwitchSync(data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function updateIapPsnSync_ByUserId(userId, data) {
    const $ = new Iap$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.updateIapPsnSync_ByUserId(userId, data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function updateIapXblSync_ByUserId(userId, data) {
    const $ = new Iap$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.updateIapXblSync_ByUserId(userId, data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function updateIapSteamSync_ByUserId(userId, data) {
    const $ = new Iap$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.updateIapSteamSync_ByUserId(userId, data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function updateIapOculuSync_ByUserId(userId) {
    const $ = new Iap$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.updateIapOculuSync_ByUserId(userId);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function updateIapTwitchSync_ByUserId(userId, data) {
    const $ = new Iap$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.updateIapTwitchSync_ByUserId(userId, data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function updateIapAppleReceipt_ByUserId(userId, data) {
    const $ = new Iap$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.updateIapAppleReceipt_ByUserId(userId, data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function updateIapEpicgameSync_ByUserId(userId, data) {
    const $ = new Iap$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.updateIapEpicgameSync_ByUserId(userId, data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function updateIapGoogleReceipt_ByUserId(userId, data) {
    const $ = new Iap$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.updateIapGoogleReceipt_ByUserId(userId, data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function updateIapAppleReceipt_ByUserId_v2(userId, data) {
    const $ = new Iap$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.updateIapAppleReceipt_ByUserId_v2(userId, data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function updateIapPsnSyncMultiServiceLabel_ByUserId(userId, data) {
    const $ = new Iap$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.updateIapPsnSyncMultiServiceLabel_ByUserId(userId, data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  return {
    /**
     * Get iap item mapping.
     */
    getIapItemMapping,
    /**
     * Get apple config version.
     */
    getIapAppleConfigVersion,
    /**
     * Sync my game twitch drops entitlements.
     */
    updateUserMeIapTwitchSync,
    /**
     * Synchronize with entitlements in PSN Store.Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: result of synchronization&lt;/li&gt;&lt;/ul&gt;
     */
    updateIapPsnSync_ByUserId,
    /**
     * Sync Xbox inventory&#39;s items.Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: &lt;/li&gt;&lt;/ul&gt;
     */
    updateIapXblSync_ByUserId,
    /**
     * Sync steam inventory&#39;s items.Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: &lt;/li&gt;&lt;/ul&gt;
     */
    updateIapSteamSync_ByUserId,
    /**
     * Sync Oculus entitlements.Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: &lt;/li&gt;&lt;/ul&gt;
     */
    updateIapOculuSync_ByUserId,
    /**
     * Sync twitch drops entitlements.Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: &lt;/li&gt;&lt;/ul&gt;
     */
    updateIapTwitchSync_ByUserId,
    /**
     * Verify apple iap receipt and fulfill item. don&#39;t support subscriptionOther detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: &lt;/li&gt;&lt;/ul&gt;
     */
    updateIapAppleReceipt_ByUserId,
    /**
     * Sync epic games inventory&#39;s items.Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: &lt;/li&gt;&lt;/ul&gt;
     */
    updateIapEpicgameSync_ByUserId,
    /**
     * Verify google iap receipt and fulfill item.Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: &lt;/li&gt;&lt;/ul&gt;
     */
    updateIapGoogleReceipt_ByUserId,
    /**
     * Verify apple iap transaction and fulfill item, support subscriptionOther detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: &lt;/li&gt;&lt;/ul&gt;
     */
    updateIapAppleReceipt_ByUserId_v2,
    /**
     * Synchronize with entitlements in PSN Store with multiple service labels.Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: result of synchronization&lt;/li&gt;&lt;/ul&gt;
     */
    updateIapPsnSyncMultiServiceLabel_ByUserId
  };
}

// src/generated-public/IapSubscriptionApi.ts
var import_sdk96 = require("@accelbyte/sdk");
function IapSubscriptionApi(sdk, args) {
  const sdkAssembly = sdk.assembly();
  const namespace = args?.coreConfig?.namespace ?? sdkAssembly.coreConfig.namespace;
  const useSchemaValidation = args?.coreConfig?.useSchemaValidation ?? sdkAssembly.coreConfig.useSchemaValidation;
  let axiosInstance = sdkAssembly.axiosInstance;
  const requestConfigOverrides = args?.axiosConfig?.request;
  const baseURLOverride = args?.coreConfig?.baseURL;
  const interceptorsOverride = args?.axiosConfig?.interceptors ?? [];
  if (requestConfigOverrides || baseURLOverride || interceptorsOverride.length > 0) {
    const requestConfig = import_sdk96.ApiUtils.mergeAxiosConfigs(sdkAssembly.axiosInstance.defaults, {
      ...baseURLOverride ? { baseURL: baseURLOverride } : {},
      ...requestConfigOverrides
    });
    axiosInstance = import_sdk96.Network.create(requestConfig);
    for (const interceptor of interceptorsOverride) {
      if (interceptor.type === "request") {
        axiosInstance.interceptors.request.use(interceptor.onRequest, interceptor.onError);
      }
      if (interceptor.type === "response") {
        axiosInstance.interceptors.response.use(interceptor.onSuccess, interceptor.onError);
      }
    }
  }
  async function getIapSubscriptionPlatform_ByUserId_ByPlatform(userId, platform, queryParams) {
    const $ = new IapSubscription$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getIapSubscriptionPlatform_ByUserId_ByPlatform(userId, platform, queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  return {
    /**
     * Query user subscription, default sort by updatedAtOther detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: &lt;/li&gt;&lt;/ul&gt;
     */
    getIapSubscriptionPlatform_ByUserId_ByPlatform
  };
}

// src/generated-public/ItemApi.ts
var import_sdk97 = require("@accelbyte/sdk");
function ItemApi(sdk, args) {
  const sdkAssembly = sdk.assembly();
  const namespace = args?.coreConfig?.namespace ?? sdkAssembly.coreConfig.namespace;
  const useSchemaValidation = args?.coreConfig?.useSchemaValidation ?? sdkAssembly.coreConfig.useSchemaValidation;
  let axiosInstance = sdkAssembly.axiosInstance;
  const requestConfigOverrides = args?.axiosConfig?.request;
  const baseURLOverride = args?.coreConfig?.baseURL;
  const interceptorsOverride = args?.axiosConfig?.interceptors ?? [];
  if (requestConfigOverrides || baseURLOverride || interceptorsOverride.length > 0) {
    const requestConfig = import_sdk97.ApiUtils.mergeAxiosConfigs(sdkAssembly.axiosInstance.defaults, {
      ...baseURLOverride ? { baseURL: baseURLOverride } : {},
      ...requestConfigOverrides
    });
    axiosInstance = import_sdk97.Network.create(requestConfig);
    for (const interceptor of interceptorsOverride) {
      if (interceptor.type === "request") {
        axiosInstance.interceptors.request.use(interceptor.onRequest, interceptor.onError);
      }
      if (interceptor.type === "response") {
        axiosInstance.interceptors.response.use(interceptor.onSuccess, interceptor.onError);
      }
    }
  }
  async function getItemsBySku(queryParams) {
    const $ = new Item$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getItemsBySku(queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getItemsSearch(queryParams) {
    const $ = new Item$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getItemsSearch(queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getItemsByAppId(queryParams) {
    const $ = new Item$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getItemsByAppId(queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getItemsByCriteria(queryParams) {
    const $ = new Item$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getItemsByCriteria(queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getItemsLocaleByIds(queryParams) {
    const $ = new Item$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getItemsLocaleByIds(queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getItemsEstimatedPrice(queryParams) {
    const $ = new Item$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getItemsEstimatedPrice(queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getLocale_ByItemId(itemId, queryParams) {
    const $ = new Item$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getLocale_ByItemId(itemId, queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getDynamic_ByItemId(itemId) {
    const $ = new Item$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getDynamic_ByItemId(itemId);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getAppLocale_ByItemId(itemId, queryParams) {
    const $ = new Item$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getAppLocale_ByItemId(itemId, queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function createItemPurchaseConditionValidate(data) {
    const $ = new Item$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.createItemPurchaseConditionValidate(data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  return {
    /**
     * This API is used to get the item by sku.&lt;p&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Optional permission&lt;/i&gt;: resource=&#34;PREVIEW&#34;, action=1(CREATE) (user with this permission can view draft store item)&lt;/li&gt;&lt;li&gt;&lt;i&gt;Optional permission&lt;/i&gt;: resource=&#34;SANDBOX&#34;, action=1(CREATE) (user with this permission can view draft store item)&lt;/li&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: the item with sku&lt;/li&gt;&lt;/ul&gt;
     */
    getItemsBySku,
    /**
     * This API is used to search items by keyword in title, description and long description, It&#39;s language constrained, also if item not exist in specific region, default region item will return.&lt;p&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Optional permission&lt;/i&gt;: resource=&#34;PREVIEW&#34;, action=1(CREATE) (user with this permission can view draft store item)&lt;/li&gt;&lt;li&gt;&lt;i&gt;Optional permission&lt;/i&gt;: resource=&#34;SANDBOX&#34;, action=1(CREATE) (user with this permission can view draft store item)&lt;/li&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: the list of items&lt;/li&gt;&lt;/ul&gt;
     */
    getItemsSearch,
    /**
     * This API is used to get item by appId.&lt;p&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Optional permission&lt;/i&gt;: resource=&#34;PREVIEW&#34;, action=1(CREATE) (user with this permission can view draft store item)&lt;/li&gt;&lt;li&gt;&lt;i&gt;Optional permission&lt;/i&gt;: resource=&#34;SANDBOX&#34;, action=1(CREATE) (user with this permission can view draft store item)&lt;/li&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: the item with that appId&lt;/li&gt;&lt;/ul&gt;
     */
    getItemsByAppId,
    /**
     * This API is used to query items by criteria within a store. If item not exist in specific region, default region item will return.&lt;p&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Optional permission&lt;/i&gt;: resource=&#34;PREVIEW&#34;, action=1(CREATE) (user with this permission can view draft store item)&lt;/li&gt;&lt;li&gt;&lt;i&gt;Optional permission&lt;/i&gt;: resource=&#34;SANDBOX&#34;, action=1(CREATE) (user with this permission can view draft store item)&lt;/li&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: the list of items&lt;/li&gt;&lt;/ul&gt;
     */
    getItemsByCriteria,
    /**
     * This API is used to bulk get locale items. If item not exist in specific region, default region item will return.&lt;p&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Optional permission&lt;/i&gt;: resource=&#34;PREVIEW&#34;, action=1(CREATE) (user with this permission can view draft store items)&lt;/li&gt;&lt;li&gt;&lt;i&gt;Optional permission&lt;/i&gt;: resource=&#34;SANDBOX&#34;, action=1(CREATE) (user with this permission can view draft store items)&lt;/li&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: the list of items info&lt;/li&gt;&lt;/ul&gt;
     */
    getItemsLocaleByIds,
    /**
     * This API is used to get estimated prices of item
     */
    getItemsEstimatedPrice,
    /**
     * This API is used to get an item in locale. If item not exist in specific region, default region item will return.&lt;p&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Optional permission&lt;/i&gt;: resource=&#34;PREVIEW&#34;, action=1(CREATE) (user with this permission can view draft store item)&lt;/li&gt;&lt;li&gt;&lt;i&gt;Optional permission&lt;/i&gt;: resource=&#34;SANDBOX&#34;, action=1(CREATE) (user with this permission can view draft store item)&lt;/li&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: item data&lt;/li&gt;&lt;/ul&gt;
     */
    getLocale_ByItemId,
    /**
     * Get item dynamic data for a published item.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: item dynamic data&lt;/li&gt;&lt;/ul&gt;
     */
    getDynamic_ByItemId,
    /**
     * This API is used to get an app in locale. If app not exist in specific region, default region app will return.&lt;p&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Optional permission&lt;/i&gt;: resource=&#34;PREVIEW&#34;, action=1(CREATE) (user with this permission can view draft store app)&lt;/li&gt;&lt;li&gt;&lt;i&gt;Optional permission&lt;/i&gt;: resource=&#34;SANDBOX&#34;, action=1(CREATE) (user with this permission can view draft store app)&lt;/li&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: app data&lt;/li&gt;&lt;/ul&gt;
     */
    getAppLocale_ByItemId,
    /**
     * This API is used to validate user item purchase condition
     */
    createItemPurchaseConditionValidate
  };
}

// src/generated-public/OrderApi.ts
var import_sdk98 = require("@accelbyte/sdk");
function OrderApi(sdk, args) {
  const sdkAssembly = sdk.assembly();
  const namespace = args?.coreConfig?.namespace ?? sdkAssembly.coreConfig.namespace;
  const useSchemaValidation = args?.coreConfig?.useSchemaValidation ?? sdkAssembly.coreConfig.useSchemaValidation;
  let axiosInstance = sdkAssembly.axiosInstance;
  const requestConfigOverrides = args?.axiosConfig?.request;
  const baseURLOverride = args?.coreConfig?.baseURL;
  const interceptorsOverride = args?.axiosConfig?.interceptors ?? [];
  if (requestConfigOverrides || baseURLOverride || interceptorsOverride.length > 0) {
    const requestConfig = import_sdk98.ApiUtils.mergeAxiosConfigs(sdkAssembly.axiosInstance.defaults, {
      ...baseURLOverride ? { baseURL: baseURLOverride } : {},
      ...requestConfigOverrides
    });
    axiosInstance = import_sdk98.Network.create(requestConfig);
    for (const interceptor of interceptorsOverride) {
      if (interceptor.type === "request") {
        axiosInstance.interceptors.request.use(interceptor.onRequest, interceptor.onError);
      }
      if (interceptor.type === "response") {
        axiosInstance.interceptors.response.use(interceptor.onSuccess, interceptor.onError);
      }
    }
  }
  async function getOrders_ByUserId(userId, queryParams) {
    const $ = new Order$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getOrders_ByUserId(userId, queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function createOrder_ByUserId(userId, data) {
    const $ = new Order$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.createOrder_ByUserId(userId, data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getOrder_ByUserId_ByOrderNo(userId, orderNo) {
    const $ = new Order$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getOrder_ByUserId_ByOrderNo(userId, orderNo);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function updateCancel_ByUserId_ByOrderNo(userId, orderNo) {
    const $ = new Order$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.updateCancel_ByUserId_ByOrderNo(userId, orderNo);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function createOrderDiscountPreview_ByUserId(userId, data) {
    const $ = new Order$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.createOrderDiscountPreview_ByUserId(userId, data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getHistory_ByUserId_ByOrderNo(userId, orderNo) {
    const $ = new Order$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getHistory_ByUserId_ByOrderNo(userId, orderNo);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getReceiptPdf_ByUserId_ByOrderNo(userId, orderNo) {
    const $ = new Order$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getReceiptPdf_ByUserId_ByOrderNo(userId, orderNo);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  return {
    /**
     * Query user orders.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: get order&lt;/li&gt;&lt;/ul&gt;
     */
    getOrders_ByUserId,
    /**
     * Create an order. The result contains the checkout link and payment token. User with permission SANDBOX will create sandbox order that not real paid for xsolla/alipay and not validate price for wxpay.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Optional permission(user with this permission will create sandbox order)&lt;/i&gt;: resource=&#34;SANDBOX&#34;, action=1 (CREATE)&lt;/li&gt;&lt;li&gt;It will be forbidden while the user is banned: ORDER_INITIATE or ORDER_AND_PAYMENT&lt;/li&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: created order&lt;/li&gt;&lt;/ul&gt;&lt;h2&gt;Restrictions for ext field&lt;/h2&gt; 1. Cannot use &lt;b&gt;&#34;.&#34;&lt;/b&gt; as the key name - &lt;pre&gt;{ &#34;data.2&#34;: &#34;value&#34; }&lt;/pre&gt; 2. Cannot use &lt;b&gt;&#34;$&#34;&lt;/b&gt; as the prefix in key names - &lt;pre&gt;{ &#34;$data&#34;: &#34;value&#34; }&lt;/pre&gt;
     */
    createOrder_ByUserId,
    /**
     * Get user order.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: get order&lt;/li&gt;&lt;/ul&gt;
     */
    getOrder_ByUserId_ByOrderNo,
    /**
     * Cancel user order.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;/li&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: cancelled order&lt;/li&gt;&lt;/ul&gt;
     */
    updateCancel_ByUserId_ByOrderNo,
    /**
     * Preview order price with discount code, this api is used to auto calc order price with discount code.Notes: this api don&#39;t do full order validation, only check discount code and calc final order price.Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: previewed order&lt;/li&gt;&lt;/ul&gt;
     */
    createOrderDiscountPreview_ByUserId,
    /**
     * Get user order histories.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: get order history&lt;/li&gt;&lt;/ul&gt;
     */
    getHistory_ByUserId_ByOrderNo,
    /**
     * Download user order receipt by orderNo.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: order receipt pdf&lt;/li&gt;&lt;/ul&gt;
     */
    getReceiptPdf_ByUserId_ByOrderNo
  };
}

// src/generated-public/PaymentAccountApi.ts
var import_sdk99 = require("@accelbyte/sdk");
function PaymentAccountApi(sdk, args) {
  const sdkAssembly = sdk.assembly();
  const namespace = args?.coreConfig?.namespace ?? sdkAssembly.coreConfig.namespace;
  const useSchemaValidation = args?.coreConfig?.useSchemaValidation ?? sdkAssembly.coreConfig.useSchemaValidation;
  let axiosInstance = sdkAssembly.axiosInstance;
  const requestConfigOverrides = args?.axiosConfig?.request;
  const baseURLOverride = args?.coreConfig?.baseURL;
  const interceptorsOverride = args?.axiosConfig?.interceptors ?? [];
  if (requestConfigOverrides || baseURLOverride || interceptorsOverride.length > 0) {
    const requestConfig = import_sdk99.ApiUtils.mergeAxiosConfigs(sdkAssembly.axiosInstance.defaults, {
      ...baseURLOverride ? { baseURL: baseURLOverride } : {},
      ...requestConfigOverrides
    });
    axiosInstance = import_sdk99.Network.create(requestConfig);
    for (const interceptor of interceptorsOverride) {
      if (interceptor.type === "request") {
        axiosInstance.interceptors.request.use(interceptor.onRequest, interceptor.onError);
      }
      if (interceptor.type === "response") {
        axiosInstance.interceptors.response.use(interceptor.onSuccess, interceptor.onError);
      }
    }
  }
  async function getPaymentAccounts_ByUserId(userId) {
    const $ = new PaymentAccount$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getPaymentAccounts_ByUserId(userId);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function deletePaymentAccount_ByUserId_ByType_ById(userId, type, id) {
    const $ = new PaymentAccount$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.deletePaymentAccount_ByUserId_ByType_ById(userId, type, id);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  return {
    /**
     * &lt;b&gt;[Not supported yet in AGS Shared Cloud]&lt;/b&gt;Get payment accounts.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: Payment account list&lt;/li&gt;&lt;/ul&gt;
     */
    getPaymentAccounts_ByUserId,
    /**
     * &lt;b&gt;[Not supported yet in AGS Shared Cloud]&lt;/b&gt;Delete payment account.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;:&lt;/li&gt;&lt;/ul&gt;
     */
    deletePaymentAccount_ByUserId_ByType_ById
  };
}

// src/generated-public/PaymentStationApi.ts
var import_sdk100 = require("@accelbyte/sdk");
function PaymentStationApi(sdk, args) {
  const sdkAssembly = sdk.assembly();
  const namespace = args?.coreConfig?.namespace ?? sdkAssembly.coreConfig.namespace;
  const useSchemaValidation = args?.coreConfig?.useSchemaValidation ?? sdkAssembly.coreConfig.useSchemaValidation;
  let axiosInstance = sdkAssembly.axiosInstance;
  const requestConfigOverrides = args?.axiosConfig?.request;
  const baseURLOverride = args?.coreConfig?.baseURL;
  const interceptorsOverride = args?.axiosConfig?.interceptors ?? [];
  if (requestConfigOverrides || baseURLOverride || interceptorsOverride.length > 0) {
    const requestConfig = import_sdk100.ApiUtils.mergeAxiosConfigs(sdkAssembly.axiosInstance.defaults, {
      ...baseURLOverride ? { baseURL: baseURLOverride } : {},
      ...requestConfigOverrides
    });
    axiosInstance = import_sdk100.Network.create(requestConfig);
    for (const interceptor of interceptorsOverride) {
      if (interceptor.type === "request") {
        axiosInstance.interceptors.request.use(interceptor.onRequest, interceptor.onError);
      }
      if (interceptor.type === "response") {
        axiosInstance.interceptors.response.use(interceptor.onSuccess, interceptor.onError);
      }
    }
  }
  async function getPaymentTax(queryParams) {
    const $ = new PaymentStation$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getPaymentTax(queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function createPaymentLink(data) {
    const $ = new PaymentStation$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.createPaymentLink(data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getPaymentQrcode(queryParams) {
    const $ = new PaymentStation$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getPaymentQrcode(queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getPaymentMethods(queryParams) {
    const $ = new PaymentStation$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getPaymentMethods(queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getPaymentReturnurl(queryParams) {
    const $ = new PaymentStation$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getPaymentReturnurl(queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getPaymentPublicconfig(queryParams) {
    const $ = new PaymentStation$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getPaymentPublicconfig(queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getPaymentCustomization(queryParams) {
    const $ = new PaymentStation$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getPaymentCustomization(queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function createPayPayment_ByPaymentOrderNo(paymentOrderNo, data, queryParams) {
    const $ = new PaymentStation$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.createPayPayment_ByPaymentOrderNo(paymentOrderNo, data, queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getInfoPayment_ByPaymentOrderNo(paymentOrderNo) {
    const $ = new PaymentStation$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getInfoPayment_ByPaymentOrderNo(paymentOrderNo);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getStatusPayment_ByPaymentOrderNo(paymentOrderNo) {
    const $ = new PaymentStation$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getStatusPayment_ByPaymentOrderNo(paymentOrderNo);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  return {
    /**
     * &lt;b&gt;[Not supported yet in AGS Shared Cloud]&lt;/b&gt;Check and get a payment order&#39;s should pay tax.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: tax result&lt;/li&gt;&lt;/ul&gt;
     */
    getPaymentTax,
    /**
     * &lt;b&gt;[Not supported yet in AGS Shared Cloud]&lt;/b&gt;Get payment url.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;For Neon Pay payment provider, the &#39;neonPayConfig&#39; field can be used to provide success and cancel URL. If &#39;neonPayConfig&#39; field is not present, the &#39;returnUrl&#39; will be used for both success and cancel URL.&lt;/li&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: Get payment link&lt;/li&gt;&lt;/ul&gt;
     */
    createPaymentLink,
    /**
     * &lt;b&gt;[Not supported yet in AGS Shared Cloud]&lt;/b&gt;Get qrcode.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: QRCode image stream&lt;/li&gt;&lt;/ul&gt;
     */
    getPaymentQrcode,
    /**
     * &lt;b&gt;[Not supported yet in AGS Shared Cloud]&lt;/b&gt;Get payment methods.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: Payment method list&lt;/li&gt;&lt;/ul&gt;
     */
    getPaymentMethods,
    /**
     * &lt;b&gt;[Not supported yet in AGS Shared Cloud]&lt;/b&gt;Normalize payment return url for payment provider&lt;br&gt;Payment response: &lt;table&gt;&lt;tr&gt;&lt;td&gt;Field&lt;/td&gt;&lt;td&gt;Type&lt;/td&gt;&lt;td&gt;Required&lt;/td&gt;&lt;td&gt;Description&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;orderNo&lt;/td&gt;&lt;td&gt;String&lt;/td&gt;&lt;td&gt;Yes&lt;/td&gt;&lt;td&gt;order no&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;paymentStatus&lt;/td&gt;&lt;td&gt;String&lt;/td&gt;&lt;td&gt;Yes&lt;/td&gt;&lt;td&gt;&lt;ul&gt;&lt;li&gt;DONE: The payment was successfully completed.&lt;/li&gt;&lt;li&gt;CANCELLED: The payment was cancelled by the shopper before completion, or the shopper returned to the merchant&#39;s site before completing the transaction.&lt;/li&gt;&lt;li&gt;PENDING: Inform the shopper that you&#39;ve received their order, and are waiting for the payment to be completed. When the shopper has completed the payment you will receive a successful AUTHORISATION.&lt;/li&gt;&lt;li&gt;RECEIVED: Inform the shopper that you&#39;ve received their order, and are waiting for the payment to clear.&lt;/li&gt;&lt;li&gt;UNKNOWN: An error occurred during the payment processing.&lt;/li&gt;&lt;li&gt;FAILED: Shopper paid failed because of various reasons.&lt;/li&gt;&lt;/ul&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;reason&lt;/td&gt;&lt;td&gt;String&lt;/td&gt;&lt;td&gt;No&lt;/td&gt;&lt;td&gt;payment status reason&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;xsolla&lt;/i&gt;: parameters &#39;user_id&#39;, &#39;foreinginvoice&#39;, &#39;invoice_id&#39; and &#39;status&#39; will be automatically added to the link&lt;/li&gt;&lt;li&gt;&lt;i&gt;adyen&lt;/i&gt;: https://docs.adyen.com/developers/checkout/web-sdk&lt;/li&gt;&lt;/ul&gt;
     */
    getPaymentReturnurl,
    /**
     * &lt;b&gt;[Not supported yet in AGS Shared Cloud]&lt;/b&gt;Get payment provider public config, at current only Strip provide public config.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: Public config&lt;/li&gt;&lt;/ul&gt;
     */
    getPaymentPublicconfig,
    /**
     * @deprecated
     * &lt;b&gt;[Not supported yet in AGS Shared Cloud]&lt;/b&gt;Get payment provider customization, at current only Adyen provide customization. This api has been deprecated, pls use /public/namespaces/{namespace}/payment/publicconfig to get adyen config&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: customization&lt;/li&gt;&lt;/ul&gt;
     */
    getPaymentCustomization,
    /**
     * &lt;b&gt;[Not supported yet in AGS Shared Cloud]&lt;/b&gt;Do payment(For now, this only support checkout.com).&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: Payment process result&lt;/li&gt;&lt;/ul&gt;
     */
    createPayPayment_ByPaymentOrderNo,
    /**
     * &lt;b&gt;[Not supported yet in AGS Shared Cloud]&lt;/b&gt;Get payment order info.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: Payment order details&lt;/li&gt;&lt;/ul&gt;
     */
    getInfoPayment_ByPaymentOrderNo,
    /**
     * &lt;b&gt;[Not supported yet in AGS Shared Cloud]&lt;/b&gt;Check payment order paid status.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: Payment order paid result&lt;/li&gt;&lt;/ul&gt;
     */
    getStatusPayment_ByPaymentOrderNo
  };
}

// src/generated-public/RewardApi.ts
var import_sdk101 = require("@accelbyte/sdk");
function RewardApi(sdk, args) {
  const sdkAssembly = sdk.assembly();
  const namespace = args?.coreConfig?.namespace ?? sdkAssembly.coreConfig.namespace;
  const useSchemaValidation = args?.coreConfig?.useSchemaValidation ?? sdkAssembly.coreConfig.useSchemaValidation;
  let axiosInstance = sdkAssembly.axiosInstance;
  const requestConfigOverrides = args?.axiosConfig?.request;
  const baseURLOverride = args?.coreConfig?.baseURL;
  const interceptorsOverride = args?.axiosConfig?.interceptors ?? [];
  if (requestConfigOverrides || baseURLOverride || interceptorsOverride.length > 0) {
    const requestConfig = import_sdk101.ApiUtils.mergeAxiosConfigs(sdkAssembly.axiosInstance.defaults, {
      ...baseURLOverride ? { baseURL: baseURLOverride } : {},
      ...requestConfigOverrides
    });
    axiosInstance = import_sdk101.Network.create(requestConfig);
    for (const interceptor of interceptorsOverride) {
      if (interceptor.type === "request") {
        axiosInstance.interceptors.request.use(interceptor.onRequest, interceptor.onError);
      }
      if (interceptor.type === "response") {
        axiosInstance.interceptors.response.use(interceptor.onSuccess, interceptor.onError);
      }
    }
  }
  async function getRewardsByCode(queryParams) {
    const $ = new Reward$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getRewardsByCode(queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getReward_ByRewardId(rewardId) {
    const $ = new Reward$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getReward_ByRewardId(rewardId);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getRewardsByCriteria(queryParams) {
    const $ = new Reward$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getRewardsByCriteria(queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  return {
    /**
     * This API is used to get reward by reward code.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: reward instance&lt;/li&gt;&lt;/ul&gt;
     */
    getRewardsByCode,
    /**
     * This API is used to get reward by reward Id.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: reward instance&lt;/li&gt;&lt;/ul&gt;
     */
    getReward_ByRewardId,
    /**
     * This API is used to query rewards by criteria.&lt;p&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: the list of rewards&lt;/li&gt;&lt;/ul&gt;
     */
    getRewardsByCriteria
  };
}

// src/generated-public/SectionApi.ts
var import_sdk102 = require("@accelbyte/sdk");
function SectionApi(sdk, args) {
  const sdkAssembly = sdk.assembly();
  const namespace = args?.coreConfig?.namespace ?? sdkAssembly.coreConfig.namespace;
  const useSchemaValidation = args?.coreConfig?.useSchemaValidation ?? sdkAssembly.coreConfig.useSchemaValidation;
  let axiosInstance = sdkAssembly.axiosInstance;
  const requestConfigOverrides = args?.axiosConfig?.request;
  const baseURLOverride = args?.coreConfig?.baseURL;
  const interceptorsOverride = args?.axiosConfig?.interceptors ?? [];
  if (requestConfigOverrides || baseURLOverride || interceptorsOverride.length > 0) {
    const requestConfig = import_sdk102.ApiUtils.mergeAxiosConfigs(sdkAssembly.axiosInstance.defaults, {
      ...baseURLOverride ? { baseURL: baseURLOverride } : {},
      ...requestConfigOverrides
    });
    axiosInstance = import_sdk102.Network.create(requestConfig);
    for (const interceptor of interceptorsOverride) {
      if (interceptor.type === "request") {
        axiosInstance.interceptors.request.use(interceptor.onRequest, interceptor.onError);
      }
      if (interceptor.type === "response") {
        axiosInstance.interceptors.response.use(interceptor.onSuccess, interceptor.onError);
      }
    }
  }
  async function getSections_ByUserId(userId, queryParams) {
    const $ = new Section$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getSections_ByUserId(userId, queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  return {
    /**
     * This API is used to list active section contents.&lt;p&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Optional permission&lt;/i&gt;: resource=&#34;PREVIEW&#34;, action=1(CREATE) (user with this permission can view draft store sections)&lt;/li&gt;&lt;li&gt;&lt;i&gt;Optional permission&lt;/i&gt;: resource=&#34;SANDBOX&#34;, action=1(CREATE) (user with this permission can view draft store sections)&lt;/li&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: active section contents&lt;/li&gt;&lt;/ul&gt;
     */
    getSections_ByUserId
  };
}

// src/generated-public/StoreApi.ts
var import_sdk103 = require("@accelbyte/sdk");
function StoreApi(sdk, args) {
  const sdkAssembly = sdk.assembly();
  const namespace = args?.coreConfig?.namespace ?? sdkAssembly.coreConfig.namespace;
  const useSchemaValidation = args?.coreConfig?.useSchemaValidation ?? sdkAssembly.coreConfig.useSchemaValidation;
  let axiosInstance = sdkAssembly.axiosInstance;
  const requestConfigOverrides = args?.axiosConfig?.request;
  const baseURLOverride = args?.coreConfig?.baseURL;
  const interceptorsOverride = args?.axiosConfig?.interceptors ?? [];
  if (requestConfigOverrides || baseURLOverride || interceptorsOverride.length > 0) {
    const requestConfig = import_sdk103.ApiUtils.mergeAxiosConfigs(sdkAssembly.axiosInstance.defaults, {
      ...baseURLOverride ? { baseURL: baseURLOverride } : {},
      ...requestConfigOverrides
    });
    axiosInstance = import_sdk103.Network.create(requestConfig);
    for (const interceptor of interceptorsOverride) {
      if (interceptor.type === "request") {
        axiosInstance.interceptors.request.use(interceptor.onRequest, interceptor.onError);
      }
      if (interceptor.type === "response") {
        axiosInstance.interceptors.response.use(interceptor.onSuccess, interceptor.onError);
      }
    }
  }
  async function getStores() {
    const $ = new Store$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getStores();
    if (resp.error) throw resp.error;
    return resp.response;
  }
  return {
    /**
     * This API is used to list all stores in a namespace.&lt;p&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Optional permission&lt;/i&gt;: resource=&#34;PREVIEW&#34;, action=1(CREATE) (user with this permission can view draft store)&lt;/li&gt;&lt;li&gt;&lt;i&gt;Optional permission&lt;/i&gt;: resource=&#34;SANDBOX&#34;, action=1(CREATE) (user with this permission can view draft store)&lt;/li&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: the list of stores&lt;/li&gt;&lt;/ul&gt;
     */
    getStores
  };
}

// src/generated-public/SubscriptionApi.ts
var import_sdk104 = require("@accelbyte/sdk");
function SubscriptionApi(sdk, args) {
  const sdkAssembly = sdk.assembly();
  const namespace = args?.coreConfig?.namespace ?? sdkAssembly.coreConfig.namespace;
  const useSchemaValidation = args?.coreConfig?.useSchemaValidation ?? sdkAssembly.coreConfig.useSchemaValidation;
  let axiosInstance = sdkAssembly.axiosInstance;
  const requestConfigOverrides = args?.axiosConfig?.request;
  const baseURLOverride = args?.coreConfig?.baseURL;
  const interceptorsOverride = args?.axiosConfig?.interceptors ?? [];
  if (requestConfigOverrides || baseURLOverride || interceptorsOverride.length > 0) {
    const requestConfig = import_sdk104.ApiUtils.mergeAxiosConfigs(sdkAssembly.axiosInstance.defaults, {
      ...baseURLOverride ? { baseURL: baseURLOverride } : {},
      ...requestConfigOverrides
    });
    axiosInstance = import_sdk104.Network.create(requestConfig);
    for (const interceptor of interceptorsOverride) {
      if (interceptor.type === "request") {
        axiosInstance.interceptors.request.use(interceptor.onRequest, interceptor.onError);
      }
      if (interceptor.type === "response") {
        axiosInstance.interceptors.response.use(interceptor.onSuccess, interceptor.onError);
      }
    }
  }
  async function getSubscriptions_ByUserId(userId, queryParams) {
    const $ = new Subscription$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getSubscriptions_ByUserId(userId, queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function createSubscription_ByUserId(userId, data) {
    const $ = new Subscription$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.createSubscription_ByUserId(userId, data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getSubscription_ByUserId_BySubscriptionId(userId, subscriptionId) {
    const $ = new Subscription$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getSubscription_ByUserId_BySubscriptionId(userId, subscriptionId);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getSubscriptionsSubscribableByItemId_ByUserId(userId, queryParams) {
    const $ = new Subscription$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getSubscriptionsSubscribableByItemId_ByUserId(userId, queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function updateCancel_ByUserId_BySubscriptionId(userId, subscriptionId, data) {
    const $ = new Subscription$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.updateCancel_ByUserId_BySubscriptionId(userId, subscriptionId, data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getHistory_ByUserId_BySubscriptionId(userId, subscriptionId, queryParams) {
    const $ = new Subscription$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getHistory_ByUserId_BySubscriptionId(userId, subscriptionId, queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function updateBillingAccount_ByUserId_BySubscriptionId(userId, subscriptionId) {
    const $ = new Subscription$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.updateBillingAccount_ByUserId_BySubscriptionId(userId, subscriptionId);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  return {
    /**
     * Query user subscriptions.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: paginated subscription&lt;/li&gt;&lt;/ul&gt;
     */
    getSubscriptions_ByUserId,
    /**
     * Subscribe a subscription. Support both real and virtual payment. Need go through payment flow using the paymentOrderNo if paymentFlowRequired true.&lt;br&gt;&lt;b&gt;ACTIVE USER subscription can&#39;t do subscribe again.&lt;/b&gt;&lt;br&gt;&lt;b&gt;The next billing date will be X(default 4) hours before the current period ends if correctly subscribed.&lt;/b&gt;&lt;br&gt;User with permission SANDBOX will create sandbox subscription that not real paid.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Optional permission(user with this permission will create sandbox subscription)&lt;/i&gt;: resource=&#34;SANDBOX&#34;, action=1 (CREATE)&lt;/li&gt;&lt;li&gt;It will be forbidden while the user is banned: ORDER_INITIATE or ORDER_AND_PAYMENT&lt;/li&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: created subscription&lt;/li&gt;&lt;/ul&gt;
     */
    createSubscription_ByUserId,
    /**
     * Get user subscription.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: subscription&lt;/li&gt;&lt;/ul&gt;
     */
    getSubscription_ByUserId_BySubscriptionId,
    /**
     * Check user subscription subscribable by itemId, ACTIVE USER subscription can&#39;t do subscribe again.&lt;p&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: subscribable info&lt;/li&gt;&lt;/ul&gt;
     */
    getSubscriptionsSubscribableByItemId_ByUserId,
    /**
     * Cancel a subscription, only ACTIVE subscription can be cancelled. &lt;b&gt;Ensure successfully cancel, recommend at least 1 day before current period ends, otherwise it may be charging or charged.&lt;/b&gt;&lt;br&gt;Set immediate true, the subscription will be terminated immediately, otherwise till the end of current billing cycle.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: cancelled subscription&lt;/li&gt;&lt;/ul&gt;
     */
    updateCancel_ByUserId_BySubscriptionId,
    /**
     * Get user subscription billing histories.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: paginated subscription history&lt;/li&gt;&lt;/ul&gt;
     */
    getHistory_ByUserId_BySubscriptionId,
    /**
     * Request to change a subscription billing account, this will guide user to payment station. The actual change will happen at the 0 payment notification successfully handled.&lt;br&gt;Only ACTIVE USER subscription with real currency billing account can be changed.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: updated subscription&lt;/li&gt;&lt;/ul&gt;
     */
    updateBillingAccount_ByUserId_BySubscriptionId
  };
}

// src/generated-public/ViewApi.ts
var import_sdk105 = require("@accelbyte/sdk");
function ViewApi(sdk, args) {
  const sdkAssembly = sdk.assembly();
  const namespace = args?.coreConfig?.namespace ?? sdkAssembly.coreConfig.namespace;
  const useSchemaValidation = args?.coreConfig?.useSchemaValidation ?? sdkAssembly.coreConfig.useSchemaValidation;
  let axiosInstance = sdkAssembly.axiosInstance;
  const requestConfigOverrides = args?.axiosConfig?.request;
  const baseURLOverride = args?.coreConfig?.baseURL;
  const interceptorsOverride = args?.axiosConfig?.interceptors ?? [];
  if (requestConfigOverrides || baseURLOverride || interceptorsOverride.length > 0) {
    const requestConfig = import_sdk105.ApiUtils.mergeAxiosConfigs(sdkAssembly.axiosInstance.defaults, {
      ...baseURLOverride ? { baseURL: baseURLOverride } : {},
      ...requestConfigOverrides
    });
    axiosInstance = import_sdk105.Network.create(requestConfig);
    for (const interceptor of interceptorsOverride) {
      if (interceptor.type === "request") {
        axiosInstance.interceptors.request.use(interceptor.onRequest, interceptor.onError);
      }
      if (interceptor.type === "response") {
        axiosInstance.interceptors.response.use(interceptor.onSuccess, interceptor.onError);
      }
    }
  }
  async function getViews_ByUserId(userId, queryParams) {
    const $ = new View$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getViews_ByUserId(userId, queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  return {
    /**
     * This API is used to get all views.&lt;p&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Optional permission&lt;/i&gt;: resource=&#34;PREVIEW&#34;, action=1(CREATE) (user with this permission can view draft store views)&lt;/li&gt;&lt;li&gt;&lt;i&gt;Optional permission&lt;/i&gt;: resource=&#34;SANDBOX&#34;, action=1(CREATE) (user with this permission can view draft store views)&lt;/li&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: all views&lt;/li&gt;&lt;/ul&gt;
     */
    getViews_ByUserId
  };
}

// src/generated-public/WalletApi.ts
var import_sdk106 = require("@accelbyte/sdk");
function WalletApi(sdk, args) {
  const sdkAssembly = sdk.assembly();
  const namespace = args?.coreConfig?.namespace ?? sdkAssembly.coreConfig.namespace;
  const useSchemaValidation = args?.coreConfig?.useSchemaValidation ?? sdkAssembly.coreConfig.useSchemaValidation;
  let axiosInstance = sdkAssembly.axiosInstance;
  const requestConfigOverrides = args?.axiosConfig?.request;
  const baseURLOverride = args?.coreConfig?.baseURL;
  const interceptorsOverride = args?.axiosConfig?.interceptors ?? [];
  if (requestConfigOverrides || baseURLOverride || interceptorsOverride.length > 0) {
    const requestConfig = import_sdk106.ApiUtils.mergeAxiosConfigs(sdkAssembly.axiosInstance.defaults, {
      ...baseURLOverride ? { baseURL: baseURLOverride } : {},
      ...requestConfigOverrides
    });
    axiosInstance = import_sdk106.Network.create(requestConfig);
    for (const interceptor of interceptorsOverride) {
      if (interceptor.type === "request") {
        axiosInstance.interceptors.request.use(interceptor.onRequest, interceptor.onError);
      }
      if (interceptor.type === "response") {
        axiosInstance.interceptors.response.use(interceptor.onSuccess, interceptor.onError);
      }
    }
  }
  async function getUserMeWallet_ByCurrencyCode(currencyCode) {
    const $ = new Wallet$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getUserMeWallet_ByCurrencyCode(currencyCode);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getWallet_ByUserId_ByCurrencyCode(userId, currencyCode) {
    const $ = new Wallet$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getWallet_ByUserId_ByCurrencyCode(userId, currencyCode);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getTransactions_ByUserId_ByCurrencyCode(userId, currencyCode, queryParams) {
    const $ = new Wallet$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getTransactions_ByUserId_ByCurrencyCode(userId, currencyCode, queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  return {
    /**
     * get my wallet by currency code and namespace.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: wallet info&lt;/li&gt;&lt;li&gt;&lt;i&gt;Path&#39;s namespace&lt;/i&gt; : &lt;ul&gt; &lt;li&gt;can be filled with &lt;b&gt;publisher namespace&lt;/b&gt; in order to get &lt;b&gt;publisher user wallet&lt;/b&gt;&lt;/li&gt; &lt;li&gt;can be filled with &lt;b&gt;game namespace&lt;/b&gt; in order to get &lt;b&gt;game user wallet&lt;/b&gt;&lt;/li&gt; &lt;/ul&gt;&lt;/li&gt;&lt;/ul&gt;
     */
    getUserMeWallet_ByCurrencyCode,
    /**
     * get a wallet by currency code.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: wallet info&lt;/li&gt;&lt;/ul&gt;
     */
    getWallet_ByUserId_ByCurrencyCode,
    /**
     * List wallet transactions by currency code ordered by create time desc.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: currency transaction info&lt;/li&gt;&lt;/ul&gt;
     */
    getTransactions_ByUserId_ByCurrencyCode
  };
}

// package.json
var name = "@accelbyte/sdk-platform";
var version = "6.0.0";
var author = "AccelByte Inc";

// src/Platform.ts
console.log(`${name}@${version}`);
var apis = {
  OrderDedicatedAdminApi,
  ItemAdminApi,
  PaymentDedicatedAdminApi,
  PaymentConfigAdminApi,
  FulfillmentScriptAdminApi,
  ViewAdminApi,
  OrderAdminApi,
  StoreAdminApi,
  RewardAdminApi,
  WalletAdminApi,
  SectionAdminApi,
  CampaignAdminApi,
  KeyGroupAdminApi,
  CategoryAdminApi,
  CurrencyAdminApi,
  EntitlementAdminApi,
  TradeActionAdminApi,
  SubscriptionAdminApi,
  IapAdminApi,
  PaymentAdminApi,
  DlcAdminApi,
  InvoiceAdminApi,
  FulfillmentAdminApi,
  IapNotificationAdminApi,
  IapSubscriptionAdminApi,
  RevocationAdminApi,
  TicketAdminApi,
  ServicePluginConfigAdminApi,
  ClawbackAdminApi,
  PaymentCallbackConfigAdminApi,
  SessionPlatformAdminApi,
  AchievementPlatformAdminApi,
  AnonymizationAdminApi,
  PlatformAccountClosureAdminApi,
  CatalogChangesAdminApi,
  PlatformAdminApi,
  DlcApi,
  StoreApi,
  CategoryApi,
  CurrencyApi,
  ItemApi,
  PaymentStationApi,
  RewardApi,
  IapApi,
  ViewApi,
  OrderApi,
  SectionApi,
  EntitlementApi,
  SubscriptionApi,
  FulfillmentApi,
  PaymentAccountApi,
  WalletApi,
  IapSubscriptionApi,
  version: () => console.log({
    version,
    name,
    author
  })
};
var Platform = apis;

// src/custom/clients/Ecommerce.ts
var OrderStatus = Order.shape.status.unwrap().unwrap();

// src/custom/clients/PlatformClient.ts
var _PlatformClient = class _PlatformClient {
  static async getCurrencyMap(sdk) {
    const { data: currencies } = await Platform.CurrencyApi(sdk).getCurrencies();
    const currMap = currencies.reduce(
      (currencyMap, cr) => {
        currencyMap.set(cr.currencyCode, cr);
        return currencyMap;
      },
      /* @__PURE__ */ new Map()
    );
    return currMap;
  }
};
/**
 * get a map of wallet represented by its currency code. Taken from LegacyWalletApi
 */
_PlatformClient.getWalletMap = async (userId, currencyCodes, sdk) => {
  const wallets = await Promise.all(
    currencyCodes.map(
      (currencyCode) => Platform.WalletApi(sdk).getWallet_ByUserId_ByCurrencyCode(userId, currencyCode).then((result2) => {
        return result2.data;
      }).catch((error) => {
        throw error;
      })
    )
  );
  const result = wallets.reduce(
    (map, wallet) => {
      map.set(wallet.currencyCode, wallet);
      return map;
    },
    /* @__PURE__ */ new Map()
  );
  return result;
};
/**
 * Fetch all information needed for a user to check the user's availability to purchase the item
 */
_PlatformClient.fetchPrePurchaseInformation = async ({ userId, item, sdk }) => {
  const [currencyMapResult, availableItemInfoResult, itemOwnershipResult, baseAppOwnershipResult, purchaseConditionValidationResult] = await Promise.all([
    _PlatformClient.getCurrencyMap(sdk),
    Platform.ItemApi(sdk).getDynamic_ByItemId(item.itemId),
    userId && item.itemId ? Platform.EntitlementApi(sdk).getEntitlementsOwnershipAny_ByUserId(userId, {
      itemIds: [item.itemId].filter(Boolean)
    }) : null,
    userId && item.baseAppId ? Platform.EntitlementApi(sdk).getEntitlementsOwnershipAny_ByUserId(userId, {
      appIds: [item.baseAppId].filter(Boolean)
    }) : null,
    userId ? Platform.ItemApi(sdk).createItemPurchaseConditionValidate({
      itemIds: [item.itemId]
    }) : null
  ]);
  return {
    currencyMapResult,
    availableItemInfoResult,
    itemOwnershipResult,
    baseAppOwnershipResult,
    purchaseConditionValidationResult
  };
};
var PlatformClient = _PlatformClient;
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  AchievementInfo,
  AchievementPlatformAdmin$,
  AchievementPlatformAdminApi,
  Action,
  ActionRequest,
  AdditionalData,
  AdditionalDataEntitlement,
  AdminEntitlementDecrement,
  AdminEntitlementSoldRequest,
  AdminOrderCreate,
  AdyenConfig,
  AliPayConfig,
  AnonymizationAdmin$,
  AnonymizationAdminApi,
  AppConfig,
  AppEntitlementInfo,
  AppEntitlementPagingSlicedResult,
  AppInfo,
  AppLocalization,
  AppUpdate,
  AppleIapConfigInfo,
  AppleIapConfigRequest,
  AppleIapConfigVersionInfo,
  AppleIapReceipt,
  AppleIapRequest,
  AvailableComparison,
  AvailablePredicate,
  AvailablePredicateArray,
  AvailablePrice,
  BaseCustomConfig,
  BaseTlsConfig,
  BasicCategoryInfo,
  BasicCategoryInfoArray,
  BasicItem,
  BasicItemArray,
  BillingAccount,
  BillingHistoryInfo,
  BillingHistoryPagingSlicedResult,
  BinarySchema,
  BoxItem,
  BulkCreditRequest,
  BulkCreditResult,
  BulkDebitRequest,
  BulkDebitResult,
  BulkEntitlementGrantRequest,
  BulkEntitlementGrantResult,
  BulkEntitlementRevokeResult,
  BulkOperationResult,
  BulkRegionDataChangeRequest,
  BundledItemInfo,
  CampaignAdmin$,
  CampaignAdminApi,
  CampaignBatchNameChange,
  CampaignBatchNameInfo,
  CampaignBatchNameInfoArray,
  CampaignCreate,
  CampaignDynamicInfo,
  CampaignIfc,
  CampaignInfo,
  CampaignPagingSlicedResult,
  CampaignUpdate,
  CancelRequest,
  CatalogChangeInfo,
  CatalogChangePagingResult,
  CatalogChangeStatistics,
  CatalogChangesAdmin$,
  CatalogChangesAdminApi,
  CatalogConfigInfo,
  CatalogConfigUpdate,
  CatalogDefinitionInfo,
  CatalogDefinitionInfoArray,
  Category$,
  CategoryAdmin$,
  CategoryAdminApi,
  CategoryApi,
  CategoryCreate,
  CategoryInfo,
  CategoryInfoArray,
  CategoryUpdate,
  CheckoutConfig,
  ClawbackAdmin$,
  ClawbackAdminApi,
  ClawbackInfo,
  ClientRequestParameter,
  ClientTransaction,
  CodeCreate,
  CodeCreateResult,
  CodeInfo,
  CodeInfoPagingSlicedResult,
  ConditionGroup,
  ConditionGroupValidateResult,
  ConditionMatchResult,
  ConsumableEntitlementRevocationConfig,
  ConsumeItem,
  CreditPayload,
  CreditRequest,
  CreditResult,
  CreditRevocation,
  CreditSummary,
  Currency$,
  CurrencyAdmin$,
  CurrencyAdminApi,
  CurrencyApi,
  CurrencyConfig,
  CurrencyCreate,
  CurrencyInfo,
  CurrencyInfoArray,
  CurrencySummary,
  CurrencyUpdate,
  CurrencyWallet,
  CurrencyWalletArray,
  Customization,
  DebitByCurrencyCodeRequest,
  DebitByWalletPlatformRequest,
  DebitPayload,
  DebitRequest,
  DebitResult,
  DeductionDetail,
  DeleteRewardConditionRequest,
  DetailedWalletTransactionInfo,
  DetailedWalletTransactionPagingSlicedResult,
  DiscountCategory,
  DiscountCodeDeductionDetail,
  DiscountCodeInfo,
  DiscountConfig,
  DiscountItem,
  Dlc$,
  DlcAdmin$,
  DlcAdminApi,
  DlcApi,
  DlcConfigRewardShortInfo,
  DlcItem,
  DlcItemConfigInfo,
  DlcItemConfigUpdate,
  DlcRecord,
  DurableEntitlementRevocationConfig,
  Entitlement$,
  EntitlementAdmin$,
  EntitlementAdminApi,
  EntitlementApi,
  EntitlementConfigInfo,
  EntitlementDecrementResult,
  EntitlementGrant,
  EntitlementGrantResult,
  EntitlementHistoryInfo,
  EntitlementHistoryInfoArray,
  EntitlementIfc,
  EntitlementInfo,
  EntitlementInfoArray,
  EntitlementLootBoxReward,
  EntitlementOriginSyncResult,
  EntitlementOwnership,
  EntitlementOwnershipArray,
  EntitlementPagingSlicedResult,
  EntitlementPlatformConfigInfo,
  EntitlementPlatformConfigUpdate,
  EntitlementPrechekResult,
  EntitlementRevocation,
  EntitlementRevocationConfig,
  EntitlementRevokeRequest,
  EntitlementRevokeResult,
  EntitlementSoldRequest,
  EntitlementSoldResult,
  EntitlementSplitRequest,
  EntitlementSplitResult,
  EntitlementSummary,
  EntitlementTransferRequest,
  EntitlementTransferResult,
  EntitlementUpdate,
  EpicGamesDlcSyncRequest,
  EpicGamesIapConfigInfo,
  EpicGamesIapConfigRequest,
  EpicGamesReconcileRequest,
  EpicGamesReconcileResult,
  EpicGamesReconcileResultArray,
  ErrorEntity,
  EstimatedPriceInfo,
  EstimatedPriceInfoArray,
  EventAdditionalData,
  EventPayload,
  ExportStoreRequest,
  ExportStoreToCsvRequest,
  ExtensionFulfillmentSummary,
  ExternalPaymentOrderCreate,
  FieldValidationError,
  FixedPeriodRotationConfig,
  FulFillItemPayload,
  FulfillBundledItemResult,
  FulfillCodeRequest,
  FulfillItemResult,
  Fulfillment$,
  FulfillmentActionHistory,
  FulfillmentAdmin$,
  FulfillmentAdminApi,
  FulfillmentApi,
  FulfillmentError,
  FulfillmentHistoryInfo,
  FulfillmentHistoryPagingSlicedResult,
  FulfillmentInfo,
  FulfillmentItem,
  FulfillmentItemArray,
  FulfillmentPagingSlicedResult,
  FulfillmentRequest,
  FulfillmentResult,
  FulfillmentScriptAdmin$,
  FulfillmentScriptAdminApi,
  FulfillmentScriptCreate,
  FulfillmentScriptInfo,
  FulfillmentScriptInfoArray,
  FulfillmentScriptUpdate,
  FulfillmentStateInfo,
  FulfillmentV2Request,
  FulfillmentV2RequestItem,
  FulfillmentV2Result,
  FullAppInfo,
  FullCategoryInfo,
  FullCategoryInfoArray,
  FullItemInfo,
  FullItemInfoArray,
  FullItemPagingResult,
  FullItemPagingSlicedResult,
  FullSectionInfo,
  FullViewInfo,
  GoogleIapConfigInfo,
  GoogleIapConfigRequest,
  GoogleIapReceipt,
  GoogleReceiptResolveResult,
  GrantSubscriptionDaysRequest,
  GrpcServerInfo,
  HierarchicalCategoryInfo,
  HierarchicalCategoryInfoArray,
  Iap$,
  IapAdmin$,
  IapAdminApi,
  IapApi,
  IapClawbackPagingSlicedResult,
  IapConsumeHistoryInfo,
  IapConsumeHistoryPagingSlicedResult,
  IapItemConfigInfo,
  IapItemConfigUpdate,
  IapItemEntry,
  IapItemFlatEntry,
  IapItemMappingInfo,
  IapNotificationAdmin$,
  IapNotificationAdminApi,
  IapOrderInfo,
  IapOrderPagingSlicedResult,
  IapSubscription$,
  IapSubscriptionAdmin$,
  IapSubscriptionAdminApi,
  IapSubscriptionApi,
  Image,
  ImportErrorDetails,
  ImportStoreAppInfo,
  ImportStoreCategoryInfo,
  ImportStoreError,
  ImportStoreHistoryInfo,
  ImportStoreHistoryPagingResult,
  ImportStoreItemInfo,
  ImportStoreResult,
  ImportStoreSectionInfo,
  ImportStoreViewInfo,
  InGameItemSync,
  InventoryConfig,
  InvoiceAdmin$,
  InvoiceAdminApi,
  InvoiceCurrencySummary,
  InvoiceSummary,
  Item$,
  ItemAcquireRequest,
  ItemAcquireResult,
  ItemAdmin$,
  ItemAdminApi,
  ItemApi,
  ItemCreate,
  ItemDynamicDataInfo,
  ItemId,
  ItemIdArray,
  ItemInfo,
  ItemInfoArray,
  ItemNaming,
  ItemPagingSlicedResult,
  ItemPurchaseConditionValidateRequest,
  ItemPurchaseConditionValidateResult,
  ItemPurchaseConditionValidateResultArray,
  ItemReturnRequest,
  ItemRevocation,
  ItemSnapshot,
  ItemTypeConfigCreate,
  ItemTypeConfigInfo,
  ItemTypeConfigInfoArray,
  ItemTypeConfigUpdate,
  ItemUpdate,
  KeyGroupAdmin$,
  KeyGroupAdminApi,
  KeyGroupCreate,
  KeyGroupDynamicInfo,
  KeyGroupInfo,
  KeyGroupPagingSlicedResult,
  KeyGroupUpdate,
  KeyInfo,
  KeyPagingSliceResult,
  ListViewInfo,
  ListViewInfoArray,
  Localization,
  LootBoxConfig,
  LootBoxPluginConfigInfo,
  LootBoxPluginConfigUpdate,
  LootBoxReward,
  MockIapReceipt,
  NeonPayConfig,
  NotificationPagingSlicedResult,
  NotificationProcessResult,
  OculusIapConfigInfo,
  OculusIapConfigRequest,
  OculusReconcileResult,
  OculusReconcileResultArray,
  Operation,
  OperationRequest,
  OptionBoxConfig,
  Order,
  Order$,
  OrderAdmin$,
  OrderAdminApi,
  OrderApi,
  OrderBundleItemInfo,
  OrderCreate,
  OrderCreationOptions,
  OrderDedicatedAdmin$,
  OrderDedicatedAdminApi,
  OrderDiscountPreviewRequest,
  OrderDiscountPreviewResponse,
  OrderGrantInfo,
  OrderHistoryInfo,
  OrderHistoryInfoArray,
  OrderInfo,
  OrderPagingResult,
  OrderPagingSlicedResult,
  OrderRefundCreate,
  OrderStatistics,
  OrderStatus,
  OrderSummary,
  OrderSyncResult,
  OrderUpdate,
  Ownership,
  OwnershipToken,
  Paging,
  PayPalConfig,
  PaymentAccount,
  PaymentAccount$,
  PaymentAccountApi,
  PaymentAccountArray,
  PaymentAdmin$,
  PaymentAdminApi,
  PaymentCallbackConfigAdmin$,
  PaymentCallbackConfigAdminApi,
  PaymentCallbackConfigInfo,
  PaymentCallbackConfigUpdate,
  PaymentConfigAdmin$,
  PaymentConfigAdminApi,
  PaymentData,
  PaymentDedicatedAdmin$,
  PaymentDedicatedAdminApi,
  PaymentDomainWhitelistConfigEdit,
  PaymentDomainWhitelistConfigInfo,
  PaymentMerchantConfigInfo,
  PaymentMethod,
  PaymentMethodArray,
  PaymentNotificationInfo,
  PaymentNotificationPagingSlicedResult,
  PaymentOrder,
  PaymentOrderChargeRequest,
  PaymentOrderChargeStatus,
  PaymentOrderCreate,
  PaymentOrderCreateResult,
  PaymentOrderDetails,
  PaymentOrderInfo,
  PaymentOrderNeonPayConfig,
  PaymentOrderNotifySimulation,
  PaymentOrderPagingSlicedResult,
  PaymentOrderPaidResult,
  PaymentOrderRefund,
  PaymentOrderRefundResult,
  PaymentOrderSyncResult,
  PaymentProcessResult,
  PaymentProviderConfigEdit,
  PaymentProviderConfigInfo,
  PaymentProviderConfigPagingSlicedResult,
  PaymentRequest,
  PaymentStation$,
  PaymentStationApi,
  PaymentTaxConfigEdit,
  PaymentTaxConfigInfo,
  PaymentToken,
  PaymentUrl,
  PaymentUrlCreate,
  Permission,
  Platform,
  PlatformAccountClosureAdmin$,
  PlatformAccountClosureAdminApi,
  PlatformAccountClosureHistoryInfo,
  PlatformAccountClosureHistoryInfoArray,
  PlatformAdmin$,
  PlatformAdminApi,
  PlatformClient,
  PlatformDlcConfigInfo,
  PlatformDlcConfigUpdate,
  PlatformDlcEntry,
  PlatformOwnership,
  PlatformReward,
  PlatformRewardCurrency,
  PlatformRewardItem,
  PlatformSubscribeRequest,
  PlatformWallet,
  PlatformWalletConfigInfo,
  PlatformWalletConfigUpdate,
  PlayStationDlcSyncMultiServiceLabelsRequest,
  PlayStationDlcSyncRequest,
  PlayStationIapConfigInfo,
  PlayStationMultiServiceLabelsReconcileRequest,
  PlayStationReconcileRequest,
  PlayStationReconcileResult,
  PlayStationReconcileResultArray,
  PlaystationIapConfigRequest,
  PopulatedItemInfo,
  PreCheckFulfillmentRequest,
  Predicate,
  PredicateValidateResult,
  PsnEntitlementOwnershipRequest,
  PublicCustomConfigInfo,
  PublicEntitlementDecrement,
  PublicEntitlementHistoryInfo,
  PublicEntitlementMetadata,
  PurchaseCondition,
  PurchaseConditionUpdate,
  PurchasedItemCount,
  Recurring,
  RecurringChargeResult,
  RedeemHistoryInfo,
  RedeemHistoryPagingSlicedResult,
  RedeemRequest,
  RedeemResult,
  RedeemableItem,
  RegionDataChange,
  RegionDataItem,
  RegionDataItemDto,
  RequestHistory,
  Requirement,
  RevocationAdmin$,
  RevocationAdminApi,
  RevocationConfigInfo,
  RevocationConfigUpdate,
  RevocationError,
  RevocationHistoryInfo,
  RevocationHistoryPagingSlicedResult,
  RevocationPluginConfigInfo,
  RevocationPluginConfigUpdate,
  RevocationRequest,
  RevocationResult,
  RevokeCurrency,
  RevokeEntitlement,
  RevokeEntitlementPayload,
  RevokeEntry,
  RevokeFulfillmentV2Result,
  RevokeItem,
  RevokeItemSummary,
  RevokeResult,
  RevokeUseCountRequest,
  Reward$,
  RewardAdmin$,
  RewardAdminApi,
  RewardApi,
  RewardCondition,
  RewardCreate,
  RewardInfo,
  RewardItem,
  RewardMigrationResult,
  RewardPagingSlicedResult,
  RewardUpdate,
  RewardsRequest,
  SaleConfig,
  Section$,
  SectionAdmin$,
  SectionAdminApi,
  SectionApi,
  SectionCreate,
  SectionInfo,
  SectionInfoArray,
  SectionItem,
  SectionPagingSlicedResult,
  SectionPluginConfigInfo,
  SectionPluginConfigUpdate,
  SectionUpdate,
  ServicePluginConfigAdmin$,
  ServicePluginConfigAdminApi,
  ServicePluginConfigInfo,
  ServicePluginConfigUpdate,
  SessionPlatformAdmin$,
  SessionPlatformAdminApi,
  SimpleDlcRewardItem,
  SimpleEntitlement,
  SimpleUserDlc,
  SimpleUserDlcRewardContent,
  SimpleUserDlcRewardContentsResponse,
  SimpleWallet,
  Slide,
  StackableEntitlementInfo,
  StackableEntitlementInfoArray,
  SteamAchievement,
  SteamAchievementUpdateRequest,
  SteamDlcSyncRequest,
  SteamIapConfig,
  SteamIapConfigInfo,
  SteamIapConfigRequest,
  SteamSyncRequest,
  Store$,
  StoreAdmin$,
  StoreAdminApi,
  StoreApi,
  StoreBackupInfo,
  StoreCreate,
  StoreInfo,
  StoreInfoArray,
  StoreUpdate,
  StreamEvent,
  StreamEventBody,
  StripeConfig,
  SubItemAvailablePrice,
  Subscribable,
  SubscribeRequest,
  Subscription$,
  SubscriptionActivityInfo,
  SubscriptionActivityPagingSlicedResult,
  SubscriptionAdmin$,
  SubscriptionAdminApi,
  SubscriptionApi,
  SubscriptionInfo,
  SubscriptionPagingSlicedResult,
  SubscriptionSummary,
  TaxResult,
  TestResult,
  ThirdPartySubscriptionOwnership,
  ThirdPartySubscriptionTransactionHistoryInfo,
  ThirdPartySubscriptionTransactionHistoryPagingSlicedResult,
  ThirdPartySubscriptionTransactionInfo,
  ThirdPartySubscriptionTransactionPagingSlicedResult,
  ThirdPartyUserSubscriptionInfo,
  ThirdPartyUserSubscriptionPagingSlicedResult,
  TicketAcquireRequest,
  TicketAcquireResult,
  TicketAdmin$,
  TicketAdminApi,
  TicketBoothId,
  TicketDynamicInfo,
  TicketSaleDecrementRequest,
  TicketSaleIncrementRequest,
  TicketSaleIncrementResult,
  TimeLimitedBalance,
  TimedOwnership,
  TlsConfig,
  TradeActionAdmin$,
  TradeActionAdminApi,
  TradeActionPagingSlicedResult,
  TradeChainActionHistoryInfo,
  TradeChainedActionCommitRequest,
  TradeNotification,
  Transaction,
  TransactionAmountDetails,
  TwitchIapConfigInfo,
  TwitchIapConfigRequest,
  TwitchSyncRequest,
  TwitchSyncResult,
  TwitchSyncResultArray,
  UserDlc,
  UserDlcRecord,
  UserDlcRecordArray,
  UserEntitlementHistoryPagingSlicedResult,
  UserEntitlementHistoryPagingSlicedResultArray,
  ValidationErrorEntity,
  View$,
  ViewAdmin$,
  ViewAdminApi,
  ViewApi,
  ViewCreate,
  ViewInfo,
  ViewInfoArray,
  ViewUpdate,
  Wallet$,
  WalletAdmin$,
  WalletAdminApi,
  WalletApi,
  WalletInfo,
  WalletPagingSlicedResult,
  WalletRevocationConfig,
  WalletTransactionInfo,
  WalletTransactionPagingSlicedResult,
  WxPayConfigInfo,
  WxPayConfigRequest,
  XblAchievementUpdateRequest,
  XblDlcSyncRequest,
  XblEntitlementOwnershipRequest,
  XblIapConfigInfo,
  XblIapConfigRequest,
  XblReconcileRequest,
  XblReconcileResult,
  XblReconcileResultArray,
  XblUserAchievements,
  XblUserSessionRequest,
  XboxAchievement,
  XsollaConfig,
  XsollaPaywallConfig,
  XsollaPaywallConfigRequest
});

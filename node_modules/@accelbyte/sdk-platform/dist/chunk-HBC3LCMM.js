// src/generated-definitions/AchievementInfo.ts
import { z } from "zod";
var AchievementInfo = z.object({
  id: z.string().nullish(),
  name: z.string().nullish(),
  progressState: z.string().nullish(),
  progression: z.record(z.any()).nullish(),
  serviceConfigId: z.string().nullish()
});

// src/generated-definitions/XblUserAchievements.ts
import { z as z2 } from "zod";
var XblUserAchievements = z2.object({ achievements: z2.array(AchievementInfo).nullish() });

// src/generated-admin/endpoints/AchievementPlatformAdmin$.ts
import { Validate } from "@accelbyte/sdk";
import { z as z3 } from "zod";
var AchievementPlatformAdmin$ = class {
  // @ts-ignore
  // prettier-ignore
  constructor(axiosInstance, namespace, useSchemaValidation = true) {
    this.axiosInstance = axiosInstance;
    this.namespace = namespace;
    this.useSchemaValidation = useSchemaValidation;
  }
  /**
   * This API is used to get xbox live user achievements(Only for test).
   */
  getAchievementXbl_ByUserId(userId, queryParams) {
    const params = { ...queryParams };
    const url = "/platform/admin/namespaces/{namespace}/users/{userId}/achievement/xbl".replace("{namespace}", this.namespace).replace("{userId}", userId);
    const resultPromise = this.axiosInstance.get(url, { params });
    return Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, XblUserAchievements, "XblUserAchievements");
  }
  /**
   * This API is used to update xbox live achievements.
   */
  updateAchievementXbl_ByUserId(userId, data) {
    const params = {};
    const url = "/platform/admin/namespaces/{namespace}/users/{userId}/achievement/xbl".replace("{namespace}", this.namespace).replace("{userId}", userId);
    const resultPromise = this.axiosInstance.put(url, data, { params });
    return Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, z3.unknown(), "z.unknown()");
  }
  /**
   * This API is used to unlock steam achievement.
   */
  updateAchievementSteam_ByUserId(userId, data) {
    const params = {};
    const url = "/platform/admin/namespaces/{namespace}/users/{userId}/achievement/steam".replace("{namespace}", this.namespace).replace("{userId}", userId);
    const resultPromise = this.axiosInstance.put(url, data, { params });
    return Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, z3.unknown(), "z.unknown()");
  }
};

// src/generated-admin/AchievementPlatformAdminApi.ts
import { ApiUtils, Network } from "@accelbyte/sdk";
function AchievementPlatformAdminApi(sdk, args) {
  const sdkAssembly = sdk.assembly();
  const namespace = args?.coreConfig?.namespace ?? sdkAssembly.coreConfig.namespace;
  const useSchemaValidation = args?.coreConfig?.useSchemaValidation ?? sdkAssembly.coreConfig.useSchemaValidation;
  let axiosInstance = sdkAssembly.axiosInstance;
  const requestConfigOverrides = args?.axiosConfig?.request;
  const baseURLOverride = args?.coreConfig?.baseURL;
  const interceptorsOverride = args?.axiosConfig?.interceptors ?? [];
  if (requestConfigOverrides || baseURLOverride || interceptorsOverride.length > 0) {
    const requestConfig = ApiUtils.mergeAxiosConfigs(sdkAssembly.axiosInstance.defaults, {
      ...baseURLOverride ? { baseURL: baseURLOverride } : {},
      ...requestConfigOverrides
    });
    axiosInstance = Network.create(requestConfig);
    for (const interceptor of interceptorsOverride) {
      if (interceptor.type === "request") {
        axiosInstance.interceptors.request.use(interceptor.onRequest, interceptor.onError);
      }
      if (interceptor.type === "response") {
        axiosInstance.interceptors.response.use(interceptor.onSuccess, interceptor.onError);
      }
    }
  }
  async function getAchievementXbl_ByUserId(userId, queryParams) {
    const $ = new AchievementPlatformAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getAchievementXbl_ByUserId(userId, queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function updateAchievementXbl_ByUserId(userId, data) {
    const $ = new AchievementPlatformAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.updateAchievementXbl_ByUserId(userId, data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function updateAchievementSteam_ByUserId(userId, data) {
    const $ = new AchievementPlatformAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.updateAchievementSteam_ByUserId(userId, data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  return {
    /**
     * This API is used to get xbox live user achievements(Only for test).
     */
    getAchievementXbl_ByUserId,
    /**
     * This API is used to update xbox live achievements.
     */
    updateAchievementXbl_ByUserId,
    /**
     * This API is used to unlock steam achievement.
     */
    updateAchievementSteam_ByUserId
  };
}

// src/generated-admin/endpoints/AnonymizationAdmin$.ts
import { Validate as Validate2 } from "@accelbyte/sdk";
import { z as z4 } from "zod";
var AnonymizationAdmin$ = class {
  // @ts-ignore
  // prettier-ignore
  constructor(axiosInstance, namespace, useSchemaValidation = true) {
    this.axiosInstance = axiosInstance;
    this.namespace = namespace;
    this.useSchemaValidation = useSchemaValidation;
  }
  /**
   * Anonymize order. At current it will only anonymize order, order history.
   */
  deleteAnonymizationOrder_ByUserId(userId) {
    const params = {};
    const url = "/platform/admin/namespaces/{namespace}/users/{userId}/anonymization/orders".replace("{namespace}", this.namespace).replace("{userId}", userId);
    const resultPromise = this.axiosInstance.delete(url, { params });
    return Validate2.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, z4.unknown(), "z.unknown()");
  }
  /**
   * Anonymize payment. At current it will only anonymize payment order, payment order history.
   */
  deleteAnonymizationPayment_ByUserId(userId) {
    const params = {};
    const url = "/platform/admin/namespaces/{namespace}/users/{userId}/anonymization/payment".replace("{namespace}", this.namespace).replace("{userId}", userId);
    const resultPromise = this.axiosInstance.delete(url, { params });
    return Validate2.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, z4.unknown(), "z.unknown()");
  }
  /**
   * Anonymize wallet. At current it will only anonymize wallet, wallet transaction.
   */
  deleteAnonymizationWallet_ByUserId(userId) {
    const params = {};
    const url = "/platform/admin/namespaces/{namespace}/users/{userId}/anonymization/wallets".replace("{namespace}", this.namespace).replace("{userId}", userId);
    const resultPromise = this.axiosInstance.delete(url, { params });
    return Validate2.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, z4.unknown(), "z.unknown()");
  }
  /**
   * Anonymize campaign. At current it will only anonymize redeem history.
   */
  deleteAnonymizationCampaign_ByUserId(userId) {
    const params = {};
    const url = "/platform/admin/namespaces/{namespace}/users/{userId}/anonymization/campaign".replace("{namespace}", this.namespace).replace("{userId}", userId);
    const resultPromise = this.axiosInstance.delete(url, { params });
    return Validate2.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, z4.unknown(), "z.unknown()");
  }
  /**
   * Anonymize revocation. At current it will only anonymize revocation history.
   */
  deleteAnonymizationRevocation_ByUserId(userId) {
    const params = {};
    const url = "/platform/admin/namespaces/{namespace}/users/{userId}/anonymization/revocation".replace("{namespace}", this.namespace).replace("{userId}", userId);
    const resultPromise = this.axiosInstance.delete(url, { params });
    return Validate2.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, z4.unknown(), "z.unknown()");
  }
  /**
   * Anonymize fulfillment. At current it will only anonymize fulfillment history.
   */
  deleteAnonymizationFulfillment_ByUserId(userId) {
    const params = {};
    const url = "/platform/admin/namespaces/{namespace}/users/{userId}/anonymization/fulfillment".replace("{namespace}", this.namespace).replace("{userId}", userId);
    const resultPromise = this.axiosInstance.delete(url, { params });
    return Validate2.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, z4.unknown(), "z.unknown()");
  }
  /**
   * Anonymize entitlement. At current it will only anonymize entitlement, entitlement history.
   */
  deleteAnonymizationEntitlement_ByUserId(userId) {
    const params = {};
    const url = "/platform/admin/namespaces/{namespace}/users/{userId}/anonymization/entitlements".replace("{namespace}", this.namespace).replace("{userId}", userId);
    const resultPromise = this.axiosInstance.delete(url, { params });
    return Validate2.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, z4.unknown(), "z.unknown()");
  }
  /**
   * Anonymize integrations. At current it will only anonymize iap histories.
   */
  deleteAnonymizationIntegration_ByUserId(userId) {
    const params = {};
    const url = "/platform/admin/namespaces/{namespace}/users/{userId}/anonymization/integrations".replace("{namespace}", this.namespace).replace("{userId}", userId);
    const resultPromise = this.axiosInstance.delete(url, { params });
    return Validate2.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, z4.unknown(), "z.unknown()");
  }
  /**
   * Anonymize subscription. At current it will anonymize subscription, billing history and subscription activity.
   */
  deleteAnonymizationSubscription_ByUserId(userId) {
    const params = {};
    const url = "/platform/admin/namespaces/{namespace}/users/{userId}/anonymization/subscriptions".replace("{namespace}", this.namespace).replace("{userId}", userId);
    const resultPromise = this.axiosInstance.delete(url, { params });
    return Validate2.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, z4.unknown(), "z.unknown()");
  }
};

// src/generated-admin/AnonymizationAdminApi.ts
import { ApiUtils as ApiUtils2, Network as Network2 } from "@accelbyte/sdk";
function AnonymizationAdminApi(sdk, args) {
  const sdkAssembly = sdk.assembly();
  const namespace = args?.coreConfig?.namespace ?? sdkAssembly.coreConfig.namespace;
  const useSchemaValidation = args?.coreConfig?.useSchemaValidation ?? sdkAssembly.coreConfig.useSchemaValidation;
  let axiosInstance = sdkAssembly.axiosInstance;
  const requestConfigOverrides = args?.axiosConfig?.request;
  const baseURLOverride = args?.coreConfig?.baseURL;
  const interceptorsOverride = args?.axiosConfig?.interceptors ?? [];
  if (requestConfigOverrides || baseURLOverride || interceptorsOverride.length > 0) {
    const requestConfig = ApiUtils2.mergeAxiosConfigs(sdkAssembly.axiosInstance.defaults, {
      ...baseURLOverride ? { baseURL: baseURLOverride } : {},
      ...requestConfigOverrides
    });
    axiosInstance = Network2.create(requestConfig);
    for (const interceptor of interceptorsOverride) {
      if (interceptor.type === "request") {
        axiosInstance.interceptors.request.use(interceptor.onRequest, interceptor.onError);
      }
      if (interceptor.type === "response") {
        axiosInstance.interceptors.response.use(interceptor.onSuccess, interceptor.onError);
      }
    }
  }
  async function deleteAnonymizationOrder_ByUserId(userId) {
    const $ = new AnonymizationAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.deleteAnonymizationOrder_ByUserId(userId);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function deleteAnonymizationPayment_ByUserId(userId) {
    const $ = new AnonymizationAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.deleteAnonymizationPayment_ByUserId(userId);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function deleteAnonymizationWallet_ByUserId(userId) {
    const $ = new AnonymizationAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.deleteAnonymizationWallet_ByUserId(userId);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function deleteAnonymizationCampaign_ByUserId(userId) {
    const $ = new AnonymizationAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.deleteAnonymizationCampaign_ByUserId(userId);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function deleteAnonymizationRevocation_ByUserId(userId) {
    const $ = new AnonymizationAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.deleteAnonymizationRevocation_ByUserId(userId);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function deleteAnonymizationFulfillment_ByUserId(userId) {
    const $ = new AnonymizationAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.deleteAnonymizationFulfillment_ByUserId(userId);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function deleteAnonymizationEntitlement_ByUserId(userId) {
    const $ = new AnonymizationAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.deleteAnonymizationEntitlement_ByUserId(userId);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function deleteAnonymizationIntegration_ByUserId(userId) {
    const $ = new AnonymizationAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.deleteAnonymizationIntegration_ByUserId(userId);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function deleteAnonymizationSubscription_ByUserId(userId) {
    const $ = new AnonymizationAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.deleteAnonymizationSubscription_ByUserId(userId);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  return {
    /**
     * Anonymize order. At current it will only anonymize order, order history.
     */
    deleteAnonymizationOrder_ByUserId,
    /**
     * Anonymize payment. At current it will only anonymize payment order, payment order history.
     */
    deleteAnonymizationPayment_ByUserId,
    /**
     * Anonymize wallet. At current it will only anonymize wallet, wallet transaction.
     */
    deleteAnonymizationWallet_ByUserId,
    /**
     * Anonymize campaign. At current it will only anonymize redeem history.
     */
    deleteAnonymizationCampaign_ByUserId,
    /**
     * Anonymize revocation. At current it will only anonymize revocation history.
     */
    deleteAnonymizationRevocation_ByUserId,
    /**
     * Anonymize fulfillment. At current it will only anonymize fulfillment history.
     */
    deleteAnonymizationFulfillment_ByUserId,
    /**
     * Anonymize entitlement. At current it will only anonymize entitlement, entitlement history.
     */
    deleteAnonymizationEntitlement_ByUserId,
    /**
     * Anonymize integrations. At current it will only anonymize iap histories.
     */
    deleteAnonymizationIntegration_ByUserId,
    /**
     * Anonymize subscription. At current it will anonymize subscription, billing history and subscription activity.
     */
    deleteAnonymizationSubscription_ByUserId
  };
}

// src/generated-definitions/BulkOperationResult.ts
import { z as z5 } from "zod";
var BulkOperationResult = z5.object({ affected: z5.number().int().nullish() });

// src/generated-definitions/CampaignBatchNameInfo.ts
import { z as z6 } from "zod";
var CampaignBatchNameInfo = z6.object({ batchName: z6.string(), batchNos: z6.array(z6.number().int()) });

// src/generated-definitions/CampaignBatchNameInfoArray.ts
import { z as z7 } from "zod";
var CampaignBatchNameInfoArray = z7.array(CampaignBatchNameInfo);

// src/generated-definitions/CampaignDynamicInfo.ts
import { z as z8 } from "zod";
var CampaignDynamicInfo = z8.object({
  availableSaleCount: z8.number().int(),
  lastBatchNo: z8.number().int(),
  quantity: z8.number().int(),
  remainder: z8.number().int(),
  saleCount: z8.number().int()
});

// src/generated-definitions/DiscountCategory.ts
import { z as z9 } from "zod";
var DiscountCategory = z9.object({ categoryPath: z9.string(), includeSubCategories: z9.boolean().nullish() });

// src/generated-definitions/DiscountItem.ts
import { z as z10 } from "zod";
var DiscountItem = z10.object({ itemId: z10.string(), itemName: z10.string() });

// src/generated-definitions/DiscountConfig.ts
import { z as z11 } from "zod";
var DiscountConfig = z11.object({
  categories: z11.array(DiscountCategory).nullish(),
  currencyCode: z11.string().nullish(),
  currencyNamespace: z11.string().nullish(),
  discountAmount: z11.number().int().nullish(),
  discountPercentage: z11.number().int().nullish(),
  discountType: z11.enum(["AMOUNT", "PERCENTAGE"]).nullish(),
  items: z11.array(DiscountItem).nullish(),
  restrictType: z11.enum(["ITEMS_AND_CATEGORIES", "NONE"]).nullish(),
  stackable: z11.boolean().nullish()
});

// src/generated-definitions/RedeemableItem.ts
import { z as z12 } from "zod";
var RedeemableItem = z12.object({
  extraSubscriptionDays: z12.number().int().nullish(),
  itemId: z12.string(),
  itemName: z12.string(),
  quantity: z12.number().int().nullish()
});

// src/generated-definitions/CampaignInfo.ts
import { z as z13 } from "zod";
var CampaignInfo = z13.object({
  boothName: z13.string(),
  createdAt: z13.string(),
  description: z13.string().nullish(),
  discountConfig: DiscountConfig.nullish(),
  id: z13.string(),
  items: z13.array(RedeemableItem).nullish(),
  maxRedeemCountPerCampaignPerUser: z13.number().int(),
  maxRedeemCountPerCode: z13.number().int(),
  maxRedeemCountPerCodePerUser: z13.number().int(),
  maxSaleCount: z13.number().int(),
  name: z13.string(),
  namespace: z13.string(),
  redeemEnd: z13.string().nullish(),
  redeemStart: z13.string().nullish(),
  redeemType: z13.enum(["DISCOUNT", "ITEM"]),
  status: z13.enum(["ACTIVE", "INACTIVE"]),
  tags: z13.array(z13.string()).nullish(),
  type: z13.enum(["REDEMPTION"]),
  updatedAt: z13.string()
});

// src/generated-definitions/Paging.ts
import { z as z14 } from "zod";
var Paging = z14.object({ next: z14.string().nullish(), previous: z14.string().nullish() });

// src/generated-definitions/CampaignPagingSlicedResult.ts
import { z as z15 } from "zod";
var CampaignPagingSlicedResult = z15.object({ data: z15.array(CampaignInfo), paging: Paging.nullish() });

// src/generated-definitions/CodeCreateResult.ts
import { z as z16 } from "zod";
var CodeCreateResult = z16.object({ numCreated: z16.number().int() });

// src/generated-definitions/CampaignIfc.ts
import { z as z17 } from "zod";
var CampaignIfc = z17.object({ id: z17.string().nullish(), name: z17.string().nullish() });

// src/generated-definitions/CodeInfo.ts
import { z as z18 } from "zod";
var CodeInfo = z18.object({
  acquireOrderNo: z18.string().nullish(),
  acquireUserId: z18.string().nullish(),
  batchName: z18.string().nullish(),
  batchNo: z18.number().int(),
  campaign: CampaignIfc.nullish(),
  campaignId: z18.string(),
  createdAt: z18.string(),
  discountConfig: DiscountConfig.nullish(),
  id: z18.string(),
  items: z18.array(RedeemableItem).nullish(),
  maxRedeemCountPerCampaignPerUser: z18.number().int(),
  maxRedeemCountPerCode: z18.number().int(),
  maxRedeemCountPerCodePerUser: z18.number().int(),
  namespace: z18.string(),
  redeemEnd: z18.string().nullish(),
  redeemStart: z18.string().nullish(),
  redeemType: z18.enum(["DISCOUNT", "ITEM"]),
  redeemedCount: z18.number().int(),
  remainder: z18.number().int(),
  status: z18.enum(["ACTIVE", "INACTIVE"]),
  type: z18.enum(["REDEMPTION"]),
  updatedAt: z18.string(),
  value: z18.string()
});

// src/generated-definitions/CodeInfoPagingSlicedResult.ts
import { z as z19 } from "zod";
var CodeInfoPagingSlicedResult = z19.object({ data: z19.array(CodeInfo), paging: Paging.nullish() });

// src/generated-definitions/RedeemHistoryInfo.ts
import { z as z20 } from "zod";
var RedeemHistoryInfo = z20.object({
  campaignId: z20.string(),
  code: z20.string(),
  createdAt: z20.string(),
  id: z20.string(),
  namespace: z20.string(),
  orderNo: z20.string().nullish(),
  redeemedAt: z20.string().nullish(),
  updatedAt: z20.string(),
  userId: z20.string()
});

// src/generated-definitions/RedeemHistoryPagingSlicedResult.ts
import { z as z21 } from "zod";
var RedeemHistoryPagingSlicedResult = z21.object({ data: z21.array(RedeemHistoryInfo), paging: Paging.nullish() });

// src/generated-definitions/RedeemResult.ts
import { z as z22 } from "zod";
var RedeemResult = z22.object({ items: z22.array(RedeemableItem).nullish() });

// src/generated-admin/endpoints/CampaignAdmin$.ts
import { Validate as Validate3 } from "@accelbyte/sdk";
import { z as z23 } from "zod";
var CampaignAdmin$ = class {
  // @ts-ignore
  // prettier-ignore
  constructor(axiosInstance, namespace, useSchemaValidation = true) {
    this.axiosInstance = axiosInstance;
    this.namespace = namespace;
    this.useSchemaValidation = useSchemaValidation;
  }
  /**
   * Query campaigns, if name is presented, it&#39;s fuzzy match.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: slice of campaigns&lt;/li&gt;&lt;/ul&gt;
   */
  getCampaigns(queryParams) {
    const params = { limit: 20, ...queryParams };
    const url = "/platform/admin/namespaces/{namespace}/campaigns".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.get(url, { params });
    return Validate3.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      CampaignPagingSlicedResult,
      "CampaignPagingSlicedResult"
    );
  }
  /**
   * Create campaign.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: created campaign&lt;/li&gt;&lt;/ul&gt;
   */
  createCampaign(data) {
    const params = {};
    const url = "/platform/admin/namespaces/{namespace}/campaigns".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.post(url, data, { params });
    return Validate3.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, CampaignInfo, "CampaignInfo");
  }
  /**
   * Get campaign code, it will check code whether available to redeem if redeemable true.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: code info&lt;/li&gt;&lt;/ul&gt;
   */
  getCode_ByCode(code, queryParams) {
    const params = { ...queryParams };
    const url = "/platform/admin/namespaces/{namespace}/codes/{code}".replace("{namespace}", this.namespace).replace("{code}", code);
    const resultPromise = this.axiosInstance.get(url, { params });
    return Validate3.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, CodeInfo, "CodeInfo");
  }
  /**
   * Enable code.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: enabled code&lt;/li&gt;&lt;/ul&gt;
   */
  updateEnable_ByCode(code) {
    const params = {};
    const url = "/platform/admin/namespaces/{namespace}/codes/{code}/enable".replace("{namespace}", this.namespace).replace("{code}", code);
    const resultPromise = this.axiosInstance.put(url, null, { params });
    return Validate3.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, CodeInfo, "CodeInfo");
  }
  /**
   * Disable code.&lt;p&gt;Disable an active code, the code can&#39;t be disabled if it has already been redeemed.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: disabled code&lt;/li&gt;&lt;/ul&gt;
   */
  updateDisable_ByCode(code) {
    const params = {};
    const url = "/platform/admin/namespaces/{namespace}/codes/{code}/disable".replace("{namespace}", this.namespace).replace("{code}", code);
    const resultPromise = this.axiosInstance.put(url, null, { params });
    return Validate3.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, CodeInfo, "CodeInfo");
  }
  /**
   * Get campaign info.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: campaign info&lt;/li&gt;&lt;/ul&gt;
   */
  getCampaign_ByCampaignId(campaignId) {
    const params = {};
    const url = "/platform/admin/namespaces/{namespace}/campaigns/{campaignId}".replace("{namespace}", this.namespace).replace("{campaignId}", campaignId);
    const resultPromise = this.axiosInstance.get(url, { params });
    return Validate3.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, CampaignInfo, "CampaignInfo");
  }
  /**
   * Update campaign.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: updated campaign&lt;/li&gt;&lt;/ul&gt;
   */
  updateCampaign_ByCampaignId(campaignId, data) {
    const params = {};
    const url = "/platform/admin/namespaces/{namespace}/campaigns/{campaignId}".replace("{namespace}", this.namespace).replace("{campaignId}", campaignId);
    const resultPromise = this.axiosInstance.put(url, data, { params });
    return Validate3.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, CampaignInfo, "CampaignInfo");
  }
  /**
   * &lt;b&gt;[SERVICE COMMUNICATION ONLY]&lt;/b&gt; Redeem code. If the campaign which the code belongs to is INACTIVE, the code couldn&#39;t be redeemed even if its status is ACTIVE.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: Redeem result&lt;/li&gt;&lt;/ul&gt;
   */
  createRedemption_ByUserId(userId, data) {
    const params = {};
    const url = "/platform/admin/namespaces/{namespace}/users/{userId}/redemption".replace("{namespace}", this.namespace).replace("{userId}", userId);
    const resultPromise = this.axiosInstance.post(url, data, { params });
    return Validate3.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, RedeemResult, "RedeemResult");
  }
  /**
   * Query campaign codes.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: list of codes&lt;/li&gt;&lt;li&gt;The &lt;i&gt;batchName&lt;/i&gt; field in the codes response will be present only when the &lt;i&gt;withBatchName&lt;/i&gt; parameter is &lt;i&gt;true&lt;/i&gt;, or when the &lt;i&gt;batchName&lt;/i&gt; filter is not blank.&lt;/li&gt;&lt;/ul&gt;
   */
  getCodeCampaign_ByCampaignId(campaignId, queryParams) {
    const params = { activeOnly: true, limit: 20, ...queryParams };
    const url = "/platform/admin/namespaces/{namespace}/codes/campaigns/{campaignId}".replace("{namespace}", this.namespace).replace("{campaignId}", campaignId);
    const resultPromise = this.axiosInstance.get(url, { params });
    return Validate3.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      CodeInfoPagingSlicedResult,
      "CodeInfoPagingSlicedResult"
    );
  }
  /**
   * This API is used to create campaign codes, it will increase the batch No. based on last creation.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: number of codes created&lt;/li&gt;&lt;/ul&gt;
   */
  createCodeCampaign_ByCampaignId(campaignId, data) {
    const params = {};
    const url = "/platform/admin/namespaces/{namespace}/codes/campaigns/{campaignId}".replace("{namespace}", this.namespace).replace("{campaignId}", campaignId);
    const resultPromise = this.axiosInstance.post(url, data, { params });
    return Validate3.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, CodeCreateResult, "CodeCreateResult");
  }
  /**
   * Get campaign dynamic.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: campaign dynamic&lt;/li&gt;&lt;/ul&gt;
   */
  getDynamic_ByCampaignId(campaignId) {
    const params = {};
    const url = "/platform/admin/namespaces/{namespace}/campaigns/{campaignId}/dynamic".replace("{namespace}", this.namespace).replace("{campaignId}", campaignId);
    const resultPromise = this.axiosInstance.get(url, { params });
    return Validate3.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, CampaignDynamicInfo, "CampaignDynamicInfo");
  }
  /**
   * Change campaign batch name.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;/ul&gt;
   */
  updateBatchName_ByCampaignId(campaignId, data) {
    const params = {};
    const url = "/platform/admin/namespaces/{namespace}/campaigns/{campaignId}/batchName".replace("{namespace}", this.namespace).replace("{campaignId}", campaignId);
    const resultPromise = this.axiosInstance.put(url, data, { params });
    return Validate3.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, z23.unknown(), "z.unknown()");
  }
  /**
   * Query campaign batch name by fuzzy match.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: list of campaign batch names&lt;/li&gt;&lt;/ul&gt;
   */
  getBatchNames_ByCampaignId(campaignId, queryParams) {
    const params = { limit: 10, ...queryParams };
    const url = "/platform/admin/namespaces/{namespace}/campaigns/{campaignId}/batchNames".replace("{namespace}", this.namespace).replace("{campaignId}", campaignId);
    const resultPromise = this.axiosInstance.get(url, { params });
    return Validate3.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      CampaignBatchNameInfoArray,
      "CampaignBatchNameInfoArray"
    );
  }
  /**
   * Query redeem history.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: slice of redeem history&lt;/li&gt;&lt;/ul&gt;
   */
  getHistoryCodes_ByCampaignId(campaignId, queryParams) {
    const params = { limit: 20, ...queryParams };
    const url = "/platform/admin/namespaces/{namespace}/codes/campaigns/{campaignId}/history".replace("{namespace}", this.namespace).replace("{campaignId}", campaignId);
    const resultPromise = this.axiosInstance.get(url, { params });
    return Validate3.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      RedeemHistoryPagingSlicedResult,
      "RedeemHistoryPagingSlicedResult"
    );
  }
  /**
   * Download all or a batch of campaign&#39;s codes as a csv file.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: codes csv file&lt;/li&gt;&lt;li&gt;The csv file will always have &lt;i&gt;Batch Name&lt;/i&gt; column, but this column will be filled only when the &lt;i&gt;withBatchName&lt;/i&gt; parameter is &lt;i&gt;true&lt;/i&gt;, or when the &lt;i&gt;batchName&lt;/i&gt; filter is not blank.&lt;/li&gt;&lt;/ul&gt;
   */
  getCodesCsv_ByCampaignId(campaignId, queryParams) {
    const params = { ...queryParams };
    const url = "/platform/admin/namespaces/{namespace}/codes/campaigns/{campaignId}/codes.csv".replace("{namespace}", this.namespace).replace("{campaignId}", campaignId);
    const resultPromise = this.axiosInstance.get(url, { params });
    return Validate3.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, z23.unknown(), "z.unknown()");
  }
  /**
   * Bulk enable campaign codes.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: the number of code actually enabled&lt;/li&gt;&lt;/ul&gt;
   */
  updateEnableBulkCode_ByCampaignId(campaignId, queryParams) {
    const params = { ...queryParams };
    const url = "/platform/admin/namespaces/{namespace}/codes/campaigns/{campaignId}/enable/bulk".replace("{namespace}", this.namespace).replace("{campaignId}", campaignId);
    const resultPromise = this.axiosInstance.put(url, null, { params });
    return Validate3.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, BulkOperationResult, "BulkOperationResult");
  }
  /**
   * Bulk disable codes.&lt;p&gt;Bulk disable campaign codes, all matched codes will be disabled except those have already been redeemed.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: the number of code actually disabled&lt;/li&gt;&lt;/ul&gt;
   */
  updateDisableBulkCode_ByCampaignId(campaignId, queryParams) {
    const params = { ...queryParams };
    const url = "/platform/admin/namespaces/{namespace}/codes/campaigns/{campaignId}/disable/bulk".replace("{namespace}", this.namespace).replace("{campaignId}", campaignId);
    const resultPromise = this.axiosInstance.put(url, null, { params });
    return Validate3.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, BulkOperationResult, "BulkOperationResult");
  }
};

// src/generated-admin/CampaignAdminApi.ts
import { ApiUtils as ApiUtils3, Network as Network3 } from "@accelbyte/sdk";
function CampaignAdminApi(sdk, args) {
  const sdkAssembly = sdk.assembly();
  const namespace = args?.coreConfig?.namespace ?? sdkAssembly.coreConfig.namespace;
  const useSchemaValidation = args?.coreConfig?.useSchemaValidation ?? sdkAssembly.coreConfig.useSchemaValidation;
  let axiosInstance = sdkAssembly.axiosInstance;
  const requestConfigOverrides = args?.axiosConfig?.request;
  const baseURLOverride = args?.coreConfig?.baseURL;
  const interceptorsOverride = args?.axiosConfig?.interceptors ?? [];
  if (requestConfigOverrides || baseURLOverride || interceptorsOverride.length > 0) {
    const requestConfig = ApiUtils3.mergeAxiosConfigs(sdkAssembly.axiosInstance.defaults, {
      ...baseURLOverride ? { baseURL: baseURLOverride } : {},
      ...requestConfigOverrides
    });
    axiosInstance = Network3.create(requestConfig);
    for (const interceptor of interceptorsOverride) {
      if (interceptor.type === "request") {
        axiosInstance.interceptors.request.use(interceptor.onRequest, interceptor.onError);
      }
      if (interceptor.type === "response") {
        axiosInstance.interceptors.response.use(interceptor.onSuccess, interceptor.onError);
      }
    }
  }
  async function getCampaigns(queryParams) {
    const $ = new CampaignAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getCampaigns(queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function createCampaign(data) {
    const $ = new CampaignAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.createCampaign(data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getCode_ByCode(code, queryParams) {
    const $ = new CampaignAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getCode_ByCode(code, queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function updateEnable_ByCode(code) {
    const $ = new CampaignAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.updateEnable_ByCode(code);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function updateDisable_ByCode(code) {
    const $ = new CampaignAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.updateDisable_ByCode(code);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getCampaign_ByCampaignId(campaignId) {
    const $ = new CampaignAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getCampaign_ByCampaignId(campaignId);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function updateCampaign_ByCampaignId(campaignId, data) {
    const $ = new CampaignAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.updateCampaign_ByCampaignId(campaignId, data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function createRedemption_ByUserId(userId, data) {
    const $ = new CampaignAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.createRedemption_ByUserId(userId, data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getCodeCampaign_ByCampaignId(campaignId, queryParams) {
    const $ = new CampaignAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getCodeCampaign_ByCampaignId(campaignId, queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function createCodeCampaign_ByCampaignId(campaignId, data) {
    const $ = new CampaignAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.createCodeCampaign_ByCampaignId(campaignId, data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getDynamic_ByCampaignId(campaignId) {
    const $ = new CampaignAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getDynamic_ByCampaignId(campaignId);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function updateBatchName_ByCampaignId(campaignId, data) {
    const $ = new CampaignAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.updateBatchName_ByCampaignId(campaignId, data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getBatchNames_ByCampaignId(campaignId, queryParams) {
    const $ = new CampaignAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getBatchNames_ByCampaignId(campaignId, queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getHistoryCodes_ByCampaignId(campaignId, queryParams) {
    const $ = new CampaignAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getHistoryCodes_ByCampaignId(campaignId, queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getCodesCsv_ByCampaignId(campaignId, queryParams) {
    const $ = new CampaignAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getCodesCsv_ByCampaignId(campaignId, queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function updateEnableBulkCode_ByCampaignId(campaignId, queryParams) {
    const $ = new CampaignAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.updateEnableBulkCode_ByCampaignId(campaignId, queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function updateDisableBulkCode_ByCampaignId(campaignId, queryParams) {
    const $ = new CampaignAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.updateDisableBulkCode_ByCampaignId(campaignId, queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  return {
    /**
     * Query campaigns, if name is presented, it&#39;s fuzzy match.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: slice of campaigns&lt;/li&gt;&lt;/ul&gt;
     */
    getCampaigns,
    /**
     * Create campaign.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: created campaign&lt;/li&gt;&lt;/ul&gt;
     */
    createCampaign,
    /**
     * Get campaign code, it will check code whether available to redeem if redeemable true.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: code info&lt;/li&gt;&lt;/ul&gt;
     */
    getCode_ByCode,
    /**
     * Enable code.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: enabled code&lt;/li&gt;&lt;/ul&gt;
     */
    updateEnable_ByCode,
    /**
     * Disable code.&lt;p&gt;Disable an active code, the code can&#39;t be disabled if it has already been redeemed.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: disabled code&lt;/li&gt;&lt;/ul&gt;
     */
    updateDisable_ByCode,
    /**
     * Get campaign info.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: campaign info&lt;/li&gt;&lt;/ul&gt;
     */
    getCampaign_ByCampaignId,
    /**
     * Update campaign.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: updated campaign&lt;/li&gt;&lt;/ul&gt;
     */
    updateCampaign_ByCampaignId,
    /**
     * &lt;b&gt;[SERVICE COMMUNICATION ONLY]&lt;/b&gt; Redeem code. If the campaign which the code belongs to is INACTIVE, the code couldn&#39;t be redeemed even if its status is ACTIVE.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: Redeem result&lt;/li&gt;&lt;/ul&gt;
     */
    createRedemption_ByUserId,
    /**
     * Query campaign codes.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: list of codes&lt;/li&gt;&lt;li&gt;The &lt;i&gt;batchName&lt;/i&gt; field in the codes response will be present only when the &lt;i&gt;withBatchName&lt;/i&gt; parameter is &lt;i&gt;true&lt;/i&gt;, or when the &lt;i&gt;batchName&lt;/i&gt; filter is not blank.&lt;/li&gt;&lt;/ul&gt;
     */
    getCodeCampaign_ByCampaignId,
    /**
     * This API is used to create campaign codes, it will increase the batch No. based on last creation.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: number of codes created&lt;/li&gt;&lt;/ul&gt;
     */
    createCodeCampaign_ByCampaignId,
    /**
     * Get campaign dynamic.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: campaign dynamic&lt;/li&gt;&lt;/ul&gt;
     */
    getDynamic_ByCampaignId,
    /**
     * Change campaign batch name.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;/ul&gt;
     */
    updateBatchName_ByCampaignId,
    /**
     * Query campaign batch name by fuzzy match.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: list of campaign batch names&lt;/li&gt;&lt;/ul&gt;
     */
    getBatchNames_ByCampaignId,
    /**
     * Query redeem history.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: slice of redeem history&lt;/li&gt;&lt;/ul&gt;
     */
    getHistoryCodes_ByCampaignId,
    /**
     * Download all or a batch of campaign&#39;s codes as a csv file.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: codes csv file&lt;/li&gt;&lt;li&gt;The csv file will always have &lt;i&gt;Batch Name&lt;/i&gt; column, but this column will be filled only when the &lt;i&gt;withBatchName&lt;/i&gt; parameter is &lt;i&gt;true&lt;/i&gt;, or when the &lt;i&gt;batchName&lt;/i&gt; filter is not blank.&lt;/li&gt;&lt;/ul&gt;
     */
    getCodesCsv_ByCampaignId,
    /**
     * Bulk enable campaign codes.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: the number of code actually enabled&lt;/li&gt;&lt;/ul&gt;
     */
    updateEnableBulkCode_ByCampaignId,
    /**
     * Bulk disable codes.&lt;p&gt;Bulk disable campaign codes, all matched codes will be disabled except those have already been redeemed.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: the number of code actually disabled&lt;/li&gt;&lt;/ul&gt;
     */
    updateDisableBulkCode_ByCampaignId
  };
}

// src/generated-definitions/CatalogChangeInfo.ts
import { z as z24 } from "zod";
var CatalogChangeInfo = z24.object({
  action: z24.enum(["CREATE", "DELETE", "UPDATE"]),
  categoryPath: z24.string().nullish(),
  changeId: z24.string(),
  createdAt: z24.string(),
  description: z24.string().nullish(),
  itemId: z24.string().nullish(),
  itemType: z24.enum(["APP", "BUNDLE", "CODE", "COINS", "EXTENSION", "INGAMEITEM", "LOOTBOX", "MEDIA", "OPTIONBOX", "SEASON", "SUBSCRIPTION"]).nullish(),
  namespace: z24.string(),
  publishedAt: z24.string().nullish(),
  sectionId: z24.string().nullish(),
  selected: z24.boolean(),
  sku: z24.string().nullish(),
  status: z24.enum(["PUBLISHED", "UNPUBLISHED"]),
  storeId: z24.string(),
  title: z24.string().nullish(),
  type: z24.enum(["CATEGORY", "ITEM", "SECTION", "STORE", "VIEW"]).nullish(),
  updatedAt: z24.string(),
  viewId: z24.string().nullish()
});

// src/generated-definitions/CatalogChangePagingResult.ts
import { z as z25 } from "zod";
var CatalogChangePagingResult = z25.object({
  data: z25.array(CatalogChangeInfo),
  paging: Paging.nullish(),
  total: z25.number().int().nullish()
});

// src/generated-definitions/CatalogChangeStatistics.ts
import { z as z26 } from "zod";
var CatalogChangeStatistics = z26.object({ count: z26.number().int(), selectedCount: z26.number().int() });

// src/generated-definitions/StoreInfo.ts
import { z as z27 } from "zod";
var StoreInfo = z27.object({
  createdAt: z27.string(),
  defaultLanguage: z27.string(),
  defaultRegion: z27.string(),
  description: z27.string().nullish(),
  namespace: z27.string(),
  published: z27.boolean(),
  publishedTime: z27.string().nullish(),
  storeId: z27.string(),
  supportedLanguages: z27.array(z27.string()),
  supportedRegions: z27.array(z27.string()),
  title: z27.string(),
  updatedAt: z27.string()
});

// src/generated-admin/endpoints/CatalogChangesAdmin$.ts
import { Validate as Validate4 } from "@accelbyte/sdk";
import { z as z28 } from "zod";
var CatalogChangesAdmin$ = class {
  // @ts-ignore
  // prettier-ignore
  constructor(axiosInstance, namespace, useSchemaValidation = true) {
    this.axiosInstance = axiosInstance;
    this.namespace = namespace;
    this.useSchemaValidation = useSchemaValidation;
  }
  /**
   * Select all changes.
   */
  updateCatalogChangeSelectAll_ByStoreId(storeId) {
    const params = {};
    const url = "/platform/admin/namespaces/{namespace}/stores/{storeId}/catalogChanges/selectAll".replace("{namespace}", this.namespace).replace("{storeId}", storeId);
    const resultPromise = this.axiosInstance.put(url, null, { params });
    return Validate4.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, z28.unknown(), "z.unknown()");
  }
  /**
   * This API is used to query changes .&lt;p&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: the pagination of changes&lt;/li&gt;&lt;/ul&gt;
   */
  getCatalogChangesByCriteria_ByStoreId(storeId, queryParams) {
    const params = { limit: 20, sortBy: ["updatedAt:desc"], status: "UNPUBLISHED", ...queryParams };
    const url = "/platform/admin/namespaces/{namespace}/stores/{storeId}/catalogChanges/byCriteria".replace("{namespace}", this.namespace).replace("{storeId}", storeId);
    const resultPromise = this.axiosInstance.get(url, { params });
    return Validate4.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      CatalogChangePagingResult,
      "CatalogChangePagingResult"
    );
  }
  /**
   * This API is used to publish all unpublished changes.&lt;p&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: no content&lt;/li&gt;&lt;/ul&gt;
   */
  updateCatalogChangePublishAll_ByStoreId(storeId) {
    const params = {};
    const url = "/platform/admin/namespaces/{namespace}/stores/{storeId}/catalogChanges/publishAll".replace("{namespace}", this.namespace).replace("{storeId}", storeId);
    const resultPromise = this.axiosInstance.put(url, null, { params });
    return Validate4.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, StoreInfo, "StoreInfo");
  }
  /**
   * This API is used to query catalog changes statistics .&lt;p&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: catalog changes statistics changes&lt;/li&gt;&lt;/ul&gt;
   */
  getCatalogChangesStatistics_ByStoreId(storeId, queryParams) {
    const params = { ...queryParams };
    const url = "/platform/admin/namespaces/{namespace}/stores/{storeId}/catalogChanges/statistics".replace("{namespace}", this.namespace).replace("{storeId}", storeId);
    const resultPromise = this.axiosInstance.get(url, { params });
    return Validate4.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      CatalogChangeStatistics,
      "CatalogChangeStatistics"
    );
  }
  /**
   * Unselect all change.
   */
  updateCatalogChangeUnselectAll_ByStoreId(storeId) {
    const params = {};
    const url = "/platform/admin/namespaces/{namespace}/stores/{storeId}/catalogChanges/unselectAll".replace("{namespace}", this.namespace).replace("{storeId}", storeId);
    const resultPromise = this.axiosInstance.put(url, null, { params });
    return Validate4.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, z28.unknown(), "z.unknown()");
  }
  /**
   * This API is used to publish selected unpublished changes.&lt;p&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: no content&lt;/li&gt;&lt;/ul&gt;
   */
  updateCatalogChangePublishSelected_ByStoreId(storeId) {
    const params = {};
    const url = "/platform/admin/namespaces/{namespace}/stores/{storeId}/catalogChanges/publishSelected".replace("{namespace}", this.namespace).replace("{storeId}", storeId);
    const resultPromise = this.axiosInstance.put(url, null, { params });
    return Validate4.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, StoreInfo, "StoreInfo");
  }
  /**
   * Select a change, it will be included when partial publish.
   */
  updateSelect_ByStoreId_ByChangeId(storeId, changeId) {
    const params = {};
    const url = "/platform/admin/namespaces/{namespace}/stores/{storeId}/catalogChanges/{changeId}/select".replace("{namespace}", this.namespace).replace("{storeId}", storeId).replace("{changeId}", changeId);
    const resultPromise = this.axiosInstance.put(url, null, { params });
    return Validate4.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, z28.unknown(), "z.unknown()");
  }
  /**
   * Unselect a change, it will not be included when partial publish.
   */
  updateUnselect_ByStoreId_ByChangeId(storeId, changeId) {
    const params = {};
    const url = "/platform/admin/namespaces/{namespace}/stores/{storeId}/catalogChanges/{changeId}/unselect".replace("{namespace}", this.namespace).replace("{storeId}", storeId).replace("{changeId}", changeId);
    const resultPromise = this.axiosInstance.put(url, null, { params });
    return Validate4.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, z28.unknown(), "z.unknown()");
  }
  /**
   * Select all changes by criteria
   */
  updateCatalogChangeSelectAllByCriteria_ByStoreId(storeId, queryParams) {
    const params = { ...queryParams };
    const url = "/platform/admin/namespaces/{namespace}/stores/{storeId}/catalogChanges/selectAllByCriteria".replace("{namespace}", this.namespace).replace("{storeId}", storeId);
    const resultPromise = this.axiosInstance.put(url, null, { params });
    return Validate4.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, z28.unknown(), "z.unknown()");
  }
};

// src/generated-admin/CatalogChangesAdminApi.ts
import { ApiUtils as ApiUtils4, Network as Network4 } from "@accelbyte/sdk";
function CatalogChangesAdminApi(sdk, args) {
  const sdkAssembly = sdk.assembly();
  const namespace = args?.coreConfig?.namespace ?? sdkAssembly.coreConfig.namespace;
  const useSchemaValidation = args?.coreConfig?.useSchemaValidation ?? sdkAssembly.coreConfig.useSchemaValidation;
  let axiosInstance = sdkAssembly.axiosInstance;
  const requestConfigOverrides = args?.axiosConfig?.request;
  const baseURLOverride = args?.coreConfig?.baseURL;
  const interceptorsOverride = args?.axiosConfig?.interceptors ?? [];
  if (requestConfigOverrides || baseURLOverride || interceptorsOverride.length > 0) {
    const requestConfig = ApiUtils4.mergeAxiosConfigs(sdkAssembly.axiosInstance.defaults, {
      ...baseURLOverride ? { baseURL: baseURLOverride } : {},
      ...requestConfigOverrides
    });
    axiosInstance = Network4.create(requestConfig);
    for (const interceptor of interceptorsOverride) {
      if (interceptor.type === "request") {
        axiosInstance.interceptors.request.use(interceptor.onRequest, interceptor.onError);
      }
      if (interceptor.type === "response") {
        axiosInstance.interceptors.response.use(interceptor.onSuccess, interceptor.onError);
      }
    }
  }
  async function updateCatalogChangeSelectAll_ByStoreId(storeId) {
    const $ = new CatalogChangesAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.updateCatalogChangeSelectAll_ByStoreId(storeId);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getCatalogChangesByCriteria_ByStoreId(storeId, queryParams) {
    const $ = new CatalogChangesAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getCatalogChangesByCriteria_ByStoreId(storeId, queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function updateCatalogChangePublishAll_ByStoreId(storeId) {
    const $ = new CatalogChangesAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.updateCatalogChangePublishAll_ByStoreId(storeId);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getCatalogChangesStatistics_ByStoreId(storeId, queryParams) {
    const $ = new CatalogChangesAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getCatalogChangesStatistics_ByStoreId(storeId, queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function updateCatalogChangeUnselectAll_ByStoreId(storeId) {
    const $ = new CatalogChangesAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.updateCatalogChangeUnselectAll_ByStoreId(storeId);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function updateCatalogChangePublishSelected_ByStoreId(storeId) {
    const $ = new CatalogChangesAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.updateCatalogChangePublishSelected_ByStoreId(storeId);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function updateSelect_ByStoreId_ByChangeId(storeId, changeId) {
    const $ = new CatalogChangesAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.updateSelect_ByStoreId_ByChangeId(storeId, changeId);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function updateUnselect_ByStoreId_ByChangeId(storeId, changeId) {
    const $ = new CatalogChangesAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.updateUnselect_ByStoreId_ByChangeId(storeId, changeId);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function updateCatalogChangeSelectAllByCriteria_ByStoreId(storeId, queryParams) {
    const $ = new CatalogChangesAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.updateCatalogChangeSelectAllByCriteria_ByStoreId(storeId, queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  return {
    /**
     * Select all changes.
     */
    updateCatalogChangeSelectAll_ByStoreId,
    /**
     * This API is used to query changes .&lt;p&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: the pagination of changes&lt;/li&gt;&lt;/ul&gt;
     */
    getCatalogChangesByCriteria_ByStoreId,
    /**
     * This API is used to publish all unpublished changes.&lt;p&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: no content&lt;/li&gt;&lt;/ul&gt;
     */
    updateCatalogChangePublishAll_ByStoreId,
    /**
     * This API is used to query catalog changes statistics .&lt;p&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: catalog changes statistics changes&lt;/li&gt;&lt;/ul&gt;
     */
    getCatalogChangesStatistics_ByStoreId,
    /**
     * Unselect all change.
     */
    updateCatalogChangeUnselectAll_ByStoreId,
    /**
     * This API is used to publish selected unpublished changes.&lt;p&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: no content&lt;/li&gt;&lt;/ul&gt;
     */
    updateCatalogChangePublishSelected_ByStoreId,
    /**
     * Select a change, it will be included when partial publish.
     */
    updateSelect_ByStoreId_ByChangeId,
    /**
     * Unselect a change, it will not be included when partial publish.
     */
    updateUnselect_ByStoreId_ByChangeId,
    /**
     * Select all changes by criteria
     */
    updateCatalogChangeSelectAllByCriteria_ByStoreId
  };
}

// src/generated-definitions/BasicCategoryInfo.ts
import { z as z29 } from "zod";
var BasicCategoryInfo = z29.object({
  categoryPath: z29.string(),
  createdAt: z29.string(),
  namespace: z29.string(),
  parentCategoryPath: z29.string(),
  root: z29.boolean().nullish(),
  updatedAt: z29.string()
});

// src/generated-definitions/BasicCategoryInfoArray.ts
import { z as z30 } from "zod";
var BasicCategoryInfoArray = z30.array(BasicCategoryInfo);

// src/generated-definitions/FullCategoryInfo.ts
import { z as z31 } from "zod";
var FullCategoryInfo = z31.object({
  categoryPath: z31.string(),
  createdAt: z31.string(),
  localizationDisplayNames: z31.record(z31.string()),
  namespace: z31.string(),
  parentCategoryPath: z31.string(),
  root: z31.boolean().nullish(),
  updatedAt: z31.string()
});

// src/generated-definitions/FullCategoryInfoArray.ts
import { z as z32 } from "zod";
var FullCategoryInfoArray = z32.array(FullCategoryInfo);

// src/generated-admin/endpoints/CategoryAdmin$.ts
import { Validate as Validate5 } from "@accelbyte/sdk";
var CategoryAdmin$ = class {
  // @ts-ignore
  // prettier-ignore
  constructor(axiosInstance, namespace, useSchemaValidation = true) {
    this.axiosInstance = axiosInstance;
    this.namespace = namespace;
    this.useSchemaValidation = useSchemaValidation;
  }
  /**
   * This API is used to get root categories.&lt;p&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: root category data&lt;/li&gt;&lt;/ul&gt;
   */
  getCategories(queryParams) {
    const params = { ...queryParams };
    const url = "/platform/admin/namespaces/{namespace}/categories".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.get(url, { params });
    return Validate5.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, FullCategoryInfoArray, "FullCategoryInfoArray");
  }
  /**
   * This API is used to create category.&lt;p&gt;A category is a path separated by &#34;/&#34;. A category also has localized display names. Example:&lt;p&gt;&lt;pre&gt;&lt;code&gt;{ &#34;categoryPath&#34;: &#34;/games&#34;, &#34;localizationDisplayNames&#34;: \{&#34;en&#34; : &#34;Games&#34;} }&lt;/code&gt;&lt;/pre&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: created category data&lt;/li&gt;&lt;/ul&gt;
   */
  createCategory(data, queryParams) {
    const params = { ...queryParams };
    const url = "/platform/admin/namespaces/{namespace}/categories".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.post(url, data, { params });
    return Validate5.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, FullCategoryInfo, "FullCategoryInfo");
  }
  /**
   * This API is used to list all categories&#39; basic info of a store ordered by category path.&lt;p&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: list of categories&#39; paths&lt;/li&gt;&lt;/ul&gt;
   */
  getCategoriesBasic(queryParams) {
    const params = { ...queryParams };
    const url = "/platform/admin/namespaces/{namespace}/categories/basic".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.get(url, { params });
    return Validate5.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      BasicCategoryInfoArray,
      "BasicCategoryInfoArray"
    );
  }
  /**
   * This API is used to delete category by category path. &lt;p&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: the deleted category data&lt;/li&gt;&lt;/ul&gt;
   */
  deleteCategory_ByCategoryPath(categoryPath, queryParams) {
    const params = { ...queryParams };
    const url = "/platform/admin/namespaces/{namespace}/categories/{categoryPath}".replace("{namespace}", this.namespace).replace("{categoryPath}", categoryPath);
    const resultPromise = this.axiosInstance.delete(url, { params });
    return Validate5.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, FullCategoryInfo, "FullCategoryInfo");
  }
  /**
   * This API is used to get category by category path.&lt;p&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: category data&lt;/li&gt;&lt;/ul&gt;
   */
  getCategory_ByCategoryPath(categoryPath, queryParams) {
    const params = { ...queryParams };
    const url = "/platform/admin/namespaces/{namespace}/categories/{categoryPath}".replace("{namespace}", this.namespace).replace("{categoryPath}", categoryPath);
    const resultPromise = this.axiosInstance.get(url, { params });
    return Validate5.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, FullCategoryInfo, "FullCategoryInfo");
  }
  /**
   * This API is used to update category. &lt;p&gt; The category update data is a category object, example as:&lt;pre&gt;&lt;code&gt;{ &#34;storeId&#34;: &#34;store-id&#34;, &#34;localizationDisplayNames&#34;: {&#34;en&#34; : &#34;Games&#34;} }&lt;/code&gt;&lt;/pre&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: the updated category data&lt;/li&gt;&lt;/ul&gt;
   */
  updateCategory_ByCategoryPath(categoryPath, data, queryParams) {
    const params = { ...queryParams };
    const url = "/platform/admin/namespaces/{namespace}/categories/{categoryPath}".replace("{namespace}", this.namespace).replace("{categoryPath}", categoryPath);
    const resultPromise = this.axiosInstance.put(url, data, { params });
    return Validate5.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, FullCategoryInfo, "FullCategoryInfo");
  }
  /**
   * This API is used to get child categories by category path.&lt;p&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: list of child categories data&lt;/li&gt;&lt;/ul&gt;
   */
  getChildren_ByCategoryPath(categoryPath, queryParams) {
    const params = { ...queryParams };
    const url = "/platform/admin/namespaces/{namespace}/categories/{categoryPath}/children".replace("{namespace}", this.namespace).replace("{categoryPath}", categoryPath);
    const resultPromise = this.axiosInstance.get(url, { params });
    return Validate5.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, FullCategoryInfoArray, "FullCategoryInfoArray");
  }
  /**
   * This API is used to get descendant categories by category path.&lt;p&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: list of descendant categories data&lt;/li&gt;&lt;/ul&gt;
   */
  getDescendants_ByCategoryPath(categoryPath, queryParams) {
    const params = { ...queryParams };
    const url = "/platform/admin/namespaces/{namespace}/categories/{categoryPath}/descendants".replace("{namespace}", this.namespace).replace("{categoryPath}", categoryPath);
    const resultPromise = this.axiosInstance.get(url, { params });
    return Validate5.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, FullCategoryInfoArray, "FullCategoryInfoArray");
  }
};

// src/generated-admin/CategoryAdminApi.ts
import { ApiUtils as ApiUtils5, Network as Network5 } from "@accelbyte/sdk";
function CategoryAdminApi(sdk, args) {
  const sdkAssembly = sdk.assembly();
  const namespace = args?.coreConfig?.namespace ?? sdkAssembly.coreConfig.namespace;
  const useSchemaValidation = args?.coreConfig?.useSchemaValidation ?? sdkAssembly.coreConfig.useSchemaValidation;
  let axiosInstance = sdkAssembly.axiosInstance;
  const requestConfigOverrides = args?.axiosConfig?.request;
  const baseURLOverride = args?.coreConfig?.baseURL;
  const interceptorsOverride = args?.axiosConfig?.interceptors ?? [];
  if (requestConfigOverrides || baseURLOverride || interceptorsOverride.length > 0) {
    const requestConfig = ApiUtils5.mergeAxiosConfigs(sdkAssembly.axiosInstance.defaults, {
      ...baseURLOverride ? { baseURL: baseURLOverride } : {},
      ...requestConfigOverrides
    });
    axiosInstance = Network5.create(requestConfig);
    for (const interceptor of interceptorsOverride) {
      if (interceptor.type === "request") {
        axiosInstance.interceptors.request.use(interceptor.onRequest, interceptor.onError);
      }
      if (interceptor.type === "response") {
        axiosInstance.interceptors.response.use(interceptor.onSuccess, interceptor.onError);
      }
    }
  }
  async function getCategories(queryParams) {
    const $ = new CategoryAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getCategories(queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function createCategory(data, queryParams) {
    const $ = new CategoryAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.createCategory(data, queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getCategoriesBasic(queryParams) {
    const $ = new CategoryAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getCategoriesBasic(queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function deleteCategory_ByCategoryPath(categoryPath, queryParams) {
    const $ = new CategoryAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.deleteCategory_ByCategoryPath(categoryPath, queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getCategory_ByCategoryPath(categoryPath, queryParams) {
    const $ = new CategoryAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getCategory_ByCategoryPath(categoryPath, queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function updateCategory_ByCategoryPath(categoryPath, data, queryParams) {
    const $ = new CategoryAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.updateCategory_ByCategoryPath(categoryPath, data, queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getChildren_ByCategoryPath(categoryPath, queryParams) {
    const $ = new CategoryAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getChildren_ByCategoryPath(categoryPath, queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getDescendants_ByCategoryPath(categoryPath, queryParams) {
    const $ = new CategoryAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getDescendants_ByCategoryPath(categoryPath, queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  return {
    /**
     * This API is used to get root categories.&lt;p&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: root category data&lt;/li&gt;&lt;/ul&gt;
     */
    getCategories,
    /**
     * This API is used to create category.&lt;p&gt;A category is a path separated by &#34;/&#34;. A category also has localized display names. Example:&lt;p&gt;&lt;pre&gt;&lt;code&gt;{ &#34;categoryPath&#34;: &#34;/games&#34;, &#34;localizationDisplayNames&#34;: \{&#34;en&#34; : &#34;Games&#34;} }&lt;/code&gt;&lt;/pre&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: created category data&lt;/li&gt;&lt;/ul&gt;
     */
    createCategory,
    /**
     * This API is used to list all categories&#39; basic info of a store ordered by category path.&lt;p&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: list of categories&#39; paths&lt;/li&gt;&lt;/ul&gt;
     */
    getCategoriesBasic,
    /**
     * This API is used to delete category by category path. &lt;p&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: the deleted category data&lt;/li&gt;&lt;/ul&gt;
     */
    deleteCategory_ByCategoryPath,
    /**
     * This API is used to get category by category path.&lt;p&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: category data&lt;/li&gt;&lt;/ul&gt;
     */
    getCategory_ByCategoryPath,
    /**
     * This API is used to update category. &lt;p&gt; The category update data is a category object, example as:&lt;pre&gt;&lt;code&gt;{ &#34;storeId&#34;: &#34;store-id&#34;, &#34;localizationDisplayNames&#34;: {&#34;en&#34; : &#34;Games&#34;} }&lt;/code&gt;&lt;/pre&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: the updated category data&lt;/li&gt;&lt;/ul&gt;
     */
    updateCategory_ByCategoryPath,
    /**
     * This API is used to get child categories by category path.&lt;p&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: list of child categories data&lt;/li&gt;&lt;/ul&gt;
     */
    getChildren_ByCategoryPath,
    /**
     * This API is used to get descendant categories by category path.&lt;p&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: list of descendant categories data&lt;/li&gt;&lt;/ul&gt;
     */
    getDescendants_ByCategoryPath
  };
}

// src/generated-definitions/ClawbackInfo.ts
import { z as z33 } from "zod";
var ClawbackInfo = z33.object({
  createdAt: z33.string().nullish(),
  dryRun: z33.boolean().nullish(),
  eventContent: z33.record(z33.any()).nullish(),
  eventId: z33.string().nullish(),
  eventType: z33.string().nullish(),
  externalOrderId: z33.string().nullish(),
  feedbackContent: z33.record(z33.any()).nullish(),
  feedbackStatus: z33.enum(["FAIL", "INIT", "SUCCESS"]).nullish(),
  feedbackStatusReason: z33.string().nullish(),
  id: z33.string(),
  namespace: z33.string(),
  platform: z33.string().nullish(),
  processId: z33.string().nullish(),
  status: z33.enum(["FAIL", "IGNORED", "INIT", "SUCCESS"]).nullish(),
  statusReason: z33.string().nullish(),
  updatedAt: z33.string().nullish(),
  userId: z33.string().nullish()
});

// src/generated-definitions/IapClawbackPagingSlicedResult.ts
import { z as z34 } from "zod";
var IapClawbackPagingSlicedResult = z34.object({ data: z34.array(ClawbackInfo), paging: Paging.nullish() });

// src/generated-admin/endpoints/ClawbackAdmin$.ts
import { Validate as Validate6 } from "@accelbyte/sdk";
var ClawbackAdmin$ = class {
  // @ts-ignore
  // prettier-ignore
  constructor(axiosInstance, namespace, useSchemaValidation = true) {
    this.axiosInstance = axiosInstance;
    this.namespace = namespace;
    this.useSchemaValidation = useSchemaValidation;
  }
  /**
   * Query clawback history.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: paginated clawback history&lt;/li&gt;&lt;/ul&gt;
   */
  getIapClawbackHistories(queryParams) {
    const params = { limit: 20, ...queryParams };
    const url = "/platform/admin/namespaces/{namespace}/iap/clawback/histories".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.get(url, { params });
    return Validate6.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      IapClawbackPagingSlicedResult,
      "IapClawbackPagingSlicedResult"
    );
  }
  /**
   * Mock Sync PlayStation Clawback event..
   */
  createIapClawbackPlaystationMock(data) {
    const params = {};
    const url = "/platform/admin/namespaces/{namespace}/iap/clawback/playstation/mock".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.post(url, data, { params });
    return Validate6.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, ClawbackInfo, "ClawbackInfo");
  }
};

// src/generated-admin/ClawbackAdminApi.ts
import { ApiUtils as ApiUtils6, Network as Network6 } from "@accelbyte/sdk";
function ClawbackAdminApi(sdk, args) {
  const sdkAssembly = sdk.assembly();
  const namespace = args?.coreConfig?.namespace ?? sdkAssembly.coreConfig.namespace;
  const useSchemaValidation = args?.coreConfig?.useSchemaValidation ?? sdkAssembly.coreConfig.useSchemaValidation;
  let axiosInstance = sdkAssembly.axiosInstance;
  const requestConfigOverrides = args?.axiosConfig?.request;
  const baseURLOverride = args?.coreConfig?.baseURL;
  const interceptorsOverride = args?.axiosConfig?.interceptors ?? [];
  if (requestConfigOverrides || baseURLOverride || interceptorsOverride.length > 0) {
    const requestConfig = ApiUtils6.mergeAxiosConfigs(sdkAssembly.axiosInstance.defaults, {
      ...baseURLOverride ? { baseURL: baseURLOverride } : {},
      ...requestConfigOverrides
    });
    axiosInstance = Network6.create(requestConfig);
    for (const interceptor of interceptorsOverride) {
      if (interceptor.type === "request") {
        axiosInstance.interceptors.request.use(interceptor.onRequest, interceptor.onError);
      }
      if (interceptor.type === "response") {
        axiosInstance.interceptors.response.use(interceptor.onSuccess, interceptor.onError);
      }
    }
  }
  async function getIapClawbackHistories(queryParams) {
    const $ = new ClawbackAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getIapClawbackHistories(queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function createIapClawbackPlaystationMock(data) {
    const $ = new ClawbackAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.createIapClawbackPlaystationMock(data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  return {
    /**
     * Query clawback history.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: paginated clawback history&lt;/li&gt;&lt;/ul&gt;
     */
    getIapClawbackHistories,
    /**
     * Mock Sync PlayStation Clawback event..
     */
    createIapClawbackPlaystationMock
  };
}

// src/generated-definitions/CurrencyConfig.ts
import { z as z35 } from "zod";
var CurrencyConfig = z35.object({ currencySymbol: z35.string() });

// src/generated-definitions/CurrencyInfo.ts
import { z as z36 } from "zod";
var CurrencyInfo = z36.object({
  createdAt: z36.string(),
  currencyCode: z36.string(),
  currencySymbol: z36.string(),
  currencyType: z36.enum(["REAL", "VIRTUAL"]),
  decimals: z36.number().int(),
  localizationDescriptions: z36.record(z36.string()).nullish(),
  namespace: z36.string(),
  updatedAt: z36.string()
});

// src/generated-definitions/CurrencyInfoArray.ts
import { z as z37 } from "zod";
var CurrencyInfoArray = z37.array(CurrencyInfo);

// src/generated-definitions/CurrencySummary.ts
import { z as z38 } from "zod";
var CurrencySummary = z38.object({
  currencyCode: z38.string(),
  currencySymbol: z38.string(),
  currencyType: z38.enum(["REAL", "VIRTUAL"]),
  decimals: z38.number().int(),
  namespace: z38.string()
});

// src/generated-admin/endpoints/CurrencyAdmin$.ts
import { Validate as Validate7 } from "@accelbyte/sdk";
var CurrencyAdmin$ = class {
  // @ts-ignore
  // prettier-ignore
  constructor(axiosInstance, namespace, useSchemaValidation = true) {
    this.axiosInstance = axiosInstance;
    this.namespace = namespace;
    this.useSchemaValidation = useSchemaValidation;
  }
  /**
   * List currencies of a namespace.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: Currency List&lt;/li&gt;&lt;/ul&gt;
   */
  getCurrencies(queryParams) {
    const params = { ...queryParams };
    const url = "/platform/admin/namespaces/{namespace}/currencies".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.get(url, { params });
    return Validate7.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, CurrencyInfoArray, "CurrencyInfoArray");
  }
  /**
   * Create a currency.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: created currency&lt;/li&gt;&lt;/ul&gt;
   */
  createCurrency(data) {
    const params = {};
    const url = "/platform/admin/namespaces/{namespace}/currencies".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.post(url, data, { params });
    return Validate7.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, CurrencyInfo, "CurrencyInfo");
  }
  /**
   * Delete a currency by currency code.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: &lt;/li&gt;&lt;/ul&gt;
   */
  deleteCurrency_ByCurrencyCode(currencyCode) {
    const params = {};
    const url = "/platform/admin/namespaces/{namespace}/currencies/{currencyCode}".replace("{namespace}", this.namespace).replace("{currencyCode}", currencyCode);
    const resultPromise = this.axiosInstance.delete(url, { params });
    return Validate7.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, CurrencyInfo, "CurrencyInfo");
  }
  /**
   * Update a currency by currency code.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: updated currency&lt;/li&gt;&lt;/ul&gt;
   */
  updateCurrency_ByCurrencyCode(currencyCode, data) {
    const params = {};
    const url = "/platform/admin/namespaces/{namespace}/currencies/{currencyCode}".replace("{namespace}", this.namespace).replace("{currencyCode}", currencyCode);
    const resultPromise = this.axiosInstance.put(url, data, { params });
    return Validate7.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, CurrencyInfo, "CurrencyInfo");
  }
  /**
   * &lt;b&gt;[SERVICE COMMUNICATION ONLY]&lt;/b&gt; Get currency config by code.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: simplified Currency&lt;/li&gt;&lt;/ul&gt;
   */
  getConfig_ByCurrencyCode(currencyCode) {
    const params = {};
    const url = "/platform/admin/namespaces/{namespace}/currencies/{currencyCode}/config".replace("{namespace}", this.namespace).replace("{currencyCode}", currencyCode);
    const resultPromise = this.axiosInstance.get(url, { params });
    return Validate7.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, CurrencyConfig, "CurrencyConfig");
  }
  /**
   * Get currency summary by code.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: simplified Currency&lt;/li&gt;&lt;/ul&gt;
   */
  getSummary_ByCurrencyCode(currencyCode) {
    const params = {};
    const url = "/platform/admin/namespaces/{namespace}/currencies/{currencyCode}/summary".replace("{namespace}", this.namespace).replace("{currencyCode}", currencyCode);
    const resultPromise = this.axiosInstance.get(url, { params });
    return Validate7.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, CurrencySummary, "CurrencySummary");
  }
};

// src/generated-admin/CurrencyAdminApi.ts
import { ApiUtils as ApiUtils7, Network as Network7 } from "@accelbyte/sdk";
function CurrencyAdminApi(sdk, args) {
  const sdkAssembly = sdk.assembly();
  const namespace = args?.coreConfig?.namespace ?? sdkAssembly.coreConfig.namespace;
  const useSchemaValidation = args?.coreConfig?.useSchemaValidation ?? sdkAssembly.coreConfig.useSchemaValidation;
  let axiosInstance = sdkAssembly.axiosInstance;
  const requestConfigOverrides = args?.axiosConfig?.request;
  const baseURLOverride = args?.coreConfig?.baseURL;
  const interceptorsOverride = args?.axiosConfig?.interceptors ?? [];
  if (requestConfigOverrides || baseURLOverride || interceptorsOverride.length > 0) {
    const requestConfig = ApiUtils7.mergeAxiosConfigs(sdkAssembly.axiosInstance.defaults, {
      ...baseURLOverride ? { baseURL: baseURLOverride } : {},
      ...requestConfigOverrides
    });
    axiosInstance = Network7.create(requestConfig);
    for (const interceptor of interceptorsOverride) {
      if (interceptor.type === "request") {
        axiosInstance.interceptors.request.use(interceptor.onRequest, interceptor.onError);
      }
      if (interceptor.type === "response") {
        axiosInstance.interceptors.response.use(interceptor.onSuccess, interceptor.onError);
      }
    }
  }
  async function getCurrencies(queryParams) {
    const $ = new CurrencyAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getCurrencies(queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function createCurrency(data) {
    const $ = new CurrencyAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.createCurrency(data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function deleteCurrency_ByCurrencyCode(currencyCode) {
    const $ = new CurrencyAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.deleteCurrency_ByCurrencyCode(currencyCode);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function updateCurrency_ByCurrencyCode(currencyCode, data) {
    const $ = new CurrencyAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.updateCurrency_ByCurrencyCode(currencyCode, data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getConfig_ByCurrencyCode(currencyCode) {
    const $ = new CurrencyAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getConfig_ByCurrencyCode(currencyCode);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getSummary_ByCurrencyCode(currencyCode) {
    const $ = new CurrencyAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getSummary_ByCurrencyCode(currencyCode);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  return {
    /**
     * List currencies of a namespace.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: Currency List&lt;/li&gt;&lt;/ul&gt;
     */
    getCurrencies,
    /**
     * Create a currency.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: created currency&lt;/li&gt;&lt;/ul&gt;
     */
    createCurrency,
    /**
     * Delete a currency by currency code.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: &lt;/li&gt;&lt;/ul&gt;
     */
    deleteCurrency_ByCurrencyCode,
    /**
     * Update a currency by currency code.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: updated currency&lt;/li&gt;&lt;/ul&gt;
     */
    updateCurrency_ByCurrencyCode,
    /**
     * &lt;b&gt;[SERVICE COMMUNICATION ONLY]&lt;/b&gt; Get currency config by code.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: simplified Currency&lt;/li&gt;&lt;/ul&gt;
     */
    getConfig_ByCurrencyCode,
    /**
     * Get currency summary by code.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: simplified Currency&lt;/li&gt;&lt;/ul&gt;
     */
    getSummary_ByCurrencyCode
  };
}

// src/generated-definitions/PlatformRewardCurrency.ts
import { z as z39 } from "zod";
var PlatformRewardCurrency = z39.object({ currencyCode: z39.string(), namespace: z39.string() });

// src/generated-definitions/PlatformRewardItem.ts
import { z as z40 } from "zod";
var PlatformRewardItem = z40.object({
  itemId: z40.string().nullish(),
  itemName: z40.string().nullish(),
  itemSku: z40.string().nullish(),
  itemType: z40.string().nullish()
});

// src/generated-definitions/PlatformReward.ts
import { z as z41 } from "zod";
var PlatformReward = z41.object({
  currency: PlatformRewardCurrency.nullish(),
  item: PlatformRewardItem.nullish(),
  quantity: z41.number().int().nullish(),
  type: z41.enum(["CURRENCY", "ITEM"]).nullish()
});

// src/generated-definitions/DlcItem.ts
import { z as z42 } from "zod";
var DlcItem = z42.object({ id: z42.string().nullish(), rewards: z42.array(PlatformReward).nullish() });

// src/generated-definitions/DlcItemConfigInfo.ts
import { z as z43 } from "zod";
var DlcItemConfigInfo = z43.object({ data: z43.array(DlcItem).nullish() });

// src/generated-definitions/PlatformDlcEntry.ts
import { z as z44 } from "zod";
var PlatformDlcEntry = z44.object({
  platform: z44.enum(["EPICGAMES", "OCULUS", "PSN", "STEAM", "XBOX"]).nullish(),
  platformDlcIdMap: z44.record(z44.string()).nullish()
});

// src/generated-definitions/PlatformDlcConfigInfo.ts
import { z as z45 } from "zod";
var PlatformDlcConfigInfo = z45.object({ data: z45.array(PlatformDlcEntry).nullish() });

// src/generated-definitions/RewardMigrationResult.ts
import { z as z46 } from "zod";
var RewardMigrationResult = z46.object({
  itemId: z46.string().nullish(),
  quantity: z46.number().int().nullish(),
  reason: z46.string().nullish(),
  sku: z46.string().nullish(),
  status: z46.enum(["FAIL", "SUCCESS"]).nullish(),
  syncedCount: z46.number().int().nullish(),
  syncedEntitlementIds: z46.array(z46.string()).nullish()
});

// src/generated-definitions/EntitlementOriginSyncResult.ts
import { z as z47 } from "zod";
var EntitlementOriginSyncResult = z47.object({
  reason: z47.string().nullish(),
  reward: PlatformReward.nullish(),
  summary: z47.array(RewardMigrationResult).nullish()
});

// src/generated-definitions/CreditRevocation.ts
import { z as z48 } from "zod";
var CreditRevocation = z48.object({
  amount: z48.number().int().nullish(),
  balanceOrigin: z48.string().nullish(),
  currencyCode: z48.string().nullish(),
  customRevocation: z48.record(z48.any()).nullish(),
  reason: z48.string().nullish(),
  revocationStrategy: z48.string().nullish(),
  skipped: z48.boolean().nullish(),
  status: z48.enum(["FAIL", "SUCCESS"]).nullish(),
  walletId: z48.string().nullish()
});

// src/generated-definitions/EntitlementRevocation.ts
import { z as z49 } from "zod";
var EntitlementRevocation = z49.object({
  customRevocation: z49.record(z49.any()).nullish(),
  entitlementId: z49.string().nullish(),
  itemId: z49.string().nullish(),
  itemSku: z49.string().nullish(),
  quantity: z49.number().int().nullish(),
  reason: z49.string().nullish(),
  revocationStrategy: z49.string().nullish(),
  skipped: z49.boolean().nullish(),
  status: z49.enum(["FAIL", "SUCCESS"]).nullish()
});

// src/generated-definitions/ItemRevocation.ts
import { z as z50 } from "zod";
var ItemRevocation = z50.lazy(
  () => z50.object({
    creditRevocations: z50.array(CreditRevocation).nullish(),
    customRevocation: z50.record(z50.any()).nullish(),
    entitlementOrigin: z50.enum(["Epic", "GooglePlay", "IOS", "Nintendo", "Oculus", "Other", "Playstation", "Steam", "System", "Twitch", "Xbox"]).nullish(),
    entitlementRevocations: z50.array(EntitlementRevocation).nullish(),
    itemId: z50.string().nullish(),
    itemRevocations: z50.array(ItemRevocation).nullish(),
    itemSku: z50.string().nullish(),
    itemType: z50.enum(["APP", "BUNDLE", "CODE", "COINS", "EXTENSION", "INGAMEITEM", "LOOTBOX", "MEDIA", "OPTIONBOX", "SEASON", "SUBSCRIPTION"]).nullish(),
    quantity: z50.number().int().nullish(),
    reason: z50.string().nullish(),
    skipped: z50.boolean().nullish(),
    status: z50.enum(["FAIL", "SUCCESS"]).nullish(),
    strategy: z50.string().nullish()
  })
);

// src/generated-definitions/RevocationResult.ts
import { z as z51 } from "zod";
var RevocationResult = z51.object({
  creditRevocations: z51.array(CreditRevocation).nullish(),
  entitlementRevocations: z51.array(EntitlementRevocation).nullish(),
  id: z51.string(),
  itemRevocations: z51.array(ItemRevocation).nullish(),
  status: z51.enum(["FAIL", "SUCCESS"])
});

// src/generated-definitions/RevokeItemSummary.ts
import { z as z52 } from "zod";
var RevokeItemSummary = z52.object({
  itemId: z52.string().nullish(),
  itemSku: z52.string().nullish(),
  itemType: z52.string().nullish(),
  revokeStatus: z52.enum(["COMPLETED", "SKIPPED"]).nullish()
});

// src/generated-definitions/RevokeResult.ts
import { z as z53 } from "zod";
var RevokeResult = z53.object({
  revokeItemSummaries: z53.array(RevokeItemSummary).nullish(),
  reward: PlatformReward.nullish(),
  status: z53.enum(["COMPLETED", "SKIPPED"]).nullish()
});

// src/generated-definitions/DlcRecord.ts
import { z as z54 } from "zod";
var DlcRecord = z54.object({
  entitlementOriginSyncResult: z54.array(EntitlementOriginSyncResult).nullish(),
  entitlementOriginSyncStatus: z54.enum(["NOT_SYNCED", "SYNCED", "SYNCED_FAILED"]).nullish(),
  id: z54.string().nullish(),
  metadata: z54.record(z54.any()).nullish(),
  obtainedAt: z54.string().nullish(),
  revocationResult: RevocationResult.nullish(),
  revokeResults: z54.array(RevokeResult).nullish(),
  revokedAt: z54.string().nullish(),
  rewards: z54.array(PlatformReward).nullish(),
  sources: z54.array(z54.string()).nullish(),
  status: z54.enum(["FULFILLED", "REVOKED", "REVOKE_FAILED"]).nullish(),
  transactionId: z54.string().nullish(),
  version: z54.number().int().nullish()
});

// src/generated-definitions/UserDlc.ts
import { z as z55 } from "zod";
var UserDlc = z55.object({
  createdAt: z55.string().nullish(),
  dlcs: z55.array(DlcRecord).nullish(),
  id: z55.string().nullish(),
  namespace: z55.string().nullish(),
  platform: z55.enum(["EPICGAMES", "OCULUS", "PSN", "STEAM", "XBOX"]).nullish(),
  rvn: z55.number().int().nullish(),
  updatedAt: z55.string().nullish(),
  userId: z55.string().nullish()
});

// src/generated-definitions/UserDlcRecord.ts
import { z as z56 } from "zod";
var UserDlcRecord = z56.object({
  entitlementOriginSyncResult: z56.array(EntitlementOriginSyncResult).nullish(),
  entitlementOriginSyncStatus: z56.enum(["NOT_SYNCED", "SYNCED", "SYNCED_FAILED"]).nullish(),
  id: z56.string().nullish(),
  metadata: z56.record(z56.any()).nullish(),
  namespace: z56.string().nullish(),
  obtainedAt: z56.string().nullish(),
  platform: z56.enum(["EPICGAMES", "OCULUS", "PSN", "STEAM", "XBOX"]).nullish(),
  revocationResult: RevocationResult.nullish(),
  revokeResults: z56.array(RevokeResult).nullish(),
  revokedAt: z56.string().nullish(),
  rewards: z56.array(PlatformReward).nullish(),
  sources: z56.array(z56.string()).nullish(),
  status: z56.enum(["FULFILLED", "REVOKED", "REVOKE_FAILED"]).nullish(),
  transactionId: z56.string().nullish(),
  userId: z56.string().nullish(),
  version: z56.number().int().nullish()
});

// src/generated-definitions/UserDlcRecordArray.ts
import { z as z57 } from "zod";
var UserDlcRecordArray = z57.array(UserDlcRecord);

// src/generated-admin/endpoints/DlcAdmin$.ts
import { Validate as Validate8 } from "@accelbyte/sdk";
import { z as z58 } from "zod";
var DlcAdmin$ = class {
  // @ts-ignore
  // prettier-ignore
  constructor(axiosInstance, namespace, useSchemaValidation = true) {
    this.axiosInstance = axiosInstance;
    this.namespace = namespace;
    this.useSchemaValidation = useSchemaValidation;
  }
  /**
   * delete a DLC item config.
   */
  deleteDlcConfigItem() {
    const params = {};
    const url = "/platform/admin/namespaces/{namespace}/dlc/config/item".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.delete(url, { params });
    return Validate8.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, z58.unknown(), "z.unknown()");
  }
  /**
   * Get DLC item config.
   */
  getDlcConfigItem() {
    const params = {};
    const url = "/platform/admin/namespaces/{namespace}/dlc/config/item".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.get(url, { params });
    return Validate8.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, DlcItemConfigInfo, "DlcItemConfigInfo");
  }
  /**
   * Update DLC item config. Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: updated DLC item config&lt;/li&gt;&lt;/ul&gt;
   */
  updateDlcConfigItem(data) {
    const params = {};
    const url = "/platform/admin/namespaces/{namespace}/dlc/config/item".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.put(url, data, { params });
    return Validate8.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, DlcItemConfigInfo, "DlcItemConfigInfo");
  }
  /**
   * Get user dlc by platform.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: user dlc&lt;/li&gt;&lt;/ul&gt;
   */
  getDlc_ByUserId(userId, queryParams) {
    const params = { ...queryParams };
    const url = "/platform/admin/namespaces/{namespace}/users/{userId}/dlc".replace("{namespace}", this.namespace).replace("{userId}", userId);
    const resultPromise = this.axiosInstance.get(url, { params });
    return Validate8.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, UserDlc, "UserDlc");
  }
  /**
   * delete a Platform DLC config.
   */
  deleteDlcConfigPlatformMap() {
    const params = {};
    const url = "/platform/admin/namespaces/{namespace}/dlc/config/platformMap".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.delete(url, { params });
    return Validate8.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, z58.unknown(), "z.unknown()");
  }
  /**
   * Get Platform DLC config.
   */
  getDlcConfigPlatformMap() {
    const params = {};
    const url = "/platform/admin/namespaces/{namespace}/dlc/config/platformMap".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.get(url, { params });
    return Validate8.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, PlatformDlcConfigInfo, "PlatformDlcConfigInfo");
  }
  /**
   * Update Platform DLC config. Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: updated Platform DLC config&lt;/li&gt;&lt;/ul&gt;&lt;h2&gt;Restrictions for platform dlc map&lt;/h2&gt; 1. Cannot use &lt;b&gt;&#34;.&#34;&lt;/b&gt; as the key name - &lt;pre&gt;{ &#34;data.2&#34;: &#34;value&#34; }&lt;/pre&gt; 2. Cannot use &lt;b&gt;&#34;$&#34;&lt;/b&gt; as the prefix in key names - &lt;pre&gt;{ &#34;$data&#34;: &#34;value&#34; }&lt;/pre&gt;
   */
  updateDlcConfigPlatformMap(data) {
    const params = {};
    const url = "/platform/admin/namespaces/{namespace}/dlc/config/platformMap".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.put(url, data, { params });
    return Validate8.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, PlatformDlcConfigInfo, "PlatformDlcConfigInfo");
  }
  /**
   * Get user dlc records.&lt;br&gt;Note: includeAllNamespaces means this endpoint will return user dlcs from all namespace, example scenario isadmin may need to check the user dlcs before unlink a 3rd party account, so the user dlcs should be from all namespaces because unlinking is a platform level action &lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: user dlc&lt;/li&gt;&lt;/ul&gt;
   */
  getDlcRecords_ByUserId(userId, queryParams) {
    const params = { ...queryParams };
    const url = "/platform/admin/namespaces/{namespace}/users/{userId}/dlc/records".replace("{namespace}", this.namespace).replace("{userId}", userId);
    const resultPromise = this.axiosInstance.get(url, { params });
    return Validate8.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, UserDlcRecordArray, "UserDlcRecordArray");
  }
};

// src/generated-admin/DlcAdminApi.ts
import { ApiUtils as ApiUtils8, Network as Network8 } from "@accelbyte/sdk";
function DlcAdminApi(sdk, args) {
  const sdkAssembly = sdk.assembly();
  const namespace = args?.coreConfig?.namespace ?? sdkAssembly.coreConfig.namespace;
  const useSchemaValidation = args?.coreConfig?.useSchemaValidation ?? sdkAssembly.coreConfig.useSchemaValidation;
  let axiosInstance = sdkAssembly.axiosInstance;
  const requestConfigOverrides = args?.axiosConfig?.request;
  const baseURLOverride = args?.coreConfig?.baseURL;
  const interceptorsOverride = args?.axiosConfig?.interceptors ?? [];
  if (requestConfigOverrides || baseURLOverride || interceptorsOverride.length > 0) {
    const requestConfig = ApiUtils8.mergeAxiosConfigs(sdkAssembly.axiosInstance.defaults, {
      ...baseURLOverride ? { baseURL: baseURLOverride } : {},
      ...requestConfigOverrides
    });
    axiosInstance = Network8.create(requestConfig);
    for (const interceptor of interceptorsOverride) {
      if (interceptor.type === "request") {
        axiosInstance.interceptors.request.use(interceptor.onRequest, interceptor.onError);
      }
      if (interceptor.type === "response") {
        axiosInstance.interceptors.response.use(interceptor.onSuccess, interceptor.onError);
      }
    }
  }
  async function deleteDlcConfigItem() {
    const $ = new DlcAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.deleteDlcConfigItem();
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getDlcConfigItem() {
    const $ = new DlcAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getDlcConfigItem();
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function updateDlcConfigItem(data) {
    const $ = new DlcAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.updateDlcConfigItem(data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getDlc_ByUserId(userId, queryParams) {
    const $ = new DlcAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getDlc_ByUserId(userId, queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function deleteDlcConfigPlatformMap() {
    const $ = new DlcAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.deleteDlcConfigPlatformMap();
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getDlcConfigPlatformMap() {
    const $ = new DlcAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getDlcConfigPlatformMap();
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function updateDlcConfigPlatformMap(data) {
    const $ = new DlcAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.updateDlcConfigPlatformMap(data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getDlcRecords_ByUserId(userId, queryParams) {
    const $ = new DlcAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getDlcRecords_ByUserId(userId, queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  return {
    /**
     * delete a DLC item config.
     */
    deleteDlcConfigItem,
    /**
     * Get DLC item config.
     */
    getDlcConfigItem,
    /**
     * Update DLC item config. Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: updated DLC item config&lt;/li&gt;&lt;/ul&gt;
     */
    updateDlcConfigItem,
    /**
     * Get user dlc by platform.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: user dlc&lt;/li&gt;&lt;/ul&gt;
     */
    getDlc_ByUserId,
    /**
     * delete a Platform DLC config.
     */
    deleteDlcConfigPlatformMap,
    /**
     * Get Platform DLC config.
     */
    getDlcConfigPlatformMap,
    /**
     * Update Platform DLC config. Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: updated Platform DLC config&lt;/li&gt;&lt;/ul&gt;&lt;h2&gt;Restrictions for platform dlc map&lt;/h2&gt; 1. Cannot use &lt;b&gt;&#34;.&#34;&lt;/b&gt; as the key name - &lt;pre&gt;{ &#34;data.2&#34;: &#34;value&#34; }&lt;/pre&gt; 2. Cannot use &lt;b&gt;&#34;$&#34;&lt;/b&gt; as the prefix in key names - &lt;pre&gt;{ &#34;$data&#34;: &#34;value&#34; }&lt;/pre&gt;
     */
    updateDlcConfigPlatformMap,
    /**
     * Get user dlc records.&lt;br&gt;Note: includeAllNamespaces means this endpoint will return user dlcs from all namespace, example scenario isadmin may need to check the user dlcs before unlink a 3rd party account, so the user dlcs should be from all namespaces because unlinking is a platform level action &lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: user dlc&lt;/li&gt;&lt;/ul&gt;
     */
    getDlcRecords_ByUserId
  };
}

// src/generated-definitions/InventoryConfig.ts
import { z as z59 } from "zod";
var InventoryConfig = z59.object({
  customAttributes: z59.record(z59.any()).nullish(),
  serverCustomAttributes: z59.record(z59.any()).nullish(),
  slotUsed: z59.number().int().nullish()
});

// src/generated-definitions/BoxItem.ts
import { z as z60 } from "zod";
var BoxItem = z60.object({
  count: z60.number().int().nullish(),
  duration: z60.number().int().nullish(),
  endDate: z60.string().nullish(),
  itemId: z60.string().nullish(),
  itemSku: z60.string().nullish(),
  itemType: z60.string().nullish()
});

// src/generated-definitions/LootBoxReward.ts
import { z as z61 } from "zod";
var LootBoxReward = z61.object({
  lootBoxItems: z61.array(BoxItem).nullish(),
  name: z61.string().nullish(),
  odds: z61.number().nullish(),
  type: z61.enum(["PROBABILITY_GROUP", "REWARD", "REWARD_GROUP"]).nullish(),
  weight: z61.number().int().nullish()
});

// src/generated-definitions/LootBoxConfig.ts
import { z as z62 } from "zod";
var LootBoxConfig = z62.object({
  rewardCount: z62.number().int().nullish(),
  rewards: z62.array(LootBoxReward).nullish(),
  rollFunction: z62.enum(["CUSTOM", "DEFAULT"]).nullish()
});

// src/generated-definitions/OptionBoxConfig.ts
import { z as z63 } from "zod";
var OptionBoxConfig = z63.object({ boxItems: z63.array(BoxItem).nullish() });

// src/generated-definitions/Recurring.ts
import { z as z64 } from "zod";
var Recurring = z64.object({
  cycle: z64.enum(["MONTHLY", "QUARTERLY", "WEEKLY", "YEARLY"]),
  fixedFreeDays: z64.number().int(),
  fixedTrialCycles: z64.number().int(),
  graceDays: z64.number().int()
});

// src/generated-definitions/RegionDataItem.ts
import { z as z65 } from "zod";
var RegionDataItem = z65.object({
  currencyCode: z65.string(),
  currencyNamespace: z65.string(),
  currencyType: z65.enum(["REAL", "VIRTUAL"]),
  discountAmount: z65.number().int().nullish(),
  discountExpireAt: z65.string().nullish(),
  discountPercentage: z65.number().int().nullish(),
  discountPurchaseAt: z65.string().nullish(),
  discountedPrice: z65.number().int().nullish(),
  expireAt: z65.string().nullish(),
  price: z65.number().int().nullish(),
  purchaseAt: z65.string().nullish(),
  trialPrice: z65.number().int().nullish()
});

// src/generated-definitions/SaleConfig.ts
import { z as z66 } from "zod";
var SaleConfig = z66.object({ currencyCode: z66.string(), price: z66.number().int() });

// src/generated-definitions/ItemSnapshot.ts
import { z as z67 } from "zod";
var ItemSnapshot = z67.object({
  appId: z67.string().nullish(),
  appType: z67.enum(["DEMO", "DLC", "GAME", "SOFTWARE"]).nullish(),
  baseAppId: z67.string().nullish(),
  boothName: z67.string().nullish(),
  createdAt: z67.string().nullish(),
  description: z67.string().nullish(),
  entitlementType: z67.enum(["CONSUMABLE", "DURABLE"]),
  features: z67.array(z67.string()).nullish(),
  flexible: z67.boolean().nullish(),
  inventoryConfig: InventoryConfig.nullish(),
  itemId: z67.string(),
  itemIds: z67.array(z67.string()).nullish(),
  itemQty: z67.record(z67.number().int()).nullish(),
  itemType: z67.enum([
    "APP",
    "BUNDLE",
    "CODE",
    "COINS",
    "EXTENSION",
    "INGAMEITEM",
    "LOOTBOX",
    "MEDIA",
    "OPTIONBOX",
    "SEASON",
    "SUBSCRIPTION"
  ]),
  language: z67.string(),
  listable: z67.boolean().nullish(),
  lootBoxConfig: LootBoxConfig.nullish(),
  maxCount: z67.number().int().nullish(),
  maxCountPerUser: z67.number().int().nullish(),
  name: z67.string(),
  namespace: z67.string(),
  optionBoxConfig: OptionBoxConfig.nullish(),
  purchasable: z67.boolean().nullish(),
  recurring: Recurring.nullish(),
  region: z67.string(),
  regionDataItem: RegionDataItem.nullish(),
  saleConfig: SaleConfig.nullish(),
  seasonType: z67.enum(["PASS", "TIER"]).nullish(),
  sectionExclusive: z67.boolean().nullish(),
  sellable: z67.boolean().nullish(),
  sku: z67.string().nullish(),
  stackable: z67.boolean().nullish(),
  targetCurrencyCode: z67.string().nullish(),
  targetItemId: z67.string().nullish(),
  targetNamespace: z67.string().nullish(),
  thumbnailUrl: z67.string().nullish(),
  title: z67.string(),
  updatedAt: z67.string().nullish(),
  useCount: z67.number().int().nullish()
});

// src/generated-definitions/AppEntitlementInfo.ts
import { z as z68 } from "zod";
var AppEntitlementInfo = z68.object({
  appId: z68.string().nullish(),
  appType: z68.enum(["DEMO", "DLC", "GAME", "SOFTWARE"]).nullish(),
  collectionId: z68.string().nullish(),
  endDate: z68.string().nullish(),
  grantedAt: z68.string(),
  itemId: z68.string().nullish(),
  itemSnapshot: ItemSnapshot.nullish(),
  namespace: z68.string(),
  noOrigin: z68.boolean().nullish(),
  origin: z68.enum(["Epic", "GooglePlay", "IOS", "Nintendo", "Oculus", "Other", "Playstation", "Steam", "System", "Twitch", "Xbox"]).nullish(),
  sku: z68.string().nullish(),
  startDate: z68.string().nullish(),
  status: z68.enum(["ACTIVE", "CONSUMED", "INACTIVE", "REVOKED", "SOLD"]),
  storeId: z68.string().nullish(),
  userId: z68.string()
});

// src/generated-definitions/AppEntitlementPagingSlicedResult.ts
import { z as z69 } from "zod";
var AppEntitlementPagingSlicedResult = z69.object({ data: z69.array(AppEntitlementInfo).nullish(), paging: Paging.nullish() });

// src/generated-definitions/EntitlementGrant.ts
import { z as z70 } from "zod";
var EntitlementGrant = z70.object({
  collectionId: z70.string().nullish(),
  endDate: z70.string().nullish(),
  grantedCode: z70.string().nullish(),
  itemId: z70.string(),
  itemNamespace: z70.string(),
  language: z70.string().nullish(),
  metadata: z70.record(z70.any()).nullish(),
  origin: z70.enum(["Epic", "GooglePlay", "IOS", "Nintendo", "Oculus", "Other", "Playstation", "Steam", "System", "Twitch", "Xbox"]).nullish(),
  quantity: z70.number().int(),
  region: z70.string().nullish(),
  source: z70.enum(["ACHIEVEMENT", "GIFT", "IAP", "OTHER", "PROMOTION", "PURCHASE", "REDEEM_CODE", "REFERRAL_BONUS", "REWARD"]).nullish(),
  startDate: z70.string().nullish(),
  storeId: z70.string().nullish()
});

// src/generated-definitions/EntitlementGrantResult.ts
import { z as z71 } from "zod";
var EntitlementGrantResult = z71.object({
  entitlementGrants: EntitlementGrant.nullish(),
  reason: z71.string().nullish(),
  userId: z71.string().nullish()
});

// src/generated-definitions/BulkEntitlementGrantResult.ts
import { z as z72 } from "zod";
var BulkEntitlementGrantResult = z72.object({
  failList: z72.array(EntitlementGrantResult).nullish(),
  status: z72.enum(["FAIL", "PARTIAL_SUCCESS", "SUCCESS"]).nullish(),
  successList: z72.array(EntitlementGrantResult).nullish()
});

// src/generated-definitions/EntitlementRevokeResult.ts
import { z as z73 } from "zod";
var EntitlementRevokeResult = z73.object({
  entitlementId: z73.string().nullish(),
  reason: z73.string().nullish(),
  userId: z73.string().nullish()
});

// src/generated-definitions/BulkEntitlementRevokeResult.ts
import { z as z74 } from "zod";
var BulkEntitlementRevokeResult = z74.object({
  failList: z74.array(EntitlementRevokeResult).nullish(),
  status: z74.enum(["FAIL", "PARTIAL_SUCCESS", "SUCCESS"]).nullish(),
  successList: z74.array(EntitlementRevokeResult).nullish()
});

// src/generated-definitions/EntitlementConfigInfo.ts
import { z as z75 } from "zod";
var EntitlementConfigInfo = z75.object({ enableEntitlementOriginFeature: z75.boolean().nullish(), namespace: z75.string().nullish() });

// src/generated-definitions/EntitlementLootBoxReward.ts
import { z as z76 } from "zod";
var EntitlementLootBoxReward = z76.object({
  count: z76.number().int().nullish(),
  itemId: z76.string().nullish(),
  itemSku: z76.string().nullish()
});

// src/generated-definitions/EntitlementDecrementResult.ts
import { z as z77 } from "zod";
var EntitlementDecrementResult = z77.object({
  appId: z77.string().nullish(),
  appType: z77.enum(["DEMO", "DLC", "GAME", "SOFTWARE"]).nullish(),
  clazz: z77.enum(["APP", "CODE", "ENTITLEMENT", "LOOTBOX", "MEDIA", "OPTIONBOX", "SUBSCRIPTION"]),
  collectionId: z77.string().nullish(),
  createdAt: z77.string(),
  endDate: z77.string().nullish(),
  features: z77.array(z77.string()).nullish(),
  grantedAt: z77.string().nullish(),
  grantedCode: z77.string().nullish(),
  id: z77.string(),
  itemId: z77.string(),
  itemNamespace: z77.string(),
  itemSnapshot: ItemSnapshot.nullish(),
  name: z77.string().nullish(),
  namespace: z77.string(),
  noOrigin: z77.boolean().nullish(),
  origin: z77.enum(["Epic", "GooglePlay", "IOS", "Nintendo", "Oculus", "Other", "Playstation", "Steam", "System", "Twitch", "Xbox"]).nullish(),
  platformAvailable: z77.boolean().nullish(),
  replayed: z77.boolean().nullish(),
  requestId: z77.string().nullish(),
  rewards: z77.array(EntitlementLootBoxReward).nullish(),
  sku: z77.string().nullish(),
  source: z77.enum(["ACHIEVEMENT", "GIFT", "IAP", "OTHER", "PROMOTION", "PURCHASE", "REDEEM_CODE", "REFERRAL_BONUS", "REWARD"]).nullish(),
  stackable: z77.boolean().nullish(),
  startDate: z77.string().nullish(),
  status: z77.enum(["ACTIVE", "CONSUMED", "INACTIVE", "REVOKED", "SOLD"]),
  storeId: z77.string().nullish(),
  type: z77.enum(["CONSUMABLE", "DURABLE"]).nullish(),
  updatedAt: z77.string(),
  useCount: z77.number().int().nullish(),
  userId: z77.string().nullish()
});

// src/generated-definitions/EntitlementHistoryInfo.ts
import { z as z78 } from "zod";
var EntitlementHistoryInfo = z78.object({
  action: z78.enum(["DECREMENT", "DISABLE", "ENABLE", "GRANT", "REVOKE", "SELL_BACK", "UPDATE"]),
  clazz: z78.enum(["APP", "CODE", "ENTITLEMENT", "LOOTBOX", "MEDIA", "OPTIONBOX", "SUBSCRIPTION"]).nullish(),
  createdAt: z78.string(),
  entitlementId: z78.string(),
  itemId: z78.string().nullish(),
  namespace: z78.string(),
  operator: z78.string(),
  origin: z78.enum(["Epic", "GooglePlay", "IOS", "Nintendo", "Oculus", "Other", "Playstation", "Steam", "System", "Twitch", "Xbox"]).nullish(),
  reason: z78.string().nullish(),
  sku: z78.string().nullish(),
  updatedAt: z78.string(),
  useCount: z78.number().int().nullish(),
  useCountChange: z78.number().int().nullish(),
  userId: z78.string()
});

// src/generated-definitions/EntitlementHistoryInfoArray.ts
import { z as z79 } from "zod";
var EntitlementHistoryInfoArray = z79.array(EntitlementHistoryInfo);

// src/generated-definitions/EntitlementIfc.ts
import { z as z80 } from "zod";
var EntitlementIfc = z80.object({
  appId: z80.string().nullish(),
  appType: z80.enum(["DEMO", "DLC", "GAME", "SOFTWARE"]).nullish(),
  clazz: z80.enum(["APP", "CODE", "ENTITLEMENT", "LOOTBOX", "MEDIA", "OPTIONBOX", "SUBSCRIPTION"]).nullish(),
  collectionId: z80.string().nullish(),
  createdAt: z80.string().nullish(),
  endDate: z80.string().nullish(),
  features: z80.array(z80.string()).nullish(),
  grantedCode: z80.string().nullish(),
  id: z80.string().nullish(),
  itemId: z80.string().nullish(),
  itemNamespace: z80.string().nullish(),
  name: z80.string().nullish(),
  namespace: z80.string().nullish(),
  noOrigin: z80.boolean().nullish(),
  origin: z80.enum(["Epic", "GooglePlay", "IOS", "Nintendo", "Oculus", "Other", "Playstation", "Steam", "System", "Twitch", "Xbox"]).nullish(),
  sku: z80.string().nullish(),
  startDate: z80.string().nullish(),
  status: z80.enum(["ACTIVE", "CONSUMED", "INACTIVE", "REVOKED", "SOLD"]).nullish(),
  storeId: z80.string().nullish(),
  type: z80.enum(["CONSUMABLE", "DURABLE"]).nullish(),
  updatedAt: z80.string().nullish(),
  useCount: z80.number().int().nullish(),
  userId: z80.string().nullish()
});

// src/generated-definitions/EntitlementInfo.ts
import { z as z81 } from "zod";
var EntitlementInfo = z81.object({
  appId: z81.string().nullish(),
  appType: z81.enum(["DEMO", "DLC", "GAME", "SOFTWARE"]).nullish(),
  clazz: z81.enum(["APP", "CODE", "ENTITLEMENT", "LOOTBOX", "MEDIA", "OPTIONBOX", "SUBSCRIPTION"]),
  collectionId: z81.string().nullish(),
  createdAt: z81.string(),
  endDate: z81.string().nullish(),
  features: z81.array(z81.string()).nullish(),
  grantedAt: z81.string().nullish(),
  grantedCode: z81.string().nullish(),
  id: z81.string(),
  itemId: z81.string(),
  itemNamespace: z81.string(),
  itemSnapshot: ItemSnapshot.nullish(),
  name: z81.string().nullish(),
  namespace: z81.string(),
  noOrigin: z81.boolean().nullish(),
  origin: z81.enum(["Epic", "GooglePlay", "IOS", "Nintendo", "Oculus", "Other", "Playstation", "Steam", "System", "Twitch", "Xbox"]).nullish(),
  platformAvailable: z81.boolean().nullish(),
  sku: z81.string().nullish(),
  source: z81.enum(["ACHIEVEMENT", "GIFT", "IAP", "OTHER", "PROMOTION", "PURCHASE", "REDEEM_CODE", "REFERRAL_BONUS", "REWARD"]).nullish(),
  stackable: z81.boolean().nullish(),
  startDate: z81.string().nullish(),
  status: z81.enum(["ACTIVE", "CONSUMED", "INACTIVE", "REVOKED", "SOLD"]),
  storeId: z81.string().nullish(),
  type: z81.enum(["CONSUMABLE", "DURABLE"]).nullish(),
  updatedAt: z81.string(),
  useCount: z81.number().int().nullish(),
  userId: z81.string().nullish()
});

// src/generated-definitions/EntitlementInfoArray.ts
import { z as z82 } from "zod";
var EntitlementInfoArray = z82.array(EntitlementInfo);

// src/generated-definitions/EntitlementOwnership.ts
import { z as z83 } from "zod";
var EntitlementOwnership = z83.object({ itemId: z83.string().nullish(), owned: z83.boolean() });

// src/generated-definitions/EntitlementOwnershipArray.ts
import { z as z84 } from "zod";
var EntitlementOwnershipArray = z84.array(EntitlementOwnership);

// src/generated-definitions/EntitlementPagingSlicedResult.ts
import { z as z85 } from "zod";
var EntitlementPagingSlicedResult = z85.object({ data: z85.array(EntitlementInfo).nullish(), paging: Paging.nullish() });

// src/generated-definitions/EntitlementPlatformConfigInfo.ts
import { z as z86 } from "zod";
var EntitlementPlatformConfigInfo = z86.object({
  allowedPlatformOrigins: z86.array(z86.string()),
  createdAt: z86.string().nullish(),
  id: z86.string().nullish(),
  namespace: z86.string(),
  platform: z86.string(),
  updatedAt: z86.string().nullish()
});

// src/generated-definitions/EntitlementPrechekResult.ts
import { z as z87 } from "zod";
var EntitlementPrechekResult = z87.object({ isRevokePossible: z87.boolean().nullish() });

// src/generated-definitions/CreditSummary.ts
import { z as z88 } from "zod";
var CreditSummary = z88.object({
  amount: z88.number().int(),
  currencyCode: z88.string().nullish(),
  namespace: z88.string(),
  userId: z88.string(),
  walletId: z88.string()
});

// src/generated-definitions/EntitlementSoldResult.ts
import { z as z89 } from "zod";
var EntitlementSoldResult = z89.object({
  creditSummaries: z89.array(CreditSummary).nullish(),
  entitlementInfo: EntitlementInfo.nullish(),
  replayed: z89.boolean().nullish(),
  requestId: z89.string().nullish()
});

// src/generated-definitions/Ownership.ts
import { z as z90 } from "zod";
var Ownership = z90.object({ owned: z90.boolean() });

// src/generated-definitions/StackableEntitlementInfo.ts
import { z as z91 } from "zod";
var StackableEntitlementInfo = z91.object({
  appId: z91.string().nullish(),
  appType: z91.enum(["DEMO", "DLC", "GAME", "SOFTWARE"]).nullish(),
  clazz: z91.enum(["APP", "CODE", "ENTITLEMENT", "LOOTBOX", "MEDIA", "OPTIONBOX", "SUBSCRIPTION"]),
  collectionId: z91.string().nullish(),
  createdAt: z91.string(),
  endDate: z91.string().nullish(),
  features: z91.array(z91.string()).nullish(),
  grantedAt: z91.string().nullish(),
  grantedCode: z91.string().nullish(),
  id: z91.string(),
  itemId: z91.string(),
  itemNamespace: z91.string(),
  itemSnapshot: ItemSnapshot.nullish(),
  name: z91.string().nullish(),
  namespace: z91.string(),
  noOrigin: z91.boolean().nullish(),
  origin: z91.enum(["Epic", "GooglePlay", "IOS", "Nintendo", "Oculus", "Other", "Playstation", "Steam", "System", "Twitch", "Xbox"]).nullish(),
  platformAvailable: z91.boolean().nullish(),
  sku: z91.string().nullish(),
  source: z91.enum(["ACHIEVEMENT", "GIFT", "IAP", "OTHER", "PROMOTION", "PURCHASE", "REDEEM_CODE", "REFERRAL_BONUS", "REWARD"]).nullish(),
  stackable: z91.boolean().nullish(),
  stackedUseCount: z91.number().int().nullish(),
  startDate: z91.string().nullish(),
  status: z91.enum(["ACTIVE", "CONSUMED", "INACTIVE", "REVOKED", "SOLD"]),
  storeId: z91.string().nullish(),
  type: z91.enum(["CONSUMABLE", "DURABLE"]).nullish(),
  updatedAt: z91.string(),
  useCount: z91.number().int().nullish(),
  userId: z91.string().nullish()
});

// src/generated-definitions/StackableEntitlementInfoArray.ts
import { z as z92 } from "zod";
var StackableEntitlementInfoArray = z92.array(StackableEntitlementInfo);

// src/generated-definitions/TimedOwnership.ts
import { z as z93 } from "zod";
var TimedOwnership = z93.object({ endDate: z93.string().nullish(), owned: z93.boolean() });

// src/generated-admin/endpoints/EntitlementAdmin$.ts
import { Validate as Validate9 } from "@accelbyte/sdk";
var EntitlementAdmin$ = class {
  // @ts-ignore
  // prettier-ignore
  constructor(axiosInstance, namespace, useSchemaValidation = true) {
    this.axiosInstance = axiosInstance;
    this.namespace = namespace;
    this.useSchemaValidation = useSchemaValidation;
  }
  /**
   * Query entitlements.&lt;p&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: entitlement list&lt;/li&gt;&lt;/ul&gt;
   */
  getEntitlements(queryParams) {
    const params = { activeOnly: true, limit: 20, ...queryParams };
    const url = "/platform/admin/namespaces/{namespace}/entitlements".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.get(url, { params });
    return Validate9.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      EntitlementPagingSlicedResult,
      "EntitlementPagingSlicedResult"
    );
  }
  /**
   * Grant entitlements to multiple users, skipped granting will be treated as fail.&lt;br&gt;&lt;br&gt;Notes: &lt;br&gt;&lt;br&gt;Support Item Types:&lt;ul&gt;&lt;li&gt;&lt;i&gt;APP&lt;/i&gt;&lt;/li&gt;&lt;li&gt;&lt;i&gt;INGAMEITEM&lt;/i&gt;&lt;/li&gt;&lt;li&gt;&lt;i&gt;CODE&lt;/i&gt;&lt;/li&gt;&lt;li&gt;&lt;i&gt;SUBSCRIPTION&lt;/i&gt;&lt;/li&gt;&lt;li&gt;&lt;i&gt;MEDIA&lt;/i&gt;&lt;/li&gt;&lt;li&gt;&lt;i&gt;OPTIONBOX&lt;/i&gt;&lt;/li&gt;&lt;li&gt;&lt;i&gt;LOOTBOX&lt;/i&gt;&lt;/li&gt;&lt;/ul&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: bulk grant entitlements result&lt;/li&gt;&lt;/ul&gt;
   */
  createEntitlementGrant(data) {
    const params = {};
    const url = "/platform/admin/namespaces/{namespace}/entitlements/grant".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.post(url, data, { params });
    return Validate9.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      BulkEntitlementGrantResult,
      "BulkEntitlementGrantResult"
    );
  }
  /**
   * Revoke entitlements, skipped revocation will be treated as fail.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: bulk revoke entitlements result&lt;/li&gt;&lt;/ul&gt;
   */
  createEntitlementRevoke(data) {
    const params = {};
    const url = "/platform/admin/namespaces/{namespace}/entitlements/revoke".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.post(url, data, { params });
    return Validate9.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      BulkEntitlementRevokeResult,
      "BulkEntitlementRevokeResult"
    );
  }
  /**
   * Query entitlements by Item Ids.&lt;p&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: entitlement list&lt;/li&gt;&lt;/ul&gt;
   */
  getEntitlementsByItemIds(queryParams) {
    const params = { activeOnly: true, limit: 20, ...queryParams };
    const url = "/platform/admin/namespaces/{namespace}/entitlements/byItemIds".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.get(url, { params });
    return Validate9.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      EntitlementPagingSlicedResult,
      "EntitlementPagingSlicedResult"
    );
  }
  /**
   * Get entitlement config info.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: entitlement info&lt;/li&gt;&lt;/ul&gt;
   */
  getEntitlementsConfigInfo(queryParams) {
    const params = { withoutCache: true, ...queryParams };
    const url = "/platform/admin/namespaces/{namespace}/entitlements/config/info".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.get(url, { params });
    return Validate9.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, EntitlementConfigInfo, "EntitlementConfigInfo");
  }
  /**
   * Query entitlements for a specific user.&lt;p&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: entitlement list&lt;/li&gt;&lt;/ul&gt;
   */
  getEntitlements_ByUserId(userId, queryParams) {
    const params = { activeOnly: true, limit: 20, ...queryParams };
    const url = "/platform/admin/namespaces/{namespace}/users/{userId}/entitlements".replace("{namespace}", this.namespace).replace("{userId}", userId);
    const resultPromise = this.axiosInstance.get(url, { params });
    return Validate9.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      EntitlementPagingSlicedResult,
      "EntitlementPagingSlicedResult"
    );
  }
  /**
   * Grant user entitlement.&lt;br&gt;&lt;br&gt;Notes: &lt;br&gt;&lt;br&gt;will skip un-supported item if input un-supported item types, please use /admin/namespaces/{namespace}/users/{userId}/fulfillment endpoint if want to fulfill other item type, like coin item&lt;br&gt;&lt;br&gt;Support Item Types:&lt;ul&gt;&lt;li&gt;&lt;i&gt;APP&lt;/i&gt;&lt;/li&gt;&lt;li&gt;&lt;i&gt;INGAMEITEM&lt;/i&gt;&lt;/li&gt;&lt;li&gt;&lt;i&gt;CODE&lt;/i&gt;&lt;/li&gt;&lt;li&gt;&lt;i&gt;SUBSCRIPTION&lt;/i&gt;&lt;/li&gt;&lt;li&gt;&lt;i&gt;MEDIA&lt;/i&gt;&lt;/li&gt;&lt;li&gt;&lt;i&gt;OPTIONBOX&lt;/i&gt;&lt;/li&gt;&lt;li&gt;&lt;i&gt;LOOTBOX&lt;/i&gt;&lt;/li&gt;&lt;/ul&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: granted entitlement&lt;/li&gt;&lt;/ul&gt;
   */
  createEntitlement_ByUserId(userId, data) {
    const params = {};
    const url = "/platform/admin/namespaces/{namespace}/users/{userId}/entitlements".replace("{namespace}", this.namespace).replace("{userId}", userId);
    const resultPromise = this.axiosInstance.post(url, data, { params });
    return Validate9.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      StackableEntitlementInfoArray,
      "StackableEntitlementInfoArray"
    );
  }
  /**
   * Get entitlement.&lt;p&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: entitlement&lt;/li&gt;&lt;/ul&gt;
   */
  getEntitlement_ByEntitlementId(entitlementId) {
    const params = {};
    const url = "/platform/admin/namespaces/{namespace}/entitlements/{entitlementId}".replace("{namespace}", this.namespace).replace("{entitlementId}", entitlementId);
    const resultPromise = this.axiosInstance.get(url, { params });
    return Validate9.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, EntitlementInfo, "EntitlementInfo");
  }
  /**
   * Get user entitlement by sku.
   */
  getEntitlementsBySku_ByUserId(userId, queryParams) {
    const params = { activeOnly: true, ...queryParams };
    const url = "/platform/admin/namespaces/{namespace}/users/{userId}/entitlements/bySku".replace("{namespace}", this.namespace).replace("{userId}", userId);
    const resultPromise = this.axiosInstance.get(url, { params });
    return Validate9.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, EntitlementInfo, "EntitlementInfo");
  }
  /**
   * Revoke all entitlements of a user (This API is for testing purpose only)&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: revoked entitlements count&lt;/li&gt;&lt;/ul&gt;
   */
  updateEntitlementRevoke_ByUserId(userId) {
    const params = {};
    const url = "/platform/admin/namespaces/{namespace}/users/{userId}/entitlements/revoke".replace("{namespace}", this.namespace).replace("{userId}", userId);
    const resultPromise = this.axiosInstance.put(url, null, { params });
    return Validate9.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, BulkOperationResult, "BulkOperationResult");
  }
  /**
   * Get user app entitlement by appId.
   */
  getEntitlementsByAppId_ByUserId(userId, queryParams) {
    const params = { activeOnly: true, ...queryParams };
    const url = "/platform/admin/namespaces/{namespace}/users/{userId}/entitlements/byAppId".replace("{namespace}", this.namespace).replace("{userId}", userId);
    const resultPromise = this.axiosInstance.get(url, { params });
    return Validate9.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, AppEntitlementInfo, "AppEntitlementInfo");
  }
  /**
   * Get user entitlement by itemId.
   */
  getEntitlementsByItemId_ByUserId(userId, queryParams) {
    const params = { activeOnly: true, ...queryParams };
    const url = "/platform/admin/namespaces/{namespace}/users/{userId}/entitlements/byItemId".replace("{namespace}", this.namespace).replace("{userId}", userId);
    const resultPromise = this.axiosInstance.get(url, { params });
    return Validate9.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, EntitlementInfo, "EntitlementInfo");
  }
  /**
   * Query app entitlements by appType.&lt;p&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: app entitlement pagination&lt;/li&gt;&lt;/ul&gt;
   */
  getEntitlementsByAppType_ByUserId(userId, queryParams) {
    const params = { activeOnly: true, limit: 20, ...queryParams };
    const url = "/platform/admin/namespaces/{namespace}/users/{userId}/entitlements/byAppType".replace("{namespace}", this.namespace).replace("{userId}", userId);
    const resultPromise = this.axiosInstance.get(url, { params });
    return Validate9.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      AppEntitlementPagingSlicedResult,
      "AppEntitlementPagingSlicedResult"
    );
  }
  /**
   * Get user entitlements by itemIds.
   */
  getEntitlementsByItemIds_ByUserId(userId, queryParams) {
    const params = { ...queryParams };
    const url = "/platform/admin/namespaces/{namespace}/users/{userId}/entitlements/byItemIds".replace("{namespace}", this.namespace).replace("{userId}", userId);
    const resultPromise = this.axiosInstance.get(url, { params });
    return Validate9.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, EntitlementInfoArray, "EntitlementInfoArray");
  }
  /**
   * Get platform entitlement config list.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: entitlement info&lt;/li&gt;&lt;/ul&gt;
   */
  getEntitlementConfig_ByPlatform(platform) {
    const params = {};
    const url = "/platform/admin/namespaces/{namespace}/platforms/{platform}/entitlement/config".replace("{namespace}", this.namespace).replace("{platform}", platform);
    const resultPromise = this.axiosInstance.get(url, { params });
    return Validate9.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      EntitlementPlatformConfigInfo,
      "EntitlementPlatformConfigInfo"
    );
  }
  /**
   * Update platform entitlement config.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: platform entitlement config&lt;/li&gt;&lt;/ul&gt;
   */
  updateEntitlementConfig_ByPlatform(platform, data) {
    const params = {};
    const url = "/platform/admin/namespaces/{namespace}/platforms/{platform}/entitlement/config".replace("{namespace}", this.namespace).replace("{platform}", platform);
    const resultPromise = this.axiosInstance.put(url, data, { params });
    return Validate9.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      EntitlementPlatformConfigInfo,
      "EntitlementPlatformConfigInfo"
    );
  }
  /**
   * Revoke user&#39;s entitlements by ids.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: revoke entitlements count&lt;/li&gt;&lt;/ul&gt;
   */
  updateEntitlementRevokeById_ByUserId(userId, queryParams) {
    const params = { ...queryParams };
    const url = "/platform/admin/namespaces/{namespace}/users/{userId}/entitlements/revoke/byIds".replace("{namespace}", this.namespace).replace("{userId}", userId);
    const resultPromise = this.axiosInstance.put(url, null, { params });
    return Validate9.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, BulkOperationResult, "BulkOperationResult");
  }
  /**
   * Exists any user active entitlement of specified itemIds, skus and appIds
   */
  getEntitlementsOwnershipAny_ByUserId(userId, queryParams) {
    const params = { ...queryParams };
    const url = "/platform/admin/namespaces/{namespace}/users/{userId}/entitlements/ownership/any".replace("{namespace}", this.namespace).replace("{userId}", userId);
    const resultPromise = this.axiosInstance.get(url, { params });
    return Validate9.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, Ownership, "Ownership");
  }
  /**
   * Get user entitlement.&lt;p&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: entitlement&lt;/li&gt;&lt;/ul&gt;
   */
  getEntitlement_ByUserId_ByEntitlementId(userId, entitlementId) {
    const params = {};
    const url = "/platform/admin/namespaces/{namespace}/users/{userId}/entitlements/{entitlementId}".replace("{namespace}", this.namespace).replace("{userId}", userId).replace("{entitlementId}", entitlementId);
    const resultPromise = this.axiosInstance.get(url, { params });
    return Validate9.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, EntitlementInfo, "EntitlementInfo");
  }
  /**
   * Update user entitlement. If update CONSUMABLE entitlement useCount to 0, the status will be CONSUMED.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: updated entitlement&lt;/li&gt;&lt;/ul&gt;
   */
  updateEntitlement_ByUserId_ByEntitlementId(userId, entitlementId, data) {
    const params = {};
    const url = "/platform/admin/namespaces/{namespace}/users/{userId}/entitlements/{entitlementId}".replace("{namespace}", this.namespace).replace("{userId}", userId).replace("{entitlementId}", entitlementId);
    const resultPromise = this.axiosInstance.put(url, data, { params });
    return Validate9.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, EntitlementInfo, "EntitlementInfo");
  }
  /**
   * Exists any user active entitlement of specified items.
   */
  getEntitlementsOwnershipAnyOf_ByUserId(userId, queryParams) {
    const params = { ...queryParams };
    const url = "/platform/admin/namespaces/{namespace}/users/{userId}/entitlements/ownership/anyOf".replace("{namespace}", this.namespace).replace("{userId}", userId);
    const resultPromise = this.axiosInstance.get(url, { params });
    return Validate9.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, Ownership, "Ownership");
  }
  /**
   * Get user entitlement ownership by sku.
   */
  getEntitlementsOwnershipBySku_ByUserId(userId, queryParams) {
    const params = { ...queryParams };
    const url = "/platform/admin/namespaces/{namespace}/users/{userId}/entitlements/ownership/bySku".replace("{namespace}", this.namespace).replace("{userId}", userId);
    const resultPromise = this.axiosInstance.get(url, { params });
    return Validate9.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, TimedOwnership, "TimedOwnership");
  }
  /**
   * Enable Entitlement origin feature.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: entitlement info&lt;/li&gt;&lt;/ul&gt;
   */
  updateEntitlementConfigEntitlementOriginEnable() {
    const params = {};
    const url = "/platform/admin/namespaces/{namespace}/entitlements/config/entitlementOrigin/enable".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.put(url, null, { params });
    return Validate9.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, EntitlementConfigInfo, "EntitlementConfigInfo");
  }
  /**
   * Get user app entitlement ownership by appId.
   */
  getEntitlementsOwnershipByAppId_ByUserId(userId, queryParams) {
    const params = { ...queryParams };
    const url = "/platform/admin/namespaces/{namespace}/users/{userId}/entitlements/ownership/byAppId".replace("{namespace}", this.namespace).replace("{userId}", userId);
    const resultPromise = this.axiosInstance.get(url, { params });
    return Validate9.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, Ownership, "Ownership");
  }
  /**
   * Get user entitlement ownership by itemId.
   */
  getEntitlementsOwnershipByItemId_ByUserId(userId, queryParams) {
    const params = { ...queryParams };
    const url = "/platform/admin/namespaces/{namespace}/users/{userId}/entitlements/ownership/byItemId".replace("{namespace}", this.namespace).replace("{userId}", userId);
    const resultPromise = this.axiosInstance.get(url, { params });
    return Validate9.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, TimedOwnership, "TimedOwnership");
  }
  /**
   * Get user entitlement ownership by itemIds.
   */
  getEntitlementsOwnershipByItemIds_ByUserId(userId, queryParams) {
    const params = { ...queryParams };
    const url = "/platform/admin/namespaces/{namespace}/users/{userId}/entitlements/ownership/byItemIds".replace("{namespace}", this.namespace).replace("{userId}", userId);
    const resultPromise = this.axiosInstance.get(url, { params });
    return Validate9.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      EntitlementOwnershipArray,
      "EntitlementOwnershipArray"
    );
  }
  /**
   * Sell user entitlement. If the entitlement is consumable, useCount is 0, the status will be CONSUMED. If the entitlement is durable, the status will be SOLD. Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: entitlement&lt;/li&gt;&lt;/ul&gt;
   */
  updateSell_ByUserId_ByEntitlementId(userId, entitlementId, data) {
    const params = {};
    const url = "/platform/admin/namespaces/{namespace}/users/{userId}/entitlements/{entitlementId}/sell".replace("{namespace}", this.namespace).replace("{userId}", userId).replace("{entitlementId}", entitlementId);
    const resultPromise = this.axiosInstance.put(url, data, { params });
    return Validate9.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, EntitlementSoldResult, "EntitlementSoldResult");
  }
  /**
   * Enable user entitlement.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: enable entitlement&lt;/li&gt;&lt;/ul&gt;
   */
  updateEnable_ByUserId_ByEntitlementId(userId, entitlementId) {
    const params = {};
    const url = "/platform/admin/namespaces/{namespace}/users/{userId}/entitlements/{entitlementId}/enable".replace("{namespace}", this.namespace).replace("{userId}", userId).replace("{entitlementId}", entitlementId);
    const resultPromise = this.axiosInstance.put(url, null, { params });
    return Validate9.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, EntitlementInfo, "EntitlementInfo");
  }
  /**
   * Revoke user entitlement.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: revoke entitlement&lt;/li&gt;&lt;/ul&gt;
   */
  updateRevoke_ByUserId_ByEntitlementId(userId, entitlementId, data) {
    const params = {};
    const url = "/platform/admin/namespaces/{namespace}/users/{userId}/entitlements/{entitlementId}/revoke".replace("{namespace}", this.namespace).replace("{userId}", userId).replace("{entitlementId}", entitlementId);
    const resultPromise = this.axiosInstance.put(url, data, { params });
    return Validate9.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, EntitlementInfo, "EntitlementInfo");
  }
  /**
   * Disable user entitlement if entitlement, only active entitlement can be disable, disabled entitlement can&#39;t consume.&lt;br&gt;&lt;b&gt;Like revoke, it will lose the entitlement ownership, except disabled entitlement can enable.&lt;/b&gt;&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: disable entitlement&lt;/li&gt;&lt;/ul&gt;
   */
  updateDisable_ByUserId_ByEntitlementId(userId, entitlementId) {
    const params = {};
    const url = "/platform/admin/namespaces/{namespace}/users/{userId}/entitlements/{entitlementId}/disable".replace("{namespace}", this.namespace).replace("{userId}", userId).replace("{entitlementId}", entitlementId);
    const resultPromise = this.axiosInstance.put(url, null, { params });
    return Validate9.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, EntitlementInfo, "EntitlementInfo");
  }
  /**
   * Get user entitlement histories.&lt;p&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: list of entitlement history&lt;/li&gt;&lt;/ul&gt;
   */
  getHistory_ByUserId_ByEntitlementId(userId, entitlementId) {
    const params = {};
    const url = "/platform/admin/namespaces/{namespace}/users/{userId}/entitlements/{entitlementId}/history".replace("{namespace}", this.namespace).replace("{userId}", userId).replace("{entitlementId}", entitlementId);
    const resultPromise = this.axiosInstance.get(url, { params });
    return Validate9.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      EntitlementHistoryInfoArray,
      "EntitlementHistoryInfoArray"
    );
  }
  /**
   * Consume user entitlement. If the entitlement useCount is 0, the status will be CONSUMED.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: consumed entitlement&lt;/li&gt;&lt;/ul&gt;
   */
  updateDecrement_ByUserId_ByEntitlementId(userId, entitlementId, data) {
    const params = {};
    const url = "/platform/admin/namespaces/{namespace}/users/{userId}/entitlements/{entitlementId}/decrement".replace("{namespace}", this.namespace).replace("{userId}", userId).replace("{entitlementId}", entitlementId);
    const resultPromise = this.axiosInstance.put(url, data, { params });
    return Validate9.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      EntitlementDecrementResult,
      "EntitlementDecrementResult"
    );
  }
  /**
   * @deprecated
   * Revoke specified use count of user entitlement. please use /{entitlementId}/revoke/byUseCount endpoint instead of this endpoint&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: revoke entitlement&lt;/li&gt;&lt;/ul&gt;
   */
  updateRevokeByUseCount_ByUserId_ByEntitlementId(userId, entitlementId, data) {
    const params = {};
    const url = "/platform/admin/namespaces/{namespace}/users/{userId}/entitlements/{entitlementId}/revokeByUseCount".replace("{namespace}", this.namespace).replace("{userId}", userId).replace("{entitlementId}", entitlementId);
    const resultPromise = this.axiosInstance.put(url, data, { params });
    return Validate9.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, EntitlementInfo, "EntitlementInfo");
  }
  /**
   * Revoke specified count of user entitlement.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: The revoked entitlement&lt;/li&gt;&lt;/ul&gt;
   */
  createRevokeByUseCount_ByUserId_ByEntitlementId(userId, entitlementId, data) {
    const params = {};
    const url = "/platform/admin/namespaces/{namespace}/users/{userId}/entitlements/{entitlementId}/revoke/byUseCount".replace("{namespace}", this.namespace).replace("{userId}", userId).replace("{entitlementId}", entitlementId);
    const resultPromise = this.axiosInstance.post(url, data, { params });
    return Validate9.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, EntitlementIfc, "EntitlementIfc");
  }
  /**
   * Checks if specified use count of user entitlement can be revoked without actually revoking it.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: true if revokable, false otherwise&lt;/li&gt;&lt;/ul&gt;
   */
  getRevokeByUseCountPreCheck_ByUserId_ByEntitlementId(userId, entitlementId, queryParams) {
    const params = { ...queryParams };
    const url = "/platform/admin/namespaces/{namespace}/users/{userId}/entitlements/{entitlementId}/revoke/byUseCount/preCheck".replace("{namespace}", this.namespace).replace("{userId}", userId).replace("{entitlementId}", entitlementId);
    const resultPromise = this.axiosInstance.get(url, { params });
    return Validate9.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      EntitlementPrechekResult,
      "EntitlementPrechekResult"
    );
  }
};

// src/generated-definitions/EntitlementSummary.ts
import { z as z94 } from "zod";
var EntitlementSummary = z94.object({
  clazz: z94.enum(["APP", "CODE", "ENTITLEMENT", "LOOTBOX", "MEDIA", "OPTIONBOX", "SUBSCRIPTION"]),
  collectionId: z94.string().nullish(),
  createdAt: z94.string(),
  endDate: z94.string().nullish(),
  grantedCode: z94.string().nullish(),
  id: z94.string(),
  itemId: z94.string().nullish(),
  name: z94.string().nullish(),
  namespace: z94.string(),
  noOrigin: z94.boolean().nullish(),
  origin: z94.enum(["Epic", "GooglePlay", "IOS", "Nintendo", "Oculus", "Other", "Playstation", "Steam", "System", "Twitch", "Xbox"]).nullish(),
  stackable: z94.boolean().nullish(),
  stackedUseCount: z94.number().int().nullish(),
  startDate: z94.string().nullish(),
  storeId: z94.string().nullish(),
  type: z94.enum(["CONSUMABLE", "DURABLE"]),
  updatedAt: z94.string(),
  userId: z94.string()
});

// src/generated-definitions/ExtensionFulfillmentSummary.ts
import { z as z95 } from "zod";
var ExtensionFulfillmentSummary = z95.object({
  grantedAt: z95.string().nullish(),
  itemClazz: z95.string().nullish(),
  itemExt: z95.record(z95.any()).nullish(),
  itemId: z95.string().nullish(),
  itemType: z95.enum(["APP", "BUNDLE", "CODE", "COINS", "EXTENSION", "INGAMEITEM", "LOOTBOX", "MEDIA", "OPTIONBOX", "SEASON", "SUBSCRIPTION"]).nullish(),
  metadata: z95.record(z95.any()).nullish(),
  namespace: z95.string().nullish(),
  quantity: z95.number().int(),
  userId: z95.string().nullish()
});

// src/generated-definitions/FulfillmentError.ts
import { z as z96 } from "zod";
var FulfillmentError = z96.object({
  code: z96.number().int().nullish(),
  httpStatus: z96.number().int().nullish(),
  message: z96.string().nullish()
});

// src/generated-definitions/FulfillmentItem.ts
import { z as z97 } from "zod";
var FulfillmentItem = z97.object({
  extraSubscriptionDays: z97.number().int().nullish(),
  itemId: z97.string().nullish(),
  itemName: z97.string().nullish(),
  itemSku: z97.string().nullish(),
  itemType: z97.enum(["APP", "BUNDLE", "CODE", "COINS", "EXTENSION", "INGAMEITEM", "LOOTBOX", "MEDIA", "OPTIONBOX", "SEASON", "SUBSCRIPTION"]).nullish(),
  quantity: z97.number().int(),
  storeId: z97.string().nullish()
});

// src/generated-definitions/FulfillmentHistoryInfo.ts
import { z as z98 } from "zod";
var FulfillmentHistoryInfo = z98.object({
  code: z98.string().nullish(),
  createdAt: z98.string(),
  creditSummaries: z98.array(CreditSummary).nullish(),
  entitlementOrigin: z98.enum(["Epic", "GooglePlay", "IOS", "Nintendo", "Oculus", "Other", "Playstation", "Steam", "System", "Twitch", "Xbox"]).nullish(),
  entitlementSummaries: z98.array(EntitlementSummary).nullish(),
  extensionFulfillmentSummaries: z98.array(ExtensionFulfillmentSummary).nullish(),
  fulfillItems: z98.array(FulfillmentItem).nullish(),
  fulfillmentError: FulfillmentError.nullish(),
  grantedItemIds: z98.array(z98.string()).nullish(),
  id: z98.string(),
  namespace: z98.string(),
  orderNo: z98.string().nullish(),
  status: z98.enum(["FAIL", "SUCCESS"]),
  updatedAt: z98.string(),
  userId: z98.string()
});

// src/generated-definitions/FulfillmentHistoryPagingSlicedResult.ts
import { z as z99 } from "zod";
var FulfillmentHistoryPagingSlicedResult = z99.object({ data: z99.array(FulfillmentHistoryInfo), paging: Paging.nullish() });

// src/generated-definitions/FulfillmentItemArray.ts
import { z as z100 } from "zod";
var FulfillmentItemArray = z100.array(FulfillmentItem);

// src/generated-definitions/FulfillmentActionHistory.ts
import { z as z101 } from "zod";
var FulfillmentActionHistory = z101.object({
  action: z101.enum(["FULFILLMENT", "REVOKE_FULFILLMENT"]).nullish(),
  createdAt: z101.string().nullish(),
  fulfillmentHistoryId: z101.string().nullish(),
  revocationHistoryId: z101.string().nullish(),
  state: z101.enum(["FULFILLED", "FULFILL_FAILED", "REVOKED", "REVOKE_FAILED"]).nullish()
});

// src/generated-definitions/FulfillBundledItemResult.ts
import { z as z102 } from "zod";
var FulfillBundledItemResult = z102.object({
  error: z102.string().nullish(),
  itemId: z102.string().nullish(),
  itemSku: z102.string().nullish(),
  quantity: z102.number().int().nullish()
});

// src/generated-definitions/FulfillItemResult.ts
import { z as z103 } from "zod";
var FulfillItemResult = z103.object({
  error: z103.string().nullish(),
  itemId: z103.string().nullish(),
  itemSku: z103.string().nullish(),
  items: z103.array(FulfillBundledItemResult).nullish()
});

// src/generated-definitions/FulfillmentStateInfo.ts
import { z as z104 } from "zod";
var FulfillmentStateInfo = z104.object({
  failedList: z104.array(FulfillItemResult).nullish(),
  successList: z104.array(FulfillItemResult).nullish()
});

// src/generated-definitions/FulfillmentInfo.ts
import { z as z105 } from "zod";
var FulfillmentInfo = z105.object({
  actions: z105.array(FulfillmentActionHistory).nullish(),
  createdAt: z105.string(),
  id: z105.string(),
  items: z105.array(FulfillmentItem).nullish(),
  namespace: z105.string(),
  state: z105.enum(["FULFILLED", "FULFILL_FAILED", "REVOKED", "REVOKE_FAILED"]).nullish(),
  stateInfo: FulfillmentStateInfo.nullish(),
  transactionId: z105.string().nullish(),
  updatedAt: z105.string(),
  userId: z105.string()
});

// src/generated-definitions/FulfillmentPagingSlicedResult.ts
import { z as z106 } from "zod";
var FulfillmentPagingSlicedResult = z106.object({ data: z106.array(FulfillmentInfo), paging: Paging.nullish() });

// src/generated-definitions/SubscriptionSummary.ts
import { z as z107 } from "zod";
var SubscriptionSummary = z107.object({
  currentPeriodEnd: z107.string().nullish(),
  currentPeriodStart: z107.string().nullish(),
  id: z107.string(),
  itemId: z107.string(),
  namespace: z107.string(),
  sku: z107.string().nullish(),
  status: z107.enum(["ACTIVE", "CANCELLED", "EXPIRED", "INIT"]),
  subscribedBy: z107.enum(["PLATFORM", "USER"]).nullish(),
  userId: z107.string()
});

// src/generated-definitions/FulfillmentResult.ts
import { z as z108 } from "zod";
var FulfillmentResult = z108.object({
  creditSummaries: z108.array(CreditSummary).nullish(),
  entitlementSummaries: z108.array(EntitlementSummary).nullish(),
  id: z108.string().nullish(),
  namespace: z108.string(),
  subscriptionSummaries: z108.array(SubscriptionSummary).nullish(),
  userId: z108.string()
});

// src/generated-definitions/FulfillmentV2Result.ts
import { z as z109 } from "zod";
var FulfillmentV2Result = z109.object({
  creditSummaries: z109.array(CreditSummary).nullish(),
  entitlementSummaries: z109.array(EntitlementSummary).nullish(),
  id: z109.string().nullish(),
  items: z109.array(FulfillmentItem),
  namespace: z109.string(),
  state: z109.enum(["FULFILLED", "FULFILL_FAILED", "REVOKED", "REVOKE_FAILED"]),
  stateInfo: FulfillmentStateInfo,
  subscriptionSummaries: z109.array(SubscriptionSummary).nullish(),
  transactionId: z109.string(),
  userId: z109.string()
});

// src/generated-definitions/RevokeFulfillmentV2Result.ts
import { z as z110 } from "zod";
var RevokeFulfillmentV2Result = z110.object({
  creditRevocations: z110.array(CreditRevocation).nullish(),
  entitlementRevocations: z110.array(EntitlementRevocation).nullish(),
  id: z110.string(),
  itemRevocations: z110.array(ItemRevocation).nullish(),
  items: z110.array(FulfillmentItem),
  namespace: z110.string(),
  state: z110.enum(["FULFILLED", "FULFILL_FAILED", "REVOKED", "REVOKE_FAILED"]),
  stateInfo: FulfillmentStateInfo,
  transactionId: z110.string(),
  userId: z110.string()
});

// src/generated-admin/endpoints/FulfillmentAdmin$.ts
import { Validate as Validate10 } from "@accelbyte/sdk";
import { z as z111 } from "zod";
var FulfillmentAdmin$ = class {
  // @ts-ignore
  // prettier-ignore
  constructor(axiosInstance, namespace, useSchemaValidation = true) {
    this.axiosInstance = axiosInstance;
    this.namespace = namespace;
    this.useSchemaValidation = useSchemaValidation;
  }
  /**
   * &lt;b&gt;[Not supported yet in AGS Shared Cloud]&lt;/b&gt; Query fulfillments in a namespace.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: list of fulfillment info:&lt;ul&gt;&lt;li&gt;storeId in items can be ignored&lt;/li&gt;&lt;li&gt;error in successList will always be null&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;/ul&gt;
   */
  getFulfillments_v2(queryParams) {
    const params = { limit: 20, ...queryParams };
    const url = "/platform/v2/admin/namespaces/{namespace}/fulfillments".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.get(url, { params });
    return Validate10.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      FulfillmentPagingSlicedResult,
      "FulfillmentPagingSlicedResult"
    );
  }
  /**
   * Query fulfillment histories in a namespace.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: query fulfillment history&lt;/li&gt;&lt;/ul&gt;
   */
  getFulfillmentHistory(queryParams) {
    const params = { limit: 20, ...queryParams };
    const url = "/platform/admin/namespaces/{namespace}/fulfillment/history".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.get(url, { params });
    return Validate10.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      FulfillmentHistoryPagingSlicedResult,
      "FulfillmentHistoryPagingSlicedResult"
    );
  }
  /**
   * Fulfill item.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: fulfillment result&lt;/li&gt;&lt;/ul&gt;
   */
  createFulfillment_ByUserId(userId, data) {
    const params = {};
    const url = "/platform/admin/namespaces/{namespace}/users/{userId}/fulfillment".replace("{namespace}", this.namespace).replace("{userId}", userId);
    const resultPromise = this.axiosInstance.post(url, data, { params });
    return Validate10.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, FulfillmentResult, "FulfillmentResult");
  }
  /**
   * Redeem campaign code.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: fulfillment result&lt;/li&gt;&lt;/ul&gt;
   */
  createFulfillmentCode_ByUserId(userId, data) {
    const params = {};
    const url = "/platform/admin/namespaces/{namespace}/users/{userId}/fulfillment/code".replace("{namespace}", this.namespace).replace("{userId}", userId);
    const resultPromise = this.axiosInstance.post(url, data, { params });
    return Validate10.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, FulfillmentResult, "FulfillmentResult");
  }
  /**
   * &lt;b&gt;[SERVICE COMMUNICATION ONLY]&lt;/b&gt; Fulfill rewards.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: fulfillment result&lt;/li&gt;&lt;/ul&gt;
   */
  createFulfillmentReward_ByUserId(userId, data) {
    const params = {};
    const url = "/platform/admin/namespaces/{namespace}/users/{userId}/fulfillment/rewards".replace("{namespace}", this.namespace).replace("{userId}", userId);
    const resultPromise = this.axiosInstance.post(url, data, { params });
    return Validate10.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, z111.unknown(), "z.unknown()");
  }
  /**
   * Retrieve and check fulfillment items based on the provided request.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: list of fulfillment items&lt;/li&gt;&lt;/ul&gt;
   */
  createFulfillmentPreCheck_ByUserId(userId, data) {
    const params = {};
    const url = "/platform/admin/namespaces/{namespace}/users/{userId}/fulfillment/preCheck".replace("{namespace}", this.namespace).replace("{userId}", userId);
    const resultPromise = this.axiosInstance.post(url, data, { params });
    return Validate10.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, FulfillmentItemArray, "FulfillmentItemArray");
  }
  /**
   * &lt;b&gt;[SERVICE COMMUNICATION ONLY]&lt;/b&gt; Fulfill rewards.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: fulfillment result&lt;/li&gt;&lt;li&gt;&lt;i&gt;rewards Item unsupported Type&lt;/i&gt;: SUBSCRIPTION&lt;/ul&gt;
   */
  createFulfillmentReward_ByUserId_v2(userId, data) {
    const params = {};
    const url = "/platform/v2/admin/namespaces/{namespace}/users/{userId}/fulfillment/rewards".replace("{namespace}", this.namespace).replace("{userId}", userId);
    const resultPromise = this.axiosInstance.post(url, data, { params });
    return Validate10.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, FulfillmentResult, "FulfillmentResult");
  }
  /**
   * &lt;b&gt;[Not supported yet in AGS Shared Cloud]&lt;/b&gt; Fulfill items by transactionId.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Request body&lt;/i&gt;: storeId, region, language, and entitlementCollectionId can be ignored.&lt;/li&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: fulfillment v2 result, storeId field can be ignored.&lt;/li&gt;&lt;/ul&gt;
   */
  updateFulfillment_ByUserId_ByTransactionId_v2(userId, transactionId, data) {
    const params = {};
    const url = "/platform/v2/admin/namespaces/{namespace}/users/{userId}/fulfillments/{transactionId}".replace("{namespace}", this.namespace).replace("{userId}", userId).replace("{transactionId}", transactionId);
    const resultPromise = this.axiosInstance.put(url, data, { params });
    return Validate10.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, FulfillmentV2Result, "FulfillmentV2Result");
  }
  /**
   * &lt;b&gt;[Not supported yet in AGS Shared Cloud]&lt;/b&gt; Retry fulfill items by transactionId without sending the original payload.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: fulfillment v2 result, storeId field can be ignored.&lt;/li&gt;&lt;/ul&gt;
   */
  updateRetry_ByUserId_ByTransactionId_v2(userId, transactionId) {
    const params = {};
    const url = "/platform/v2/admin/namespaces/{namespace}/users/{userId}/fulfillments/{transactionId}/retry".replace("{namespace}", this.namespace).replace("{userId}", userId).replace("{transactionId}", transactionId);
    const resultPromise = this.axiosInstance.put(url, null, { params });
    return Validate10.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, FulfillmentV2Result, "FulfillmentV2Result");
  }
  /**
   * &lt;b&gt;[Not supported yet in AGS Shared Cloud]&lt;/b&gt; Revoke items by transactionId.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: revoke fulfillment v2 result, storeId field can be ignored.&lt;/li&gt;&lt;/ul&gt;
   */
  updateRevoke_ByUserId_ByTransactionId_v2(userId, transactionId) {
    const params = {};
    const url = "/platform/v2/admin/namespaces/{namespace}/users/{userId}/fulfillments/{transactionId}/revoke".replace("{namespace}", this.namespace).replace("{userId}", userId).replace("{transactionId}", transactionId);
    const resultPromise = this.axiosInstance.put(url, null, { params });
    return Validate10.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      RevokeFulfillmentV2Result,
      "RevokeFulfillmentV2Result"
    );
  }
};

// src/generated-definitions/FulfillmentScriptInfo.ts
import { z as z112 } from "zod";
var FulfillmentScriptInfo = z112.object({ grantDays: z112.string().nullish(), id: z112.string().nullish() });

// src/generated-definitions/FulfillmentScriptInfoArray.ts
import { z as z113 } from "zod";
var FulfillmentScriptInfoArray = z113.array(FulfillmentScriptInfo);

// src/generated-admin/endpoints/FulfillmentScriptAdmin$.ts
import { Validate as Validate11 } from "@accelbyte/sdk";
import { z as z114 } from "zod";
var FulfillmentScriptAdmin$ = class {
  // @ts-ignore
  // prettier-ignore
  constructor(axiosInstance, namespace, useSchemaValidation = true) {
    this.axiosInstance = axiosInstance;
    this.namespace = namespace;
    this.useSchemaValidation = useSchemaValidation;
  }
  /**
   * &lt;b&gt;[Not supported yet in AGS Shared Cloud]&lt;/b&gt;List all fulfillment scripts.
   */
  getFulfillmentScripts() {
    const params = {};
    const url = "/platform/admin/fulfillment/scripts";
    const resultPromise = this.axiosInstance.get(url, { params });
    return Validate11.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      FulfillmentScriptInfoArray,
      "FulfillmentScriptInfoArray"
    );
  }
  /**
   * &lt;b&gt;[Not supported yet in AGS Shared Cloud]&lt;/b&gt;Delete fulfillment script.
   */
  deleteFulfillmentScript_ById(id) {
    const params = {};
    const url = "/platform/admin/fulfillment/scripts/{id}".replace("{id}", id);
    const resultPromise = this.axiosInstance.delete(url, { params });
    return Validate11.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, z114.unknown(), "z.unknown()");
  }
  /**
   * &lt;b&gt;[Not supported yet in AGS Shared Cloud]&lt;/b&gt;Get fulfillment script by id.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: get fulfillment script&lt;/li&gt;&lt;/ul&gt;
   */
  getFulfillmentScript_ById(id) {
    const params = {};
    const url = "/platform/admin/fulfillment/scripts/{id}".replace("{id}", id);
    const resultPromise = this.axiosInstance.get(url, { params });
    return Validate11.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, FulfillmentScriptInfo, "FulfillmentScriptInfo");
  }
  /**
   * &lt;b&gt;[Not supported yet in AGS Shared Cloud]&lt;/b&gt;Update fulfillment script.
   */
  patchFulfillmentScript_ById(id, data) {
    const params = {};
    const url = "/platform/admin/fulfillment/scripts/{id}".replace("{id}", id);
    const resultPromise = this.axiosInstance.patch(url, data, { params });
    return Validate11.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, FulfillmentScriptInfo, "FulfillmentScriptInfo");
  }
  /**
   * &lt;b&gt;[Not supported yet in AGS Shared Cloud]&lt;/b&gt;Create fulfillment script.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;/ul&gt;Fulfillment scripts are used for adding custom fulfillment logic based on &lt;b&gt;ITEM_TYPE&lt;/b&gt;: [MEDIA,INGAMEITEM] for now, and the custom scripts only cover grantDays.&lt;br&gt;Example for grantDays: &lt;br&gt;&lt;code&gt;order &amp;&amp; ((order.currency &amp;&amp; order.currency.currencyCode) == &#39;LP&#39; || order.isFree) ? 30 : -1&lt;/code&gt;&lt;br&gt;
   */
  createFulfillmentScript_ById(id, data) {
    const params = {};
    const url = "/platform/admin/fulfillment/scripts/{id}".replace("{id}", id);
    const resultPromise = this.axiosInstance.post(url, data, { params });
    return Validate11.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, FulfillmentScriptInfo, "FulfillmentScriptInfo");
  }
};

// src/generated-definitions/AppleIapConfigInfo.ts
import { z as z115 } from "zod";
var AppleIapConfigInfo = z115.object({
  appAppleId: z115.number().int().nullish(),
  authKeyFileName: z115.string().nullish(),
  bundleId: z115.string().nullish(),
  issuerId: z115.string().nullish(),
  keyId: z115.string().nullish(),
  namespace: z115.string(),
  password: z115.string().nullish(),
  version: z115.enum(["V1", "V2"]).nullish()
});

// src/generated-definitions/EpicGamesIapConfigInfo.ts
import { z as z116 } from "zod";
var EpicGamesIapConfigInfo = z116.object({ namespace: z116.string(), sandboxId: z116.string().nullish() });

// src/generated-definitions/GoogleIapConfigInfo.ts
import { z as z117 } from "zod";
var GoogleIapConfigInfo = z117.object({
  applicationName: z117.string().nullish(),
  namespace: z117.string(),
  notificationTokenAudience: z117.string().nullish(),
  notificationTokenEmail: z117.string().nullish(),
  p12FileName: z117.string().nullish(),
  serviceAccountId: z117.string().nullish()
});

// src/generated-definitions/ClientRequestParameter.ts
import { z as z118 } from "zod";
var ClientRequestParameter = z118.object({
  currencyCode: z118.string().nullish(),
  language: z118.string().nullish(),
  price: z118.number().nullish(),
  region: z118.string().nullish()
});

// src/generated-definitions/ConsumeItem.ts
import { z as z119 } from "zod";
var ConsumeItem = z119.object({
  extItemDefId: z119.string().nullish(),
  extItemId: z119.string().nullish(),
  itemIdentity: z119.string().nullish(),
  itemIdentityType: z119.enum(["ITEM_ID", "ITEM_SKU"]).nullish()
});

// src/generated-definitions/RequestHistory.ts
import { z as z120 } from "zod";
var RequestHistory = z120.object({
  requestTime: z120.string().nullish(),
  responseBody: z120.record(z120.any()).nullish(),
  responseTime: z120.string().nullish(),
  status: z120.enum(["FAIL", "PENDING", "SUCCESS"]).nullish(),
  statusCode: z120.number().int().nullish()
});

// src/generated-definitions/IapConsumeHistoryInfo.ts
import { z as z121 } from "zod";
var IapConsumeHistoryInfo = z121.object({
  clientRequestParameter: ClientRequestParameter.nullish(),
  consumeItems: z121.array(ConsumeItem).nullish(),
  iapType: z121.enum(["APPLE", "EPICGAMES", "GOOGLE", "OCULUS", "PLAYSTATION", "STADIA", "STEAM", "TWITCH", "XBOX"]).nullish(),
  id: z121.string().nullish(),
  namespace: z121.string().nullish(),
  requestBody: z121.record(z121.any()).nullish(),
  requestHistories: z121.array(RequestHistory).nullish(),
  requestUrl: z121.string().nullish(),
  status: z121.enum(["FAIL", "PENDING", "SUCCESS"]).nullish(),
  userId: z121.string().nullish()
});

// src/generated-definitions/IapConsumeHistoryPagingSlicedResult.ts
import { z as z122 } from "zod";
var IapConsumeHistoryPagingSlicedResult = z122.object({ data: z122.array(IapConsumeHistoryInfo), paging: Paging.nullish() });

// src/generated-definitions/IapItemEntry.ts
import { z as z123 } from "zod";
var IapItemEntry = z123.object({
  itemIdentity: z123.string().nullish(),
  itemIdentityType: z123.enum(["ITEM_ID", "ITEM_SKU"]).nullish(),
  platformProductIdMap: z123.record(z123.string()).nullish()
});

// src/generated-definitions/IapItemConfigInfo.ts
import { z as z124 } from "zod";
var IapItemConfigInfo = z124.object({ data: z124.array(IapItemEntry).nullish() });

// src/generated-definitions/IapOrderInfo.ts
import { z as z125 } from "zod";
var IapOrderInfo = z125.object({
  createdAt: z125.string(),
  credits: z125.array(CreditSummary).nullish(),
  currencyCode: z125.string().nullish(),
  entitlements: z125.array(EntitlementSummary).nullish(),
  fulfilledTime: z125.string().nullish(),
  iapOrderNo: z125.string(),
  language: z125.string().nullish(),
  namespace: z125.string(),
  price: z125.number().nullish(),
  productId: z125.string().nullish(),
  quantity: z125.number().int().nullish(),
  receiptData: z125.string().nullish(),
  region: z125.string().nullish(),
  retryCount: z125.number().int().nullish(),
  sandbox: z125.boolean().nullish(),
  status: z125.enum(["FAILED", "FULFILLED", "VERIFIED"]),
  statusReason: z125.string().nullish(),
  transactionId: z125.string().nullish(),
  type: z125.enum(["APPLE", "EPICGAMES", "GOOGLE", "OCULUS", "PLAYSTATION", "STADIA", "STEAM", "TWITCH", "XBOX"]),
  updatedAt: z125.string(),
  userId: z125.string()
});

// src/generated-definitions/IapOrderPagingSlicedResult.ts
import { z as z126 } from "zod";
var IapOrderPagingSlicedResult = z126.object({ data: z126.array(IapOrderInfo), paging: Paging.nullish() });

// src/generated-definitions/OculusIapConfigInfo.ts
import { z as z127 } from "zod";
var OculusIapConfigInfo = z127.object({ appId: z127.string().nullish(), appSecret: z127.string().nullish(), namespace: z127.string() });

// src/generated-definitions/PlayStationIapConfigInfo.ts
import { z as z128 } from "zod";
var PlayStationIapConfigInfo = z128.object({
  backOfficeServerClientId: z128.string().nullish(),
  backOfficeServerClientSecret: z128.string().nullish(),
  enableStreamJob: z128.boolean().nullish(),
  environment: z128.string().nullish(),
  namespace: z128.string(),
  streamName: z128.string().nullish(),
  streamPartnerName: z128.string().nullish()
});

// src/generated-definitions/SteamIapConfig.ts
import { z as z129 } from "zod";
var SteamIapConfig = z129.object({
  appId: z129.string().nullish(),
  createdAt: z129.string().nullish(),
  namespace: z129.string().nullish(),
  publisherAuthenticationKey: z129.string().nullish(),
  rvn: z129.number().int().nullish(),
  updatedAt: z129.string().nullish()
});

// src/generated-definitions/SteamIapConfigInfo.ts
import { z as z130 } from "zod";
var SteamIapConfigInfo = z130.object({ appId: z130.string().nullish(), namespace: z130.string(), publisherAuthenticationKey: z130.string() });

// src/generated-definitions/TestResult.ts
import { z as z131 } from "zod";
var TestResult = z131.object({ msg: z131.string().nullish(), success: z131.boolean() });

// src/generated-definitions/TwitchIapConfigInfo.ts
import { z as z132 } from "zod";
var TwitchIapConfigInfo = z132.object({
  clientId: z132.string().nullish(),
  clientSecret: z132.string().nullish(),
  namespace: z132.string(),
  organizationId: z132.string().nullish()
});

// src/generated-definitions/XblIapConfigInfo.ts
import { z as z133 } from "zod";
var XblIapConfigInfo = z133.object({
  businessPartnerCertExpiredTime: z133.string().nullish(),
  businessPartnerCertFileName: z133.string().nullish(),
  namespace: z133.string(),
  password: z133.string().nullish(),
  relyingPartyCert: z133.string().nullish()
});

// src/generated-admin/endpoints/IapAdmin$.ts
import { Validate as Validate12 } from "@accelbyte/sdk";
import { z as z134 } from "zod";
var IapAdmin$ = class {
  // @ts-ignore
  // prettier-ignore
  constructor(axiosInstance, namespace, useSchemaValidation = true) {
    this.axiosInstance = axiosInstance;
    this.namespace = namespace;
    this.useSchemaValidation = useSchemaValidation;
  }
  /**
   * Delete xbl iap config.
   */
  deleteIapConfigXbl() {
    const params = {};
    const url = "/platform/admin/namespaces/{namespace}/iap/config/xbl".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.delete(url, { params });
    return Validate12.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, z134.unknown(), "z.unknown()");
  }
  /**
   * Get xbox iap config.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: xbox iap config&lt;/li&gt;&lt;/ul&gt;
   */
  getIapConfigXbl() {
    const params = {};
    const url = "/platform/admin/namespaces/{namespace}/iap/config/xbl".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.get(url, { params });
    return Validate12.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, XblIapConfigInfo, "XblIapConfigInfo");
  }
  /**
   * Update xbl iap config. Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: updated xbl iap config&lt;/li&gt;&lt;/ul&gt;
   */
  updateIapConfigXbl(data) {
    const params = {};
    const url = "/platform/admin/namespaces/{namespace}/iap/config/xbl".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.put(url, data, { params });
    return Validate12.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, XblIapConfigInfo, "XblIapConfigInfo");
  }
  /**
   * delete a iap item config.
   */
  deleteIapConfigItem() {
    const params = {};
    const url = "/platform/admin/namespaces/{namespace}/iap/config/item".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.delete(url, { params });
    return Validate12.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, z134.unknown(), "z.unknown()");
  }
  /**
   * Get iap item config.
   */
  getIapConfigItem() {
    const params = {};
    const url = "/platform/admin/namespaces/{namespace}/iap/config/item".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.get(url, { params });
    return Validate12.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, IapItemConfigInfo, "IapItemConfigInfo");
  }
  /**
   * Update iap item config. Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: updated iap item config&lt;/li&gt;&lt;/ul&gt;
   */
  updateIapConfigItem(data) {
    const params = {};
    const url = "/platform/admin/namespaces/{namespace}/iap/config/item".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.put(url, data, { params });
    return Validate12.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, IapItemConfigInfo, "IapItemConfigInfo");
  }
  /**
   * Delete apple iap config.
   */
  deleteIapConfigApple() {
    const params = {};
    const url = "/platform/admin/namespaces/{namespace}/iap/config/apple".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.delete(url, { params });
    return Validate12.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, z134.unknown(), "z.unknown()");
  }
  /**
   * Get apple iap config.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: apple iap config&lt;/li&gt;&lt;/ul&gt;
   */
  getIapConfigApple() {
    const params = {};
    const url = "/platform/admin/namespaces/{namespace}/iap/config/apple".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.get(url, { params });
    return Validate12.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, AppleIapConfigInfo, "AppleIapConfigInfo");
  }
  /**
   * Update apple iap config. Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: updated apple iap config&lt;/li&gt;&lt;/ul&gt;
   */
  updateIapConfigApple(data) {
    const params = {};
    const url = "/platform/admin/namespaces/{namespace}/iap/config/apple".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.put(url, data, { params });
    return Validate12.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, AppleIapConfigInfo, "AppleIapConfigInfo");
  }
  /**
   * Delete steam iap config.
   */
  deleteIapConfigSteam() {
    const params = {};
    const url = "/platform/admin/namespaces/{namespace}/iap/config/steam".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.delete(url, { params });
    return Validate12.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, z134.unknown(), "z.unknown()");
  }
  /**
   * Get steam iap config.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: steam iap config&lt;/li&gt;&lt;/ul&gt;
   */
  getIapConfigSteam() {
    const params = {};
    const url = "/platform/admin/namespaces/{namespace}/iap/config/steam".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.get(url, { params });
    return Validate12.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, SteamIapConfig, "SteamIapConfig");
  }
  /**
   * Update steam iap config. Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: updated steam iap config&lt;/li&gt;&lt;/ul&gt;
   */
  updateIapConfigSteam(data) {
    const params = {};
    const url = "/platform/admin/namespaces/{namespace}/iap/config/steam".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.put(url, data, { params });
    return Validate12.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, SteamIapConfigInfo, "SteamIapConfigInfo");
  }
  /**
   * Delete google iap config.
   */
  deleteIapConfigGoogle() {
    const params = {};
    const url = "/platform/admin/namespaces/{namespace}/iap/config/google".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.delete(url, { params });
    return Validate12.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, z134.unknown(), "z.unknown()");
  }
  /**
   * Get google iap config.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: google iap config&lt;/li&gt;&lt;/ul&gt;
   */
  getIapConfigGoogle() {
    const params = {};
    const url = "/platform/admin/namespaces/{namespace}/iap/config/google".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.get(url, { params });
    return Validate12.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, GoogleIapConfigInfo, "GoogleIapConfigInfo");
  }
  /**
   * Update google iap config. Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: updated google iap config&lt;/li&gt;&lt;/ul&gt;
   */
  updateIapConfigGoogle(data) {
    const params = {};
    const url = "/platform/admin/namespaces/{namespace}/iap/config/google".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.put(url, data, { params });
    return Validate12.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, GoogleIapConfigInfo, "GoogleIapConfigInfo");
  }
  /**
   * Delete oculus iap config.
   */
  deleteIapConfigOculu() {
    const params = {};
    const url = "/platform/admin/namespaces/{namespace}/iap/config/oculus".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.delete(url, { params });
    return Validate12.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, z134.unknown(), "z.unknown()");
  }
  /**
   * Get oculus iap config.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: steam iap config&lt;/li&gt;&lt;/ul&gt;
   */
  getIapConfigOculus() {
    const params = {};
    const url = "/platform/admin/namespaces/{namespace}/iap/config/oculus".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.get(url, { params });
    return Validate12.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, OculusIapConfigInfo, "OculusIapConfigInfo");
  }
  /**
   * Update oculus iap config. Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: updated steam iap config&lt;/li&gt;&lt;/ul&gt;
   */
  updateIapConfigOculu(data) {
    const params = {};
    const url = "/platform/admin/namespaces/{namespace}/iap/config/oculus".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.put(url, data, { params });
    return Validate12.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, OculusIapConfigInfo, "OculusIapConfigInfo");
  }
  /**
   * Delete twitch iap config.
   */
  deleteIapConfigTwitch() {
    const params = {};
    const url = "/platform/admin/namespaces/{namespace}/iap/config/twitch".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.delete(url, { params });
    return Validate12.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, z134.unknown(), "z.unknown()");
  }
  /**
   * Get twitch iap config.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: twitch iap config&lt;/li&gt;&lt;/ul&gt;
   */
  getIapConfigTwitch() {
    const params = {};
    const url = "/platform/admin/namespaces/{namespace}/iap/config/twitch".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.get(url, { params });
    return Validate12.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, TwitchIapConfigInfo, "TwitchIapConfigInfo");
  }
  /**
   * Update twitch iap config. Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: updated twitch iap config&lt;/li&gt;&lt;/ul&gt;
   */
  updateIapConfigTwitch(data) {
    const params = {};
    const url = "/platform/admin/namespaces/{namespace}/iap/config/twitch".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.put(url, data, { params });
    return Validate12.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, TwitchIapConfigInfo, "TwitchIapConfigInfo");
  }
  /**
   * Query IAP orders.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: paginated iap orders&lt;/li&gt;&lt;/ul&gt;
   */
  getIap_ByUserId(userId, queryParams) {
    const params = { limit: 20, ...queryParams };
    const url = "/platform/admin/namespaces/{namespace}/users/{userId}/iap".replace("{namespace}", this.namespace).replace("{userId}", userId);
    const resultPromise = this.axiosInstance.get(url, { params });
    return Validate12.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      IapOrderPagingSlicedResult,
      "IapOrderPagingSlicedResult"
    );
  }
  /**
   * Upload xbl business partner cert file.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: updated xbl iap config&lt;/li&gt;&lt;/ul&gt;
   */
  updateIapConfigXblCert(data) {
    const params = {};
    const url = "/platform/admin/namespaces/{namespace}/iap/config/xbl/cert".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.put(url, data, { params });
    return Validate12.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, XblIapConfigInfo, "XblIapConfigInfo");
  }
  /**
   * Delete epic games iap config.
   */
  deleteIapConfigEpicgame() {
    const params = {};
    const url = "/platform/admin/namespaces/{namespace}/iap/config/epicgames".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.delete(url, { params });
    return Validate12.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, z134.unknown(), "z.unknown()");
  }
  /**
   * Get epic games iap config.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: epic games iap config&lt;/li&gt;&lt;/ul&gt;
   */
  getIapConfigEpicgames() {
    const params = {};
    const url = "/platform/admin/namespaces/{namespace}/iap/config/epicgames".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.get(url, { params });
    return Validate12.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      EpicGamesIapConfigInfo,
      "EpicGamesIapConfigInfo"
    );
  }
  /**
   * Update epic games iap config. Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: updated epic games iap config&lt;/li&gt;&lt;/ul&gt;
   */
  updateIapConfigEpicgame(data) {
    const params = {};
    const url = "/platform/admin/namespaces/{namespace}/iap/config/epicgames".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.put(url, data, { params });
    return Validate12.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      EpicGamesIapConfigInfo,
      "EpicGamesIapConfigInfo"
    );
  }
  /**
   * Upload Apple Store p8 file.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: updated apple iap config&lt;/li&gt;&lt;/ul&gt;
   */
  updateIapConfigAppleCert(data) {
    const params = {};
    const url = "/platform/admin/namespaces/{namespace}/iap/config/apple/cert".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.put(url, data, { params });
    return Validate12.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, AppleIapConfigInfo, "AppleIapConfigInfo");
  }
  /**
   * Upload google play p12 file.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: updated google iap config&lt;/li&gt;&lt;/ul&gt;
   */
  updateIapConfigGoogleCert(data) {
    const params = {};
    const url = "/platform/admin/namespaces/{namespace}/iap/config/google/cert".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.put(url, data, { params });
    return Validate12.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, GoogleIapConfigInfo, "GoogleIapConfigInfo");
  }
  /**
   * Delete playstation iap config.
   */
  deleteIapConfigPlaystation() {
    const params = {};
    const url = "/platform/admin/namespaces/{namespace}/iap/config/playstation".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.delete(url, { params });
    return Validate12.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, z134.unknown(), "z.unknown()");
  }
  /**
   * Get playstation iap config.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: playstation iap config&lt;/li&gt;&lt;/ul&gt;
   */
  getIapConfigPlaystation() {
    const params = {};
    const url = "/platform/admin/namespaces/{namespace}/iap/config/playstation".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.get(url, { params });
    return Validate12.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      PlayStationIapConfigInfo,
      "PlayStationIapConfigInfo"
    );
  }
  /**
   * Update playstation iap config. Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: updated playstation iap config&lt;/li&gt;&lt;/ul&gt;
   */
  updateIapConfigPlaystation(data) {
    const params = {};
    const url = "/platform/admin/namespaces/{namespace}/iap/config/playstation".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.put(url, data, { params });
    return Validate12.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      PlayStationIapConfigInfo,
      "PlayStationIapConfigInfo"
    );
  }
  /**
   * Query all user IAP orders.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: list of iap orders&lt;/li&gt;&lt;/ul&gt;
   */
  getIapAll_ByUserId(userId) {
    const params = {};
    const url = "/platform/admin/namespaces/{namespace}/users/{userId}/iap/all".replace("{namespace}", this.namespace).replace("{userId}", userId);
    const resultPromise = this.axiosInstance.get(url, { params });
    return Validate12.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      IapOrderPagingSlicedResult,
      "IapOrderPagingSlicedResult"
    );
  }
  /**
   * Validate playstation iap config. Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: Test Results&lt;/li&gt;&lt;/ul&gt;
   */
  getIapConfigPlaystationValidate() {
    const params = {};
    const url = "/platform/admin/namespaces/{namespace}/iap/config/playstation/validate".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.get(url, { params });
    return Validate12.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, TestResult, "TestResult");
  }
  /**
   * Validate playstation iap config. Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: Test Results&lt;/li&gt;&lt;/ul&gt;
   */
  updateIapConfigPlaystationValidate(data) {
    const params = {};
    const url = "/platform/admin/namespaces/{namespace}/iap/config/playstation/validate".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.put(url, data, { params });
    return Validate12.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, TestResult, "TestResult");
  }
  /**
   * &lt;b&gt;[TEST FACILITY ONLY] Forbidden in live environment. &lt;/b&gt; Mock fulfill iap item without validate receipt.Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: &lt;/li&gt;&lt;/ul&gt;
   */
  updateIapMockReceipt_ByUserId(userId, data) {
    const params = {};
    const url = "/platform/admin/namespaces/{namespace}/users/{userId}/iap/mock/receipt".replace("{namespace}", this.namespace).replace("{userId}", userId);
    const resultPromise = this.axiosInstance.put(url, data, { params });
    return Validate12.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, z134.unknown(), "z.unknown()");
  }
  /**
   * Query IAP consume history.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: paginated iap consume history&lt;/li&gt;&lt;/ul&gt;
   */
  getIapConsumeHistory_ByUserId(userId, queryParams) {
    const params = { limit: 20, ...queryParams };
    const url = "/platform/admin/namespaces/{namespace}/users/{userId}/iap/consume/history".replace("{namespace}", this.namespace).replace("{userId}", userId);
    const resultPromise = this.axiosInstance.get(url, { params });
    return Validate12.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      IapConsumeHistoryPagingSlicedResult,
      "IapConsumeHistoryPagingSlicedResult"
    );
  }
};

// src/generated-definitions/NotificationPagingSlicedResult.ts
import { z as z135 } from "zod";
var NotificationPagingSlicedResult = z135.any();

// src/generated-admin/endpoints/IapNotificationAdmin$.ts
import { Validate as Validate13 } from "@accelbyte/sdk";
var IapNotificationAdmin$ = class {
  // @ts-ignore
  // prettier-ignore
  constructor(axiosInstance, namespace, useSchemaValidation = true) {
    this.axiosInstance = axiosInstance;
    this.namespace = namespace;
    this.useSchemaValidation = useSchemaValidation;
  }
  /**
   * Query third party notifications.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: Third Party Platform notifications&lt;/li&gt;&lt;/ul&gt;
   */
  getIapNotifications(queryParams) {
    const params = { limit: 20, ...queryParams };
    const url = "/platform/admin/namespaces/{namespace}/iap/notifications".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.get(url, { params });
    return Validate13.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      NotificationPagingSlicedResult,
      "NotificationPagingSlicedResult"
    );
  }
};

// src/generated-definitions/ThirdPartySubscriptionOwnership.ts
import { z as z136 } from "zod";
var ThirdPartySubscriptionOwnership = z136.object({ owned: z136.boolean() });

// src/generated-definitions/ThirdPartySubscriptionTransactionHistoryInfo.ts
import { z as z137 } from "zod";
var ThirdPartySubscriptionTransactionHistoryInfo = z137.object({
  createdAt: z137.string().nullish(),
  expiredAt: z137.string().nullish(),
  id: z137.string(),
  lastTransactionId: z137.string().nullish(),
  namespace: z137.string(),
  operator: z137.string().nullish(),
  reason: z137.string().nullish(),
  status: z137.enum([
    "ACTIVE",
    "BILLING_RETRY_PERIOD",
    "CANCELED",
    "EXPIRED",
    "IN_GRACE_PERIOD",
    "ON_HOLD",
    "PAUSED",
    "PENDING",
    "REVOKED",
    "UNKNOWN"
  ]),
  subscriptionProductId: z137.string().nullish(),
  thirdPartySubscriptionId: z137.string(),
  updatedAt: z137.string().nullish(),
  userId: z137.string()
});

// src/generated-definitions/ThirdPartySubscriptionTransactionHistoryPagingSlicedResult.ts
import { z as z138 } from "zod";
var ThirdPartySubscriptionTransactionHistoryPagingSlicedResult = z138.object({
  data: z138.array(ThirdPartySubscriptionTransactionHistoryInfo),
  paging: Paging.nullish()
});

// src/generated-definitions/ThirdPartySubscriptionTransactionInfo.ts
import { z as z139 } from "zod";
var ThirdPartySubscriptionTransactionInfo = z139.object({
  active: z139.boolean(),
  createdAt: z139.string().nullish(),
  expiredAt: z139.string(),
  id: z139.string(),
  lastTransactionId: z139.string().nullish(),
  namespace: z139.string(),
  originalTransactionId: z139.string(),
  platform: z139.enum(["APPLE", "EPICGAMES", "GOOGLE", "OCULUS", "PLAYSTATION", "STADIA", "STEAM", "TWITCH", "XBOX"]),
  purchaseToken: z139.string().nullish(),
  startAt: z139.string().nullish(),
  status: z139.enum([
    "ACTIVE",
    "BILLING_RETRY_PERIOD",
    "CANCELED",
    "EXPIRED",
    "IN_GRACE_PERIOD",
    "ON_HOLD",
    "PAUSED",
    "PENDING",
    "REVOKED",
    "UNKNOWN"
  ]),
  subscriptionGroupId: z139.string().nullish(),
  subscriptionProductId: z139.string(),
  updatedAt: z139.string().nullish(),
  userId: z139.string()
});

// src/generated-definitions/ThirdPartySubscriptionTransactionPagingSlicedResult.ts
import { z as z140 } from "zod";
var ThirdPartySubscriptionTransactionPagingSlicedResult = z140.object({
  data: z140.array(ThirdPartySubscriptionTransactionInfo),
  paging: Paging.nullish()
});

// src/generated-definitions/ThirdPartyUserSubscriptionInfo.ts
import { z as z141 } from "zod";
var ThirdPartyUserSubscriptionInfo = z141.object({
  active: z141.boolean(),
  createdAt: z141.string().nullish(),
  expiredAt: z141.string(),
  id: z141.string(),
  lastTransactionId: z141.string().nullish(),
  namespace: z141.string(),
  platform: z141.enum(["APPLE", "EPICGAMES", "GOOGLE", "OCULUS", "PLAYSTATION", "STADIA", "STEAM", "TWITCH", "XBOX"]),
  startAt: z141.string().nullish(),
  status: z141.enum([
    "ACTIVE",
    "BILLING_RETRY_PERIOD",
    "CANCELED",
    "EXPIRED",
    "IN_GRACE_PERIOD",
    "ON_HOLD",
    "PAUSED",
    "PENDING",
    "REVOKED",
    "UNKNOWN"
  ]),
  subscriptionGroupId: z141.string().nullish(),
  subscriptionProductId: z141.string(),
  updatedAt: z141.string().nullish(),
  userId: z141.string()
});

// src/generated-definitions/ThirdPartyUserSubscriptionPagingSlicedResult.ts
import { z as z142 } from "zod";
var ThirdPartyUserSubscriptionPagingSlicedResult = z142.object({
  data: z142.array(ThirdPartyUserSubscriptionInfo),
  paging: Paging.nullish()
});

// src/generated-admin/endpoints/IapSubscriptionAdmin$.ts
import { Validate as Validate14 } from "@accelbyte/sdk";
var IapSubscriptionAdmin$ = class {
  // @ts-ignore
  // prettier-ignore
  constructor(axiosInstance, namespace, useSchemaValidation = true) {
    this.axiosInstance = axiosInstance;
    this.namespace = namespace;
    this.useSchemaValidation = useSchemaValidation;
  }
  /**
   * Query subscriptions, default sort by updatedAt Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: &lt;/li&gt;&lt;/ul&gt;
   */
  getIapSubscriptions(queryParams) {
    const params = { limit: 20, ...queryParams };
    const url = "/platform/admin/namespaces/{namespace}/iap/subscriptions".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.get(url, { params });
    return Validate14.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      ThirdPartyUserSubscriptionPagingSlicedResult,
      "ThirdPartyUserSubscriptionPagingSlicedResult"
    );
  }
  /**
   * Query user subscription, default sort by updatedAtOther detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: &lt;/li&gt;&lt;/ul&gt;
   */
  getIapSubscriptions_ByUserId(userId, queryParams) {
    const params = { limit: 20, ...queryParams };
    const url = "/platform/admin/namespaces/{namespace}/users/{userId}/iap/subscriptions".replace("{namespace}", this.namespace).replace("{userId}", userId);
    const resultPromise = this.axiosInstance.get(url, { params });
    return Validate14.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      ThirdPartyUserSubscriptionPagingSlicedResult,
      "ThirdPartyUserSubscriptionPagingSlicedResult"
    );
  }
  /**
   * Admin get user subscription details.Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: &lt;/li&gt;&lt;/ul&gt;
   */
  getIapSubscription_ByUserId_ById(userId, id) {
    const params = {};
    const url = "/platform/admin/namespaces/{namespace}/users/{userId}/iap/subscriptions/{id}".replace("{namespace}", this.namespace).replace("{userId}", userId).replace("{id}", id);
    const resultPromise = this.axiosInstance.get(url, { params });
    return Validate14.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      ThirdPartyUserSubscriptionInfo,
      "ThirdPartyUserSubscriptionInfo"
    );
  }
  /**
   * Sync Subscription Status
   */
  updateSyncIap_ByUserId_ById(userId, id) {
    const params = {};
    const url = "/platform/admin/namespaces/{namespace}/users/{userId}/iap/subscriptions/{id}/sync".replace("{namespace}", this.namespace).replace("{userId}", userId).replace("{id}", id);
    const resultPromise = this.axiosInstance.put(url, null, { params });
    return Validate14.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      ThirdPartyUserSubscriptionInfo,
      "ThirdPartyUserSubscriptionInfo"
    );
  }
  /**
   * Admin query user subscription transactions, default sort by startAt timeOther detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: &lt;/li&gt;&lt;/ul&gt;
   */
  getIapSubscriptionsTransactions_ByUserId(userId, queryParams) {
    const params = { limit: 20, ...queryParams };
    const url = "/platform/admin/namespaces/{namespace}/users/{userId}/iap/subscriptions/transactions".replace("{namespace}", this.namespace).replace("{userId}", userId);
    const resultPromise = this.axiosInstance.get(url, { params });
    return Validate14.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      ThirdPartySubscriptionTransactionPagingSlicedResult,
      "ThirdPartySubscriptionTransactionPagingSlicedResult"
    );
  }
  /**
   * Admin get user subscription details.Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: &lt;/li&gt;&lt;/ul&gt;
   */
  getIapSubscriptionTransaction_ByUserId_ById(userId, id) {
    const params = {};
    const url = "/platform/admin/namespaces/{namespace}/users/{userId}/iap/subscriptions/transactions/{id}".replace("{namespace}", this.namespace).replace("{userId}", userId).replace("{id}", id);
    const resultPromise = this.axiosInstance.get(url, { params });
    return Validate14.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      ThirdPartySubscriptionTransactionInfo,
      "ThirdPartySubscriptionTransactionInfo"
    );
  }
  /**
   * Sync Subscription Status
   */
  updateSyncSubscriptionIap_ByUserId_ById(userId, id) {
    const params = {};
    const url = "/platform/admin/namespaces/{namespace}/users/{userId}/iap/subscriptions/transactions/{id}/sync".replace("{namespace}", this.namespace).replace("{userId}", userId).replace("{id}", id);
    const resultPromise = this.axiosInstance.put(url, null, { params });
    return Validate14.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      ThirdPartySubscriptionTransactionInfo,
      "ThirdPartySubscriptionTransactionInfo"
    );
  }
  /**
   * Get Subscription Transaction Update History
   */
  getHistoriesSubscriptionsIap_ByUserId_ById(userId, id, queryParams) {
    const params = { limit: 20, ...queryParams };
    const url = "/platform/admin/namespaces/{namespace}/users/{userId}/iap/subscriptions/transactions/{id}/histories".replace("{namespace}", this.namespace).replace("{userId}", userId).replace("{id}", id);
    const resultPromise = this.axiosInstance.get(url, { params });
    return Validate14.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      ThirdPartySubscriptionTransactionHistoryPagingSlicedResult,
      "ThirdPartySubscriptionTransactionHistoryPagingSlicedResult"
    );
  }
  /**
   * Get user third party subscription by subscription group id.
   */
  getOwnershipByGroupIdSubscriptionsIap_ByUserId_ByPlatform(userId, platform, queryParams) {
    const params = { ...queryParams };
    const url = "/platform/admin/namespaces/{namespace}/users/{userId}/iap/subscriptions/platforms/{platform}/ownership/byGroupId".replace("{namespace}", this.namespace).replace("{userId}", userId).replace("{platform}", platform);
    const resultPromise = this.axiosInstance.get(url, { params });
    return Validate14.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      ThirdPartySubscriptionOwnership,
      "ThirdPartySubscriptionOwnership"
    );
  }
  /**
   * Get user third party subscription by subscription product id.
   */
  getOwnershipByProductIdSubscriptionsIap_ByUserId_ByPlatform(userId, platform, queryParams) {
    const params = { ...queryParams };
    const url = "/platform/admin/namespaces/{namespace}/users/{userId}/iap/subscriptions/platforms/{platform}/ownership/byProductId".replace("{namespace}", this.namespace).replace("{userId}", userId).replace("{platform}", platform);
    const resultPromise = this.axiosInstance.get(url, { params });
    return Validate14.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      ThirdPartySubscriptionOwnership,
      "ThirdPartySubscriptionOwnership"
    );
  }
};

// src/generated-definitions/InvoiceCurrencySummary.ts
import { z as z143 } from "zod";
var InvoiceCurrencySummary = z143.object({
  currency: CurrencySummary,
  salesVolume: z143.number().int(),
  subtotalPrice: z143.number().int(),
  totalPrice: z143.number().int(),
  totalTax: z143.number().int()
});

// src/generated-definitions/InvoiceSummary.ts
import { z as z144 } from "zod";
var InvoiceSummary = z144.object({ invoiceCurrencySummary: z144.array(InvoiceCurrencySummary), totalSalesVolume: z144.number().int() });

// src/generated-admin/endpoints/InvoiceAdmin$.ts
import { Validate as Validate15 } from "@accelbyte/sdk";
import { z as z145 } from "zod";
var InvoiceAdmin$ = class {
  // @ts-ignore
  // prettier-ignore
  constructor(axiosInstance, namespace, useSchemaValidation = true) {
    this.axiosInstance = axiosInstance;
    this.namespace = namespace;
    this.useSchemaValidation = useSchemaValidation;
  }
  /**
   * Generate invoice summary.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: query orders&lt;/li&gt;&lt;/ul&gt;
   */
  getInvoiceSummary(queryParams) {
    const params = { ...queryParams };
    const url = "/platform/admin/namespaces/{namespace}/invoice/summary".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.get(url, { params });
    return Validate15.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, InvoiceSummary, "InvoiceSummary");
  }
  /**
   * Download invoice details as a csv file.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: invoice details csv file&lt;/li&gt;&lt;/ul&gt;
   */
  getInvoiceDetailsCsv(queryParams) {
    const params = { ...queryParams };
    const url = "/platform/admin/namespaces/{namespace}/invoice/details.csv".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.get(url, { params });
    return Validate15.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, z145.unknown(), "z.unknown()");
  }
};

// src/generated-definitions/AvailableComparison.ts
import { z as z146 } from "zod";
var AvailableComparison = z146.object({
  comparison: z146.enum(["excludes", "includes", "is", "isGreaterThan", "isGreaterThanOrEqual", "isLessThan", "isLessThanOrEqual", "isNot"]).nullish(),
  text: z146.string().nullish()
});

// src/generated-definitions/AvailablePredicate.ts
import { z as z147 } from "zod";
var AvailablePredicate = z147.object({
  availableComparisons: z147.array(AvailableComparison).nullish(),
  predicateType: z147.enum(["EntitlementPredicate", "SeasonPassPredicate", "SeasonTierPredicate", "StatisticCodePredicate"]).nullish(),
  showAnyOf: z147.boolean().nullish(),
  valueType: z147.enum(["List", "Number", "String"]).nullish()
});

// src/generated-definitions/AvailablePredicateArray.ts
import { z as z148 } from "zod";
var AvailablePredicateArray = z148.array(AvailablePredicate);

// src/generated-definitions/BasicItem.ts
import { z as z149 } from "zod";
var BasicItem = z149.object({
  appId: z149.string().nullish(),
  appType: z149.enum(["DEMO", "DLC", "GAME", "SOFTWARE"]).nullish(),
  baseAppId: z149.string().nullish(),
  createdAt: z149.string(),
  entitlementType: z149.enum(["CONSUMABLE", "DURABLE"]),
  features: z149.array(z149.string()).nullish(),
  itemId: z149.string(),
  itemType: z149.enum([
    "APP",
    "BUNDLE",
    "CODE",
    "COINS",
    "EXTENSION",
    "INGAMEITEM",
    "LOOTBOX",
    "MEDIA",
    "OPTIONBOX",
    "SEASON",
    "SUBSCRIPTION"
  ]),
  name: z149.string(),
  namespace: z149.string(),
  seasonType: z149.enum(["PASS", "TIER"]).nullish(),
  sku: z149.string().nullish(),
  status: z149.enum(["ACTIVE", "INACTIVE"]),
  tags: z149.array(z149.string()).nullish(),
  updatedAt: z149.string(),
  useCount: z149.number().int().nullish()
});

// src/generated-definitions/BasicItemArray.ts
import { z as z150 } from "zod";
var BasicItemArray = z150.array(BasicItem);

// src/generated-definitions/SubItemAvailablePrice.ts
import { z as z151 } from "zod";
var SubItemAvailablePrice = z151.object({
  discountedPrice: z151.number().int(),
  itemId: z151.string(),
  itemName: z151.string(),
  itemSku: z151.string(),
  owned: z151.boolean().nullish(),
  price: z151.number().int(),
  quantity: z151.number().int().nullish()
});

// src/generated-definitions/AvailablePrice.ts
import { z as z152 } from "zod";
var AvailablePrice = z152.object({
  currencyCode: z152.string(),
  currencyNamespace: z152.string(),
  discountExpireAt: z152.string().nullish(),
  discountPurchaseAt: z152.string().nullish(),
  discountedPrice: z152.number().int(),
  expireAt: z152.string().nullish(),
  price: z152.number().int(),
  priceDetails: z152.array(SubItemAvailablePrice).nullish(),
  purchaseAt: z152.string().nullish()
});

// src/generated-definitions/EstimatedPriceInfo.ts
import { z as z153 } from "zod";
var EstimatedPriceInfo = z153.object({
  estimatedPrices: z153.array(AvailablePrice).nullish(),
  itemId: z153.string(),
  region: z153.string().nullish()
});

// src/generated-definitions/AppLocalization.ts
import { z as z154 } from "zod";
var AppLocalization = z154.object({ announcement: z154.string().nullish(), slogan: z154.string().nullish() });

// src/generated-definitions/Requirement.ts
import { z as z155 } from "zod";
var Requirement = z155.object({
  additionals: z155.string().nullish(),
  directXVersion: z155.string().nullish(),
  diskSpace: z155.string().nullish(),
  graphics: z155.string().nullish(),
  label: z155.string(),
  osVersion: z155.string().nullish(),
  processor: z155.string().nullish(),
  ram: z155.string().nullish(),
  soundCard: z155.string().nullish()
});

// src/generated-definitions/Slide.ts
import { z as z156 } from "zod";
var Slide = z156.object({
  alt: z156.string().nullish(),
  previewUrl: z156.string().nullish(),
  thumbnailUrl: z156.string().nullish(),
  type: z156.enum(["image", "video"]).nullish(),
  url: z156.string().nullish(),
  videoSource: z156.enum(["generic", "vimeo", "youtube"]).nullish()
});

// src/generated-definitions/FullAppInfo.ts
import { z as z157 } from "zod";
var FullAppInfo = z157.object({
  carousel: z157.array(Slide).nullish(),
  developer: z157.string().nullish(),
  forumUrl: z157.string().nullish(),
  genres: z157.array(
    z157.enum([
      "Action",
      "Adventure",
      "Casual",
      "FreeToPlay",
      "Indie",
      "MassivelyMultiplayer",
      "RPG",
      "Racing",
      "Simulation",
      "Sports",
      "Strategy"
    ])
  ).nullish(),
  itemId: z157.string(),
  localizations: z157.record(AppLocalization).nullish(),
  namespace: z157.string(),
  platformRequirements: z157.record(z157.array(Requirement)).nullish(),
  platforms: z157.array(z157.enum(["Android", "IOS", "Linux", "MacOS", "Windows"])).nullish(),
  players: z157.array(z157.enum(["Coop", "CrossPlatformMulti", "LocalCoop", "MMO", "Multi", "Single"])).nullish(),
  primaryGenre: z157.enum([
    "Action",
    "Adventure",
    "Casual",
    "FreeToPlay",
    "Indie",
    "MassivelyMultiplayer",
    "RPG",
    "Racing",
    "Simulation",
    "Sports",
    "Strategy"
  ]).nullish(),
  publisher: z157.string().nullish(),
  releaseDate: z157.string().nullish(),
  websiteUrl: z157.string().nullish()
});

// src/generated-definitions/Image.ts
import { z as z158 } from "zod";
var Image = z158.object({
  as: z158.string().nullish(),
  caption: z158.string().nullish(),
  height: z158.number().int(),
  imageUrl: z158.string(),
  smallImageUrl: z158.string(),
  width: z158.number().int()
});

// src/generated-definitions/Localization.ts
import { z as z159 } from "zod";
var Localization = z159.object({
  description: z159.string().nullish(),
  localExt: z159.record(z159.any()).nullish(),
  longDescription: z159.string().nullish(),
  title: z159.string()
});

// src/generated-definitions/Predicate.ts
import { z as z160 } from "zod";
var Predicate = z160.object({
  anyOf: z160.number().int().nullish(),
  code: z160.string().nullish(),
  comparison: z160.enum(["excludes", "includes", "is", "isGreaterThan", "isGreaterThanOrEqual", "isLessThan", "isLessThanOrEqual", "isNot"]).nullish(),
  name: z160.string().nullish(),
  predicateType: z160.enum(["EntitlementPredicate", "SeasonPassPredicate", "SeasonTierPredicate", "StatisticCodePredicate"]).nullish(),
  value: z160.string().nullish(),
  values: z160.array(z160.string()).nullish()
});

// src/generated-definitions/ConditionGroup.ts
import { z as z161 } from "zod";
var ConditionGroup = z161.object({ operator: z161.enum(["and", "or"]).nullish(), predicates: z161.array(Predicate).nullish() });

// src/generated-definitions/PurchaseCondition.ts
import { z as z162 } from "zod";
var PurchaseCondition = z162.object({ conditionGroups: z162.array(ConditionGroup).nullish() });

// src/generated-definitions/FullItemInfo.ts
import { z as z163 } from "zod";
var FullItemInfo = z163.object({
  appId: z163.string().nullish(),
  appType: z163.enum(["DEMO", "DLC", "GAME", "SOFTWARE"]).nullish(),
  baseAppId: z163.string().nullish(),
  boothName: z163.string().nullish(),
  boundItemIds: z163.array(z163.string()).nullish(),
  categoryPath: z163.string().nullish(),
  clazz: z163.string().nullish(),
  createdAt: z163.string(),
  displayOrder: z163.number().int().nullish(),
  entitlementType: z163.enum(["CONSUMABLE", "DURABLE"]),
  ext: z163.record(z163.any()).nullish(),
  features: z163.array(z163.string()).nullish(),
  flexible: z163.boolean().nullish(),
  images: z163.array(Image).nullish(),
  inventoryConfig: InventoryConfig.nullish(),
  itemId: z163.string(),
  itemIds: z163.array(z163.string()).nullish(),
  itemQty: z163.record(z163.number().int()).nullish(),
  itemType: z163.enum([
    "APP",
    "BUNDLE",
    "CODE",
    "COINS",
    "EXTENSION",
    "INGAMEITEM",
    "LOOTBOX",
    "MEDIA",
    "OPTIONBOX",
    "SEASON",
    "SUBSCRIPTION"
  ]),
  listable: z163.boolean().nullish(),
  localizations: z163.record(Localization),
  lootBoxConfig: LootBoxConfig.nullish(),
  maxCount: z163.number().int().nullish(),
  maxCountPerUser: z163.number().int().nullish(),
  name: z163.string(),
  namespace: z163.string(),
  optionBoxConfig: OptionBoxConfig.nullish(),
  purchasable: z163.boolean().nullish(),
  purchaseCondition: PurchaseCondition.nullish(),
  recurring: Recurring.nullish(),
  regionData: z163.record(z163.array(RegionDataItem)),
  saleConfig: SaleConfig.nullish(),
  seasonType: z163.enum(["PASS", "TIER"]).nullish(),
  sectionExclusive: z163.boolean().nullish(),
  sellable: z163.boolean().nullish(),
  sku: z163.string().nullish(),
  stackable: z163.boolean().nullish(),
  status: z163.enum(["ACTIVE", "INACTIVE"]),
  tags: z163.array(z163.string()).nullish(),
  targetCurrencyCode: z163.string().nullish(),
  targetItemId: z163.string().nullish(),
  targetNamespace: z163.string().nullish(),
  thumbnailUrl: z163.string().nullish(),
  updatedAt: z163.string(),
  useCount: z163.number().int().nullish()
});

// src/generated-definitions/FullItemInfoArray.ts
import { z as z164 } from "zod";
var FullItemInfoArray = z164.array(FullItemInfo);

// src/generated-definitions/FullItemPagingResult.ts
import { z as z165 } from "zod";
var FullItemPagingResult = z165.object({ data: z165.array(FullItemInfo), paging: Paging.nullish(), total: z165.number().int().nullish() });

// src/generated-definitions/FullItemPagingSlicedResult.ts
import { z as z166 } from "zod";
var FullItemPagingSlicedResult = z166.object({ data: z166.array(FullItemInfo), paging: Paging.nullish() });

// src/generated-definitions/ItemAcquireResult.ts
import { z as z167 } from "zod";
var ItemAcquireResult = z167.object({ maxCount: z167.number().int(), success: z167.boolean() });

// src/generated-definitions/ItemDynamicDataInfo.ts
import { z as z168 } from "zod";
var ItemDynamicDataInfo = z168.object({
  availableCount: z168.number().int(),
  itemId: z168.string(),
  namespace: z168.string(),
  userAvailableCount: z168.number().int(),
  userPurchaseLimit: z168.number().int()
});

// src/generated-definitions/ItemId.ts
import { z as z169 } from "zod";
var ItemId = z169.object({ itemId: z169.string(), sku: z169.string().nullish(), status: z169.enum(["ACTIVE", "INACTIVE"]).nullish() });

// src/generated-definitions/ItemIdArray.ts
import { z as z170 } from "zod";
var ItemIdArray = z170.array(ItemId);

// src/generated-definitions/ItemInfo.ts
import { z as z171 } from "zod";
var ItemInfo = z171.object({
  appId: z171.string().nullish(),
  appType: z171.enum(["DEMO", "DLC", "GAME", "SOFTWARE"]).nullish(),
  baseAppId: z171.string().nullish(),
  boothName: z171.string().nullish(),
  boundItemIds: z171.array(z171.string()).nullish(),
  categoryPath: z171.string(),
  clazz: z171.string().nullish(),
  createdAt: z171.string(),
  description: z171.string().nullish(),
  displayOrder: z171.number().int().nullish(),
  entitlementType: z171.enum(["CONSUMABLE", "DURABLE"]),
  ext: z171.record(z171.any()).nullish(),
  features: z171.array(z171.string()).nullish(),
  flexible: z171.boolean().nullish(),
  fresh: z171.boolean().nullish(),
  images: z171.array(Image).nullish(),
  inventoryConfig: InventoryConfig.nullish(),
  itemId: z171.string(),
  itemIds: z171.array(z171.string()).nullish(),
  itemQty: z171.record(z171.number().int()).nullish(),
  itemType: z171.enum([
    "APP",
    "BUNDLE",
    "CODE",
    "COINS",
    "EXTENSION",
    "INGAMEITEM",
    "LOOTBOX",
    "MEDIA",
    "OPTIONBOX",
    "SEASON",
    "SUBSCRIPTION"
  ]),
  language: z171.string(),
  listable: z171.boolean().nullish(),
  localExt: z171.record(z171.any()).nullish(),
  longDescription: z171.string().nullish(),
  lootBoxConfig: LootBoxConfig.nullish(),
  maxCount: z171.number().int().nullish(),
  maxCountPerUser: z171.number().int().nullish(),
  name: z171.string(),
  namespace: z171.string(),
  optionBoxConfig: OptionBoxConfig.nullish(),
  purchasable: z171.boolean().nullish(),
  purchaseCondition: PurchaseCondition.nullish(),
  recurring: Recurring.nullish(),
  region: z171.string(),
  regionData: z171.array(RegionDataItem).nullish(),
  saleConfig: SaleConfig.nullish(),
  seasonType: z171.enum(["PASS", "TIER"]).nullish(),
  sectionExclusive: z171.boolean().nullish(),
  sellable: z171.boolean().nullish(),
  sku: z171.string().nullish(),
  stackable: z171.boolean().nullish(),
  status: z171.enum(["ACTIVE", "INACTIVE"]),
  tags: z171.array(z171.string()).nullish(),
  targetCurrencyCode: z171.string().nullish(),
  targetItemId: z171.string().nullish(),
  targetNamespace: z171.string().nullish(),
  thumbnailUrl: z171.string().nullish(),
  title: z171.string(),
  updatedAt: z171.string(),
  useCount: z171.number().int().nullish()
});

// src/generated-definitions/ItemInfoArray.ts
import { z as z172 } from "zod";
var ItemInfoArray = z172.array(ItemInfo);

// src/generated-definitions/PredicateValidateResult.ts
import { z as z173 } from "zod";
var PredicateValidateResult = z173.object({
  matched: z173.array(z173.string()).nullish(),
  predicateName: z173.string().nullish(),
  unmatched: z173.array(z173.string()).nullish(),
  validated: z173.boolean().nullish()
});

// src/generated-definitions/ConditionGroupValidateResult.ts
import { z as z174 } from "zod";
var ConditionGroupValidateResult = z174.object({ predicateValidateResults: z174.array(PredicateValidateResult).nullish() });

// src/generated-definitions/ItemPurchaseConditionValidateResult.ts
import { z as z175 } from "zod";
var ItemPurchaseConditionValidateResult = z175.object({
  itemId: z175.string().nullish(),
  purchasable: z175.boolean().nullish(),
  sku: z175.string().nullish(),
  validateDetails: z175.array(ConditionGroupValidateResult).nullish()
});

// src/generated-definitions/ItemPurchaseConditionValidateResultArray.ts
import { z as z176 } from "zod";
var ItemPurchaseConditionValidateResultArray = z176.array(ItemPurchaseConditionValidateResult);

// src/generated-definitions/ItemTypeConfigInfo.ts
import { z as z177 } from "zod";
var ItemTypeConfigInfo = z177.object({
  clazz: z177.string().nullish(),
  createdAt: z177.string(),
  dryRun: z177.boolean().nullish(),
  fulfillmentUrl: z177.string(),
  id: z177.string(),
  itemType: z177.enum([
    "APP",
    "BUNDLE",
    "CODE",
    "COINS",
    "EXTENSION",
    "INGAMEITEM",
    "LOOTBOX",
    "MEDIA",
    "OPTIONBOX",
    "SEASON",
    "SUBSCRIPTION"
  ]),
  purchaseConditionUrl: z177.string().nullish(),
  updatedAt: z177.string()
});

// src/generated-definitions/ItemTypeConfigInfoArray.ts
import { z as z178 } from "zod";
var ItemTypeConfigInfoArray = z178.array(ItemTypeConfigInfo);

// src/generated-definitions/BundledItemInfo.ts
import { z as z179 } from "zod";
var BundledItemInfo = z179.object({
  appId: z179.string().nullish(),
  appType: z179.enum(["DEMO", "DLC", "GAME", "SOFTWARE"]).nullish(),
  baseAppId: z179.string().nullish(),
  boothName: z179.string().nullish(),
  boundItemIds: z179.array(z179.string()).nullish(),
  bundledQty: z179.number().int().nullish(),
  categoryPath: z179.string(),
  clazz: z179.string().nullish(),
  createdAt: z179.string(),
  description: z179.string().nullish(),
  displayOrder: z179.number().int().nullish(),
  entitlementType: z179.enum(["CONSUMABLE", "DURABLE"]),
  ext: z179.record(z179.any()).nullish(),
  features: z179.array(z179.string()).nullish(),
  flexible: z179.boolean().nullish(),
  fresh: z179.boolean().nullish(),
  images: z179.array(Image).nullish(),
  inventoryConfig: InventoryConfig.nullish(),
  itemId: z179.string(),
  itemIds: z179.array(z179.string()).nullish(),
  itemQty: z179.record(z179.number().int()).nullish(),
  itemType: z179.enum([
    "APP",
    "BUNDLE",
    "CODE",
    "COINS",
    "EXTENSION",
    "INGAMEITEM",
    "LOOTBOX",
    "MEDIA",
    "OPTIONBOX",
    "SEASON",
    "SUBSCRIPTION"
  ]),
  language: z179.string(),
  listable: z179.boolean().nullish(),
  localExt: z179.record(z179.any()).nullish(),
  longDescription: z179.string().nullish(),
  lootBoxConfig: LootBoxConfig.nullish(),
  maxCount: z179.number().int().nullish(),
  maxCountPerUser: z179.number().int().nullish(),
  name: z179.string(),
  namespace: z179.string(),
  optionBoxConfig: OptionBoxConfig.nullish(),
  purchasable: z179.boolean().nullish(),
  purchaseCondition: PurchaseCondition.nullish(),
  recurring: Recurring.nullish(),
  region: z179.string(),
  regionData: z179.array(RegionDataItem).nullish(),
  saleConfig: SaleConfig.nullish(),
  seasonType: z179.enum(["PASS", "TIER"]).nullish(),
  sectionExclusive: z179.boolean().nullish(),
  sellable: z179.boolean().nullish(),
  sku: z179.string().nullish(),
  stackable: z179.boolean().nullish(),
  status: z179.enum(["ACTIVE", "INACTIVE"]),
  tags: z179.array(z179.string()).nullish(),
  targetCurrencyCode: z179.string().nullish(),
  targetItemId: z179.string().nullish(),
  targetNamespace: z179.string().nullish(),
  thumbnailUrl: z179.string().nullish(),
  title: z179.string(),
  updatedAt: z179.string(),
  useCount: z179.number().int().nullish()
});

// src/generated-definitions/PopulatedItemInfo.ts
import { z as z180 } from "zod";
var PopulatedItemInfo = z180.object({
  appId: z180.string().nullish(),
  appType: z180.enum(["DEMO", "DLC", "GAME", "SOFTWARE"]).nullish(),
  baseAppId: z180.string().nullish(),
  boothName: z180.string().nullish(),
  boundItemIds: z180.array(z180.string()).nullish(),
  categoryPath: z180.string(),
  clazz: z180.string().nullish(),
  createdAt: z180.string(),
  description: z180.string().nullish(),
  displayOrder: z180.number().int().nullish(),
  entitlementType: z180.enum(["CONSUMABLE", "DURABLE"]),
  ext: z180.record(z180.any()).nullish(),
  features: z180.array(z180.string()).nullish(),
  flexible: z180.boolean().nullish(),
  fresh: z180.boolean().nullish(),
  images: z180.array(Image).nullish(),
  inventoryConfig: InventoryConfig.nullish(),
  itemId: z180.string(),
  itemIds: z180.array(z180.string()).nullish(),
  itemQty: z180.record(z180.number().int()).nullish(),
  itemType: z180.enum([
    "APP",
    "BUNDLE",
    "CODE",
    "COINS",
    "EXTENSION",
    "INGAMEITEM",
    "LOOTBOX",
    "MEDIA",
    "OPTIONBOX",
    "SEASON",
    "SUBSCRIPTION"
  ]),
  items: z180.array(BundledItemInfo).nullish(),
  language: z180.string(),
  listable: z180.boolean().nullish(),
  localExt: z180.record(z180.any()).nullish(),
  longDescription: z180.string().nullish(),
  lootBoxConfig: LootBoxConfig.nullish(),
  maxCount: z180.number().int().nullish(),
  maxCountPerUser: z180.number().int().nullish(),
  name: z180.string(),
  namespace: z180.string(),
  optionBoxConfig: OptionBoxConfig.nullish(),
  purchasable: z180.boolean().nullish(),
  purchaseCondition: PurchaseCondition.nullish(),
  recurring: Recurring.nullish(),
  region: z180.string(),
  regionData: z180.array(RegionDataItem).nullish(),
  saleConfig: SaleConfig.nullish(),
  seasonType: z180.enum(["PASS", "TIER"]).nullish(),
  sectionExclusive: z180.boolean().nullish(),
  sellable: z180.boolean().nullish(),
  sku: z180.string().nullish(),
  stackable: z180.boolean().nullish(),
  status: z180.enum(["ACTIVE", "INACTIVE"]),
  tags: z180.array(z180.string()).nullish(),
  targetCurrencyCode: z180.string().nullish(),
  targetItemId: z180.string().nullish(),
  targetNamespace: z180.string().nullish(),
  thumbnailUrl: z180.string().nullish(),
  title: z180.string(),
  updatedAt: z180.string(),
  useCount: z180.number().int().nullish()
});

// src/generated-admin/endpoints/ItemAdmin$.ts
import { Validate as Validate16 } from "@accelbyte/sdk";
import { z as z181 } from "zod";
var ItemAdmin$ = class {
  // @ts-ignore
  // prettier-ignore
  constructor(axiosInstance, namespace, useSchemaValidation = true) {
    this.axiosInstance = axiosInstance;
    this.namespace = namespace;
    this.useSchemaValidation = useSchemaValidation;
  }
  /**
   * &lt;b&gt;[Not supported yet in AGS Shared Cloud]&lt;/b&gt;This API is used to get all item type configs.&lt;p&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: the list of items&lt;/li&gt;&lt;/ul&gt;
   */
  getItemsConfigs() {
    const params = {};
    const url = "/platform/admin/items/configs";
    const resultPromise = this.axiosInstance.get(url, { params });
    return Validate16.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      ItemTypeConfigInfoArray,
      "ItemTypeConfigInfoArray"
    );
  }
  /**
   * &lt;b&gt;[Not supported yet in AGS Shared Cloud]&lt;/b&gt;This API is used to create an item type config.&lt;p&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: item type config data&lt;/li&gt;&lt;/ul&gt;
   */
  createItemConfig(data) {
    const params = {};
    const url = "/platform/admin/items/configs";
    const resultPromise = this.axiosInstance.post(url, data, { params });
    return Validate16.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, z181.unknown(), "z.unknown()");
  }
  /**
   * &lt;b&gt;[Not supported yet in AGS Shared Cloud]&lt;/b&gt;This API is used to delete an item type config permanently.
   */
  deleteItemConfig_ById(id) {
    const params = {};
    const url = "/platform/admin/items/configs/{id}".replace("{id}", id);
    const resultPromise = this.axiosInstance.delete(url, { params });
    return Validate16.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, z181.unknown(), "z.unknown()");
  }
  /**
   * &lt;b&gt;[Not supported yet in AGS Shared Cloud]&lt;/b&gt;This API is used to get an item type config.&lt;p&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: item type config data&lt;/li&gt;&lt;/ul&gt;
   */
  getItemConfig_ById(id) {
    const params = {};
    const url = "/platform/admin/items/configs/{id}".replace("{id}", id);
    const resultPromise = this.axiosInstance.get(url, { params });
    return Validate16.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, ItemTypeConfigInfo, "ItemTypeConfigInfo");
  }
  /**
   * &lt;b&gt;[Not supported yet in AGS Shared Cloud]&lt;/b&gt;This API is used to update an item type config.&lt;p&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: item type config data&lt;/li&gt;&lt;/ul&gt;
   */
  updateItemConfig_ById(id, data) {
    const params = {};
    const url = "/platform/admin/items/configs/{id}".replace("{id}", id);
    const resultPromise = this.axiosInstance.put(url, data, { params });
    return Validate16.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, ItemTypeConfigInfo, "ItemTypeConfigInfo");
  }
  /**
   * &lt;b&gt;[Not supported yet in AGS Shared Cloud]&lt;/b&gt;This API is used to get an item type config.&lt;p&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: item type config data&lt;/li&gt;&lt;/ul&gt;
   */
  getItemsConfigsSearch(queryParams) {
    const params = { ...queryParams };
    const url = "/platform/admin/items/configs/search";
    const resultPromise = this.axiosInstance.get(url, { params });
    return Validate16.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, ItemTypeConfigInfo, "ItemTypeConfigInfo");
  }
  /**
   * This API is used to create an item. APP item only can created in publisher namespace.&lt;p&gt;An item create example:&lt;p&gt;&lt;pre&gt;&lt;code&gt;{ &#34;categoryPath&#34;: &#34;/games&#34;, &#34;localizations&#34;: \{ &#34;en&#34;: \{ &#34;title&#34;:&#34;required&#34;, &#34;description&#34;:&#34;optional&#34;, &#34;longDescription&#34;:&#34;optional&#34;, &#34;localExt&#34;: \{ &#34;properties&#34;:\[ \{ &#34;key1&#34;:&#34;value1&#34;, &#34;key2&#34;:&#34;value2&#34; \} \], &#34;functions&#34;:\[ \{ &#34;key1&#34;:&#34;value1&#34;, &#34;key2&#34;:&#34;value2&#34; \} \] \} \} \}, &#34;images&#34;: \[ \{ &#34;as&#34;:&#34;optional, image for&#34;, &#34;caption&#34;:&#34;optional&#34;, &#34;height&#34;:10, &#34;width&#34;:10, &#34;imageUrl&#34;:&#34;http://img-url-required&#34;, &#34;smallImageUrl&#34;:&#34;http://small-img-url-required&#34; \} \], &#34;thumbnailUrl&#34;: &#34;optional, thumbnail url&#34;, &#34;status&#34;: &#34;ACTIVE&#34;, &#34;listable&#34;: true, &#34;purchasable&#34;: true, &#34;itemType&#34;: &#34;APP(allowed: [APP,COINS,INGAMEITEM,CODE,BUNDLE])&#34;, &#34;name&#34;: &#34;required, also will be used as entitlement name&#34;, &#34;entitlementType&#34;: &#34;DURABLE(allowed:[DURABLE,CONSUMABLE], should be CONSUMABLE when item type is COINS)&#34;, &#34;useCount&#34;: 1(optional, required if the entitlement type is consumable), &#34;stackable&#34;: false, &#34;appId&#34;: &#34;optional, required if itemType is APP&#34;, &#34;appType&#34;: &#34;GAME(optional, required if itemType is APP)&#34;, &#34;seasonType&#34;: &#34;PASS(optional, required if itemType is SEASON)&#34;, &#34;baseAppId&#34;: &#34;optional, set value of game app id if you want to link to a game&#34;, &#34;targetCurrencyCode&#34;: &#34;optional, required if itemType is COINS&#34;, &#34;targetNamespace&#34;: &#34;optional, required when itemType is INGAMEITEM, the targetNamespace will only take effect when the item created belongs to the publisher namespace&#34;, &#34;sku&#34;: &#34;optional, commonly unique item code&#34;, &#34;regionData&#34;: \{ &#34;US(store&#39;s default region is required)&#34;: \[ \{ &#34;price&#34;:10, &#34;discountPercentage&#34;: 0(integer, optional, range[0,100], discountedPrice = price \* ((100 - discountPercentage) \* 0.01), will use it to calculate discounted price if it is not 0), &#34;discountAmount&#34;:0(integer, optional, range[0,itemPrice], will use it to calculate discounted price if discountPercentage is 0), &#34;currencyCode&#34;:&#34;code(required, example: USD)&#34;, &#34;currencyNamespace&#34;:&#34;test-ns-required(allow publisher namespace if namespace is publisher namespace, allow publisher and game namespace if namespace is not publisher namespace)&#34;, &#34;trialPrice&#34;:5(required while fixedTrialCycles set, should &gt;=0 and &lt;= price, will same as price if not present), &#34;purchaseAt&#34;:&#34;optional yyyy-MM-dd&#39;T&#39;HH:mm:ss.SSS&#39;Z&#39;&#34;, &#34;expireAt&#34;:&#34;optional yyyy-MM-dd&#39;T&#39;HH:mm:ss.SSS&#39;Z&#39;&#34;, &#34;discountPurchaseAt&#34;:&#34;optional yyyy-MM-dd&#39;T&#39;HH:mm:ss.SSS&#39;Z&#39;&#34;, &#34;discountExpireAt&#34;:&#34;optional yyyy-MM-dd&#39;T&#39;HH:mm:ss.SSS&#39;Z&#39;&#34; \} \] \}, &#34;itemIds&#34;: \[ &#34;itemId&#34; \], &#34;itemQty&#34;: \{ &#34;itemId&#34;:1 \}, &#34;recurring&#34;: \{ &#34;cycle&#34;:&#34;MONTHLY(allowed: [WEEKLY,MONTHLY,QUARTERLY,YEARLY])&#34;, &#34;fixedFreeDays&#34;:0(integer, fixed free days, 0 means not set), &#34;fixedTrialCycles&#34;:0(integer, fixed trial cycles, 0 means not set, will not take effect if fixedFreeDays set), &#34;graceDays&#34;:7(integer, recurring grace days, retry recurring charge within configured days if charge fail, default 7) \}, &#34;tags&#34;: \[ &#34;exampleTag24&#34; \], &#34;features&#34;: \[ &#34;feature&#34; \], &#34;clazz&#34;: &#34;weapon&#34;, &#34;boothName&#34;: &#34;C_campaign1&#34;, &#34;displayOrder&#34;: 1000, &#34;ext&#34;: \{ &#34;properties&#34;:\[ \{ &#34;key1&#34;:&#34;value1&#34;, &#34;key2&#34;:&#34;value2&#34; \} \], &#34;functions&#34;:\[ \{ &#34;key1&#34;:&#34;value1&#34;, &#34;key2&#34;:&#34;value2&#34; \} \] \}, &#34;maxCountPerUser&#34;: 1(integer, optional, -1 means UNLIMITED), &#34;maxCount&#34;: 1(integer, optional, -1 means UNLIMITED, unset when itemType is CODE) }&lt;/code&gt;&lt;/pre&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: created item data&lt;/li&gt;&lt;/ul&gt;&lt;h2&gt;Restrictions for item extension and localization extension and inventory config custom attributes&lt;/h2&gt; 1. Cannot use &lt;b&gt;&#34;.&#34;&lt;/b&gt; as the key name - &lt;pre&gt;{ &#34;data.2&#34;: &#34;value&#34; }&lt;/pre&gt; 2. Cannot use &lt;b&gt;&#34;$&#34;&lt;/b&gt; as the prefix in key names - &lt;pre&gt;{ &#34;$data&#34;: &#34;value&#34; }&lt;/pre&gt;
   */
  createItem(data, queryParams) {
    const params = { ...queryParams };
    const url = "/platform/admin/namespaces/{namespace}/items".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.post(url, data, { params });
    return Validate16.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, FullItemInfo, "FullItemInfo");
  }
  /**
   * &lt;b&gt;[Not supported yet in AGS Shared Cloud]&lt;/b&gt;This API is used to sync an in game item in game namespace to publisher namespace, only INGAMEITEM, CODE, COINS and SEASON are supported&lt;p&gt;The synced item has an additional field targetItemId besides targetNamespace, mostly this item should not modified manually again. &lt;p&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: item data&lt;/li&gt;&lt;/ul&gt;
   */
  updateItem(data, queryParams) {
    const params = { ...queryParams };
    const url = "/platform/admin/namespaces/{namespace}/items".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.put(url, data, { params });
    return Validate16.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, FullItemInfo, "FullItemInfo");
  }
  /**
   * This API is used to get items.&lt;p&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: the list of items info&lt;/li&gt;&lt;/ul&gt;
   */
  getItemsByIds(queryParams) {
    const params = { activeOnly: true, ...queryParams };
    const url = "/platform/admin/namespaces/{namespace}/items/byIds".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.get(url, { params });
    return Validate16.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, FullItemInfoArray, "FullItemInfoArray");
  }
  /**
   * This API is used to get the item by sku.&lt;p&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: the item with sku&lt;/li&gt;&lt;/ul&gt;
   */
  getItemsBySku(queryParams) {
    const params = { activeOnly: true, ...queryParams };
    const url = "/platform/admin/namespaces/{namespace}/items/bySku".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.get(url, { params });
    return Validate16.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, FullItemInfo, "FullItemInfo");
  }
  /**
   * This API is used to search items by keyword in title, description and long description within a store.&lt;p&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: the list of items&lt;/li&gt;&lt;/ul&gt;
   */
  getItemsSearch(queryParams) {
    const params = { activeOnly: true, limit: 20, sortBy: "name:asc,createdAt:asc", ...queryParams };
    const url = "/platform/admin/namespaces/{namespace}/items/search".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.get(url, { params });
    return Validate16.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      FullItemPagingSlicedResult,
      "FullItemPagingSlicedResult"
    );
  }
  /**
   * This API is used to get the item by appId.&lt;p&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: the item with that appId&lt;/li&gt;&lt;/ul&gt;
   */
  getItemsByAppId(queryParams) {
    const params = { activeOnly: true, ...queryParams };
    const url = "/platform/admin/namespaces/{namespace}/items/byAppId".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.get(url, { params });
    return Validate16.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, FullItemInfo, "FullItemInfo");
  }
  /**
   * This API is used to delete an item permanently.&lt;p&gt;force: the default value should be: false. When the value is: &lt;li&gt;&lt;i&gt;false:&lt;i&gt;only the items in the draft store that have never been published yet can be removed.&lt;/li&gt;&lt;li&gt;&lt;i&gt;true:&lt;i&gt;the item in the draft store(even been published before) can be removed.&lt;/li&gt;
   */
  deleteItem_ByItemId(itemId, queryParams) {
    const params = { ...queryParams };
    const url = "/platform/admin/namespaces/{namespace}/items/{itemId}".replace("{namespace}", this.namespace).replace("{itemId}", itemId);
    const resultPromise = this.axiosInstance.delete(url, { params });
    return Validate16.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, z181.unknown(), "z.unknown()");
  }
  /**
   * This API is used to get an item.&lt;p&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: item data&lt;/li&gt;&lt;/ul&gt;
   */
  getItem_ByItemId(itemId, queryParams) {
    const params = { activeOnly: true, ...queryParams };
    const url = "/platform/admin/namespaces/{namespace}/items/{itemId}".replace("{namespace}", this.namespace).replace("{itemId}", itemId);
    const resultPromise = this.axiosInstance.get(url, { params });
    return Validate16.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, FullItemInfo, "FullItemInfo");
  }
  /**
   * This API is used to update an item.&lt;p&gt;An item update example:&lt;p&gt;&lt;pre&gt;&lt;code&gt;{ &#34;categoryPath&#34;: &#34;/games&#34;, &#34;localizations&#34;: \{ &#34;en&#34;: \{ &#34;title&#34;:&#34;required&#34;, &#34;description&#34;:&#34;optional&#34;, &#34;longDescription&#34;:&#34;optional&#34;, &#34;localExt&#34;: \{ &#34;properties&#34;:\[ \{ &#34;key1&#34;:&#34;value1&#34;, &#34;key2&#34;:&#34;value2&#34; \} \], &#34;functions&#34;:\[ \{ &#34;key1&#34;:&#34;value1&#34;, &#34;key2&#34;:&#34;value2&#34; \} \] \} \} \}, &#34;images&#34;: \[ \{ &#34;as&#34;:&#34;optional, image for&#34;, &#34;caption&#34;:&#34;optional&#34;, &#34;height&#34;:10, &#34;width&#34;:10, &#34;imageUrl&#34;:&#34;http://img-url-required&#34;, &#34;smallImageUrl&#34;:&#34;http://small-img-url-required&#34; \} \], &#34;thumbnailUrl&#34;: &#34;optional, thumbnail url&#34;, &#34;status&#34;: &#34;ACTIVE&#34;, &#34;listable&#34;: true, &#34;purchasable&#34;: true, &#34;itemType&#34;: &#34;APP(allowed: [APP,COINS,INGAMEITEM,CODE,BUNDLE])&#34;, &#34;name&#34;: &#34;optional&#34;, &#34;entitlementType&#34;: &#34;DURABLE(allowed:[DURABLE,CONSUMABLE], should be CONSUMABLE when item type is COINS)&#34;, &#34;useCount&#34;: 1(optional, required if the entitlement type is consumable), &#34;stackable&#34;: false, &#34;appId&#34;: &#34;optional, required if itemType is APP&#34;, &#34;baseAppId&#34;: &#34;optional, set value of game app id if you want to link to a game&#34;, &#34;appType&#34;: &#34;GAME(optional, required if itemType is APP)&#34;, &#34;seasonType&#34;: &#34;PASS(optional, required if itemType is SEASON)&#34;, &#34;sku&#34;: &#34;optional, commonly unique item code&#34;, &#34;targetCurrencyCode&#34;: &#34;optional, required if itemType is COINS&#34;, &#34;targetNamespace&#34;: &#34;optional, required when itemType is INGAMEITEM, the targetNamespace will only take effect when the item created belongs to the publisher namespace&#34;, &#34;regionData&#34;: \{ &#34;US(store&#39;s default region is required)&#34;: \[ \{ &#34;price&#34;:10, &#34;discountPercentage&#34;:0(integer, optional, range[0,100], discountedPrice = price\*((100 - discountPercentage) \* 0.01), if it is not 0, will use it to calculate discounted price), &#34;discountAmount&#34;:0(integer, optional, range[0,itemPrice], will use it to calculate discounted price if discountPercentage is 0), &#34;currencyCode&#34;:&#34;code(required, example: USD)&#34;, &#34;currencyNamespace&#34;:&#34;test-ns-required(allow publisher namespace if namespace is publisher namespace, allow publisher and game namespace if namespace is not publisher namespace)&#34;, &#34;trialPrice&#34;:5(required while fixedTrialCycles set, should &gt;=0 and &lt;= price, will same as price if not present), &#34;purchaseAt&#34;:&#34;optional yyyy-MM-dd&#39;T&#39;HH:mm:ss.SSS&#39;Z&#39;&#34;, &#34;expireAt&#34;:&#34;optional yyyy-MM-dd&#39;T&#39;HH:mm:ss.SSS&#39;Z&#39;&#34;, &#34;discountPurchaseAt&#34;:&#34;optional yyyy-MM-dd&#39;T&#39;HH:mm:ss.SSS&#39;Z&#39;&#34;, &#34;discountExpireAt&#34;:&#34;optional yyyy-MM-dd&#39;T&#39;HH:mm:ss.SSS&#39;Z&#39;&#34; \} \] \}, &#34;itemIds&#34;: \[ &#34;itemId&#34; \], &#34;itemQty&#34;: \{ &#34;itemId&#34;:1 \}, &#34;recurring&#34;: \{ &#34;cycle&#34;:&#34;MONTHLY(allowed: [WEEKLY,MONTHLY,QUARTERLY,YEARLY])&#34;, &#34;fixedFreeDays&#34;:0(integer, fixed free days, 0 means not set), &#34;fixedTrialCycles&#34;:0(integer, fixed trial cycles, 0 means not set, will not take effect if fixedFreeDays set), &#34;graceDays&#34;:7(integer, recurring grace days, retry recurring charge within configured days if charge fail, default 7) \}, &#34;tags&#34;: \[ &#34;exampleTag24&#34; \], &#34;features&#34;: \[ &#34;feature&#34; \], &#34;clazz&#34;: &#34;weapon&#34;, &#34;boothName&#34;: &#34;C_campaign1&#34;, &#34;displayOrder&#34;: 1000, &#34;ext&#34;: \{ &#34;properties&#34;:\[ \{ &#34;key1&#34;:&#34;value1&#34;, &#34;key2&#34;:&#34;value2&#34; \} \], &#34;functions&#34;:\[ \{ &#34;key1&#34;:&#34;value1&#34;, &#34;key2&#34;:&#34;value2&#34; \} \] \}, &#34;maxCountPerUser&#34;: 1(integer, optional, -1 means UNLIMITED), &#34;maxCount&#34;: 1(integer, optional, -1 means UNLIMITED, new value should &gt;= old value if both old value and new value is limited, unset when item type is CODE) }&lt;/code&gt;&lt;/pre&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: updated item data&lt;/li&gt;&lt;/ul&gt;&lt;h2&gt;Restrictions for item extension and localization extension&lt;/h2&gt; 1. Cannot use &lt;b&gt;&#34;.&#34;&lt;/b&gt; as the key name - &lt;pre&gt;{ &#34;data.2&#34;: &#34;value&#34; }&lt;/pre&gt; 2. Cannot use &lt;b&gt;&#34;$&#34;&lt;/b&gt; as the prefix in key names - &lt;pre&gt;{ &#34;$data&#34;: &#34;value&#34; }&lt;/pre&gt;
   */
  updateItem_ByItemId(itemId, data, queryParams) {
    const params = { ...queryParams };
    const url = "/platform/admin/namespaces/{namespace}/items/{itemId}".replace("{namespace}", this.namespace).replace("{itemId}", itemId);
    const resultPromise = this.axiosInstance.put(url, data, { params });
    return Validate16.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, FullItemInfo, "FullItemInfo");
  }
  /**
   * This API is used to query items by criteria within a store.&lt;p&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: the list of items&lt;/li&gt;&lt;/ul&gt;
   */
  getItemsByCriteria(queryParams) {
    const params = { activeOnly: true, limit: 20, sortBy: ["name:asc", "displayOrder:asc"], ...queryParams };
    const url = "/platform/admin/namespaces/{namespace}/items/byCriteria".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.get(url, { params });
    return Validate16.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      FullItemPagingSlicedResult,
      "FullItemPagingSlicedResult"
    );
  }
  /**
   * This API is used to update region data of items in bulk &lt;br /&gt;
   */
  updateItemRegiondata(data, queryParams) {
    const params = { ...queryParams };
    const url = "/platform/admin/namespaces/{namespace}/items/regiondata".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.put(url, data, { params });
    return Validate16.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, z181.unknown(), "z.unknown()");
  }
  /**
   * This API is used to get an app info.&lt;p&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: app data&lt;/li&gt;&lt;/ul&gt;
   */
  getApp_ByItemId(itemId, queryParams) {
    const params = { activeOnly: true, ...queryParams };
    const url = "/platform/admin/namespaces/{namespace}/items/{itemId}/app".replace("{namespace}", this.namespace).replace("{itemId}", itemId);
    const resultPromise = this.axiosInstance.get(url, { params });
    return Validate16.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, FullAppInfo, "FullAppInfo");
  }
  /**
   * This API is used to update an app.&lt;p&gt;An app update example:&lt;p&gt;&lt;pre&gt;&lt;code&gt;{ &#34;developer&#34;: &#34;accelbyte&#34;, &#34;publisher&#34;: &#34;accelbyte&#34;, &#34;websiteUrl&#34;: &#34;http://accelbyte.io&#34;, &#34;forumUrl&#34;: &#34;http://accelbyte.io&#34;, &#34;platforms&#34;: \[&#34;Windows(allowed values: Windows, MacOS, Linux, IOS, Android)&#34;\], &#34;platformRequirements&#34;: \{ &#34;Windows&#34;: \[ \{ &#34;label&#34;:&#34;minimum(can be minimum or recommended)&#34;, &#34;osVersion&#34;:&#34;os version&#34;, &#34;processor&#34;:&#34;processor&#34;, &#34;ram&#34;:&#34;RAM&#34;, &#34;graphics&#34;:&#34;graphics&#34;, &#34;directXVersion&#34;:&#34;directXVersion&#34;, &#34;diskSpace&#34;:&#34;diskSpace&#34;, &#34;soundCard&#34;:&#34;soundCard&#34;, &#34;additionals&#34;:&#34;additionals&#34; \} \] \}, &#34;carousel&#34;: \[ \{ &#34;type&#34;:&#34;image(allowed values: image, video)&#34;, &#34;videoSource&#34;:&#34;generic(allowed values:generic, youtube, viemo)&#34;, &#34;url&#34;:&#34;url&#34;, &#34;alt&#34;:&#34;alternative url or text&#34;, &#34;thumbnailUrl&#34;:&#34;thumbnail url&#34;, &#34;previewUrl&#34;:&#34;preview url&#34;, \} \], &#34;localizations&#34;: \{ &#34;en&#34;: \{ &#34;slogan&#34;:&#34;slogan&#34;, &#34;announcement&#34;:&#34;announcement&#34;, \} \}, &#34;primaryGenre&#34;: &#34;Action&#34;, &#34;genres&#34;: \[&#34;Action&#34;, &#34;Adventure&#34;\], &#34;players&#34;: \[&#34;Single&#34;\], &#34;releaseDate&#34;: &#34;optional yyyy-MM-dd&#39;T&#39;HH:mm:ss.SSS&#39;Z&#39;&#34; }&lt;/code&gt;&lt;/pre&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: updated app data&lt;/li&gt;&lt;/ul&gt;
   */
  updateApp_ByItemId(itemId, data, queryParams) {
    const params = { ...queryParams };
    const url = "/platform/admin/namespaces/{namespace}/items/{itemId}/app".replace("{namespace}", this.namespace).replace("{itemId}", itemId);
    const resultPromise = this.axiosInstance.put(url, data, { params });
    return Validate16.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, FullAppInfo, "FullAppInfo");
  }
  /**
   * This API is used to get an item by sku in specific locale. If item not exist in specific region, default region item will return.&lt;p&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: item data&lt;/li&gt;&lt;/ul&gt;
   */
  getItemsBySkuLocale(queryParams) {
    const params = { activeOnly: true, ...queryParams };
    const url = "/platform/admin/namespaces/{namespace}/items/bySku/locale".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.get(url, { params });
    return Validate16.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, PopulatedItemInfo, "PopulatedItemInfo");
  }
  /**
   * &lt;b&gt;[SERVICE COMMUNICATION ONLY]&lt;/b&gt; This API is used to get the itemId by sku.&lt;p&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: the itemId with sku&lt;/li&gt;&lt;/ul&gt;
   */
  getItemsItemIdBySku(queryParams) {
    const params = { activeOnly: true, ...queryParams };
    const url = "/platform/admin/namespaces/{namespace}/items/itemId/bySku".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.get(url, { params });
    return Validate16.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, ItemId, "ItemId");
  }
  /**
   * This API is used to bulk get locale items. If item not exist in specific region, default region item will return.&lt;p&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: the list of items info&lt;/li&gt;&lt;/ul&gt;
   */
  getItemsLocaleByIds(queryParams) {
    const params = { activeOnly: true, ...queryParams };
    const url = "/platform/admin/namespaces/{namespace}/items/locale/byIds".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.get(url, { params });
    return Validate16.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, ItemInfoArray, "ItemInfoArray");
  }
  /**
   * This API is used to get an list of itemId by list of sku.&lt;p&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: item data&lt;/li&gt;&lt;/ul&gt;
   */
  getItemsItemIdBySkus(queryParams) {
    const params = { ...queryParams };
    const url = "/platform/admin/namespaces/{namespace}/items/itemId/bySkus".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.get(url, { params });
    return Validate16.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, ItemIdArray, "ItemIdArray");
  }
  /**
   * This API is used to query uncategorized items within a store.&lt;p&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: the list of uncategorized items&lt;/li&gt;&lt;/ul&gt;
   */
  getItemsUncategorized(queryParams) {
    const params = { activeOnly: true, limit: 20, sortBy: ["name:asc"], ...queryParams };
    const url = "/platform/admin/namespaces/{namespace}/items/uncategorized".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.get(url, { params });
    return Validate16.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      FullItemPagingSlicedResult,
      "FullItemPagingSlicedResult"
    );
  }
  /**
   * This API is used to query items by criteria within a store.&lt;p&gt;The behaviour for itemStatus query parameter:&lt;li&gt;TRUE: Show only ACTIVE items&lt;/li&gt;&lt;li&gt;FALSE: Show only INACTIVE items&lt;/li&gt;&lt;li&gt;Not provided: show both ACTIVE and INACTIVE items&lt;/li&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: the list of items&lt;/li&gt;&lt;/ul&gt;
   */
  getItemsByCriteria_v2(queryParams) {
    const params = { limit: 20, sortBy: ["name:asc", "displayOrder:asc"], ...queryParams };
    const url = "/platform/v2/admin/namespaces/{namespace}/items/byCriteria".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.get(url, { params });
    return Validate16.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, FullItemPagingResult, "FullItemPagingResult");
  }
  /**
   * This API is used to get estimated prices of a flexible pricing bundle
   */
  getItemsEstimatedPrice(queryParams) {
    const params = { ...queryParams };
    const url = "/platform/admin/namespaces/{namespace}/items/estimatedPrice".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.get(url, { params });
    return Validate16.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, EstimatedPriceInfo, "EstimatedPriceInfo");
  }
  /**
   * Enable an item.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: updated item&lt;/li&gt;&lt;/ul&gt;
   */
  updateEnable_ByItemId(itemId, queryParams) {
    const params = { ...queryParams };
    const url = "/platform/admin/namespaces/{namespace}/items/{itemId}/enable".replace("{namespace}", this.namespace).replace("{itemId}", itemId);
    const resultPromise = this.axiosInstance.put(url, null, { params });
    return Validate16.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, FullItemInfo, "FullItemInfo");
  }
  /**
   * This API is used to get an item in specific locale. If item not exist in specific region, default region item will return.&lt;p&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: item data&lt;/li&gt;&lt;/ul&gt;
   */
  getLocale_ByItemId(itemId, queryParams) {
    const params = { activeOnly: true, ...queryParams };
    const url = "/platform/admin/namespaces/{namespace}/items/{itemId}/locale".replace("{namespace}", this.namespace).replace("{itemId}", itemId);
    const resultPromise = this.axiosInstance.get(url, { params });
    return Validate16.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, PopulatedItemInfo, "PopulatedItemInfo");
  }
  /**
   * &lt;b&gt;[SERVICE COMMUNICATION ONLY]&lt;/b&gt; This api is used for returning a published item while the item is maxCount limited, it will increase the sale available count if orderNo already acquired.
   */
  updateReturn_ByItemId(itemId, data) {
    const params = {};
    const url = "/platform/admin/namespaces/{namespace}/items/{itemId}/return".replace("{namespace}", this.namespace).replace("{itemId}", itemId);
    const resultPromise = this.axiosInstance.put(url, data, { params });
    return Validate16.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, z181.unknown(), "z.unknown()");
  }
  /**
   * Get available predicate types.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: available predicate types&lt;/li&gt;&lt;/ul&gt;
   */
  getItemsPredicateTypes() {
    const params = {};
    const url = "/platform/admin/namespaces/{namespace}/items/predicate/types".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.get(url, { params });
    return Validate16.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      AvailablePredicateArray,
      "AvailablePredicateArray"
    );
  }
  /**
   * &lt;b&gt;[SERVICE COMMUNICATION ONLY]&lt;/b&gt; This api is used for acquiring a published item while the item is maxCount limited, it will decrease the sale available count.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: acquire result&lt;/li&gt;&lt;/ul&gt;
   */
  updateAcquire_ByItemId(itemId, data) {
    const params = {};
    const url = "/platform/admin/namespaces/{namespace}/items/{itemId}/acquire".replace("{namespace}", this.namespace).replace("{itemId}", itemId);
    const resultPromise = this.axiosInstance.put(url, data, { params });
    return Validate16.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, ItemAcquireResult, "ItemAcquireResult");
  }
  /**
   * Disable an item.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: updated item&lt;/li&gt;&lt;/ul&gt;
   */
  updateDisable_ByItemId(itemId, queryParams) {
    const params = { ...queryParams };
    const url = "/platform/admin/namespaces/{namespace}/items/{itemId}/disable".replace("{namespace}", this.namespace).replace("{itemId}", itemId);
    const resultPromise = this.axiosInstance.put(url, null, { params });
    return Validate16.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, FullItemInfo, "FullItemInfo");
  }
  /**
   * Get item dynamic data for published item.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: item dynamic data&lt;/li&gt;&lt;/ul&gt;
   */
  getDynamic_ByItemId(itemId) {
    const params = {};
    const url = "/platform/admin/namespaces/{namespace}/items/{itemId}/dynamic".replace("{namespace}", this.namespace).replace("{itemId}", itemId);
    const resultPromise = this.axiosInstance.get(url, { params });
    return Validate16.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, ItemDynamicDataInfo, "ItemDynamicDataInfo");
  }
  /**
   * &lt;b&gt;[SERVICE COMMUNICATION ONLY]&lt;/b&gt; This API is used to list basic items by features.&lt;p&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: the list of basic items&lt;/li&gt;&lt;/ul&gt;
   */
  getItemsByFeaturesBasic(queryParams) {
    const params = { activeOnly: true, ...queryParams };
    const url = "/platform/admin/namespaces/{namespace}/items/byFeatures/basic".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.get(url, { params });
    return Validate16.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, BasicItemArray, "BasicItemArray");
  }
  /**
   * Remove a feature from an item.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: updated item&lt;/li&gt;&lt;/ul&gt;
   */
  deleteFeature_ByItemId_ByFeature(itemId, feature, queryParams) {
    const params = { ...queryParams };
    const url = "/platform/admin/namespaces/{namespace}/items/{itemId}/features/{feature}".replace("{namespace}", this.namespace).replace("{itemId}", itemId).replace("{feature}", feature);
    const resultPromise = this.axiosInstance.delete(url, { params });
    return Validate16.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, FullItemInfo, "FullItemInfo");
  }
  /**
   * Add a feature to an item.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: updated item&lt;/li&gt;&lt;/ul&gt;
   */
  updateFeature_ByItemId_ByFeature(itemId, feature, queryParams) {
    const params = { ...queryParams };
    const url = "/platform/admin/namespaces/{namespace}/items/{itemId}/features/{feature}".replace("{namespace}", this.namespace).replace("{itemId}", itemId).replace("{feature}", feature);
    const resultPromise = this.axiosInstance.put(url, null, { params });
    return Validate16.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, FullItemInfo, "FullItemInfo");
  }
  /**
   * This API is used to update item purchase condition
   */
  updatePurchaseCondition_ByItemId(itemId, data, queryParams) {
    const params = { ...queryParams };
    const url = "/platform/admin/namespaces/{namespace}/items/{itemId}/purchase/condition".replace("{namespace}", this.namespace).replace("{itemId}", itemId);
    const resultPromise = this.axiosInstance.put(url, data, { params });
    return Validate16.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, FullItemInfo, "FullItemInfo");
  }
  /**
   * This API is used to validate user purchase condition
   */
  createItemPurchaseConditionValidate(data, queryParams) {
    const params = { ...queryParams };
    const url = "/platform/admin/namespaces/{namespace}/items/purchase/conditions/validate".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.post(url, data, { params });
    return Validate16.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      ItemPurchaseConditionValidateResultArray,
      "ItemPurchaseConditionValidateResultArray"
    );
  }
};

// src/generated-definitions/KeyGroupDynamicInfo.ts
import { z as z182 } from "zod";
var KeyGroupDynamicInfo = z182.object({
  availableSaleCount: z182.number().int(),
  quantity: z182.number().int(),
  saleCount: z182.number().int()
});

// src/generated-definitions/KeyGroupInfo.ts
import { z as z183 } from "zod";
var KeyGroupInfo = z183.object({
  boothName: z183.string(),
  createdAt: z183.string(),
  description: z183.string().nullish(),
  id: z183.string(),
  name: z183.string(),
  namespace: z183.string(),
  status: z183.enum(["ACTIVE", "INACTIVE"]),
  tags: z183.array(z183.string()).nullish(),
  updatedAt: z183.string()
});

// src/generated-definitions/KeyGroupPagingSlicedResult.ts
import { z as z184 } from "zod";
var KeyGroupPagingSlicedResult = z184.object({ data: z184.array(KeyGroupInfo), paging: Paging.nullish() });

// src/generated-definitions/KeyInfo.ts
import { z as z185 } from "zod";
var KeyInfo = z185.object({
  acquireOrderNo: z185.string().nullish(),
  acquireUserId: z185.string().nullish(),
  createdAt: z185.string(),
  id: z185.string(),
  keyFile: z185.string(),
  keyGroupId: z185.string(),
  namespace: z185.string(),
  status: z185.enum(["ACQUIRED", "ACTIVE"]),
  updatedAt: z185.string(),
  value: z185.string()
});

// src/generated-definitions/KeyPagingSliceResult.ts
import { z as z186 } from "zod";
var KeyPagingSliceResult = z186.object({ data: z186.array(KeyInfo), paging: Paging.nullish() });

// src/generated-admin/endpoints/KeyGroupAdmin$.ts
import { Validate as Validate17 } from "@accelbyte/sdk";
var KeyGroupAdmin$ = class {
  // @ts-ignore
  // prettier-ignore
  constructor(axiosInstance, namespace, useSchemaValidation = true) {
    this.axiosInstance = axiosInstance;
    this.namespace = namespace;
    this.useSchemaValidation = useSchemaValidation;
  }
  /**
   * Query key groups, if name is presented, it&#39;s fuzzy match.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: slice of key group&lt;/li&gt;&lt;/ul&gt;
   */
  getKeygroups(queryParams) {
    const params = { limit: 20, ...queryParams };
    const url = "/platform/admin/namespaces/{namespace}/keygroups".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.get(url, { params });
    return Validate17.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      KeyGroupPagingSlicedResult,
      "KeyGroupPagingSlicedResult"
    );
  }
  /**
   * Create key group.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: created key group&lt;/li&gt;&lt;/ul&gt;
   */
  createKeygroup(data) {
    const params = {};
    const url = "/platform/admin/namespaces/{namespace}/keygroups".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.post(url, data, { params });
    return Validate17.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, KeyGroupInfo, "KeyGroupInfo");
  }
  /**
   * @deprecated
   * Get key group.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: key group info&lt;/li&gt;&lt;/ul&gt;
   */
  getKeygroupsByBoothName(queryParams) {
    const params = { ...queryParams };
    const url = "/platform/admin/namespaces/{namespace}/keygroups/byBoothName".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.get(url, { params });
    return Validate17.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, KeyGroupInfo, "KeyGroupInfo");
  }
  /**
   * Get key group.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: key group info&lt;/li&gt;&lt;/ul&gt;
   */
  getKeygroup_ByKeyGroupId(keyGroupId) {
    const params = {};
    const url = "/platform/admin/namespaces/{namespace}/keygroups/{keyGroupId}".replace("{namespace}", this.namespace).replace("{keyGroupId}", keyGroupId);
    const resultPromise = this.axiosInstance.get(url, { params });
    return Validate17.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, KeyGroupInfo, "KeyGroupInfo");
  }
  /**
   * Update key group.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: updated key group&lt;/li&gt;&lt;/ul&gt;
   */
  updateKeygroup_ByKeyGroupId(keyGroupId, data) {
    const params = {};
    const url = "/platform/admin/namespaces/{namespace}/keygroups/{keyGroupId}".replace("{namespace}", this.namespace).replace("{keyGroupId}", keyGroupId);
    const resultPromise = this.axiosInstance.put(url, data, { params });
    return Validate17.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, KeyGroupInfo, "KeyGroupInfo");
  }
  /**
   * This API is used to list keys of a key group.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: keys&lt;/li&gt;&lt;/ul&gt;
   */
  getKeys_ByKeyGroupId(keyGroupId, queryParams) {
    const params = { limit: 20, ...queryParams };
    const url = "/platform/admin/namespaces/{namespace}/keygroups/{keyGroupId}/keys".replace("{namespace}", this.namespace).replace("{keyGroupId}", keyGroupId);
    const resultPromise = this.axiosInstance.get(url, { params });
    return Validate17.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, KeyPagingSliceResult, "KeyPagingSliceResult");
  }
  /**
   * This API is used to upload keys with csv format to a key group.&lt;p&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: item data&lt;/li&gt;&lt;/ul&gt;
   */
  createKey_ByKeyGroupId(keyGroupId, data) {
    const params = {};
    const url = "/platform/admin/namespaces/{namespace}/keygroups/{keyGroupId}/keys".replace("{namespace}", this.namespace).replace("{keyGroupId}", keyGroupId);
    const resultPromise = this.axiosInstance.post(url, data, { params });
    return Validate17.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, BulkOperationResult, "BulkOperationResult");
  }
  /**
   * Get key group dynamic.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: key group info&lt;/li&gt;&lt;/ul&gt;
   */
  getDynamic_ByKeyGroupId(keyGroupId) {
    const params = {};
    const url = "/platform/admin/namespaces/{namespace}/keygroups/{keyGroupId}/dynamic".replace("{namespace}", this.namespace).replace("{keyGroupId}", keyGroupId);
    const resultPromise = this.axiosInstance.get(url, { params });
    return Validate17.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, KeyGroupDynamicInfo, "KeyGroupDynamicInfo");
  }
};

// src/generated-definitions/OrderGrantInfo.ts
import { z as z187 } from "zod";
var OrderGrantInfo = z187.object({ credits: z187.array(CreditSummary).nullish(), entitlements: z187.array(EntitlementSummary).nullish() });

// src/generated-definitions/OrderHistoryInfo.ts
import { z as z188 } from "zod";
var OrderHistoryInfo = z188.object({
  action: z188.enum([
    "CHARGEBACK",
    "CHARGEBACK_REVERSED",
    "CHARGED",
    "CLOSE",
    "DELETED",
    "FULFILLED",
    "FULFILL_FAILED",
    "INIT",
    "REFUNDED",
    "REFUNDING",
    "REFUND_FAILED",
    "SET_STATUS"
  ]),
  createdAt: z188.string(),
  namespace: z188.string(),
  operator: z188.string(),
  orderNo: z188.string(),
  reason: z188.string().nullish(),
  updatedAt: z188.string(),
  userId: z188.string()
});

// src/generated-definitions/OrderHistoryInfoArray.ts
import { z as z189 } from "zod";
var OrderHistoryInfoArray = z189.array(OrderHistoryInfo);

// src/generated-definitions/DiscountCodeInfo.ts
import { z as z190 } from "zod";
var DiscountCodeInfo = z190.object({
  campaignId: z190.string().nullish(),
  campaignName: z190.string().nullish(),
  code: z190.string().nullish(),
  deduction: z190.number().int().nullish(),
  discountConfig: DiscountConfig.nullish()
});

// src/generated-definitions/DiscountCodeDeductionDetail.ts
import { z as z191 } from "zod";
var DiscountCodeDeductionDetail = z191.object({
  discountAmountCodes: z191.array(DiscountCodeInfo).nullish(),
  discountPercentageCodes: z191.array(DiscountCodeInfo).nullish(),
  totalAmountDeduction: z191.number().int().nullish(),
  totalDeduction: z191.number().int().nullish(),
  totalPercentageDeduction: z191.number().int().nullish()
});

// src/generated-definitions/DeductionDetail.ts
import { z as z192 } from "zod";
var DeductionDetail = z192.object({
  deductionType: z192.enum(["DISCOUNT_CODE", "PAYMENT_DISCOUNT_CODE"]).nullish(),
  discountCodeDeductionDetail: DiscountCodeDeductionDetail.nullish(),
  discountProviderName: z192.string().nullish()
});

// src/generated-definitions/OrderBundleItemInfo.ts
import { z as z193 } from "zod";
var OrderBundleItemInfo = z193.object({
  discountedPrice: z193.number().int(),
  itemId: z193.string(),
  itemName: z193.string(),
  itemSku: z193.string(),
  price: z193.number().int(),
  purchased: z193.boolean().nullish(),
  quantity: z193.number().int().nullish()
});

// src/generated-definitions/OrderCreationOptions.ts
import { z as z194 } from "zod";
var OrderCreationOptions = z194.object({ skipPriceValidation: z194.boolean().nullish() });

// src/generated-definitions/OrderInfo.ts
import { z as z195 } from "zod";
var OrderInfo = z195.object({
  chargebackReversedTime: z195.string().nullish(),
  chargebackTime: z195.string().nullish(),
  chargedTime: z195.string().nullish(),
  createdAt: z195.string(),
  createdTime: z195.string().nullish(),
  creationOptions: OrderCreationOptions.nullish(),
  currency: CurrencySummary,
  deduction: z195.number().int(),
  deductionDetails: z195.array(DeductionDetail).nullish(),
  discountedPrice: z195.number().int(),
  expireTime: z195.string().nullish(),
  ext: z195.record(z195.any()).nullish(),
  fulfilledTime: z195.string().nullish(),
  itemId: z195.string(),
  itemSnapshot: ItemSnapshot.nullish(),
  language: z195.string().nullish(),
  namespace: z195.string(),
  orderBundleItemInfos: z195.array(OrderBundleItemInfo).nullish(),
  orderNo: z195.string(),
  paymentMethod: z195.string().nullish(),
  paymentMethodFee: z195.number().int().nullish(),
  paymentOrderNo: z195.string().nullish(),
  paymentProvider: z195.enum(["ADYEN", "ALIPAY", "CHECKOUT", "NEONPAY", "PAYPAL", "STRIPE", "WALLET", "WXPAY", "XSOLLA"]).nullish(),
  paymentProviderFee: z195.number().int().nullish(),
  paymentRemainSeconds: z195.number().int(),
  paymentStationUrl: z195.string().nullish(),
  price: z195.number().int(),
  quantity: z195.number().int(),
  refundedTime: z195.string().nullish(),
  region: z195.string().nullish(),
  salesTax: z195.number().int().nullish(),
  sandbox: z195.boolean(),
  status: z195.enum([
    "CHARGEBACK",
    "CHARGEBACK_REVERSED",
    "CHARGED",
    "CLOSED",
    "DELETED",
    "FULFILLED",
    "FULFILL_FAILED",
    "INIT",
    "REFUNDED",
    "REFUNDING",
    "REFUND_FAILED"
  ]),
  statusReason: z195.string().nullish(),
  subtotalPrice: z195.number().int().nullish(),
  tax: z195.number().int().nullish(),
  totalPrice: z195.number().int().nullish(),
  totalTax: z195.number().int().nullish(),
  updatedAt: z195.string(),
  userId: z195.string(),
  vat: z195.number().int().nullish()
});

// src/generated-definitions/OrderPagingResult.ts
import { z as z196 } from "zod";
var OrderPagingResult = z196.object({ data: z196.array(OrderInfo), paging: Paging.nullish(), total: z196.number().int().nullish() });

// src/generated-definitions/OrderPagingSlicedResult.ts
import { z as z197 } from "zod";
var OrderPagingSlicedResult = z197.object({ data: z197.array(OrderInfo), paging: Paging.nullish() });

// src/generated-definitions/OrderStatistics.ts
import { z as z198 } from "zod";
var OrderStatistics = z198.object({ statusCount: z198.record(z198.number().int()), total: z198.number().int() });

// src/generated-definitions/PurchasedItemCount.ts
import { z as z199 } from "zod";
var PurchasedItemCount = z199.object({ count: z199.number().int().nullish() });

// src/generated-admin/endpoints/OrderAdmin$.ts
import { Validate as Validate18 } from "@accelbyte/sdk";
import { z as z200 } from "zod";
var OrderAdmin$ = class {
  // @ts-ignore
  // prettier-ignore
  constructor(axiosInstance, namespace, useSchemaValidation = true) {
    this.axiosInstance = axiosInstance;
    this.namespace = namespace;
    this.useSchemaValidation = useSchemaValidation;
  }
  /**
   * Query orders.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: query orders&lt;/li&gt;&lt;/ul&gt;
   */
  getOrders(queryParams) {
    const params = { limit: 20, sortBy: "createdTime:desc", ...queryParams };
    const url = "/platform/admin/namespaces/{namespace}/orders".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.get(url, { params });
    return Validate18.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, OrderPagingResult, "OrderPagingResult");
  }
  /**
   * Get Order Statistics.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: order statistics&lt;/li&gt;&lt;/ul&gt;
   */
  getOrdersStats() {
    const params = {};
    const url = "/platform/admin/namespaces/{namespace}/orders/stats".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.get(url, { params });
    return Validate18.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, OrderStatistics, "OrderStatistics");
  }
  /**
   * Get order by orderNo.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: order instance&lt;/li&gt;&lt;/ul&gt;
   */
  getOrder_ByOrderNo(orderNo) {
    const params = {};
    const url = "/platform/admin/namespaces/{namespace}/orders/{orderNo}".replace("{namespace}", this.namespace).replace("{orderNo}", orderNo);
    const resultPromise = this.axiosInstance.get(url, { params });
    return Validate18.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, OrderInfo, "OrderInfo");
  }
  /**
   * Query user orders.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: get order&lt;/li&gt;&lt;/ul&gt;
   */
  getOrders_ByUserId(userId, queryParams) {
    const params = { limit: 20, ...queryParams };
    const url = "/platform/admin/namespaces/{namespace}/users/{userId}/orders".replace("{namespace}", this.namespace).replace("{userId}", userId);
    const resultPromise = this.axiosInstance.get(url, { params });
    return Validate18.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      OrderPagingSlicedResult,
      "OrderPagingSlicedResult"
    );
  }
  /**
   * Admin Create an order. The result contains the checkout link and payment token. User with permission SANDBOX will create sandbox order that not real paid for xsolla/alipay and not validate price for wxpay.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;It will be forbidden while the user is banned: ORDER_INITIATE or ORDER_AND_PAYMENT&lt;/li&gt;&lt;li&gt;sandbox default value is &lt;b&gt;false&lt;/b&gt;&lt;/li&gt;&lt;li&gt;platform default value is &lt;b&gt;Other&lt;/b&gt;&lt;/li&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: created order&lt;/li&gt;&lt;/ul&gt;&lt;h2&gt;Restrictions for ext field&lt;/h2&gt; 1. Cannot use &lt;b&gt;&#34;.&#34;&lt;/b&gt; as the key name - &lt;pre&gt;{ &#34;data.2&#34;: &#34;value&#34; }&lt;/pre&gt; 2. Cannot use &lt;b&gt;&#34;$&#34;&lt;/b&gt; as the prefix in key names - &lt;pre&gt;{ &#34;$data&#34;: &#34;value&#34; }&lt;/pre&gt;
   */
  createOrder_ByUserId(userId, data) {
    const params = {};
    const url = "/platform/admin/namespaces/{namespace}/users/{userId}/orders".replace("{namespace}", this.namespace).replace("{userId}", userId);
    const resultPromise = this.axiosInstance.post(url, data, { params });
    return Validate18.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, OrderInfo, "OrderInfo");
  }
  /**
   * Refund order by orderNo.
   */
  updateRefund_ByOrderNo(orderNo, data) {
    const params = {};
    const url = "/platform/admin/namespaces/{namespace}/orders/{orderNo}/refund".replace("{namespace}", this.namespace).replace("{orderNo}", orderNo);
    const resultPromise = this.axiosInstance.put(url, data, { params });
    return Validate18.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, OrderInfo, "OrderInfo");
  }
  /**
   * Get an order.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: get order&lt;/li&gt;&lt;/ul&gt;
   */
  getOrder_ByUserId_ByOrderNo(userId, orderNo) {
    const params = {};
    const url = "/platform/admin/namespaces/{namespace}/users/{userId}/orders/{orderNo}".replace("{namespace}", this.namespace).replace("{userId}", userId).replace("{orderNo}", orderNo);
    const resultPromise = this.axiosInstance.get(url, { params });
    return Validate18.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, OrderInfo, "OrderInfo");
  }
  /**
   * Update order status.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: updated order&lt;/li&gt;&lt;/ul&gt;
   */
  updateOrder_ByUserId_ByOrderNo(userId, orderNo, data) {
    const params = {};
    const url = "/platform/admin/namespaces/{namespace}/users/{userId}/orders/{orderNo}".replace("{namespace}", this.namespace).replace("{userId}", userId).replace("{orderNo}", orderNo);
    const resultPromise = this.axiosInstance.put(url, data, { params });
    return Validate18.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, OrderInfo, "OrderInfo");
  }
  /**
   * This API is used to get the count of purchased item which is the order target.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: Item purchased count&lt;/li&gt;&lt;/ul&gt;
   */
  getOrdersCountOfItem_ByUserId(userId, queryParams) {
    const params = { ...queryParams };
    const url = "/platform/admin/namespaces/{namespace}/users/{userId}/orders/countOfItem".replace("{namespace}", this.namespace).replace("{userId}", userId);
    const resultPromise = this.axiosInstance.get(url, { params });
    return Validate18.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, PurchasedItemCount, "PurchasedItemCount");
  }
  /**
   * @deprecated
   * Get user order grant that fulfilled by this order.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: get order grant&lt;/li&gt;&lt;/ul&gt;
   */
  getGrant_ByUserId_ByOrderNo(userId, orderNo) {
    const params = {};
    const url = "/platform/admin/namespaces/{namespace}/users/{userId}/orders/{orderNo}/grant".replace("{namespace}", this.namespace).replace("{userId}", userId).replace("{orderNo}", orderNo);
    const resultPromise = this.axiosInstance.get(url, { params });
    return Validate18.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, OrderGrantInfo, "OrderGrantInfo");
  }
  /**
   * Fulfill an order if the order is charged but fulfill failed.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: fulfilled order&lt;/li&gt;&lt;/ul&gt;
   */
  updateFulfill_ByUserId_ByOrderNo(userId, orderNo) {
    const params = {};
    const url = "/platform/admin/namespaces/{namespace}/users/{userId}/orders/{orderNo}/fulfill".replace("{namespace}", this.namespace).replace("{userId}", userId).replace("{orderNo}", orderNo);
    const resultPromise = this.axiosInstance.put(url, null, { params });
    return Validate18.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, OrderInfo, "OrderInfo");
  }
  /**
   * Get user order history.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: get order history&lt;/li&gt;&lt;/ul&gt;
   */
  getHistory_ByUserId_ByOrderNo(userId, orderNo) {
    const params = {};
    const url = "/platform/admin/namespaces/{namespace}/users/{userId}/orders/{orderNo}/history".replace("{namespace}", this.namespace).replace("{userId}", userId).replace("{orderNo}", orderNo);
    const resultPromise = this.axiosInstance.get(url, { params });
    return Validate18.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, OrderHistoryInfoArray, "OrderHistoryInfoArray");
  }
  /**
   * Download user order receipt by orderNo.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: order receipt pdf&lt;/li&gt;&lt;/ul&gt;
   */
  getReceiptPdf_ByUserId_ByOrderNo(userId, orderNo) {
    const params = {};
    const url = "/platform/admin/namespaces/{namespace}/users/{userId}/orders/{orderNo}/receipt.pdf".replace("{namespace}", this.namespace).replace("{userId}", userId).replace("{orderNo}", orderNo);
    const resultPromise = this.axiosInstance.get(url, { params });
    return Validate18.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, z200.unknown(), "z.unknown()");
  }
  /**
   * &lt;b&gt;[SERVICE COMMUNICATION ONLY]&lt;/b&gt; This API is used as a web hook for payment notification from justice payment service.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: Process result&lt;/li&gt;&lt;/ul&gt;
   */
  createNotification_ByUserId_ByOrderNo(userId, orderNo, data) {
    const params = {};
    const url = "/platform/admin/namespaces/{namespace}/users/{userId}/orders/{orderNo}/notifications".replace("{namespace}", this.namespace).replace("{userId}", userId).replace("{orderNo}", orderNo);
    const resultPromise = this.axiosInstance.post(url, data, { params });
    return Validate18.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, z200.unknown(), "z.unknown()");
  }
};

// src/generated-definitions/PaymentData.ts
import { z as z201 } from "zod";
var PaymentData = z201.object({
  discountAmount: z201.number().int().nullish(),
  discountCode: z201.string().nullish(),
  subtotalPrice: z201.number().int().nullish(),
  tax: z201.number().int().nullish(),
  totalPrice: z201.number().int().nullish()
});

// src/generated-definitions/Order.ts
import { z as z202 } from "zod";
var Order = z202.object({
  chargebackReversedTime: z202.string().nullish(),
  chargebackTime: z202.string().nullish(),
  charged: z202.boolean().nullish(),
  chargedTime: z202.string().nullish(),
  countItemId: z202.string().nullish(),
  countNamespace: z202.string().nullish(),
  countUserId: z202.string().nullish(),
  createdAt: z202.string().nullish(),
  createdTime: z202.string().nullish(),
  creationOptions: OrderCreationOptions.nullish(),
  currency: CurrencySummary.nullish(),
  deduction: z202.number().int().nullish(),
  deductionDetails: z202.array(DeductionDetail).nullish(),
  discountedPrice: z202.number().int().nullish(),
  expireTime: z202.string().nullish(),
  ext: z202.record(z202.any()).nullish(),
  finalPrice: z202.number().int().nullish(),
  free: z202.boolean().nullish(),
  fulfilledTime: z202.string().nullish(),
  itemId: z202.string().nullish(),
  itemSnapshot: ItemSnapshot.nullish(),
  language: z202.string().nullish(),
  namespace: z202.string().nullish(),
  orderBundleItemInfos: z202.array(OrderBundleItemInfo).nullish(),
  orderNo: z202.string().nullish(),
  paymentData: PaymentData.nullish(),
  paymentMethod: z202.string().nullish(),
  paymentMethodFee: z202.number().int().nullish(),
  paymentOrderNo: z202.string().nullish(),
  paymentProvider: z202.enum(["ADYEN", "ALIPAY", "CHECKOUT", "NEONPAY", "PAYPAL", "STRIPE", "WALLET", "WXPAY", "XSOLLA"]).nullish(),
  paymentProviderFee: z202.number().int().nullish(),
  paymentRemainSeconds: z202.number().int().nullish(),
  paymentStationUrl: z202.string().nullish(),
  price: z202.number().int().nullish(),
  quantity: z202.number().int().nullish(),
  refundedTime: z202.string().nullish(),
  region: z202.string().nullish(),
  returnUrl: z202.string().nullish(),
  rvn: z202.number().int().nullish(),
  salesTax: z202.number().int().nullish(),
  sandbox: z202.boolean().nullish(),
  status: z202.enum([
    "CHARGEBACK",
    "CHARGEBACK_REVERSED",
    "CHARGED",
    "CLOSED",
    "DELETED",
    "FULFILLED",
    "FULFILL_FAILED",
    "INIT",
    "REFUNDED",
    "REFUNDING",
    "REFUND_FAILED"
  ]).nullish(),
  statusReason: z202.string().nullish(),
  subtotalPrice: z202.number().int().nullish(),
  tax: z202.number().int().nullish(),
  totalPrice: z202.number().int().nullish(),
  totalTax: z202.number().int().nullish(),
  updatedAt: z202.string().nullish(),
  userId: z202.string().nullish(),
  vat: z202.number().int().nullish()
});

// src/generated-definitions/OrderSyncResult.ts
import { z as z203 } from "zod";
var OrderSyncResult = z203.object({ nextEvaluatedKey: z203.string().nullish(), orders: z203.array(Order).nullish() });

// src/generated-admin/endpoints/OrderDedicatedAdmin$.ts
import { Validate as Validate19 } from "@accelbyte/sdk";
var OrderDedicatedAdmin$ = class {
  // @ts-ignore
  // prettier-ignore
  constructor(axiosInstance, namespace, useSchemaValidation = true) {
    this.axiosInstance = axiosInstance;
    this.namespace = namespace;
    this.useSchemaValidation = useSchemaValidation;
  }
  /**
   * &lt;b&gt;[Not supported yet in AGS Shared Cloud]&lt;/b&gt;Sync orders. If response contains nextEvaluatedKey, please use it as query param in the next call to fetch the next batch, a batch has 1000 elements or less.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: sync orders&lt;/li&gt;&lt;/ul&gt;
   */
  getOrders(queryParams) {
    const params = { ...queryParams };
    const url = "/platform/admin/orders";
    const resultPromise = this.axiosInstance.get(url, { params });
    return Validate19.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, OrderSyncResult, "OrderSyncResult");
  }
};

// src/generated-definitions/NotificationProcessResult.ts
import { z as z204 } from "zod";
var NotificationProcessResult = z204.object({
  code: z204.string().nullish(),
  customParam: z204.record(z204.any()).nullish(),
  severity: z204.number().int().nullish(),
  status: z204.enum(["ERROR", "IGNORED", "PROCESSED", "WARN"]).nullish()
});

// src/generated-definitions/PaymentNotificationInfo.ts
import { z as z205 } from "zod";
var PaymentNotificationInfo = z205.object({
  createdAt: z205.string(),
  externalId: z205.string().nullish(),
  id: z205.string(),
  namespace: z205.string(),
  notification: z205.record(z205.any()),
  notificationSource: z205.enum(["ADYEN", "ALIPAY", "CHECKOUT", "NEONPAY", "PAYPAL", "STRIPE", "WALLET", "WXPAY", "XSOLLA"]),
  notificationType: z205.string(),
  paymentOrderNo: z205.string(),
  status: z205.enum(["ERROR", "IGNORED", "PROCESSED", "WARN"]),
  statusReason: z205.string().nullish(),
  updatedAt: z205.string()
});

// src/generated-definitions/PaymentNotificationPagingSlicedResult.ts
import { z as z206 } from "zod";
var PaymentNotificationPagingSlicedResult = z206.object({ data: z206.array(PaymentNotificationInfo), paging: Paging.nullish() });

// src/generated-definitions/PaymentOrderChargeStatus.ts
import { z as z207 } from "zod";
var PaymentOrderChargeStatus = z207.object({
  charging: z207.boolean().nullish(),
  status: z207.enum([
    "AUTHORISED",
    "AUTHORISE_FAILED",
    "CHARGEBACK",
    "CHARGEBACK_REVERSED",
    "CHARGED",
    "CHARGE_FAILED",
    "DELETED",
    "INIT",
    "NOTIFICATION_OF_CHARGEBACK",
    "REFUNDED",
    "REFUNDING",
    "REFUND_FAILED",
    "REQUEST_FOR_INFORMATION"
  ]).nullish()
});

// src/generated-definitions/AdditionalData.ts
import { z as z208 } from "zod";
var AdditionalData = z208.object({ cardSummary: z208.string().nullish() });

// src/generated-definitions/Transaction.ts
import { z as z209 } from "zod";
var Transaction = z209.object({
  additionalData: AdditionalData.nullish(),
  amount: z209.number().int().nullish(),
  currency: CurrencySummary.nullish(),
  extMessage: z209.string().nullish(),
  extStatusCode: z209.string().nullish(),
  extTxId: z209.string().nullish(),
  merchantId: z209.string().nullish(),
  notified: z209.boolean().nullish(),
  paymentData: PaymentData.nullish(),
  paymentMethod: z209.string().nullish(),
  paymentMethodFee: z209.number().int().nullish(),
  paymentProviderFee: z209.number().int().nullish(),
  provider: z209.enum(["ADYEN", "ALIPAY", "CHECKOUT", "NEONPAY", "PAYPAL", "STRIPE", "WALLET", "WXPAY", "XSOLLA"]).nullish(),
  salesTax: z209.number().int().nullish(),
  status: z209.enum(["FAILED", "FINISHED"]).nullish(),
  tax: z209.number().int().nullish(),
  txEndTime: z209.string().nullish(),
  txId: z209.string().nullish(),
  type: z209.enum([
    "AUTHORISATION",
    "CHARGE",
    "CHARGEBACK",
    "CHARGEBACK_REVERSED",
    "CHARGE_FAILED",
    "NOTIFICATION_OF_CHARGEBACK",
    "REFUND",
    "REFUND_FAILED",
    "REQUEST_FOR_INFORMATION"
  ]).nullish(),
  vat: z209.number().int().nullish()
});

// src/generated-definitions/PaymentOrderInfo.ts
import { z as z210 } from "zod";
var PaymentOrderInfo = z210.object({
  authorisedTime: z210.string().nullish(),
  channel: z210.enum(["EXTERNAL", "INTERNAL"]),
  chargebackReversedTime: z210.string().nullish(),
  chargebackTime: z210.string().nullish(),
  chargedTime: z210.string().nullish(),
  charging: z210.boolean().nullish(),
  createdAt: z210.string(),
  createdTime: z210.string().nullish(),
  currency: CurrencySummary,
  customParameters: z210.record(z210.any()).nullish(),
  description: z210.string().nullish(),
  extOrderNo: z210.string(),
  extUserId: z210.string().nullish(),
  itemType: z210.enum(["APP", "BUNDLE", "CODE", "COINS", "EXTENSION", "INGAMEITEM", "LOOTBOX", "MEDIA", "OPTIONBOX", "SEASON", "SUBSCRIPTION"]).nullish(),
  language: z210.string().nullish(),
  metadata: z210.record(z210.string()).nullish(),
  namespace: z210.string(),
  notifyUrl: z210.string().nullish(),
  omitNotification: z210.boolean().nullish(),
  paymentMethod: z210.string().nullish(),
  paymentMethodFee: z210.number().int().nullish(),
  paymentOrderNo: z210.string(),
  paymentProvider: z210.enum(["ADYEN", "ALIPAY", "CHECKOUT", "NEONPAY", "PAYPAL", "STRIPE", "WALLET", "WXPAY", "XSOLLA"]).nullish(),
  paymentProviderFee: z210.number().int().nullish(),
  paymentStationUrl: z210.string().nullish(),
  price: z210.number().int(),
  recurringPaymentOrderNo: z210.string().nullish(),
  refundedTime: z210.string().nullish(),
  region: z210.string().nullish(),
  returnUrl: z210.string().nullish(),
  salesTax: z210.number().int().nullish(),
  sandbox: z210.boolean(),
  sku: z210.string().nullish(),
  status: z210.enum([
    "AUTHORISED",
    "AUTHORISE_FAILED",
    "CHARGEBACK",
    "CHARGEBACK_REVERSED",
    "CHARGED",
    "CHARGE_FAILED",
    "DELETED",
    "INIT",
    "NOTIFICATION_OF_CHARGEBACK",
    "REFUNDED",
    "REFUNDING",
    "REFUND_FAILED",
    "REQUEST_FOR_INFORMATION"
  ]),
  statusReason: z210.string().nullish(),
  subscriptionId: z210.string().nullish(),
  subtotalPrice: z210.number().int().nullish(),
  targetNamespace: z210.string().nullish(),
  targetUserId: z210.string().nullish(),
  tax: z210.number().int().nullish(),
  title: z210.string(),
  totalPrice: z210.number().int().nullish(),
  totalTax: z210.number().int().nullish(),
  transactions: z210.array(Transaction).nullish(),
  updatedAt: z210.string(),
  userId: z210.string(),
  vat: z210.number().int().nullish()
});

// src/generated-definitions/PaymentOrderPagingSlicedResult.ts
import { z as z211 } from "zod";
var PaymentOrderPagingSlicedResult = z211.object({ data: z211.array(PaymentOrderInfo), paging: Paging.nullish() });

// src/generated-admin/endpoints/PaymentAdmin$.ts
import { Validate as Validate20 } from "@accelbyte/sdk";
import { z as z212 } from "zod";
var PaymentAdmin$ = class {
  // @ts-ignore
  // prettier-ignore
  constructor(axiosInstance, namespace, useSchemaValidation = true) {
    this.axiosInstance = axiosInstance;
    this.namespace = namespace;
    this.useSchemaValidation = useSchemaValidation;
  }
  /**
   * &lt;b&gt;[Not supported yet in AGS Shared Cloud]&lt;/b&gt;Query payment orders.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: query payment orders&lt;/li&gt;&lt;/ul&gt;
   */
  getPaymentOrders(queryParams) {
    const params = { limit: 20, ...queryParams };
    const url = "/platform/admin/namespaces/{namespace}/payment/orders".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.get(url, { params });
    return Validate20.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      PaymentOrderPagingSlicedResult,
      "PaymentOrderPagingSlicedResult"
    );
  }
  /**
   * &lt;b&gt;[Not supported yet in AGS Shared Cloud]&lt;/b&gt;Query payment notifications.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: Payment notifications&lt;/li&gt;&lt;/ul&gt;
   */
  getPaymentNotifications(queryParams) {
    const params = { limit: 20, ...queryParams };
    const url = "/platform/admin/namespaces/{namespace}/payment/notifications".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.get(url, { params });
    return Validate20.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      PaymentNotificationPagingSlicedResult,
      "PaymentNotificationPagingSlicedResult"
    );
  }
  /**
   * &lt;b&gt;[Not supported yet in AGS Shared Cloud]&lt;/b&gt;List external order No by external transaction id.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: payment orders&lt;/li&gt;&lt;/ul&gt;
   */
  getPaymentOrdersByExtTxId(queryParams) {
    const params = { ...queryParams };
    const url = "/platform/admin/namespaces/{namespace}/payment/orders/byExtTxId".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.get(url, { params });
    return Validate20.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, z212.unknown(), "z.unknown()");
  }
  /**
   * &lt;b&gt;[Not supported yet in AGS Shared Cloud]&lt;/b&gt;&lt;b&gt;[SERVICE COMMUNICATION ONLY]&lt;/b&gt; This API is used to create payment order from justice service. The result contains the payment station url.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;It will be forbidden while the user is banned: PAYMENT_INITIATE or ORDER_AND_PAYMENT&lt;/li&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: created order&lt;/li&gt;&lt;/ul&gt;&lt;h2&gt;Restrictions for custom parameters and meta data&lt;/h2&gt; 1. Cannot use &lt;b&gt;&#34;.&#34;&lt;/b&gt; as the key name - &lt;pre&gt;{ &#34;data.2&#34;: &#34;value&#34; }&lt;/pre&gt; 2. Cannot use &lt;b&gt;&#34;$&#34;&lt;/b&gt; as the prefix in key names - &lt;pre&gt;{ &#34;$data&#34;: &#34;value&#34; }&lt;/pre&gt;
   */
  createPaymentOrder_ByUserId(userId, data) {
    const params = {};
    const url = "/platform/admin/namespaces/{namespace}/users/{userId}/payment/orders".replace("{namespace}", this.namespace).replace("{userId}", userId);
    const resultPromise = this.axiosInstance.post(url, data, { params });
    return Validate20.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, PaymentOrderInfo, "PaymentOrderInfo");
  }
  /**
   * &lt;b&gt;[Not supported yet in AGS Shared Cloud]&lt;/b&gt;Get payment order by paymentOrderNo.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: payment order instance&lt;/li&gt;&lt;/ul&gt;
   */
  getPaymentOrder_ByPaymentOrderNo(paymentOrderNo) {
    const params = {};
    const url = "/platform/admin/namespaces/{namespace}/payment/orders/{paymentOrderNo}".replace("{namespace}", this.namespace).replace("{paymentOrderNo}", paymentOrderNo);
    const resultPromise = this.axiosInstance.get(url, { params });
    return Validate20.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, PaymentOrderInfo, "PaymentOrderInfo");
  }
  /**
   * &lt;b&gt;[Not supported yet in AGS Shared Cloud]&lt;/b&gt;&lt;b&gt;[TEST FACILITY ONLY] Forbidden in live environment. &lt;/b&gt; Charge payment order without payment flow for unpaid payment order, usually for test usage to simulate real currency payment process.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: payment order instance&lt;/li&gt;&lt;/ul&gt;
   */
  updatePaymentOrder_ByPaymentOrderNo(paymentOrderNo, data) {
    const params = {};
    const url = "/platform/admin/namespaces/{namespace}/payment/orders/{paymentOrderNo}".replace("{namespace}", this.namespace).replace("{paymentOrderNo}", paymentOrderNo);
    const resultPromise = this.axiosInstance.put(url, data, { params });
    return Validate20.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, PaymentOrderInfo, "PaymentOrderInfo");
  }
  /**
   * &lt;b&gt;[Not supported yet in AGS Shared Cloud]&lt;/b&gt;Get payment order charge status.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: payment order charge status&lt;/li&gt;&lt;/ul&gt;
   */
  getStatusPayment_ByPaymentOrderNo(paymentOrderNo) {
    const params = {};
    const url = "/platform/admin/namespaces/{namespace}/payment/orders/{paymentOrderNo}/status".replace("{namespace}", this.namespace).replace("{paymentOrderNo}", paymentOrderNo);
    const resultPromise = this.axiosInstance.get(url, { params });
    return Validate20.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      PaymentOrderChargeStatus,
      "PaymentOrderChargeStatus"
    );
  }
  /**
   * &lt;b&gt;[Not supported yet in AGS Shared Cloud]&lt;/b&gt;&lt;b&gt;[TEST FACILITY ONLY] Forbidden in live environment. &lt;/b&gt; Simulate payment notification on sandbox payment order, usually for test usage to simulate real currency payment notification.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: notification process result&lt;/li&gt;&lt;/ul&gt;
   */
  updateSimulateNotificationPayment_ByPaymentOrderNo(paymentOrderNo, data) {
    const params = {};
    const url = "/platform/admin/namespaces/{namespace}/payment/orders/{paymentOrderNo}/simulate-notification".replace("{namespace}", this.namespace).replace("{paymentOrderNo}", paymentOrderNo);
    const resultPromise = this.axiosInstance.put(url, data, { params });
    return Validate20.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      NotificationProcessResult,
      "NotificationProcessResult"
    );
  }
  /**
   * &lt;b&gt;[Not supported yet in AGS Shared Cloud]&lt;/b&gt;&lt;b&gt;[SERVICE COMMUNICATION ONLY]&lt;/b&gt; This API is used to refund order by paymentOrderNo from justice service.
   */
  updateRefundPayment_ByUserId_ByPaymentOrderNo(userId, paymentOrderNo, data) {
    const params = {};
    const url = "/platform/admin/namespaces/{namespace}/users/{userId}/payment/orders/{paymentOrderNo}/refund".replace("{namespace}", this.namespace).replace("{userId}", userId).replace("{paymentOrderNo}", paymentOrderNo);
    const resultPromise = this.axiosInstance.put(url, data, { params });
    return Validate20.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, PaymentOrderInfo, "PaymentOrderInfo");
  }
};

// src/generated-definitions/PaymentCallbackConfigInfo.ts
import { z as z213 } from "zod";
var PaymentCallbackConfigInfo = z213.object({
  dryRun: z213.boolean().nullish(),
  namespace: z213.string(),
  notifyUrl: z213.string().nullish(),
  privateKey: z213.string().nullish()
});

// src/generated-admin/endpoints/PaymentCallbackConfigAdmin$.ts
import { Validate as Validate21 } from "@accelbyte/sdk";
var PaymentCallbackConfigAdmin$ = class {
  // @ts-ignore
  // prettier-ignore
  constructor(axiosInstance, namespace, useSchemaValidation = true) {
    this.axiosInstance = axiosInstance;
    this.namespace = namespace;
    this.useSchemaValidation = useSchemaValidation;
  }
  /**
   * &lt;b&gt;[Not supported yet in AGS Shared Cloud]&lt;/b&gt;Get payment callback configuration.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: Payment callback config&lt;/li&gt;&lt;/ul&gt;
   */
  getPaymentConfigCallback() {
    const params = {};
    const url = "/platform/admin/namespaces/{namespace}/payment/config/callback".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.get(url, { params });
    return Validate21.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      PaymentCallbackConfigInfo,
      "PaymentCallbackConfigInfo"
    );
  }
  /**
   * &lt;b&gt;[Not supported yet in AGS Shared Cloud]&lt;/b&gt;Update payment callback configuration.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: Payment callback config&lt;/li&gt;&lt;/ul&gt;
   */
  updatePaymentConfigCallback(data) {
    const params = {};
    const url = "/platform/admin/namespaces/{namespace}/payment/config/callback".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.put(url, data, { params });
    return Validate21.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      PaymentCallbackConfigInfo,
      "PaymentCallbackConfigInfo"
    );
  }
};

// src/generated-definitions/PaymentDomainWhitelistConfigInfo.ts
import { z as z214 } from "zod";
var PaymentDomainWhitelistConfigInfo = z214.object({ domains: z214.array(z214.string()), namespace: z214.string() });

// src/generated-definitions/AdyenConfig.ts
import { z as z215 } from "zod";
var AdyenConfig = z215.object({
  allowedPaymentMethods: z215.array(z215.string()).nullish(),
  apiKey: z215.string().nullish(),
  authoriseAsCapture: z215.boolean().nullish(),
  blockedPaymentMethods: z215.array(z215.string()).nullish(),
  clientKey: z215.string().nullish(),
  dropInSettings: z215.string().nullish(),
  liveEndpointUrlPrefix: z215.string().nullish(),
  merchantAccount: z215.string().nullish(),
  notificationHmacKey: z215.string().nullish(),
  notificationPassword: z215.string().nullish(),
  notificationUsername: z215.string().nullish(),
  returnUrl: z215.string().nullish(),
  settings: z215.string().nullish()
});

// src/generated-definitions/AliPayConfig.ts
import { z as z216 } from "zod";
var AliPayConfig = z216.object({
  appId: z216.string().nullish(),
  privateKey: z216.string().nullish(),
  publicKey: z216.string().nullish(),
  returnUrl: z216.string().nullish()
});

// src/generated-definitions/CheckoutConfig.ts
import { z as z217 } from "zod";
var CheckoutConfig = z217.object({ publicKey: z217.string().nullish(), secretKey: z217.string().nullish() });

// src/generated-definitions/NeonPayConfig.ts
import { z as z218 } from "zod";
var NeonPayConfig = z218.object({ apiKey: z218.string().nullish(), webhookSecretKey: z218.string().nullish() });

// src/generated-definitions/PayPalConfig.ts
import { z as z219 } from "zod";
var PayPalConfig = z219.object({
  clientID: z219.string().nullish(),
  clientSecret: z219.string().nullish(),
  returnUrl: z219.string().nullish(),
  webHookId: z219.string().nullish()
});

// src/generated-definitions/StripeConfig.ts
import { z as z220 } from "zod";
var StripeConfig = z220.object({
  allowedPaymentMethodTypes: z220.array(z220.string()).nullish(),
  publishableKey: z220.string().nullish(),
  secretKey: z220.string().nullish(),
  webhookSecret: z220.string().nullish()
});

// src/generated-definitions/WxPayConfigInfo.ts
import { z as z221 } from "zod";
var WxPayConfigInfo = z221.object({
  appId: z221.string().nullish(),
  certPath: z221.string().nullish(),
  key: z221.string().nullish(),
  mchid: z221.string().nullish(),
  returnUrl: z221.string().nullish()
});

// src/generated-definitions/XsollaConfig.ts
import { z as z222 } from "zod";
var XsollaConfig = z222.object({
  apiKey: z222.string().nullish(),
  flowCompletionUrl: z222.string().nullish(),
  merchantId: z222.number().int().nullish(),
  projectId: z222.number().int().nullish(),
  projectSecretKey: z222.string().nullish()
});

// src/generated-definitions/XsollaPaywallConfig.ts
import { z as z223 } from "zod";
var XsollaPaywallConfig = z223.object({
  device: z223.enum(["DESKTOP", "MOBILE"]),
  showCloseButton: z223.boolean(),
  size: z223.enum(["LARGE", "MEDIUM", "SMALL"]),
  theme: z223.enum(["DARK", "DEFAULT", "DEFAULT_DARK"])
});

// src/generated-definitions/PaymentMerchantConfigInfo.ts
import { z as z224 } from "zod";
var PaymentMerchantConfigInfo = z224.object({
  adyenConfig: AdyenConfig.nullish(),
  adyenSandboxConfig: AdyenConfig.nullish(),
  aliPayConfig: AliPayConfig.nullish(),
  aliPaySandboxConfig: AliPayConfig.nullish(),
  checkoutConfig: CheckoutConfig.nullish(),
  checkoutSandboxConfig: CheckoutConfig.nullish(),
  createdAt: z224.string(),
  id: z224.string(),
  neonPayConfig: NeonPayConfig.nullish(),
  neonPaySandboxConfig: NeonPayConfig.nullish(),
  payPalConfig: PayPalConfig.nullish(),
  payPalSandboxConfig: PayPalConfig.nullish(),
  stripeConfig: StripeConfig.nullish(),
  stripeSandboxConfig: StripeConfig.nullish(),
  updatedAt: z224.string(),
  wxPayConfig: WxPayConfigInfo.nullish(),
  xsollaConfig: XsollaConfig.nullish(),
  xsollaPaywallConfig: XsollaPaywallConfig.nullish()
});

// src/generated-definitions/PaymentProviderConfigInfo.ts
import { z as z225 } from "zod";
var PaymentProviderConfigInfo = z225.object({
  aggregate: z225.enum(["ADYEN", "CHECKOUT", "NEONPAY", "STRIPE", "XSOLLA"]).nullish(),
  id: z225.string(),
  namespace: z225.string(),
  paymentMerchantConfigId: z225.string().nullish(),
  region: z225.string(),
  sandboxTaxJarApiToken: z225.string().nullish(),
  specials: z225.array(z225.enum(["ADYEN", "ALIPAY", "CHECKOUT", "NEONPAY", "PAYPAL", "STRIPE", "WALLET", "WXPAY", "XSOLLA"])).nullish(),
  taxJarApiToken: z225.string().nullish(),
  taxJarEnabled: z225.boolean().nullish(),
  useGlobalTaxJarApiToken: z225.boolean().nullish()
});

// src/generated-definitions/PaymentProviderConfigPagingSlicedResult.ts
import { z as z226 } from "zod";
var PaymentProviderConfigPagingSlicedResult = z226.object({ data: z226.array(PaymentProviderConfigInfo), paging: Paging.nullish() });

// src/generated-definitions/PaymentTaxConfigInfo.ts
import { z as z227 } from "zod";
var PaymentTaxConfigInfo = z227.object({
  sandboxTaxJarApiToken: z227.string().nullish(),
  taxJarApiToken: z227.string().nullish(),
  taxJarEnabled: z227.boolean().nullish(),
  taxJarProductCodesMapping: z227.record(z227.string()).nullish()
});

// src/generated-admin/endpoints/PaymentConfigAdmin$.ts
import { Validate as Validate22 } from "@accelbyte/sdk";
import { z as z228 } from "zod";
var PaymentConfigAdmin$ = class {
  // @ts-ignore
  // prettier-ignore
  constructor(axiosInstance, namespace, useSchemaValidation = true) {
    this.axiosInstance = axiosInstance;
    this.namespace = namespace;
    this.useSchemaValidation = useSchemaValidation;
  }
  /**
   * &lt;b&gt;[Not supported yet in AGS Shared Cloud]&lt;/b&gt;Get payment global tax config.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: payment provider list&lt;/li&gt;&lt;/ul&gt;
   */
  getPaymentConfigTax() {
    const params = {};
    const url = "/platform/admin/payment/config/tax";
    const resultPromise = this.axiosInstance.get(url, { params });
    return Validate22.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, PaymentTaxConfigInfo, "PaymentTaxConfigInfo");
  }
  /**
   * &lt;b&gt;[Not supported yet in AGS Shared Cloud]&lt;/b&gt;Update payment tax config.&lt;br&gt;&lt;pre&gt;&lt;p&gt;&lt;strong&gt;Request Body Parameters:&lt;/strong&gt;&lt;/p&gt;&lt;pre&gt;&lt;table&gt;&lt;tr&gt;&lt;td&gt;Parameter&lt;/td&gt;&lt;td&gt;Type&lt;/td&gt;&lt;td&gt;Required&lt;/td&gt;&lt;td&gt;Description&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;taxJarEnabled&lt;/td&gt;&lt;td&gt;Boolean&lt;/td&gt;&lt;td&gt;false&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;taxJarApiToken&lt;/td&gt;&lt;td&gt;String&lt;/td&gt;&lt;td&gt;false&lt;/td&gt;&lt;td&gt;required, when taxJarEnabled is true and there is no existing token&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;sandboxTaxJarApiToken&lt;/td&gt;&lt;td&gt;String&lt;/td&gt;&lt;td&gt;false&lt;/td&gt;&lt;td&gt;optional&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;taxJarProductCodesMapping&lt;/td&gt;&lt;td&gt;Map&lt;/td&gt;&lt;td&gt;No&lt;/td&gt;&lt;td&gt;key is item type(APP|COINS|INGAMEITEM|BUNDLE|CODE|SUBSCRIPTION) and value is product tax code: https://developers.taxjar.com/api/reference/?ruby#get-list-tax-categories&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/pre&gt;&lt;/ol&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: payment global tax config&lt;/li&gt;&lt;/ul&gt;
   */
  updatePaymentConfigTax(data) {
    const params = {};
    const url = "/platform/admin/payment/config/tax";
    const resultPromise = this.axiosInstance.put(url, data, { params });
    return Validate22.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, PaymentTaxConfigInfo, "PaymentTaxConfigInfo");
  }
  /**
   * &lt;b&gt;[Not supported yet in AGS Shared Cloud]&lt;/b&gt;Query payment provider config.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: payment provider config list&lt;/li&gt;&lt;/ul&gt;
   */
  getPaymentConfigProvider(queryParams) {
    const params = { limit: 20, ...queryParams };
    const url = "/platform/admin/payment/config/provider";
    const resultPromise = this.axiosInstance.get(url, { params });
    return Validate22.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      PaymentProviderConfigPagingSlicedResult,
      "PaymentProviderConfigPagingSlicedResult"
    );
  }
  /**
   * &lt;b&gt;[Not supported yet in AGS Shared Cloud]&lt;/b&gt;Create payment provider config.&lt;br&gt;&lt;pre&gt;&lt;p&gt;&lt;strong&gt;Request Body Parameters:&lt;/strong&gt;&lt;/p&gt;&lt;pre&gt;&lt;table&gt;&lt;tr&gt;&lt;td&gt;Parameter&lt;/td&gt;&lt;td&gt;Type&lt;/td&gt;&lt;td&gt;Required&lt;/td&gt;&lt;td&gt;Description&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;namespace&lt;/td&gt;&lt;td&gt;String&lt;/td&gt;&lt;td&gt;Yes&lt;/td&gt;&lt;td&gt;namespace, * indicates all namespace&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;region&lt;/td&gt;&lt;td&gt;String&lt;/td&gt;&lt;td&gt;Yes&lt;/td&gt;&lt;td&gt;region, * indicates all regions&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;aggregate&lt;/td&gt;&lt;td&gt;String&lt;/td&gt;&lt;td&gt;No&lt;/td&gt;&lt;td&gt;aggregate payment provider, such as XSOLLA, ADYEN, STRIPE&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;specials&lt;/td&gt;&lt;td&gt;List&lt;/td&gt;&lt;td&gt;No&lt;/td&gt;&lt;td&gt;special payment provider, such as ALIPAY, WXPAY&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/pre&gt;payment provider applied has priority: &lt;ol&gt;&lt;li&gt;namespace and region match&lt;/li&gt;&lt;li&gt;namespace matches and region is *&lt;/li&gt;&lt;li&gt;region matches and namespace is *&lt;/li&gt;&lt;li&gt;namespace and region are *&lt;/li&gt;&lt;/ol&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: payment provider config&lt;/li&gt;&lt;/ul&gt;
   */
  createPaymentConfigProvider(data) {
    const params = {};
    const url = "/platform/admin/payment/config/provider";
    const resultPromise = this.axiosInstance.post(url, data, { params });
    return Validate22.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      PaymentProviderConfigInfo,
      "PaymentProviderConfigInfo"
    );
  }
  /**
   * &lt;b&gt;[Not supported yet in AGS Shared Cloud]&lt;/b&gt;Get payment merchant config by id.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: payment merchant config info&lt;/li&gt;&lt;/ul&gt;
   */
  getPaymentConfigMerchant_ById(id) {
    const params = {};
    const url = "/platform/admin/payment/config/merchant/{id}".replace("{id}", id);
    const resultPromise = this.axiosInstance.get(url, { params });
    return Validate22.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      PaymentMerchantConfigInfo,
      "PaymentMerchantConfigInfo"
    );
  }
  /**
   * &lt;b&gt;[Not supported yet in AGS Shared Cloud]&lt;/b&gt;Delete payment provider config.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: payment provider config&lt;/li&gt;&lt;/ul&gt;
   */
  deletePaymentConfigProvider_ById(id) {
    const params = {};
    const url = "/platform/admin/payment/config/provider/{id}".replace("{id}", id);
    const resultPromise = this.axiosInstance.delete(url, { params });
    return Validate22.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, z228.unknown(), "z.unknown()");
  }
  /**
   * &lt;b&gt;[Not supported yet in AGS Shared Cloud]&lt;/b&gt;Update payment provider config.&lt;br&gt;&lt;pre&gt;&lt;p&gt;&lt;strong&gt;Request Body Parameters:&lt;/strong&gt;&lt;/p&gt;&lt;pre&gt;&lt;table&gt;&lt;tr&gt;&lt;td&gt;Parameter&lt;/td&gt;&lt;td&gt;Type&lt;/td&gt;&lt;td&gt;Required&lt;/td&gt;&lt;td&gt;Description&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;namespace&lt;/td&gt;&lt;td&gt;String&lt;/td&gt;&lt;td&gt;Yes&lt;/td&gt;&lt;td&gt;namespace, * indicates all namespace&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;region&lt;/td&gt;&lt;td&gt;String&lt;/td&gt;&lt;td&gt;Yes&lt;/td&gt;&lt;td&gt;region, * indicates all regions&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;aggregate&lt;/td&gt;&lt;td&gt;String&lt;/td&gt;&lt;td&gt;No&lt;/td&gt;&lt;td&gt;aggregate payment provider, such as XSOLLA, ADYEN, STRIPE&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;specials&lt;/td&gt;&lt;td&gt;List&lt;/td&gt;&lt;td&gt;No&lt;/td&gt;&lt;td&gt;special payment provider, such as ALIPAY, WXPAY&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/pre&gt;payment provider applied has priority: &lt;ol&gt;&lt;li&gt;namespace and region match&lt;/li&gt;&lt;li&gt;namespace matches and region is *&lt;/li&gt;&lt;li&gt;region matches and namespace is *&lt;/li&gt;&lt;li&gt;namespace and region are *&lt;/li&gt;&lt;/ol&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: payment provider config&lt;/li&gt;&lt;/ul&gt;
   */
  updatePaymentConfigProvider_ById(id, data) {
    const params = {};
    const url = "/platform/admin/payment/config/provider/{id}".replace("{id}", id);
    const resultPromise = this.axiosInstance.put(url, data, { params });
    return Validate22.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      PaymentProviderConfigInfo,
      "PaymentProviderConfigInfo"
    );
  }
  /**
   * &lt;b&gt;[Not supported yet in AGS Shared Cloud]&lt;/b&gt;Debug matched payment merchant config.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: payment merchant config info&lt;/li&gt;&lt;/ul&gt;
   */
  getPaymentConfigMerchantMatched(queryParams) {
    const params = { namespace: "*", region: "*", ...queryParams };
    const url = "/platform/admin/payment/config/merchant/matched";
    const resultPromise = this.axiosInstance.get(url, { params });
    return Validate22.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      PaymentMerchantConfigInfo,
      "PaymentMerchantConfigInfo"
    );
  }
  /**
   * &lt;b&gt;[Not supported yet in AGS Shared Cloud]&lt;/b&gt;Debug matched payment provider config.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: payment provider config&lt;/li&gt;&lt;/ul&gt;
   */
  getPaymentConfigProviderMatched(queryParams) {
    const params = { namespace: "*", region: "*", ...queryParams };
    const url = "/platform/admin/payment/config/provider/matched";
    const resultPromise = this.axiosInstance.get(url, { params });
    return Validate22.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      PaymentProviderConfigInfo,
      "PaymentProviderConfigInfo"
    );
  }
  /**
   * &lt;b&gt;[Not supported yet in AGS Shared Cloud]&lt;/b&gt;Get special payment providers, such as ALIPAY, WXPAY.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: payment provider list&lt;/li&gt;&lt;/ul&gt;
   */
  getPaymentConfigProviderSpecial() {
    const params = {};
    const url = "/platform/admin/payment/config/provider/special";
    const resultPromise = this.axiosInstance.get(url, { params });
    return Validate22.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, z228.unknown(), "z.unknown()");
  }
  /**
   * &lt;b&gt;[Not supported yet in AGS Shared Cloud]&lt;/b&gt;Get aggregate payment providers, such as XSOLLA, ADYEN.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: payment provider list&lt;/li&gt;&lt;/ul&gt;
   */
  getPaymentConfigProviderAggregate() {
    const params = {};
    const url = "/platform/admin/payment/config/provider/aggregate";
    const resultPromise = this.axiosInstance.get(url, { params });
    return Validate22.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, z228.unknown(), "z.unknown()");
  }
  /**
   * &lt;b&gt;[Not supported yet in AGS Shared Cloud]&lt;/b&gt;Update adyen config.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: updated payment merchant config&lt;/li&gt;&lt;/ul&gt;
   */
  updateAdyenconfigPayment_ById(id, data, queryParams) {
    const params = { sandbox: true, ...queryParams };
    const url = "/platform/admin/payment/config/merchant/{id}/adyenconfig".replace("{id}", id);
    const resultPromise = this.axiosInstance.put(url, data, { params });
    return Validate22.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      PaymentMerchantConfigInfo,
      "PaymentMerchantConfigInfo"
    );
  }
  /**
   * &lt;b&gt;[Not supported yet in AGS Shared Cloud]&lt;/b&gt;Update wxpay configuration.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: updated payment merchant config&lt;/li&gt;&lt;/ul&gt;
   */
  updateWxpayconfigPayment_ById(id, data, queryParams) {
    const params = { ...queryParams };
    const url = "/platform/admin/payment/config/merchant/{id}/wxpayconfig".replace("{id}", id);
    const resultPromise = this.axiosInstance.put(url, data, { params });
    return Validate22.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      PaymentMerchantConfigInfo,
      "PaymentMerchantConfigInfo"
    );
  }
  /**
   * &lt;b&gt;[Not supported yet in AGS Shared Cloud]&lt;/b&gt;Test adyen configuration. &lt;h4&gt;Check List:&lt;/h4&gt; &lt;ul&gt;&lt;li&gt;apiKey&lt;/li&gt;&lt;li&gt;merchantAccount&lt;/li&gt;&lt;/ul&gt;&lt;h4&gt;Non-check list:&lt;/h4&gt;&lt;ul&gt;&lt;li&gt;notificationHmacKey&lt;/li&gt;&lt;li&gt;notificationUsername&lt;/li&gt;&lt;li&gt;notificationPassword&lt;/li&gt;&lt;li&gt;liveEndpointUrlPrefix&lt;/li&gt;&lt;li&gt;allowedPaymentMethods&lt;/li&gt;&lt;li&gt;blockedPaymentMethods&lt;/li&gt;&lt;li&gt;settings&lt;/li&gt;&lt;/ul&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: test adyen config&lt;/li&gt;&lt;/ul&gt;
   */
  createPaymentConfigMerchantAdyenconfigTest(data, queryParams) {
    const params = { sandbox: true, ...queryParams };
    const url = "/platform/admin/payment/config/merchant/adyenconfig/test";
    const resultPromise = this.axiosInstance.post(url, data, { params });
    return Validate22.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, TestResult, "TestResult");
  }
  /**
   * &lt;b&gt;[Not supported yet in AGS Shared Cloud]&lt;/b&gt;Test WxPay configuration. Reference: &lt;a href=&#34;https://pay.weixin.qq.com/wiki/doc/api/native.php?chapter=9_1&#34;&gt;WxPay Document&lt;/a&gt;.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: test WxPay config&lt;/li&gt;&lt;/ul&gt;
   */
  createPaymentConfigMerchantWxpayconfigTest(data) {
    const params = {};
    const url = "/platform/admin/payment/config/merchant/wxpayconfig/test";
    const resultPromise = this.axiosInstance.post(url, data, { params });
    return Validate22.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, TestResult, "TestResult");
  }
  /**
   * &lt;b&gt;[Not supported yet in AGS Shared Cloud]&lt;/b&gt;Update alipay configuration.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: updated payment merchant config&lt;/li&gt;&lt;/ul&gt;
   */
  updateAlipayconfigPayment_ById(id, data, queryParams) {
    const params = { sandbox: true, ...queryParams };
    const url = "/platform/admin/payment/config/merchant/{id}/alipayconfig".replace("{id}", id);
    const resultPromise = this.axiosInstance.put(url, data, { params });
    return Validate22.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      PaymentMerchantConfigInfo,
      "PaymentMerchantConfigInfo"
    );
  }
  /**
   * &lt;b&gt;[Not supported yet in AGS Shared Cloud]&lt;/b&gt;Update PayPal config.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: updated payment merchant config&lt;/li&gt;&lt;/ul&gt;
   */
  updatePaypalconfigPayment_ById(id, data, queryParams) {
    const params = { sandbox: true, ...queryParams };
    const url = "/platform/admin/payment/config/merchant/{id}/paypalconfig".replace("{id}", id);
    const resultPromise = this.axiosInstance.put(url, data, { params });
    return Validate22.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      PaymentMerchantConfigInfo,
      "PaymentMerchantConfigInfo"
    );
  }
  /**
   * &lt;b&gt;[Not supported yet in AGS Shared Cloud]&lt;/b&gt;Update stripe config.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: updated payment merchant config&lt;/li&gt;&lt;/ul&gt;
   */
  updateStripeconfigPayment_ById(id, data, queryParams) {
    const params = { sandbox: true, ...queryParams };
    const url = "/platform/admin/payment/config/merchant/{id}/stripeconfig".replace("{id}", id);
    const resultPromise = this.axiosInstance.put(url, data, { params });
    return Validate22.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      PaymentMerchantConfigInfo,
      "PaymentMerchantConfigInfo"
    );
  }
  /**
   * &lt;b&gt;[Not supported yet in AGS Shared Cloud]&lt;/b&gt;Update xsolla configuration. Reference: &lt;a href=&#34;https://developers.xsolla.com/?#simple-checkout&#34;&gt;Xsolla Document&lt;/a&gt;.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: updated payment merchant config&lt;/li&gt;&lt;/ul&gt;
   */
  updateXsollaconfigPayment_ById(id, data, queryParams) {
    const params = { ...queryParams };
    const url = "/platform/admin/payment/config/merchant/{id}/xsollaconfig".replace("{id}", id);
    const resultPromise = this.axiosInstance.put(url, data, { params });
    return Validate22.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      PaymentMerchantConfigInfo,
      "PaymentMerchantConfigInfo"
    );
  }
  /**
   * &lt;b&gt;[Not supported yet in AGS Shared Cloud]&lt;/b&gt;Test AliPay configuration.Reference: &lt;a href=&#34;https://docs.open.alipay.com/270/alipay.trade.page.pay&#34;&gt;Alipay Document&lt;/a&gt;.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: test result&lt;/li&gt;&lt;/ul&gt;
   */
  createPaymentConfigMerchantAlipayconfigTest(data, queryParams) {
    const params = { sandbox: true, ...queryParams };
    const url = "/platform/admin/payment/config/merchant/alipayconfig/test";
    const resultPromise = this.axiosInstance.post(url, data, { params });
    return Validate22.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, TestResult, "TestResult");
  }
  /**
   * &lt;b&gt;[Not supported yet in AGS Shared Cloud]&lt;/b&gt;Test PayPal configuration. &lt;h4&gt;Check List:&lt;/h4&gt; &lt;ul&gt;&lt;li&gt;clientID&lt;/li&gt;&lt;li&gt;clientSecret&lt;/li&gt;&lt;/ul&gt;&lt;h4&gt;Non-check list:&lt;/h4&gt;&lt;ul&gt;&lt;li&gt;webHookId&lt;/li&gt;&lt;/ul&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: test result&lt;/li&gt;&lt;/ul&gt;
   */
  createPaymentConfigMerchantPaypalconfigTest(data, queryParams) {
    const params = { sandbox: true, ...queryParams };
    const url = "/platform/admin/payment/config/merchant/paypalconfig/test";
    const resultPromise = this.axiosInstance.post(url, data, { params });
    return Validate22.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, TestResult, "TestResult");
  }
  /**
   * &lt;b&gt;[Not supported yet in AGS Shared Cloud]&lt;/b&gt;Test stripe configuration. &lt;h4&gt;Check List:&lt;/h4&gt; &lt;ul&gt;&lt;li&gt;secretKey&lt;/li&gt;&lt;li&gt;allowedPaymentMethodTypes&lt;/li&gt;&lt;/ul&gt;&lt;h4&gt;Non-check list:&lt;/h4&gt;&lt;ul&gt;&lt;li&gt;publishableKey&lt;/li&gt;&lt;li&gt;webhookSecret&lt;/li&gt;&lt;/ul&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: test adyen config&lt;/li&gt;&lt;/ul&gt;
   */
  createPaymentConfigMerchantStripeconfigTest(data, queryParams) {
    const params = { sandbox: true, ...queryParams };
    const url = "/platform/admin/payment/config/merchant/stripeconfig/test";
    const resultPromise = this.axiosInstance.post(url, data, { params });
    return Validate22.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, TestResult, "TestResult");
  }
  /**
   * &lt;b&gt;[Not supported yet in AGS Shared Cloud]&lt;/b&gt;Check xsolla configuration, Reference: &lt;a href=&#34;https://developers.xsolla.com/?#simple-checkout&#34;&gt;Xsolla Document&lt;/a&gt;.&lt;h4&gt;Check List:&lt;/h4&gt; &lt;ul&gt;&lt;li&gt;merchantId&lt;/li&gt;&lt;li&gt;projectId&lt;/li&gt;&lt;li&gt;apiKey&lt;/li&gt;&lt;/ul&gt;&lt;h4&gt;Non-check list:&lt;/h4&gt;&lt;ul&gt;&lt;li&gt;projectSecretKey&lt;/li&gt;&lt;/ul&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: test result&lt;/li&gt;&lt;/ul&gt;
   */
  createPaymentConfigMerchantXsollaconfigTest(data) {
    const params = {};
    const url = "/platform/admin/payment/config/merchant/xsollaconfig/test";
    const resultPromise = this.axiosInstance.post(url, data, { params });
    return Validate22.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, TestResult, "TestResult");
  }
  /**
   * &lt;b&gt;[Not supported yet in AGS Shared Cloud]&lt;/b&gt;Update Neon Pay config.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: updated payment merchant config&lt;/li&gt;&lt;/ul&gt;
   */
  updateNeonpayconfigPayment_ById(id, data, queryParams) {
    const params = { sandbox: true, ...queryParams };
    const url = "/platform/admin/payment/config/merchant/{id}/neonpayconfig".replace("{id}", id);
    const resultPromise = this.axiosInstance.put(url, data, { params });
    return Validate22.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      PaymentMerchantConfigInfo,
      "PaymentMerchantConfigInfo"
    );
  }
  /**
   * &lt;b&gt;[Not supported yet in AGS Shared Cloud]&lt;/b&gt;Check Neon Pay configuration, Reference: &lt;a href=&#34;https://docs.neonpay.com/docs/checkout&#34;&gt;Neon Pay Document&lt;/a&gt;.&lt;h4&gt;Check List:&lt;/h4&gt; &lt;ul&gt;&lt;li&gt;apiKey&lt;/li&gt;&lt;li&gt;webhookSecretKey&lt;/li&gt;&lt;/ul&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: test result&lt;/li&gt;&lt;/ul&gt;
   */
  createPaymentConfigMerchantNeonpayconfigTest(data, queryParams) {
    const params = { sandbox: true, ...queryParams };
    const url = "/platform/admin/payment/config/merchant/neonpayconfig/test";
    const resultPromise = this.axiosInstance.post(url, data, { params });
    return Validate22.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, TestResult, "TestResult");
  }
  /**
   * &lt;b&gt;[Not supported yet in AGS Shared Cloud]&lt;/b&gt;Update checkout.com config.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: updated payment merchant config&lt;/li&gt;&lt;/ul&gt;
   */
  updateCheckoutconfigPayment_ById(id, data, queryParams) {
    const params = { sandbox: true, ...queryParams };
    const url = "/platform/admin/payment/config/merchant/{id}/checkoutconfig".replace("{id}", id);
    const resultPromise = this.axiosInstance.put(url, data, { params });
    return Validate22.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      PaymentMerchantConfigInfo,
      "PaymentMerchantConfigInfo"
    );
  }
  /**
   * &lt;b&gt;[Not supported yet in AGS Shared Cloud]&lt;/b&gt;Update xsolla UI configuration.Reference: &lt;a href=&#34;https://developers.xsolla.com/api.html#ui-integrations&#34;&gt;Xsolla Document&lt;/a&gt;.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: updated payment merchant config&lt;/li&gt;&lt;/ul&gt;
   */
  updateXsollauiconfigPayment_ById(id, data) {
    const params = {};
    const url = "/platform/admin/payment/config/merchant/{id}/xsollauiconfig".replace("{id}", id);
    const resultPromise = this.axiosInstance.put(url, data, { params });
    return Validate22.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      PaymentMerchantConfigInfo,
      "PaymentMerchantConfigInfo"
    );
  }
  /**
   * &lt;b&gt;[Not supported yet in AGS Shared Cloud]&lt;/b&gt;Test checkout.com configuration. &lt;h4&gt;Check List:&lt;/h4&gt; &lt;ul&gt;&lt;li&gt;publicKey&lt;/li&gt;&lt;li&gt;secretKey&lt;/li&gt;&lt;/ul&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: test result&lt;/li&gt;&lt;/ul&gt;
   */
  createPaymentConfigMerchantCheckoutconfigTest(data, queryParams) {
    const params = { sandbox: true, ...queryParams };
    const url = "/platform/admin/payment/config/merchant/checkoutconfig/test";
    const resultPromise = this.axiosInstance.post(url, data, { params });
    return Validate22.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, TestResult, "TestResult");
  }
  /**
   * &lt;b&gt;[Not supported yet in AGS Shared Cloud]&lt;/b&gt;Get payment domain whitelist config by namespace.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: payment domain whitelist config info&lt;/li&gt;&lt;/ul&gt;
   */
  getPaymentConfigDomains() {
    const params = {};
    const url = "/platform/admin/namespaces/{namespace}/payment/config/domains".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.get(url, { params });
    return Validate22.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      PaymentDomainWhitelistConfigInfo,
      "PaymentDomainWhitelistConfigInfo"
    );
  }
  /**
   * &lt;b&gt;[Not supported yet in AGS Shared Cloud]&lt;/b&gt;Update payment provider config by namespace.&lt;br&gt;&lt;pre&gt;&lt;p&gt;&lt;strong&gt;Request Body Parameters:&lt;/strong&gt;&lt;/p&gt;&lt;pre&gt;&lt;table&gt;&lt;tr&gt;&lt;td&gt;Parameter&lt;/td&gt;&lt;td&gt;Type&lt;/td&gt;&lt;td&gt;Required&lt;/td&gt;&lt;td&gt;Description&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;domains&lt;/td&gt;&lt;td&gt;String&lt;/td&gt;&lt;td&gt;Yes&lt;/td&gt;&lt;td&gt;list of domains to whitelist for the return URL.&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/pre&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Validation&lt;/i&gt;: the domain should include the protocol (http/https), but the whitelist check will only compare the host part (www.example.com)&lt;/li&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: payment domain whitelist config&lt;/li&gt;&lt;/ul&gt;
   */
  updatePaymentConfigDomain(data) {
    const params = {};
    const url = "/platform/admin/namespaces/{namespace}/payment/config/domains".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.put(url, data, { params });
    return Validate22.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      PaymentDomainWhitelistConfigInfo,
      "PaymentDomainWhitelistConfigInfo"
    );
  }
  /**
   * &lt;b&gt;[Not supported yet in AGS Shared Cloud]&lt;/b&gt;Test adyen configuration in payment merchant config. Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: test adyen config&lt;/li&gt;&lt;/ul&gt;
   */
  getAdyenconfigTestPayment_ById(id, queryParams) {
    const params = { sandbox: true, ...queryParams };
    const url = "/platform/admin/payment/config/merchant/{id}/adyenconfig/test".replace("{id}", id);
    const resultPromise = this.axiosInstance.get(url, { params });
    return Validate22.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, TestResult, "TestResult");
  }
  /**
   * &lt;b&gt;[Not supported yet in AGS Shared Cloud]&lt;/b&gt;Upload wxpay cert file.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: updated payment merchant config&lt;/li&gt;&lt;/ul&gt;
   */
  updateWxpayconfigCertPayment_ById(id, data) {
    const params = {};
    const url = "/platform/admin/payment/config/merchant/{id}/wxpayconfig/cert".replace("{id}", id);
    const resultPromise = this.axiosInstance.put(url, data, { params });
    return Validate22.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      PaymentMerchantConfigInfo,
      "PaymentMerchantConfigInfo"
    );
  }
  /**
   * &lt;b&gt;[Not supported yet in AGS Shared Cloud]&lt;/b&gt;Test WxPay configuration in payment merchant config. Reference: &lt;a href=&#34;https://pay.weixin.qq.com/wiki/doc/api/native.php?chapter=9_1&#34;&gt;WxPay Document&lt;/a&gt;.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: test WxPay config&lt;/li&gt;&lt;/ul&gt;
   */
  getWxpayconfigTestPayment_ById(id) {
    const params = {};
    const url = "/platform/admin/payment/config/merchant/{id}/wxpayconfig/test".replace("{id}", id);
    const resultPromise = this.axiosInstance.get(url, { params });
    return Validate22.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, TestResult, "TestResult");
  }
  /**
   * &lt;b&gt;[Not supported yet in AGS Shared Cloud]&lt;/b&gt;Test AliPay configuration in payment merchant config. Reference: &lt;a href=&#34;https://docs.open.alipay.com/270/alipay.trade.page.pay&#34;&gt;Alipay Document&lt;/a&gt;.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: test alipay config&lt;/li&gt;&lt;/ul&gt;
   */
  getAlipayconfigTestPayment_ById(id, queryParams) {
    const params = { sandbox: true, ...queryParams };
    const url = "/platform/admin/payment/config/merchant/{id}/alipayconfig/test".replace("{id}", id);
    const resultPromise = this.axiosInstance.get(url, { params });
    return Validate22.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, TestResult, "TestResult");
  }
  /**
   * &lt;b&gt;[Not supported yet in AGS Shared Cloud]&lt;/b&gt;Test PayPal configuration in payment merchant config. Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: test result&lt;/li&gt;&lt;/ul&gt;
   */
  getPaypalconfigTestPayment_ById(id, queryParams) {
    const params = { sandbox: true, ...queryParams };
    const url = "/platform/admin/payment/config/merchant/{id}/paypalconfig/test".replace("{id}", id);
    const resultPromise = this.axiosInstance.get(url, { params });
    return Validate22.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, TestResult, "TestResult");
  }
  /**
   * &lt;b&gt;[Not supported yet in AGS Shared Cloud]&lt;/b&gt;Test stripe configuration in payment merchant config. Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: test adyen config&lt;/li&gt;&lt;/ul&gt;
   */
  getStripeconfigTestPayment_ById(id, queryParams) {
    const params = { sandbox: true, ...queryParams };
    const url = "/platform/admin/payment/config/merchant/{id}/stripeconfig/test".replace("{id}", id);
    const resultPromise = this.axiosInstance.get(url, { params });
    return Validate22.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, TestResult, "TestResult");
  }
  /**
   * &lt;b&gt;[Not supported yet in AGS Shared Cloud]&lt;/b&gt;Test xsolla configuration in payment merchant config. Reference: &lt;a href=&#34;https://developers.xsolla.com/?#simple-checkout&#34;&gt;Xsolla Document&lt;/a&gt;.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: test xsolla config&lt;/li&gt;&lt;/ul&gt;
   */
  getXsollaconfigTestPayment_ById(id) {
    const params = {};
    const url = "/platform/admin/payment/config/merchant/{id}/xsollaconfig/test".replace("{id}", id);
    const resultPromise = this.axiosInstance.get(url, { params });
    return Validate22.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, TestResult, "TestResult");
  }
  /**
   * &lt;b&gt;[Not supported yet in AGS Shared Cloud]&lt;/b&gt;Test Neon Pay configuration in payment merchant config. Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: test result&lt;/li&gt;&lt;/ul&gt;
   */
  getNeonpayconfigTestPayment_ById(id, queryParams) {
    const params = { sandbox: true, ...queryParams };
    const url = "/platform/admin/payment/config/merchant/{id}/neonpayconfig/test".replace("{id}", id);
    const resultPromise = this.axiosInstance.get(url, { params });
    return Validate22.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, TestResult, "TestResult");
  }
  /**
   * &lt;b&gt;[Not supported yet in AGS Shared Cloud]&lt;/b&gt;Test checkout.com configuration in payment merchant config. Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: test result&lt;/li&gt;&lt;/ul&gt;
   */
  getCheckoutconfigTestPayment_ById(id, queryParams) {
    const params = { sandbox: true, ...queryParams };
    const url = "/platform/admin/payment/config/merchant/{id}/checkoutconfig/test".replace("{id}", id);
    const resultPromise = this.axiosInstance.get(url, { params });
    return Validate22.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, TestResult, "TestResult");
  }
};

// src/generated-definitions/PaymentOrderCreateResult.ts
import { z as z229 } from "zod";
var PaymentOrderCreateResult = z229.object({
  createdTime: z229.string(),
  namespace: z229.string(),
  paymentOrderNo: z229.string(),
  paymentStationUrl: z229.string().nullish(),
  status: z229.enum([
    "AUTHORISED",
    "AUTHORISE_FAILED",
    "CHARGEBACK",
    "CHARGEBACK_REVERSED",
    "CHARGED",
    "CHARGE_FAILED",
    "DELETED",
    "INIT",
    "NOTIFICATION_OF_CHARGEBACK",
    "REFUNDED",
    "REFUNDING",
    "REFUND_FAILED",
    "REQUEST_FOR_INFORMATION"
  ]),
  targetNamespace: z229.string().nullish(),
  targetUserId: z229.string().nullish()
});

// src/generated-definitions/PaymentOrderRefundResult.ts
import { z as z230 } from "zod";
var PaymentOrderRefundResult = z230.object({
  createdTime: z230.string(),
  namespace: z230.string(),
  paymentOrderNo: z230.string(),
  refundedTime: z230.string().nullish(),
  status: z230.enum([
    "AUTHORISED",
    "AUTHORISE_FAILED",
    "CHARGEBACK",
    "CHARGEBACK_REVERSED",
    "CHARGED",
    "CHARGE_FAILED",
    "DELETED",
    "INIT",
    "NOTIFICATION_OF_CHARGEBACK",
    "REFUNDED",
    "REFUNDING",
    "REFUND_FAILED",
    "REQUEST_FOR_INFORMATION"
  ]),
  targetNamespace: z230.string().nullish(),
  targetUserId: z230.string().nullish()
});

// src/generated-definitions/PaymentOrderNeonPayConfig.ts
import { z as z231 } from "zod";
var PaymentOrderNeonPayConfig = z231.object({ cancelUrl: z231.string(), successUrl: z231.string() });

// src/generated-definitions/PaymentOrder.ts
import { z as z232 } from "zod";
var PaymentOrder = z232.object({
  authorisedTime: z232.string().nullish(),
  channel: z232.enum(["EXTERNAL", "INTERNAL"]).nullish(),
  chargebackReversedTime: z232.string().nullish(),
  chargebackTime: z232.string().nullish(),
  chargedTime: z232.string().nullish(),
  charging: z232.boolean().nullish(),
  checkoutUrl: z232.string().nullish(),
  checkoutUrlExpiredAt: z232.string().nullish(),
  checkoutUrlValid: z232.boolean().nullish(),
  createdAt: z232.string().nullish(),
  createdTime: z232.string().nullish(),
  currency: CurrencySummary.nullish(),
  customParameters: z232.record(z232.any()).nullish(),
  description: z232.string().nullish(),
  extOrderNo: z232.string().nullish(),
  extUserId: z232.string().nullish(),
  itemType: z232.enum(["APP", "BUNDLE", "CODE", "COINS", "EXTENSION", "INGAMEITEM", "LOOTBOX", "MEDIA", "OPTIONBOX", "SEASON", "SUBSCRIPTION"]).nullish(),
  language: z232.string().nullish(),
  metadata: z232.record(z232.string()).nullish(),
  namespace: z232.string().nullish(),
  neonPayConfig: PaymentOrderNeonPayConfig.nullish(),
  notifyUrl: z232.string().nullish(),
  omitNotification: z232.boolean().nullish(),
  paymentData: PaymentData.nullish(),
  paymentMethod: z232.string().nullish(),
  paymentMethodFee: z232.number().int().nullish(),
  paymentOrderNo: z232.string().nullish(),
  paymentProvider: z232.enum(["ADYEN", "ALIPAY", "CHECKOUT", "NEONPAY", "PAYPAL", "STRIPE", "WALLET", "WXPAY", "XSOLLA"]).nullish(),
  paymentProviderFee: z232.number().int().nullish(),
  paymentStationUrl: z232.string().nullish(),
  platform: z232.string().nullish(),
  price: z232.number().int().nullish(),
  recurringPaymentOrderNo: z232.string().nullish(),
  refundedTime: z232.string().nullish(),
  region: z232.string().nullish(),
  returnUrl: z232.string().nullish(),
  rvn: z232.number().int().nullish(),
  salesTax: z232.number().int().nullish(),
  sandbox: z232.boolean().nullish(),
  sku: z232.string().nullish(),
  state: z232.string().nullish(),
  status: z232.enum([
    "AUTHORISED",
    "AUTHORISE_FAILED",
    "CHARGEBACK",
    "CHARGEBACK_REVERSED",
    "CHARGED",
    "CHARGE_FAILED",
    "DELETED",
    "INIT",
    "NOTIFICATION_OF_CHARGEBACK",
    "REFUNDED",
    "REFUNDING",
    "REFUND_FAILED",
    "REQUEST_FOR_INFORMATION"
  ]).nullish(),
  statusReason: z232.string().nullish(),
  subscriptionId: z232.string().nullish(),
  subtotalPrice: z232.number().int().nullish(),
  targetNamespace: z232.string().nullish(),
  targetUserId: z232.string().nullish(),
  tax: z232.number().int().nullish(),
  title: z232.string().nullish(),
  totalPrice: z232.number().int().nullish(),
  totalTax: z232.number().int().nullish(),
  transactions: z232.array(Transaction).nullish(),
  updatedAt: z232.string().nullish(),
  userId: z232.string().nullish(),
  vat: z232.number().int().nullish(),
  zipCode: z232.string().nullish()
});

// src/generated-definitions/PaymentOrderSyncResult.ts
import { z as z233 } from "zod";
var PaymentOrderSyncResult = z233.object({ nextEvaluatedKey: z233.string().nullish(), paymentOrders: z233.array(PaymentOrder).nullish() });

// src/generated-admin/endpoints/PaymentDedicatedAdmin$.ts
import { Validate as Validate23 } from "@accelbyte/sdk";
var PaymentDedicatedAdmin$ = class {
  // @ts-ignore
  // prettier-ignore
  constructor(axiosInstance, namespace, useSchemaValidation = true) {
    this.axiosInstance = axiosInstance;
    this.namespace = namespace;
    this.useSchemaValidation = useSchemaValidation;
  }
  /**
   * &lt;b&gt;[Not supported yet in AGS Shared Cloud]&lt;/b&gt;Sync payment orders. If response contains nextEvaluatedKey, please use it as query param in the next call to fetch the next batch, a batch has 1000 elements or less.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: sync payment orders&lt;/li&gt;&lt;/ul&gt;
   */
  getPaymentOrders(queryParams) {
    const params = { ...queryParams };
    const url = "/platform/admin/payment/orders";
    const resultPromise = this.axiosInstance.get(url, { params });
    return Validate23.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      PaymentOrderSyncResult,
      "PaymentOrderSyncResult"
    );
  }
  /**
   * &lt;b&gt;[Not supported yet in AGS Shared Cloud]&lt;/b&gt;&lt;p&gt;This API is used to create payment order from non justice service. e.g. from dedicated server, the result contains the payment station url.&lt;/p&gt;&lt;p&gt;&lt;strong&gt;Path Parameter:&lt;/strong&gt;&lt;/p&gt;&lt;pre&gt;&lt;table&gt;&lt;tr&gt;&lt;td&gt;Parameter&lt;/td&gt;&lt;td&gt;Type&lt;/td&gt;&lt;td&gt;Required&lt;/td&gt;&lt;td&gt;Description&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;namespace&lt;/td&gt;&lt;td&gt;String&lt;/td&gt;&lt;td&gt;Yes&lt;/td&gt;&lt;td&gt;Namespace that payment order resides in, should be publisher namespace if it&#39;s a Steam like platform that share &lt;br&gt;payment config cross namespaces, otherwise it&#39;s the game namespace&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;p&gt;&lt;strong&gt;Request Body Parameters:&lt;/strong&gt;&lt;/p&gt;&lt;pre&gt;&lt;table&gt;&lt;tr&gt;&lt;td&gt;Parameter&lt;/td&gt;&lt;td&gt;Type&lt;/td&gt;&lt;td&gt;Required&lt;/td&gt;&lt;td&gt;Description&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;extOrderNo&lt;/td&gt;&lt;td&gt;String&lt;/td&gt;&lt;td&gt;Yes&lt;/td&gt;&lt;td&gt;External order number, it should be unique in invoker order system&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;sku&lt;/td&gt;&lt;td&gt;String&lt;/td&gt;&lt;td&gt;No&lt;/td&gt;&lt;td&gt;Item identity&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;targetNamespace&lt;/td&gt;&lt;td&gt;String&lt;/td&gt;&lt;td&gt;Yes&lt;/td&gt;&lt;td&gt;The game namespace&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;targetUserId&lt;/td&gt;&lt;td&gt;String&lt;/td&gt;&lt;td&gt;Yes&lt;/td&gt;&lt;td&gt;User id for the order owner in game namespace&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;extUserId&lt;/td&gt;&lt;td&gt;String&lt;/td&gt;&lt;td&gt;No&lt;/td&gt;&lt;td&gt;External user id, can be user character id &lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;price&lt;/td&gt;&lt;td&gt;int&lt;/td&gt;&lt;td&gt;Yes&lt;/td&gt;&lt;td&gt;price which should be greater than 0&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;title&lt;/td&gt;&lt;td&gt;String&lt;/td&gt;&lt;td&gt;Yes&lt;/td&gt;&lt;td&gt;Item title&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;description&lt;/td&gt;&lt;td&gt;String&lt;/td&gt;&lt;td&gt;Yes&lt;/td&gt;&lt;td&gt;Item description&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;currencyCode&lt;/td&gt;&lt;td&gt;String&lt;/td&gt;&lt;td&gt;No&lt;/td&gt;&lt;td&gt;Currency code, default is USD&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;currencyNamespace&lt;/td&gt;&lt;td&gt;String&lt;/td&gt;&lt;td&gt;No&lt;/td&gt;&lt;td&gt;Currency namespace, default is publisher namespace&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;region&lt;/td&gt;&lt;td&gt;String&lt;/td&gt;&lt;td&gt;No&lt;/td&gt;&lt;td&gt;Country of the user, will get from user info if not present&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;language&lt;/td&gt;&lt;td&gt;String&lt;/td&gt;&lt;td&gt;No&lt;/td&gt;&lt;td&gt;Language of the user&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;sandbox&lt;/td&gt;&lt;td&gt;Boolean&lt;/td&gt;&lt;td&gt;No&lt;/td&gt;&lt;td&gt;set to true will create sandbox order that not real paid for xsolla/alipay and will not validate &lt;br&gt;price for wxpay.&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;returnUrl&lt;/td&gt;&lt;td&gt;String&lt;/td&gt;&lt;td&gt;No&lt;/td&gt;&lt;td&gt;customized return url for redirect once payment finished, leave unset to use configuration in &lt;br&gt;namespace&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;notifyUrl&lt;/td&gt;&lt;td&gt;String&lt;/td&gt;&lt;td&gt;No&lt;/td&gt;&lt;td&gt;customized notify url for payment web hook, leave unset to use configuration in namespace&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;customParameters&lt;/td&gt;&lt;td&gt;String&lt;/td&gt;&lt;td&gt;No&lt;/td&gt;&lt;td&gt;Custom parameters&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;Request Body Example:&lt;/strong&gt;&lt;/p&gt;&lt;pre&gt;&lt;code style=&#39;overflow: auto&#39;&gt;{ &#34;extOrderNo&#34;: &#34;123456789&#34;, &#34;sku&#34;: &#34;sku&#34;, &#34;targetNamespace&#34;: &#34;game1&#34;, &#34;targetUserId&#34;: &#34;94451623768940d58416ca33ca767ec3&#34;, &#34;extUserId&#34;: &#34;678&#34;, &#34;title&#34;: &#34;Frostmourne&#34;, &#34;description\&#34;: &#34;Here was power. Here was despair&#34;, &#34;price&#34;: 100, &#34;region&#34;: &#34;CN&#34;, &#34;language&#34;: &#34;zh-CN&#34;, &#34;currencyCode&#34;: &#34;USD&#34;, &#34;currencyNamespace&#34;: &#34;accelbyte&#34; }&lt;/pre&gt;&lt;/code&gt;&lt;h4&gt;Payment Notification:&lt;/h4&gt;&lt;p&gt;After user complete the payment, it will send notification to configured web hook, http status code should return 200 or 204 once you resolve notification successfully, otherwise payment system will retry notification in interval&lt;/p&gt;&lt;p&gt;&lt;strong&gt;Payment notification parameter:&lt;/strong&gt;&lt;/p&gt;&lt;pre&gt;&lt;table&gt;&lt;tr&gt;&lt;td&gt;Parameter&lt;/td&gt;&lt;td&gt;Type&lt;/td&gt;&lt;td&gt;Required&lt;/td&gt;&lt;td&gt;Description&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;payload&lt;/td&gt;&lt;td&gt;String&lt;/td&gt;&lt;td&gt;Yes&lt;/td&gt;&lt;td&gt;Payment notification payload in json string &lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;sign&lt;/td&gt;&lt;td&gt;String&lt;/td&gt;&lt;td&gt;Yes&lt;/td&gt;&lt;td&gt;sha1 hex signature for payload and private key&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;Payment notification parameter Example:&lt;/strong&gt;&lt;/p&gt;&lt;pre&gt;&lt;code style=&#39;overflow: auto&#39;&gt;{ &#34;payload&#34;: &#34;{ \&#34;type\&#34;: \&#34;payment\&#34;, \&#34;nonceStr\&#34;: \&#34;34c1dcf3eb58455eb161465bbfc0b590\&#34;, \&#34;paymentOrderNo\&#34;: \&#34;18081239088\&#34;, \&#34;namespace\&#34;: \&#34;accelbyte\&#34;, \&#34;targetNamespace\&#34;: \&#34;game1\&#34;, \&#34;targetUserId\&#34;: \&#34;94451623768940d58416ca33ca767ec3\&#34;, \&#34;extOrderNo\&#34;: \&#34;123456789\&#34;, \&#34;sku\&#34;: \&#34;sku\&#34;, \&#34;extUserId\&#34;: \&#34;678\&#34;, \&#34;price\&#34;: 100, \&#34;paymentProvider\&#34;: \&#34;XSOLLA\&#34;, \&#34;vat\&#34;: 0, \&#34;salesTax\&#34;: 0, \&#34;paymentProviderFee\&#34;: 0, \&#34;paymentMethodFee\&#34;: 0, \&#34;currency\&#34;: { \&#34;currencyCode\&#34;: \&#34;USD\&#34;, \&#34;currencySymbol\&#34;: \&#34;$\&#34;, \&#34;currencyType\&#34;: \&#34;REAL\&#34;, \&#34;namespace\&#34;: \&#34;accelbyte\&#34;, \&#34;decimals\&#34;: 2 }, \&#34;status\&#34;: \&#34;CHARGED\&#34;, \&#34;createdTime\&#34;: \&#34;2018-07-28T00:39:16.274Z\&#34;, \&#34;chargedTime\&#34;: \&#34;2018-07-28T00:39:16.274Z\&#34; }&#34;, &#34;sign&#34;:&#34;e31fb92516cc9faaf50ad70343e1293acec6f3d5&#34; }&lt;/pre&gt;&lt;/code&gt;&lt;p&gt;&lt;strong&gt;Payment notification payload parameter list:&lt;/strong&gt;&lt;/p&gt;&lt;pre&gt;&lt;table&gt;&lt;tr&gt;&lt;td&gt;Parameter&lt;/td&gt;&lt;td&gt;Type&lt;/td&gt;&lt;td&gt;Required&lt;/td&gt;&lt;td&gt;Description&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;type&lt;/td&gt;&lt;td&gt;String&lt;/td&gt;&lt;td&gt;Yes&lt;/td&gt;&lt;td&gt;Notification type: &#39;payment&#39;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;paymentOrderNo&lt;/td&gt;&lt;td&gt;String&lt;/td&gt;&lt;td&gt;Yes&lt;/td&gt;&lt;td&gt;Payment system generated order number&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;extOrderNo&lt;/td&gt;&lt;td&gt;String&lt;/td&gt;&lt;td&gt;No&lt;/td&gt;&lt;td&gt;External order number that passed by invoker&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;namespace&lt;/td&gt;&lt;td&gt;String&lt;/td&gt;&lt;td&gt;Yes&lt;/td&gt;&lt;td&gt;Namespace that related payment order resides in&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;targetNamespace&lt;/td&gt;&lt;td&gt;String&lt;/td&gt;&lt;td&gt;Yes&lt;/td&gt;&lt;td&gt;The game namespace&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;targetUserId&lt;/td&gt;&lt;td&gt;String&lt;/td&gt;&lt;td&gt;Yes&lt;/td&gt;&lt;td&gt;The user id in game namespace&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;sku&lt;/td&gt;&lt;td&gt;String&lt;/td&gt;&lt;td&gt;No&lt;/td&gt;&lt;td&gt;Item identify, it will return if pass it when create payment&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;extUserId&lt;/td&gt;&lt;td&gt;String&lt;/td&gt;&lt;td&gt;No&lt;/td&gt;&lt;td&gt;External user id, can be character id, it will return if pass it when create payment&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;price&lt;/td&gt;&lt;td&gt;int&lt;/td&gt;&lt;td&gt;Yes&lt;/td&gt;&lt;td&gt;Price of item&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;paymentProvider&lt;/td&gt;&lt;td&gt;String&lt;/td&gt;&lt;td&gt;Yes&lt;/td&gt;&lt;td&gt;Payment provider, allowed values: xsolla/alipay/wxpay/wallet&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;vat&lt;/td&gt;&lt;td&gt;int&lt;/td&gt;&lt;td&gt;Yes&lt;/td&gt;&lt;td&gt;Payment order VAT&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;salesTax&lt;/td&gt;&lt;td&gt;int&lt;/td&gt;&lt;td&gt;Yes&lt;/td&gt;&lt;td&gt;Payment order sales tax&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;paymentProviderFee&lt;/td&gt;&lt;td&gt;int&lt;/td&gt;&lt;td&gt;Yes&lt;/td&gt;&lt;td&gt;Payment provider fee&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;paymentMethodFee&lt;/td&gt;&lt;td&gt;int&lt;/td&gt;&lt;td&gt;Yes&lt;/td&gt;&lt;td&gt;Payment method fee&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;currency&lt;/td&gt;&lt;td&gt;Map&lt;/td&gt;&lt;td&gt;Yes&lt;/td&gt;&lt;td&gt;Payment order currency info&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;status&lt;/td&gt;&lt;td&gt;String&lt;/td&gt;&lt;td&gt;Yes&lt;/td&gt;&lt;td&gt;Payment order status&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;statusReason&lt;/td&gt;&lt;td&gt;String&lt;/td&gt;&lt;td&gt;No&lt;/td&gt;&lt;td&gt;Payment order status reason&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;createdTime&lt;/td&gt;&lt;td&gt;Datetime&lt;/td&gt;&lt;td&gt;No&lt;/td&gt;&lt;td&gt;The time of the order created&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;chargedTime&lt;/td&gt;&lt;td&gt;Datetime&lt;/td&gt;&lt;td&gt;No&lt;/td&gt;&lt;td&gt;The time of the order charged&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;customParameters&lt;/td&gt;&lt;td&gt;Map&lt;/td&gt;&lt;td&gt;No&lt;/td&gt;&lt;td&gt;custom parameters, will return if pass it when create payment&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;nonceStr&lt;/td&gt;&lt;td&gt;String&lt;/td&gt;&lt;td&gt;Yes&lt;/td&gt;&lt;td&gt;Random string, max length is 32, can be timestamp or uuid&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;Currency info parameter list:&lt;/strong&gt;&lt;/p&gt;&lt;pre&gt;&lt;table&gt;&lt;tr&gt;&lt;td&gt;Parameter&lt;/td&gt;&lt;td&gt;Type&lt;/td&gt;&lt;td&gt;Required&lt;/td&gt;&lt;td&gt;Description&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;currencyCode&lt;/td&gt;&lt;td&gt;String&lt;/td&gt;&lt;td&gt;Yes&lt;/td&gt;&lt;td&gt;Currency Code&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;currencySymbol&lt;/td&gt;&lt;td&gt;String&lt;/td&gt;&lt;td&gt;Yes&lt;/td&gt;&lt;td&gt;Currency Symbol&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;currencyType&lt;/td&gt;&lt;td&gt;String&lt;/td&gt;&lt;td&gt;Yes&lt;/td&gt;&lt;td&gt;Currency type(REAL/VIRTUAL)&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;namespace&lt;/td&gt;&lt;td&gt;String&lt;/td&gt;&lt;td&gt;Yes&lt;/td&gt;&lt;td&gt;Currency namespace&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;decimals&lt;/td&gt;&lt;td&gt;int&lt;/td&gt;&lt;td&gt;Yes&lt;/td&gt;&lt;td&gt;Currency decimals&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/pre&gt;&lt;h4&gt;Encryption Rule:&lt;/h4&gt;&lt;p&gt;Concat payload json string and private key and then do sha1Hex.&lt;/p&gt;&lt;h4&gt;Other detail info:&lt;/h4&gt; &lt;ul&gt;&lt;li&gt;&lt;i&gt;Token type&lt;/i&gt;: client token&lt;/li&gt;&lt;li&gt;&lt;i&gt;Optional permission(user with this permission will create sandbox order)&lt;/i&gt;: resource=&#34;SANDBOX&#34;, action=1 (CREATE)&lt;/li&gt;&lt;li&gt;It will be forbidden while the target user is banned: PAYMENT_INITIATE or ORDER_AND_PAYMENT&lt;/li&gt;&lt;li&gt;&lt;b&gt;cross namespace allowed&lt;/b&gt;&lt;/li&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: created payment order info&lt;/li&gt;&lt;/ul&gt;
   */
  createPaymentOrder(data) {
    const params = {};
    const url = "/platform/admin/namespaces/{namespace}/payment/orders".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.post(url, data, { params });
    return Validate23.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      PaymentOrderCreateResult,
      "PaymentOrderCreateResult"
    );
  }
  /**
   * &lt;b&gt;[Not supported yet in AGS Shared Cloud]&lt;/b&gt;&lt;p&gt;This API is used to refund payment order by paymentOrderNo from non justice service. e.g. dedicated server. &lt;ul&gt;&lt;li&gt;if the status field of response json is &#34;REFUNDED&#34;, usually wallet paid, it indicates payment order already refunded&lt;/li&gt;&lt;li&gt;if the status field of response json is &#34;REFUNDING&#34;, usually real money paid, platform will send notification to registered notify url once refund successfully&lt;/li&gt; &lt;/ul&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;Path Parameter:&lt;/strong&gt;&lt;/p&gt;&lt;pre&gt;&lt;table&gt;&lt;tr&gt;&lt;td&gt;Parameter&lt;/td&gt;&lt;td&gt;Type&lt;/td&gt;&lt;td&gt;Required&lt;/td&gt;&lt;td&gt;Description&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;namespace&lt;/td&gt;&lt;td&gt;String&lt;/td&gt;&lt;td&gt;Yes&lt;/td&gt;&lt;td&gt;Namespace that payment order resides in&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;paymentOrderNo&lt;/td&gt;&lt;td&gt;String&lt;/td&gt;&lt;td&gt;Yes&lt;/td&gt;&lt;td&gt;Payment order number&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;Request Body Parameters:&lt;/strong&gt;&lt;/p&gt;&lt;pre&gt;&lt;table&gt;&lt;tr&gt;&lt;td&gt;Parameter&lt;/td&gt;&lt;td&gt;Type&lt;/td&gt;&lt;td&gt;Required&lt;/td&gt;&lt;td&gt;Description&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;description&lt;/td&gt;&lt;td&gt;String&lt;/td&gt;&lt;td&gt;Yes&lt;/td&gt;&lt;td&gt;Refund description&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;Request Body Example:&lt;/strong&gt;&lt;/p&gt;&lt;pre&gt;&lt;code style=&#39;overflow: auto&#39;&gt;{ &#34;description&#34;: &#34;Repeated item.&#34; }&lt;/pre&gt;&lt;/code&gt;&lt;h4&gt;Refund Notification:&lt;/h4&gt;&lt;p&gt;It will send notification to configured web hook after refund successfully, http status code should return 200 or 204 once you resolve notification successfully, otherwise payment system will retry notification in interval&lt;/p&gt;&lt;p&gt;&lt;strong&gt;Refund notification parameter:&lt;/strong&gt;&lt;/p&gt;&lt;pre&gt;&lt;table&gt;&lt;tr&gt;&lt;td&gt;Parameter&lt;/td&gt;&lt;td&gt;Type&lt;/td&gt;&lt;td&gt;Required&lt;/td&gt;&lt;td&gt;Description&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;payload&lt;/td&gt;&lt;td&gt;String&lt;/td&gt;&lt;td&gt;Yes&lt;/td&gt;&lt;td&gt;Refund notification payload in json string &lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;sign&lt;/td&gt;&lt;td&gt;String&lt;/td&gt;&lt;td&gt;Yes&lt;/td&gt;&lt;td&gt;sha1 hex signature for payload and private key&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;Refund notification Example:&lt;/strong&gt;&lt;/p&gt;&lt;pre&gt;&lt;code style=&#39;overflow: auto&#39;&gt;{ &#34;payload&#34;: &#34;{ \&#34;type\&#34;: \&#34;payment\&#34;, \&#34;nonceStr\&#34;: \&#34;34c1dcf3eb58455eb161465bbfc0b590\&#34;, \&#34;paymentOrderNo\&#34;: \&#34;18081239088\&#34;, \&#34;namespace\&#34;: \&#34;accelbyte\&#34;, \&#34;targetNamespace\&#34;: \&#34;game1\&#34;, \&#34;targetUserId\&#34;: \&#34;94451623768940d58416ca33ca767ec3\&#34;, \&#34;extOrderNo\&#34;: \&#34;123456789\&#34;, \&#34;sku\&#34;: \&#34;sku\&#34;, \&#34;extUserId\&#34;: \&#34;678\&#34;, \&#34;price\&#34;: 100, \&#34;paymentProvider\&#34;: \&#34;XSOLLA\&#34;, \&#34;vat\&#34;: 0, \&#34;salesTax\&#34;: 0, \&#34;paymentProviderFee\&#34;: 0, \&#34;paymentMethodFee\&#34;: 0, \&#34;currency\&#34;: { \&#34;currencyCode\&#34;: \&#34;USD\&#34;, \&#34;currencySymbol\&#34;: \&#34;$\&#34;, \&#34;currencyType\&#34;: \&#34;REAL\&#34;, \&#34;namespace\&#34;: \&#34;accelbyte\&#34;, \&#34;decimals\&#34;: 2 }, \&#34;status\&#34;: \&#34;REFUNDED\&#34;, \&#34;createdTime\&#34;: \&#34;2018-07-28T00:39:16.274Z\&#34;, \&#34;chargedTime\&#34;: \&#34;2018-07-28T00:39:16.274Z\&#34;, \&#34;refundedTime\&#34;: \&#34;2018-07-28T00:39:16.274Z\&#34; }&#34;, &#34;sign&#34;:&#34;e31fb92516cc9faaf50ad70343e1293acec6f3d5&#34; }&lt;/pre&gt;&lt;/code&gt;&lt;p&gt;&lt;strong&gt;Refund notification payload parameter list:&lt;/strong&gt;&lt;/p&gt;&lt;pre&gt;&lt;table&gt;&lt;tr&gt;&lt;td&gt;Parameter&lt;/td&gt;&lt;td&gt;Type&lt;/td&gt;&lt;td&gt;Required&lt;/td&gt;&lt;td&gt;Description&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;type&lt;/td&gt;&lt;td&gt;String&lt;/td&gt;&lt;td&gt;Yes&lt;/td&gt;&lt;td&gt;Notification type: &#39;payment&#39;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;paymentOrderNo&lt;/td&gt;&lt;td&gt;String&lt;/td&gt;&lt;td&gt;Yes&lt;/td&gt;&lt;td&gt;Payment system generated order number&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;extOrderNo&lt;/td&gt;&lt;td&gt;String&lt;/td&gt;&lt;td&gt;No&lt;/td&gt;&lt;td&gt;External order number that passed by invoker&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;namespace&lt;/td&gt;&lt;td&gt;String&lt;/td&gt;&lt;td&gt;Yes&lt;/td&gt;&lt;td&gt;Namespace that related payment order resides in&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;targetNamespace&lt;/td&gt;&lt;td&gt;String&lt;/td&gt;&lt;td&gt;Yes&lt;/td&gt;&lt;td&gt;The game namespace&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;targetUserId&lt;/td&gt;&lt;td&gt;String&lt;/td&gt;&lt;td&gt;Yes&lt;/td&gt;&lt;td&gt;The user id in game namespace&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;sku&lt;/td&gt;&lt;td&gt;String&lt;/td&gt;&lt;td&gt;No&lt;/td&gt;&lt;td&gt;Item identify, it will return if pass it when create payment&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;extUserId&lt;/td&gt;&lt;td&gt;String&lt;/td&gt;&lt;td&gt;No&lt;/td&gt;&lt;td&gt;External user id, can be character id, it will return if pass it when create payment&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;price&lt;/td&gt;&lt;td&gt;int&lt;/td&gt;&lt;td&gt;Yes&lt;/td&gt;&lt;td&gt;Price of item&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;paymentProvider&lt;/td&gt;&lt;td&gt;String&lt;/td&gt;&lt;td&gt;Yes&lt;/td&gt;&lt;td&gt;Payment provider: xsolla/alipay/wxpay/wallet&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;vat&lt;/td&gt;&lt;td&gt;int&lt;/td&gt;&lt;td&gt;Yes&lt;/td&gt;&lt;td&gt;Payment order VAT&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;salesTax&lt;/td&gt;&lt;td&gt;int&lt;/td&gt;&lt;td&gt;Yes&lt;/td&gt;&lt;td&gt;Payment order sales tax&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;paymentProviderFee&lt;/td&gt;&lt;td&gt;int&lt;/td&gt;&lt;td&gt;Yes&lt;/td&gt;&lt;td&gt;Payment provider fee&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;paymentMethodFee&lt;/td&gt;&lt;td&gt;int&lt;/td&gt;&lt;td&gt;Yes&lt;/td&gt;&lt;td&gt;Payment method fee&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;currency&lt;/td&gt;&lt;td&gt;Map&lt;/td&gt;&lt;td&gt;Yes&lt;/td&gt;&lt;td&gt;Payment order currency info&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;status&lt;/td&gt;&lt;td&gt;String&lt;/td&gt;&lt;td&gt;Yes&lt;/td&gt;&lt;td&gt;Payment order status&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;statusReason&lt;/td&gt;&lt;td&gt;String&lt;/td&gt;&lt;td&gt;No&lt;/td&gt;&lt;td&gt;Payment order refund status reason&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;createdTime&lt;/td&gt;&lt;td&gt;Datetime&lt;/td&gt;&lt;td&gt;No&lt;/td&gt;&lt;td&gt;The time of the order created&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;chargedTime&lt;/td&gt;&lt;td&gt;Datetime&lt;/td&gt;&lt;td&gt;No&lt;/td&gt;&lt;td&gt;The time of the order charged&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;refundedTime&lt;/td&gt;&lt;td&gt;Datetime&lt;/td&gt;&lt;td&gt;No&lt;/td&gt;&lt;td&gt;The time of the order refunded&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;customParameters&lt;/td&gt;&lt;td&gt;Map&lt;/td&gt;&lt;td&gt;No&lt;/td&gt;&lt;td&gt;custom parameters, will return if pass it when create payment&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;nonceStr&lt;/td&gt;&lt;td&gt;String&lt;/td&gt;&lt;td&gt;Yes&lt;/td&gt;&lt;td&gt;Random string, max length is 32, &lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;Currency info parameter list:&lt;/strong&gt;&lt;/p&gt;&lt;pre&gt;&lt;table&gt;&lt;tr&gt;&lt;td&gt;Parameter&lt;/td&gt;&lt;td&gt;Type&lt;/td&gt;&lt;td&gt;Required&lt;/td&gt;&lt;td&gt;Description&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;currencyCode&lt;/td&gt;&lt;td&gt;String&lt;/td&gt;&lt;td&gt;Yes&lt;/td&gt;&lt;td&gt;Currency Code&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;currencySymbol&lt;/td&gt;&lt;td&gt;String&lt;/td&gt;&lt;td&gt;Yes&lt;/td&gt;&lt;td&gt;Currency Symbol&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;currencyType&lt;/td&gt;&lt;td&gt;String&lt;/td&gt;&lt;td&gt;Yes&lt;/td&gt;&lt;td&gt;Currency type(REAL/VIRTUAL)&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;namespace&lt;/td&gt;&lt;td&gt;String&lt;/td&gt;&lt;td&gt;Yes&lt;/td&gt;&lt;td&gt;Currency namespace&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;decimals&lt;/td&gt;&lt;td&gt;int&lt;/td&gt;&lt;td&gt;Yes&lt;/td&gt;&lt;td&gt;Currency decimals&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/pre&gt;&lt;h4&gt;Encryption Rule:&lt;/h4&gt;&lt;p&gt;Concat payload json string and private key and then do sha1Hex.&lt;/p&gt;&lt;h4&gt;Other detail info:&lt;/h4&gt; &lt;ul&gt;&lt;li&gt;&lt;i&gt;Token type&lt;/i&gt;: client token&lt;/li&gt;&lt;li&gt;&lt;b&gt;cross namespace allowed&lt;/b&gt;&lt;/li&gt;&lt;/ul&gt;
   */
  updateRefundPayment_ByPaymentOrderNo(paymentOrderNo, data) {
    const params = {};
    const url = "/platform/admin/namespaces/{namespace}/payment/orders/{paymentOrderNo}/refund".replace("{namespace}", this.namespace).replace("{paymentOrderNo}", paymentOrderNo);
    const resultPromise = this.axiosInstance.put(url, data, { params });
    return Validate23.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      PaymentOrderRefundResult,
      "PaymentOrderRefundResult"
    );
  }
};

// src/generated-definitions/SimpleEntitlement.ts
import { z as z234 } from "zod";
var SimpleEntitlement = z234.object({
  entitlementId: z234.string().nullish(),
  grantedCode: z234.string().nullish(),
  itemId: z234.string().nullish(),
  itemNamespace: z234.string().nullish(),
  name: z234.string().nullish(),
  namespace: z234.string().nullish(),
  origin: z234.string().nullish(),
  sku: z234.string().nullish(),
  useCount: z234.number().int().nullish()
});

// src/generated-definitions/SimpleUserDlc.ts
import { z as z235 } from "zod";
var SimpleUserDlc = z235.object({ dlcId: z235.string().nullish() });

// src/generated-definitions/TimeLimitedBalance.ts
import { z as z236 } from "zod";
var TimeLimitedBalance = z236.object({
  balance: z236.number().int().nullish(),
  balanceSource: z236.string().nullish(),
  expireAt: z236.string().nullish()
});

// src/generated-definitions/SimpleWallet.ts
import { z as z237 } from "zod";
var SimpleWallet = z237.object({
  balance: z237.number().int().nullish(),
  balanceOrigin: z237.string().nullish(),
  currencyCode: z237.string().nullish(),
  timeLimitedBalances: z237.array(TimeLimitedBalance).nullish(),
  walletId: z237.string().nullish()
});

// src/generated-definitions/PlatformAccountClosureHistoryInfo.ts
import { z as z238 } from "zod";
var PlatformAccountClosureHistoryInfo = z238.object({
  entitlements: z238.array(SimpleEntitlement).nullish(),
  id: z238.string(),
  namespace: z238.string(),
  platform: z238.string(),
  progression: z238.enum(["IN_PROGRESS", "SUCCESS"]),
  userDlcS: z238.array(SimpleUserDlc).nullish(),
  userId: z238.string(),
  wallets: z238.array(SimpleWallet).nullish()
});

// src/generated-definitions/PlatformAccountClosureHistoryInfoArray.ts
import { z as z239 } from "zod";
var PlatformAccountClosureHistoryInfoArray = z239.array(PlatformAccountClosureHistoryInfo);

// src/generated-admin/endpoints/PlatformAccountClosureAdmin$.ts
import { Validate as Validate24 } from "@accelbyte/sdk";
var PlatformAccountClosureAdmin$ = class {
  // @ts-ignore
  // prettier-ignore
  constructor(axiosInstance, namespace, useSchemaValidation = true) {
    this.axiosInstance = axiosInstance;
    this.namespace = namespace;
    this.useSchemaValidation = useSchemaValidation;
  }
  /**
   * Get user platform account closure history.&lt;br&gt;
   */
  getPlatformClosureHistory_ByUserId(userId) {
    const params = {};
    const url = "/platform/admin/namespaces/{namespace}/users/{userId}/platform/closure/history".replace("{namespace}", this.namespace).replace("{userId}", userId);
    const resultPromise = this.axiosInstance.get(url, { params });
    return Validate24.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      PlatformAccountClosureHistoryInfoArray,
      "PlatformAccountClosureHistoryInfoArray"
    );
  }
};

// src/generated-definitions/PlatformOwnership.ts
import { z as z240 } from "zod";
var PlatformOwnership = z240.object({ owned: z240.boolean() });

// src/generated-admin/endpoints/PlatformAdmin$.ts
import { Validate as Validate25 } from "@accelbyte/sdk";
var PlatformAdmin$ = class {
  // @ts-ignore
  // prettier-ignore
  constructor(axiosInstance, namespace, useSchemaValidation = true) {
    this.axiosInstance = axiosInstance;
    this.namespace = namespace;
    this.useSchemaValidation = useSchemaValidation;
  }
  /**
   * Get Xbox entitlement ownership by product sku.
   */
  createOwnershipXblPlatform_ByProductSku(productSku, data) {
    const params = {};
    const url = "/platform/admin/namespaces/{namespace}/platforms/xbl/entitlements/{productSku}/ownership".replace("{namespace}", this.namespace).replace("{productSku}", productSku);
    const resultPromise = this.axiosInstance.post(url, data, { params });
    return Validate25.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, PlatformOwnership, "PlatformOwnership");
  }
  /**
   * Get user psn entitlement ownership by entitlement label.
   */
  createOwnershipPsnPlatform_ByEntitlementLabel(entitlementLabel, data) {
    const params = {};
    const url = "/platform/admin/namespaces/{namespace}/platforms/psn/entitlements/{entitlementLabel}/ownership".replace("{namespace}", this.namespace).replace("{entitlementLabel}", entitlementLabel);
    const resultPromise = this.axiosInstance.post(url, data, { params });
    return Validate25.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, Ownership, "Ownership");
  }
};

// src/generated-definitions/ConsumableEntitlementRevocationConfig.ts
import { z as z241 } from "zod";
var ConsumableEntitlementRevocationConfig = z241.object({
  enabled: z241.boolean().nullish(),
  strategy: z241.enum(["CUSTOM", "REVOKE_OR_REPORT"]).nullish()
});

// src/generated-definitions/DurableEntitlementRevocationConfig.ts
import { z as z242 } from "zod";
var DurableEntitlementRevocationConfig = z242.object({
  enabled: z242.boolean().nullish(),
  strategy: z242.enum(["CUSTOM", "REVOKE_OR_REPORT"]).nullish()
});

// src/generated-definitions/EntitlementRevocationConfig.ts
import { z as z243 } from "zod";
var EntitlementRevocationConfig = z243.object({
  consumable: ConsumableEntitlementRevocationConfig.nullish(),
  durable: DurableEntitlementRevocationConfig.nullish()
});

// src/generated-definitions/WalletRevocationConfig.ts
import { z as z244 } from "zod";
var WalletRevocationConfig = z244.object({
  enabled: z244.boolean().nullish(),
  strategy: z244.enum(["ALWAYS_REVOKE", "CUSTOM", "REVOKE_OR_REPORT"]).nullish()
});

// src/generated-definitions/RevocationConfigInfo.ts
import { z as z245 } from "zod";
var RevocationConfigInfo = z245.object({
  entitlement: EntitlementRevocationConfig.nullish(),
  namespace: z245.string().nullish(),
  wallet: WalletRevocationConfig.nullish()
});

// src/generated-definitions/RevocationError.ts
import { z as z246 } from "zod";
var RevocationError = z246.object({
  code: z246.number().int().nullish(),
  httpStatus: z246.number().int().nullish(),
  message: z246.string().nullish()
});

// src/generated-definitions/RevokeCurrency.ts
import { z as z247 } from "zod";
var RevokeCurrency = z247.object({
  balanceOrigin: z247.enum(["Epic", "GooglePlay", "IOS", "Nintendo", "Oculus", "Other", "Playstation", "Steam", "System", "Twitch", "Xbox"]).nullish(),
  currencyCode: z247.string().nullish(),
  namespace: z247.string().nullish()
});

// src/generated-definitions/RevokeEntitlement.ts
import { z as z248 } from "zod";
var RevokeEntitlement = z248.object({ entitlementId: z248.string().nullish() });

// src/generated-definitions/RevokeItem.ts
import { z as z249 } from "zod";
var RevokeItem = z249.object({
  entitlementOrigin: z249.enum(["Epic", "GooglePlay", "IOS", "Nintendo", "Oculus", "Other", "Playstation", "Steam", "System", "Twitch", "Xbox"]).nullish(),
  itemIdentity: z249.string().nullish(),
  itemIdentityType: z249.enum(["ITEM_ID", "ITEM_SKU"]).nullish(),
  origin: z249.enum(["Epic", "GooglePlay", "IOS", "Nintendo", "Oculus", "Other", "Playstation", "Steam", "System", "Twitch", "Xbox"]).nullish()
});

// src/generated-definitions/RevokeEntry.ts
import { z as z250 } from "zod";
var RevokeEntry = z250.object({
  currency: RevokeCurrency.nullish(),
  entitlement: RevokeEntitlement.nullish(),
  item: RevokeItem.nullish(),
  quantity: z250.number().int().nullish(),
  type: z250.enum(["CURRENCY", "ENTITLEMENT", "ITEM"]).nullish()
});

// src/generated-definitions/RevocationHistoryInfo.ts
import { z as z251 } from "zod";
var RevocationHistoryInfo = z251.object({
  createdAt: z251.string().nullish(),
  creditRevocations: z251.array(CreditRevocation).nullish(),
  entitlementRevocations: z251.array(EntitlementRevocation).nullish(),
  id: z251.string().nullish(),
  itemRevocations: z251.array(ItemRevocation).nullish(),
  meta: z251.record(z251.any()).nullish(),
  namespace: z251.string().nullish(),
  revocationErrors: z251.array(RevocationError).nullish(),
  revokeEntries: z251.array(RevokeEntry).nullish(),
  source: z251.string().nullish(),
  status: z251.enum(["FAIL", "SUCCESS"]).nullish(),
  transactionId: z251.string().nullish(),
  updatedAt: z251.string().nullish(),
  userId: z251.string().nullish()
});

// src/generated-definitions/RevocationHistoryPagingSlicedResult.ts
import { z as z252 } from "zod";
var RevocationHistoryPagingSlicedResult = z252.object({ data: z252.array(RevocationHistoryInfo), paging: Paging.nullish() });

// src/generated-admin/endpoints/RevocationAdmin$.ts
import { Validate as Validate26 } from "@accelbyte/sdk";
import { z as z253 } from "zod";
var RevocationAdmin$ = class {
  // @ts-ignore
  // prettier-ignore
  constructor(axiosInstance, namespace, useSchemaValidation = true) {
    this.axiosInstance = axiosInstance;
    this.namespace = namespace;
    this.useSchemaValidation = useSchemaValidation;
  }
  /**
   * Delete revocation config.
   */
  deleteRevocationConfig() {
    const params = {};
    const url = "/platform/admin/namespaces/{namespace}/revocation/config".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.delete(url, { params });
    return Validate26.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, z253.unknown(), "z.unknown()");
  }
  /**
   * Get revocation configuration.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: Revocation config&lt;/li&gt;&lt;/ul&gt;
   */
  getRevocationConfig() {
    const params = {};
    const url = "/platform/admin/namespaces/{namespace}/revocation/config".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.get(url, { params });
    return Validate26.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, RevocationConfigInfo, "RevocationConfigInfo");
  }
  /**
   * Update revocation configuration.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: Revocation config&lt;/li&gt;&lt;/ul&gt;
   */
  updateRevocationConfig(data) {
    const params = {};
    const url = "/platform/admin/namespaces/{namespace}/revocation/config".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.put(url, data, { params });
    return Validate26.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, RevocationConfigInfo, "RevocationConfigInfo");
  }
  /**
   * Query revocation histories in a namespace.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: query revocation history&lt;/li&gt;&lt;/ul&gt;
   */
  getRevocationHistory(queryParams) {
    const params = { limit: 20, ...queryParams };
    const url = "/platform/admin/namespaces/{namespace}/revocation/history".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.get(url, { params });
    return Validate26.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      RevocationHistoryPagingSlicedResult,
      "RevocationHistoryPagingSlicedResult"
    );
  }
  /**
   * Do revocation.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: revocation results&lt;/li&gt;&lt;/ul&gt;
   */
  updateRevocation_ByUserId(userId, data) {
    const params = {};
    const url = "/platform/admin/namespaces/{namespace}/users/{userId}/revocation".replace("{namespace}", this.namespace).replace("{userId}", userId);
    const resultPromise = this.axiosInstance.put(url, data, { params });
    return Validate26.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, RevocationResult, "RevocationResult");
  }
};

// src/generated-definitions/ConditionMatchResult.ts
import { z as z254 } from "zod";
var ConditionMatchResult = z254.object({
  matched: z254.boolean().nullish(),
  matchedConditions: z254.array(z254.any()).nullish(),
  notMatchReason: z254.string().nullish()
});

// src/generated-definitions/RewardItem.ts
import { z as z255 } from "zod";
var RewardItem = z255.object({
  duration: z255.number().int().nullish(),
  endDate: z255.string().nullish(),
  identityType: z255.enum(["ITEM_ID", "ITEM_SKU"]).nullish(),
  itemId: z255.string().nullish(),
  quantity: z255.number().int().nullish(),
  sku: z255.string().nullish()
});

// src/generated-definitions/RewardCondition.ts
import { z as z256 } from "zod";
var RewardCondition = z256.object({
  condition: z256.string().nullish(),
  conditionName: z256.string().nullish(),
  eventName: z256.string().nullish(),
  rewardItems: z256.array(RewardItem).nullish()
});

// src/generated-definitions/RewardInfo.ts
import { z as z257 } from "zod";
var RewardInfo = z257.object({
  createdAt: z257.string().nullish(),
  description: z257.string().nullish(),
  eventTopic: z257.string(),
  maxAwarded: z257.number().int().nullish(),
  maxAwardedPerUser: z257.number().int().nullish(),
  namespace: z257.string(),
  namespaceExpression: z257.string().nullish(),
  rewardCode: z257.string().nullish(),
  rewardConditions: z257.array(RewardCondition).nullish(),
  rewardId: z257.string(),
  updatedAt: z257.string().nullish(),
  userIdExpression: z257.string().nullish()
});

// src/generated-definitions/RewardPagingSlicedResult.ts
import { z as z258 } from "zod";
var RewardPagingSlicedResult = z258.object({ data: z258.array(RewardInfo), paging: Paging.nullish() });

// src/generated-admin/endpoints/RewardAdmin$.ts
import { Validate as Validate27 } from "@accelbyte/sdk";
import { z as z259 } from "zod";
var RewardAdmin$ = class {
  // @ts-ignore
  // prettier-ignore
  constructor(axiosInstance, namespace, useSchemaValidation = true) {
    this.axiosInstance = axiosInstance;
    this.namespace = namespace;
    this.useSchemaValidation = useSchemaValidation;
  }
  /**
   * This API is used to create a reward.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: created reward data&lt;/li&gt;&lt;li&gt;&lt;i&gt;Acceptable values for rewardItem&#39;s identityType are&lt;/i&gt;: ITEM_ID or ITEM_SKU&lt;/li&gt;&lt;/ul&gt;
   */
  createReward(data) {
    const params = {};
    const url = "/platform/admin/namespaces/{namespace}/rewards".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.post(url, data, { params });
    return Validate27.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, RewardInfo, "RewardInfo");
  }
  /**
   * Export reward configurations for a given namespace into file. At current, only JSON file is supported.
   */
  getRewardsExport() {
    const params = {};
    const url = "/platform/admin/namespaces/{namespace}/rewards/export".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.get(url, { params });
    return Validate27.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, z259.unknown(), "z.unknown()");
  }
  /**
   * Import reward configurations for a given namespace from file. At current, only JSON file is supported.
   */
  createRewardImport(data, queryParams) {
    const params = { ...queryParams };
    const url = "/platform/admin/namespaces/{namespace}/rewards/import".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.post(url, data, { params });
    return Validate27.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, z259.unknown(), "z.unknown()");
  }
  /**
   * This API is used to delete a reward by reward Id. &lt;p&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: the deleted reward data&lt;/li&gt;&lt;/ul&gt;
   */
  deleteReward_ByRewardId(rewardId) {
    const params = {};
    const url = "/platform/admin/namespaces/{namespace}/rewards/{rewardId}".replace("{namespace}", this.namespace).replace("{rewardId}", rewardId);
    const resultPromise = this.axiosInstance.delete(url, { params });
    return Validate27.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, RewardInfo, "RewardInfo");
  }
  /**
   * This API is used to get reward by reward Id.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: reward instance&lt;/li&gt;&lt;/ul&gt;
   */
  getReward_ByRewardId(rewardId) {
    const params = {};
    const url = "/platform/admin/namespaces/{namespace}/rewards/{rewardId}".replace("{namespace}", this.namespace).replace("{rewardId}", rewardId);
    const resultPromise = this.axiosInstance.get(url, { params });
    return Validate27.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, RewardInfo, "RewardInfo");
  }
  /**
   * This API is used to update a reward.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: reward instance&lt;/li&gt;&lt;li&gt;&lt;i&gt;Acceptable values for rewardItem&#39;s identityType are&lt;/i&gt;: ITEM_ID or ITEM_SKU&lt;/li&gt;&lt;/ul&gt;
   */
  updateReward_ByRewardId(rewardId, data) {
    const params = {};
    const url = "/platform/admin/namespaces/{namespace}/rewards/{rewardId}".replace("{namespace}", this.namespace).replace("{rewardId}", rewardId);
    const resultPromise = this.axiosInstance.put(url, data, { params });
    return Validate27.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, RewardInfo, "RewardInfo");
  }
  /**
   * This API is used to query rewards by criteria.&lt;p&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: the list of rewards&lt;/li&gt;&lt;/ul&gt;
   */
  getRewardsByCriteria(queryParams) {
    const params = { limit: 20, sortBy: ["namespace:asc", "rewardCode:asc"], ...queryParams };
    const url = "/platform/admin/namespaces/{namespace}/rewards/byCriteria".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.get(url, { params });
    return Validate27.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      RewardPagingSlicedResult,
      "RewardPagingSlicedResult"
    );
  }
  /**
   * &lt;b&gt;[TEST FACILITY ONLY] Forbidden in live environment. &lt;/b&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: match result&lt;/li&gt;&lt;/ul&gt;
   */
  updateMatch_ByRewardId(rewardId, data) {
    const params = {};
    const url = "/platform/admin/namespaces/{namespace}/rewards/{rewardId}/match".replace("{namespace}", this.namespace).replace("{rewardId}", rewardId);
    const resultPromise = this.axiosInstance.put(url, data, { params });
    return Validate27.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, ConditionMatchResult, "ConditionMatchResult");
  }
  /**
   * &lt;b&gt;[TEST FACILITY ONLY] Forbidden in live environment. &lt;/b&gt; This API is used to delete a reward condition record by reward Id and condition Name (optional). &lt;p&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: 204 No Content &lt;/li&gt;&lt;/ul&gt;
   */
  deleteRecord_ByRewardId(rewardId, data) {
    const params = {};
    const url = "/platform/admin/namespaces/{namespace}/rewards/{rewardId}/record".replace("{namespace}", this.namespace).replace("{rewardId}", rewardId);
    const resultPromise = this.axiosInstance.delete(url, { data, params });
    return Validate27.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, z259.unknown(), "z.unknown()");
  }
};

// src/generated-definitions/FixedPeriodRotationConfig.ts
import { z as z260 } from "zod";
var FixedPeriodRotationConfig = z260.object({
  backfillType: z260.enum(["CUSTOM", "NONE"]).nullish(),
  duration: z260.number().int().nullish(),
  itemCount: z260.number().int().nullish(),
  rule: z260.enum(["SEQUENCE"]).nullish()
});

// src/generated-definitions/ItemNaming.ts
import { z as z261 } from "zod";
var ItemNaming = z261.object({
  categoryPath: z261.string().nullish(),
  itemId: z261.string(),
  itemType: z261.enum([
    "APP",
    "BUNDLE",
    "CODE",
    "COINS",
    "EXTENSION",
    "INGAMEITEM",
    "LOOTBOX",
    "MEDIA",
    "OPTIONBOX",
    "SEASON",
    "SUBSCRIPTION"
  ]),
  name: z261.string(),
  namespace: z261.string(),
  seasonType: z261.enum(["PASS", "TIER"]).nullish(),
  sku: z261.string().nullish(),
  status: z261.enum(["ACTIVE", "INACTIVE"]).nullish()
});

// src/generated-definitions/SectionItem.ts
import { z as z262 } from "zod";
var SectionItem = z262.object({ id: z262.string(), sku: z262.string().nullish() });

// src/generated-definitions/FullSectionInfo.ts
import { z as z263 } from "zod";
var FullSectionInfo = z263.object({
  active: z263.boolean(),
  createdAt: z263.string(),
  displayOrder: z263.number().int().nullish(),
  endDate: z263.string(),
  ext: z263.record(z263.any()).nullish(),
  fixedPeriodRotationConfig: FixedPeriodRotationConfig.nullish(),
  itemNamings: z263.array(ItemNaming).nullish(),
  items: z263.array(SectionItem).nullish(),
  localizations: z263.record(Localization),
  name: z263.string(),
  namespace: z263.string(),
  rotationType: z263.enum(["CUSTOM", "FIXED_PERIOD", "NONE"]).nullish(),
  sectionId: z263.string(),
  startDate: z263.string(),
  updatedAt: z263.string(),
  viewId: z263.string().nullish(),
  viewName: z263.string().nullish()
});

// src/generated-definitions/SectionPagingSlicedResult.ts
import { z as z264 } from "zod";
var SectionPagingSlicedResult = z264.object({ data: z264.array(FullSectionInfo), paging: Paging.nullish() });

// src/generated-admin/endpoints/SectionAdmin$.ts
import { Validate as Validate28 } from "@accelbyte/sdk";
import { z as z265 } from "zod";
var SectionAdmin$ = class {
  // @ts-ignore
  // prettier-ignore
  constructor(axiosInstance, namespace, useSchemaValidation = true) {
    this.axiosInstance = axiosInstance;
    this.namespace = namespace;
    this.useSchemaValidation = useSchemaValidation;
  }
  /**
   * This API is used to query sections.&lt;p&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: paginated sections&lt;/li&gt;&lt;/ul&gt;
   */
  getSections(queryParams) {
    const params = { limit: 20, ...queryParams };
    const url = "/platform/admin/namespaces/{namespace}/sections".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.get(url, { params });
    return Validate28.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      SectionPagingSlicedResult,
      "SectionPagingSlicedResult"
    );
  }
  /**
   * This API is used to create a section.&lt;p&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: created a section&lt;/li&gt;&lt;/ul&gt;&lt;h2&gt;Restrictions for section extension and localization extension&lt;/h2&gt; 1. Cannot use &lt;b&gt;&#34;.&#34;&lt;/b&gt; as the key name - &lt;pre&gt;{ &#34;data.2&#34;: &#34;value&#34; }&lt;/pre&gt; 2. Cannot use &lt;b&gt;&#34;$&#34;&lt;/b&gt; as the prefix in key names - &lt;pre&gt;{ &#34;$data&#34;: &#34;value&#34; }&lt;/pre&gt;
   */
  createSection(data, queryParams) {
    const params = { ...queryParams };
    const url = "/platform/admin/namespaces/{namespace}/sections".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.post(url, data, { params });
    return Validate28.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, FullSectionInfo, "FullSectionInfo");
  }
  /**
   * This API is used to delete s section.
   */
  deleteSection_BySectionId(sectionId, queryParams) {
    const params = { ...queryParams };
    const url = "/platform/admin/namespaces/{namespace}/sections/{sectionId}".replace("{namespace}", this.namespace).replace("{sectionId}", sectionId);
    const resultPromise = this.axiosInstance.delete(url, { params });
    return Validate28.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, z265.unknown(), "z.unknown()");
  }
  /**
   * This API is used to get a section.&lt;p&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: section data&lt;/li&gt;&lt;/ul&gt;
   */
  getSection_BySectionId(sectionId, queryParams) {
    const params = { ...queryParams };
    const url = "/platform/admin/namespaces/{namespace}/sections/{sectionId}".replace("{namespace}", this.namespace).replace("{sectionId}", sectionId);
    const resultPromise = this.axiosInstance.get(url, { params });
    return Validate28.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, FullSectionInfo, "FullSectionInfo");
  }
  /**
   * This API is used to update s section.&lt;p&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: updated section data&lt;/li&gt;&lt;/ul&gt;&lt;h2&gt;Restrictions for section extension and localization extension&lt;/h2&gt; 1. Cannot use &lt;b&gt;&#34;.&#34;&lt;/b&gt; as the key name - &lt;pre&gt;{ &#34;data.2&#34;: &#34;value&#34; }&lt;/pre&gt; 2. Cannot use &lt;b&gt;&#34;$&#34;&lt;/b&gt; as the prefix in key names - &lt;pre&gt;{ &#34;$data&#34;: &#34;value&#34; }&lt;/pre&gt;
   */
  updateSection_BySectionId(sectionId, data, queryParams) {
    const params = { ...queryParams };
    const url = "/platform/admin/namespaces/{namespace}/sections/{sectionId}".replace("{namespace}", this.namespace).replace("{sectionId}", sectionId);
    const resultPromise = this.axiosInstance.put(url, data, { params });
    return Validate28.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, FullSectionInfo, "FullSectionInfo");
  }
  /**
   * This API is used to purge expired section.
   */
  deleteSectionPurgeExpired(queryParams) {
    const params = { ...queryParams };
    const url = "/platform/admin/namespaces/{namespace}/sections/purge/expired".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.delete(url, { params });
    return Validate28.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, z265.unknown(), "z.unknown()");
  }
};

// src/generated-definitions/TlsConfig.ts
import { z as z266 } from "zod";
var TlsConfig = z266.object({ rootCertFileBytes: z266.array(z266.string()).nullish(), rootCertFileName: z266.string().nullish() });

// src/generated-definitions/GrpcServerInfo.ts
import { z as z267 } from "zod";
var GrpcServerInfo = z267.object({
  address: z267.string().nullish(),
  connectionTypeEnum: z267.enum(["INSECURE", "TLS"]).nullish(),
  status: z267.string().nullish(),
  tlsConfig: TlsConfig.nullish()
});

// src/generated-definitions/AppConfig.ts
import { z as z268 } from "zod";
var AppConfig = z268.object({ appName: z268.string() });

// src/generated-definitions/BaseTlsConfig.ts
import { z as z269 } from "zod";
var BaseTlsConfig = z269.object({ rootCertFileName: z269.string().nullish() });

// src/generated-definitions/PublicCustomConfigInfo.ts
import { z as z270 } from "zod";
var PublicCustomConfigInfo = z270.object({
  connectionType: z270.enum(["INSECURE", "TLS"]),
  grpcServerAddress: z270.string(),
  tlsConfig: BaseTlsConfig.nullish()
});

// src/generated-definitions/LootBoxPluginConfigInfo.ts
import { z as z271 } from "zod";
var LootBoxPluginConfigInfo = z271.object({
  appConfig: AppConfig.nullish(),
  customConfig: PublicCustomConfigInfo.nullish(),
  extendType: z271.enum(["APP", "CUSTOM"]).nullish(),
  namespace: z271.string()
});

// src/generated-definitions/RevocationPluginConfigInfo.ts
import { z as z272 } from "zod";
var RevocationPluginConfigInfo = z272.object({
  appConfig: AppConfig.nullish(),
  customConfig: PublicCustomConfigInfo.nullish(),
  extendType: z272.enum(["APP", "CUSTOM"]).nullish(),
  namespace: z272.string()
});

// src/generated-definitions/SectionPluginConfigInfo.ts
import { z as z273 } from "zod";
var SectionPluginConfigInfo = z273.object({
  appConfig: AppConfig.nullish(),
  customConfig: PublicCustomConfigInfo.nullish(),
  extendType: z273.enum(["APP", "CUSTOM"]).nullish(),
  namespace: z273.string()
});

// src/generated-definitions/ServicePluginConfigInfo.ts
import { z as z274 } from "zod";
var ServicePluginConfigInfo = z274.object({ grpcServerAddress: z274.string().nullish(), namespace: z274.string().nullish() });

// src/generated-admin/endpoints/ServicePluginConfigAdmin$.ts
import { Validate as Validate29 } from "@accelbyte/sdk";
import { z as z275 } from "zod";
var ServicePluginConfigAdmin$ = class {
  // @ts-ignore
  // prettier-ignore
  constructor(axiosInstance, namespace, useSchemaValidation = true) {
    this.axiosInstance = axiosInstance;
    this.namespace = namespace;
    this.useSchemaValidation = useSchemaValidation;
  }
  /**
   * @deprecated
   * Delete service plugin config
   */
  deleteConfigServicePlugin() {
    const params = {};
    const url = "/platform/admin/namespaces/{namespace}/configs/servicePlugin".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.delete(url, { params });
    return Validate29.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, z275.unknown(), "z.unknown()");
  }
  /**
   * @deprecated
   * Get service plugin config
   */
  getConfigsServicePlugin() {
    const params = {};
    const url = "/platform/admin/namespaces/{namespace}/configs/servicePlugin".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.get(url, { params });
    return Validate29.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      ServicePluginConfigInfo,
      "ServicePluginConfigInfo"
    );
  }
  /**
   * @deprecated
   * Update catalog config. Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: updated service plugin config&lt;/li&gt;&lt;/ul&gt;
   */
  updateConfigServicePlugin(data) {
    const params = {};
    const url = "/platform/admin/namespaces/{namespace}/configs/servicePlugin".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.put(url, data, { params });
    return Validate29.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      ServicePluginConfigInfo,
      "ServicePluginConfigInfo"
    );
  }
  /**
   * Delete service plugin config.
   */
  deleteCatalogPluginLootbox() {
    const params = {};
    const url = "/platform/admin/namespaces/{namespace}/catalog/plugins/lootbox".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.delete(url, { params });
    return Validate29.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, z275.unknown(), "z.unknown()");
  }
  /**
   * Get lootbox plugin config.
   */
  getCatalogPluginsLootbox() {
    const params = {};
    const url = "/platform/admin/namespaces/{namespace}/catalog/plugins/lootbox".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.get(url, { params });
    return Validate29.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      LootBoxPluginConfigInfo,
      "LootBoxPluginConfigInfo"
    );
  }
  /**
   * Update lootbox plugin config. Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: updated service plugin config&lt;/li&gt;&lt;/ul&gt;
   */
  updateCatalogPluginLootbox(data) {
    const params = {};
    const url = "/platform/admin/namespaces/{namespace}/catalog/plugins/lootbox".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.put(url, data, { params });
    return Validate29.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      LootBoxPluginConfigInfo,
      "LootBoxPluginConfigInfo"
    );
  }
  /**
   * Delete section plugin config.
   */
  deleteCatalogPluginSection() {
    const params = {};
    const url = "/platform/admin/namespaces/{namespace}/catalog/plugins/section".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.delete(url, { params });
    return Validate29.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, z275.unknown(), "z.unknown()");
  }
  /**
   * Get section plugin config.
   */
  getCatalogPluginsSection() {
    const params = {};
    const url = "/platform/admin/namespaces/{namespace}/catalog/plugins/section".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.get(url, { params });
    return Validate29.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      SectionPluginConfigInfo,
      "SectionPluginConfigInfo"
    );
  }
  /**
   * Update section config. Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: updated service plugin config&lt;/li&gt;&lt;/ul&gt;
   */
  updateCatalogPluginSection(data) {
    const params = {};
    const url = "/platform/admin/namespaces/{namespace}/catalog/plugins/section".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.put(url, data, { params });
    return Validate29.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      SectionPluginConfigInfo,
      "SectionPluginConfigInfo"
    );
  }
  /**
   * Delete service plugin config.
   */
  deleteRevocationPluginRevocation() {
    const params = {};
    const url = "/platform/admin/namespaces/{namespace}/revocation/plugins/revocation".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.delete(url, { params });
    return Validate29.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, z275.unknown(), "z.unknown()");
  }
  /**
   * Get revocation plugin config.
   */
  getRevocationPluginsRevocation() {
    const params = {};
    const url = "/platform/admin/namespaces/{namespace}/revocation/plugins/revocation".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.get(url, { params });
    return Validate29.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      RevocationPluginConfigInfo,
      "RevocationPluginConfigInfo"
    );
  }
  /**
   * Update revocation plugin config. Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: updated service plugin config&lt;/li&gt;&lt;/ul&gt;
   */
  updateRevocationPluginRevocation(data) {
    const params = {};
    const url = "/platform/admin/namespaces/{namespace}/revocation/plugins/revocation".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.put(url, data, { params });
    return Validate29.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      RevocationPluginConfigInfo,
      "RevocationPluginConfigInfo"
    );
  }
  /**
   * Get lootbox plugin gRPC info.
   */
  getCatalogPluginsLootboxGrpcInfo(queryParams) {
    const params = { ...queryParams };
    const url = "/platform/admin/namespaces/{namespace}/catalog/plugins/lootbox/grpcInfo".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.get(url, { params });
    return Validate29.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, GrpcServerInfo, "GrpcServerInfo");
  }
  /**
   * Upload lootbox plugin custom config tls cert.Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: updated service plugin config&lt;/li&gt;&lt;/ul&gt;
   */
  updateCatalogPluginLootboxCustomConfigCert(data) {
    const params = {};
    const url = "/platform/admin/namespaces/{namespace}/catalog/plugins/lootbox/customConfig/cert".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.put(url, data, { params });
    return Validate29.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      LootBoxPluginConfigInfo,
      "LootBoxPluginConfigInfo"
    );
  }
  /**
   * Upload section plugin custom config tls cert.Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: updated service plugin config&lt;/li&gt;&lt;/ul&gt;
   */
  updateCatalogPluginSectionCustomConfigCert(data) {
    const params = {};
    const url = "/platform/admin/namespaces/{namespace}/catalog/plugins/section/customConfig/cert".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.put(url, data, { params });
    return Validate29.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      SectionPluginConfigInfo,
      "SectionPluginConfigInfo"
    );
  }
  /**
   * Upload revocation plugin custom config tls cert.Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: updated service plugin config&lt;/li&gt;&lt;/ul&gt;
   */
  updateRevocationPluginRevocationRevocationCustomConfigCert(data) {
    const params = {};
    const url = "/platform/admin/namespaces/{namespace}/revocation/plugins/revocation/revocation/customConfig/cert".replace(
      "{namespace}",
      this.namespace
    );
    const resultPromise = this.axiosInstance.put(url, data, { params });
    return Validate29.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      RevocationPluginConfigInfo,
      "RevocationPluginConfigInfo"
    );
  }
};

// src/generated-admin/endpoints/SessionPlatformAdmin$.ts
import { Validate as Validate30 } from "@accelbyte/sdk";
import { z as z276 } from "zod";
var SessionPlatformAdmin$ = class {
  // @ts-ignore
  // prettier-ignore
  constructor(axiosInstance, namespace, useSchemaValidation = true) {
    this.axiosInstance = axiosInstance;
    this.namespace = namespace;
    this.useSchemaValidation = useSchemaValidation;
  }
  /**
   * This API is used to register/update a session on xbox.
   */
  updateSessionXbl_ByUserId(userId, data) {
    const params = {};
    const url = "/platform/admin/namespaces/{namespace}/users/{userId}/session/xbl".replace("{namespace}", this.namespace).replace("{userId}", userId);
    const resultPromise = this.axiosInstance.put(url, data, { params });
    return Validate30.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, z276.unknown(), "z.unknown()");
  }
};

// src/generated-definitions/CatalogConfigInfo.ts
import { z as z277 } from "zod";
var CatalogConfigInfo = z277.object({ enableInventoryCheck: z277.boolean() });

// src/generated-definitions/CatalogDefinitionInfo.ts
import { z as z278 } from "zod";
var CatalogDefinitionInfo = z278.object({
  field: z278.string(),
  itemType: z278.enum(["APP", "BUNDLE", "CODE", "COINS", "EXTENSION", "INGAMEITEM", "LOOTBOX", "MEDIA", "OPTIONBOX", "SEASON", "SUBSCRIPTION"]).nullish(),
  name: z278.string(),
  required: z278.boolean()
});

// src/generated-definitions/CatalogDefinitionInfoArray.ts
import { z as z279 } from "zod";
var CatalogDefinitionInfoArray = z279.array(CatalogDefinitionInfo);

// src/generated-definitions/ImportErrorDetails.ts
import { z as z280 } from "zod";
var ImportErrorDetails = z280.object({
  errorCode: z280.number().int().nullish(),
  errorField: z280.string().nullish(),
  errorMessage: z280.string().nullish(),
  errorValue: z280.string().nullish(),
  messageVariables: z280.record(z280.string()).nullish()
});

// src/generated-definitions/ImportStoreAppInfo.ts
import { z as z281 } from "zod";
var ImportStoreAppInfo = z281.object({ itemId: z281.string().nullish() });

// src/generated-definitions/ImportStoreCategoryInfo.ts
import { z as z282 } from "zod";
var ImportStoreCategoryInfo = z282.object({
  categoryId: z282.string().nullish(),
  categoryPath: z282.string().nullish(),
  namespace: z282.string().nullish()
});

// src/generated-definitions/ImportStoreItemInfo.ts
import { z as z283 } from "zod";
var ImportStoreItemInfo = z283.object({
  categoryPath: z283.string().nullish(),
  itemId: z283.string().nullish(),
  itemType: z283.enum([
    "APP",
    "BUNDLE",
    "CODE",
    "COINS",
    "EXTENSION",
    "INGAMEITEM",
    "LOOTBOX",
    "MEDIA",
    "OPTIONBOX",
    "SEASON",
    "SUBSCRIPTION"
  ]),
  localizations: z283.record(Localization).nullish(),
  name: z283.string().nullish(),
  sku: z283.string().nullish()
});

// src/generated-definitions/ImportStoreSectionInfo.ts
import { z as z284 } from "zod";
var ImportStoreSectionInfo = z284.object({ name: z284.string().nullish(), sectionId: z284.string().nullish() });

// src/generated-definitions/ImportStoreViewInfo.ts
import { z as z285 } from "zod";
var ImportStoreViewInfo = z285.object({ name: z285.string().nullish(), viewId: z285.string().nullish() });

// src/generated-definitions/ImportStoreError.ts
import { z as z286 } from "zod";
var ImportStoreError = z286.object({
  app: ImportStoreAppInfo.nullish(),
  category: ImportStoreCategoryInfo.nullish(),
  errors: z286.array(ImportErrorDetails).nullish(),
  item: ImportStoreItemInfo.nullish(),
  section: ImportStoreSectionInfo.nullish(),
  type: z286.enum(["APP", "CATEGORY", "ITEM", "SECTION", "STORE", "VIEW"]).nullish(),
  view: ImportStoreViewInfo.nullish()
});

// src/generated-definitions/ImportStoreHistoryInfo.ts
import { z as z287 } from "zod";
var ImportStoreHistoryInfo = z287.object({
  createdAt: z287.string(),
  errors: z287.array(ImportStoreError).nullish(),
  id: z287.string(),
  importFileFormat: z287.enum(["CSV", "JSON"]),
  initiatedBy: z287.string(),
  namespace: z287.string(),
  note: z287.string().nullish(),
  storeId: z287.string(),
  success: z287.boolean()
});

// src/generated-definitions/ImportStoreHistoryPagingResult.ts
import { z as z288 } from "zod";
var ImportStoreHistoryPagingResult = z288.object({
  data: z288.array(ImportStoreHistoryInfo),
  paging: Paging.nullish(),
  total: z288.number().int().nullish()
});

// src/generated-definitions/ImportStoreResult.ts
import { z as z289 } from "zod";
var ImportStoreResult = z289.object({
  errors: z289.array(ImportStoreError).nullish(),
  storeInfo: StoreInfo.nullish(),
  success: z289.boolean().nullish()
});

// src/generated-definitions/StoreBackupInfo.ts
import { z as z290 } from "zod";
var StoreBackupInfo = z290.object({
  autoBackup: z290.boolean(),
  createdAt: z290.string(),
  id: z290.string(),
  name: z290.string(),
  storeId: z290.string(),
  updatedAt: z290.string()
});

// src/generated-definitions/StoreInfoArray.ts
import { z as z291 } from "zod";
var StoreInfoArray = z291.array(StoreInfo);

// src/generated-admin/endpoints/StoreAdmin$.ts
import { Validate as Validate31 } from "@accelbyte/sdk";
import { z as z292 } from "zod";
var StoreAdmin$ = class {
  // @ts-ignore
  // prettier-ignore
  constructor(axiosInstance, namespace, useSchemaValidation = true) {
    this.axiosInstance = axiosInstance;
    this.namespace = namespace;
    this.useSchemaValidation = useSchemaValidation;
  }
  /**
   * This API is used to list stores in a namespace.&lt;p&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: the list of stores&lt;/li&gt;&lt;/ul&gt;
   */
  getStores() {
    const params = {};
    const url = "/platform/admin/namespaces/{namespace}/stores".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.get(url, { params });
    return Validate31.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, StoreInfoArray, "StoreInfoArray");
  }
  /**
   * This API is used to create a non published store in a namespace.&lt;p&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: created store data&lt;/li&gt;&lt;/ul&gt;
   */
  createStore(data) {
    const params = {};
    const url = "/platform/admin/namespaces/{namespace}/stores".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.post(url, data, { params });
    return Validate31.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, StoreInfo, "StoreInfo");
  }
  /**
   * @deprecated
   * This API is used to import a store.&lt;p&gt;This api has been deprecated, pls use /v2/admin/namespaces/{namespace}/stores/import to import store.&lt;br&gt;
   */
  updateStoreImport(data, queryParams) {
    const params = { ...queryParams };
    const url = "/platform/admin/namespaces/{namespace}/stores/import".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.put(url, data, { params });
    return Validate31.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, StoreInfo, "StoreInfo");
  }
  /**
   * Get catalog config.
   */
  getCatalogConfigs() {
    const params = {};
    const url = "/platform/admin/namespaces/{namespace}/catalog/configs".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.get(url, { params });
    return Validate31.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, CatalogConfigInfo, "CatalogConfigInfo");
  }
  /**
   * Update catalog config. Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: updated catalog config&lt;/li&gt;&lt;/ul&gt;
   */
  updateCatalogConfig(data) {
    const params = {};
    const url = "/platform/admin/namespaces/{namespace}/catalog/configs".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.put(url, data, { params });
    return Validate31.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, CatalogConfigInfo, "CatalogConfigInfo");
  }
  /**
   * This API is used to delete a store. Only non published store can be deleted.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: store&lt;/li&gt;&lt;/ul&gt;
   */
  deleteStore_ByStoreId(storeId) {
    const params = {};
    const url = "/platform/admin/namespaces/{namespace}/stores/{storeId}".replace("{namespace}", this.namespace).replace("{storeId}", storeId);
    const resultPromise = this.axiosInstance.delete(url, { params });
    return Validate31.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, StoreInfo, "StoreInfo");
  }
  /**
   * This API is used to get a store.&lt;p&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: store data&lt;/li&gt;&lt;/ul&gt;
   */
  getStore_ByStoreId(storeId) {
    const params = {};
    const url = "/platform/admin/namespaces/{namespace}/stores/{storeId}".replace("{namespace}", this.namespace).replace("{storeId}", storeId);
    const resultPromise = this.axiosInstance.get(url, { params });
    return Validate31.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, StoreInfo, "StoreInfo");
  }
  /**
   * This API is used to Update a store basic info.&lt;p&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: updated store data&lt;/li&gt;&lt;/ul&gt;
   */
  updateStore_ByStoreId(storeId, data) {
    const params = {};
    const url = "/platform/admin/namespaces/{namespace}/stores/{storeId}".replace("{namespace}", this.namespace).replace("{storeId}", storeId);
    const resultPromise = this.axiosInstance.put(url, data, { params });
    return Validate31.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, StoreInfo, "StoreInfo");
  }
  /**
   * This API is used to delete published store including category and items before release to public.&lt;p&gt;&lt;b&gt;Warning: Please do not use this API once published to public user.&lt;/b&gt;
   */
  deleteStorePublished() {
    const params = {};
    const url = "/platform/admin/namespaces/{namespace}/stores/published".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.delete(url, { params });
    return Validate31.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, StoreInfo, "StoreInfo");
  }
  /**
   * This API is used to get a published store basic info, exclude category and item information.&lt;p&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: store data&lt;/li&gt;&lt;/ul&gt;
   */
  getStoresPublished() {
    const params = {};
    const url = "/platform/admin/namespaces/{namespace}/stores/published".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.get(url, { params });
    return Validate31.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, StoreInfo, "StoreInfo");
  }
  /**
   * This API is used to import a store.
   */
  updateStoreImport_v2(data, queryParams) {
    const params = { strictMode: true, ...queryParams };
    const url = "/platform/v2/admin/namespaces/{namespace}/stores/import".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.put(url, data, { params });
    return Validate31.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, ImportStoreResult, "ImportStoreResult");
  }
  /**
   * This API is used to export a store to CSV format
   */
  createStoreExportByCsv(data) {
    const params = {};
    const url = "/platform/admin/namespaces/{namespace}/stores/exportByCSV".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.post(url, data, { params });
    return Validate31.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, z292.unknown(), "z.unknown()");
  }
  /**
   * This API is used to clone a store. Usually clone a draft store to published store because published store can&#39;t directly edit content.&lt;p&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: clone store info&lt;/li&gt;&lt;/ul&gt;
   */
  updateClone_ByStoreId(storeId, queryParams) {
    const params = { ...queryParams };
    const url = "/platform/admin/namespaces/{namespace}/stores/{storeId}/clone".replace("{namespace}", this.namespace).replace("{storeId}", storeId);
    const resultPromise = this.axiosInstance.put(url, null, { params });
    return Validate31.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, StoreInfo, "StoreInfo");
  }
  /**
   * @deprecated
   * This API is used to export a store.&lt;p&gt;This api has been deprecated, pls use /v2/admin/namespaces/{namespace}/stores/export to export store.&lt;br&gt;
   */
  getExport_ByStoreId(storeId) {
    const params = {};
    const url = "/platform/admin/namespaces/{namespace}/stores/{storeId}/export".replace("{namespace}", this.namespace).replace("{storeId}", storeId);
    const resultPromise = this.axiosInstance.get(url, { params });
    return Validate31.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, z292.unknown(), "z.unknown()");
  }
  /**
   * This API is used to get a store&#39;s backup. &lt;p&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: store backup info&lt;/li&gt;&lt;/ul&gt;
   */
  getStoresPublishedBackup() {
    const params = {};
    const url = "/platform/admin/namespaces/{namespace}/stores/published/backup".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.get(url, { params });
    return Validate31.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, StoreBackupInfo, "StoreBackupInfo");
  }
  /**
   * This API is used to get catalog definition for import/export store by CSV&lt;p&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: catalog definition&lt;/li&gt;&lt;/ul&gt;
   */
  getStoresCatalogDefinition(queryParams) {
    const params = { ...queryParams };
    const url = "/platform/admin/namespaces/{namespace}/stores/catalogDefinition".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.get(url, { params });
    return Validate31.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      CatalogDefinitionInfoArray,
      "CatalogDefinitionInfoArray"
    );
  }
  /**
   * This API is used to rollback a published store. &lt;p&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: updated store info&lt;/li&gt;&lt;/ul&gt;
   */
  updateStorePublishedRollback() {
    const params = {};
    const url = "/platform/admin/namespaces/{namespace}/stores/published/rollback".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.put(url, null, { params });
    return Validate31.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, StoreInfo, "StoreInfo");
  }
  /**
   * This API is used to export a whole or partial store.
   */
  createExport_ByStoreId_v2(storeId, data) {
    const params = {};
    const url = "/platform/v2/admin/namespaces/{namespace}/stores/{storeId}/export".replace("{namespace}", this.namespace).replace("{storeId}", storeId);
    const resultPromise = this.axiosInstance.post(url, data, { params });
    return Validate31.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, z292.unknown(), "z.unknown()");
  }
  /**
   * This API is used to download store csv templates for store importing by CSV feature
   */
  getStoresDownloadCsvTemplates() {
    const params = {};
    const url = "/platform/admin/namespaces/{namespace}/stores/downloadCSVTemplates".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.get(url, { params });
    return Validate31.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, z292.unknown(), "z.unknown()");
  }
  /**
   * This API is used to import a store by CSV format.
   */
  createImportByCsv_ByStoreId(storeId, data) {
    const params = {};
    const url = "/platform/admin/namespaces/{namespace}/stores/{storeId}/importByCSV".replace("{namespace}", this.namespace).replace("{storeId}", storeId);
    const resultPromise = this.axiosInstance.post(url, data, { params });
    return Validate31.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, ImportStoreResult, "ImportStoreResult");
  }
  /**
   * This API is used to query import store history
   */
  getImportHistory_ByStoreId(storeId, queryParams) {
    const params = { limit: 20, sortBy: "createdAt:desc", ...queryParams };
    const url = "/platform/admin/namespaces/{namespace}/stores/{storeId}/import/history".replace("{namespace}", this.namespace).replace("{storeId}", storeId);
    const resultPromise = this.axiosInstance.get(url, { params });
    return Validate31.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      ImportStoreHistoryPagingResult,
      "ImportStoreHistoryPagingResult"
    );
  }
};

// src/generated-definitions/BillingAccount.ts
import { z as z293 } from "zod";
var BillingAccount = z293.object({
  additionalData: AdditionalData.nullish(),
  paymentMethod: z293.string().nullish(),
  paymentProvider: z293.enum(["ADYEN", "ALIPAY", "CHECKOUT", "NEONPAY", "PAYPAL", "STRIPE", "WALLET", "WXPAY", "XSOLLA"]).nullish()
});

// src/generated-definitions/BillingHistoryInfo.ts
import { z as z294 } from "zod";
var BillingHistoryInfo = z294.object({
  amount: z294.number().int(),
  billingAccount: BillingAccount.nullish(),
  changeBillingAccount: z294.boolean().nullish(),
  createdAt: z294.string(),
  currency: CurrencySummary,
  description: z294.string().nullish(),
  extTxId: z294.string().nullish(),
  itemId: z294.string(),
  namespace: z294.string(),
  paymentOrderNo: z294.string().nullish(),
  recurringOrderNo: z294.string(),
  retryAttempted: z294.number().int().nullish(),
  sandbox: z294.boolean(),
  sku: z294.string().nullish(),
  status: z294.enum(["CHARGED", "CHARGE_FAILED", "INIT", "REFUNDED", "REFUND_FAILED"]),
  statusReason: z294.string().nullish(),
  subscriptionId: z294.string(),
  subtotalPrice: z294.number().int().nullish(),
  title: z294.string(),
  totalPrice: z294.number().int().nullish(),
  totalTax: z294.number().int().nullish(),
  txEndTime: z294.string().nullish(),
  updatedAt: z294.string(),
  userId: z294.string()
});

// src/generated-definitions/BillingHistoryPagingSlicedResult.ts
import { z as z295 } from "zod";
var BillingHistoryPagingSlicedResult = z295.object({ data: z295.array(BillingHistoryInfo), paging: Paging.nullish() });

// src/generated-definitions/RecurringChargeResult.ts
import { z as z296 } from "zod";
var RecurringChargeResult = z296.object({ code: z296.string().nullish(), detail: z296.string().nullish(), triggered: z296.boolean() });

// src/generated-definitions/Subscribable.ts
import { z as z297 } from "zod";
var Subscribable = z297.object({ subscribable: z297.boolean() });

// src/generated-definitions/SubscriptionActivityInfo.ts
import { z as z298 } from "zod";
var SubscriptionActivityInfo = z298.object({
  action: z298.enum(["CANCEL", "CHANGE_BILLING_ACCOUNT", "GRANT_DAYS", "IMMEDIATE_CANCEL", "RESUBSCRIBE", "SUBSCRIBE"]),
  chargedCycles: z298.number().int(),
  createdAt: z298.string(),
  currentCycle: z298.number().int(),
  grantDays: z298.number().int().nullish(),
  inFixedCycleTrial: z298.boolean().nullish(),
  inFixedFreeDays: z298.boolean().nullish(),
  namespace: z298.string(),
  operator: z298.string(),
  reason: z298.string().nullish(),
  subscribedBy: z298.enum(["PLATFORM", "USER"]),
  subscriptionId: z298.string(),
  trialedCycles: z298.number().int().nullish(),
  updatedAt: z298.string(),
  userId: z298.string()
});

// src/generated-definitions/SubscriptionActivityPagingSlicedResult.ts
import { z as z299 } from "zod";
var SubscriptionActivityPagingSlicedResult = z299.object({ data: z299.array(SubscriptionActivityInfo), paging: Paging.nullish() });

// src/generated-definitions/SubscriptionInfo.ts
import { z as z300 } from "zod";
var SubscriptionInfo = z300.object({
  billingAccount: BillingAccount.nullish(),
  chargeStatus: z300.enum(["CHARGED", "CHARGE_FAILED", "NEVER", "RECURRING_CHARGING", "SETUP"]),
  chargedCycles: z300.number().int().nullish(),
  createdAt: z300.string(),
  currency: CurrencySummary.nullish(),
  currentCycle: z300.number().int().nullish(),
  currentPeriodEnd: z300.string().nullish(),
  currentPeriodStart: z300.string().nullish(),
  description: z300.string().nullish(),
  end: z300.string().nullish(),
  entitlements: z300.array(EntitlementSummary).nullish(),
  firstSubscribe: z300.boolean().nullish(),
  id: z300.string(),
  inFixedCycleTrial: z300.boolean(),
  inFixedFreeDays: z300.boolean(),
  itemId: z300.string(),
  itemSnapshot: ItemSnapshot.nullish(),
  language: z300.string().nullish(),
  namespace: z300.string(),
  nextBillingDate: z300.string().nullish(),
  paid: z300.boolean().nullish(),
  paymentFlowRequired: z300.boolean(),
  paymentOrderNo: z300.string().nullish(),
  paymentStationUrl: z300.string().nullish(),
  price: z300.number().int().nullish(),
  recurring: Recurring,
  region: z300.string().nullish(),
  retryAttempted: z300.number().int().nullish(),
  returnUrl: z300.string().nullish(),
  sandbox: z300.boolean().nullish(),
  sku: z300.string().nullish(),
  source: z300.string().nullish(),
  start: z300.string().nullish(),
  status: z300.enum(["ACTIVE", "CANCELLED", "EXPIRED", "INIT"]),
  subscribedAt: z300.string().nullish(),
  subscribedBy: z300.enum(["PLATFORM", "USER"]).nullish(),
  title: z300.string().nullish(),
  trialPrice: z300.number().int().nullish(),
  trialedCycles: z300.number().int().nullish(),
  unsubscribeReason: z300.string().nullish(),
  unsubscribedAt: z300.string().nullish(),
  updatedAt: z300.string(),
  userId: z300.string()
});

// src/generated-definitions/SubscriptionPagingSlicedResult.ts
import { z as z301 } from "zod";
var SubscriptionPagingSlicedResult = z301.object({ data: z301.array(SubscriptionInfo), paging: Paging.nullish() });

// src/generated-admin/endpoints/SubscriptionAdmin$.ts
import { Validate as Validate32 } from "@accelbyte/sdk";
import { z as z302 } from "zod";
var SubscriptionAdmin$ = class {
  // @ts-ignore
  // prettier-ignore
  constructor(axiosInstance, namespace, useSchemaValidation = true) {
    this.axiosInstance = axiosInstance;
    this.namespace = namespace;
    this.useSchemaValidation = useSchemaValidation;
  }
  /**
   * Query subscriptions.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: paginated subscriptions&lt;/li&gt;&lt;/ul&gt;
   */
  getSubscriptions(queryParams) {
    const params = { limit: 20, ...queryParams };
    const url = "/platform/admin/namespaces/{namespace}/subscriptions".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.get(url, { params });
    return Validate32.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      SubscriptionPagingSlicedResult,
      "SubscriptionPagingSlicedResult"
    );
  }
  /**
   * Query user subscriptions.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: paginated subscription&lt;/li&gt;&lt;/ul&gt;
   */
  getSubscriptions_ByUserId(userId, queryParams) {
    const params = { limit: 20, ...queryParams };
    const url = "/platform/admin/namespaces/{namespace}/users/{userId}/subscriptions".replace("{namespace}", this.namespace).replace("{userId}", userId);
    const resultPromise = this.axiosInstance.get(url, { params });
    return Validate32.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      SubscriptionPagingSlicedResult,
      "SubscriptionPagingSlicedResult"
    );
  }
  /**
   * Get user subscription activity.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: paginated subscription activity&lt;/li&gt;&lt;/ul&gt;
   */
  getSubscriptionsActivities_ByUserId(userId, queryParams) {
    const params = { limit: 20, ...queryParams };
    const url = "/platform/admin/namespaces/{namespace}/users/{userId}/subscriptions/activities".replace("{namespace}", this.namespace).replace("{userId}", userId);
    const resultPromise = this.axiosInstance.get(url, { params });
    return Validate32.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      SubscriptionActivityPagingSlicedResult,
      "SubscriptionActivityPagingSlicedResult"
    );
  }
  /**
   * &lt;b&gt;[TEST FACILITY ONLY] Forbidden in live environment. &lt;/b&gt; Recurring charge subscription, it will trigger recurring charge if the USER subscription status is ACTIVE, nextBillingDate is before now and no fail recurring charge within X(default 12) hours.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: recurring charge result&lt;/li&gt;&lt;/ul&gt;
   */
  updateRecurring_BySubscriptionId(subscriptionId) {
    const params = {};
    const url = "/platform/admin/namespaces/{namespace}/subscriptions/{subscriptionId}/recurring".replace("{namespace}", this.namespace).replace("{subscriptionId}", subscriptionId);
    const resultPromise = this.axiosInstance.put(url, null, { params });
    return Validate32.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, RecurringChargeResult, "RecurringChargeResult");
  }
  /**
   * &lt;b&gt;[TEST FACILITY ONLY] Forbidden in live environment. &lt;/b&gt; Delete user subscription.
   */
  deleteSubscription_ByUserId_BySubscriptionId(userId, subscriptionId) {
    const params = {};
    const url = "/platform/admin/namespaces/{namespace}/users/{userId}/subscriptions/{subscriptionId}".replace("{namespace}", this.namespace).replace("{userId}", userId).replace("{subscriptionId}", subscriptionId);
    const resultPromise = this.axiosInstance.delete(url, { params });
    return Validate32.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, z302.unknown(), "z.unknown()");
  }
  /**
   * Get user subscription.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: subscription&lt;/li&gt;&lt;/ul&gt;
   */
  getSubscription_ByUserId_BySubscriptionId(userId, subscriptionId) {
    const params = {};
    const url = "/platform/admin/namespaces/{namespace}/users/{userId}/subscriptions/{subscriptionId}".replace("{namespace}", this.namespace).replace("{userId}", userId).replace("{subscriptionId}", subscriptionId);
    const resultPromise = this.axiosInstance.get(url, { params });
    return Validate32.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, SubscriptionInfo, "SubscriptionInfo");
  }
  /**
   * Free subscribe by platform, can used by other justice service to redeem/reward the subscription.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: result subscription&lt;/li&gt;&lt;/ul&gt;
   */
  createSubscriptionPlatformSubscribe_ByUserId(userId, data) {
    const params = {};
    const url = "/platform/admin/namespaces/{namespace}/users/{userId}/subscriptions/platformSubscribe".replace("{namespace}", this.namespace).replace("{userId}", userId);
    const resultPromise = this.axiosInstance.post(url, data, { params });
    return Validate32.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, SubscriptionInfo, "SubscriptionInfo");
  }
  /**
   * Check user subscription subscribable by itemId, ACTIVE USER subscription can&#39;t do subscribe again.&lt;p&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: subscribable info&lt;/li&gt;&lt;/ul&gt;
   */
  getSubscriptionsSubscribableByItemId_ByUserId(userId, queryParams) {
    const params = { ...queryParams };
    const url = "/platform/admin/namespaces/{namespace}/users/{userId}/subscriptions/subscribable/byItemId".replace("{namespace}", this.namespace).replace("{userId}", userId);
    const resultPromise = this.axiosInstance.get(url, { params });
    return Validate32.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, Subscribable, "Subscribable");
  }
  /**
   * Grant days to a subscription, if grantDays is positive, it will add free days and push the next billing date by the amount of day.&lt;br&gt;if the grantDays is negative or zero, it only apply to active/cancelled subscription, remove days will decrease current period end, and move the next billing date closer.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: updated subscription&lt;/li&gt;&lt;/ul&gt;
   */
  updateGrant_ByUserId_BySubscriptionId(userId, subscriptionId, data) {
    const params = {};
    const url = "/platform/admin/namespaces/{namespace}/users/{userId}/subscriptions/{subscriptionId}/grant".replace("{namespace}", this.namespace).replace("{userId}", userId).replace("{subscriptionId}", subscriptionId);
    const resultPromise = this.axiosInstance.put(url, data, { params });
    return Validate32.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, SubscriptionInfo, "SubscriptionInfo");
  }
  /**
   * Cancel a subscription, only ACTIVE subscription can be cancelled. &lt;b&gt;Ensure successfully cancel, recommend at least 1 day before current period ends, otherwise it may be charging or charged.&lt;/b&gt;&lt;br&gt;Set immediate true, the subscription will be terminated immediately, otherwise till the end of current billing cycle.&lt;br&gt;Set force true, will ignore the error if subscription is during recurring charging.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: cancelled subscription&lt;/li&gt;&lt;/ul&gt;
   */
  updateCancel_ByUserId_BySubscriptionId(userId, subscriptionId, data, queryParams) {
    const params = { ...queryParams };
    const url = "/platform/admin/namespaces/{namespace}/users/{userId}/subscriptions/{subscriptionId}/cancel".replace("{namespace}", this.namespace).replace("{userId}", userId).replace("{subscriptionId}", subscriptionId);
    const resultPromise = this.axiosInstance.put(url, data, { params });
    return Validate32.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, SubscriptionInfo, "SubscriptionInfo");
  }
  /**
   * Get user subscription billing histories.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: paginated subscription billing history&lt;/li&gt;&lt;/ul&gt;
   */
  getHistory_ByUserId_BySubscriptionId(userId, subscriptionId, queryParams) {
    const params = { limit: 20, ...queryParams };
    const url = "/platform/admin/namespaces/{namespace}/users/{userId}/subscriptions/{subscriptionId}/history".replace("{namespace}", this.namespace).replace("{userId}", userId).replace("{subscriptionId}", subscriptionId);
    const resultPromise = this.axiosInstance.get(url, { params });
    return Validate32.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      BillingHistoryPagingSlicedResult,
      "BillingHistoryPagingSlicedResult"
    );
  }
  /**
   * &lt;b&gt;[SERVICE COMMUNICATION ONLY]&lt;/b&gt; This API is used as a web hook for payment notification from justice payment service.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: Process result&lt;/li&gt;&lt;/ul&gt;
   */
  createNotification_ByUserId_BySubscriptionId(userId, subscriptionId, data) {
    const params = {};
    const url = "/platform/admin/namespaces/{namespace}/users/{userId}/subscriptions/{subscriptionId}/notifications".replace("{namespace}", this.namespace).replace("{userId}", userId).replace("{subscriptionId}", subscriptionId);
    const resultPromise = this.axiosInstance.post(url, data, { params });
    return Validate32.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, z302.unknown(), "z.unknown()");
  }
};

// src/generated-definitions/TicketAcquireResult.ts
import { z as z303 } from "zod";
var TicketAcquireResult = z303.object({ values: z303.array(z303.string()).nullish() });

// src/generated-definitions/TicketBoothId.ts
import { z as z304 } from "zod";
var TicketBoothId = z304.object({ id: z304.string(), type: z304.enum(["CAMPAIGN", "KEYGROUP"]) });

// src/generated-definitions/TicketDynamicInfo.ts
import { z as z305 } from "zod";
var TicketDynamicInfo = z305.object({ availableSaleCount: z305.number().int() });

// src/generated-definitions/TicketSaleIncrementResult.ts
import { z as z306 } from "zod";
var TicketSaleIncrementResult = z306.object({ maxSaleCount: z306.number().int(), success: z306.boolean() });

// src/generated-admin/endpoints/TicketAdmin$.ts
import { Validate as Validate33 } from "@accelbyte/sdk";
import { z as z307 } from "zod";
var TicketAdmin$ = class {
  // @ts-ignore
  // prettier-ignore
  constructor(axiosInstance, namespace, useSchemaValidation = true) {
    this.axiosInstance = axiosInstance;
    this.namespace = namespace;
    this.useSchemaValidation = useSchemaValidation;
  }
  /**
   * &lt;b&gt;[SERVICE COMMUNICATION ONLY]&lt;/b&gt; Get ticket(code/key) dynamic based on booth name.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: ticket dynamic&lt;/li&gt;&lt;/ul&gt;
   */
  getTicket_ByBoothName(boothName) {
    const params = {};
    const url = "/platform/admin/namespaces/{namespace}/tickets/{boothName}".replace("{namespace}", this.namespace).replace("{boothName}", boothName);
    const resultPromise = this.axiosInstance.get(url, { params });
    return Validate33.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, TicketDynamicInfo, "TicketDynamicInfo");
  }
  /**
   * Get ticket(code/key) booth ID.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: ticket booth id&lt;/li&gt;&lt;/ul&gt;
   */
  getId_ByBoothName(boothName) {
    const params = {};
    const url = "/platform/admin/namespaces/{namespace}/tickets/{boothName}/id".replace("{namespace}", this.namespace).replace("{boothName}", boothName);
    const resultPromise = this.axiosInstance.get(url, { params });
    return Validate33.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, TicketBoothId, "TicketBoothId");
  }
  /**
   * &lt;b&gt;[SERVICE COMMUNICATION ONLY]&lt;/b&gt; Decrease ticket(code/key) sale if requested orderNo is already increased.
   */
  updateDecrement_ByBoothName(boothName, data) {
    const params = {};
    const url = "/platform/admin/namespaces/{namespace}/tickets/{boothName}/decrement".replace("{namespace}", this.namespace).replace("{boothName}", boothName);
    const resultPromise = this.axiosInstance.put(url, data, { params });
    return Validate33.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, z307.unknown(), "z.unknown()");
  }
  /**
   * &lt;b&gt;[SERVICE COMMUNICATION ONLY]&lt;/b&gt; increase ticket(code/key) sale.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: Ticket sale increment result&lt;/li&gt;&lt;/ul&gt;
   */
  updateIncrement_ByBoothName(boothName, data) {
    const params = {};
    const url = "/platform/admin/namespaces/{namespace}/tickets/{boothName}/increment".replace("{namespace}", this.namespace).replace("{boothName}", boothName);
    const resultPromise = this.axiosInstance.put(url, data, { params });
    return Validate33.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      TicketSaleIncrementResult,
      "TicketSaleIncrementResult"
    );
  }
  /**
   * &lt;b&gt;[SERVICE COMMUNICATION ONLY]&lt;/b&gt; Acquire ticket(code/key) based on booth name.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: acquire result&lt;/li&gt;&lt;/ul&gt;
   */
  createTicket_ByUserId_ByBoothName(userId, boothName, data) {
    const params = {};
    const url = "/platform/admin/namespaces/{namespace}/users/{userId}/tickets/{boothName}".replace("{namespace}", this.namespace).replace("{userId}", userId).replace("{boothName}", boothName);
    const resultPromise = this.axiosInstance.post(url, data, { params });
    return Validate33.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, TicketAcquireResult, "TicketAcquireResult");
  }
};

// src/generated-definitions/CreditPayload.ts
import { z as z308 } from "zod";
var CreditPayload = z308.object({
  balanceOrigin: z308.enum(["Epic", "GooglePlay", "IOS", "Nintendo", "Oculus", "Other", "Playstation", "Steam", "System", "Twitch", "Xbox"]).nullish(),
  count: z308.number().int(),
  currencyCode: z308.string(),
  expireAt: z308.string().nullish()
});

// src/generated-definitions/DebitPayload.ts
import { z as z309 } from "zod";
var DebitPayload = z309.object({
  count: z309.number().int(),
  currencyCode: z309.string(),
  walletPlatform: z309.enum(["Epic", "GooglePlay", "IOS", "Nintendo", "Oculus", "Other", "Playstation", "Steam", "Xbox"])
});

// src/generated-definitions/FulFillItemPayload.ts
import { z as z310 } from "zod";
var FulFillItemPayload = z310.object({
  count: z310.number().int(),
  entitlementCollectionId: z310.string().nullish(),
  entitlementOrigin: z310.enum(["Epic", "GooglePlay", "IOS", "Nintendo", "Oculus", "Other", "Playstation", "Steam", "System", "Twitch", "Xbox"]).nullish(),
  itemIdentity: z310.string(),
  itemIdentityType: z310.enum(["ITEM_ID", "ITEM_SKU"])
});

// src/generated-definitions/RevokeEntitlementPayload.ts
import { z as z311 } from "zod";
var RevokeEntitlementPayload = z311.object({ count: z311.number().int().nullish(), entitlementId: z311.string() });

// src/generated-definitions/Operation.ts
import { z as z312 } from "zod";
var Operation = z312.object({
  creditPayload: CreditPayload.nullish(),
  debitPayload: DebitPayload.nullish(),
  fulFillItemPayload: FulFillItemPayload.nullish(),
  resultId: z312.string().nullish(),
  revokeEntitlementPayload: RevokeEntitlementPayload.nullish(),
  status: z312.enum(["FAILED", "INIT", "SKIPPED", "SUCCESS"]).nullish(),
  statusReason: z312.string().nullish(),
  type: z312.enum(["CREDIT_WALLET", "DEBIT_WALLET", "FULFILL_ITEM", "REVOKE_ENTITLEMENT"])
});

// src/generated-definitions/Action.ts
import { z as z313 } from "zod";
var Action = z313.object({
  operations: z313.array(Operation).nullish(),
  status: z313.enum(["FAILED", "INIT", "SKIPPED", "SUCCESS"]).nullish(),
  statusReason: z313.string().nullish(),
  userId: z313.string().nullish()
});

// src/generated-definitions/TradeChainActionHistoryInfo.ts
import { z as z314 } from "zod";
var TradeChainActionHistoryInfo = z314.object({
  actions: z314.array(Action).nullish(),
  metadata: z314.record(z314.any()).nullish(),
  namespace: z314.string().nullish(),
  status: z314.enum(["FAILED", "INIT", "SUCCESS"]).nullish(),
  statusReason: z314.string().nullish(),
  transactionId: z314.string().nullish(),
  type: z314.string().nullish(),
  userIds: z314.array(z314.string()).nullish()
});

// src/generated-definitions/TradeActionPagingSlicedResult.ts
import { z as z315 } from "zod";
var TradeActionPagingSlicedResult = z315.object({ data: z315.array(TradeChainActionHistoryInfo), paging: Paging.nullish() });

// src/generated-admin/endpoints/TradeActionAdmin$.ts
import { Validate as Validate34 } from "@accelbyte/sdk";
var TradeActionAdmin$ = class {
  // @ts-ignore
  // prettier-ignore
  constructor(axiosInstance, namespace, useSchemaValidation = true) {
    this.axiosInstance = axiosInstance;
    this.namespace = namespace;
    this.useSchemaValidation = useSchemaValidation;
  }
  /**
   * This API is used to create a chained operations&lt;p&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: chain action history&lt;/li&gt;&lt;li&gt;&lt;i&gt;FULFILL_ITEM operation supported item type&lt;/i&gt;: INGAMEITEM,LOOTBOX,OPTIONBOX&lt;/li&gt;&lt;/ul&gt;&lt;h2&gt;Restrictions for metadata&lt;/h2&gt; 1. Cannot use &lt;b&gt;&#34;.&#34;&lt;/b&gt; as the key name - &lt;pre&gt;{ &#34;data.2&#34;: &#34;value&#34; }&lt;/pre&gt; 2. Cannot use &lt;b&gt;&#34;$&#34;&lt;/b&gt; as the prefix in key names - &lt;pre&gt;{ &#34;$data&#34;: &#34;value&#34; }&lt;/pre&gt;
   */
  createTradeCommit(data) {
    const params = {};
    const url = "/platform/admin/namespaces/{namespace}/trade/commit".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.post(url, data, { params });
    return Validate34.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      TradeChainActionHistoryInfo,
      "TradeChainActionHistoryInfo"
    );
  }
  /**
   * This API is used to fetch a specific trade history using transaction ID&lt;p&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: trade history based on transaction ID&lt;/li&gt;&lt;/ul&gt;
   */
  getTrade_ByTransactionId(transactionId) {
    const params = {};
    const url = "/platform/admin/namespaces/{namespace}/trade/{transactionId}".replace("{namespace}", this.namespace).replace("{transactionId}", transactionId);
    const resultPromise = this.axiosInstance.get(url, { params });
    return Validate34.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      TradeChainActionHistoryInfo,
      "TradeChainActionHistoryInfo"
    );
  }
  /**
   * This API is used to fetch trade history based on the provided criteria&lt;p&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: trade history list based on criteria&lt;/li&gt;&lt;/ul&gt;
   */
  getTradeHistoryByCriteria(queryParams) {
    const params = { limit: 20, ...queryParams };
    const url = "/platform/admin/namespaces/{namespace}/trade/history/byCriteria".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.get(url, { params });
    return Validate34.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      TradeActionPagingSlicedResult,
      "TradeActionPagingSlicedResult"
    );
  }
};

// src/generated-definitions/FullViewInfo.ts
import { z as z316 } from "zod";
var FullViewInfo = z316.object({
  createdAt: z316.string(),
  displayOrder: z316.number().int(),
  localizations: z316.record(Localization),
  name: z316.string(),
  namespace: z316.string(),
  updatedAt: z316.string(),
  viewId: z316.string()
});

// src/generated-definitions/ListViewInfo.ts
import { z as z317 } from "zod";
var ListViewInfo = z317.object({
  createdAt: z317.string(),
  displayOrder: z317.number().int(),
  name: z317.string(),
  namespace: z317.string(),
  updatedAt: z317.string(),
  viewId: z317.string()
});

// src/generated-definitions/ListViewInfoArray.ts
import { z as z318 } from "zod";
var ListViewInfoArray = z318.array(ListViewInfo);

// src/generated-admin/endpoints/ViewAdmin$.ts
import { Validate as Validate35 } from "@accelbyte/sdk";
import { z as z319 } from "zod";
var ViewAdmin$ = class {
  // @ts-ignore
  // prettier-ignore
  constructor(axiosInstance, namespace, useSchemaValidation = true) {
    this.axiosInstance = axiosInstance;
    this.namespace = namespace;
    this.useSchemaValidation = useSchemaValidation;
  }
  /**
   * This API is used to list all views.&lt;p&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: the list of views&lt;/li&gt;&lt;/ul&gt;
   */
  getViews(queryParams) {
    const params = { ...queryParams };
    const url = "/platform/admin/namespaces/{namespace}/views".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.get(url, { params });
    return Validate35.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, ListViewInfoArray, "ListViewInfoArray");
  }
  /**
   * This API is used to create a view.&lt;p&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: created a view&lt;/li&gt;&lt;/ul&gt;&lt;h2&gt;Restrictions for localization extension&lt;/h2&gt; 1. Cannot use &lt;b&gt;&#34;.&#34;&lt;/b&gt; as the key name - &lt;pre&gt;{ &#34;data.2&#34;: &#34;value&#34; }&lt;/pre&gt; 2. Cannot use &lt;b&gt;&#34;$&#34;&lt;/b&gt; as the prefix in key names - &lt;pre&gt;{ &#34;$data&#34;: &#34;value&#34; }&lt;/pre&gt;
   */
  createView(data, queryParams) {
    const params = { ...queryParams };
    const url = "/platform/admin/namespaces/{namespace}/views".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.post(url, data, { params });
    return Validate35.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, FullViewInfo, "FullViewInfo");
  }
  /**
   * This API is used to delete a view.It will also delete all the related sections
   */
  deleteView_ByViewId(viewId, queryParams) {
    const params = { ...queryParams };
    const url = "/platform/admin/namespaces/{namespace}/views/{viewId}".replace("{namespace}", this.namespace).replace("{viewId}", viewId);
    const resultPromise = this.axiosInstance.delete(url, { params });
    return Validate35.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, z319.unknown(), "z.unknown()");
  }
  /**
   * This API is used to get a view.&lt;p&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: view data&lt;/li&gt;&lt;/ul&gt;
   */
  getView_ByViewId(viewId, queryParams) {
    const params = { ...queryParams };
    const url = "/platform/admin/namespaces/{namespace}/views/{viewId}".replace("{namespace}", this.namespace).replace("{viewId}", viewId);
    const resultPromise = this.axiosInstance.get(url, { params });
    return Validate35.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, FullViewInfo, "FullViewInfo");
  }
  /**
   * This API is used to update a view.&lt;p&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: updated view data&lt;/li&gt;&lt;/ul&gt;&lt;h2&gt;Restrictions for localization extension&lt;/h2&gt; 1. Cannot use &lt;b&gt;&#34;.&#34;&lt;/b&gt; as the key name - &lt;pre&gt;{ &#34;data.2&#34;: &#34;value&#34; }&lt;/pre&gt; 2. Cannot use &lt;b&gt;&#34;$&#34;&lt;/b&gt; as the prefix in key names - &lt;pre&gt;{ &#34;$data&#34;: &#34;value&#34; }&lt;/pre&gt;
   */
  updateView_ByViewId(viewId, data, queryParams) {
    const params = { ...queryParams };
    const url = "/platform/admin/namespaces/{namespace}/views/{viewId}".replace("{namespace}", this.namespace).replace("{viewId}", viewId);
    const resultPromise = this.axiosInstance.put(url, data, { params });
    return Validate35.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, FullViewInfo, "FullViewInfo");
  }
};

// src/generated-definitions/CreditRequest.ts
import { z as z320 } from "zod";
var CreditRequest = z320.object({
  amount: z320.number().int(),
  expireAt: z320.string().nullish(),
  metadata: z320.record(z320.any()).nullish(),
  origin: z320.enum(["Epic", "GooglePlay", "IOS", "Nintendo", "Oculus", "Other", "Playstation", "Steam", "System", "Twitch", "Xbox"]).nullish(),
  reason: z320.string().nullish(),
  source: z320.enum([
    "ACHIEVEMENT",
    "CONSUME_ENTITLEMENT",
    "DLC",
    "GIFT",
    "IAP",
    "IAP_CHARGEBACK_REVERSED",
    "OTHER",
    "PROMOTION",
    "PURCHASE",
    "REDEEM_CODE",
    "REFERRAL_BONUS",
    "REFUND",
    "REWARD",
    "SELL_BACK",
    "TRADE"
  ]).nullish()
});

// src/generated-definitions/CreditResult.ts
import { z as z321 } from "zod";
var CreditResult = z321.object({
  creditRequest: CreditRequest.nullish(),
  currencyCode: z321.string().nullish(),
  reason: z321.string().nullish(),
  userId: z321.string().nullish()
});

// src/generated-definitions/BulkCreditResult.ts
import { z as z322 } from "zod";
var BulkCreditResult = z322.object({
  failList: z322.array(CreditResult).nullish(),
  status: z322.enum(["FAIL", "PARTIAL_SUCCESS", "SUCCESS"]).nullish(),
  successList: z322.array(CreditResult).nullish()
});

// src/generated-definitions/DebitByCurrencyCodeRequest.ts
import { z as z323 } from "zod";
var DebitByCurrencyCodeRequest = z323.object({
  allowOverdraft: z323.boolean().nullish(),
  amount: z323.number().int(),
  balanceOrigin: z323.enum(["Epic", "GooglePlay", "IOS", "Nintendo", "Oculus", "Other", "Playstation", "Steam", "System", "Twitch", "Xbox"]).nullish(),
  balanceSource: z323.enum(["DLC_REVOCATION", "EXPIRATION", "IAP_REVOCATION", "ORDER_REVOCATION", "OTHER", "PAYMENT", "TRADE"]).nullish(),
  metadata: z323.record(z323.any()).nullish(),
  reason: z323.string().nullish()
});

// src/generated-definitions/DebitResult.ts
import { z as z324 } from "zod";
var DebitResult = z324.object({
  currencyCode: z324.string().nullish(),
  reason: z324.string().nullish(),
  request: DebitByCurrencyCodeRequest.nullish(),
  userId: z324.string().nullish()
});

// src/generated-definitions/BulkDebitResult.ts
import { z as z325 } from "zod";
var BulkDebitResult = z325.object({
  failList: z325.array(DebitResult).nullish(),
  status: z325.enum(["FAIL", "PARTIAL_SUCCESS", "SUCCESS"]).nullish(),
  successList: z325.array(DebitResult).nullish()
});

// src/generated-definitions/WalletInfo.ts
import { z as z326 } from "zod";
var WalletInfo = z326.object({
  balance: z326.number().int(),
  balanceOrigin: z326.string(),
  createdAt: z326.string(),
  currencyCode: z326.string(),
  currencySymbol: z326.string(),
  id: z326.string(),
  namespace: z326.string(),
  status: z326.enum(["ACTIVE", "INACTIVE"]),
  timeLimitedBalances: z326.array(TimeLimitedBalance).nullish(),
  totalPermanentBalance: z326.number().int().nullish(),
  totalTimeLimitedBalance: z326.number().int().nullish(),
  updatedAt: z326.string(),
  userId: z326.string()
});

// src/generated-definitions/CurrencyWallet.ts
import { z as z327 } from "zod";
var CurrencyWallet = z327.object({
  balance: z327.number().int(),
  currencyCode: z327.string(),
  currencySymbol: z327.string(),
  namespace: z327.string(),
  totalPermanentBalance: z327.number().int().nullish(),
  totalTimeLimitedBalance: z327.number().int().nullish(),
  userId: z327.string(),
  walletInfos: z327.array(WalletInfo).nullish()
});

// src/generated-definitions/CurrencyWalletArray.ts
import { z as z328 } from "zod";
var CurrencyWalletArray = z328.array(CurrencyWallet);

// src/generated-definitions/DetailedWalletTransactionInfo.ts
import { z as z329 } from "zod";
var DetailedWalletTransactionInfo = z329.object({
  amount: z329.number().int(),
  balanceSource: z329.string().nullish(),
  createdAt: z329.string(),
  currencyCode: z329.string(),
  namespace: z329.string(),
  operator: z329.string(),
  reason: z329.string().nullish(),
  updatedAt: z329.string(),
  userId: z329.string(),
  walletAction: z329.enum(["CREDIT", "DEBIT", "PAYMENT"]).nullish(),
  walletId: z329.string()
});

// src/generated-definitions/DetailedWalletTransactionPagingSlicedResult.ts
import { z as z330 } from "zod";
var DetailedWalletTransactionPagingSlicedResult = z330.object({
  data: z330.array(DetailedWalletTransactionInfo),
  paging: Paging.nullish()
});

// src/generated-definitions/PlatformWallet.ts
import { z as z331 } from "zod";
var PlatformWallet = z331.object({
  balance: z331.number().int(),
  currencyCode: z331.string(),
  currencySymbol: z331.string(),
  id: z331.string().nullish(),
  namespace: z331.string(),
  status: z331.enum(["ACTIVE", "INACTIVE"]).nullish(),
  transactionId: z331.string().nullish(),
  userId: z331.string(),
  walletInfos: z331.array(WalletInfo).nullish(),
  walletStatus: z331.enum(["ACTIVE", "INACTIVE"]).nullish()
});

// src/generated-definitions/PlatformWalletConfigInfo.ts
import { z as z332 } from "zod";
var PlatformWalletConfigInfo = z332.object({
  allowedBalanceOrigins: z332.array(z332.string()),
  createdAt: z332.string().nullish(),
  id: z332.string().nullish(),
  namespace: z332.string(),
  platform: z332.string(),
  updatedAt: z332.string().nullish()
});

// src/generated-definitions/WalletPagingSlicedResult.ts
import { z as z333 } from "zod";
var WalletPagingSlicedResult = z333.object({ data: z333.array(WalletInfo), paging: Paging.nullish() });

// src/generated-definitions/TransactionAmountDetails.ts
import { z as z334 } from "zod";
var TransactionAmountDetails = z334.object({
  amount: z334.number().int().nullish(),
  expireAt: z334.string().nullish(),
  origin: z334.string().nullish(),
  walletId: z334.string().nullish()
});

// src/generated-definitions/WalletTransactionInfo.ts
import { z as z335 } from "zod";
var WalletTransactionInfo = z335.object({
  amount: z335.number().int(),
  balanceSource: z335.string().nullish(),
  createdAt: z335.string(),
  currencyCode: z335.string(),
  metadata: z335.record(z335.any()).nullish(),
  namespace: z335.string(),
  operator: z335.string(),
  reason: z335.string().nullish(),
  transactionAmountDetails: z335.array(TransactionAmountDetails).nullish(),
  updatedAt: z335.string(),
  userId: z335.string(),
  walletAction: z335.enum(["CREDIT", "DEBIT", "PAYMENT"]).nullish()
});

// src/generated-definitions/WalletTransactionPagingSlicedResult.ts
import { z as z336 } from "zod";
var WalletTransactionPagingSlicedResult = z336.object({ data: z336.array(WalletTransactionInfo), paging: Paging.nullish() });

// src/generated-admin/endpoints/WalletAdmin$.ts
import { Validate as Validate36 } from "@accelbyte/sdk";
import { z as z337 } from "zod";
var WalletAdmin$ = class {
  // @ts-ignore
  // prettier-ignore
  constructor(axiosInstance, namespace, useSchemaValidation = true) {
    this.axiosInstance = axiosInstance;
    this.namespace = namespace;
    this.useSchemaValidation = useSchemaValidation;
  }
  /**
   * @deprecated
   * Query wallets.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: paginated wallets info&lt;/li&gt;&lt;/ul&gt;
   */
  getWallets(queryParams) {
    const params = { limit: 20, ...queryParams };
    const url = "/platform/admin/namespaces/{namespace}/wallets".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.get(url, { params });
    return Validate36.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      WalletPagingSlicedResult,
      "WalletPagingSlicedResult"
    );
  }
  /**
   * Debit different users&#39; wallets.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: bulk credit result&lt;/li&gt;&lt;/ul&gt;
   */
  createWalletDebit(data) {
    const params = {};
    const url = "/platform/admin/namespaces/{namespace}/wallets/debit".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.post(url, data, { params });
    return Validate36.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, BulkDebitResult, "BulkDebitResult");
  }
  /**
   * Credit different users&#39; wallets.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: bulk credit result&lt;/li&gt;&lt;/ul&gt;
   */
  createWalletCredit(data) {
    const params = {};
    const url = "/platform/admin/namespaces/{namespace}/wallets/credit".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.post(url, data, { params });
    return Validate36.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, BulkCreditResult, "BulkCreditResult");
  }
  /**
   * @deprecated
   * get a wallet by wallet id.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: wallet info&lt;/li&gt;&lt;/ul&gt;
   */
  getWallet_ByWalletId(walletId) {
    const params = {};
    const url = "/platform/admin/namespaces/{namespace}/wallets/{walletId}".replace("{namespace}", this.namespace).replace("{walletId}", walletId);
    const resultPromise = this.axiosInstance.get(url, { params });
    return Validate36.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, WalletInfo, "WalletInfo");
  }
  /**
   * @deprecated
   * get a user wallet.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: wallet info&lt;/li&gt;&lt;/ul&gt;
   */
  getWallet_ByUserId_ByWalletId(userId, walletId) {
    const params = {};
    const url = "/platform/admin/namespaces/{namespace}/users/{userId}/wallets/{walletId}".replace("{namespace}", this.namespace).replace("{userId}", userId).replace("{walletId}", walletId);
    const resultPromise = this.axiosInstance.get(url, { params });
    return Validate36.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, WalletInfo, "WalletInfo");
  }
  /**
   * Get platform wallet config list.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: wallet info&lt;/li&gt;&lt;/ul&gt;
   */
  getWalletConfig_ByPlatform(platform) {
    const params = {};
    const url = "/platform/admin/namespaces/{namespace}/platforms/{platform}/wallet/config".replace("{namespace}", this.namespace).replace("{platform}", platform);
    const resultPromise = this.axiosInstance.get(url, { params });
    return Validate36.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      PlatformWalletConfigInfo,
      "PlatformWalletConfigInfo"
    );
  }
  /**
   * Update platform wallet config.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: platform wallet config&lt;/li&gt;&lt;/ul&gt;
   */
  updateWalletConfig_ByPlatform(platform, data) {
    const params = {};
    const url = "/platform/admin/namespaces/{namespace}/platforms/{platform}/wallet/config".replace("{namespace}", this.namespace).replace("{platform}", platform);
    const resultPromise = this.axiosInstance.put(url, data, { params });
    return Validate36.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      PlatformWalletConfigInfo,
      "PlatformWalletConfigInfo"
    );
  }
  /**
   * @deprecated
   * Debit a user wallet.
   */
  updateDebit_ByUserId_ByWalletId(userId, walletId, data) {
    const params = {};
    const url = "/platform/admin/namespaces/{namespace}/users/{userId}/wallets/{walletId}/debit".replace("{namespace}", this.namespace).replace("{userId}", userId).replace("{walletId}", walletId);
    const resultPromise = this.axiosInstance.put(url, data, { params });
    return Validate36.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, WalletInfo, "WalletInfo");
  }
  /**
   * Reset platform wallet config to default config.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: platform wallet config&lt;/li&gt;&lt;/ul&gt;
   */
  updateWalletConfigReset_ByPlatform(platform) {
    const params = {};
    const url = "/platform/admin/namespaces/{namespace}/platforms/{platform}/wallet/config/reset".replace("{namespace}", this.namespace).replace("{platform}", platform);
    const resultPromise = this.axiosInstance.put(url, null, { params });
    return Validate36.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      PlatformWalletConfigInfo,
      "PlatformWalletConfigInfo"
    );
  }
  /**
   * @deprecated
   * enable a user wallet.
   */
  updateEnable_ByUserId_ByWalletId(userId, walletId) {
    const params = {};
    const url = "/platform/admin/namespaces/{namespace}/users/{userId}/wallets/{walletId}/enable".replace("{namespace}", this.namespace).replace("{userId}", userId).replace("{walletId}", walletId);
    const resultPromise = this.axiosInstance.put(url, null, { params });
    return Validate36.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, z337.unknown(), "z.unknown()");
  }
  /**
   * @deprecated
   * disable a user wallet.
   */
  updateDisable_ByUserId_ByWalletId(userId, walletId) {
    const params = {};
    const url = "/platform/admin/namespaces/{namespace}/users/{userId}/wallets/{walletId}/disable".replace("{namespace}", this.namespace).replace("{userId}", userId).replace("{walletId}", walletId);
    const resultPromise = this.axiosInstance.put(url, null, { params });
    return Validate36.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, z337.unknown(), "z.unknown()");
  }
  /**
   * Get user currency wallet summary.&lt;br&gt;Other detail info: &lt;ul&gt;(READ)&lt;/li&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: currency wallet summary&lt;/li&gt;&lt;/ul&gt;
   */
  getWalletsCurrenciesSummary_ByUserId(userId) {
    const params = {};
    const url = "/platform/admin/namespaces/{namespace}/users/{userId}/wallets/currencies/summary".replace("{namespace}", this.namespace).replace("{userId}", userId);
    const resultPromise = this.axiosInstance.get(url, { params });
    return Validate36.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, CurrencyWalletArray, "CurrencyWalletArray");
  }
  /**
   * @deprecated
   * &lt;b&gt;[SERVICE COMMUNICATION ONLY]&lt;/b&gt; Check wallet by balance origin and currency code whether it&#39;s inactive.
   */
  getCheck_ByUserId_ByCurrencyCode(userId, currencyCode, queryParams) {
    const params = { ...queryParams };
    const url = "/platform/admin/namespaces/{namespace}/users/{userId}/wallets/{currencyCode}/check".replace("{namespace}", this.namespace).replace("{userId}", userId).replace("{currencyCode}", currencyCode);
    const resultPromise = this.axiosInstance.get(url, { params });
    return Validate36.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, z337.unknown(), "z.unknown()");
  }
  /**
   * Credit a user wallet by currency code and balance origin, if wallet not exists, it will create a new wallet.&lt;br&gt;Other detail info: &lt;ul&gt;(UPDATE)&lt;/li&gt;&lt;/ul&gt;
   */
  updateCredit_ByUserId_ByCurrencyCode(userId, currencyCode, data) {
    const params = {};
    const url = "/platform/admin/namespaces/{namespace}/users/{userId}/wallets/{currencyCode}/credit".replace("{namespace}", this.namespace).replace("{userId}", userId).replace("{currencyCode}", currencyCode);
    const resultPromise = this.axiosInstance.put(url, data, { params });
    return Validate36.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, WalletInfo, "WalletInfo");
  }
  /**
   * Pay with user wallet by currency code and client platform.
   */
  updatePayment_ByUserId_ByCurrencyCode(userId, currencyCode, data) {
    const params = {};
    const url = "/platform/admin/namespaces/{namespace}/users/{userId}/wallets/{currencyCode}/payment".replace("{namespace}", this.namespace).replace("{userId}", userId).replace("{currencyCode}", currencyCode);
    const resultPromise = this.axiosInstance.put(url, data, { params });
    return Validate36.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, PlatformWallet, "PlatformWallet");
  }
  /**
   * @deprecated
   * List user wallet transactions ordered by create time desc.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;/li&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: wallet transaction info&lt;/li&gt;&lt;/ul&gt;
   */
  getTransactions_ByUserId_ByWalletId(userId, walletId, queryParams) {
    const params = { limit: 20, ...queryParams };
    const url = "/platform/admin/namespaces/{namespace}/users/{userId}/wallets/{walletId}/transactions".replace("{namespace}", this.namespace).replace("{userId}", userId).replace("{walletId}", walletId);
    const resultPromise = this.axiosInstance.get(url, { params });
    return Validate36.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      DetailedWalletTransactionPagingSlicedResult,
      "DetailedWalletTransactionPagingSlicedResult"
    );
  }
  /**
   * Checks if the user has enough balance based on the provided criteria.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: boolean value indicating if the user has enough balance&lt;/li&gt;&lt;/ul&gt;
   */
  createBalanceCheck_ByUserId_ByCurrencyCode(userId, currencyCode, data) {
    const params = {};
    const url = "/platform/admin/namespaces/{namespace}/users/{userId}/wallets/{currencyCode}/balanceCheck".replace("{namespace}", this.namespace).replace("{userId}", userId).replace("{currencyCode}", currencyCode);
    const resultPromise = this.axiosInstance.post(url, data, { params });
    return Validate36.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, z337.unknown(), "z.unknown()");
  }
  /**
   * Debit a user wallet by currency code, default is debit system wallet.
   */
  updateDebitWallet_ByUserId_ByCurrencyCode(userId, currencyCode, data) {
    const params = {};
    const url = "/platform/admin/namespaces/{namespace}/users/{userId}/wallets/currencies/{currencyCode}/debit".replace("{namespace}", this.namespace).replace("{userId}", userId).replace("{currencyCode}", currencyCode);
    const resultPromise = this.axiosInstance.put(url, data, { params });
    return Validate36.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, WalletInfo, "WalletInfo");
  }
  /**
   * Pay with user wallet by currency code and client platform.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;/ul&gt;&lt;h2&gt;Restrictions for metadata&lt;/h2&gt; 1. Cannot use &lt;b&gt;&#34;.&#34;&lt;/b&gt; as the key name - &lt;pre&gt;{ &#34;data.2&#34;: &#34;value&#34; }&lt;/pre&gt; 2. Cannot use &lt;b&gt;&#34;$&#34;&lt;/b&gt; as the prefix in key names - &lt;pre&gt;{ &#34;$data&#34;: &#34;value&#34; }&lt;/pre&gt;
   */
  updateDebitByWalletPlatform_ByUserId_ByCurrencyCode(userId, currencyCode, data) {
    const params = {};
    const url = "/platform/admin/namespaces/{namespace}/users/{userId}/wallets/{currencyCode}/debitByWalletPlatform".replace("{namespace}", this.namespace).replace("{userId}", userId).replace("{currencyCode}", currencyCode);
    const resultPromise = this.axiosInstance.put(url, data, { params });
    return Validate36.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, PlatformWallet, "PlatformWallet");
  }
  /**
   * List user currency transactions ordered by create time desc.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;/li&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: currency transaction info&lt;/li&gt;&lt;/ul&gt;
   */
  getTransactionsWallets_ByUserId_ByCurrencyCode(userId, currencyCode, queryParams) {
    const params = { limit: 20, ...queryParams };
    const url = "/platform/admin/namespaces/{namespace}/users/{userId}/wallets/currencies/{currencyCode}/transactions".replace("{namespace}", this.namespace).replace("{userId}", userId).replace("{currencyCode}", currencyCode);
    const resultPromise = this.axiosInstance.get(url, { params });
    return Validate36.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      WalletTransactionPagingSlicedResult,
      "WalletTransactionPagingSlicedResult"
    );
  }
};

// src/generated-admin/EntitlementAdminApi.ts
import { ApiUtils as ApiUtils9, Network as Network9 } from "@accelbyte/sdk";
function EntitlementAdminApi(sdk, args) {
  const sdkAssembly = sdk.assembly();
  const namespace = args?.coreConfig?.namespace ?? sdkAssembly.coreConfig.namespace;
  const useSchemaValidation = args?.coreConfig?.useSchemaValidation ?? sdkAssembly.coreConfig.useSchemaValidation;
  let axiosInstance = sdkAssembly.axiosInstance;
  const requestConfigOverrides = args?.axiosConfig?.request;
  const baseURLOverride = args?.coreConfig?.baseURL;
  const interceptorsOverride = args?.axiosConfig?.interceptors ?? [];
  if (requestConfigOverrides || baseURLOverride || interceptorsOverride.length > 0) {
    const requestConfig = ApiUtils9.mergeAxiosConfigs(sdkAssembly.axiosInstance.defaults, {
      ...baseURLOverride ? { baseURL: baseURLOverride } : {},
      ...requestConfigOverrides
    });
    axiosInstance = Network9.create(requestConfig);
    for (const interceptor of interceptorsOverride) {
      if (interceptor.type === "request") {
        axiosInstance.interceptors.request.use(interceptor.onRequest, interceptor.onError);
      }
      if (interceptor.type === "response") {
        axiosInstance.interceptors.response.use(interceptor.onSuccess, interceptor.onError);
      }
    }
  }
  async function getEntitlements(queryParams) {
    const $ = new EntitlementAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getEntitlements(queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function createEntitlementGrant(data) {
    const $ = new EntitlementAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.createEntitlementGrant(data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function createEntitlementRevoke(data) {
    const $ = new EntitlementAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.createEntitlementRevoke(data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getEntitlementsByItemIds(queryParams) {
    const $ = new EntitlementAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getEntitlementsByItemIds(queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getEntitlementsConfigInfo(queryParams) {
    const $ = new EntitlementAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getEntitlementsConfigInfo(queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getEntitlements_ByUserId(userId, queryParams) {
    const $ = new EntitlementAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getEntitlements_ByUserId(userId, queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function createEntitlement_ByUserId(userId, data) {
    const $ = new EntitlementAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.createEntitlement_ByUserId(userId, data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getEntitlement_ByEntitlementId(entitlementId) {
    const $ = new EntitlementAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getEntitlement_ByEntitlementId(entitlementId);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getEntitlementsBySku_ByUserId(userId, queryParams) {
    const $ = new EntitlementAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getEntitlementsBySku_ByUserId(userId, queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function updateEntitlementRevoke_ByUserId(userId) {
    const $ = new EntitlementAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.updateEntitlementRevoke_ByUserId(userId);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getEntitlementsByAppId_ByUserId(userId, queryParams) {
    const $ = new EntitlementAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getEntitlementsByAppId_ByUserId(userId, queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getEntitlementsByItemId_ByUserId(userId, queryParams) {
    const $ = new EntitlementAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getEntitlementsByItemId_ByUserId(userId, queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getEntitlementsByAppType_ByUserId(userId, queryParams) {
    const $ = new EntitlementAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getEntitlementsByAppType_ByUserId(userId, queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getEntitlementsByItemIds_ByUserId(userId, queryParams) {
    const $ = new EntitlementAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getEntitlementsByItemIds_ByUserId(userId, queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getEntitlementConfig_ByPlatform(platform) {
    const $ = new EntitlementAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getEntitlementConfig_ByPlatform(platform);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function updateEntitlementConfig_ByPlatform(platform, data) {
    const $ = new EntitlementAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.updateEntitlementConfig_ByPlatform(platform, data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function updateEntitlementRevokeById_ByUserId(userId, queryParams) {
    const $ = new EntitlementAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.updateEntitlementRevokeById_ByUserId(userId, queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getEntitlementsOwnershipAny_ByUserId(userId, queryParams) {
    const $ = new EntitlementAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getEntitlementsOwnershipAny_ByUserId(userId, queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getEntitlement_ByUserId_ByEntitlementId(userId, entitlementId) {
    const $ = new EntitlementAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getEntitlement_ByUserId_ByEntitlementId(userId, entitlementId);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function updateEntitlement_ByUserId_ByEntitlementId(userId, entitlementId, data) {
    const $ = new EntitlementAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.updateEntitlement_ByUserId_ByEntitlementId(userId, entitlementId, data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getEntitlementsOwnershipAnyOf_ByUserId(userId, queryParams) {
    const $ = new EntitlementAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getEntitlementsOwnershipAnyOf_ByUserId(userId, queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getEntitlementsOwnershipBySku_ByUserId(userId, queryParams) {
    const $ = new EntitlementAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getEntitlementsOwnershipBySku_ByUserId(userId, queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function updateEntitlementConfigEntitlementOriginEnable() {
    const $ = new EntitlementAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.updateEntitlementConfigEntitlementOriginEnable();
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getEntitlementsOwnershipByAppId_ByUserId(userId, queryParams) {
    const $ = new EntitlementAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getEntitlementsOwnershipByAppId_ByUserId(userId, queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getEntitlementsOwnershipByItemId_ByUserId(userId, queryParams) {
    const $ = new EntitlementAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getEntitlementsOwnershipByItemId_ByUserId(userId, queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getEntitlementsOwnershipByItemIds_ByUserId(userId, queryParams) {
    const $ = new EntitlementAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getEntitlementsOwnershipByItemIds_ByUserId(userId, queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function updateSell_ByUserId_ByEntitlementId(userId, entitlementId, data) {
    const $ = new EntitlementAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.updateSell_ByUserId_ByEntitlementId(userId, entitlementId, data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function updateEnable_ByUserId_ByEntitlementId(userId, entitlementId) {
    const $ = new EntitlementAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.updateEnable_ByUserId_ByEntitlementId(userId, entitlementId);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function updateRevoke_ByUserId_ByEntitlementId(userId, entitlementId, data) {
    const $ = new EntitlementAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.updateRevoke_ByUserId_ByEntitlementId(userId, entitlementId, data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function updateDisable_ByUserId_ByEntitlementId(userId, entitlementId) {
    const $ = new EntitlementAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.updateDisable_ByUserId_ByEntitlementId(userId, entitlementId);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getHistory_ByUserId_ByEntitlementId(userId, entitlementId) {
    const $ = new EntitlementAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getHistory_ByUserId_ByEntitlementId(userId, entitlementId);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function updateDecrement_ByUserId_ByEntitlementId(userId, entitlementId, data) {
    const $ = new EntitlementAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.updateDecrement_ByUserId_ByEntitlementId(userId, entitlementId, data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function updateRevokeByUseCount_ByUserId_ByEntitlementId(userId, entitlementId, data) {
    const $ = new EntitlementAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.updateRevokeByUseCount_ByUserId_ByEntitlementId(userId, entitlementId, data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function createRevokeByUseCount_ByUserId_ByEntitlementId(userId, entitlementId, data) {
    const $ = new EntitlementAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.createRevokeByUseCount_ByUserId_ByEntitlementId(userId, entitlementId, data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getRevokeByUseCountPreCheck_ByUserId_ByEntitlementId(userId, entitlementId, queryParams) {
    const $ = new EntitlementAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getRevokeByUseCountPreCheck_ByUserId_ByEntitlementId(userId, entitlementId, queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  return {
    /**
     * Query entitlements.&lt;p&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: entitlement list&lt;/li&gt;&lt;/ul&gt;
     */
    getEntitlements,
    /**
     * Grant entitlements to multiple users, skipped granting will be treated as fail.&lt;br&gt;&lt;br&gt;Notes: &lt;br&gt;&lt;br&gt;Support Item Types:&lt;ul&gt;&lt;li&gt;&lt;i&gt;APP&lt;/i&gt;&lt;/li&gt;&lt;li&gt;&lt;i&gt;INGAMEITEM&lt;/i&gt;&lt;/li&gt;&lt;li&gt;&lt;i&gt;CODE&lt;/i&gt;&lt;/li&gt;&lt;li&gt;&lt;i&gt;SUBSCRIPTION&lt;/i&gt;&lt;/li&gt;&lt;li&gt;&lt;i&gt;MEDIA&lt;/i&gt;&lt;/li&gt;&lt;li&gt;&lt;i&gt;OPTIONBOX&lt;/i&gt;&lt;/li&gt;&lt;li&gt;&lt;i&gt;LOOTBOX&lt;/i&gt;&lt;/li&gt;&lt;/ul&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: bulk grant entitlements result&lt;/li&gt;&lt;/ul&gt;
     */
    createEntitlementGrant,
    /**
     * Revoke entitlements, skipped revocation will be treated as fail.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: bulk revoke entitlements result&lt;/li&gt;&lt;/ul&gt;
     */
    createEntitlementRevoke,
    /**
     * Query entitlements by Item Ids.&lt;p&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: entitlement list&lt;/li&gt;&lt;/ul&gt;
     */
    getEntitlementsByItemIds,
    /**
     * Get entitlement config info.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: entitlement info&lt;/li&gt;&lt;/ul&gt;
     */
    getEntitlementsConfigInfo,
    /**
     * Query entitlements for a specific user.&lt;p&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: entitlement list&lt;/li&gt;&lt;/ul&gt;
     */
    getEntitlements_ByUserId,
    /**
     * Grant user entitlement.&lt;br&gt;&lt;br&gt;Notes: &lt;br&gt;&lt;br&gt;will skip un-supported item if input un-supported item types, please use /admin/namespaces/{namespace}/users/{userId}/fulfillment endpoint if want to fulfill other item type, like coin item&lt;br&gt;&lt;br&gt;Support Item Types:&lt;ul&gt;&lt;li&gt;&lt;i&gt;APP&lt;/i&gt;&lt;/li&gt;&lt;li&gt;&lt;i&gt;INGAMEITEM&lt;/i&gt;&lt;/li&gt;&lt;li&gt;&lt;i&gt;CODE&lt;/i&gt;&lt;/li&gt;&lt;li&gt;&lt;i&gt;SUBSCRIPTION&lt;/i&gt;&lt;/li&gt;&lt;li&gt;&lt;i&gt;MEDIA&lt;/i&gt;&lt;/li&gt;&lt;li&gt;&lt;i&gt;OPTIONBOX&lt;/i&gt;&lt;/li&gt;&lt;li&gt;&lt;i&gt;LOOTBOX&lt;/i&gt;&lt;/li&gt;&lt;/ul&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: granted entitlement&lt;/li&gt;&lt;/ul&gt;
     */
    createEntitlement_ByUserId,
    /**
     * Get entitlement.&lt;p&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: entitlement&lt;/li&gt;&lt;/ul&gt;
     */
    getEntitlement_ByEntitlementId,
    /**
     * Get user entitlement by sku.
     */
    getEntitlementsBySku_ByUserId,
    /**
     * Revoke all entitlements of a user (This API is for testing purpose only)&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: revoked entitlements count&lt;/li&gt;&lt;/ul&gt;
     */
    updateEntitlementRevoke_ByUserId,
    /**
     * Get user app entitlement by appId.
     */
    getEntitlementsByAppId_ByUserId,
    /**
     * Get user entitlement by itemId.
     */
    getEntitlementsByItemId_ByUserId,
    /**
     * Query app entitlements by appType.&lt;p&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: app entitlement pagination&lt;/li&gt;&lt;/ul&gt;
     */
    getEntitlementsByAppType_ByUserId,
    /**
     * Get user entitlements by itemIds.
     */
    getEntitlementsByItemIds_ByUserId,
    /**
     * Get platform entitlement config list.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: entitlement info&lt;/li&gt;&lt;/ul&gt;
     */
    getEntitlementConfig_ByPlatform,
    /**
     * Update platform entitlement config.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: platform entitlement config&lt;/li&gt;&lt;/ul&gt;
     */
    updateEntitlementConfig_ByPlatform,
    /**
     * Revoke user&#39;s entitlements by ids.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: revoke entitlements count&lt;/li&gt;&lt;/ul&gt;
     */
    updateEntitlementRevokeById_ByUserId,
    /**
     * Exists any user active entitlement of specified itemIds, skus and appIds
     */
    getEntitlementsOwnershipAny_ByUserId,
    /**
     * Get user entitlement.&lt;p&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: entitlement&lt;/li&gt;&lt;/ul&gt;
     */
    getEntitlement_ByUserId_ByEntitlementId,
    /**
     * Update user entitlement. If update CONSUMABLE entitlement useCount to 0, the status will be CONSUMED.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: updated entitlement&lt;/li&gt;&lt;/ul&gt;
     */
    updateEntitlement_ByUserId_ByEntitlementId,
    /**
     * Exists any user active entitlement of specified items.
     */
    getEntitlementsOwnershipAnyOf_ByUserId,
    /**
     * Get user entitlement ownership by sku.
     */
    getEntitlementsOwnershipBySku_ByUserId,
    /**
     * Enable Entitlement origin feature.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: entitlement info&lt;/li&gt;&lt;/ul&gt;
     */
    updateEntitlementConfigEntitlementOriginEnable,
    /**
     * Get user app entitlement ownership by appId.
     */
    getEntitlementsOwnershipByAppId_ByUserId,
    /**
     * Get user entitlement ownership by itemId.
     */
    getEntitlementsOwnershipByItemId_ByUserId,
    /**
     * Get user entitlement ownership by itemIds.
     */
    getEntitlementsOwnershipByItemIds_ByUserId,
    /**
     * Sell user entitlement. If the entitlement is consumable, useCount is 0, the status will be CONSUMED. If the entitlement is durable, the status will be SOLD. Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: entitlement&lt;/li&gt;&lt;/ul&gt;
     */
    updateSell_ByUserId_ByEntitlementId,
    /**
     * Enable user entitlement.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: enable entitlement&lt;/li&gt;&lt;/ul&gt;
     */
    updateEnable_ByUserId_ByEntitlementId,
    /**
     * Revoke user entitlement.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: revoke entitlement&lt;/li&gt;&lt;/ul&gt;
     */
    updateRevoke_ByUserId_ByEntitlementId,
    /**
     * Disable user entitlement if entitlement, only active entitlement can be disable, disabled entitlement can&#39;t consume.&lt;br&gt;&lt;b&gt;Like revoke, it will lose the entitlement ownership, except disabled entitlement can enable.&lt;/b&gt;&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: disable entitlement&lt;/li&gt;&lt;/ul&gt;
     */
    updateDisable_ByUserId_ByEntitlementId,
    /**
     * Get user entitlement histories.&lt;p&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: list of entitlement history&lt;/li&gt;&lt;/ul&gt;
     */
    getHistory_ByUserId_ByEntitlementId,
    /**
     * Consume user entitlement. If the entitlement useCount is 0, the status will be CONSUMED.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: consumed entitlement&lt;/li&gt;&lt;/ul&gt;
     */
    updateDecrement_ByUserId_ByEntitlementId,
    /**
     * @deprecated
     * Revoke specified use count of user entitlement. please use /{entitlementId}/revoke/byUseCount endpoint instead of this endpoint&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: revoke entitlement&lt;/li&gt;&lt;/ul&gt;
     */
    updateRevokeByUseCount_ByUserId_ByEntitlementId,
    /**
     * Revoke specified count of user entitlement.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: The revoked entitlement&lt;/li&gt;&lt;/ul&gt;
     */
    createRevokeByUseCount_ByUserId_ByEntitlementId,
    /**
     * Checks if specified use count of user entitlement can be revoked without actually revoking it.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: true if revokable, false otherwise&lt;/li&gt;&lt;/ul&gt;
     */
    getRevokeByUseCountPreCheck_ByUserId_ByEntitlementId
  };
}

// src/generated-admin/FulfillmentAdminApi.ts
import { ApiUtils as ApiUtils10, Network as Network10 } from "@accelbyte/sdk";
function FulfillmentAdminApi(sdk, args) {
  const sdkAssembly = sdk.assembly();
  const namespace = args?.coreConfig?.namespace ?? sdkAssembly.coreConfig.namespace;
  const useSchemaValidation = args?.coreConfig?.useSchemaValidation ?? sdkAssembly.coreConfig.useSchemaValidation;
  let axiosInstance = sdkAssembly.axiosInstance;
  const requestConfigOverrides = args?.axiosConfig?.request;
  const baseURLOverride = args?.coreConfig?.baseURL;
  const interceptorsOverride = args?.axiosConfig?.interceptors ?? [];
  if (requestConfigOverrides || baseURLOverride || interceptorsOverride.length > 0) {
    const requestConfig = ApiUtils10.mergeAxiosConfigs(sdkAssembly.axiosInstance.defaults, {
      ...baseURLOverride ? { baseURL: baseURLOverride } : {},
      ...requestConfigOverrides
    });
    axiosInstance = Network10.create(requestConfig);
    for (const interceptor of interceptorsOverride) {
      if (interceptor.type === "request") {
        axiosInstance.interceptors.request.use(interceptor.onRequest, interceptor.onError);
      }
      if (interceptor.type === "response") {
        axiosInstance.interceptors.response.use(interceptor.onSuccess, interceptor.onError);
      }
    }
  }
  async function getFulfillments_v2(queryParams) {
    const $ = new FulfillmentAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getFulfillments_v2(queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getFulfillmentHistory(queryParams) {
    const $ = new FulfillmentAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getFulfillmentHistory(queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function createFulfillment_ByUserId(userId, data) {
    const $ = new FulfillmentAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.createFulfillment_ByUserId(userId, data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function createFulfillmentCode_ByUserId(userId, data) {
    const $ = new FulfillmentAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.createFulfillmentCode_ByUserId(userId, data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function createFulfillmentReward_ByUserId(userId, data) {
    const $ = new FulfillmentAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.createFulfillmentReward_ByUserId(userId, data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function createFulfillmentPreCheck_ByUserId(userId, data) {
    const $ = new FulfillmentAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.createFulfillmentPreCheck_ByUserId(userId, data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function createFulfillmentReward_ByUserId_v2(userId, data) {
    const $ = new FulfillmentAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.createFulfillmentReward_ByUserId_v2(userId, data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function updateFulfillment_ByUserId_ByTransactionId_v2(userId, transactionId, data) {
    const $ = new FulfillmentAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.updateFulfillment_ByUserId_ByTransactionId_v2(userId, transactionId, data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function updateRetry_ByUserId_ByTransactionId_v2(userId, transactionId) {
    const $ = new FulfillmentAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.updateRetry_ByUserId_ByTransactionId_v2(userId, transactionId);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function updateRevoke_ByUserId_ByTransactionId_v2(userId, transactionId) {
    const $ = new FulfillmentAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.updateRevoke_ByUserId_ByTransactionId_v2(userId, transactionId);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  return {
    /**
     * &lt;b&gt;[Not supported yet in AGS Shared Cloud]&lt;/b&gt; Query fulfillments in a namespace.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: list of fulfillment info:&lt;ul&gt;&lt;li&gt;storeId in items can be ignored&lt;/li&gt;&lt;li&gt;error in successList will always be null&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;/ul&gt;
     */
    getFulfillments_v2,
    /**
     * Query fulfillment histories in a namespace.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: query fulfillment history&lt;/li&gt;&lt;/ul&gt;
     */
    getFulfillmentHistory,
    /**
     * Fulfill item.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: fulfillment result&lt;/li&gt;&lt;/ul&gt;
     */
    createFulfillment_ByUserId,
    /**
     * Redeem campaign code.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: fulfillment result&lt;/li&gt;&lt;/ul&gt;
     */
    createFulfillmentCode_ByUserId,
    /**
     * &lt;b&gt;[SERVICE COMMUNICATION ONLY]&lt;/b&gt; Fulfill rewards.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: fulfillment result&lt;/li&gt;&lt;/ul&gt;
     */
    createFulfillmentReward_ByUserId,
    /**
     * Retrieve and check fulfillment items based on the provided request.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: list of fulfillment items&lt;/li&gt;&lt;/ul&gt;
     */
    createFulfillmentPreCheck_ByUserId,
    /**
     * &lt;b&gt;[SERVICE COMMUNICATION ONLY]&lt;/b&gt; Fulfill rewards.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: fulfillment result&lt;/li&gt;&lt;li&gt;&lt;i&gt;rewards Item unsupported Type&lt;/i&gt;: SUBSCRIPTION&lt;/ul&gt;
     */
    createFulfillmentReward_ByUserId_v2,
    /**
     * &lt;b&gt;[Not supported yet in AGS Shared Cloud]&lt;/b&gt; Fulfill items by transactionId.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Request body&lt;/i&gt;: storeId, region, language, and entitlementCollectionId can be ignored.&lt;/li&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: fulfillment v2 result, storeId field can be ignored.&lt;/li&gt;&lt;/ul&gt;
     */
    updateFulfillment_ByUserId_ByTransactionId_v2,
    /**
     * &lt;b&gt;[Not supported yet in AGS Shared Cloud]&lt;/b&gt; Retry fulfill items by transactionId without sending the original payload.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: fulfillment v2 result, storeId field can be ignored.&lt;/li&gt;&lt;/ul&gt;
     */
    updateRetry_ByUserId_ByTransactionId_v2,
    /**
     * &lt;b&gt;[Not supported yet in AGS Shared Cloud]&lt;/b&gt; Revoke items by transactionId.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: revoke fulfillment v2 result, storeId field can be ignored.&lt;/li&gt;&lt;/ul&gt;
     */
    updateRevoke_ByUserId_ByTransactionId_v2
  };
}

// src/generated-admin/FulfillmentScriptAdminApi.ts
import { ApiUtils as ApiUtils11, Network as Network11 } from "@accelbyte/sdk";
function FulfillmentScriptAdminApi(sdk, args) {
  const sdkAssembly = sdk.assembly();
  const namespace = args?.coreConfig?.namespace ?? sdkAssembly.coreConfig.namespace;
  const useSchemaValidation = args?.coreConfig?.useSchemaValidation ?? sdkAssembly.coreConfig.useSchemaValidation;
  let axiosInstance = sdkAssembly.axiosInstance;
  const requestConfigOverrides = args?.axiosConfig?.request;
  const baseURLOverride = args?.coreConfig?.baseURL;
  const interceptorsOverride = args?.axiosConfig?.interceptors ?? [];
  if (requestConfigOverrides || baseURLOverride || interceptorsOverride.length > 0) {
    const requestConfig = ApiUtils11.mergeAxiosConfigs(sdkAssembly.axiosInstance.defaults, {
      ...baseURLOverride ? { baseURL: baseURLOverride } : {},
      ...requestConfigOverrides
    });
    axiosInstance = Network11.create(requestConfig);
    for (const interceptor of interceptorsOverride) {
      if (interceptor.type === "request") {
        axiosInstance.interceptors.request.use(interceptor.onRequest, interceptor.onError);
      }
      if (interceptor.type === "response") {
        axiosInstance.interceptors.response.use(interceptor.onSuccess, interceptor.onError);
      }
    }
  }
  async function getFulfillmentScripts() {
    const $ = new FulfillmentScriptAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getFulfillmentScripts();
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function deleteFulfillmentScript_ById(id) {
    const $ = new FulfillmentScriptAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.deleteFulfillmentScript_ById(id);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getFulfillmentScript_ById(id) {
    const $ = new FulfillmentScriptAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getFulfillmentScript_ById(id);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function patchFulfillmentScript_ById(id, data) {
    const $ = new FulfillmentScriptAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.patchFulfillmentScript_ById(id, data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function createFulfillmentScript_ById(id, data) {
    const $ = new FulfillmentScriptAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.createFulfillmentScript_ById(id, data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  return {
    /**
     * &lt;b&gt;[Not supported yet in AGS Shared Cloud]&lt;/b&gt;List all fulfillment scripts.
     */
    getFulfillmentScripts,
    /**
     * &lt;b&gt;[Not supported yet in AGS Shared Cloud]&lt;/b&gt;Delete fulfillment script.
     */
    deleteFulfillmentScript_ById,
    /**
     * &lt;b&gt;[Not supported yet in AGS Shared Cloud]&lt;/b&gt;Get fulfillment script by id.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: get fulfillment script&lt;/li&gt;&lt;/ul&gt;
     */
    getFulfillmentScript_ById,
    /**
     * &lt;b&gt;[Not supported yet in AGS Shared Cloud]&lt;/b&gt;Update fulfillment script.
     */
    patchFulfillmentScript_ById,
    /**
     * &lt;b&gt;[Not supported yet in AGS Shared Cloud]&lt;/b&gt;Create fulfillment script.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;/ul&gt;Fulfillment scripts are used for adding custom fulfillment logic based on &lt;b&gt;ITEM_TYPE&lt;/b&gt;: [MEDIA,INGAMEITEM] for now, and the custom scripts only cover grantDays.&lt;br&gt;Example for grantDays: &lt;br&gt;&lt;code&gt;order &amp;&amp; ((order.currency &amp;&amp; order.currency.currencyCode) == &#39;LP&#39; || order.isFree) ? 30 : -1&lt;/code&gt;&lt;br&gt;
     */
    createFulfillmentScript_ById
  };
}

// src/generated-admin/IapAdminApi.ts
import { ApiUtils as ApiUtils12, Network as Network12 } from "@accelbyte/sdk";
function IapAdminApi(sdk, args) {
  const sdkAssembly = sdk.assembly();
  const namespace = args?.coreConfig?.namespace ?? sdkAssembly.coreConfig.namespace;
  const useSchemaValidation = args?.coreConfig?.useSchemaValidation ?? sdkAssembly.coreConfig.useSchemaValidation;
  let axiosInstance = sdkAssembly.axiosInstance;
  const requestConfigOverrides = args?.axiosConfig?.request;
  const baseURLOverride = args?.coreConfig?.baseURL;
  const interceptorsOverride = args?.axiosConfig?.interceptors ?? [];
  if (requestConfigOverrides || baseURLOverride || interceptorsOverride.length > 0) {
    const requestConfig = ApiUtils12.mergeAxiosConfigs(sdkAssembly.axiosInstance.defaults, {
      ...baseURLOverride ? { baseURL: baseURLOverride } : {},
      ...requestConfigOverrides
    });
    axiosInstance = Network12.create(requestConfig);
    for (const interceptor of interceptorsOverride) {
      if (interceptor.type === "request") {
        axiosInstance.interceptors.request.use(interceptor.onRequest, interceptor.onError);
      }
      if (interceptor.type === "response") {
        axiosInstance.interceptors.response.use(interceptor.onSuccess, interceptor.onError);
      }
    }
  }
  async function deleteIapConfigXbl() {
    const $ = new IapAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.deleteIapConfigXbl();
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getIapConfigXbl() {
    const $ = new IapAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getIapConfigXbl();
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function updateIapConfigXbl(data) {
    const $ = new IapAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.updateIapConfigXbl(data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function deleteIapConfigItem() {
    const $ = new IapAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.deleteIapConfigItem();
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getIapConfigItem() {
    const $ = new IapAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getIapConfigItem();
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function updateIapConfigItem(data) {
    const $ = new IapAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.updateIapConfigItem(data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function deleteIapConfigApple() {
    const $ = new IapAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.deleteIapConfigApple();
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getIapConfigApple() {
    const $ = new IapAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getIapConfigApple();
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function updateIapConfigApple(data) {
    const $ = new IapAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.updateIapConfigApple(data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function deleteIapConfigSteam() {
    const $ = new IapAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.deleteIapConfigSteam();
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getIapConfigSteam() {
    const $ = new IapAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getIapConfigSteam();
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function updateIapConfigSteam(data) {
    const $ = new IapAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.updateIapConfigSteam(data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function deleteIapConfigGoogle() {
    const $ = new IapAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.deleteIapConfigGoogle();
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getIapConfigGoogle() {
    const $ = new IapAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getIapConfigGoogle();
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function updateIapConfigGoogle(data) {
    const $ = new IapAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.updateIapConfigGoogle(data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function deleteIapConfigOculu() {
    const $ = new IapAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.deleteIapConfigOculu();
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getIapConfigOculus() {
    const $ = new IapAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getIapConfigOculus();
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function updateIapConfigOculu(data) {
    const $ = new IapAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.updateIapConfigOculu(data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function deleteIapConfigTwitch() {
    const $ = new IapAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.deleteIapConfigTwitch();
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getIapConfigTwitch() {
    const $ = new IapAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getIapConfigTwitch();
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function updateIapConfigTwitch(data) {
    const $ = new IapAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.updateIapConfigTwitch(data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getIap_ByUserId(userId, queryParams) {
    const $ = new IapAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getIap_ByUserId(userId, queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function updateIapConfigXblCert(data) {
    const $ = new IapAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.updateIapConfigXblCert(data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function deleteIapConfigEpicgame() {
    const $ = new IapAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.deleteIapConfigEpicgame();
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getIapConfigEpicgames() {
    const $ = new IapAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getIapConfigEpicgames();
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function updateIapConfigEpicgame(data) {
    const $ = new IapAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.updateIapConfigEpicgame(data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function updateIapConfigAppleCert(data) {
    const $ = new IapAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.updateIapConfigAppleCert(data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function updateIapConfigGoogleCert(data) {
    const $ = new IapAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.updateIapConfigGoogleCert(data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function deleteIapConfigPlaystation() {
    const $ = new IapAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.deleteIapConfigPlaystation();
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getIapConfigPlaystation() {
    const $ = new IapAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getIapConfigPlaystation();
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function updateIapConfigPlaystation(data) {
    const $ = new IapAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.updateIapConfigPlaystation(data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getIapAll_ByUserId(userId) {
    const $ = new IapAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getIapAll_ByUserId(userId);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getIapConfigPlaystationValidate() {
    const $ = new IapAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getIapConfigPlaystationValidate();
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function updateIapConfigPlaystationValidate(data) {
    const $ = new IapAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.updateIapConfigPlaystationValidate(data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function updateIapMockReceipt_ByUserId(userId, data) {
    const $ = new IapAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.updateIapMockReceipt_ByUserId(userId, data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getIapConsumeHistory_ByUserId(userId, queryParams) {
    const $ = new IapAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getIapConsumeHistory_ByUserId(userId, queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  return {
    /**
     * Delete xbl iap config.
     */
    deleteIapConfigXbl,
    /**
     * Get xbox iap config.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: xbox iap config&lt;/li&gt;&lt;/ul&gt;
     */
    getIapConfigXbl,
    /**
     * Update xbl iap config. Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: updated xbl iap config&lt;/li&gt;&lt;/ul&gt;
     */
    updateIapConfigXbl,
    /**
     * delete a iap item config.
     */
    deleteIapConfigItem,
    /**
     * Get iap item config.
     */
    getIapConfigItem,
    /**
     * Update iap item config. Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: updated iap item config&lt;/li&gt;&lt;/ul&gt;
     */
    updateIapConfigItem,
    /**
     * Delete apple iap config.
     */
    deleteIapConfigApple,
    /**
     * Get apple iap config.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: apple iap config&lt;/li&gt;&lt;/ul&gt;
     */
    getIapConfigApple,
    /**
     * Update apple iap config. Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: updated apple iap config&lt;/li&gt;&lt;/ul&gt;
     */
    updateIapConfigApple,
    /**
     * Delete steam iap config.
     */
    deleteIapConfigSteam,
    /**
     * Get steam iap config.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: steam iap config&lt;/li&gt;&lt;/ul&gt;
     */
    getIapConfigSteam,
    /**
     * Update steam iap config. Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: updated steam iap config&lt;/li&gt;&lt;/ul&gt;
     */
    updateIapConfigSteam,
    /**
     * Delete google iap config.
     */
    deleteIapConfigGoogle,
    /**
     * Get google iap config.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: google iap config&lt;/li&gt;&lt;/ul&gt;
     */
    getIapConfigGoogle,
    /**
     * Update google iap config. Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: updated google iap config&lt;/li&gt;&lt;/ul&gt;
     */
    updateIapConfigGoogle,
    /**
     * Delete oculus iap config.
     */
    deleteIapConfigOculu,
    /**
     * Get oculus iap config.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: steam iap config&lt;/li&gt;&lt;/ul&gt;
     */
    getIapConfigOculus,
    /**
     * Update oculus iap config. Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: updated steam iap config&lt;/li&gt;&lt;/ul&gt;
     */
    updateIapConfigOculu,
    /**
     * Delete twitch iap config.
     */
    deleteIapConfigTwitch,
    /**
     * Get twitch iap config.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: twitch iap config&lt;/li&gt;&lt;/ul&gt;
     */
    getIapConfigTwitch,
    /**
     * Update twitch iap config. Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: updated twitch iap config&lt;/li&gt;&lt;/ul&gt;
     */
    updateIapConfigTwitch,
    /**
     * Query IAP orders.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: paginated iap orders&lt;/li&gt;&lt;/ul&gt;
     */
    getIap_ByUserId,
    /**
     * Upload xbl business partner cert file.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: updated xbl iap config&lt;/li&gt;&lt;/ul&gt;
     */
    updateIapConfigXblCert,
    /**
     * Delete epic games iap config.
     */
    deleteIapConfigEpicgame,
    /**
     * Get epic games iap config.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: epic games iap config&lt;/li&gt;&lt;/ul&gt;
     */
    getIapConfigEpicgames,
    /**
     * Update epic games iap config. Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: updated epic games iap config&lt;/li&gt;&lt;/ul&gt;
     */
    updateIapConfigEpicgame,
    /**
     * Upload Apple Store p8 file.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: updated apple iap config&lt;/li&gt;&lt;/ul&gt;
     */
    updateIapConfigAppleCert,
    /**
     * Upload google play p12 file.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: updated google iap config&lt;/li&gt;&lt;/ul&gt;
     */
    updateIapConfigGoogleCert,
    /**
     * Delete playstation iap config.
     */
    deleteIapConfigPlaystation,
    /**
     * Get playstation iap config.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: playstation iap config&lt;/li&gt;&lt;/ul&gt;
     */
    getIapConfigPlaystation,
    /**
     * Update playstation iap config. Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: updated playstation iap config&lt;/li&gt;&lt;/ul&gt;
     */
    updateIapConfigPlaystation,
    /**
     * Query all user IAP orders.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: list of iap orders&lt;/li&gt;&lt;/ul&gt;
     */
    getIapAll_ByUserId,
    /**
     * Validate playstation iap config. Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: Test Results&lt;/li&gt;&lt;/ul&gt;
     */
    getIapConfigPlaystationValidate,
    /**
     * Validate playstation iap config. Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: Test Results&lt;/li&gt;&lt;/ul&gt;
     */
    updateIapConfigPlaystationValidate,
    /**
     * &lt;b&gt;[TEST FACILITY ONLY] Forbidden in live environment. &lt;/b&gt; Mock fulfill iap item without validate receipt.Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: &lt;/li&gt;&lt;/ul&gt;
     */
    updateIapMockReceipt_ByUserId,
    /**
     * Query IAP consume history.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: paginated iap consume history&lt;/li&gt;&lt;/ul&gt;
     */
    getIapConsumeHistory_ByUserId
  };
}

// src/generated-admin/IapNotificationAdminApi.ts
import { ApiUtils as ApiUtils13, Network as Network13 } from "@accelbyte/sdk";
function IapNotificationAdminApi(sdk, args) {
  const sdkAssembly = sdk.assembly();
  const namespace = args?.coreConfig?.namespace ?? sdkAssembly.coreConfig.namespace;
  const useSchemaValidation = args?.coreConfig?.useSchemaValidation ?? sdkAssembly.coreConfig.useSchemaValidation;
  let axiosInstance = sdkAssembly.axiosInstance;
  const requestConfigOverrides = args?.axiosConfig?.request;
  const baseURLOverride = args?.coreConfig?.baseURL;
  const interceptorsOverride = args?.axiosConfig?.interceptors ?? [];
  if (requestConfigOverrides || baseURLOverride || interceptorsOverride.length > 0) {
    const requestConfig = ApiUtils13.mergeAxiosConfigs(sdkAssembly.axiosInstance.defaults, {
      ...baseURLOverride ? { baseURL: baseURLOverride } : {},
      ...requestConfigOverrides
    });
    axiosInstance = Network13.create(requestConfig);
    for (const interceptor of interceptorsOverride) {
      if (interceptor.type === "request") {
        axiosInstance.interceptors.request.use(interceptor.onRequest, interceptor.onError);
      }
      if (interceptor.type === "response") {
        axiosInstance.interceptors.response.use(interceptor.onSuccess, interceptor.onError);
      }
    }
  }
  async function getIapNotifications(queryParams) {
    const $ = new IapNotificationAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getIapNotifications(queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  return {
    /**
     * Query third party notifications.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: Third Party Platform notifications&lt;/li&gt;&lt;/ul&gt;
     */
    getIapNotifications
  };
}

// src/generated-admin/IapSubscriptionAdminApi.ts
import { ApiUtils as ApiUtils14, Network as Network14 } from "@accelbyte/sdk";
function IapSubscriptionAdminApi(sdk, args) {
  const sdkAssembly = sdk.assembly();
  const namespace = args?.coreConfig?.namespace ?? sdkAssembly.coreConfig.namespace;
  const useSchemaValidation = args?.coreConfig?.useSchemaValidation ?? sdkAssembly.coreConfig.useSchemaValidation;
  let axiosInstance = sdkAssembly.axiosInstance;
  const requestConfigOverrides = args?.axiosConfig?.request;
  const baseURLOverride = args?.coreConfig?.baseURL;
  const interceptorsOverride = args?.axiosConfig?.interceptors ?? [];
  if (requestConfigOverrides || baseURLOverride || interceptorsOverride.length > 0) {
    const requestConfig = ApiUtils14.mergeAxiosConfigs(sdkAssembly.axiosInstance.defaults, {
      ...baseURLOverride ? { baseURL: baseURLOverride } : {},
      ...requestConfigOverrides
    });
    axiosInstance = Network14.create(requestConfig);
    for (const interceptor of interceptorsOverride) {
      if (interceptor.type === "request") {
        axiosInstance.interceptors.request.use(interceptor.onRequest, interceptor.onError);
      }
      if (interceptor.type === "response") {
        axiosInstance.interceptors.response.use(interceptor.onSuccess, interceptor.onError);
      }
    }
  }
  async function getIapSubscriptions(queryParams) {
    const $ = new IapSubscriptionAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getIapSubscriptions(queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getIapSubscriptions_ByUserId(userId, queryParams) {
    const $ = new IapSubscriptionAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getIapSubscriptions_ByUserId(userId, queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getIapSubscription_ByUserId_ById(userId, id) {
    const $ = new IapSubscriptionAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getIapSubscription_ByUserId_ById(userId, id);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function updateSyncIap_ByUserId_ById(userId, id) {
    const $ = new IapSubscriptionAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.updateSyncIap_ByUserId_ById(userId, id);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getIapSubscriptionsTransactions_ByUserId(userId, queryParams) {
    const $ = new IapSubscriptionAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getIapSubscriptionsTransactions_ByUserId(userId, queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getIapSubscriptionTransaction_ByUserId_ById(userId, id) {
    const $ = new IapSubscriptionAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getIapSubscriptionTransaction_ByUserId_ById(userId, id);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function updateSyncSubscriptionIap_ByUserId_ById(userId, id) {
    const $ = new IapSubscriptionAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.updateSyncSubscriptionIap_ByUserId_ById(userId, id);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getHistoriesSubscriptionsIap_ByUserId_ById(userId, id, queryParams) {
    const $ = new IapSubscriptionAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getHistoriesSubscriptionsIap_ByUserId_ById(userId, id, queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getOwnershipByGroupIdSubscriptionsIap_ByUserId_ByPlatform(userId, platform, queryParams) {
    const $ = new IapSubscriptionAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getOwnershipByGroupIdSubscriptionsIap_ByUserId_ByPlatform(userId, platform, queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getOwnershipByProductIdSubscriptionsIap_ByUserId_ByPlatform(userId, platform, queryParams) {
    const $ = new IapSubscriptionAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getOwnershipByProductIdSubscriptionsIap_ByUserId_ByPlatform(userId, platform, queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  return {
    /**
     * Query subscriptions, default sort by updatedAt Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: &lt;/li&gt;&lt;/ul&gt;
     */
    getIapSubscriptions,
    /**
     * Query user subscription, default sort by updatedAtOther detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: &lt;/li&gt;&lt;/ul&gt;
     */
    getIapSubscriptions_ByUserId,
    /**
     * Admin get user subscription details.Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: &lt;/li&gt;&lt;/ul&gt;
     */
    getIapSubscription_ByUserId_ById,
    /**
     * Sync Subscription Status
     */
    updateSyncIap_ByUserId_ById,
    /**
     * Admin query user subscription transactions, default sort by startAt timeOther detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: &lt;/li&gt;&lt;/ul&gt;
     */
    getIapSubscriptionsTransactions_ByUserId,
    /**
     * Admin get user subscription details.Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: &lt;/li&gt;&lt;/ul&gt;
     */
    getIapSubscriptionTransaction_ByUserId_ById,
    /**
     * Sync Subscription Status
     */
    updateSyncSubscriptionIap_ByUserId_ById,
    /**
     * Get Subscription Transaction Update History
     */
    getHistoriesSubscriptionsIap_ByUserId_ById,
    /**
     * Get user third party subscription by subscription group id.
     */
    getOwnershipByGroupIdSubscriptionsIap_ByUserId_ByPlatform,
    /**
     * Get user third party subscription by subscription product id.
     */
    getOwnershipByProductIdSubscriptionsIap_ByUserId_ByPlatform
  };
}

// src/generated-admin/InvoiceAdminApi.ts
import { ApiUtils as ApiUtils15, Network as Network15 } from "@accelbyte/sdk";
function InvoiceAdminApi(sdk, args) {
  const sdkAssembly = sdk.assembly();
  const namespace = args?.coreConfig?.namespace ?? sdkAssembly.coreConfig.namespace;
  const useSchemaValidation = args?.coreConfig?.useSchemaValidation ?? sdkAssembly.coreConfig.useSchemaValidation;
  let axiosInstance = sdkAssembly.axiosInstance;
  const requestConfigOverrides = args?.axiosConfig?.request;
  const baseURLOverride = args?.coreConfig?.baseURL;
  const interceptorsOverride = args?.axiosConfig?.interceptors ?? [];
  if (requestConfigOverrides || baseURLOverride || interceptorsOverride.length > 0) {
    const requestConfig = ApiUtils15.mergeAxiosConfigs(sdkAssembly.axiosInstance.defaults, {
      ...baseURLOverride ? { baseURL: baseURLOverride } : {},
      ...requestConfigOverrides
    });
    axiosInstance = Network15.create(requestConfig);
    for (const interceptor of interceptorsOverride) {
      if (interceptor.type === "request") {
        axiosInstance.interceptors.request.use(interceptor.onRequest, interceptor.onError);
      }
      if (interceptor.type === "response") {
        axiosInstance.interceptors.response.use(interceptor.onSuccess, interceptor.onError);
      }
    }
  }
  async function getInvoiceSummary(queryParams) {
    const $ = new InvoiceAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getInvoiceSummary(queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getInvoiceDetailsCsv(queryParams) {
    const $ = new InvoiceAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getInvoiceDetailsCsv(queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  return {
    /**
     * Generate invoice summary.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: query orders&lt;/li&gt;&lt;/ul&gt;
     */
    getInvoiceSummary,
    /**
     * Download invoice details as a csv file.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: invoice details csv file&lt;/li&gt;&lt;/ul&gt;
     */
    getInvoiceDetailsCsv
  };
}

// src/generated-admin/ItemAdminApi.ts
import { ApiUtils as ApiUtils16, Network as Network16 } from "@accelbyte/sdk";
function ItemAdminApi(sdk, args) {
  const sdkAssembly = sdk.assembly();
  const namespace = args?.coreConfig?.namespace ?? sdkAssembly.coreConfig.namespace;
  const useSchemaValidation = args?.coreConfig?.useSchemaValidation ?? sdkAssembly.coreConfig.useSchemaValidation;
  let axiosInstance = sdkAssembly.axiosInstance;
  const requestConfigOverrides = args?.axiosConfig?.request;
  const baseURLOverride = args?.coreConfig?.baseURL;
  const interceptorsOverride = args?.axiosConfig?.interceptors ?? [];
  if (requestConfigOverrides || baseURLOverride || interceptorsOverride.length > 0) {
    const requestConfig = ApiUtils16.mergeAxiosConfigs(sdkAssembly.axiosInstance.defaults, {
      ...baseURLOverride ? { baseURL: baseURLOverride } : {},
      ...requestConfigOverrides
    });
    axiosInstance = Network16.create(requestConfig);
    for (const interceptor of interceptorsOverride) {
      if (interceptor.type === "request") {
        axiosInstance.interceptors.request.use(interceptor.onRequest, interceptor.onError);
      }
      if (interceptor.type === "response") {
        axiosInstance.interceptors.response.use(interceptor.onSuccess, interceptor.onError);
      }
    }
  }
  async function getItemsConfigs() {
    const $ = new ItemAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getItemsConfigs();
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function createItemConfig(data) {
    const $ = new ItemAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.createItemConfig(data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function deleteItemConfig_ById(id) {
    const $ = new ItemAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.deleteItemConfig_ById(id);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getItemConfig_ById(id) {
    const $ = new ItemAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getItemConfig_ById(id);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function updateItemConfig_ById(id, data) {
    const $ = new ItemAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.updateItemConfig_ById(id, data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getItemsConfigsSearch(queryParams) {
    const $ = new ItemAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getItemsConfigsSearch(queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function createItem(data, queryParams) {
    const $ = new ItemAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.createItem(data, queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function updateItem(data, queryParams) {
    const $ = new ItemAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.updateItem(data, queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getItemsByIds(queryParams) {
    const $ = new ItemAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getItemsByIds(queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getItemsBySku(queryParams) {
    const $ = new ItemAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getItemsBySku(queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getItemsSearch(queryParams) {
    const $ = new ItemAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getItemsSearch(queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getItemsByAppId(queryParams) {
    const $ = new ItemAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getItemsByAppId(queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function deleteItem_ByItemId(itemId, queryParams) {
    const $ = new ItemAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.deleteItem_ByItemId(itemId, queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getItem_ByItemId(itemId, queryParams) {
    const $ = new ItemAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getItem_ByItemId(itemId, queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function updateItem_ByItemId(itemId, data, queryParams) {
    const $ = new ItemAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.updateItem_ByItemId(itemId, data, queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getItemsByCriteria(queryParams) {
    const $ = new ItemAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getItemsByCriteria(queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function updateItemRegiondata(data, queryParams) {
    const $ = new ItemAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.updateItemRegiondata(data, queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getApp_ByItemId(itemId, queryParams) {
    const $ = new ItemAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getApp_ByItemId(itemId, queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function updateApp_ByItemId(itemId, data, queryParams) {
    const $ = new ItemAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.updateApp_ByItemId(itemId, data, queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getItemsBySkuLocale(queryParams) {
    const $ = new ItemAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getItemsBySkuLocale(queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getItemsItemIdBySku(queryParams) {
    const $ = new ItemAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getItemsItemIdBySku(queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getItemsLocaleByIds(queryParams) {
    const $ = new ItemAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getItemsLocaleByIds(queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getItemsItemIdBySkus(queryParams) {
    const $ = new ItemAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getItemsItemIdBySkus(queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getItemsUncategorized(queryParams) {
    const $ = new ItemAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getItemsUncategorized(queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getItemsByCriteria_v2(queryParams) {
    const $ = new ItemAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getItemsByCriteria_v2(queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getItemsEstimatedPrice(queryParams) {
    const $ = new ItemAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getItemsEstimatedPrice(queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function updateEnable_ByItemId(itemId, queryParams) {
    const $ = new ItemAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.updateEnable_ByItemId(itemId, queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getLocale_ByItemId(itemId, queryParams) {
    const $ = new ItemAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getLocale_ByItemId(itemId, queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function updateReturn_ByItemId(itemId, data) {
    const $ = new ItemAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.updateReturn_ByItemId(itemId, data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getItemsPredicateTypes() {
    const $ = new ItemAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getItemsPredicateTypes();
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function updateAcquire_ByItemId(itemId, data) {
    const $ = new ItemAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.updateAcquire_ByItemId(itemId, data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function updateDisable_ByItemId(itemId, queryParams) {
    const $ = new ItemAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.updateDisable_ByItemId(itemId, queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getDynamic_ByItemId(itemId) {
    const $ = new ItemAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getDynamic_ByItemId(itemId);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getItemsByFeaturesBasic(queryParams) {
    const $ = new ItemAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getItemsByFeaturesBasic(queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function deleteFeature_ByItemId_ByFeature(itemId, feature, queryParams) {
    const $ = new ItemAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.deleteFeature_ByItemId_ByFeature(itemId, feature, queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function updateFeature_ByItemId_ByFeature(itemId, feature, queryParams) {
    const $ = new ItemAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.updateFeature_ByItemId_ByFeature(itemId, feature, queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function updatePurchaseCondition_ByItemId(itemId, data, queryParams) {
    const $ = new ItemAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.updatePurchaseCondition_ByItemId(itemId, data, queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function createItemPurchaseConditionValidate(data, queryParams) {
    const $ = new ItemAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.createItemPurchaseConditionValidate(data, queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  return {
    /**
     * &lt;b&gt;[Not supported yet in AGS Shared Cloud]&lt;/b&gt;This API is used to get all item type configs.&lt;p&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: the list of items&lt;/li&gt;&lt;/ul&gt;
     */
    getItemsConfigs,
    /**
     * &lt;b&gt;[Not supported yet in AGS Shared Cloud]&lt;/b&gt;This API is used to create an item type config.&lt;p&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: item type config data&lt;/li&gt;&lt;/ul&gt;
     */
    createItemConfig,
    /**
     * &lt;b&gt;[Not supported yet in AGS Shared Cloud]&lt;/b&gt;This API is used to delete an item type config permanently.
     */
    deleteItemConfig_ById,
    /**
     * &lt;b&gt;[Not supported yet in AGS Shared Cloud]&lt;/b&gt;This API is used to get an item type config.&lt;p&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: item type config data&lt;/li&gt;&lt;/ul&gt;
     */
    getItemConfig_ById,
    /**
     * &lt;b&gt;[Not supported yet in AGS Shared Cloud]&lt;/b&gt;This API is used to update an item type config.&lt;p&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: item type config data&lt;/li&gt;&lt;/ul&gt;
     */
    updateItemConfig_ById,
    /**
     * &lt;b&gt;[Not supported yet in AGS Shared Cloud]&lt;/b&gt;This API is used to get an item type config.&lt;p&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: item type config data&lt;/li&gt;&lt;/ul&gt;
     */
    getItemsConfigsSearch,
    /**
     * This API is used to create an item. APP item only can created in publisher namespace.&lt;p&gt;An item create example:&lt;p&gt;&lt;pre&gt;&lt;code&gt;{ &#34;categoryPath&#34;: &#34;/games&#34;, &#34;localizations&#34;: \{ &#34;en&#34;: \{ &#34;title&#34;:&#34;required&#34;, &#34;description&#34;:&#34;optional&#34;, &#34;longDescription&#34;:&#34;optional&#34;, &#34;localExt&#34;: \{ &#34;properties&#34;:\[ \{ &#34;key1&#34;:&#34;value1&#34;, &#34;key2&#34;:&#34;value2&#34; \} \], &#34;functions&#34;:\[ \{ &#34;key1&#34;:&#34;value1&#34;, &#34;key2&#34;:&#34;value2&#34; \} \] \} \} \}, &#34;images&#34;: \[ \{ &#34;as&#34;:&#34;optional, image for&#34;, &#34;caption&#34;:&#34;optional&#34;, &#34;height&#34;:10, &#34;width&#34;:10, &#34;imageUrl&#34;:&#34;http://img-url-required&#34;, &#34;smallImageUrl&#34;:&#34;http://small-img-url-required&#34; \} \], &#34;thumbnailUrl&#34;: &#34;optional, thumbnail url&#34;, &#34;status&#34;: &#34;ACTIVE&#34;, &#34;listable&#34;: true, &#34;purchasable&#34;: true, &#34;itemType&#34;: &#34;APP(allowed: [APP,COINS,INGAMEITEM,CODE,BUNDLE])&#34;, &#34;name&#34;: &#34;required, also will be used as entitlement name&#34;, &#34;entitlementType&#34;: &#34;DURABLE(allowed:[DURABLE,CONSUMABLE], should be CONSUMABLE when item type is COINS)&#34;, &#34;useCount&#34;: 1(optional, required if the entitlement type is consumable), &#34;stackable&#34;: false, &#34;appId&#34;: &#34;optional, required if itemType is APP&#34;, &#34;appType&#34;: &#34;GAME(optional, required if itemType is APP)&#34;, &#34;seasonType&#34;: &#34;PASS(optional, required if itemType is SEASON)&#34;, &#34;baseAppId&#34;: &#34;optional, set value of game app id if you want to link to a game&#34;, &#34;targetCurrencyCode&#34;: &#34;optional, required if itemType is COINS&#34;, &#34;targetNamespace&#34;: &#34;optional, required when itemType is INGAMEITEM, the targetNamespace will only take effect when the item created belongs to the publisher namespace&#34;, &#34;sku&#34;: &#34;optional, commonly unique item code&#34;, &#34;regionData&#34;: \{ &#34;US(store&#39;s default region is required)&#34;: \[ \{ &#34;price&#34;:10, &#34;discountPercentage&#34;: 0(integer, optional, range[0,100], discountedPrice = price \* ((100 - discountPercentage) \* 0.01), will use it to calculate discounted price if it is not 0), &#34;discountAmount&#34;:0(integer, optional, range[0,itemPrice], will use it to calculate discounted price if discountPercentage is 0), &#34;currencyCode&#34;:&#34;code(required, example: USD)&#34;, &#34;currencyNamespace&#34;:&#34;test-ns-required(allow publisher namespace if namespace is publisher namespace, allow publisher and game namespace if namespace is not publisher namespace)&#34;, &#34;trialPrice&#34;:5(required while fixedTrialCycles set, should &gt;=0 and &lt;= price, will same as price if not present), &#34;purchaseAt&#34;:&#34;optional yyyy-MM-dd&#39;T&#39;HH:mm:ss.SSS&#39;Z&#39;&#34;, &#34;expireAt&#34;:&#34;optional yyyy-MM-dd&#39;T&#39;HH:mm:ss.SSS&#39;Z&#39;&#34;, &#34;discountPurchaseAt&#34;:&#34;optional yyyy-MM-dd&#39;T&#39;HH:mm:ss.SSS&#39;Z&#39;&#34;, &#34;discountExpireAt&#34;:&#34;optional yyyy-MM-dd&#39;T&#39;HH:mm:ss.SSS&#39;Z&#39;&#34; \} \] \}, &#34;itemIds&#34;: \[ &#34;itemId&#34; \], &#34;itemQty&#34;: \{ &#34;itemId&#34;:1 \}, &#34;recurring&#34;: \{ &#34;cycle&#34;:&#34;MONTHLY(allowed: [WEEKLY,MONTHLY,QUARTERLY,YEARLY])&#34;, &#34;fixedFreeDays&#34;:0(integer, fixed free days, 0 means not set), &#34;fixedTrialCycles&#34;:0(integer, fixed trial cycles, 0 means not set, will not take effect if fixedFreeDays set), &#34;graceDays&#34;:7(integer, recurring grace days, retry recurring charge within configured days if charge fail, default 7) \}, &#34;tags&#34;: \[ &#34;exampleTag24&#34; \], &#34;features&#34;: \[ &#34;feature&#34; \], &#34;clazz&#34;: &#34;weapon&#34;, &#34;boothName&#34;: &#34;C_campaign1&#34;, &#34;displayOrder&#34;: 1000, &#34;ext&#34;: \{ &#34;properties&#34;:\[ \{ &#34;key1&#34;:&#34;value1&#34;, &#34;key2&#34;:&#34;value2&#34; \} \], &#34;functions&#34;:\[ \{ &#34;key1&#34;:&#34;value1&#34;, &#34;key2&#34;:&#34;value2&#34; \} \] \}, &#34;maxCountPerUser&#34;: 1(integer, optional, -1 means UNLIMITED), &#34;maxCount&#34;: 1(integer, optional, -1 means UNLIMITED, unset when itemType is CODE) }&lt;/code&gt;&lt;/pre&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: created item data&lt;/li&gt;&lt;/ul&gt;&lt;h2&gt;Restrictions for item extension and localization extension and inventory config custom attributes&lt;/h2&gt; 1. Cannot use &lt;b&gt;&#34;.&#34;&lt;/b&gt; as the key name - &lt;pre&gt;{ &#34;data.2&#34;: &#34;value&#34; }&lt;/pre&gt; 2. Cannot use &lt;b&gt;&#34;$&#34;&lt;/b&gt; as the prefix in key names - &lt;pre&gt;{ &#34;$data&#34;: &#34;value&#34; }&lt;/pre&gt;
     */
    createItem,
    /**
     * &lt;b&gt;[Not supported yet in AGS Shared Cloud]&lt;/b&gt;This API is used to sync an in game item in game namespace to publisher namespace, only INGAMEITEM, CODE, COINS and SEASON are supported&lt;p&gt;The synced item has an additional field targetItemId besides targetNamespace, mostly this item should not modified manually again. &lt;p&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: item data&lt;/li&gt;&lt;/ul&gt;
     */
    updateItem,
    /**
     * This API is used to get items.&lt;p&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: the list of items info&lt;/li&gt;&lt;/ul&gt;
     */
    getItemsByIds,
    /**
     * This API is used to get the item by sku.&lt;p&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: the item with sku&lt;/li&gt;&lt;/ul&gt;
     */
    getItemsBySku,
    /**
     * This API is used to search items by keyword in title, description and long description within a store.&lt;p&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: the list of items&lt;/li&gt;&lt;/ul&gt;
     */
    getItemsSearch,
    /**
     * This API is used to get the item by appId.&lt;p&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: the item with that appId&lt;/li&gt;&lt;/ul&gt;
     */
    getItemsByAppId,
    /**
     * This API is used to delete an item permanently.&lt;p&gt;force: the default value should be: false. When the value is: &lt;li&gt;&lt;i&gt;false:&lt;i&gt;only the items in the draft store that have never been published yet can be removed.&lt;/li&gt;&lt;li&gt;&lt;i&gt;true:&lt;i&gt;the item in the draft store(even been published before) can be removed.&lt;/li&gt;
     */
    deleteItem_ByItemId,
    /**
     * This API is used to get an item.&lt;p&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: item data&lt;/li&gt;&lt;/ul&gt;
     */
    getItem_ByItemId,
    /**
     * This API is used to update an item.&lt;p&gt;An item update example:&lt;p&gt;&lt;pre&gt;&lt;code&gt;{ &#34;categoryPath&#34;: &#34;/games&#34;, &#34;localizations&#34;: \{ &#34;en&#34;: \{ &#34;title&#34;:&#34;required&#34;, &#34;description&#34;:&#34;optional&#34;, &#34;longDescription&#34;:&#34;optional&#34;, &#34;localExt&#34;: \{ &#34;properties&#34;:\[ \{ &#34;key1&#34;:&#34;value1&#34;, &#34;key2&#34;:&#34;value2&#34; \} \], &#34;functions&#34;:\[ \{ &#34;key1&#34;:&#34;value1&#34;, &#34;key2&#34;:&#34;value2&#34; \} \] \} \} \}, &#34;images&#34;: \[ \{ &#34;as&#34;:&#34;optional, image for&#34;, &#34;caption&#34;:&#34;optional&#34;, &#34;height&#34;:10, &#34;width&#34;:10, &#34;imageUrl&#34;:&#34;http://img-url-required&#34;, &#34;smallImageUrl&#34;:&#34;http://small-img-url-required&#34; \} \], &#34;thumbnailUrl&#34;: &#34;optional, thumbnail url&#34;, &#34;status&#34;: &#34;ACTIVE&#34;, &#34;listable&#34;: true, &#34;purchasable&#34;: true, &#34;itemType&#34;: &#34;APP(allowed: [APP,COINS,INGAMEITEM,CODE,BUNDLE])&#34;, &#34;name&#34;: &#34;optional&#34;, &#34;entitlementType&#34;: &#34;DURABLE(allowed:[DURABLE,CONSUMABLE], should be CONSUMABLE when item type is COINS)&#34;, &#34;useCount&#34;: 1(optional, required if the entitlement type is consumable), &#34;stackable&#34;: false, &#34;appId&#34;: &#34;optional, required if itemType is APP&#34;, &#34;baseAppId&#34;: &#34;optional, set value of game app id if you want to link to a game&#34;, &#34;appType&#34;: &#34;GAME(optional, required if itemType is APP)&#34;, &#34;seasonType&#34;: &#34;PASS(optional, required if itemType is SEASON)&#34;, &#34;sku&#34;: &#34;optional, commonly unique item code&#34;, &#34;targetCurrencyCode&#34;: &#34;optional, required if itemType is COINS&#34;, &#34;targetNamespace&#34;: &#34;optional, required when itemType is INGAMEITEM, the targetNamespace will only take effect when the item created belongs to the publisher namespace&#34;, &#34;regionData&#34;: \{ &#34;US(store&#39;s default region is required)&#34;: \[ \{ &#34;price&#34;:10, &#34;discountPercentage&#34;:0(integer, optional, range[0,100], discountedPrice = price\*((100 - discountPercentage) \* 0.01), if it is not 0, will use it to calculate discounted price), &#34;discountAmount&#34;:0(integer, optional, range[0,itemPrice], will use it to calculate discounted price if discountPercentage is 0), &#34;currencyCode&#34;:&#34;code(required, example: USD)&#34;, &#34;currencyNamespace&#34;:&#34;test-ns-required(allow publisher namespace if namespace is publisher namespace, allow publisher and game namespace if namespace is not publisher namespace)&#34;, &#34;trialPrice&#34;:5(required while fixedTrialCycles set, should &gt;=0 and &lt;= price, will same as price if not present), &#34;purchaseAt&#34;:&#34;optional yyyy-MM-dd&#39;T&#39;HH:mm:ss.SSS&#39;Z&#39;&#34;, &#34;expireAt&#34;:&#34;optional yyyy-MM-dd&#39;T&#39;HH:mm:ss.SSS&#39;Z&#39;&#34;, &#34;discountPurchaseAt&#34;:&#34;optional yyyy-MM-dd&#39;T&#39;HH:mm:ss.SSS&#39;Z&#39;&#34;, &#34;discountExpireAt&#34;:&#34;optional yyyy-MM-dd&#39;T&#39;HH:mm:ss.SSS&#39;Z&#39;&#34; \} \] \}, &#34;itemIds&#34;: \[ &#34;itemId&#34; \], &#34;itemQty&#34;: \{ &#34;itemId&#34;:1 \}, &#34;recurring&#34;: \{ &#34;cycle&#34;:&#34;MONTHLY(allowed: [WEEKLY,MONTHLY,QUARTERLY,YEARLY])&#34;, &#34;fixedFreeDays&#34;:0(integer, fixed free days, 0 means not set), &#34;fixedTrialCycles&#34;:0(integer, fixed trial cycles, 0 means not set, will not take effect if fixedFreeDays set), &#34;graceDays&#34;:7(integer, recurring grace days, retry recurring charge within configured days if charge fail, default 7) \}, &#34;tags&#34;: \[ &#34;exampleTag24&#34; \], &#34;features&#34;: \[ &#34;feature&#34; \], &#34;clazz&#34;: &#34;weapon&#34;, &#34;boothName&#34;: &#34;C_campaign1&#34;, &#34;displayOrder&#34;: 1000, &#34;ext&#34;: \{ &#34;properties&#34;:\[ \{ &#34;key1&#34;:&#34;value1&#34;, &#34;key2&#34;:&#34;value2&#34; \} \], &#34;functions&#34;:\[ \{ &#34;key1&#34;:&#34;value1&#34;, &#34;key2&#34;:&#34;value2&#34; \} \] \}, &#34;maxCountPerUser&#34;: 1(integer, optional, -1 means UNLIMITED), &#34;maxCount&#34;: 1(integer, optional, -1 means UNLIMITED, new value should &gt;= old value if both old value and new value is limited, unset when item type is CODE) }&lt;/code&gt;&lt;/pre&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: updated item data&lt;/li&gt;&lt;/ul&gt;&lt;h2&gt;Restrictions for item extension and localization extension&lt;/h2&gt; 1. Cannot use &lt;b&gt;&#34;.&#34;&lt;/b&gt; as the key name - &lt;pre&gt;{ &#34;data.2&#34;: &#34;value&#34; }&lt;/pre&gt; 2. Cannot use &lt;b&gt;&#34;$&#34;&lt;/b&gt; as the prefix in key names - &lt;pre&gt;{ &#34;$data&#34;: &#34;value&#34; }&lt;/pre&gt;
     */
    updateItem_ByItemId,
    /**
     * This API is used to query items by criteria within a store.&lt;p&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: the list of items&lt;/li&gt;&lt;/ul&gt;
     */
    getItemsByCriteria,
    /**
     * This API is used to update region data of items in bulk &lt;br /&gt;
     */
    updateItemRegiondata,
    /**
     * This API is used to get an app info.&lt;p&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: app data&lt;/li&gt;&lt;/ul&gt;
     */
    getApp_ByItemId,
    /**
     * This API is used to update an app.&lt;p&gt;An app update example:&lt;p&gt;&lt;pre&gt;&lt;code&gt;{ &#34;developer&#34;: &#34;accelbyte&#34;, &#34;publisher&#34;: &#34;accelbyte&#34;, &#34;websiteUrl&#34;: &#34;http://accelbyte.io&#34;, &#34;forumUrl&#34;: &#34;http://accelbyte.io&#34;, &#34;platforms&#34;: \[&#34;Windows(allowed values: Windows, MacOS, Linux, IOS, Android)&#34;\], &#34;platformRequirements&#34;: \{ &#34;Windows&#34;: \[ \{ &#34;label&#34;:&#34;minimum(can be minimum or recommended)&#34;, &#34;osVersion&#34;:&#34;os version&#34;, &#34;processor&#34;:&#34;processor&#34;, &#34;ram&#34;:&#34;RAM&#34;, &#34;graphics&#34;:&#34;graphics&#34;, &#34;directXVersion&#34;:&#34;directXVersion&#34;, &#34;diskSpace&#34;:&#34;diskSpace&#34;, &#34;soundCard&#34;:&#34;soundCard&#34;, &#34;additionals&#34;:&#34;additionals&#34; \} \] \}, &#34;carousel&#34;: \[ \{ &#34;type&#34;:&#34;image(allowed values: image, video)&#34;, &#34;videoSource&#34;:&#34;generic(allowed values:generic, youtube, viemo)&#34;, &#34;url&#34;:&#34;url&#34;, &#34;alt&#34;:&#34;alternative url or text&#34;, &#34;thumbnailUrl&#34;:&#34;thumbnail url&#34;, &#34;previewUrl&#34;:&#34;preview url&#34;, \} \], &#34;localizations&#34;: \{ &#34;en&#34;: \{ &#34;slogan&#34;:&#34;slogan&#34;, &#34;announcement&#34;:&#34;announcement&#34;, \} \}, &#34;primaryGenre&#34;: &#34;Action&#34;, &#34;genres&#34;: \[&#34;Action&#34;, &#34;Adventure&#34;\], &#34;players&#34;: \[&#34;Single&#34;\], &#34;releaseDate&#34;: &#34;optional yyyy-MM-dd&#39;T&#39;HH:mm:ss.SSS&#39;Z&#39;&#34; }&lt;/code&gt;&lt;/pre&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: updated app data&lt;/li&gt;&lt;/ul&gt;
     */
    updateApp_ByItemId,
    /**
     * This API is used to get an item by sku in specific locale. If item not exist in specific region, default region item will return.&lt;p&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: item data&lt;/li&gt;&lt;/ul&gt;
     */
    getItemsBySkuLocale,
    /**
     * &lt;b&gt;[SERVICE COMMUNICATION ONLY]&lt;/b&gt; This API is used to get the itemId by sku.&lt;p&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: the itemId with sku&lt;/li&gt;&lt;/ul&gt;
     */
    getItemsItemIdBySku,
    /**
     * This API is used to bulk get locale items. If item not exist in specific region, default region item will return.&lt;p&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: the list of items info&lt;/li&gt;&lt;/ul&gt;
     */
    getItemsLocaleByIds,
    /**
     * This API is used to get an list of itemId by list of sku.&lt;p&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: item data&lt;/li&gt;&lt;/ul&gt;
     */
    getItemsItemIdBySkus,
    /**
     * This API is used to query uncategorized items within a store.&lt;p&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: the list of uncategorized items&lt;/li&gt;&lt;/ul&gt;
     */
    getItemsUncategorized,
    /**
     * This API is used to query items by criteria within a store.&lt;p&gt;The behaviour for itemStatus query parameter:&lt;li&gt;TRUE: Show only ACTIVE items&lt;/li&gt;&lt;li&gt;FALSE: Show only INACTIVE items&lt;/li&gt;&lt;li&gt;Not provided: show both ACTIVE and INACTIVE items&lt;/li&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: the list of items&lt;/li&gt;&lt;/ul&gt;
     */
    getItemsByCriteria_v2,
    /**
     * This API is used to get estimated prices of a flexible pricing bundle
     */
    getItemsEstimatedPrice,
    /**
     * Enable an item.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: updated item&lt;/li&gt;&lt;/ul&gt;
     */
    updateEnable_ByItemId,
    /**
     * This API is used to get an item in specific locale. If item not exist in specific region, default region item will return.&lt;p&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: item data&lt;/li&gt;&lt;/ul&gt;
     */
    getLocale_ByItemId,
    /**
     * &lt;b&gt;[SERVICE COMMUNICATION ONLY]&lt;/b&gt; This api is used for returning a published item while the item is maxCount limited, it will increase the sale available count if orderNo already acquired.
     */
    updateReturn_ByItemId,
    /**
     * Get available predicate types.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: available predicate types&lt;/li&gt;&lt;/ul&gt;
     */
    getItemsPredicateTypes,
    /**
     * &lt;b&gt;[SERVICE COMMUNICATION ONLY]&lt;/b&gt; This api is used for acquiring a published item while the item is maxCount limited, it will decrease the sale available count.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: acquire result&lt;/li&gt;&lt;/ul&gt;
     */
    updateAcquire_ByItemId,
    /**
     * Disable an item.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: updated item&lt;/li&gt;&lt;/ul&gt;
     */
    updateDisable_ByItemId,
    /**
     * Get item dynamic data for published item.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: item dynamic data&lt;/li&gt;&lt;/ul&gt;
     */
    getDynamic_ByItemId,
    /**
     * &lt;b&gt;[SERVICE COMMUNICATION ONLY]&lt;/b&gt; This API is used to list basic items by features.&lt;p&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: the list of basic items&lt;/li&gt;&lt;/ul&gt;
     */
    getItemsByFeaturesBasic,
    /**
     * Remove a feature from an item.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: updated item&lt;/li&gt;&lt;/ul&gt;
     */
    deleteFeature_ByItemId_ByFeature,
    /**
     * Add a feature to an item.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: updated item&lt;/li&gt;&lt;/ul&gt;
     */
    updateFeature_ByItemId_ByFeature,
    /**
     * This API is used to update item purchase condition
     */
    updatePurchaseCondition_ByItemId,
    /**
     * This API is used to validate user purchase condition
     */
    createItemPurchaseConditionValidate
  };
}

// src/generated-admin/KeyGroupAdminApi.ts
import { ApiUtils as ApiUtils17, Network as Network17 } from "@accelbyte/sdk";
function KeyGroupAdminApi(sdk, args) {
  const sdkAssembly = sdk.assembly();
  const namespace = args?.coreConfig?.namespace ?? sdkAssembly.coreConfig.namespace;
  const useSchemaValidation = args?.coreConfig?.useSchemaValidation ?? sdkAssembly.coreConfig.useSchemaValidation;
  let axiosInstance = sdkAssembly.axiosInstance;
  const requestConfigOverrides = args?.axiosConfig?.request;
  const baseURLOverride = args?.coreConfig?.baseURL;
  const interceptorsOverride = args?.axiosConfig?.interceptors ?? [];
  if (requestConfigOverrides || baseURLOverride || interceptorsOverride.length > 0) {
    const requestConfig = ApiUtils17.mergeAxiosConfigs(sdkAssembly.axiosInstance.defaults, {
      ...baseURLOverride ? { baseURL: baseURLOverride } : {},
      ...requestConfigOverrides
    });
    axiosInstance = Network17.create(requestConfig);
    for (const interceptor of interceptorsOverride) {
      if (interceptor.type === "request") {
        axiosInstance.interceptors.request.use(interceptor.onRequest, interceptor.onError);
      }
      if (interceptor.type === "response") {
        axiosInstance.interceptors.response.use(interceptor.onSuccess, interceptor.onError);
      }
    }
  }
  async function getKeygroups(queryParams) {
    const $ = new KeyGroupAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getKeygroups(queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function createKeygroup(data) {
    const $ = new KeyGroupAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.createKeygroup(data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getKeygroupsByBoothName(queryParams) {
    const $ = new KeyGroupAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getKeygroupsByBoothName(queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getKeygroup_ByKeyGroupId(keyGroupId) {
    const $ = new KeyGroupAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getKeygroup_ByKeyGroupId(keyGroupId);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function updateKeygroup_ByKeyGroupId(keyGroupId, data) {
    const $ = new KeyGroupAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.updateKeygroup_ByKeyGroupId(keyGroupId, data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getKeys_ByKeyGroupId(keyGroupId, queryParams) {
    const $ = new KeyGroupAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getKeys_ByKeyGroupId(keyGroupId, queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function createKey_ByKeyGroupId(keyGroupId, data) {
    const $ = new KeyGroupAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.createKey_ByKeyGroupId(keyGroupId, data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getDynamic_ByKeyGroupId(keyGroupId) {
    const $ = new KeyGroupAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getDynamic_ByKeyGroupId(keyGroupId);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  return {
    /**
     * Query key groups, if name is presented, it&#39;s fuzzy match.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: slice of key group&lt;/li&gt;&lt;/ul&gt;
     */
    getKeygroups,
    /**
     * Create key group.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: created key group&lt;/li&gt;&lt;/ul&gt;
     */
    createKeygroup,
    /**
     * @deprecated
     * Get key group.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: key group info&lt;/li&gt;&lt;/ul&gt;
     */
    getKeygroupsByBoothName,
    /**
     * Get key group.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: key group info&lt;/li&gt;&lt;/ul&gt;
     */
    getKeygroup_ByKeyGroupId,
    /**
     * Update key group.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: updated key group&lt;/li&gt;&lt;/ul&gt;
     */
    updateKeygroup_ByKeyGroupId,
    /**
     * This API is used to list keys of a key group.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: keys&lt;/li&gt;&lt;/ul&gt;
     */
    getKeys_ByKeyGroupId,
    /**
     * This API is used to upload keys with csv format to a key group.&lt;p&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: item data&lt;/li&gt;&lt;/ul&gt;
     */
    createKey_ByKeyGroupId,
    /**
     * Get key group dynamic.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: key group info&lt;/li&gt;&lt;/ul&gt;
     */
    getDynamic_ByKeyGroupId
  };
}

// src/generated-admin/OrderAdminApi.ts
import { ApiUtils as ApiUtils18, Network as Network18 } from "@accelbyte/sdk";
function OrderAdminApi(sdk, args) {
  const sdkAssembly = sdk.assembly();
  const namespace = args?.coreConfig?.namespace ?? sdkAssembly.coreConfig.namespace;
  const useSchemaValidation = args?.coreConfig?.useSchemaValidation ?? sdkAssembly.coreConfig.useSchemaValidation;
  let axiosInstance = sdkAssembly.axiosInstance;
  const requestConfigOverrides = args?.axiosConfig?.request;
  const baseURLOverride = args?.coreConfig?.baseURL;
  const interceptorsOverride = args?.axiosConfig?.interceptors ?? [];
  if (requestConfigOverrides || baseURLOverride || interceptorsOverride.length > 0) {
    const requestConfig = ApiUtils18.mergeAxiosConfigs(sdkAssembly.axiosInstance.defaults, {
      ...baseURLOverride ? { baseURL: baseURLOverride } : {},
      ...requestConfigOverrides
    });
    axiosInstance = Network18.create(requestConfig);
    for (const interceptor of interceptorsOverride) {
      if (interceptor.type === "request") {
        axiosInstance.interceptors.request.use(interceptor.onRequest, interceptor.onError);
      }
      if (interceptor.type === "response") {
        axiosInstance.interceptors.response.use(interceptor.onSuccess, interceptor.onError);
      }
    }
  }
  async function getOrders(queryParams) {
    const $ = new OrderAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getOrders(queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getOrdersStats() {
    const $ = new OrderAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getOrdersStats();
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getOrder_ByOrderNo(orderNo) {
    const $ = new OrderAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getOrder_ByOrderNo(orderNo);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getOrders_ByUserId(userId, queryParams) {
    const $ = new OrderAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getOrders_ByUserId(userId, queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function createOrder_ByUserId(userId, data) {
    const $ = new OrderAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.createOrder_ByUserId(userId, data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function updateRefund_ByOrderNo(orderNo, data) {
    const $ = new OrderAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.updateRefund_ByOrderNo(orderNo, data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getOrder_ByUserId_ByOrderNo(userId, orderNo) {
    const $ = new OrderAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getOrder_ByUserId_ByOrderNo(userId, orderNo);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function updateOrder_ByUserId_ByOrderNo(userId, orderNo, data) {
    const $ = new OrderAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.updateOrder_ByUserId_ByOrderNo(userId, orderNo, data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getOrdersCountOfItem_ByUserId(userId, queryParams) {
    const $ = new OrderAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getOrdersCountOfItem_ByUserId(userId, queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getGrant_ByUserId_ByOrderNo(userId, orderNo) {
    const $ = new OrderAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getGrant_ByUserId_ByOrderNo(userId, orderNo);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function updateFulfill_ByUserId_ByOrderNo(userId, orderNo) {
    const $ = new OrderAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.updateFulfill_ByUserId_ByOrderNo(userId, orderNo);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getHistory_ByUserId_ByOrderNo(userId, orderNo) {
    const $ = new OrderAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getHistory_ByUserId_ByOrderNo(userId, orderNo);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getReceiptPdf_ByUserId_ByOrderNo(userId, orderNo) {
    const $ = new OrderAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getReceiptPdf_ByUserId_ByOrderNo(userId, orderNo);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function createNotification_ByUserId_ByOrderNo(userId, orderNo, data) {
    const $ = new OrderAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.createNotification_ByUserId_ByOrderNo(userId, orderNo, data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  return {
    /**
     * Query orders.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: query orders&lt;/li&gt;&lt;/ul&gt;
     */
    getOrders,
    /**
     * Get Order Statistics.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: order statistics&lt;/li&gt;&lt;/ul&gt;
     */
    getOrdersStats,
    /**
     * Get order by orderNo.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: order instance&lt;/li&gt;&lt;/ul&gt;
     */
    getOrder_ByOrderNo,
    /**
     * Query user orders.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: get order&lt;/li&gt;&lt;/ul&gt;
     */
    getOrders_ByUserId,
    /**
     * Admin Create an order. The result contains the checkout link and payment token. User with permission SANDBOX will create sandbox order that not real paid for xsolla/alipay and not validate price for wxpay.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;It will be forbidden while the user is banned: ORDER_INITIATE or ORDER_AND_PAYMENT&lt;/li&gt;&lt;li&gt;sandbox default value is &lt;b&gt;false&lt;/b&gt;&lt;/li&gt;&lt;li&gt;platform default value is &lt;b&gt;Other&lt;/b&gt;&lt;/li&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: created order&lt;/li&gt;&lt;/ul&gt;&lt;h2&gt;Restrictions for ext field&lt;/h2&gt; 1. Cannot use &lt;b&gt;&#34;.&#34;&lt;/b&gt; as the key name - &lt;pre&gt;{ &#34;data.2&#34;: &#34;value&#34; }&lt;/pre&gt; 2. Cannot use &lt;b&gt;&#34;$&#34;&lt;/b&gt; as the prefix in key names - &lt;pre&gt;{ &#34;$data&#34;: &#34;value&#34; }&lt;/pre&gt;
     */
    createOrder_ByUserId,
    /**
     * Refund order by orderNo.
     */
    updateRefund_ByOrderNo,
    /**
     * Get an order.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: get order&lt;/li&gt;&lt;/ul&gt;
     */
    getOrder_ByUserId_ByOrderNo,
    /**
     * Update order status.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: updated order&lt;/li&gt;&lt;/ul&gt;
     */
    updateOrder_ByUserId_ByOrderNo,
    /**
     * This API is used to get the count of purchased item which is the order target.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: Item purchased count&lt;/li&gt;&lt;/ul&gt;
     */
    getOrdersCountOfItem_ByUserId,
    /**
     * @deprecated
     * Get user order grant that fulfilled by this order.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: get order grant&lt;/li&gt;&lt;/ul&gt;
     */
    getGrant_ByUserId_ByOrderNo,
    /**
     * Fulfill an order if the order is charged but fulfill failed.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: fulfilled order&lt;/li&gt;&lt;/ul&gt;
     */
    updateFulfill_ByUserId_ByOrderNo,
    /**
     * Get user order history.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: get order history&lt;/li&gt;&lt;/ul&gt;
     */
    getHistory_ByUserId_ByOrderNo,
    /**
     * Download user order receipt by orderNo.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: order receipt pdf&lt;/li&gt;&lt;/ul&gt;
     */
    getReceiptPdf_ByUserId_ByOrderNo,
    /**
     * &lt;b&gt;[SERVICE COMMUNICATION ONLY]&lt;/b&gt; This API is used as a web hook for payment notification from justice payment service.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: Process result&lt;/li&gt;&lt;/ul&gt;
     */
    createNotification_ByUserId_ByOrderNo
  };
}

// src/generated-admin/OrderDedicatedAdminApi.ts
import { ApiUtils as ApiUtils19, Network as Network19 } from "@accelbyte/sdk";
function OrderDedicatedAdminApi(sdk, args) {
  const sdkAssembly = sdk.assembly();
  const namespace = args?.coreConfig?.namespace ?? sdkAssembly.coreConfig.namespace;
  const useSchemaValidation = args?.coreConfig?.useSchemaValidation ?? sdkAssembly.coreConfig.useSchemaValidation;
  let axiosInstance = sdkAssembly.axiosInstance;
  const requestConfigOverrides = args?.axiosConfig?.request;
  const baseURLOverride = args?.coreConfig?.baseURL;
  const interceptorsOverride = args?.axiosConfig?.interceptors ?? [];
  if (requestConfigOverrides || baseURLOverride || interceptorsOverride.length > 0) {
    const requestConfig = ApiUtils19.mergeAxiosConfigs(sdkAssembly.axiosInstance.defaults, {
      ...baseURLOverride ? { baseURL: baseURLOverride } : {},
      ...requestConfigOverrides
    });
    axiosInstance = Network19.create(requestConfig);
    for (const interceptor of interceptorsOverride) {
      if (interceptor.type === "request") {
        axiosInstance.interceptors.request.use(interceptor.onRequest, interceptor.onError);
      }
      if (interceptor.type === "response") {
        axiosInstance.interceptors.response.use(interceptor.onSuccess, interceptor.onError);
      }
    }
  }
  async function getOrders(queryParams) {
    const $ = new OrderDedicatedAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getOrders(queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  return {
    /**
     * &lt;b&gt;[Not supported yet in AGS Shared Cloud]&lt;/b&gt;Sync orders. If response contains nextEvaluatedKey, please use it as query param in the next call to fetch the next batch, a batch has 1000 elements or less.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: sync orders&lt;/li&gt;&lt;/ul&gt;
     */
    getOrders
  };
}

// src/generated-admin/PaymentAdminApi.ts
import { ApiUtils as ApiUtils20, Network as Network20 } from "@accelbyte/sdk";
function PaymentAdminApi(sdk, args) {
  const sdkAssembly = sdk.assembly();
  const namespace = args?.coreConfig?.namespace ?? sdkAssembly.coreConfig.namespace;
  const useSchemaValidation = args?.coreConfig?.useSchemaValidation ?? sdkAssembly.coreConfig.useSchemaValidation;
  let axiosInstance = sdkAssembly.axiosInstance;
  const requestConfigOverrides = args?.axiosConfig?.request;
  const baseURLOverride = args?.coreConfig?.baseURL;
  const interceptorsOverride = args?.axiosConfig?.interceptors ?? [];
  if (requestConfigOverrides || baseURLOverride || interceptorsOverride.length > 0) {
    const requestConfig = ApiUtils20.mergeAxiosConfigs(sdkAssembly.axiosInstance.defaults, {
      ...baseURLOverride ? { baseURL: baseURLOverride } : {},
      ...requestConfigOverrides
    });
    axiosInstance = Network20.create(requestConfig);
    for (const interceptor of interceptorsOverride) {
      if (interceptor.type === "request") {
        axiosInstance.interceptors.request.use(interceptor.onRequest, interceptor.onError);
      }
      if (interceptor.type === "response") {
        axiosInstance.interceptors.response.use(interceptor.onSuccess, interceptor.onError);
      }
    }
  }
  async function getPaymentOrders(queryParams) {
    const $ = new PaymentAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getPaymentOrders(queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getPaymentNotifications(queryParams) {
    const $ = new PaymentAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getPaymentNotifications(queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getPaymentOrdersByExtTxId(queryParams) {
    const $ = new PaymentAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getPaymentOrdersByExtTxId(queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function createPaymentOrder_ByUserId(userId, data) {
    const $ = new PaymentAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.createPaymentOrder_ByUserId(userId, data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getPaymentOrder_ByPaymentOrderNo(paymentOrderNo) {
    const $ = new PaymentAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getPaymentOrder_ByPaymentOrderNo(paymentOrderNo);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function updatePaymentOrder_ByPaymentOrderNo(paymentOrderNo, data) {
    const $ = new PaymentAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.updatePaymentOrder_ByPaymentOrderNo(paymentOrderNo, data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getStatusPayment_ByPaymentOrderNo(paymentOrderNo) {
    const $ = new PaymentAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getStatusPayment_ByPaymentOrderNo(paymentOrderNo);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function updateSimulateNotificationPayment_ByPaymentOrderNo(paymentOrderNo, data) {
    const $ = new PaymentAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.updateSimulateNotificationPayment_ByPaymentOrderNo(paymentOrderNo, data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function updateRefundPayment_ByUserId_ByPaymentOrderNo(userId, paymentOrderNo, data) {
    const $ = new PaymentAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.updateRefundPayment_ByUserId_ByPaymentOrderNo(userId, paymentOrderNo, data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  return {
    /**
     * &lt;b&gt;[Not supported yet in AGS Shared Cloud]&lt;/b&gt;Query payment orders.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: query payment orders&lt;/li&gt;&lt;/ul&gt;
     */
    getPaymentOrders,
    /**
     * &lt;b&gt;[Not supported yet in AGS Shared Cloud]&lt;/b&gt;Query payment notifications.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: Payment notifications&lt;/li&gt;&lt;/ul&gt;
     */
    getPaymentNotifications,
    /**
     * &lt;b&gt;[Not supported yet in AGS Shared Cloud]&lt;/b&gt;List external order No by external transaction id.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: payment orders&lt;/li&gt;&lt;/ul&gt;
     */
    getPaymentOrdersByExtTxId,
    /**
     * &lt;b&gt;[Not supported yet in AGS Shared Cloud]&lt;/b&gt;&lt;b&gt;[SERVICE COMMUNICATION ONLY]&lt;/b&gt; This API is used to create payment order from justice service. The result contains the payment station url.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;It will be forbidden while the user is banned: PAYMENT_INITIATE or ORDER_AND_PAYMENT&lt;/li&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: created order&lt;/li&gt;&lt;/ul&gt;&lt;h2&gt;Restrictions for custom parameters and meta data&lt;/h2&gt; 1. Cannot use &lt;b&gt;&#34;.&#34;&lt;/b&gt; as the key name - &lt;pre&gt;{ &#34;data.2&#34;: &#34;value&#34; }&lt;/pre&gt; 2. Cannot use &lt;b&gt;&#34;$&#34;&lt;/b&gt; as the prefix in key names - &lt;pre&gt;{ &#34;$data&#34;: &#34;value&#34; }&lt;/pre&gt;
     */
    createPaymentOrder_ByUserId,
    /**
     * &lt;b&gt;[Not supported yet in AGS Shared Cloud]&lt;/b&gt;Get payment order by paymentOrderNo.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: payment order instance&lt;/li&gt;&lt;/ul&gt;
     */
    getPaymentOrder_ByPaymentOrderNo,
    /**
     * &lt;b&gt;[Not supported yet in AGS Shared Cloud]&lt;/b&gt;&lt;b&gt;[TEST FACILITY ONLY] Forbidden in live environment. &lt;/b&gt; Charge payment order without payment flow for unpaid payment order, usually for test usage to simulate real currency payment process.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: payment order instance&lt;/li&gt;&lt;/ul&gt;
     */
    updatePaymentOrder_ByPaymentOrderNo,
    /**
     * &lt;b&gt;[Not supported yet in AGS Shared Cloud]&lt;/b&gt;Get payment order charge status.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: payment order charge status&lt;/li&gt;&lt;/ul&gt;
     */
    getStatusPayment_ByPaymentOrderNo,
    /**
     * &lt;b&gt;[Not supported yet in AGS Shared Cloud]&lt;/b&gt;&lt;b&gt;[TEST FACILITY ONLY] Forbidden in live environment. &lt;/b&gt; Simulate payment notification on sandbox payment order, usually for test usage to simulate real currency payment notification.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: notification process result&lt;/li&gt;&lt;/ul&gt;
     */
    updateSimulateNotificationPayment_ByPaymentOrderNo,
    /**
     * &lt;b&gt;[Not supported yet in AGS Shared Cloud]&lt;/b&gt;&lt;b&gt;[SERVICE COMMUNICATION ONLY]&lt;/b&gt; This API is used to refund order by paymentOrderNo from justice service.
     */
    updateRefundPayment_ByUserId_ByPaymentOrderNo
  };
}

// src/generated-admin/PaymentCallbackConfigAdminApi.ts
import { ApiUtils as ApiUtils21, Network as Network21 } from "@accelbyte/sdk";
function PaymentCallbackConfigAdminApi(sdk, args) {
  const sdkAssembly = sdk.assembly();
  const namespace = args?.coreConfig?.namespace ?? sdkAssembly.coreConfig.namespace;
  const useSchemaValidation = args?.coreConfig?.useSchemaValidation ?? sdkAssembly.coreConfig.useSchemaValidation;
  let axiosInstance = sdkAssembly.axiosInstance;
  const requestConfigOverrides = args?.axiosConfig?.request;
  const baseURLOverride = args?.coreConfig?.baseURL;
  const interceptorsOverride = args?.axiosConfig?.interceptors ?? [];
  if (requestConfigOverrides || baseURLOverride || interceptorsOverride.length > 0) {
    const requestConfig = ApiUtils21.mergeAxiosConfigs(sdkAssembly.axiosInstance.defaults, {
      ...baseURLOverride ? { baseURL: baseURLOverride } : {},
      ...requestConfigOverrides
    });
    axiosInstance = Network21.create(requestConfig);
    for (const interceptor of interceptorsOverride) {
      if (interceptor.type === "request") {
        axiosInstance.interceptors.request.use(interceptor.onRequest, interceptor.onError);
      }
      if (interceptor.type === "response") {
        axiosInstance.interceptors.response.use(interceptor.onSuccess, interceptor.onError);
      }
    }
  }
  async function getPaymentConfigCallback() {
    const $ = new PaymentCallbackConfigAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getPaymentConfigCallback();
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function updatePaymentConfigCallback(data) {
    const $ = new PaymentCallbackConfigAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.updatePaymentConfigCallback(data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  return {
    /**
     * &lt;b&gt;[Not supported yet in AGS Shared Cloud]&lt;/b&gt;Get payment callback configuration.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: Payment callback config&lt;/li&gt;&lt;/ul&gt;
     */
    getPaymentConfigCallback,
    /**
     * &lt;b&gt;[Not supported yet in AGS Shared Cloud]&lt;/b&gt;Update payment callback configuration.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: Payment callback config&lt;/li&gt;&lt;/ul&gt;
     */
    updatePaymentConfigCallback
  };
}

// src/generated-admin/PaymentConfigAdminApi.ts
import { ApiUtils as ApiUtils22, Network as Network22 } from "@accelbyte/sdk";
function PaymentConfigAdminApi(sdk, args) {
  const sdkAssembly = sdk.assembly();
  const namespace = args?.coreConfig?.namespace ?? sdkAssembly.coreConfig.namespace;
  const useSchemaValidation = args?.coreConfig?.useSchemaValidation ?? sdkAssembly.coreConfig.useSchemaValidation;
  let axiosInstance = sdkAssembly.axiosInstance;
  const requestConfigOverrides = args?.axiosConfig?.request;
  const baseURLOverride = args?.coreConfig?.baseURL;
  const interceptorsOverride = args?.axiosConfig?.interceptors ?? [];
  if (requestConfigOverrides || baseURLOverride || interceptorsOverride.length > 0) {
    const requestConfig = ApiUtils22.mergeAxiosConfigs(sdkAssembly.axiosInstance.defaults, {
      ...baseURLOverride ? { baseURL: baseURLOverride } : {},
      ...requestConfigOverrides
    });
    axiosInstance = Network22.create(requestConfig);
    for (const interceptor of interceptorsOverride) {
      if (interceptor.type === "request") {
        axiosInstance.interceptors.request.use(interceptor.onRequest, interceptor.onError);
      }
      if (interceptor.type === "response") {
        axiosInstance.interceptors.response.use(interceptor.onSuccess, interceptor.onError);
      }
    }
  }
  async function getPaymentConfigTax() {
    const $ = new PaymentConfigAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getPaymentConfigTax();
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function updatePaymentConfigTax(data) {
    const $ = new PaymentConfigAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.updatePaymentConfigTax(data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getPaymentConfigProvider(queryParams) {
    const $ = new PaymentConfigAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getPaymentConfigProvider(queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function createPaymentConfigProvider(data) {
    const $ = new PaymentConfigAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.createPaymentConfigProvider(data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getPaymentConfigMerchant_ById(id) {
    const $ = new PaymentConfigAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getPaymentConfigMerchant_ById(id);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function deletePaymentConfigProvider_ById(id) {
    const $ = new PaymentConfigAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.deletePaymentConfigProvider_ById(id);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function updatePaymentConfigProvider_ById(id, data) {
    const $ = new PaymentConfigAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.updatePaymentConfigProvider_ById(id, data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getPaymentConfigMerchantMatched(queryParams) {
    const $ = new PaymentConfigAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getPaymentConfigMerchantMatched(queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getPaymentConfigProviderMatched(queryParams) {
    const $ = new PaymentConfigAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getPaymentConfigProviderMatched(queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getPaymentConfigProviderSpecial() {
    const $ = new PaymentConfigAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getPaymentConfigProviderSpecial();
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getPaymentConfigProviderAggregate() {
    const $ = new PaymentConfigAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getPaymentConfigProviderAggregate();
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function updateAdyenconfigPayment_ById(id, data, queryParams) {
    const $ = new PaymentConfigAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.updateAdyenconfigPayment_ById(id, data, queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function updateWxpayconfigPayment_ById(id, data, queryParams) {
    const $ = new PaymentConfigAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.updateWxpayconfigPayment_ById(id, data, queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function createPaymentConfigMerchantAdyenconfigTest(data, queryParams) {
    const $ = new PaymentConfigAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.createPaymentConfigMerchantAdyenconfigTest(data, queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function createPaymentConfigMerchantWxpayconfigTest(data) {
    const $ = new PaymentConfigAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.createPaymentConfigMerchantWxpayconfigTest(data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function updateAlipayconfigPayment_ById(id, data, queryParams) {
    const $ = new PaymentConfigAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.updateAlipayconfigPayment_ById(id, data, queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function updatePaypalconfigPayment_ById(id, data, queryParams) {
    const $ = new PaymentConfigAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.updatePaypalconfigPayment_ById(id, data, queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function updateStripeconfigPayment_ById(id, data, queryParams) {
    const $ = new PaymentConfigAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.updateStripeconfigPayment_ById(id, data, queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function updateXsollaconfigPayment_ById(id, data, queryParams) {
    const $ = new PaymentConfigAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.updateXsollaconfigPayment_ById(id, data, queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function createPaymentConfigMerchantAlipayconfigTest(data, queryParams) {
    const $ = new PaymentConfigAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.createPaymentConfigMerchantAlipayconfigTest(data, queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function createPaymentConfigMerchantPaypalconfigTest(data, queryParams) {
    const $ = new PaymentConfigAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.createPaymentConfigMerchantPaypalconfigTest(data, queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function createPaymentConfigMerchantStripeconfigTest(data, queryParams) {
    const $ = new PaymentConfigAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.createPaymentConfigMerchantStripeconfigTest(data, queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function createPaymentConfigMerchantXsollaconfigTest(data) {
    const $ = new PaymentConfigAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.createPaymentConfigMerchantXsollaconfigTest(data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function updateNeonpayconfigPayment_ById(id, data, queryParams) {
    const $ = new PaymentConfigAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.updateNeonpayconfigPayment_ById(id, data, queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function createPaymentConfigMerchantNeonpayconfigTest(data, queryParams) {
    const $ = new PaymentConfigAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.createPaymentConfigMerchantNeonpayconfigTest(data, queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function updateCheckoutconfigPayment_ById(id, data, queryParams) {
    const $ = new PaymentConfigAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.updateCheckoutconfigPayment_ById(id, data, queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function updateXsollauiconfigPayment_ById(id, data) {
    const $ = new PaymentConfigAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.updateXsollauiconfigPayment_ById(id, data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function createPaymentConfigMerchantCheckoutconfigTest(data, queryParams) {
    const $ = new PaymentConfigAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.createPaymentConfigMerchantCheckoutconfigTest(data, queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getPaymentConfigDomains() {
    const $ = new PaymentConfigAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getPaymentConfigDomains();
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function updatePaymentConfigDomain(data) {
    const $ = new PaymentConfigAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.updatePaymentConfigDomain(data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getAdyenconfigTestPayment_ById(id, queryParams) {
    const $ = new PaymentConfigAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getAdyenconfigTestPayment_ById(id, queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function updateWxpayconfigCertPayment_ById(id, data) {
    const $ = new PaymentConfigAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.updateWxpayconfigCertPayment_ById(id, data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getWxpayconfigTestPayment_ById(id) {
    const $ = new PaymentConfigAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getWxpayconfigTestPayment_ById(id);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getAlipayconfigTestPayment_ById(id, queryParams) {
    const $ = new PaymentConfigAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getAlipayconfigTestPayment_ById(id, queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getPaypalconfigTestPayment_ById(id, queryParams) {
    const $ = new PaymentConfigAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getPaypalconfigTestPayment_ById(id, queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getStripeconfigTestPayment_ById(id, queryParams) {
    const $ = new PaymentConfigAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getStripeconfigTestPayment_ById(id, queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getXsollaconfigTestPayment_ById(id) {
    const $ = new PaymentConfigAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getXsollaconfigTestPayment_ById(id);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getNeonpayconfigTestPayment_ById(id, queryParams) {
    const $ = new PaymentConfigAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getNeonpayconfigTestPayment_ById(id, queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getCheckoutconfigTestPayment_ById(id, queryParams) {
    const $ = new PaymentConfigAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getCheckoutconfigTestPayment_ById(id, queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  return {
    /**
     * &lt;b&gt;[Not supported yet in AGS Shared Cloud]&lt;/b&gt;Get payment global tax config.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: payment provider list&lt;/li&gt;&lt;/ul&gt;
     */
    getPaymentConfigTax,
    /**
     * &lt;b&gt;[Not supported yet in AGS Shared Cloud]&lt;/b&gt;Update payment tax config.&lt;br&gt;&lt;pre&gt;&lt;p&gt;&lt;strong&gt;Request Body Parameters:&lt;/strong&gt;&lt;/p&gt;&lt;pre&gt;&lt;table&gt;&lt;tr&gt;&lt;td&gt;Parameter&lt;/td&gt;&lt;td&gt;Type&lt;/td&gt;&lt;td&gt;Required&lt;/td&gt;&lt;td&gt;Description&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;taxJarEnabled&lt;/td&gt;&lt;td&gt;Boolean&lt;/td&gt;&lt;td&gt;false&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;taxJarApiToken&lt;/td&gt;&lt;td&gt;String&lt;/td&gt;&lt;td&gt;false&lt;/td&gt;&lt;td&gt;required, when taxJarEnabled is true and there is no existing token&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;sandboxTaxJarApiToken&lt;/td&gt;&lt;td&gt;String&lt;/td&gt;&lt;td&gt;false&lt;/td&gt;&lt;td&gt;optional&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;taxJarProductCodesMapping&lt;/td&gt;&lt;td&gt;Map&lt;/td&gt;&lt;td&gt;No&lt;/td&gt;&lt;td&gt;key is item type(APP|COINS|INGAMEITEM|BUNDLE|CODE|SUBSCRIPTION) and value is product tax code: https://developers.taxjar.com/api/reference/?ruby#get-list-tax-categories&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/pre&gt;&lt;/ol&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: payment global tax config&lt;/li&gt;&lt;/ul&gt;
     */
    updatePaymentConfigTax,
    /**
     * &lt;b&gt;[Not supported yet in AGS Shared Cloud]&lt;/b&gt;Query payment provider config.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: payment provider config list&lt;/li&gt;&lt;/ul&gt;
     */
    getPaymentConfigProvider,
    /**
     * &lt;b&gt;[Not supported yet in AGS Shared Cloud]&lt;/b&gt;Create payment provider config.&lt;br&gt;&lt;pre&gt;&lt;p&gt;&lt;strong&gt;Request Body Parameters:&lt;/strong&gt;&lt;/p&gt;&lt;pre&gt;&lt;table&gt;&lt;tr&gt;&lt;td&gt;Parameter&lt;/td&gt;&lt;td&gt;Type&lt;/td&gt;&lt;td&gt;Required&lt;/td&gt;&lt;td&gt;Description&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;namespace&lt;/td&gt;&lt;td&gt;String&lt;/td&gt;&lt;td&gt;Yes&lt;/td&gt;&lt;td&gt;namespace, * indicates all namespace&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;region&lt;/td&gt;&lt;td&gt;String&lt;/td&gt;&lt;td&gt;Yes&lt;/td&gt;&lt;td&gt;region, * indicates all regions&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;aggregate&lt;/td&gt;&lt;td&gt;String&lt;/td&gt;&lt;td&gt;No&lt;/td&gt;&lt;td&gt;aggregate payment provider, such as XSOLLA, ADYEN, STRIPE&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;specials&lt;/td&gt;&lt;td&gt;List&lt;/td&gt;&lt;td&gt;No&lt;/td&gt;&lt;td&gt;special payment provider, such as ALIPAY, WXPAY&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/pre&gt;payment provider applied has priority: &lt;ol&gt;&lt;li&gt;namespace and region match&lt;/li&gt;&lt;li&gt;namespace matches and region is *&lt;/li&gt;&lt;li&gt;region matches and namespace is *&lt;/li&gt;&lt;li&gt;namespace and region are *&lt;/li&gt;&lt;/ol&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: payment provider config&lt;/li&gt;&lt;/ul&gt;
     */
    createPaymentConfigProvider,
    /**
     * &lt;b&gt;[Not supported yet in AGS Shared Cloud]&lt;/b&gt;Get payment merchant config by id.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: payment merchant config info&lt;/li&gt;&lt;/ul&gt;
     */
    getPaymentConfigMerchant_ById,
    /**
     * &lt;b&gt;[Not supported yet in AGS Shared Cloud]&lt;/b&gt;Delete payment provider config.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: payment provider config&lt;/li&gt;&lt;/ul&gt;
     */
    deletePaymentConfigProvider_ById,
    /**
     * &lt;b&gt;[Not supported yet in AGS Shared Cloud]&lt;/b&gt;Update payment provider config.&lt;br&gt;&lt;pre&gt;&lt;p&gt;&lt;strong&gt;Request Body Parameters:&lt;/strong&gt;&lt;/p&gt;&lt;pre&gt;&lt;table&gt;&lt;tr&gt;&lt;td&gt;Parameter&lt;/td&gt;&lt;td&gt;Type&lt;/td&gt;&lt;td&gt;Required&lt;/td&gt;&lt;td&gt;Description&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;namespace&lt;/td&gt;&lt;td&gt;String&lt;/td&gt;&lt;td&gt;Yes&lt;/td&gt;&lt;td&gt;namespace, * indicates all namespace&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;region&lt;/td&gt;&lt;td&gt;String&lt;/td&gt;&lt;td&gt;Yes&lt;/td&gt;&lt;td&gt;region, * indicates all regions&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;aggregate&lt;/td&gt;&lt;td&gt;String&lt;/td&gt;&lt;td&gt;No&lt;/td&gt;&lt;td&gt;aggregate payment provider, such as XSOLLA, ADYEN, STRIPE&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;specials&lt;/td&gt;&lt;td&gt;List&lt;/td&gt;&lt;td&gt;No&lt;/td&gt;&lt;td&gt;special payment provider, such as ALIPAY, WXPAY&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/pre&gt;payment provider applied has priority: &lt;ol&gt;&lt;li&gt;namespace and region match&lt;/li&gt;&lt;li&gt;namespace matches and region is *&lt;/li&gt;&lt;li&gt;region matches and namespace is *&lt;/li&gt;&lt;li&gt;namespace and region are *&lt;/li&gt;&lt;/ol&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: payment provider config&lt;/li&gt;&lt;/ul&gt;
     */
    updatePaymentConfigProvider_ById,
    /**
     * &lt;b&gt;[Not supported yet in AGS Shared Cloud]&lt;/b&gt;Debug matched payment merchant config.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: payment merchant config info&lt;/li&gt;&lt;/ul&gt;
     */
    getPaymentConfigMerchantMatched,
    /**
     * &lt;b&gt;[Not supported yet in AGS Shared Cloud]&lt;/b&gt;Debug matched payment provider config.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: payment provider config&lt;/li&gt;&lt;/ul&gt;
     */
    getPaymentConfigProviderMatched,
    /**
     * &lt;b&gt;[Not supported yet in AGS Shared Cloud]&lt;/b&gt;Get special payment providers, such as ALIPAY, WXPAY.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: payment provider list&lt;/li&gt;&lt;/ul&gt;
     */
    getPaymentConfigProviderSpecial,
    /**
     * &lt;b&gt;[Not supported yet in AGS Shared Cloud]&lt;/b&gt;Get aggregate payment providers, such as XSOLLA, ADYEN.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: payment provider list&lt;/li&gt;&lt;/ul&gt;
     */
    getPaymentConfigProviderAggregate,
    /**
     * &lt;b&gt;[Not supported yet in AGS Shared Cloud]&lt;/b&gt;Update adyen config.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: updated payment merchant config&lt;/li&gt;&lt;/ul&gt;
     */
    updateAdyenconfigPayment_ById,
    /**
     * &lt;b&gt;[Not supported yet in AGS Shared Cloud]&lt;/b&gt;Update wxpay configuration.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: updated payment merchant config&lt;/li&gt;&lt;/ul&gt;
     */
    updateWxpayconfigPayment_ById,
    /**
     * &lt;b&gt;[Not supported yet in AGS Shared Cloud]&lt;/b&gt;Test adyen configuration. &lt;h4&gt;Check List:&lt;/h4&gt; &lt;ul&gt;&lt;li&gt;apiKey&lt;/li&gt;&lt;li&gt;merchantAccount&lt;/li&gt;&lt;/ul&gt;&lt;h4&gt;Non-check list:&lt;/h4&gt;&lt;ul&gt;&lt;li&gt;notificationHmacKey&lt;/li&gt;&lt;li&gt;notificationUsername&lt;/li&gt;&lt;li&gt;notificationPassword&lt;/li&gt;&lt;li&gt;liveEndpointUrlPrefix&lt;/li&gt;&lt;li&gt;allowedPaymentMethods&lt;/li&gt;&lt;li&gt;blockedPaymentMethods&lt;/li&gt;&lt;li&gt;settings&lt;/li&gt;&lt;/ul&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: test adyen config&lt;/li&gt;&lt;/ul&gt;
     */
    createPaymentConfigMerchantAdyenconfigTest,
    /**
     * &lt;b&gt;[Not supported yet in AGS Shared Cloud]&lt;/b&gt;Test WxPay configuration. Reference: &lt;a href=&#34;https://pay.weixin.qq.com/wiki/doc/api/native.php?chapter=9_1&#34;&gt;WxPay Document&lt;/a&gt;.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: test WxPay config&lt;/li&gt;&lt;/ul&gt;
     */
    createPaymentConfigMerchantWxpayconfigTest,
    /**
     * &lt;b&gt;[Not supported yet in AGS Shared Cloud]&lt;/b&gt;Update alipay configuration.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: updated payment merchant config&lt;/li&gt;&lt;/ul&gt;
     */
    updateAlipayconfigPayment_ById,
    /**
     * &lt;b&gt;[Not supported yet in AGS Shared Cloud]&lt;/b&gt;Update PayPal config.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: updated payment merchant config&lt;/li&gt;&lt;/ul&gt;
     */
    updatePaypalconfigPayment_ById,
    /**
     * &lt;b&gt;[Not supported yet in AGS Shared Cloud]&lt;/b&gt;Update stripe config.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: updated payment merchant config&lt;/li&gt;&lt;/ul&gt;
     */
    updateStripeconfigPayment_ById,
    /**
     * &lt;b&gt;[Not supported yet in AGS Shared Cloud]&lt;/b&gt;Update xsolla configuration. Reference: &lt;a href=&#34;https://developers.xsolla.com/?#simple-checkout&#34;&gt;Xsolla Document&lt;/a&gt;.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: updated payment merchant config&lt;/li&gt;&lt;/ul&gt;
     */
    updateXsollaconfigPayment_ById,
    /**
     * &lt;b&gt;[Not supported yet in AGS Shared Cloud]&lt;/b&gt;Test AliPay configuration.Reference: &lt;a href=&#34;https://docs.open.alipay.com/270/alipay.trade.page.pay&#34;&gt;Alipay Document&lt;/a&gt;.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: test result&lt;/li&gt;&lt;/ul&gt;
     */
    createPaymentConfigMerchantAlipayconfigTest,
    /**
     * &lt;b&gt;[Not supported yet in AGS Shared Cloud]&lt;/b&gt;Test PayPal configuration. &lt;h4&gt;Check List:&lt;/h4&gt; &lt;ul&gt;&lt;li&gt;clientID&lt;/li&gt;&lt;li&gt;clientSecret&lt;/li&gt;&lt;/ul&gt;&lt;h4&gt;Non-check list:&lt;/h4&gt;&lt;ul&gt;&lt;li&gt;webHookId&lt;/li&gt;&lt;/ul&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: test result&lt;/li&gt;&lt;/ul&gt;
     */
    createPaymentConfigMerchantPaypalconfigTest,
    /**
     * &lt;b&gt;[Not supported yet in AGS Shared Cloud]&lt;/b&gt;Test stripe configuration. &lt;h4&gt;Check List:&lt;/h4&gt; &lt;ul&gt;&lt;li&gt;secretKey&lt;/li&gt;&lt;li&gt;allowedPaymentMethodTypes&lt;/li&gt;&lt;/ul&gt;&lt;h4&gt;Non-check list:&lt;/h4&gt;&lt;ul&gt;&lt;li&gt;publishableKey&lt;/li&gt;&lt;li&gt;webhookSecret&lt;/li&gt;&lt;/ul&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: test adyen config&lt;/li&gt;&lt;/ul&gt;
     */
    createPaymentConfigMerchantStripeconfigTest,
    /**
     * &lt;b&gt;[Not supported yet in AGS Shared Cloud]&lt;/b&gt;Check xsolla configuration, Reference: &lt;a href=&#34;https://developers.xsolla.com/?#simple-checkout&#34;&gt;Xsolla Document&lt;/a&gt;.&lt;h4&gt;Check List:&lt;/h4&gt; &lt;ul&gt;&lt;li&gt;merchantId&lt;/li&gt;&lt;li&gt;projectId&lt;/li&gt;&lt;li&gt;apiKey&lt;/li&gt;&lt;/ul&gt;&lt;h4&gt;Non-check list:&lt;/h4&gt;&lt;ul&gt;&lt;li&gt;projectSecretKey&lt;/li&gt;&lt;/ul&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: test result&lt;/li&gt;&lt;/ul&gt;
     */
    createPaymentConfigMerchantXsollaconfigTest,
    /**
     * &lt;b&gt;[Not supported yet in AGS Shared Cloud]&lt;/b&gt;Update Neon Pay config.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: updated payment merchant config&lt;/li&gt;&lt;/ul&gt;
     */
    updateNeonpayconfigPayment_ById,
    /**
     * &lt;b&gt;[Not supported yet in AGS Shared Cloud]&lt;/b&gt;Check Neon Pay configuration, Reference: &lt;a href=&#34;https://docs.neonpay.com/docs/checkout&#34;&gt;Neon Pay Document&lt;/a&gt;.&lt;h4&gt;Check List:&lt;/h4&gt; &lt;ul&gt;&lt;li&gt;apiKey&lt;/li&gt;&lt;li&gt;webhookSecretKey&lt;/li&gt;&lt;/ul&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: test result&lt;/li&gt;&lt;/ul&gt;
     */
    createPaymentConfigMerchantNeonpayconfigTest,
    /**
     * &lt;b&gt;[Not supported yet in AGS Shared Cloud]&lt;/b&gt;Update checkout.com config.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: updated payment merchant config&lt;/li&gt;&lt;/ul&gt;
     */
    updateCheckoutconfigPayment_ById,
    /**
     * &lt;b&gt;[Not supported yet in AGS Shared Cloud]&lt;/b&gt;Update xsolla UI configuration.Reference: &lt;a href=&#34;https://developers.xsolla.com/api.html#ui-integrations&#34;&gt;Xsolla Document&lt;/a&gt;.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: updated payment merchant config&lt;/li&gt;&lt;/ul&gt;
     */
    updateXsollauiconfigPayment_ById,
    /**
     * &lt;b&gt;[Not supported yet in AGS Shared Cloud]&lt;/b&gt;Test checkout.com configuration. &lt;h4&gt;Check List:&lt;/h4&gt; &lt;ul&gt;&lt;li&gt;publicKey&lt;/li&gt;&lt;li&gt;secretKey&lt;/li&gt;&lt;/ul&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: test result&lt;/li&gt;&lt;/ul&gt;
     */
    createPaymentConfigMerchantCheckoutconfigTest,
    /**
     * &lt;b&gt;[Not supported yet in AGS Shared Cloud]&lt;/b&gt;Get payment domain whitelist config by namespace.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: payment domain whitelist config info&lt;/li&gt;&lt;/ul&gt;
     */
    getPaymentConfigDomains,
    /**
     * &lt;b&gt;[Not supported yet in AGS Shared Cloud]&lt;/b&gt;Update payment provider config by namespace.&lt;br&gt;&lt;pre&gt;&lt;p&gt;&lt;strong&gt;Request Body Parameters:&lt;/strong&gt;&lt;/p&gt;&lt;pre&gt;&lt;table&gt;&lt;tr&gt;&lt;td&gt;Parameter&lt;/td&gt;&lt;td&gt;Type&lt;/td&gt;&lt;td&gt;Required&lt;/td&gt;&lt;td&gt;Description&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;domains&lt;/td&gt;&lt;td&gt;String&lt;/td&gt;&lt;td&gt;Yes&lt;/td&gt;&lt;td&gt;list of domains to whitelist for the return URL.&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/pre&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Validation&lt;/i&gt;: the domain should include the protocol (http/https), but the whitelist check will only compare the host part (www.example.com)&lt;/li&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: payment domain whitelist config&lt;/li&gt;&lt;/ul&gt;
     */
    updatePaymentConfigDomain,
    /**
     * &lt;b&gt;[Not supported yet in AGS Shared Cloud]&lt;/b&gt;Test adyen configuration in payment merchant config. Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: test adyen config&lt;/li&gt;&lt;/ul&gt;
     */
    getAdyenconfigTestPayment_ById,
    /**
     * &lt;b&gt;[Not supported yet in AGS Shared Cloud]&lt;/b&gt;Upload wxpay cert file.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: updated payment merchant config&lt;/li&gt;&lt;/ul&gt;
     */
    updateWxpayconfigCertPayment_ById,
    /**
     * &lt;b&gt;[Not supported yet in AGS Shared Cloud]&lt;/b&gt;Test WxPay configuration in payment merchant config. Reference: &lt;a href=&#34;https://pay.weixin.qq.com/wiki/doc/api/native.php?chapter=9_1&#34;&gt;WxPay Document&lt;/a&gt;.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: test WxPay config&lt;/li&gt;&lt;/ul&gt;
     */
    getWxpayconfigTestPayment_ById,
    /**
     * &lt;b&gt;[Not supported yet in AGS Shared Cloud]&lt;/b&gt;Test AliPay configuration in payment merchant config. Reference: &lt;a href=&#34;https://docs.open.alipay.com/270/alipay.trade.page.pay&#34;&gt;Alipay Document&lt;/a&gt;.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: test alipay config&lt;/li&gt;&lt;/ul&gt;
     */
    getAlipayconfigTestPayment_ById,
    /**
     * &lt;b&gt;[Not supported yet in AGS Shared Cloud]&lt;/b&gt;Test PayPal configuration in payment merchant config. Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: test result&lt;/li&gt;&lt;/ul&gt;
     */
    getPaypalconfigTestPayment_ById,
    /**
     * &lt;b&gt;[Not supported yet in AGS Shared Cloud]&lt;/b&gt;Test stripe configuration in payment merchant config. Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: test adyen config&lt;/li&gt;&lt;/ul&gt;
     */
    getStripeconfigTestPayment_ById,
    /**
     * &lt;b&gt;[Not supported yet in AGS Shared Cloud]&lt;/b&gt;Test xsolla configuration in payment merchant config. Reference: &lt;a href=&#34;https://developers.xsolla.com/?#simple-checkout&#34;&gt;Xsolla Document&lt;/a&gt;.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: test xsolla config&lt;/li&gt;&lt;/ul&gt;
     */
    getXsollaconfigTestPayment_ById,
    /**
     * &lt;b&gt;[Not supported yet in AGS Shared Cloud]&lt;/b&gt;Test Neon Pay configuration in payment merchant config. Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: test result&lt;/li&gt;&lt;/ul&gt;
     */
    getNeonpayconfigTestPayment_ById,
    /**
     * &lt;b&gt;[Not supported yet in AGS Shared Cloud]&lt;/b&gt;Test checkout.com configuration in payment merchant config. Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: test result&lt;/li&gt;&lt;/ul&gt;
     */
    getCheckoutconfigTestPayment_ById
  };
}

// src/generated-admin/PaymentDedicatedAdminApi.ts
import { ApiUtils as ApiUtils23, Network as Network23 } from "@accelbyte/sdk";
function PaymentDedicatedAdminApi(sdk, args) {
  const sdkAssembly = sdk.assembly();
  const namespace = args?.coreConfig?.namespace ?? sdkAssembly.coreConfig.namespace;
  const useSchemaValidation = args?.coreConfig?.useSchemaValidation ?? sdkAssembly.coreConfig.useSchemaValidation;
  let axiosInstance = sdkAssembly.axiosInstance;
  const requestConfigOverrides = args?.axiosConfig?.request;
  const baseURLOverride = args?.coreConfig?.baseURL;
  const interceptorsOverride = args?.axiosConfig?.interceptors ?? [];
  if (requestConfigOverrides || baseURLOverride || interceptorsOverride.length > 0) {
    const requestConfig = ApiUtils23.mergeAxiosConfigs(sdkAssembly.axiosInstance.defaults, {
      ...baseURLOverride ? { baseURL: baseURLOverride } : {},
      ...requestConfigOverrides
    });
    axiosInstance = Network23.create(requestConfig);
    for (const interceptor of interceptorsOverride) {
      if (interceptor.type === "request") {
        axiosInstance.interceptors.request.use(interceptor.onRequest, interceptor.onError);
      }
      if (interceptor.type === "response") {
        axiosInstance.interceptors.response.use(interceptor.onSuccess, interceptor.onError);
      }
    }
  }
  async function getPaymentOrders(queryParams) {
    const $ = new PaymentDedicatedAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getPaymentOrders(queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function createPaymentOrder(data) {
    const $ = new PaymentDedicatedAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.createPaymentOrder(data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function updateRefundPayment_ByPaymentOrderNo(paymentOrderNo, data) {
    const $ = new PaymentDedicatedAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.updateRefundPayment_ByPaymentOrderNo(paymentOrderNo, data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  return {
    /**
     * &lt;b&gt;[Not supported yet in AGS Shared Cloud]&lt;/b&gt;Sync payment orders. If response contains nextEvaluatedKey, please use it as query param in the next call to fetch the next batch, a batch has 1000 elements or less.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: sync payment orders&lt;/li&gt;&lt;/ul&gt;
     */
    getPaymentOrders,
    /**
     * &lt;b&gt;[Not supported yet in AGS Shared Cloud]&lt;/b&gt;&lt;p&gt;This API is used to create payment order from non justice service. e.g. from dedicated server, the result contains the payment station url.&lt;/p&gt;&lt;p&gt;&lt;strong&gt;Path Parameter:&lt;/strong&gt;&lt;/p&gt;&lt;pre&gt;&lt;table&gt;&lt;tr&gt;&lt;td&gt;Parameter&lt;/td&gt;&lt;td&gt;Type&lt;/td&gt;&lt;td&gt;Required&lt;/td&gt;&lt;td&gt;Description&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;namespace&lt;/td&gt;&lt;td&gt;String&lt;/td&gt;&lt;td&gt;Yes&lt;/td&gt;&lt;td&gt;Namespace that payment order resides in, should be publisher namespace if it&#39;s a Steam like platform that share &lt;br&gt;payment config cross namespaces, otherwise it&#39;s the game namespace&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;p&gt;&lt;strong&gt;Request Body Parameters:&lt;/strong&gt;&lt;/p&gt;&lt;pre&gt;&lt;table&gt;&lt;tr&gt;&lt;td&gt;Parameter&lt;/td&gt;&lt;td&gt;Type&lt;/td&gt;&lt;td&gt;Required&lt;/td&gt;&lt;td&gt;Description&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;extOrderNo&lt;/td&gt;&lt;td&gt;String&lt;/td&gt;&lt;td&gt;Yes&lt;/td&gt;&lt;td&gt;External order number, it should be unique in invoker order system&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;sku&lt;/td&gt;&lt;td&gt;String&lt;/td&gt;&lt;td&gt;No&lt;/td&gt;&lt;td&gt;Item identity&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;targetNamespace&lt;/td&gt;&lt;td&gt;String&lt;/td&gt;&lt;td&gt;Yes&lt;/td&gt;&lt;td&gt;The game namespace&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;targetUserId&lt;/td&gt;&lt;td&gt;String&lt;/td&gt;&lt;td&gt;Yes&lt;/td&gt;&lt;td&gt;User id for the order owner in game namespace&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;extUserId&lt;/td&gt;&lt;td&gt;String&lt;/td&gt;&lt;td&gt;No&lt;/td&gt;&lt;td&gt;External user id, can be user character id &lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;price&lt;/td&gt;&lt;td&gt;int&lt;/td&gt;&lt;td&gt;Yes&lt;/td&gt;&lt;td&gt;price which should be greater than 0&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;title&lt;/td&gt;&lt;td&gt;String&lt;/td&gt;&lt;td&gt;Yes&lt;/td&gt;&lt;td&gt;Item title&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;description&lt;/td&gt;&lt;td&gt;String&lt;/td&gt;&lt;td&gt;Yes&lt;/td&gt;&lt;td&gt;Item description&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;currencyCode&lt;/td&gt;&lt;td&gt;String&lt;/td&gt;&lt;td&gt;No&lt;/td&gt;&lt;td&gt;Currency code, default is USD&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;currencyNamespace&lt;/td&gt;&lt;td&gt;String&lt;/td&gt;&lt;td&gt;No&lt;/td&gt;&lt;td&gt;Currency namespace, default is publisher namespace&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;region&lt;/td&gt;&lt;td&gt;String&lt;/td&gt;&lt;td&gt;No&lt;/td&gt;&lt;td&gt;Country of the user, will get from user info if not present&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;language&lt;/td&gt;&lt;td&gt;String&lt;/td&gt;&lt;td&gt;No&lt;/td&gt;&lt;td&gt;Language of the user&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;sandbox&lt;/td&gt;&lt;td&gt;Boolean&lt;/td&gt;&lt;td&gt;No&lt;/td&gt;&lt;td&gt;set to true will create sandbox order that not real paid for xsolla/alipay and will not validate &lt;br&gt;price for wxpay.&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;returnUrl&lt;/td&gt;&lt;td&gt;String&lt;/td&gt;&lt;td&gt;No&lt;/td&gt;&lt;td&gt;customized return url for redirect once payment finished, leave unset to use configuration in &lt;br&gt;namespace&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;notifyUrl&lt;/td&gt;&lt;td&gt;String&lt;/td&gt;&lt;td&gt;No&lt;/td&gt;&lt;td&gt;customized notify url for payment web hook, leave unset to use configuration in namespace&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;customParameters&lt;/td&gt;&lt;td&gt;String&lt;/td&gt;&lt;td&gt;No&lt;/td&gt;&lt;td&gt;Custom parameters&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;Request Body Example:&lt;/strong&gt;&lt;/p&gt;&lt;pre&gt;&lt;code style=&#39;overflow: auto&#39;&gt;{ &#34;extOrderNo&#34;: &#34;123456789&#34;, &#34;sku&#34;: &#34;sku&#34;, &#34;targetNamespace&#34;: &#34;game1&#34;, &#34;targetUserId&#34;: &#34;94451623768940d58416ca33ca767ec3&#34;, &#34;extUserId&#34;: &#34;678&#34;, &#34;title&#34;: &#34;Frostmourne&#34;, &#34;description\&#34;: &#34;Here was power. Here was despair&#34;, &#34;price&#34;: 100, &#34;region&#34;: &#34;CN&#34;, &#34;language&#34;: &#34;zh-CN&#34;, &#34;currencyCode&#34;: &#34;USD&#34;, &#34;currencyNamespace&#34;: &#34;accelbyte&#34; }&lt;/pre&gt;&lt;/code&gt;&lt;h4&gt;Payment Notification:&lt;/h4&gt;&lt;p&gt;After user complete the payment, it will send notification to configured web hook, http status code should return 200 or 204 once you resolve notification successfully, otherwise payment system will retry notification in interval&lt;/p&gt;&lt;p&gt;&lt;strong&gt;Payment notification parameter:&lt;/strong&gt;&lt;/p&gt;&lt;pre&gt;&lt;table&gt;&lt;tr&gt;&lt;td&gt;Parameter&lt;/td&gt;&lt;td&gt;Type&lt;/td&gt;&lt;td&gt;Required&lt;/td&gt;&lt;td&gt;Description&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;payload&lt;/td&gt;&lt;td&gt;String&lt;/td&gt;&lt;td&gt;Yes&lt;/td&gt;&lt;td&gt;Payment notification payload in json string &lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;sign&lt;/td&gt;&lt;td&gt;String&lt;/td&gt;&lt;td&gt;Yes&lt;/td&gt;&lt;td&gt;sha1 hex signature for payload and private key&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;Payment notification parameter Example:&lt;/strong&gt;&lt;/p&gt;&lt;pre&gt;&lt;code style=&#39;overflow: auto&#39;&gt;{ &#34;payload&#34;: &#34;{ \&#34;type\&#34;: \&#34;payment\&#34;, \&#34;nonceStr\&#34;: \&#34;34c1dcf3eb58455eb161465bbfc0b590\&#34;, \&#34;paymentOrderNo\&#34;: \&#34;18081239088\&#34;, \&#34;namespace\&#34;: \&#34;accelbyte\&#34;, \&#34;targetNamespace\&#34;: \&#34;game1\&#34;, \&#34;targetUserId\&#34;: \&#34;94451623768940d58416ca33ca767ec3\&#34;, \&#34;extOrderNo\&#34;: \&#34;123456789\&#34;, \&#34;sku\&#34;: \&#34;sku\&#34;, \&#34;extUserId\&#34;: \&#34;678\&#34;, \&#34;price\&#34;: 100, \&#34;paymentProvider\&#34;: \&#34;XSOLLA\&#34;, \&#34;vat\&#34;: 0, \&#34;salesTax\&#34;: 0, \&#34;paymentProviderFee\&#34;: 0, \&#34;paymentMethodFee\&#34;: 0, \&#34;currency\&#34;: { \&#34;currencyCode\&#34;: \&#34;USD\&#34;, \&#34;currencySymbol\&#34;: \&#34;$\&#34;, \&#34;currencyType\&#34;: \&#34;REAL\&#34;, \&#34;namespace\&#34;: \&#34;accelbyte\&#34;, \&#34;decimals\&#34;: 2 }, \&#34;status\&#34;: \&#34;CHARGED\&#34;, \&#34;createdTime\&#34;: \&#34;2018-07-28T00:39:16.274Z\&#34;, \&#34;chargedTime\&#34;: \&#34;2018-07-28T00:39:16.274Z\&#34; }&#34;, &#34;sign&#34;:&#34;e31fb92516cc9faaf50ad70343e1293acec6f3d5&#34; }&lt;/pre&gt;&lt;/code&gt;&lt;p&gt;&lt;strong&gt;Payment notification payload parameter list:&lt;/strong&gt;&lt;/p&gt;&lt;pre&gt;&lt;table&gt;&lt;tr&gt;&lt;td&gt;Parameter&lt;/td&gt;&lt;td&gt;Type&lt;/td&gt;&lt;td&gt;Required&lt;/td&gt;&lt;td&gt;Description&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;type&lt;/td&gt;&lt;td&gt;String&lt;/td&gt;&lt;td&gt;Yes&lt;/td&gt;&lt;td&gt;Notification type: &#39;payment&#39;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;paymentOrderNo&lt;/td&gt;&lt;td&gt;String&lt;/td&gt;&lt;td&gt;Yes&lt;/td&gt;&lt;td&gt;Payment system generated order number&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;extOrderNo&lt;/td&gt;&lt;td&gt;String&lt;/td&gt;&lt;td&gt;No&lt;/td&gt;&lt;td&gt;External order number that passed by invoker&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;namespace&lt;/td&gt;&lt;td&gt;String&lt;/td&gt;&lt;td&gt;Yes&lt;/td&gt;&lt;td&gt;Namespace that related payment order resides in&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;targetNamespace&lt;/td&gt;&lt;td&gt;String&lt;/td&gt;&lt;td&gt;Yes&lt;/td&gt;&lt;td&gt;The game namespace&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;targetUserId&lt;/td&gt;&lt;td&gt;String&lt;/td&gt;&lt;td&gt;Yes&lt;/td&gt;&lt;td&gt;The user id in game namespace&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;sku&lt;/td&gt;&lt;td&gt;String&lt;/td&gt;&lt;td&gt;No&lt;/td&gt;&lt;td&gt;Item identify, it will return if pass it when create payment&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;extUserId&lt;/td&gt;&lt;td&gt;String&lt;/td&gt;&lt;td&gt;No&lt;/td&gt;&lt;td&gt;External user id, can be character id, it will return if pass it when create payment&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;price&lt;/td&gt;&lt;td&gt;int&lt;/td&gt;&lt;td&gt;Yes&lt;/td&gt;&lt;td&gt;Price of item&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;paymentProvider&lt;/td&gt;&lt;td&gt;String&lt;/td&gt;&lt;td&gt;Yes&lt;/td&gt;&lt;td&gt;Payment provider, allowed values: xsolla/alipay/wxpay/wallet&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;vat&lt;/td&gt;&lt;td&gt;int&lt;/td&gt;&lt;td&gt;Yes&lt;/td&gt;&lt;td&gt;Payment order VAT&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;salesTax&lt;/td&gt;&lt;td&gt;int&lt;/td&gt;&lt;td&gt;Yes&lt;/td&gt;&lt;td&gt;Payment order sales tax&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;paymentProviderFee&lt;/td&gt;&lt;td&gt;int&lt;/td&gt;&lt;td&gt;Yes&lt;/td&gt;&lt;td&gt;Payment provider fee&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;paymentMethodFee&lt;/td&gt;&lt;td&gt;int&lt;/td&gt;&lt;td&gt;Yes&lt;/td&gt;&lt;td&gt;Payment method fee&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;currency&lt;/td&gt;&lt;td&gt;Map&lt;/td&gt;&lt;td&gt;Yes&lt;/td&gt;&lt;td&gt;Payment order currency info&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;status&lt;/td&gt;&lt;td&gt;String&lt;/td&gt;&lt;td&gt;Yes&lt;/td&gt;&lt;td&gt;Payment order status&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;statusReason&lt;/td&gt;&lt;td&gt;String&lt;/td&gt;&lt;td&gt;No&lt;/td&gt;&lt;td&gt;Payment order status reason&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;createdTime&lt;/td&gt;&lt;td&gt;Datetime&lt;/td&gt;&lt;td&gt;No&lt;/td&gt;&lt;td&gt;The time of the order created&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;chargedTime&lt;/td&gt;&lt;td&gt;Datetime&lt;/td&gt;&lt;td&gt;No&lt;/td&gt;&lt;td&gt;The time of the order charged&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;customParameters&lt;/td&gt;&lt;td&gt;Map&lt;/td&gt;&lt;td&gt;No&lt;/td&gt;&lt;td&gt;custom parameters, will return if pass it when create payment&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;nonceStr&lt;/td&gt;&lt;td&gt;String&lt;/td&gt;&lt;td&gt;Yes&lt;/td&gt;&lt;td&gt;Random string, max length is 32, can be timestamp or uuid&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;Currency info parameter list:&lt;/strong&gt;&lt;/p&gt;&lt;pre&gt;&lt;table&gt;&lt;tr&gt;&lt;td&gt;Parameter&lt;/td&gt;&lt;td&gt;Type&lt;/td&gt;&lt;td&gt;Required&lt;/td&gt;&lt;td&gt;Description&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;currencyCode&lt;/td&gt;&lt;td&gt;String&lt;/td&gt;&lt;td&gt;Yes&lt;/td&gt;&lt;td&gt;Currency Code&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;currencySymbol&lt;/td&gt;&lt;td&gt;String&lt;/td&gt;&lt;td&gt;Yes&lt;/td&gt;&lt;td&gt;Currency Symbol&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;currencyType&lt;/td&gt;&lt;td&gt;String&lt;/td&gt;&lt;td&gt;Yes&lt;/td&gt;&lt;td&gt;Currency type(REAL/VIRTUAL)&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;namespace&lt;/td&gt;&lt;td&gt;String&lt;/td&gt;&lt;td&gt;Yes&lt;/td&gt;&lt;td&gt;Currency namespace&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;decimals&lt;/td&gt;&lt;td&gt;int&lt;/td&gt;&lt;td&gt;Yes&lt;/td&gt;&lt;td&gt;Currency decimals&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/pre&gt;&lt;h4&gt;Encryption Rule:&lt;/h4&gt;&lt;p&gt;Concat payload json string and private key and then do sha1Hex.&lt;/p&gt;&lt;h4&gt;Other detail info:&lt;/h4&gt; &lt;ul&gt;&lt;li&gt;&lt;i&gt;Token type&lt;/i&gt;: client token&lt;/li&gt;&lt;li&gt;&lt;i&gt;Optional permission(user with this permission will create sandbox order)&lt;/i&gt;: resource=&#34;SANDBOX&#34;, action=1 (CREATE)&lt;/li&gt;&lt;li&gt;It will be forbidden while the target user is banned: PAYMENT_INITIATE or ORDER_AND_PAYMENT&lt;/li&gt;&lt;li&gt;&lt;b&gt;cross namespace allowed&lt;/b&gt;&lt;/li&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: created payment order info&lt;/li&gt;&lt;/ul&gt;
     */
    createPaymentOrder,
    /**
     * &lt;b&gt;[Not supported yet in AGS Shared Cloud]&lt;/b&gt;&lt;p&gt;This API is used to refund payment order by paymentOrderNo from non justice service. e.g. dedicated server. &lt;ul&gt;&lt;li&gt;if the status field of response json is &#34;REFUNDED&#34;, usually wallet paid, it indicates payment order already refunded&lt;/li&gt;&lt;li&gt;if the status field of response json is &#34;REFUNDING&#34;, usually real money paid, platform will send notification to registered notify url once refund successfully&lt;/li&gt; &lt;/ul&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;Path Parameter:&lt;/strong&gt;&lt;/p&gt;&lt;pre&gt;&lt;table&gt;&lt;tr&gt;&lt;td&gt;Parameter&lt;/td&gt;&lt;td&gt;Type&lt;/td&gt;&lt;td&gt;Required&lt;/td&gt;&lt;td&gt;Description&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;namespace&lt;/td&gt;&lt;td&gt;String&lt;/td&gt;&lt;td&gt;Yes&lt;/td&gt;&lt;td&gt;Namespace that payment order resides in&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;paymentOrderNo&lt;/td&gt;&lt;td&gt;String&lt;/td&gt;&lt;td&gt;Yes&lt;/td&gt;&lt;td&gt;Payment order number&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;Request Body Parameters:&lt;/strong&gt;&lt;/p&gt;&lt;pre&gt;&lt;table&gt;&lt;tr&gt;&lt;td&gt;Parameter&lt;/td&gt;&lt;td&gt;Type&lt;/td&gt;&lt;td&gt;Required&lt;/td&gt;&lt;td&gt;Description&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;description&lt;/td&gt;&lt;td&gt;String&lt;/td&gt;&lt;td&gt;Yes&lt;/td&gt;&lt;td&gt;Refund description&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;Request Body Example:&lt;/strong&gt;&lt;/p&gt;&lt;pre&gt;&lt;code style=&#39;overflow: auto&#39;&gt;{ &#34;description&#34;: &#34;Repeated item.&#34; }&lt;/pre&gt;&lt;/code&gt;&lt;h4&gt;Refund Notification:&lt;/h4&gt;&lt;p&gt;It will send notification to configured web hook after refund successfully, http status code should return 200 or 204 once you resolve notification successfully, otherwise payment system will retry notification in interval&lt;/p&gt;&lt;p&gt;&lt;strong&gt;Refund notification parameter:&lt;/strong&gt;&lt;/p&gt;&lt;pre&gt;&lt;table&gt;&lt;tr&gt;&lt;td&gt;Parameter&lt;/td&gt;&lt;td&gt;Type&lt;/td&gt;&lt;td&gt;Required&lt;/td&gt;&lt;td&gt;Description&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;payload&lt;/td&gt;&lt;td&gt;String&lt;/td&gt;&lt;td&gt;Yes&lt;/td&gt;&lt;td&gt;Refund notification payload in json string &lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;sign&lt;/td&gt;&lt;td&gt;String&lt;/td&gt;&lt;td&gt;Yes&lt;/td&gt;&lt;td&gt;sha1 hex signature for payload and private key&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;Refund notification Example:&lt;/strong&gt;&lt;/p&gt;&lt;pre&gt;&lt;code style=&#39;overflow: auto&#39;&gt;{ &#34;payload&#34;: &#34;{ \&#34;type\&#34;: \&#34;payment\&#34;, \&#34;nonceStr\&#34;: \&#34;34c1dcf3eb58455eb161465bbfc0b590\&#34;, \&#34;paymentOrderNo\&#34;: \&#34;18081239088\&#34;, \&#34;namespace\&#34;: \&#34;accelbyte\&#34;, \&#34;targetNamespace\&#34;: \&#34;game1\&#34;, \&#34;targetUserId\&#34;: \&#34;94451623768940d58416ca33ca767ec3\&#34;, \&#34;extOrderNo\&#34;: \&#34;123456789\&#34;, \&#34;sku\&#34;: \&#34;sku\&#34;, \&#34;extUserId\&#34;: \&#34;678\&#34;, \&#34;price\&#34;: 100, \&#34;paymentProvider\&#34;: \&#34;XSOLLA\&#34;, \&#34;vat\&#34;: 0, \&#34;salesTax\&#34;: 0, \&#34;paymentProviderFee\&#34;: 0, \&#34;paymentMethodFee\&#34;: 0, \&#34;currency\&#34;: { \&#34;currencyCode\&#34;: \&#34;USD\&#34;, \&#34;currencySymbol\&#34;: \&#34;$\&#34;, \&#34;currencyType\&#34;: \&#34;REAL\&#34;, \&#34;namespace\&#34;: \&#34;accelbyte\&#34;, \&#34;decimals\&#34;: 2 }, \&#34;status\&#34;: \&#34;REFUNDED\&#34;, \&#34;createdTime\&#34;: \&#34;2018-07-28T00:39:16.274Z\&#34;, \&#34;chargedTime\&#34;: \&#34;2018-07-28T00:39:16.274Z\&#34;, \&#34;refundedTime\&#34;: \&#34;2018-07-28T00:39:16.274Z\&#34; }&#34;, &#34;sign&#34;:&#34;e31fb92516cc9faaf50ad70343e1293acec6f3d5&#34; }&lt;/pre&gt;&lt;/code&gt;&lt;p&gt;&lt;strong&gt;Refund notification payload parameter list:&lt;/strong&gt;&lt;/p&gt;&lt;pre&gt;&lt;table&gt;&lt;tr&gt;&lt;td&gt;Parameter&lt;/td&gt;&lt;td&gt;Type&lt;/td&gt;&lt;td&gt;Required&lt;/td&gt;&lt;td&gt;Description&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;type&lt;/td&gt;&lt;td&gt;String&lt;/td&gt;&lt;td&gt;Yes&lt;/td&gt;&lt;td&gt;Notification type: &#39;payment&#39;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;paymentOrderNo&lt;/td&gt;&lt;td&gt;String&lt;/td&gt;&lt;td&gt;Yes&lt;/td&gt;&lt;td&gt;Payment system generated order number&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;extOrderNo&lt;/td&gt;&lt;td&gt;String&lt;/td&gt;&lt;td&gt;No&lt;/td&gt;&lt;td&gt;External order number that passed by invoker&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;namespace&lt;/td&gt;&lt;td&gt;String&lt;/td&gt;&lt;td&gt;Yes&lt;/td&gt;&lt;td&gt;Namespace that related payment order resides in&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;targetNamespace&lt;/td&gt;&lt;td&gt;String&lt;/td&gt;&lt;td&gt;Yes&lt;/td&gt;&lt;td&gt;The game namespace&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;targetUserId&lt;/td&gt;&lt;td&gt;String&lt;/td&gt;&lt;td&gt;Yes&lt;/td&gt;&lt;td&gt;The user id in game namespace&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;sku&lt;/td&gt;&lt;td&gt;String&lt;/td&gt;&lt;td&gt;No&lt;/td&gt;&lt;td&gt;Item identify, it will return if pass it when create payment&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;extUserId&lt;/td&gt;&lt;td&gt;String&lt;/td&gt;&lt;td&gt;No&lt;/td&gt;&lt;td&gt;External user id, can be character id, it will return if pass it when create payment&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;price&lt;/td&gt;&lt;td&gt;int&lt;/td&gt;&lt;td&gt;Yes&lt;/td&gt;&lt;td&gt;Price of item&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;paymentProvider&lt;/td&gt;&lt;td&gt;String&lt;/td&gt;&lt;td&gt;Yes&lt;/td&gt;&lt;td&gt;Payment provider: xsolla/alipay/wxpay/wallet&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;vat&lt;/td&gt;&lt;td&gt;int&lt;/td&gt;&lt;td&gt;Yes&lt;/td&gt;&lt;td&gt;Payment order VAT&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;salesTax&lt;/td&gt;&lt;td&gt;int&lt;/td&gt;&lt;td&gt;Yes&lt;/td&gt;&lt;td&gt;Payment order sales tax&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;paymentProviderFee&lt;/td&gt;&lt;td&gt;int&lt;/td&gt;&lt;td&gt;Yes&lt;/td&gt;&lt;td&gt;Payment provider fee&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;paymentMethodFee&lt;/td&gt;&lt;td&gt;int&lt;/td&gt;&lt;td&gt;Yes&lt;/td&gt;&lt;td&gt;Payment method fee&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;currency&lt;/td&gt;&lt;td&gt;Map&lt;/td&gt;&lt;td&gt;Yes&lt;/td&gt;&lt;td&gt;Payment order currency info&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;status&lt;/td&gt;&lt;td&gt;String&lt;/td&gt;&lt;td&gt;Yes&lt;/td&gt;&lt;td&gt;Payment order status&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;statusReason&lt;/td&gt;&lt;td&gt;String&lt;/td&gt;&lt;td&gt;No&lt;/td&gt;&lt;td&gt;Payment order refund status reason&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;createdTime&lt;/td&gt;&lt;td&gt;Datetime&lt;/td&gt;&lt;td&gt;No&lt;/td&gt;&lt;td&gt;The time of the order created&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;chargedTime&lt;/td&gt;&lt;td&gt;Datetime&lt;/td&gt;&lt;td&gt;No&lt;/td&gt;&lt;td&gt;The time of the order charged&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;refundedTime&lt;/td&gt;&lt;td&gt;Datetime&lt;/td&gt;&lt;td&gt;No&lt;/td&gt;&lt;td&gt;The time of the order refunded&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;customParameters&lt;/td&gt;&lt;td&gt;Map&lt;/td&gt;&lt;td&gt;No&lt;/td&gt;&lt;td&gt;custom parameters, will return if pass it when create payment&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;nonceStr&lt;/td&gt;&lt;td&gt;String&lt;/td&gt;&lt;td&gt;Yes&lt;/td&gt;&lt;td&gt;Random string, max length is 32, &lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;Currency info parameter list:&lt;/strong&gt;&lt;/p&gt;&lt;pre&gt;&lt;table&gt;&lt;tr&gt;&lt;td&gt;Parameter&lt;/td&gt;&lt;td&gt;Type&lt;/td&gt;&lt;td&gt;Required&lt;/td&gt;&lt;td&gt;Description&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;currencyCode&lt;/td&gt;&lt;td&gt;String&lt;/td&gt;&lt;td&gt;Yes&lt;/td&gt;&lt;td&gt;Currency Code&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;currencySymbol&lt;/td&gt;&lt;td&gt;String&lt;/td&gt;&lt;td&gt;Yes&lt;/td&gt;&lt;td&gt;Currency Symbol&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;currencyType&lt;/td&gt;&lt;td&gt;String&lt;/td&gt;&lt;td&gt;Yes&lt;/td&gt;&lt;td&gt;Currency type(REAL/VIRTUAL)&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;namespace&lt;/td&gt;&lt;td&gt;String&lt;/td&gt;&lt;td&gt;Yes&lt;/td&gt;&lt;td&gt;Currency namespace&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;decimals&lt;/td&gt;&lt;td&gt;int&lt;/td&gt;&lt;td&gt;Yes&lt;/td&gt;&lt;td&gt;Currency decimals&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/pre&gt;&lt;h4&gt;Encryption Rule:&lt;/h4&gt;&lt;p&gt;Concat payload json string and private key and then do sha1Hex.&lt;/p&gt;&lt;h4&gt;Other detail info:&lt;/h4&gt; &lt;ul&gt;&lt;li&gt;&lt;i&gt;Token type&lt;/i&gt;: client token&lt;/li&gt;&lt;li&gt;&lt;b&gt;cross namespace allowed&lt;/b&gt;&lt;/li&gt;&lt;/ul&gt;
     */
    updateRefundPayment_ByPaymentOrderNo
  };
}

// src/generated-admin/PlatformAccountClosureAdminApi.ts
import { ApiUtils as ApiUtils24, Network as Network24 } from "@accelbyte/sdk";
function PlatformAccountClosureAdminApi(sdk, args) {
  const sdkAssembly = sdk.assembly();
  const namespace = args?.coreConfig?.namespace ?? sdkAssembly.coreConfig.namespace;
  const useSchemaValidation = args?.coreConfig?.useSchemaValidation ?? sdkAssembly.coreConfig.useSchemaValidation;
  let axiosInstance = sdkAssembly.axiosInstance;
  const requestConfigOverrides = args?.axiosConfig?.request;
  const baseURLOverride = args?.coreConfig?.baseURL;
  const interceptorsOverride = args?.axiosConfig?.interceptors ?? [];
  if (requestConfigOverrides || baseURLOverride || interceptorsOverride.length > 0) {
    const requestConfig = ApiUtils24.mergeAxiosConfigs(sdkAssembly.axiosInstance.defaults, {
      ...baseURLOverride ? { baseURL: baseURLOverride } : {},
      ...requestConfigOverrides
    });
    axiosInstance = Network24.create(requestConfig);
    for (const interceptor of interceptorsOverride) {
      if (interceptor.type === "request") {
        axiosInstance.interceptors.request.use(interceptor.onRequest, interceptor.onError);
      }
      if (interceptor.type === "response") {
        axiosInstance.interceptors.response.use(interceptor.onSuccess, interceptor.onError);
      }
    }
  }
  async function getPlatformClosureHistory_ByUserId(userId) {
    const $ = new PlatformAccountClosureAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getPlatformClosureHistory_ByUserId(userId);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  return {
    /**
     * Get user platform account closure history.&lt;br&gt;
     */
    getPlatformClosureHistory_ByUserId
  };
}

// src/generated-admin/PlatformAdminApi.ts
import { ApiUtils as ApiUtils25, Network as Network25 } from "@accelbyte/sdk";
function PlatformAdminApi(sdk, args) {
  const sdkAssembly = sdk.assembly();
  const namespace = args?.coreConfig?.namespace ?? sdkAssembly.coreConfig.namespace;
  const useSchemaValidation = args?.coreConfig?.useSchemaValidation ?? sdkAssembly.coreConfig.useSchemaValidation;
  let axiosInstance = sdkAssembly.axiosInstance;
  const requestConfigOverrides = args?.axiosConfig?.request;
  const baseURLOverride = args?.coreConfig?.baseURL;
  const interceptorsOverride = args?.axiosConfig?.interceptors ?? [];
  if (requestConfigOverrides || baseURLOverride || interceptorsOverride.length > 0) {
    const requestConfig = ApiUtils25.mergeAxiosConfigs(sdkAssembly.axiosInstance.defaults, {
      ...baseURLOverride ? { baseURL: baseURLOverride } : {},
      ...requestConfigOverrides
    });
    axiosInstance = Network25.create(requestConfig);
    for (const interceptor of interceptorsOverride) {
      if (interceptor.type === "request") {
        axiosInstance.interceptors.request.use(interceptor.onRequest, interceptor.onError);
      }
      if (interceptor.type === "response") {
        axiosInstance.interceptors.response.use(interceptor.onSuccess, interceptor.onError);
      }
    }
  }
  async function createOwnershipXblPlatform_ByProductSku(productSku, data) {
    const $ = new PlatformAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.createOwnershipXblPlatform_ByProductSku(productSku, data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function createOwnershipPsnPlatform_ByEntitlementLabel(entitlementLabel, data) {
    const $ = new PlatformAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.createOwnershipPsnPlatform_ByEntitlementLabel(entitlementLabel, data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  return {
    /**
     * Get Xbox entitlement ownership by product sku.
     */
    createOwnershipXblPlatform_ByProductSku,
    /**
     * Get user psn entitlement ownership by entitlement label.
     */
    createOwnershipPsnPlatform_ByEntitlementLabel
  };
}

// src/generated-admin/RevocationAdminApi.ts
import { ApiUtils as ApiUtils26, Network as Network26 } from "@accelbyte/sdk";
function RevocationAdminApi(sdk, args) {
  const sdkAssembly = sdk.assembly();
  const namespace = args?.coreConfig?.namespace ?? sdkAssembly.coreConfig.namespace;
  const useSchemaValidation = args?.coreConfig?.useSchemaValidation ?? sdkAssembly.coreConfig.useSchemaValidation;
  let axiosInstance = sdkAssembly.axiosInstance;
  const requestConfigOverrides = args?.axiosConfig?.request;
  const baseURLOverride = args?.coreConfig?.baseURL;
  const interceptorsOverride = args?.axiosConfig?.interceptors ?? [];
  if (requestConfigOverrides || baseURLOverride || interceptorsOverride.length > 0) {
    const requestConfig = ApiUtils26.mergeAxiosConfigs(sdkAssembly.axiosInstance.defaults, {
      ...baseURLOverride ? { baseURL: baseURLOverride } : {},
      ...requestConfigOverrides
    });
    axiosInstance = Network26.create(requestConfig);
    for (const interceptor of interceptorsOverride) {
      if (interceptor.type === "request") {
        axiosInstance.interceptors.request.use(interceptor.onRequest, interceptor.onError);
      }
      if (interceptor.type === "response") {
        axiosInstance.interceptors.response.use(interceptor.onSuccess, interceptor.onError);
      }
    }
  }
  async function deleteRevocationConfig() {
    const $ = new RevocationAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.deleteRevocationConfig();
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getRevocationConfig() {
    const $ = new RevocationAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getRevocationConfig();
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function updateRevocationConfig(data) {
    const $ = new RevocationAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.updateRevocationConfig(data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getRevocationHistory(queryParams) {
    const $ = new RevocationAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getRevocationHistory(queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function updateRevocation_ByUserId(userId, data) {
    const $ = new RevocationAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.updateRevocation_ByUserId(userId, data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  return {
    /**
     * Delete revocation config.
     */
    deleteRevocationConfig,
    /**
     * Get revocation configuration.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: Revocation config&lt;/li&gt;&lt;/ul&gt;
     */
    getRevocationConfig,
    /**
     * Update revocation configuration.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: Revocation config&lt;/li&gt;&lt;/ul&gt;
     */
    updateRevocationConfig,
    /**
     * Query revocation histories in a namespace.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: query revocation history&lt;/li&gt;&lt;/ul&gt;
     */
    getRevocationHistory,
    /**
     * Do revocation.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: revocation results&lt;/li&gt;&lt;/ul&gt;
     */
    updateRevocation_ByUserId
  };
}

// src/generated-admin/RewardAdminApi.ts
import { ApiUtils as ApiUtils27, Network as Network27 } from "@accelbyte/sdk";
function RewardAdminApi(sdk, args) {
  const sdkAssembly = sdk.assembly();
  const namespace = args?.coreConfig?.namespace ?? sdkAssembly.coreConfig.namespace;
  const useSchemaValidation = args?.coreConfig?.useSchemaValidation ?? sdkAssembly.coreConfig.useSchemaValidation;
  let axiosInstance = sdkAssembly.axiosInstance;
  const requestConfigOverrides = args?.axiosConfig?.request;
  const baseURLOverride = args?.coreConfig?.baseURL;
  const interceptorsOverride = args?.axiosConfig?.interceptors ?? [];
  if (requestConfigOverrides || baseURLOverride || interceptorsOverride.length > 0) {
    const requestConfig = ApiUtils27.mergeAxiosConfigs(sdkAssembly.axiosInstance.defaults, {
      ...baseURLOverride ? { baseURL: baseURLOverride } : {},
      ...requestConfigOverrides
    });
    axiosInstance = Network27.create(requestConfig);
    for (const interceptor of interceptorsOverride) {
      if (interceptor.type === "request") {
        axiosInstance.interceptors.request.use(interceptor.onRequest, interceptor.onError);
      }
      if (interceptor.type === "response") {
        axiosInstance.interceptors.response.use(interceptor.onSuccess, interceptor.onError);
      }
    }
  }
  async function createReward(data) {
    const $ = new RewardAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.createReward(data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getRewardsExport() {
    const $ = new RewardAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getRewardsExport();
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function createRewardImport(data, queryParams) {
    const $ = new RewardAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.createRewardImport(data, queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function deleteReward_ByRewardId(rewardId) {
    const $ = new RewardAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.deleteReward_ByRewardId(rewardId);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getReward_ByRewardId(rewardId) {
    const $ = new RewardAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getReward_ByRewardId(rewardId);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function updateReward_ByRewardId(rewardId, data) {
    const $ = new RewardAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.updateReward_ByRewardId(rewardId, data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getRewardsByCriteria(queryParams) {
    const $ = new RewardAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getRewardsByCriteria(queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function updateMatch_ByRewardId(rewardId, data) {
    const $ = new RewardAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.updateMatch_ByRewardId(rewardId, data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function deleteRecord_ByRewardId(rewardId, data) {
    const $ = new RewardAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.deleteRecord_ByRewardId(rewardId, data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  return {
    /**
     * This API is used to create a reward.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: created reward data&lt;/li&gt;&lt;li&gt;&lt;i&gt;Acceptable values for rewardItem&#39;s identityType are&lt;/i&gt;: ITEM_ID or ITEM_SKU&lt;/li&gt;&lt;/ul&gt;
     */
    createReward,
    /**
     * Export reward configurations for a given namespace into file. At current, only JSON file is supported.
     */
    getRewardsExport,
    /**
     * Import reward configurations for a given namespace from file. At current, only JSON file is supported.
     */
    createRewardImport,
    /**
     * This API is used to delete a reward by reward Id. &lt;p&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: the deleted reward data&lt;/li&gt;&lt;/ul&gt;
     */
    deleteReward_ByRewardId,
    /**
     * This API is used to get reward by reward Id.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: reward instance&lt;/li&gt;&lt;/ul&gt;
     */
    getReward_ByRewardId,
    /**
     * This API is used to update a reward.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: reward instance&lt;/li&gt;&lt;li&gt;&lt;i&gt;Acceptable values for rewardItem&#39;s identityType are&lt;/i&gt;: ITEM_ID or ITEM_SKU&lt;/li&gt;&lt;/ul&gt;
     */
    updateReward_ByRewardId,
    /**
     * This API is used to query rewards by criteria.&lt;p&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: the list of rewards&lt;/li&gt;&lt;/ul&gt;
     */
    getRewardsByCriteria,
    /**
     * &lt;b&gt;[TEST FACILITY ONLY] Forbidden in live environment. &lt;/b&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: match result&lt;/li&gt;&lt;/ul&gt;
     */
    updateMatch_ByRewardId,
    /**
     * &lt;b&gt;[TEST FACILITY ONLY] Forbidden in live environment. &lt;/b&gt; This API is used to delete a reward condition record by reward Id and condition Name (optional). &lt;p&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: 204 No Content &lt;/li&gt;&lt;/ul&gt;
     */
    deleteRecord_ByRewardId
  };
}

// src/generated-admin/SectionAdminApi.ts
import { ApiUtils as ApiUtils28, Network as Network28 } from "@accelbyte/sdk";
function SectionAdminApi(sdk, args) {
  const sdkAssembly = sdk.assembly();
  const namespace = args?.coreConfig?.namespace ?? sdkAssembly.coreConfig.namespace;
  const useSchemaValidation = args?.coreConfig?.useSchemaValidation ?? sdkAssembly.coreConfig.useSchemaValidation;
  let axiosInstance = sdkAssembly.axiosInstance;
  const requestConfigOverrides = args?.axiosConfig?.request;
  const baseURLOverride = args?.coreConfig?.baseURL;
  const interceptorsOverride = args?.axiosConfig?.interceptors ?? [];
  if (requestConfigOverrides || baseURLOverride || interceptorsOverride.length > 0) {
    const requestConfig = ApiUtils28.mergeAxiosConfigs(sdkAssembly.axiosInstance.defaults, {
      ...baseURLOverride ? { baseURL: baseURLOverride } : {},
      ...requestConfigOverrides
    });
    axiosInstance = Network28.create(requestConfig);
    for (const interceptor of interceptorsOverride) {
      if (interceptor.type === "request") {
        axiosInstance.interceptors.request.use(interceptor.onRequest, interceptor.onError);
      }
      if (interceptor.type === "response") {
        axiosInstance.interceptors.response.use(interceptor.onSuccess, interceptor.onError);
      }
    }
  }
  async function getSections(queryParams) {
    const $ = new SectionAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getSections(queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function createSection(data, queryParams) {
    const $ = new SectionAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.createSection(data, queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function deleteSection_BySectionId(sectionId, queryParams) {
    const $ = new SectionAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.deleteSection_BySectionId(sectionId, queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getSection_BySectionId(sectionId, queryParams) {
    const $ = new SectionAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getSection_BySectionId(sectionId, queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function updateSection_BySectionId(sectionId, data, queryParams) {
    const $ = new SectionAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.updateSection_BySectionId(sectionId, data, queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function deleteSectionPurgeExpired(queryParams) {
    const $ = new SectionAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.deleteSectionPurgeExpired(queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  return {
    /**
     * This API is used to query sections.&lt;p&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: paginated sections&lt;/li&gt;&lt;/ul&gt;
     */
    getSections,
    /**
     * This API is used to create a section.&lt;p&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: created a section&lt;/li&gt;&lt;/ul&gt;&lt;h2&gt;Restrictions for section extension and localization extension&lt;/h2&gt; 1. Cannot use &lt;b&gt;&#34;.&#34;&lt;/b&gt; as the key name - &lt;pre&gt;{ &#34;data.2&#34;: &#34;value&#34; }&lt;/pre&gt; 2. Cannot use &lt;b&gt;&#34;$&#34;&lt;/b&gt; as the prefix in key names - &lt;pre&gt;{ &#34;$data&#34;: &#34;value&#34; }&lt;/pre&gt;
     */
    createSection,
    /**
     * This API is used to delete s section.
     */
    deleteSection_BySectionId,
    /**
     * This API is used to get a section.&lt;p&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: section data&lt;/li&gt;&lt;/ul&gt;
     */
    getSection_BySectionId,
    /**
     * This API is used to update s section.&lt;p&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: updated section data&lt;/li&gt;&lt;/ul&gt;&lt;h2&gt;Restrictions for section extension and localization extension&lt;/h2&gt; 1. Cannot use &lt;b&gt;&#34;.&#34;&lt;/b&gt; as the key name - &lt;pre&gt;{ &#34;data.2&#34;: &#34;value&#34; }&lt;/pre&gt; 2. Cannot use &lt;b&gt;&#34;$&#34;&lt;/b&gt; as the prefix in key names - &lt;pre&gt;{ &#34;$data&#34;: &#34;value&#34; }&lt;/pre&gt;
     */
    updateSection_BySectionId,
    /**
     * This API is used to purge expired section.
     */
    deleteSectionPurgeExpired
  };
}

// src/generated-admin/ServicePluginConfigAdminApi.ts
import { ApiUtils as ApiUtils29, Network as Network29 } from "@accelbyte/sdk";
function ServicePluginConfigAdminApi(sdk, args) {
  const sdkAssembly = sdk.assembly();
  const namespace = args?.coreConfig?.namespace ?? sdkAssembly.coreConfig.namespace;
  const useSchemaValidation = args?.coreConfig?.useSchemaValidation ?? sdkAssembly.coreConfig.useSchemaValidation;
  let axiosInstance = sdkAssembly.axiosInstance;
  const requestConfigOverrides = args?.axiosConfig?.request;
  const baseURLOverride = args?.coreConfig?.baseURL;
  const interceptorsOverride = args?.axiosConfig?.interceptors ?? [];
  if (requestConfigOverrides || baseURLOverride || interceptorsOverride.length > 0) {
    const requestConfig = ApiUtils29.mergeAxiosConfigs(sdkAssembly.axiosInstance.defaults, {
      ...baseURLOverride ? { baseURL: baseURLOverride } : {},
      ...requestConfigOverrides
    });
    axiosInstance = Network29.create(requestConfig);
    for (const interceptor of interceptorsOverride) {
      if (interceptor.type === "request") {
        axiosInstance.interceptors.request.use(interceptor.onRequest, interceptor.onError);
      }
      if (interceptor.type === "response") {
        axiosInstance.interceptors.response.use(interceptor.onSuccess, interceptor.onError);
      }
    }
  }
  async function deleteConfigServicePlugin() {
    const $ = new ServicePluginConfigAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.deleteConfigServicePlugin();
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getConfigsServicePlugin() {
    const $ = new ServicePluginConfigAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getConfigsServicePlugin();
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function updateConfigServicePlugin(data) {
    const $ = new ServicePluginConfigAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.updateConfigServicePlugin(data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function deleteCatalogPluginLootbox() {
    const $ = new ServicePluginConfigAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.deleteCatalogPluginLootbox();
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getCatalogPluginsLootbox() {
    const $ = new ServicePluginConfigAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getCatalogPluginsLootbox();
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function updateCatalogPluginLootbox(data) {
    const $ = new ServicePluginConfigAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.updateCatalogPluginLootbox(data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function deleteCatalogPluginSection() {
    const $ = new ServicePluginConfigAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.deleteCatalogPluginSection();
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getCatalogPluginsSection() {
    const $ = new ServicePluginConfigAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getCatalogPluginsSection();
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function updateCatalogPluginSection(data) {
    const $ = new ServicePluginConfigAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.updateCatalogPluginSection(data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function deleteRevocationPluginRevocation() {
    const $ = new ServicePluginConfigAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.deleteRevocationPluginRevocation();
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getRevocationPluginsRevocation() {
    const $ = new ServicePluginConfigAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getRevocationPluginsRevocation();
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function updateRevocationPluginRevocation(data) {
    const $ = new ServicePluginConfigAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.updateRevocationPluginRevocation(data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getCatalogPluginsLootboxGrpcInfo(queryParams) {
    const $ = new ServicePluginConfigAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getCatalogPluginsLootboxGrpcInfo(queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function updateCatalogPluginLootboxCustomConfigCert(data) {
    const $ = new ServicePluginConfigAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.updateCatalogPluginLootboxCustomConfigCert(data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function updateCatalogPluginSectionCustomConfigCert(data) {
    const $ = new ServicePluginConfigAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.updateCatalogPluginSectionCustomConfigCert(data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function updateRevocationPluginRevocationRevocationCustomConfigCert(data) {
    const $ = new ServicePluginConfigAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.updateRevocationPluginRevocationRevocationCustomConfigCert(data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  return {
    /**
     * @deprecated
     * Delete service plugin config
     */
    deleteConfigServicePlugin,
    /**
     * @deprecated
     * Get service plugin config
     */
    getConfigsServicePlugin,
    /**
     * @deprecated
     * Update catalog config. Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: updated service plugin config&lt;/li&gt;&lt;/ul&gt;
     */
    updateConfigServicePlugin,
    /**
     * Delete service plugin config.
     */
    deleteCatalogPluginLootbox,
    /**
     * Get lootbox plugin config.
     */
    getCatalogPluginsLootbox,
    /**
     * Update lootbox plugin config. Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: updated service plugin config&lt;/li&gt;&lt;/ul&gt;
     */
    updateCatalogPluginLootbox,
    /**
     * Delete section plugin config.
     */
    deleteCatalogPluginSection,
    /**
     * Get section plugin config.
     */
    getCatalogPluginsSection,
    /**
     * Update section config. Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: updated service plugin config&lt;/li&gt;&lt;/ul&gt;
     */
    updateCatalogPluginSection,
    /**
     * Delete service plugin config.
     */
    deleteRevocationPluginRevocation,
    /**
     * Get revocation plugin config.
     */
    getRevocationPluginsRevocation,
    /**
     * Update revocation plugin config. Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: updated service plugin config&lt;/li&gt;&lt;/ul&gt;
     */
    updateRevocationPluginRevocation,
    /**
     * Get lootbox plugin gRPC info.
     */
    getCatalogPluginsLootboxGrpcInfo,
    /**
     * Upload lootbox plugin custom config tls cert.Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: updated service plugin config&lt;/li&gt;&lt;/ul&gt;
     */
    updateCatalogPluginLootboxCustomConfigCert,
    /**
     * Upload section plugin custom config tls cert.Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: updated service plugin config&lt;/li&gt;&lt;/ul&gt;
     */
    updateCatalogPluginSectionCustomConfigCert,
    /**
     * Upload revocation plugin custom config tls cert.Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: updated service plugin config&lt;/li&gt;&lt;/ul&gt;
     */
    updateRevocationPluginRevocationRevocationCustomConfigCert
  };
}

// src/generated-admin/SessionPlatformAdminApi.ts
import { ApiUtils as ApiUtils30, Network as Network30 } from "@accelbyte/sdk";
function SessionPlatformAdminApi(sdk, args) {
  const sdkAssembly = sdk.assembly();
  const namespace = args?.coreConfig?.namespace ?? sdkAssembly.coreConfig.namespace;
  const useSchemaValidation = args?.coreConfig?.useSchemaValidation ?? sdkAssembly.coreConfig.useSchemaValidation;
  let axiosInstance = sdkAssembly.axiosInstance;
  const requestConfigOverrides = args?.axiosConfig?.request;
  const baseURLOverride = args?.coreConfig?.baseURL;
  const interceptorsOverride = args?.axiosConfig?.interceptors ?? [];
  if (requestConfigOverrides || baseURLOverride || interceptorsOverride.length > 0) {
    const requestConfig = ApiUtils30.mergeAxiosConfigs(sdkAssembly.axiosInstance.defaults, {
      ...baseURLOverride ? { baseURL: baseURLOverride } : {},
      ...requestConfigOverrides
    });
    axiosInstance = Network30.create(requestConfig);
    for (const interceptor of interceptorsOverride) {
      if (interceptor.type === "request") {
        axiosInstance.interceptors.request.use(interceptor.onRequest, interceptor.onError);
      }
      if (interceptor.type === "response") {
        axiosInstance.interceptors.response.use(interceptor.onSuccess, interceptor.onError);
      }
    }
  }
  async function updateSessionXbl_ByUserId(userId, data) {
    const $ = new SessionPlatformAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.updateSessionXbl_ByUserId(userId, data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  return {
    /**
     * This API is used to register/update a session on xbox.
     */
    updateSessionXbl_ByUserId
  };
}

// src/generated-admin/StoreAdminApi.ts
import { ApiUtils as ApiUtils31, Network as Network31 } from "@accelbyte/sdk";
function StoreAdminApi(sdk, args) {
  const sdkAssembly = sdk.assembly();
  const namespace = args?.coreConfig?.namespace ?? sdkAssembly.coreConfig.namespace;
  const useSchemaValidation = args?.coreConfig?.useSchemaValidation ?? sdkAssembly.coreConfig.useSchemaValidation;
  let axiosInstance = sdkAssembly.axiosInstance;
  const requestConfigOverrides = args?.axiosConfig?.request;
  const baseURLOverride = args?.coreConfig?.baseURL;
  const interceptorsOverride = args?.axiosConfig?.interceptors ?? [];
  if (requestConfigOverrides || baseURLOverride || interceptorsOverride.length > 0) {
    const requestConfig = ApiUtils31.mergeAxiosConfigs(sdkAssembly.axiosInstance.defaults, {
      ...baseURLOverride ? { baseURL: baseURLOverride } : {},
      ...requestConfigOverrides
    });
    axiosInstance = Network31.create(requestConfig);
    for (const interceptor of interceptorsOverride) {
      if (interceptor.type === "request") {
        axiosInstance.interceptors.request.use(interceptor.onRequest, interceptor.onError);
      }
      if (interceptor.type === "response") {
        axiosInstance.interceptors.response.use(interceptor.onSuccess, interceptor.onError);
      }
    }
  }
  async function getStores() {
    const $ = new StoreAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getStores();
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function createStore(data) {
    const $ = new StoreAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.createStore(data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function updateStoreImport(data, queryParams) {
    const $ = new StoreAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.updateStoreImport(data, queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getCatalogConfigs() {
    const $ = new StoreAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getCatalogConfigs();
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function updateCatalogConfig(data) {
    const $ = new StoreAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.updateCatalogConfig(data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function deleteStore_ByStoreId(storeId) {
    const $ = new StoreAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.deleteStore_ByStoreId(storeId);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getStore_ByStoreId(storeId) {
    const $ = new StoreAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getStore_ByStoreId(storeId);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function updateStore_ByStoreId(storeId, data) {
    const $ = new StoreAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.updateStore_ByStoreId(storeId, data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function deleteStorePublished() {
    const $ = new StoreAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.deleteStorePublished();
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getStoresPublished() {
    const $ = new StoreAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getStoresPublished();
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function updateStoreImport_v2(data, queryParams) {
    const $ = new StoreAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.updateStoreImport_v2(data, queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function createStoreExportByCsv(data) {
    const $ = new StoreAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.createStoreExportByCsv(data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function updateClone_ByStoreId(storeId, queryParams) {
    const $ = new StoreAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.updateClone_ByStoreId(storeId, queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getExport_ByStoreId(storeId) {
    const $ = new StoreAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getExport_ByStoreId(storeId);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getStoresPublishedBackup() {
    const $ = new StoreAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getStoresPublishedBackup();
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getStoresCatalogDefinition(queryParams) {
    const $ = new StoreAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getStoresCatalogDefinition(queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function updateStorePublishedRollback() {
    const $ = new StoreAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.updateStorePublishedRollback();
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function createExport_ByStoreId_v2(storeId, data) {
    const $ = new StoreAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.createExport_ByStoreId_v2(storeId, data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getStoresDownloadCsvTemplates() {
    const $ = new StoreAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getStoresDownloadCsvTemplates();
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function createImportByCsv_ByStoreId(storeId, data) {
    const $ = new StoreAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.createImportByCsv_ByStoreId(storeId, data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getImportHistory_ByStoreId(storeId, queryParams) {
    const $ = new StoreAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getImportHistory_ByStoreId(storeId, queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  return {
    /**
     * This API is used to list stores in a namespace.&lt;p&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: the list of stores&lt;/li&gt;&lt;/ul&gt;
     */
    getStores,
    /**
     * This API is used to create a non published store in a namespace.&lt;p&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: created store data&lt;/li&gt;&lt;/ul&gt;
     */
    createStore,
    /**
     * @deprecated
     * This API is used to import a store.&lt;p&gt;This api has been deprecated, pls use /v2/admin/namespaces/{namespace}/stores/import to import store.&lt;br&gt;
     */
    updateStoreImport,
    /**
     * Get catalog config.
     */
    getCatalogConfigs,
    /**
     * Update catalog config. Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: updated catalog config&lt;/li&gt;&lt;/ul&gt;
     */
    updateCatalogConfig,
    /**
     * This API is used to delete a store. Only non published store can be deleted.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: store&lt;/li&gt;&lt;/ul&gt;
     */
    deleteStore_ByStoreId,
    /**
     * This API is used to get a store.&lt;p&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: store data&lt;/li&gt;&lt;/ul&gt;
     */
    getStore_ByStoreId,
    /**
     * This API is used to Update a store basic info.&lt;p&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: updated store data&lt;/li&gt;&lt;/ul&gt;
     */
    updateStore_ByStoreId,
    /**
     * This API is used to delete published store including category and items before release to public.&lt;p&gt;&lt;b&gt;Warning: Please do not use this API once published to public user.&lt;/b&gt;
     */
    deleteStorePublished,
    /**
     * This API is used to get a published store basic info, exclude category and item information.&lt;p&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: store data&lt;/li&gt;&lt;/ul&gt;
     */
    getStoresPublished,
    /**
     * This API is used to import a store.
     */
    updateStoreImport_v2,
    /**
     * This API is used to export a store to CSV format
     */
    createStoreExportByCsv,
    /**
     * This API is used to clone a store. Usually clone a draft store to published store because published store can&#39;t directly edit content.&lt;p&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: clone store info&lt;/li&gt;&lt;/ul&gt;
     */
    updateClone_ByStoreId,
    /**
     * @deprecated
     * This API is used to export a store.&lt;p&gt;This api has been deprecated, pls use /v2/admin/namespaces/{namespace}/stores/export to export store.&lt;br&gt;
     */
    getExport_ByStoreId,
    /**
     * This API is used to get a store&#39;s backup. &lt;p&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: store backup info&lt;/li&gt;&lt;/ul&gt;
     */
    getStoresPublishedBackup,
    /**
     * This API is used to get catalog definition for import/export store by CSV&lt;p&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: catalog definition&lt;/li&gt;&lt;/ul&gt;
     */
    getStoresCatalogDefinition,
    /**
     * This API is used to rollback a published store. &lt;p&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: updated store info&lt;/li&gt;&lt;/ul&gt;
     */
    updateStorePublishedRollback,
    /**
     * This API is used to export a whole or partial store.
     */
    createExport_ByStoreId_v2,
    /**
     * This API is used to download store csv templates for store importing by CSV feature
     */
    getStoresDownloadCsvTemplates,
    /**
     * This API is used to import a store by CSV format.
     */
    createImportByCsv_ByStoreId,
    /**
     * This API is used to query import store history
     */
    getImportHistory_ByStoreId
  };
}

// src/generated-admin/SubscriptionAdminApi.ts
import { ApiUtils as ApiUtils32, Network as Network32 } from "@accelbyte/sdk";
function SubscriptionAdminApi(sdk, args) {
  const sdkAssembly = sdk.assembly();
  const namespace = args?.coreConfig?.namespace ?? sdkAssembly.coreConfig.namespace;
  const useSchemaValidation = args?.coreConfig?.useSchemaValidation ?? sdkAssembly.coreConfig.useSchemaValidation;
  let axiosInstance = sdkAssembly.axiosInstance;
  const requestConfigOverrides = args?.axiosConfig?.request;
  const baseURLOverride = args?.coreConfig?.baseURL;
  const interceptorsOverride = args?.axiosConfig?.interceptors ?? [];
  if (requestConfigOverrides || baseURLOverride || interceptorsOverride.length > 0) {
    const requestConfig = ApiUtils32.mergeAxiosConfigs(sdkAssembly.axiosInstance.defaults, {
      ...baseURLOverride ? { baseURL: baseURLOverride } : {},
      ...requestConfigOverrides
    });
    axiosInstance = Network32.create(requestConfig);
    for (const interceptor of interceptorsOverride) {
      if (interceptor.type === "request") {
        axiosInstance.interceptors.request.use(interceptor.onRequest, interceptor.onError);
      }
      if (interceptor.type === "response") {
        axiosInstance.interceptors.response.use(interceptor.onSuccess, interceptor.onError);
      }
    }
  }
  async function getSubscriptions(queryParams) {
    const $ = new SubscriptionAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getSubscriptions(queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getSubscriptions_ByUserId(userId, queryParams) {
    const $ = new SubscriptionAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getSubscriptions_ByUserId(userId, queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getSubscriptionsActivities_ByUserId(userId, queryParams) {
    const $ = new SubscriptionAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getSubscriptionsActivities_ByUserId(userId, queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function updateRecurring_BySubscriptionId(subscriptionId) {
    const $ = new SubscriptionAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.updateRecurring_BySubscriptionId(subscriptionId);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function deleteSubscription_ByUserId_BySubscriptionId(userId, subscriptionId) {
    const $ = new SubscriptionAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.deleteSubscription_ByUserId_BySubscriptionId(userId, subscriptionId);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getSubscription_ByUserId_BySubscriptionId(userId, subscriptionId) {
    const $ = new SubscriptionAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getSubscription_ByUserId_BySubscriptionId(userId, subscriptionId);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function createSubscriptionPlatformSubscribe_ByUserId(userId, data) {
    const $ = new SubscriptionAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.createSubscriptionPlatformSubscribe_ByUserId(userId, data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getSubscriptionsSubscribableByItemId_ByUserId(userId, queryParams) {
    const $ = new SubscriptionAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getSubscriptionsSubscribableByItemId_ByUserId(userId, queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function updateGrant_ByUserId_BySubscriptionId(userId, subscriptionId, data) {
    const $ = new SubscriptionAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.updateGrant_ByUserId_BySubscriptionId(userId, subscriptionId, data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function updateCancel_ByUserId_BySubscriptionId(userId, subscriptionId, data, queryParams) {
    const $ = new SubscriptionAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.updateCancel_ByUserId_BySubscriptionId(userId, subscriptionId, data, queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getHistory_ByUserId_BySubscriptionId(userId, subscriptionId, queryParams) {
    const $ = new SubscriptionAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getHistory_ByUserId_BySubscriptionId(userId, subscriptionId, queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function createNotification_ByUserId_BySubscriptionId(userId, subscriptionId, data) {
    const $ = new SubscriptionAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.createNotification_ByUserId_BySubscriptionId(userId, subscriptionId, data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  return {
    /**
     * Query subscriptions.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: paginated subscriptions&lt;/li&gt;&lt;/ul&gt;
     */
    getSubscriptions,
    /**
     * Query user subscriptions.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: paginated subscription&lt;/li&gt;&lt;/ul&gt;
     */
    getSubscriptions_ByUserId,
    /**
     * Get user subscription activity.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: paginated subscription activity&lt;/li&gt;&lt;/ul&gt;
     */
    getSubscriptionsActivities_ByUserId,
    /**
     * &lt;b&gt;[TEST FACILITY ONLY] Forbidden in live environment. &lt;/b&gt; Recurring charge subscription, it will trigger recurring charge if the USER subscription status is ACTIVE, nextBillingDate is before now and no fail recurring charge within X(default 12) hours.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: recurring charge result&lt;/li&gt;&lt;/ul&gt;
     */
    updateRecurring_BySubscriptionId,
    /**
     * &lt;b&gt;[TEST FACILITY ONLY] Forbidden in live environment. &lt;/b&gt; Delete user subscription.
     */
    deleteSubscription_ByUserId_BySubscriptionId,
    /**
     * Get user subscription.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: subscription&lt;/li&gt;&lt;/ul&gt;
     */
    getSubscription_ByUserId_BySubscriptionId,
    /**
     * Free subscribe by platform, can used by other justice service to redeem/reward the subscription.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: result subscription&lt;/li&gt;&lt;/ul&gt;
     */
    createSubscriptionPlatformSubscribe_ByUserId,
    /**
     * Check user subscription subscribable by itemId, ACTIVE USER subscription can&#39;t do subscribe again.&lt;p&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: subscribable info&lt;/li&gt;&lt;/ul&gt;
     */
    getSubscriptionsSubscribableByItemId_ByUserId,
    /**
     * Grant days to a subscription, if grantDays is positive, it will add free days and push the next billing date by the amount of day.&lt;br&gt;if the grantDays is negative or zero, it only apply to active/cancelled subscription, remove days will decrease current period end, and move the next billing date closer.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: updated subscription&lt;/li&gt;&lt;/ul&gt;
     */
    updateGrant_ByUserId_BySubscriptionId,
    /**
     * Cancel a subscription, only ACTIVE subscription can be cancelled. &lt;b&gt;Ensure successfully cancel, recommend at least 1 day before current period ends, otherwise it may be charging or charged.&lt;/b&gt;&lt;br&gt;Set immediate true, the subscription will be terminated immediately, otherwise till the end of current billing cycle.&lt;br&gt;Set force true, will ignore the error if subscription is during recurring charging.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: cancelled subscription&lt;/li&gt;&lt;/ul&gt;
     */
    updateCancel_ByUserId_BySubscriptionId,
    /**
     * Get user subscription billing histories.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: paginated subscription billing history&lt;/li&gt;&lt;/ul&gt;
     */
    getHistory_ByUserId_BySubscriptionId,
    /**
     * &lt;b&gt;[SERVICE COMMUNICATION ONLY]&lt;/b&gt; This API is used as a web hook for payment notification from justice payment service.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: Process result&lt;/li&gt;&lt;/ul&gt;
     */
    createNotification_ByUserId_BySubscriptionId
  };
}

// src/generated-admin/TicketAdminApi.ts
import { ApiUtils as ApiUtils33, Network as Network33 } from "@accelbyte/sdk";
function TicketAdminApi(sdk, args) {
  const sdkAssembly = sdk.assembly();
  const namespace = args?.coreConfig?.namespace ?? sdkAssembly.coreConfig.namespace;
  const useSchemaValidation = args?.coreConfig?.useSchemaValidation ?? sdkAssembly.coreConfig.useSchemaValidation;
  let axiosInstance = sdkAssembly.axiosInstance;
  const requestConfigOverrides = args?.axiosConfig?.request;
  const baseURLOverride = args?.coreConfig?.baseURL;
  const interceptorsOverride = args?.axiosConfig?.interceptors ?? [];
  if (requestConfigOverrides || baseURLOverride || interceptorsOverride.length > 0) {
    const requestConfig = ApiUtils33.mergeAxiosConfigs(sdkAssembly.axiosInstance.defaults, {
      ...baseURLOverride ? { baseURL: baseURLOverride } : {},
      ...requestConfigOverrides
    });
    axiosInstance = Network33.create(requestConfig);
    for (const interceptor of interceptorsOverride) {
      if (interceptor.type === "request") {
        axiosInstance.interceptors.request.use(interceptor.onRequest, interceptor.onError);
      }
      if (interceptor.type === "response") {
        axiosInstance.interceptors.response.use(interceptor.onSuccess, interceptor.onError);
      }
    }
  }
  async function getTicket_ByBoothName(boothName) {
    const $ = new TicketAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getTicket_ByBoothName(boothName);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getId_ByBoothName(boothName) {
    const $ = new TicketAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getId_ByBoothName(boothName);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function updateDecrement_ByBoothName(boothName, data) {
    const $ = new TicketAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.updateDecrement_ByBoothName(boothName, data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function updateIncrement_ByBoothName(boothName, data) {
    const $ = new TicketAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.updateIncrement_ByBoothName(boothName, data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function createTicket_ByUserId_ByBoothName(userId, boothName, data) {
    const $ = new TicketAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.createTicket_ByUserId_ByBoothName(userId, boothName, data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  return {
    /**
     * &lt;b&gt;[SERVICE COMMUNICATION ONLY]&lt;/b&gt; Get ticket(code/key) dynamic based on booth name.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: ticket dynamic&lt;/li&gt;&lt;/ul&gt;
     */
    getTicket_ByBoothName,
    /**
     * Get ticket(code/key) booth ID.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: ticket booth id&lt;/li&gt;&lt;/ul&gt;
     */
    getId_ByBoothName,
    /**
     * &lt;b&gt;[SERVICE COMMUNICATION ONLY]&lt;/b&gt; Decrease ticket(code/key) sale if requested orderNo is already increased.
     */
    updateDecrement_ByBoothName,
    /**
     * &lt;b&gt;[SERVICE COMMUNICATION ONLY]&lt;/b&gt; increase ticket(code/key) sale.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: Ticket sale increment result&lt;/li&gt;&lt;/ul&gt;
     */
    updateIncrement_ByBoothName,
    /**
     * &lt;b&gt;[SERVICE COMMUNICATION ONLY]&lt;/b&gt; Acquire ticket(code/key) based on booth name.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: acquire result&lt;/li&gt;&lt;/ul&gt;
     */
    createTicket_ByUserId_ByBoothName
  };
}

// src/generated-admin/TradeActionAdminApi.ts
import { ApiUtils as ApiUtils34, Network as Network34 } from "@accelbyte/sdk";
function TradeActionAdminApi(sdk, args) {
  const sdkAssembly = sdk.assembly();
  const namespace = args?.coreConfig?.namespace ?? sdkAssembly.coreConfig.namespace;
  const useSchemaValidation = args?.coreConfig?.useSchemaValidation ?? sdkAssembly.coreConfig.useSchemaValidation;
  let axiosInstance = sdkAssembly.axiosInstance;
  const requestConfigOverrides = args?.axiosConfig?.request;
  const baseURLOverride = args?.coreConfig?.baseURL;
  const interceptorsOverride = args?.axiosConfig?.interceptors ?? [];
  if (requestConfigOverrides || baseURLOverride || interceptorsOverride.length > 0) {
    const requestConfig = ApiUtils34.mergeAxiosConfigs(sdkAssembly.axiosInstance.defaults, {
      ...baseURLOverride ? { baseURL: baseURLOverride } : {},
      ...requestConfigOverrides
    });
    axiosInstance = Network34.create(requestConfig);
    for (const interceptor of interceptorsOverride) {
      if (interceptor.type === "request") {
        axiosInstance.interceptors.request.use(interceptor.onRequest, interceptor.onError);
      }
      if (interceptor.type === "response") {
        axiosInstance.interceptors.response.use(interceptor.onSuccess, interceptor.onError);
      }
    }
  }
  async function createTradeCommit(data) {
    const $ = new TradeActionAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.createTradeCommit(data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getTrade_ByTransactionId(transactionId) {
    const $ = new TradeActionAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getTrade_ByTransactionId(transactionId);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getTradeHistoryByCriteria(queryParams) {
    const $ = new TradeActionAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getTradeHistoryByCriteria(queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  return {
    /**
     * This API is used to create a chained operations&lt;p&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: chain action history&lt;/li&gt;&lt;li&gt;&lt;i&gt;FULFILL_ITEM operation supported item type&lt;/i&gt;: INGAMEITEM,LOOTBOX,OPTIONBOX&lt;/li&gt;&lt;/ul&gt;&lt;h2&gt;Restrictions for metadata&lt;/h2&gt; 1. Cannot use &lt;b&gt;&#34;.&#34;&lt;/b&gt; as the key name - &lt;pre&gt;{ &#34;data.2&#34;: &#34;value&#34; }&lt;/pre&gt; 2. Cannot use &lt;b&gt;&#34;$&#34;&lt;/b&gt; as the prefix in key names - &lt;pre&gt;{ &#34;$data&#34;: &#34;value&#34; }&lt;/pre&gt;
     */
    createTradeCommit,
    /**
     * This API is used to fetch a specific trade history using transaction ID&lt;p&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: trade history based on transaction ID&lt;/li&gt;&lt;/ul&gt;
     */
    getTrade_ByTransactionId,
    /**
     * This API is used to fetch trade history based on the provided criteria&lt;p&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: trade history list based on criteria&lt;/li&gt;&lt;/ul&gt;
     */
    getTradeHistoryByCriteria
  };
}

// src/generated-admin/ViewAdminApi.ts
import { ApiUtils as ApiUtils35, Network as Network35 } from "@accelbyte/sdk";
function ViewAdminApi(sdk, args) {
  const sdkAssembly = sdk.assembly();
  const namespace = args?.coreConfig?.namespace ?? sdkAssembly.coreConfig.namespace;
  const useSchemaValidation = args?.coreConfig?.useSchemaValidation ?? sdkAssembly.coreConfig.useSchemaValidation;
  let axiosInstance = sdkAssembly.axiosInstance;
  const requestConfigOverrides = args?.axiosConfig?.request;
  const baseURLOverride = args?.coreConfig?.baseURL;
  const interceptorsOverride = args?.axiosConfig?.interceptors ?? [];
  if (requestConfigOverrides || baseURLOverride || interceptorsOverride.length > 0) {
    const requestConfig = ApiUtils35.mergeAxiosConfigs(sdkAssembly.axiosInstance.defaults, {
      ...baseURLOverride ? { baseURL: baseURLOverride } : {},
      ...requestConfigOverrides
    });
    axiosInstance = Network35.create(requestConfig);
    for (const interceptor of interceptorsOverride) {
      if (interceptor.type === "request") {
        axiosInstance.interceptors.request.use(interceptor.onRequest, interceptor.onError);
      }
      if (interceptor.type === "response") {
        axiosInstance.interceptors.response.use(interceptor.onSuccess, interceptor.onError);
      }
    }
  }
  async function getViews(queryParams) {
    const $ = new ViewAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getViews(queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function createView(data, queryParams) {
    const $ = new ViewAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.createView(data, queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function deleteView_ByViewId(viewId, queryParams) {
    const $ = new ViewAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.deleteView_ByViewId(viewId, queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getView_ByViewId(viewId, queryParams) {
    const $ = new ViewAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getView_ByViewId(viewId, queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function updateView_ByViewId(viewId, data, queryParams) {
    const $ = new ViewAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.updateView_ByViewId(viewId, data, queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  return {
    /**
     * This API is used to list all views.&lt;p&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: the list of views&lt;/li&gt;&lt;/ul&gt;
     */
    getViews,
    /**
     * This API is used to create a view.&lt;p&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: created a view&lt;/li&gt;&lt;/ul&gt;&lt;h2&gt;Restrictions for localization extension&lt;/h2&gt; 1. Cannot use &lt;b&gt;&#34;.&#34;&lt;/b&gt; as the key name - &lt;pre&gt;{ &#34;data.2&#34;: &#34;value&#34; }&lt;/pre&gt; 2. Cannot use &lt;b&gt;&#34;$&#34;&lt;/b&gt; as the prefix in key names - &lt;pre&gt;{ &#34;$data&#34;: &#34;value&#34; }&lt;/pre&gt;
     */
    createView,
    /**
     * This API is used to delete a view.It will also delete all the related sections
     */
    deleteView_ByViewId,
    /**
     * This API is used to get a view.&lt;p&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: view data&lt;/li&gt;&lt;/ul&gt;
     */
    getView_ByViewId,
    /**
     * This API is used to update a view.&lt;p&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: updated view data&lt;/li&gt;&lt;/ul&gt;&lt;h2&gt;Restrictions for localization extension&lt;/h2&gt; 1. Cannot use &lt;b&gt;&#34;.&#34;&lt;/b&gt; as the key name - &lt;pre&gt;{ &#34;data.2&#34;: &#34;value&#34; }&lt;/pre&gt; 2. Cannot use &lt;b&gt;&#34;$&#34;&lt;/b&gt; as the prefix in key names - &lt;pre&gt;{ &#34;$data&#34;: &#34;value&#34; }&lt;/pre&gt;
     */
    updateView_ByViewId
  };
}

// src/generated-admin/WalletAdminApi.ts
import { ApiUtils as ApiUtils36, Network as Network36 } from "@accelbyte/sdk";
function WalletAdminApi(sdk, args) {
  const sdkAssembly = sdk.assembly();
  const namespace = args?.coreConfig?.namespace ?? sdkAssembly.coreConfig.namespace;
  const useSchemaValidation = args?.coreConfig?.useSchemaValidation ?? sdkAssembly.coreConfig.useSchemaValidation;
  let axiosInstance = sdkAssembly.axiosInstance;
  const requestConfigOverrides = args?.axiosConfig?.request;
  const baseURLOverride = args?.coreConfig?.baseURL;
  const interceptorsOverride = args?.axiosConfig?.interceptors ?? [];
  if (requestConfigOverrides || baseURLOverride || interceptorsOverride.length > 0) {
    const requestConfig = ApiUtils36.mergeAxiosConfigs(sdkAssembly.axiosInstance.defaults, {
      ...baseURLOverride ? { baseURL: baseURLOverride } : {},
      ...requestConfigOverrides
    });
    axiosInstance = Network36.create(requestConfig);
    for (const interceptor of interceptorsOverride) {
      if (interceptor.type === "request") {
        axiosInstance.interceptors.request.use(interceptor.onRequest, interceptor.onError);
      }
      if (interceptor.type === "response") {
        axiosInstance.interceptors.response.use(interceptor.onSuccess, interceptor.onError);
      }
    }
  }
  async function getWallets(queryParams) {
    const $ = new WalletAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getWallets(queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function createWalletDebit(data) {
    const $ = new WalletAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.createWalletDebit(data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function createWalletCredit(data) {
    const $ = new WalletAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.createWalletCredit(data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getWallet_ByWalletId(walletId) {
    const $ = new WalletAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getWallet_ByWalletId(walletId);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getWallet_ByUserId_ByWalletId(userId, walletId) {
    const $ = new WalletAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getWallet_ByUserId_ByWalletId(userId, walletId);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getWalletConfig_ByPlatform(platform) {
    const $ = new WalletAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getWalletConfig_ByPlatform(platform);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function updateWalletConfig_ByPlatform(platform, data) {
    const $ = new WalletAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.updateWalletConfig_ByPlatform(platform, data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function updateDebit_ByUserId_ByWalletId(userId, walletId, data) {
    const $ = new WalletAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.updateDebit_ByUserId_ByWalletId(userId, walletId, data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function updateWalletConfigReset_ByPlatform(platform) {
    const $ = new WalletAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.updateWalletConfigReset_ByPlatform(platform);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function updateEnable_ByUserId_ByWalletId(userId, walletId) {
    const $ = new WalletAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.updateEnable_ByUserId_ByWalletId(userId, walletId);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function updateDisable_ByUserId_ByWalletId(userId, walletId) {
    const $ = new WalletAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.updateDisable_ByUserId_ByWalletId(userId, walletId);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getWalletsCurrenciesSummary_ByUserId(userId) {
    const $ = new WalletAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getWalletsCurrenciesSummary_ByUserId(userId);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getCheck_ByUserId_ByCurrencyCode(userId, currencyCode, queryParams) {
    const $ = new WalletAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getCheck_ByUserId_ByCurrencyCode(userId, currencyCode, queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function updateCredit_ByUserId_ByCurrencyCode(userId, currencyCode, data) {
    const $ = new WalletAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.updateCredit_ByUserId_ByCurrencyCode(userId, currencyCode, data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function updatePayment_ByUserId_ByCurrencyCode(userId, currencyCode, data) {
    const $ = new WalletAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.updatePayment_ByUserId_ByCurrencyCode(userId, currencyCode, data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getTransactions_ByUserId_ByWalletId(userId, walletId, queryParams) {
    const $ = new WalletAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getTransactions_ByUserId_ByWalletId(userId, walletId, queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function createBalanceCheck_ByUserId_ByCurrencyCode(userId, currencyCode, data) {
    const $ = new WalletAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.createBalanceCheck_ByUserId_ByCurrencyCode(userId, currencyCode, data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function updateDebitWallet_ByUserId_ByCurrencyCode(userId, currencyCode, data) {
    const $ = new WalletAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.updateDebitWallet_ByUserId_ByCurrencyCode(userId, currencyCode, data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function updateDebitByWalletPlatform_ByUserId_ByCurrencyCode(userId, currencyCode, data) {
    const $ = new WalletAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.updateDebitByWalletPlatform_ByUserId_ByCurrencyCode(userId, currencyCode, data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getTransactionsWallets_ByUserId_ByCurrencyCode(userId, currencyCode, queryParams) {
    const $ = new WalletAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getTransactionsWallets_ByUserId_ByCurrencyCode(userId, currencyCode, queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  return {
    /**
     * @deprecated
     * Query wallets.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: paginated wallets info&lt;/li&gt;&lt;/ul&gt;
     */
    getWallets,
    /**
     * Debit different users&#39; wallets.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: bulk credit result&lt;/li&gt;&lt;/ul&gt;
     */
    createWalletDebit,
    /**
     * Credit different users&#39; wallets.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: bulk credit result&lt;/li&gt;&lt;/ul&gt;
     */
    createWalletCredit,
    /**
     * @deprecated
     * get a wallet by wallet id.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: wallet info&lt;/li&gt;&lt;/ul&gt;
     */
    getWallet_ByWalletId,
    /**
     * @deprecated
     * get a user wallet.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: wallet info&lt;/li&gt;&lt;/ul&gt;
     */
    getWallet_ByUserId_ByWalletId,
    /**
     * Get platform wallet config list.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: wallet info&lt;/li&gt;&lt;/ul&gt;
     */
    getWalletConfig_ByPlatform,
    /**
     * Update platform wallet config.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: platform wallet config&lt;/li&gt;&lt;/ul&gt;
     */
    updateWalletConfig_ByPlatform,
    /**
     * @deprecated
     * Debit a user wallet.
     */
    updateDebit_ByUserId_ByWalletId,
    /**
     * Reset platform wallet config to default config.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: platform wallet config&lt;/li&gt;&lt;/ul&gt;
     */
    updateWalletConfigReset_ByPlatform,
    /**
     * @deprecated
     * enable a user wallet.
     */
    updateEnable_ByUserId_ByWalletId,
    /**
     * @deprecated
     * disable a user wallet.
     */
    updateDisable_ByUserId_ByWalletId,
    /**
     * Get user currency wallet summary.&lt;br&gt;Other detail info: &lt;ul&gt;(READ)&lt;/li&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: currency wallet summary&lt;/li&gt;&lt;/ul&gt;
     */
    getWalletsCurrenciesSummary_ByUserId,
    /**
     * @deprecated
     * &lt;b&gt;[SERVICE COMMUNICATION ONLY]&lt;/b&gt; Check wallet by balance origin and currency code whether it&#39;s inactive.
     */
    getCheck_ByUserId_ByCurrencyCode,
    /**
     * Credit a user wallet by currency code and balance origin, if wallet not exists, it will create a new wallet.&lt;br&gt;Other detail info: &lt;ul&gt;(UPDATE)&lt;/li&gt;&lt;/ul&gt;
     */
    updateCredit_ByUserId_ByCurrencyCode,
    /**
     * Pay with user wallet by currency code and client platform.
     */
    updatePayment_ByUserId_ByCurrencyCode,
    /**
     * @deprecated
     * List user wallet transactions ordered by create time desc.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;/li&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: wallet transaction info&lt;/li&gt;&lt;/ul&gt;
     */
    getTransactions_ByUserId_ByWalletId,
    /**
     * Checks if the user has enough balance based on the provided criteria.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: boolean value indicating if the user has enough balance&lt;/li&gt;&lt;/ul&gt;
     */
    createBalanceCheck_ByUserId_ByCurrencyCode,
    /**
     * Debit a user wallet by currency code, default is debit system wallet.
     */
    updateDebitWallet_ByUserId_ByCurrencyCode,
    /**
     * Pay with user wallet by currency code and client platform.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;/ul&gt;&lt;h2&gt;Restrictions for metadata&lt;/h2&gt; 1. Cannot use &lt;b&gt;&#34;.&#34;&lt;/b&gt; as the key name - &lt;pre&gt;{ &#34;data.2&#34;: &#34;value&#34; }&lt;/pre&gt; 2. Cannot use &lt;b&gt;&#34;$&#34;&lt;/b&gt; as the prefix in key names - &lt;pre&gt;{ &#34;$data&#34;: &#34;value&#34; }&lt;/pre&gt;
     */
    updateDebitByWalletPlatform_ByUserId_ByCurrencyCode,
    /**
     * List user currency transactions ordered by create time desc.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;/li&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: currency transaction info&lt;/li&gt;&lt;/ul&gt;
     */
    getTransactionsWallets_ByUserId_ByCurrencyCode
  };
}

// src/generated-definitions/AppInfo.ts
import { z as z338 } from "zod";
var AppInfo = z338.object({
  announcement: z338.string().nullish(),
  carousel: z338.array(Slide).nullish(),
  developer: z338.string().nullish(),
  forumUrl: z338.string().nullish(),
  genres: z338.array(
    z338.enum([
      "Action",
      "Adventure",
      "Casual",
      "FreeToPlay",
      "Indie",
      "MassivelyMultiplayer",
      "RPG",
      "Racing",
      "Simulation",
      "Sports",
      "Strategy"
    ])
  ).nullish(),
  itemId: z338.string(),
  language: z338.string().nullish(),
  namespace: z338.string(),
  platformRequirements: z338.record(z338.array(Requirement)).nullish(),
  platforms: z338.array(z338.enum(["Android", "IOS", "Linux", "MacOS", "Windows"])).nullish(),
  players: z338.array(z338.enum(["Coop", "CrossPlatformMulti", "LocalCoop", "MMO", "Multi", "Single"])).nullish(),
  primaryGenre: z338.enum([
    "Action",
    "Adventure",
    "Casual",
    "FreeToPlay",
    "Indie",
    "MassivelyMultiplayer",
    "RPG",
    "Racing",
    "Simulation",
    "Sports",
    "Strategy"
  ]).nullish(),
  publisher: z338.string().nullish(),
  region: z338.string().nullish(),
  releaseDate: z338.string().nullish(),
  slogan: z338.string().nullish(),
  websiteUrl: z338.string().nullish()
});

// src/generated-definitions/AppleIapConfigVersionInfo.ts
import { z as z339 } from "zod";
var AppleIapConfigVersionInfo = z339.object({ version: z339.enum(["V1", "V2"]).nullish() });

// src/generated-definitions/BinarySchema.ts
import { z as z340 } from "zod";
var BinarySchema = z340.any();

// src/generated-definitions/CategoryInfo.ts
import { z as z341 } from "zod";
var CategoryInfo = z341.object({
  categoryPath: z341.string(),
  createdAt: z341.string(),
  displayName: z341.string(),
  namespace: z341.string(),
  parentCategoryPath: z341.string(),
  root: z341.boolean().nullish(),
  updatedAt: z341.string()
});

// src/generated-definitions/CategoryInfoArray.ts
import { z as z342 } from "zod";
var CategoryInfoArray = z342.array(CategoryInfo);

// src/generated-definitions/Customization.ts
import { z as z343 } from "zod";
var Customization = z343.object({ settings: z343.string().nullish() });

// src/generated-definitions/DlcConfigRewardShortInfo.ts
import { z as z344 } from "zod";
var DlcConfigRewardShortInfo = z344.object({
  data: z344.record(z344.array(z344.string())).nullish(),
  dlcType: z344.enum(["EPICGAMES", "OCULUS", "PSN", "STEAM", "XBOX"]).nullish()
});

// src/generated-definitions/EntitlementSplitResult.ts
import { z as z345 } from "zod";
var EntitlementSplitResult = z345.object({ source: EntitlementInfo.nullish(), target: EntitlementInfo.nullish() });

// src/generated-definitions/EntitlementTransferResult.ts
import { z as z346 } from "zod";
var EntitlementTransferResult = z346.object({ source: EntitlementInfo.nullish(), target: EntitlementInfo.nullish() });

// src/generated-definitions/EpicGamesReconcileResult.ts
import { z as z347 } from "zod";
var EpicGamesReconcileResult = z347.object({
  epicGamesItemId: z347.string().nullish(),
  itemId: z347.string().nullish(),
  sku: z347.string().nullish(),
  status: z347.enum(["FAILED", "FULFILLED", "VERIFIED"]).nullish(),
  transactionId: z347.string().nullish()
});

// src/generated-definitions/EpicGamesReconcileResultArray.ts
import { z as z348 } from "zod";
var EpicGamesReconcileResultArray = z348.array(EpicGamesReconcileResult);

// src/generated-definitions/EstimatedPriceInfoArray.ts
import { z as z349 } from "zod";
var EstimatedPriceInfoArray = z349.array(EstimatedPriceInfo);

// src/generated-definitions/GoogleReceiptResolveResult.ts
import { z as z350 } from "zod";
var GoogleReceiptResolveResult = z350.object({ needConsume: z350.boolean().nullish() });

// src/generated-definitions/HierarchicalCategoryInfo.ts
import { z as z351 } from "zod";
var HierarchicalCategoryInfo = z351.lazy(
  () => z351.object({
    categoryPath: z351.string(),
    childCategories: z351.array(HierarchicalCategoryInfo),
    createdAt: z351.string(),
    displayName: z351.string(),
    namespace: z351.string(),
    parentCategoryPath: z351.string(),
    root: z351.boolean().nullish(),
    updatedAt: z351.string()
  })
);

// src/generated-definitions/HierarchicalCategoryInfoArray.ts
import { z as z352 } from "zod";
var HierarchicalCategoryInfoArray = z352.array(HierarchicalCategoryInfo);

// src/generated-definitions/IapItemFlatEntry.ts
import { z as z353 } from "zod";
var IapItemFlatEntry = z353.object({
  itemIdentity: z353.string().nullish(),
  itemIdentityType: z353.enum(["ITEM_ID", "ITEM_SKU"]).nullish(),
  platform: z353.enum(["APPLE", "EPICGAMES", "GOOGLE", "OCULUS", "PLAYSTATION", "STADIA", "STEAM", "TWITCH", "XBOX"]).nullish(),
  platformProductId: z353.string().nullish()
});

// src/generated-definitions/IapItemMappingInfo.ts
import { z as z354 } from "zod";
var IapItemMappingInfo = z354.object({ data: z354.array(IapItemFlatEntry).nullish() });

// src/generated-definitions/ItemPagingSlicedResult.ts
import { z as z355 } from "zod";
var ItemPagingSlicedResult = z355.object({ data: z355.array(ItemInfo), paging: Paging.nullish() });

// src/generated-definitions/OculusReconcileResult.ts
import { z as z356 } from "zod";
var OculusReconcileResult = z356.object({
  iapOrderStatus: z356.enum(["FAILED", "FULFILLED", "VERIFIED"]).nullish(),
  itemIdentity: z356.string().nullish(),
  itemIdentityType: z356.enum(["ITEM_ID", "ITEM_SKU"]).nullish(),
  oculusItemSku: z356.string().nullish(),
  transactionId: z356.string().nullish()
});

// src/generated-definitions/OculusReconcileResultArray.ts
import { z as z357 } from "zod";
var OculusReconcileResultArray = z357.array(OculusReconcileResult);

// src/generated-definitions/OrderDiscountPreviewResponse.ts
import { z as z358 } from "zod";
var OrderDiscountPreviewResponse = z358.object({
  deduction: z358.number().int(),
  deductionDetails: z358.array(DeductionDetail).nullish(),
  discountedPrice: z358.number().int(),
  finalPrice: z358.number().int().nullish(),
  itemId: z358.string(),
  price: z358.number().int().nullish(),
  quantity: z358.number().int()
});

// src/generated-definitions/OwnershipToken.ts
import { z as z359 } from "zod";
var OwnershipToken = z359.object({ ownershipToken: z359.string().nullish() });

// src/generated-definitions/PaymentAccount.ts
import { z as z360 } from "zod";
var PaymentAccount = z360.object({ id: z360.string(), name: z360.string(), type: z360.enum(["card", "paypal"]) });

// src/generated-definitions/PaymentAccountArray.ts
import { z as z361 } from "zod";
var PaymentAccountArray = z361.array(PaymentAccount);

// src/generated-definitions/PaymentMethod.ts
import { z as z362 } from "zod";
var PaymentMethod = z362.object({
  name: z362.string(),
  paymentProvider: z362.enum(["ADYEN", "ALIPAY", "CHECKOUT", "NEONPAY", "PAYPAL", "STRIPE", "WALLET", "WXPAY", "XSOLLA"])
});

// src/generated-definitions/PaymentMethodArray.ts
import { z as z363 } from "zod";
var PaymentMethodArray = z363.array(PaymentMethod);

// src/generated-definitions/PaymentOrderDetails.ts
import { z as z364 } from "zod";
var PaymentOrderDetails = z364.object({
  charging: z364.boolean(),
  currencyCode: z364.string(),
  currencySymbol: z364.string(),
  description: z364.string().nullish(),
  displayName: z364.string().nullish(),
  price: z364.string(),
  region: z364.string().nullish(),
  sandbox: z364.boolean(),
  title: z364.string()
});

// src/generated-definitions/PaymentOrderPaidResult.ts
import { z as z365 } from "zod";
var PaymentOrderPaidResult = z365.object({ charging: z365.boolean(), success: z365.boolean() });

// src/generated-definitions/PaymentProcessResult.ts
import { z as z366 } from "zod";
var PaymentProcessResult = z366.object({
  pending: z366.boolean(),
  reason: z366.string().nullish(),
  redirectUrl: z366.string().nullish(),
  success: z366.boolean()
});

// src/generated-definitions/PaymentUrl.ts
import { z as z367 } from "zod";
var PaymentUrl = z367.object({
  paymentProvider: z367.enum(["ADYEN", "ALIPAY", "CHECKOUT", "NEONPAY", "PAYPAL", "STRIPE", "WALLET", "WXPAY", "XSOLLA"]),
  paymentType: z367.enum(["LINK", "QR_CODE"]),
  paymentUrl: z367.string().nullish(),
  returnUrl: z367.string().nullish(),
  sessionData: z367.string().nullish(),
  sessionId: z367.string().nullish()
});

// src/generated-definitions/PlayStationReconcileResult.ts
import { z as z368 } from "zod";
var PlayStationReconcileResult = z368.object({
  itemId: z368.string().nullish(),
  psnItemId: z368.string().nullish(),
  sku: z368.string().nullish(),
  status: z368.enum(["FAILED", "FULFILLED", "VERIFIED"]).nullish(),
  transactionId: z368.string().nullish()
});

// src/generated-definitions/PlayStationReconcileResultArray.ts
import { z as z369 } from "zod";
var PlayStationReconcileResultArray = z369.array(PlayStationReconcileResult);

// src/generated-definitions/PublicEntitlementHistoryInfo.ts
import { z as z370 } from "zod";
var PublicEntitlementHistoryInfo = z370.object({
  action: z370.enum(["DECREMENT", "DISABLE", "ENABLE", "GRANT", "REVOKE", "SELL_BACK", "UPDATE"]),
  clazz: z370.enum(["APP", "CODE", "ENTITLEMENT", "LOOTBOX", "MEDIA", "OPTIONBOX", "SUBSCRIPTION"]).nullish(),
  createdAt: z370.string(),
  entitlementId: z370.string(),
  itemId: z370.string().nullish(),
  namespace: z370.string(),
  origin: z370.enum(["Epic", "GooglePlay", "IOS", "Nintendo", "Oculus", "Other", "Playstation", "Steam", "System", "Twitch", "Xbox"]).nullish(),
  reason: z370.string().nullish(),
  sku: z370.string().nullish(),
  updatedAt: z370.string(),
  useCount: z370.number().int().nullish(),
  useCountChange: z370.number().int().nullish(),
  userId: z370.string()
});

// src/generated-definitions/SectionInfo.ts
import { z as z371 } from "zod";
var SectionInfo = z371.object({
  active: z371.boolean(),
  createdAt: z371.string(),
  currentRotationExpireAt: z371.string().nullish(),
  currentRotationItems: z371.array(ItemInfo).nullish(),
  description: z371.string().nullish(),
  displayOrder: z371.number().int().nullish(),
  endDate: z371.string(),
  ext: z371.record(z371.any()).nullish(),
  localExt: z371.record(z371.any()).nullish(),
  longDescription: z371.string().nullish(),
  name: z371.string(),
  namespace: z371.string(),
  sectionId: z371.string(),
  startDate: z371.string(),
  title: z371.string(),
  updatedAt: z371.string(),
  viewId: z371.string()
});

// src/generated-definitions/SectionInfoArray.ts
import { z as z372 } from "zod";
var SectionInfoArray = z372.array(SectionInfo);

// src/generated-definitions/SimpleDlcRewardItem.ts
import { z as z373 } from "zod";
var SimpleDlcRewardItem = z373.object({ itemName: z373.string().nullish() });

// src/generated-definitions/SimpleUserDlcRewardContent.ts
import { z as z374 } from "zod";
var SimpleUserDlcRewardContent = z374.object({
  currency: PlatformRewardCurrency.nullish(),
  item: SimpleDlcRewardItem.nullish(),
  obtainedAt: z374.string().nullish(),
  quantity: z374.number().int().nullish(),
  type: z374.enum(["CURRENCY", "ITEM"]).nullish()
});

// src/generated-definitions/SimpleUserDlcRewardContentsResponse.ts
import { z as z375 } from "zod";
var SimpleUserDlcRewardContentsResponse = z375.object({ data: z375.array(SimpleUserDlcRewardContent).nullish() });

// src/generated-definitions/TaxResult.ts
import { z as z376 } from "zod";
var TaxResult = z376.object({
  enableTax: z376.boolean().nullish(),
  formattedTax: z376.string().nullish(),
  state: z376.string().nullish(),
  tax: z376.number().int().nullish()
});

// src/generated-definitions/TwitchSyncResult.ts
import { z as z377 } from "zod";
var TwitchSyncResult = z377.object({
  iapOrderStatus: z377.enum(["FAILED", "FULFILLED", "VERIFIED"]).nullish(),
  itemSku: z377.string().nullish(),
  transactionId: z377.string().nullish()
});

// src/generated-definitions/TwitchSyncResultArray.ts
import { z as z378 } from "zod";
var TwitchSyncResultArray = z378.array(TwitchSyncResult);

// src/generated-definitions/UserEntitlementHistoryPagingSlicedResult.ts
import { z as z379 } from "zod";
var UserEntitlementHistoryPagingSlicedResult = z379.object({ data: z379.array(PublicEntitlementHistoryInfo), paging: Paging.nullish() });

// src/generated-definitions/UserEntitlementHistoryPagingSlicedResultArray.ts
import { z as z380 } from "zod";
var UserEntitlementHistoryPagingSlicedResultArray = z380.array(UserEntitlementHistoryPagingSlicedResult);

// src/generated-definitions/ViewInfo.ts
import { z as z381 } from "zod";
var ViewInfo = z381.object({
  createdAt: z381.string(),
  description: z381.string().nullish(),
  displayOrder: z381.number().int(),
  localExt: z381.record(z381.any()).nullish(),
  longDescription: z381.string().nullish(),
  name: z381.string(),
  namespace: z381.string(),
  title: z381.string(),
  updatedAt: z381.string(),
  viewId: z381.string()
});

// src/generated-definitions/ViewInfoArray.ts
import { z as z382 } from "zod";
var ViewInfoArray = z382.array(ViewInfo);

// src/generated-definitions/XblReconcileResult.ts
import { z as z383 } from "zod";
var XblReconcileResult = z383.object({
  iapOrderStatus: z383.enum(["FAILED", "FULFILLED", "VERIFIED"]).nullish(),
  itemId: z383.string().nullish(),
  sku: z383.string().nullish(),
  transactionId: z383.string().nullish(),
  xboxProductId: z383.string().nullish()
});

// src/generated-definitions/XblReconcileResultArray.ts
import { z as z384 } from "zod";
var XblReconcileResultArray = z384.array(XblReconcileResult);

// src/generated-public/endpoints/Category$.ts
import { Validate as Validate37 } from "@accelbyte/sdk";
var Category$ = class {
  // @ts-ignore
  // prettier-ignore
  constructor(axiosInstance, namespace, useSchemaValidation = true) {
    this.axiosInstance = axiosInstance;
    this.namespace = namespace;
    this.useSchemaValidation = useSchemaValidation;
  }
  /**
   * This API is used to get root categories.&lt;p&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Optional permission&lt;/i&gt;: resource=&#34;PREVIEW&#34;, action=1(CREATE) (user with this permission can view draft store category)&lt;/li&gt;&lt;li&gt;&lt;i&gt;Optional permission&lt;/i&gt;: resource=&#34;SANDBOX&#34;, action=1(CREATE) (user with this permission can view draft store category)&lt;/li&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: root category data&lt;/li&gt;&lt;/ul&gt;
   */
  getCategories(queryParams) {
    const params = { ...queryParams };
    const url = "/platform/public/namespaces/{namespace}/categories".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.get(url, { params });
    return Validate37.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, CategoryInfoArray, "CategoryInfoArray");
  }
  /**
   * This API is used to download store&#39;s structured categories.&lt;p&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Optional permission&lt;/i&gt;: resource=&#34;PREVIEW&#34;, action=1(CREATE) (user with this permission can view draft store content)&lt;/li&gt;&lt;li&gt;&lt;i&gt;Optional permission&lt;/i&gt;: resource=&#34;SANDBOX&#34;, action=1(CREATE) (user with this permission can view draft store content)&lt;/li&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: structured categories&lt;/li&gt;&lt;/ul&gt;
   */
  getCategoriesDownload(queryParams) {
    const params = { ...queryParams };
    const url = "/platform/public/namespaces/{namespace}/categories/download".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.get(url, { params });
    return Validate37.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      HierarchicalCategoryInfoArray,
      "HierarchicalCategoryInfoArray"
    );
  }
  /**
   * This API is used to get category by category path.&lt;p&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Optional permission&lt;/i&gt;: resource=&#34;PREVIEW&#34;, action=1(CREATE) (user with this permission can view draft store category)&lt;/li&gt;&lt;li&gt;&lt;i&gt;Optional permission&lt;/i&gt;: resource=&#34;SANDBOX&#34;, action=1 (CREATE)(user with this permission can view draft store category)&lt;/li&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: category data&lt;/li&gt;&lt;/ul&gt;
   */
  getCategory_ByCategoryPath(categoryPath, queryParams) {
    const params = { ...queryParams };
    const url = "/platform/public/namespaces/{namespace}/categories/{categoryPath}".replace("{namespace}", this.namespace).replace("{categoryPath}", categoryPath);
    const resultPromise = this.axiosInstance.get(url, { params });
    return Validate37.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, CategoryInfo, "CategoryInfo");
  }
  /**
   * This API is used to get child categories by category path.&lt;p&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Optional permission&lt;/i&gt;: resource=&#34;PREVIEW&#34;, action=1(CREATE) (user with this permission can view draft store category)&lt;/li&gt;&lt;li&gt;&lt;i&gt;Optional permission&lt;/i&gt;: resource=&#34;SANDBOX&#34;, action=1(CREATE) (user with this permission can view draft store category)&lt;/li&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: list of child categories data&lt;/li&gt;&lt;/ul&gt;
   */
  getChildren_ByCategoryPath(categoryPath, queryParams) {
    const params = { ...queryParams };
    const url = "/platform/public/namespaces/{namespace}/categories/{categoryPath}/children".replace("{namespace}", this.namespace).replace("{categoryPath}", categoryPath);
    const resultPromise = this.axiosInstance.get(url, { params });
    return Validate37.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, CategoryInfoArray, "CategoryInfoArray");
  }
  /**
   * This API is used to get descendant categories by category path.&lt;p&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Optional permission&lt;/i&gt;: resource=&#34;PREVIEW&#34;, action=1(CREATE) (user with this permission can view draft store category)&lt;/li&gt;&lt;li&gt;&lt;i&gt;Optional permission&lt;/i&gt;: resource=&#34;SANDBOX&#34;, action=1(CREATE) (user with this permission can view draft store category)&lt;/li&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: list of descendant categories data&lt;/li&gt;&lt;/ul&gt;
   */
  getDescendants_ByCategoryPath(categoryPath, queryParams) {
    const params = { ...queryParams };
    const url = "/platform/public/namespaces/{namespace}/categories/{categoryPath}/descendants".replace("{namespace}", this.namespace).replace("{categoryPath}", categoryPath);
    const resultPromise = this.axiosInstance.get(url, { params });
    return Validate37.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, CategoryInfoArray, "CategoryInfoArray");
  }
};

// src/generated-public/CategoryApi.ts
import { ApiUtils as ApiUtils37, Network as Network37 } from "@accelbyte/sdk";
function CategoryApi(sdk, args) {
  const sdkAssembly = sdk.assembly();
  const namespace = args?.coreConfig?.namespace ?? sdkAssembly.coreConfig.namespace;
  const useSchemaValidation = args?.coreConfig?.useSchemaValidation ?? sdkAssembly.coreConfig.useSchemaValidation;
  let axiosInstance = sdkAssembly.axiosInstance;
  const requestConfigOverrides = args?.axiosConfig?.request;
  const baseURLOverride = args?.coreConfig?.baseURL;
  const interceptorsOverride = args?.axiosConfig?.interceptors ?? [];
  if (requestConfigOverrides || baseURLOverride || interceptorsOverride.length > 0) {
    const requestConfig = ApiUtils37.mergeAxiosConfigs(sdkAssembly.axiosInstance.defaults, {
      ...baseURLOverride ? { baseURL: baseURLOverride } : {},
      ...requestConfigOverrides
    });
    axiosInstance = Network37.create(requestConfig);
    for (const interceptor of interceptorsOverride) {
      if (interceptor.type === "request") {
        axiosInstance.interceptors.request.use(interceptor.onRequest, interceptor.onError);
      }
      if (interceptor.type === "response") {
        axiosInstance.interceptors.response.use(interceptor.onSuccess, interceptor.onError);
      }
    }
  }
  async function getCategories(queryParams) {
    const $ = new Category$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getCategories(queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getCategoriesDownload(queryParams) {
    const $ = new Category$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getCategoriesDownload(queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getCategory_ByCategoryPath(categoryPath, queryParams) {
    const $ = new Category$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getCategory_ByCategoryPath(categoryPath, queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getChildren_ByCategoryPath(categoryPath, queryParams) {
    const $ = new Category$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getChildren_ByCategoryPath(categoryPath, queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getDescendants_ByCategoryPath(categoryPath, queryParams) {
    const $ = new Category$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getDescendants_ByCategoryPath(categoryPath, queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  return {
    /**
     * This API is used to get root categories.&lt;p&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Optional permission&lt;/i&gt;: resource=&#34;PREVIEW&#34;, action=1(CREATE) (user with this permission can view draft store category)&lt;/li&gt;&lt;li&gt;&lt;i&gt;Optional permission&lt;/i&gt;: resource=&#34;SANDBOX&#34;, action=1(CREATE) (user with this permission can view draft store category)&lt;/li&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: root category data&lt;/li&gt;&lt;/ul&gt;
     */
    getCategories,
    /**
     * This API is used to download store&#39;s structured categories.&lt;p&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Optional permission&lt;/i&gt;: resource=&#34;PREVIEW&#34;, action=1(CREATE) (user with this permission can view draft store content)&lt;/li&gt;&lt;li&gt;&lt;i&gt;Optional permission&lt;/i&gt;: resource=&#34;SANDBOX&#34;, action=1(CREATE) (user with this permission can view draft store content)&lt;/li&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: structured categories&lt;/li&gt;&lt;/ul&gt;
     */
    getCategoriesDownload,
    /**
     * This API is used to get category by category path.&lt;p&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Optional permission&lt;/i&gt;: resource=&#34;PREVIEW&#34;, action=1(CREATE) (user with this permission can view draft store category)&lt;/li&gt;&lt;li&gt;&lt;i&gt;Optional permission&lt;/i&gt;: resource=&#34;SANDBOX&#34;, action=1 (CREATE)(user with this permission can view draft store category)&lt;/li&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: category data&lt;/li&gt;&lt;/ul&gt;
     */
    getCategory_ByCategoryPath,
    /**
     * This API is used to get child categories by category path.&lt;p&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Optional permission&lt;/i&gt;: resource=&#34;PREVIEW&#34;, action=1(CREATE) (user with this permission can view draft store category)&lt;/li&gt;&lt;li&gt;&lt;i&gt;Optional permission&lt;/i&gt;: resource=&#34;SANDBOX&#34;, action=1(CREATE) (user with this permission can view draft store category)&lt;/li&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: list of child categories data&lt;/li&gt;&lt;/ul&gt;
     */
    getChildren_ByCategoryPath,
    /**
     * This API is used to get descendant categories by category path.&lt;p&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Optional permission&lt;/i&gt;: resource=&#34;PREVIEW&#34;, action=1(CREATE) (user with this permission can view draft store category)&lt;/li&gt;&lt;li&gt;&lt;i&gt;Optional permission&lt;/i&gt;: resource=&#34;SANDBOX&#34;, action=1(CREATE) (user with this permission can view draft store category)&lt;/li&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: list of descendant categories data&lt;/li&gt;&lt;/ul&gt;
     */
    getDescendants_ByCategoryPath
  };
}

// src/generated-public/endpoints/Currency$.ts
import { Validate as Validate38 } from "@accelbyte/sdk";
var Currency$ = class {
  // @ts-ignore
  // prettier-ignore
  constructor(axiosInstance, namespace, useSchemaValidation = true) {
    this.axiosInstance = axiosInstance;
    this.namespace = namespace;
    this.useSchemaValidation = useSchemaValidation;
  }
  /**
   * List currencies of a namespace.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: Currency List&lt;/li&gt;&lt;/ul&gt;
   */
  getCurrencies(queryParams) {
    const params = { ...queryParams };
    const url = "/platform/public/namespaces/{namespace}/currencies".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.get(url, { params });
    return Validate38.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, CurrencyInfoArray, "CurrencyInfoArray");
  }
};

// src/generated-public/CurrencyApi.ts
import { ApiUtils as ApiUtils38, Network as Network38 } from "@accelbyte/sdk";
function CurrencyApi(sdk, args) {
  const sdkAssembly = sdk.assembly();
  const namespace = args?.coreConfig?.namespace ?? sdkAssembly.coreConfig.namespace;
  const useSchemaValidation = args?.coreConfig?.useSchemaValidation ?? sdkAssembly.coreConfig.useSchemaValidation;
  let axiosInstance = sdkAssembly.axiosInstance;
  const requestConfigOverrides = args?.axiosConfig?.request;
  const baseURLOverride = args?.coreConfig?.baseURL;
  const interceptorsOverride = args?.axiosConfig?.interceptors ?? [];
  if (requestConfigOverrides || baseURLOverride || interceptorsOverride.length > 0) {
    const requestConfig = ApiUtils38.mergeAxiosConfigs(sdkAssembly.axiosInstance.defaults, {
      ...baseURLOverride ? { baseURL: baseURLOverride } : {},
      ...requestConfigOverrides
    });
    axiosInstance = Network38.create(requestConfig);
    for (const interceptor of interceptorsOverride) {
      if (interceptor.type === "request") {
        axiosInstance.interceptors.request.use(interceptor.onRequest, interceptor.onError);
      }
      if (interceptor.type === "response") {
        axiosInstance.interceptors.response.use(interceptor.onSuccess, interceptor.onError);
      }
    }
  }
  async function getCurrencies(queryParams) {
    const $ = new Currency$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getCurrencies(queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  return {
    /**
     * List currencies of a namespace.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: Currency List&lt;/li&gt;&lt;/ul&gt;
     */
    getCurrencies
  };
}

// src/generated-public/endpoints/Dlc$.ts
import { Validate as Validate39 } from "@accelbyte/sdk";
import { z as z385 } from "zod";
var Dlc$ = class {
  // @ts-ignore
  // prettier-ignore
  constructor(axiosInstance, namespace, useSchemaValidation = true) {
    this.axiosInstance = axiosInstance;
    this.namespace = namespace;
    this.useSchemaValidation = useSchemaValidation;
  }
  /**
   * Get user dlc reward contents. If includeAllNamespaces is false, will only return the dlc synced from the current namespace&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: user dlc&lt;/li&gt;&lt;/ul&gt;
   */
  getUsersMeDlcContent(queryParams) {
    const params = { ...queryParams };
    const url = "/platform/public/users/me/dlc/content";
    const resultPromise = this.axiosInstance.get(url, { params });
    return Validate39.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      SimpleUserDlcRewardContentsResponse,
      "SimpleUserDlcRewardContentsResponse"
    );
  }
  /**
   * Get dlc reward simple map, only return the sku of durable item reward.
   */
  getDlcRewardsDurableMap(queryParams) {
    const params = { ...queryParams };
    const url = "/platform/public/namespaces/{namespace}/dlc/rewards/durable/map".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.get(url, { params });
    return Validate39.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      DlcConfigRewardShortInfo,
      "DlcConfigRewardShortInfo"
    );
  }
  /**
   * Synchronize with dlc entitlements in PSN Store.Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: result of synchronization&lt;/li&gt;&lt;/ul&gt;
   */
  updateDlcPsnSync_ByUserId(userId, data) {
    const params = {};
    const url = "/platform/public/namespaces/{namespace}/users/{userId}/dlc/psn/sync".replace("{namespace}", this.namespace).replace("{userId}", userId);
    const resultPromise = this.axiosInstance.put(url, data, { params });
    return Validate39.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, z385.unknown(), "z.unknown()");
  }
  /**
   * Sync Xbox inventory&#39;s dlc items
   */
  updateDlcXblSync_ByUserId(userId, data) {
    const params = {};
    const url = "/platform/public/namespaces/{namespace}/users/{userId}/dlc/xbl/sync".replace("{namespace}", this.namespace).replace("{userId}", userId);
    const resultPromise = this.axiosInstance.put(url, data, { params });
    return Validate39.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, z385.unknown(), "z.unknown()");
  }
  /**
   * Sync steam dlc
   */
  updateDlcSteamSync_ByUserId(userId, data) {
    const params = {};
    const url = "/platform/public/namespaces/{namespace}/users/{userId}/dlc/steam/sync".replace("{namespace}", this.namespace).replace("{userId}", userId);
    const resultPromise = this.axiosInstance.put(url, data, { params });
    return Validate39.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, z385.unknown(), "z.unknown()");
  }
  /**
   * Sync oculus dlc
   */
  updateDlcOculuSync_ByUserId(userId) {
    const params = {};
    const url = "/platform/public/namespaces/{namespace}/users/{userId}/dlc/oculus/sync".replace("{namespace}", this.namespace).replace("{userId}", userId);
    const resultPromise = this.axiosInstance.put(url, null, { params });
    return Validate39.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, z385.unknown(), "z.unknown()");
  }
  /**
   * Sync epic games dlc items
   */
  updateDlcEpicgameSync_ByUserId(userId, data) {
    const params = {};
    const url = "/platform/public/namespaces/{namespace}/users/{userId}/dlc/epicgames/sync".replace("{namespace}", this.namespace).replace("{userId}", userId);
    const resultPromise = this.axiosInstance.put(url, data, { params });
    return Validate39.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, z385.unknown(), "z.unknown()");
  }
  /**
   * Synchronize with dlc entitlements in PSN Store with multiple service labels.Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: result of synchronization&lt;/li&gt;&lt;/ul&gt;
   */
  updateDlcPsnSyncMultiServiceLabel_ByUserId(userId, data) {
    const params = {};
    const url = "/platform/public/namespaces/{namespace}/users/{userId}/dlc/psn/sync/multiServiceLabels".replace("{namespace}", this.namespace).replace("{userId}", userId);
    const resultPromise = this.axiosInstance.put(url, data, { params });
    return Validate39.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, z385.unknown(), "z.unknown()");
  }
};

// src/generated-public/DlcApi.ts
import { ApiUtils as ApiUtils39, Network as Network39 } from "@accelbyte/sdk";
function DlcApi(sdk, args) {
  const sdkAssembly = sdk.assembly();
  const namespace = args?.coreConfig?.namespace ?? sdkAssembly.coreConfig.namespace;
  const useSchemaValidation = args?.coreConfig?.useSchemaValidation ?? sdkAssembly.coreConfig.useSchemaValidation;
  let axiosInstance = sdkAssembly.axiosInstance;
  const requestConfigOverrides = args?.axiosConfig?.request;
  const baseURLOverride = args?.coreConfig?.baseURL;
  const interceptorsOverride = args?.axiosConfig?.interceptors ?? [];
  if (requestConfigOverrides || baseURLOverride || interceptorsOverride.length > 0) {
    const requestConfig = ApiUtils39.mergeAxiosConfigs(sdkAssembly.axiosInstance.defaults, {
      ...baseURLOverride ? { baseURL: baseURLOverride } : {},
      ...requestConfigOverrides
    });
    axiosInstance = Network39.create(requestConfig);
    for (const interceptor of interceptorsOverride) {
      if (interceptor.type === "request") {
        axiosInstance.interceptors.request.use(interceptor.onRequest, interceptor.onError);
      }
      if (interceptor.type === "response") {
        axiosInstance.interceptors.response.use(interceptor.onSuccess, interceptor.onError);
      }
    }
  }
  async function getUsersMeDlcContent(queryParams) {
    const $ = new Dlc$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getUsersMeDlcContent(queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getDlcRewardsDurableMap(queryParams) {
    const $ = new Dlc$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getDlcRewardsDurableMap(queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function updateDlcPsnSync_ByUserId(userId, data) {
    const $ = new Dlc$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.updateDlcPsnSync_ByUserId(userId, data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function updateDlcXblSync_ByUserId(userId, data) {
    const $ = new Dlc$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.updateDlcXblSync_ByUserId(userId, data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function updateDlcSteamSync_ByUserId(userId, data) {
    const $ = new Dlc$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.updateDlcSteamSync_ByUserId(userId, data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function updateDlcOculuSync_ByUserId(userId) {
    const $ = new Dlc$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.updateDlcOculuSync_ByUserId(userId);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function updateDlcEpicgameSync_ByUserId(userId, data) {
    const $ = new Dlc$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.updateDlcEpicgameSync_ByUserId(userId, data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function updateDlcPsnSyncMultiServiceLabel_ByUserId(userId, data) {
    const $ = new Dlc$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.updateDlcPsnSyncMultiServiceLabel_ByUserId(userId, data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  return {
    /**
     * Get user dlc reward contents. If includeAllNamespaces is false, will only return the dlc synced from the current namespace&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: user dlc&lt;/li&gt;&lt;/ul&gt;
     */
    getUsersMeDlcContent,
    /**
     * Get dlc reward simple map, only return the sku of durable item reward.
     */
    getDlcRewardsDurableMap,
    /**
     * Synchronize with dlc entitlements in PSN Store.Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: result of synchronization&lt;/li&gt;&lt;/ul&gt;
     */
    updateDlcPsnSync_ByUserId,
    /**
     * Sync Xbox inventory&#39;s dlc items
     */
    updateDlcXblSync_ByUserId,
    /**
     * Sync steam dlc
     */
    updateDlcSteamSync_ByUserId,
    /**
     * Sync oculus dlc
     */
    updateDlcOculuSync_ByUserId,
    /**
     * Sync epic games dlc items
     */
    updateDlcEpicgameSync_ByUserId,
    /**
     * Synchronize with dlc entitlements in PSN Store with multiple service labels.Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: result of synchronization&lt;/li&gt;&lt;/ul&gt;
     */
    updateDlcPsnSyncMultiServiceLabel_ByUserId
  };
}

// src/generated-public/endpoints/Entitlement$.ts
import { Validate as Validate40 } from "@accelbyte/sdk";
var Entitlement$ = class {
  // @ts-ignore
  // prettier-ignore
  constructor(axiosInstance, namespace, useSchemaValidation = true) {
    this.axiosInstance = axiosInstance;
    this.namespace = namespace;
    this.useSchemaValidation = useSchemaValidation;
  }
  /**
   * Query user entitlements for a specific user.&lt;p&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: entitlement list&lt;/li&gt;&lt;/ul&gt;
   */
  getEntitlements_ByUserId(userId, queryParams) {
    const params = { limit: 20, ...queryParams };
    const url = "/platform/public/namespaces/{namespace}/users/{userId}/entitlements".replace("{namespace}", this.namespace).replace("{userId}", userId);
    const resultPromise = this.axiosInstance.get(url, { params });
    return Validate40.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      EntitlementPagingSlicedResult,
      "EntitlementPagingSlicedResult"
    );
  }
  /**
   * Get user entitlements by ids..&lt;p&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: entitlement list&lt;/li&gt;&lt;/ul&gt;
   */
  getEntitlementsByIds_ByUserId(userId, queryParams) {
    const params = { availablePlatformOnly: true, ...queryParams };
    const url = "/platform/public/namespaces/{namespace}/users/{userId}/entitlements/byIds".replace("{namespace}", this.namespace).replace("{userId}", userId);
    const resultPromise = this.axiosInstance.get(url, { params });
    return Validate40.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, EntitlementInfoArray, "EntitlementInfoArray");
  }
  /**
   * @deprecated
   * Get user entitlement by sku.
   */
  getEntitlementsBySku_ByUserId(userId, queryParams) {
    const params = { ...queryParams };
    const url = "/platform/public/namespaces/{namespace}/users/{userId}/entitlements/bySku".replace("{namespace}", this.namespace).replace("{userId}", userId);
    const resultPromise = this.axiosInstance.get(url, { params });
    return Validate40.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, EntitlementInfo, "EntitlementInfo");
  }
  /**
   * Get user app entitlement by appId.
   */
  getEntitlementsByAppId_ByUserId(userId, queryParams) {
    const params = { ...queryParams };
    const url = "/platform/public/namespaces/{namespace}/users/{userId}/entitlements/byAppId".replace("{namespace}", this.namespace).replace("{userId}", userId);
    const resultPromise = this.axiosInstance.get(url, { params });
    return Validate40.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, AppEntitlementInfo, "AppEntitlementInfo");
  }
  /**
   * Get user entitlement history&lt;p&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: user entitlement history list&lt;/li&gt;&lt;/ul&gt;
   */
  getEntitlementsHistory_ByUserId(userId, queryParams) {
    const params = { limit: 20, ...queryParams };
    const url = "/platform/public/namespaces/{namespace}/users/{userId}/entitlements/history".replace("{namespace}", this.namespace).replace("{userId}", userId);
    const resultPromise = this.axiosInstance.get(url, { params });
    return Validate40.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      UserEntitlementHistoryPagingSlicedResultArray,
      "UserEntitlementHistoryPagingSlicedResultArray"
    );
  }
  /**
   * Exists any my active entitlement of specified itemIds, skus and appIds
   */
  getUsersMeEntitlementsOwnershipAny(queryParams) {
    const params = { ...queryParams };
    const url = "/platform/public/namespaces/{namespace}/users/me/entitlements/ownership/any".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.get(url, { params });
    return Validate40.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, Ownership, "Ownership");
  }
  /**
   * @deprecated
   * Get user entitlement by itemId.
   */
  getEntitlementsByItemId_ByUserId(userId, queryParams) {
    const params = { ...queryParams };
    const url = "/platform/public/namespaces/{namespace}/users/{userId}/entitlements/byItemId".replace("{namespace}", this.namespace).replace("{userId}", userId);
    const resultPromise = this.axiosInstance.get(url, { params });
    return Validate40.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, EntitlementInfo, "EntitlementInfo");
  }
  /**
   * Gets an entitlement ownership token of specified itemIds, skus and appIds&lt;p&gt;The decoded ownership token header like below:&lt;p&gt;&lt;pre&gt;&lt;code&gt;{ &#34;kid&#34;: &#34;9fd4cd5f991cebe3323605cd12d3b8bfdfc73fa4&#34;, &#34;typ&#34;: &#34;JWT&#34;, &#34;alg&#34;: &#34;RS256&#34; } &lt;/code&gt;&lt;/pre&gt;That you can get the jwks by api &lt;baseUrl&gt;/platform/jwks, if the configured private key is same as IAM, &lt;p&gt;you can also get jwks from IAM endpoint. &lt;p&gt;The decoded ownership token payload like below:&lt;p&gt;&lt;pre&gt;&lt;code&gt;{ &#34;namespace&#34;: &#34;accelbyte&#34;, &#34;entitlements&#34;: [ { &#34;itemId&#34;: &#34;4c1296291f604c199f7bb7f0ee02e5f8&#34;, &#34;appType&#34;: null, &#34;appId&#34;: null, &#34;namespace&#34;: &#34;accelbyte&#34;, &#34;itemNamespace&#34;: &#34;accelbyte&#34;, &#34;sku&#34;: &#34;prime-plus&#34; }, { &#34;itemId&#34;: &#34;e8f4974cf45c4e1f8d4f0c6990c518bd&#34;, &#34;appType&#34;: &#34;GAME&#34;, &#34;appId&#34;: &#34;omeganebula&#34;, &#34;namespace&#34;: &#34;accelbyte&#34;, &#34;itemNamespace&#34;: &#34;accelbyte&#34;, &#34;sku&#34;: &#34;APPG005ON&#34; } ], &#34;sub&#34;: &#34;66459eb6a4e44e6fb0040bd20c1079a5&#34;, &#34;exp&#34;: 1619624360, &#34;iat&#34;: 1619624060 } &lt;/code&gt;&lt;/pre&gt;&lt;b&gt;if there&#39;s no active entitlement for the specific params, the entitlements section will be omitted&lt;/b&gt;.
   */
  getUsersMeEntitlementsOwnershipToken(queryParams) {
    const params = { ...queryParams };
    const url = "/platform/public/namespaces/{namespace}/users/me/entitlements/ownershipToken".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.get(url, { params });
    return Validate40.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, OwnershipToken, "OwnershipToken");
  }
  /**
   * Query app entitlements by appType.&lt;p&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: app entitlement pagination&lt;/li&gt;&lt;/ul&gt;
   */
  getEntitlementsByAppType_ByUserId(userId, queryParams) {
    const params = { limit: 20, ...queryParams };
    const url = "/platform/public/namespaces/{namespace}/users/{userId}/entitlements/byAppType".replace("{namespace}", this.namespace).replace("{userId}", userId);
    const resultPromise = this.axiosInstance.get(url, { params });
    return Validate40.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      AppEntitlementPagingSlicedResult,
      "AppEntitlementPagingSlicedResult"
    );
  }
  /**
   * Get my entitlement ownership by sku.&lt;p&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Path&#39;s namespace&lt;/i&gt; : &lt;ul&gt;&lt;li&gt;can be filled with &lt;b&gt;publisher namespace&lt;/b&gt; in order to get &lt;b&gt;publisher namespace entitlement ownership by sku&lt;/b&gt;&lt;/li&gt;&lt;li&gt;can be filled with &lt;b&gt;game namespace&lt;/b&gt; in order to get &lt;b&gt;game namespace entitlement ownership by sku&lt;/b&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;/ul&gt;
   */
  getUsersMeEntitlementsOwnershipBySku(queryParams) {
    const params = { ...queryParams };
    const url = "/platform/public/namespaces/{namespace}/users/me/entitlements/ownership/bySku".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.get(url, { params });
    return Validate40.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, TimedOwnership, "TimedOwnership");
  }
  /**
   * Get my app entitlement ownership by appId.&lt;p&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Path&#39;s namespace&lt;/i&gt; : &lt;ul&gt;&lt;li&gt;can be filled with &lt;b&gt;publisher namespace&lt;/b&gt; in order to get &lt;b&gt;publisher namespace app entitlement ownership&lt;/b&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;/ul&gt;
   */
  getUsersMeEntitlementsOwnershipByAppId(queryParams) {
    const params = { ...queryParams };
    const url = "/platform/public/namespaces/{namespace}/users/me/entitlements/ownership/byAppId".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.get(url, { params });
    return Validate40.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, Ownership, "Ownership");
  }
  /**
   * Get my entitlement ownership by itemId.&lt;p&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Path&#39;s namespace&lt;/i&gt; : &lt;ul&gt;&lt;li&gt;can be filled with &lt;b&gt;publisher namespace&lt;/b&gt; in order to get &lt;b&gt;publisher namespace entitlement ownership by sku&lt;/b&gt;&lt;/li&gt;&lt;li&gt;can be filled with &lt;b&gt;game namespace&lt;/b&gt; in order to get &lt;b&gt;game namespace entitlement ownership by sku&lt;/b&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;/ul&gt;
   */
  getUsersMeEntitlementsOwnershipByItemId(queryParams) {
    const params = { ...queryParams };
    const url = "/platform/public/namespaces/{namespace}/users/me/entitlements/ownership/byItemId".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.get(url, { params });
    return Validate40.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, TimedOwnership, "TimedOwnership");
  }
  /**
   * Exists any user active entitlement of specified itemIds, skus and appIds
   */
  getEntitlementsOwnershipAny_ByUserId(userId, queryParams) {
    const params = { ...queryParams };
    const url = "/platform/public/namespaces/{namespace}/users/{userId}/entitlements/ownership/any".replace("{namespace}", this.namespace).replace("{userId}", userId);
    const resultPromise = this.axiosInstance.get(url, { params });
    return Validate40.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, Ownership, "Ownership");
  }
  /**
   * Get user entitlement.&lt;p&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: entitlement&lt;/li&gt;&lt;/ul&gt;
   */
  getEntitlement_ByUserId_ByEntitlementId(userId, entitlementId) {
    const params = {};
    const url = "/platform/public/namespaces/{namespace}/users/{userId}/entitlements/{entitlementId}".replace("{namespace}", this.namespace).replace("{userId}", userId).replace("{entitlementId}", entitlementId);
    const resultPromise = this.axiosInstance.get(url, { params });
    return Validate40.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, EntitlementInfo, "EntitlementInfo");
  }
  /**
   * Get user entitlement ownership by sku.
   */
  getEntitlementsOwnershipBySku_ByUserId(userId, queryParams) {
    const params = { ...queryParams };
    const url = "/platform/public/namespaces/{namespace}/users/{userId}/entitlements/ownership/bySku".replace("{namespace}", this.namespace).replace("{userId}", userId);
    const resultPromise = this.axiosInstance.get(url, { params });
    return Validate40.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, TimedOwnership, "TimedOwnership");
  }
  /**
   * Get user app entitlement ownership by appId.
   */
  getEntitlementsOwnershipByAppId_ByUserId(userId, queryParams) {
    const params = { ...queryParams };
    const url = "/platform/public/namespaces/{namespace}/users/{userId}/entitlements/ownership/byAppId".replace("{namespace}", this.namespace).replace("{userId}", userId);
    const resultPromise = this.axiosInstance.get(url, { params });
    return Validate40.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, Ownership, "Ownership");
  }
  /**
   * Get user entitlement ownership by itemId.
   */
  getEntitlementsOwnershipByItemId_ByUserId(userId, queryParams) {
    const params = { ...queryParams };
    const url = "/platform/public/namespaces/{namespace}/users/{userId}/entitlements/ownership/byItemId".replace("{namespace}", this.namespace).replace("{userId}", userId);
    const resultPromise = this.axiosInstance.get(url, { params });
    return Validate40.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, TimedOwnership, "TimedOwnership");
  }
  /**
   * Get user entitlement ownership by itemIds.
   */
  getEntitlementsOwnershipByItemIds_ByUserId(userId, queryParams) {
    const params = { ...queryParams };
    const url = "/platform/public/namespaces/{namespace}/users/{userId}/entitlements/ownership/byItemIds".replace("{namespace}", this.namespace).replace("{userId}", userId);
    const resultPromise = this.axiosInstance.get(url, { params });
    return Validate40.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      EntitlementOwnershipArray,
      "EntitlementOwnershipArray"
    );
  }
  /**
   * Sell user entitlement. If the entitlement is consumable, useCount is 0, the status will be CONSUMED. If the entitlement is durable, the status will be SOLD. Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: entitlement&lt;/li&gt;&lt;/ul&gt;
   */
  updateSell_ByUserId_ByEntitlementId(userId, entitlementId, data) {
    const params = {};
    const url = "/platform/public/namespaces/{namespace}/users/{userId}/entitlements/{entitlementId}/sell".replace("{namespace}", this.namespace).replace("{userId}", userId).replace("{entitlementId}", entitlementId);
    const resultPromise = this.axiosInstance.put(url, data, { params });
    return Validate40.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, EntitlementSoldResult, "EntitlementSoldResult");
  }
  /**
   * Split a specified use count of entitlement and create a new entitlement with splitting use count.Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: entitlement&lt;/li&gt;&lt;/ul&gt;
   */
  updateSplit_ByUserId_ByEntitlementId(userId, entitlementId, data) {
    const params = {};
    const url = "/platform/public/namespaces/{namespace}/users/{userId}/entitlements/{entitlementId}/split".replace("{namespace}", this.namespace).replace("{userId}", userId).replace("{entitlementId}", entitlementId);
    const resultPromise = this.axiosInstance.put(url, data, { params });
    return Validate40.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      EntitlementSplitResult,
      "EntitlementSplitResult"
    );
  }
  /**
   * Transfer a specified use count from entitlement A to B..Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: entitlement&lt;/li&gt;&lt;/ul&gt;
   */
  updateTransfer_ByUserId_ByEntitlementId(userId, entitlementId, data) {
    const params = {};
    const url = "/platform/public/namespaces/{namespace}/users/{userId}/entitlements/{entitlementId}/transfer".replace("{namespace}", this.namespace).replace("{userId}", userId).replace("{entitlementId}", entitlementId);
    const resultPromise = this.axiosInstance.put(url, data, { params });
    return Validate40.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      EntitlementTransferResult,
      "EntitlementTransferResult"
    );
  }
  /**
   * Consume user entitlement. If the entitlement useCount is 0, the status will be CONSUMED. Client should pass item id in options if entitlement clazz is OPTIONBOX&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: consumed entitlement&lt;/li&gt;&lt;/ul&gt;
   */
  updateDecrement_ByUserId_ByEntitlementId(userId, entitlementId, data) {
    const params = {};
    const url = "/platform/public/namespaces/{namespace}/users/{userId}/entitlements/{entitlementId}/decrement".replace("{namespace}", this.namespace).replace("{userId}", userId).replace("{entitlementId}", entitlementId);
    const resultPromise = this.axiosInstance.put(url, data, { params });
    return Validate40.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      EntitlementDecrementResult,
      "EntitlementDecrementResult"
    );
  }
};

// src/generated-public/endpoints/Fulfillment$.ts
import { Validate as Validate41 } from "@accelbyte/sdk";
var Fulfillment$ = class {
  // @ts-ignore
  // prettier-ignore
  constructor(axiosInstance, namespace, useSchemaValidation = true) {
    this.axiosInstance = axiosInstance;
    this.namespace = namespace;
    this.useSchemaValidation = useSchemaValidation;
  }
  /**
   * Redeem campaign code, this api have rate limit, default: only allow request once per user in 2 seconds&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: fulfillment result&lt;/li&gt;&lt;/ul&gt;
   */
  createFulfillmentCode_ByUserId(userId, data) {
    const params = {};
    const url = "/platform/public/namespaces/{namespace}/users/{userId}/fulfillment/code".replace("{namespace}", this.namespace).replace("{userId}", userId);
    const resultPromise = this.axiosInstance.post(url, data, { params });
    return Validate41.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, FulfillmentResult, "FulfillmentResult");
  }
};

// src/generated-public/endpoints/Iap$.ts
import { Validate as Validate42 } from "@accelbyte/sdk";
import { z as z386 } from "zod";
var Iap$ = class {
  // @ts-ignore
  // prettier-ignore
  constructor(axiosInstance, namespace, useSchemaValidation = true) {
    this.axiosInstance = axiosInstance;
    this.namespace = namespace;
    this.useSchemaValidation = useSchemaValidation;
  }
  /**
   * Get iap item mapping.
   */
  getIapItemMapping(queryParams) {
    const params = { ...queryParams };
    const url = "/platform/public/namespaces/{namespace}/iap/item/mapping".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.get(url, { params });
    return Validate42.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, IapItemMappingInfo, "IapItemMappingInfo");
  }
  /**
   * Get apple config version.
   */
  getIapAppleConfigVersion() {
    const params = {};
    const url = "/platform/public/namespaces/{namespace}/iap/apple/config/version".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.get(url, { params });
    return Validate42.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      AppleIapConfigVersionInfo,
      "AppleIapConfigVersionInfo"
    );
  }
  /**
   * Sync my game twitch drops entitlements.
   */
  updateUserMeIapTwitchSync(data) {
    const params = {};
    const url = "/platform/public/namespaces/{namespace}/users/me/iap/twitch/sync".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.put(url, data, { params });
    return Validate42.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, TwitchSyncResultArray, "TwitchSyncResultArray");
  }
  /**
   * Synchronize with entitlements in PSN Store.Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: result of synchronization&lt;/li&gt;&lt;/ul&gt;
   */
  updateIapPsnSync_ByUserId(userId, data) {
    const params = {};
    const url = "/platform/public/namespaces/{namespace}/users/{userId}/iap/psn/sync".replace("{namespace}", this.namespace).replace("{userId}", userId);
    const resultPromise = this.axiosInstance.put(url, data, { params });
    return Validate42.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      PlayStationReconcileResultArray,
      "PlayStationReconcileResultArray"
    );
  }
  /**
   * Sync Xbox inventory&#39;s items.Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: &lt;/li&gt;&lt;/ul&gt;
   */
  updateIapXblSync_ByUserId(userId, data) {
    const params = {};
    const url = "/platform/public/namespaces/{namespace}/users/{userId}/iap/xbl/sync".replace("{namespace}", this.namespace).replace("{userId}", userId);
    const resultPromise = this.axiosInstance.put(url, data, { params });
    return Validate42.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      XblReconcileResultArray,
      "XblReconcileResultArray"
    );
  }
  /**
   * Sync steam inventory&#39;s items.Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: &lt;/li&gt;&lt;/ul&gt;
   */
  updateIapSteamSync_ByUserId(userId, data) {
    const params = {};
    const url = "/platform/public/namespaces/{namespace}/users/{userId}/iap/steam/sync".replace("{namespace}", this.namespace).replace("{userId}", userId);
    const resultPromise = this.axiosInstance.put(url, data, { params });
    return Validate42.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, z386.unknown(), "z.unknown()");
  }
  /**
   * Sync Oculus entitlements.Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: &lt;/li&gt;&lt;/ul&gt;
   */
  updateIapOculuSync_ByUserId(userId) {
    const params = {};
    const url = "/platform/public/namespaces/{namespace}/users/{userId}/iap/oculus/sync".replace("{namespace}", this.namespace).replace("{userId}", userId);
    const resultPromise = this.axiosInstance.put(url, null, { params });
    return Validate42.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      OculusReconcileResultArray,
      "OculusReconcileResultArray"
    );
  }
  /**
   * Sync twitch drops entitlements.Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: &lt;/li&gt;&lt;/ul&gt;
   */
  updateIapTwitchSync_ByUserId(userId, data) {
    const params = {};
    const url = "/platform/public/namespaces/{namespace}/users/{userId}/iap/twitch/sync".replace("{namespace}", this.namespace).replace("{userId}", userId);
    const resultPromise = this.axiosInstance.put(url, data, { params });
    return Validate42.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, z386.unknown(), "z.unknown()");
  }
  /**
   * Verify apple iap receipt and fulfill item. don&#39;t support subscriptionOther detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: &lt;/li&gt;&lt;/ul&gt;
   */
  updateIapAppleReceipt_ByUserId(userId, data) {
    const params = {};
    const url = "/platform/public/namespaces/{namespace}/users/{userId}/iap/apple/receipt".replace("{namespace}", this.namespace).replace("{userId}", userId);
    const resultPromise = this.axiosInstance.put(url, data, { params });
    return Validate42.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, z386.unknown(), "z.unknown()");
  }
  /**
   * Sync epic games inventory&#39;s items.Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: &lt;/li&gt;&lt;/ul&gt;
   */
  updateIapEpicgameSync_ByUserId(userId, data) {
    const params = {};
    const url = "/platform/public/namespaces/{namespace}/users/{userId}/iap/epicgames/sync".replace("{namespace}", this.namespace).replace("{userId}", userId);
    const resultPromise = this.axiosInstance.put(url, data, { params });
    return Validate42.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      EpicGamesReconcileResultArray,
      "EpicGamesReconcileResultArray"
    );
  }
  /**
   * Verify google iap receipt and fulfill item.Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: &lt;/li&gt;&lt;/ul&gt;
   */
  updateIapGoogleReceipt_ByUserId(userId, data) {
    const params = {};
    const url = "/platform/public/namespaces/{namespace}/users/{userId}/iap/google/receipt".replace("{namespace}", this.namespace).replace("{userId}", userId);
    const resultPromise = this.axiosInstance.put(url, data, { params });
    return Validate42.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      GoogleReceiptResolveResult,
      "GoogleReceiptResolveResult"
    );
  }
  /**
   * Verify apple iap transaction and fulfill item, support subscriptionOther detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: &lt;/li&gt;&lt;/ul&gt;
   */
  updateIapAppleReceipt_ByUserId_v2(userId, data) {
    const params = {};
    const url = "/platform/v2/public/namespaces/{namespace}/users/{userId}/iap/apple/receipt".replace("{namespace}", this.namespace).replace("{userId}", userId);
    const resultPromise = this.axiosInstance.put(url, data, { params });
    return Validate42.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, z386.unknown(), "z.unknown()");
  }
  /**
   * Synchronize with entitlements in PSN Store with multiple service labels.Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: result of synchronization&lt;/li&gt;&lt;/ul&gt;
   */
  updateIapPsnSyncMultiServiceLabel_ByUserId(userId, data) {
    const params = {};
    const url = "/platform/public/namespaces/{namespace}/users/{userId}/iap/psn/sync/multiServiceLabels".replace("{namespace}", this.namespace).replace("{userId}", userId);
    const resultPromise = this.axiosInstance.put(url, data, { params });
    return Validate42.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      PlayStationReconcileResultArray,
      "PlayStationReconcileResultArray"
    );
  }
};

// src/generated-public/endpoints/IapSubscription$.ts
import { Validate as Validate43 } from "@accelbyte/sdk";
var IapSubscription$ = class {
  // @ts-ignore
  // prettier-ignore
  constructor(axiosInstance, namespace, useSchemaValidation = true) {
    this.axiosInstance = axiosInstance;
    this.namespace = namespace;
    this.useSchemaValidation = useSchemaValidation;
  }
  /**
   * Query user subscription, default sort by updatedAtOther detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: &lt;/li&gt;&lt;/ul&gt;
   */
  getIapSubscriptionPlatform_ByUserId_ByPlatform(userId, platform, queryParams) {
    const params = { limit: 20, ...queryParams };
    const url = "/platform/public/namespaces/{namespace}/users/{userId}/iap/subscriptions/platforms/{platform}".replace("{namespace}", this.namespace).replace("{userId}", userId).replace("{platform}", platform);
    const resultPromise = this.axiosInstance.get(url, { params });
    return Validate43.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      ThirdPartyUserSubscriptionPagingSlicedResult,
      "ThirdPartyUserSubscriptionPagingSlicedResult"
    );
  }
};

// src/generated-public/endpoints/Item$.ts
import { Validate as Validate44 } from "@accelbyte/sdk";
var Item$ = class {
  // @ts-ignore
  // prettier-ignore
  constructor(axiosInstance, namespace, useSchemaValidation = true) {
    this.axiosInstance = axiosInstance;
    this.namespace = namespace;
    this.useSchemaValidation = useSchemaValidation;
  }
  /**
   * This API is used to get the item by sku.&lt;p&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Optional permission&lt;/i&gt;: resource=&#34;PREVIEW&#34;, action=1(CREATE) (user with this permission can view draft store item)&lt;/li&gt;&lt;li&gt;&lt;i&gt;Optional permission&lt;/i&gt;: resource=&#34;SANDBOX&#34;, action=1(CREATE) (user with this permission can view draft store item)&lt;/li&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: the item with sku&lt;/li&gt;&lt;/ul&gt;
   */
  getItemsBySku(queryParams) {
    const params = { ...queryParams };
    const url = "/platform/public/namespaces/{namespace}/items/bySku".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.get(url, { params });
    return Validate44.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, ItemInfo, "ItemInfo");
  }
  /**
   * This API is used to search items by keyword in title, description and long description, It&#39;s language constrained, also if item not exist in specific region, default region item will return.&lt;p&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Optional permission&lt;/i&gt;: resource=&#34;PREVIEW&#34;, action=1(CREATE) (user with this permission can view draft store item)&lt;/li&gt;&lt;li&gt;&lt;i&gt;Optional permission&lt;/i&gt;: resource=&#34;SANDBOX&#34;, action=1(CREATE) (user with this permission can view draft store item)&lt;/li&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: the list of items&lt;/li&gt;&lt;/ul&gt;
   */
  getItemsSearch(queryParams) {
    const params = { limit: 20, ...queryParams };
    const url = "/platform/public/namespaces/{namespace}/items/search".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.get(url, { params });
    return Validate44.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      ItemPagingSlicedResult,
      "ItemPagingSlicedResult"
    );
  }
  /**
   * This API is used to get item by appId.&lt;p&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Optional permission&lt;/i&gt;: resource=&#34;PREVIEW&#34;, action=1(CREATE) (user with this permission can view draft store item)&lt;/li&gt;&lt;li&gt;&lt;i&gt;Optional permission&lt;/i&gt;: resource=&#34;SANDBOX&#34;, action=1(CREATE) (user with this permission can view draft store item)&lt;/li&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: the item with that appId&lt;/li&gt;&lt;/ul&gt;
   */
  getItemsByAppId(queryParams) {
    const params = { ...queryParams };
    const url = "/platform/public/namespaces/{namespace}/items/byAppId".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.get(url, { params });
    return Validate44.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, ItemInfo, "ItemInfo");
  }
  /**
   * This API is used to query items by criteria within a store. If item not exist in specific region, default region item will return.&lt;p&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Optional permission&lt;/i&gt;: resource=&#34;PREVIEW&#34;, action=1(CREATE) (user with this permission can view draft store item)&lt;/li&gt;&lt;li&gt;&lt;i&gt;Optional permission&lt;/i&gt;: resource=&#34;SANDBOX&#34;, action=1(CREATE) (user with this permission can view draft store item)&lt;/li&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: the list of items&lt;/li&gt;&lt;/ul&gt;
   */
  getItemsByCriteria(queryParams) {
    const params = { limit: 20, sortBy: ["name:asc", "displayOrder:asc"], ...queryParams };
    const url = "/platform/public/namespaces/{namespace}/items/byCriteria".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.get(url, { params });
    return Validate44.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      ItemPagingSlicedResult,
      "ItemPagingSlicedResult"
    );
  }
  /**
   * This API is used to bulk get locale items. If item not exist in specific region, default region item will return.&lt;p&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Optional permission&lt;/i&gt;: resource=&#34;PREVIEW&#34;, action=1(CREATE) (user with this permission can view draft store items)&lt;/li&gt;&lt;li&gt;&lt;i&gt;Optional permission&lt;/i&gt;: resource=&#34;SANDBOX&#34;, action=1(CREATE) (user with this permission can view draft store items)&lt;/li&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: the list of items info&lt;/li&gt;&lt;/ul&gt;
   */
  getItemsLocaleByIds(queryParams) {
    const params = { ...queryParams };
    const url = "/platform/public/namespaces/{namespace}/items/locale/byIds".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.get(url, { params });
    return Validate44.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, ItemInfoArray, "ItemInfoArray");
  }
  /**
   * This API is used to get estimated prices of item
   */
  getItemsEstimatedPrice(queryParams) {
    const params = { ...queryParams };
    const url = "/platform/public/namespaces/{namespace}/items/estimatedPrice".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.get(url, { params });
    return Validate44.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      EstimatedPriceInfoArray,
      "EstimatedPriceInfoArray"
    );
  }
  /**
   * This API is used to get an item in locale. If item not exist in specific region, default region item will return.&lt;p&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Optional permission&lt;/i&gt;: resource=&#34;PREVIEW&#34;, action=1(CREATE) (user with this permission can view draft store item)&lt;/li&gt;&lt;li&gt;&lt;i&gt;Optional permission&lt;/i&gt;: resource=&#34;SANDBOX&#34;, action=1(CREATE) (user with this permission can view draft store item)&lt;/li&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: item data&lt;/li&gt;&lt;/ul&gt;
   */
  getLocale_ByItemId(itemId, queryParams) {
    const params = { ...queryParams };
    const url = "/platform/public/namespaces/{namespace}/items/{itemId}/locale".replace("{namespace}", this.namespace).replace("{itemId}", itemId);
    const resultPromise = this.axiosInstance.get(url, { params });
    return Validate44.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, PopulatedItemInfo, "PopulatedItemInfo");
  }
  /**
   * Get item dynamic data for a published item.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: item dynamic data&lt;/li&gt;&lt;/ul&gt;
   */
  getDynamic_ByItemId(itemId) {
    const params = {};
    const url = "/platform/public/namespaces/{namespace}/items/{itemId}/dynamic".replace("{namespace}", this.namespace).replace("{itemId}", itemId);
    const resultPromise = this.axiosInstance.get(url, { params });
    return Validate44.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, ItemDynamicDataInfo, "ItemDynamicDataInfo");
  }
  /**
   * This API is used to get an app in locale. If app not exist in specific region, default region app will return.&lt;p&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Optional permission&lt;/i&gt;: resource=&#34;PREVIEW&#34;, action=1(CREATE) (user with this permission can view draft store app)&lt;/li&gt;&lt;li&gt;&lt;i&gt;Optional permission&lt;/i&gt;: resource=&#34;SANDBOX&#34;, action=1(CREATE) (user with this permission can view draft store app)&lt;/li&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: app data&lt;/li&gt;&lt;/ul&gt;
   */
  getAppLocale_ByItemId(itemId, queryParams) {
    const params = { ...queryParams };
    const url = "/platform/public/namespaces/{namespace}/items/{itemId}/app/locale".replace("{namespace}", this.namespace).replace("{itemId}", itemId);
    const resultPromise = this.axiosInstance.get(url, { params });
    return Validate44.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, AppInfo, "AppInfo");
  }
  /**
   * This API is used to validate user item purchase condition
   */
  createItemPurchaseConditionValidate(data) {
    const params = {};
    const url = "/platform/public/namespaces/{namespace}/items/purchase/conditions/validate".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.post(url, data, { params });
    return Validate44.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      ItemPurchaseConditionValidateResultArray,
      "ItemPurchaseConditionValidateResultArray"
    );
  }
};

// src/generated-public/endpoints/Order$.ts
import { Validate as Validate45 } from "@accelbyte/sdk";
import { z as z387 } from "zod";
var Order$ = class {
  // @ts-ignore
  // prettier-ignore
  constructor(axiosInstance, namespace, useSchemaValidation = true) {
    this.axiosInstance = axiosInstance;
    this.namespace = namespace;
    this.useSchemaValidation = useSchemaValidation;
  }
  /**
   * Query user orders.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: get order&lt;/li&gt;&lt;/ul&gt;
   */
  getOrders_ByUserId(userId, queryParams) {
    const params = { limit: 20, ...queryParams };
    const url = "/platform/public/namespaces/{namespace}/users/{userId}/orders".replace("{namespace}", this.namespace).replace("{userId}", userId);
    const resultPromise = this.axiosInstance.get(url, { params });
    return Validate45.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      OrderPagingSlicedResult,
      "OrderPagingSlicedResult"
    );
  }
  /**
   * Create an order. The result contains the checkout link and payment token. User with permission SANDBOX will create sandbox order that not real paid for xsolla/alipay and not validate price for wxpay.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Optional permission(user with this permission will create sandbox order)&lt;/i&gt;: resource=&#34;SANDBOX&#34;, action=1 (CREATE)&lt;/li&gt;&lt;li&gt;It will be forbidden while the user is banned: ORDER_INITIATE or ORDER_AND_PAYMENT&lt;/li&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: created order&lt;/li&gt;&lt;/ul&gt;&lt;h2&gt;Restrictions for ext field&lt;/h2&gt; 1. Cannot use &lt;b&gt;&#34;.&#34;&lt;/b&gt; as the key name - &lt;pre&gt;{ &#34;data.2&#34;: &#34;value&#34; }&lt;/pre&gt; 2. Cannot use &lt;b&gt;&#34;$&#34;&lt;/b&gt; as the prefix in key names - &lt;pre&gt;{ &#34;$data&#34;: &#34;value&#34; }&lt;/pre&gt;
   */
  createOrder_ByUserId(userId, data) {
    const params = {};
    const url = "/platform/public/namespaces/{namespace}/users/{userId}/orders".replace("{namespace}", this.namespace).replace("{userId}", userId);
    const resultPromise = this.axiosInstance.post(url, data, { params });
    return Validate45.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, OrderInfo, "OrderInfo");
  }
  /**
   * Get user order.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: get order&lt;/li&gt;&lt;/ul&gt;
   */
  getOrder_ByUserId_ByOrderNo(userId, orderNo) {
    const params = {};
    const url = "/platform/public/namespaces/{namespace}/users/{userId}/orders/{orderNo}".replace("{namespace}", this.namespace).replace("{userId}", userId).replace("{orderNo}", orderNo);
    const resultPromise = this.axiosInstance.get(url, { params });
    return Validate45.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, OrderInfo, "OrderInfo");
  }
  /**
   * Cancel user order.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;/li&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: cancelled order&lt;/li&gt;&lt;/ul&gt;
   */
  updateCancel_ByUserId_ByOrderNo(userId, orderNo) {
    const params = {};
    const url = "/platform/public/namespaces/{namespace}/users/{userId}/orders/{orderNo}/cancel".replace("{namespace}", this.namespace).replace("{userId}", userId).replace("{orderNo}", orderNo);
    const resultPromise = this.axiosInstance.put(url, null, { params });
    return Validate45.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, OrderInfo, "OrderInfo");
  }
  /**
   * Preview order price with discount code, this api is used to auto calc order price with discount code.Notes: this api don&#39;t do full order validation, only check discount code and calc final order price.Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: previewed order&lt;/li&gt;&lt;/ul&gt;
   */
  createOrderDiscountPreview_ByUserId(userId, data) {
    const params = {};
    const url = "/platform/public/namespaces/{namespace}/users/{userId}/orders/discount/preview".replace("{namespace}", this.namespace).replace("{userId}", userId);
    const resultPromise = this.axiosInstance.post(url, data, { params });
    return Validate45.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      OrderDiscountPreviewResponse,
      "OrderDiscountPreviewResponse"
    );
  }
  /**
   * Get user order histories.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: get order history&lt;/li&gt;&lt;/ul&gt;
   */
  getHistory_ByUserId_ByOrderNo(userId, orderNo) {
    const params = {};
    const url = "/platform/public/namespaces/{namespace}/users/{userId}/orders/{orderNo}/history".replace("{namespace}", this.namespace).replace("{userId}", userId).replace("{orderNo}", orderNo);
    const resultPromise = this.axiosInstance.get(url, { params });
    return Validate45.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, OrderHistoryInfoArray, "OrderHistoryInfoArray");
  }
  /**
   * Download user order receipt by orderNo.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: order receipt pdf&lt;/li&gt;&lt;/ul&gt;
   */
  getReceiptPdf_ByUserId_ByOrderNo(userId, orderNo) {
    const params = {};
    const url = "/platform/public/namespaces/{namespace}/users/{userId}/orders/{orderNo}/receipt.pdf".replace("{namespace}", this.namespace).replace("{userId}", userId).replace("{orderNo}", orderNo);
    const resultPromise = this.axiosInstance.get(url, { params });
    return Validate45.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, z387.unknown(), "z.unknown()");
  }
};

// src/generated-public/endpoints/PaymentAccount$.ts
import { Validate as Validate46 } from "@accelbyte/sdk";
import { z as z388 } from "zod";
var PaymentAccount$ = class {
  // @ts-ignore
  // prettier-ignore
  constructor(axiosInstance, namespace, useSchemaValidation = true) {
    this.axiosInstance = axiosInstance;
    this.namespace = namespace;
    this.useSchemaValidation = useSchemaValidation;
  }
  /**
   * &lt;b&gt;[Not supported yet in AGS Shared Cloud]&lt;/b&gt;Get payment accounts.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: Payment account list&lt;/li&gt;&lt;/ul&gt;
   */
  getPaymentAccounts_ByUserId(userId) {
    const params = {};
    const url = "/platform/public/namespaces/{namespace}/users/{userId}/payment/accounts".replace("{namespace}", this.namespace).replace("{userId}", userId);
    const resultPromise = this.axiosInstance.get(url, { params });
    return Validate46.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, PaymentAccountArray, "PaymentAccountArray");
  }
  /**
   * &lt;b&gt;[Not supported yet in AGS Shared Cloud]&lt;/b&gt;Delete payment account.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;:&lt;/li&gt;&lt;/ul&gt;
   */
  deletePaymentAccount_ByUserId_ByType_ById(userId, type, id) {
    const params = {};
    const url = "/platform/public/namespaces/{namespace}/users/{userId}/payment/accounts/{type}/{id}".replace("{namespace}", this.namespace).replace("{userId}", userId).replace("{type}", type).replace("{id}", id);
    const resultPromise = this.axiosInstance.delete(url, { params });
    return Validate46.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, z388.unknown(), "z.unknown()");
  }
};

// src/generated-public/endpoints/PaymentStation$.ts
import { Validate as Validate47 } from "@accelbyte/sdk";
import { z as z389 } from "zod";
var PaymentStation$ = class {
  // @ts-ignore
  // prettier-ignore
  constructor(axiosInstance, namespace, useSchemaValidation = true) {
    this.axiosInstance = axiosInstance;
    this.namespace = namespace;
    this.useSchemaValidation = useSchemaValidation;
  }
  /**
   * &lt;b&gt;[Not supported yet in AGS Shared Cloud]&lt;/b&gt;Check and get a payment order&#39;s should pay tax.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: tax result&lt;/li&gt;&lt;/ul&gt;
   */
  getPaymentTax(queryParams) {
    const params = { ...queryParams };
    const url = "/platform/public/namespaces/{namespace}/payment/tax".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.get(url, { params });
    return Validate47.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, TaxResult, "TaxResult");
  }
  /**
   * &lt;b&gt;[Not supported yet in AGS Shared Cloud]&lt;/b&gt;Get payment url.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;For Neon Pay payment provider, the &#39;neonPayConfig&#39; field can be used to provide success and cancel URL. If &#39;neonPayConfig&#39; field is not present, the &#39;returnUrl&#39; will be used for both success and cancel URL.&lt;/li&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: Get payment link&lt;/li&gt;&lt;/ul&gt;
   */
  createPaymentLink(data) {
    const params = {};
    const url = "/platform/public/namespaces/{namespace}/payment/link".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.post(url, data, { params });
    return Validate47.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, PaymentUrl, "PaymentUrl");
  }
  /**
   * &lt;b&gt;[Not supported yet in AGS Shared Cloud]&lt;/b&gt;Get qrcode.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: QRCode image stream&lt;/li&gt;&lt;/ul&gt;
   */
  getPaymentQrcode(queryParams) {
    const params = { ...queryParams };
    const url = "/platform/public/namespaces/{namespace}/payment/qrcode".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.get(url, { params });
    return Validate47.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, BinarySchema, "BinarySchema");
  }
  /**
   * &lt;b&gt;[Not supported yet in AGS Shared Cloud]&lt;/b&gt;Get payment methods.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: Payment method list&lt;/li&gt;&lt;/ul&gt;
   */
  getPaymentMethods(queryParams) {
    const params = { ...queryParams };
    const url = "/platform/public/namespaces/{namespace}/payment/methods".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.get(url, { params });
    return Validate47.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, PaymentMethodArray, "PaymentMethodArray");
  }
  /**
   * &lt;b&gt;[Not supported yet in AGS Shared Cloud]&lt;/b&gt;Normalize payment return url for payment provider&lt;br&gt;Payment response: &lt;table&gt;&lt;tr&gt;&lt;td&gt;Field&lt;/td&gt;&lt;td&gt;Type&lt;/td&gt;&lt;td&gt;Required&lt;/td&gt;&lt;td&gt;Description&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;orderNo&lt;/td&gt;&lt;td&gt;String&lt;/td&gt;&lt;td&gt;Yes&lt;/td&gt;&lt;td&gt;order no&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;paymentStatus&lt;/td&gt;&lt;td&gt;String&lt;/td&gt;&lt;td&gt;Yes&lt;/td&gt;&lt;td&gt;&lt;ul&gt;&lt;li&gt;DONE: The payment was successfully completed.&lt;/li&gt;&lt;li&gt;CANCELLED: The payment was cancelled by the shopper before completion, or the shopper returned to the merchant&#39;s site before completing the transaction.&lt;/li&gt;&lt;li&gt;PENDING: Inform the shopper that you&#39;ve received their order, and are waiting for the payment to be completed. When the shopper has completed the payment you will receive a successful AUTHORISATION.&lt;/li&gt;&lt;li&gt;RECEIVED: Inform the shopper that you&#39;ve received their order, and are waiting for the payment to clear.&lt;/li&gt;&lt;li&gt;UNKNOWN: An error occurred during the payment processing.&lt;/li&gt;&lt;li&gt;FAILED: Shopper paid failed because of various reasons.&lt;/li&gt;&lt;/ul&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;reason&lt;/td&gt;&lt;td&gt;String&lt;/td&gt;&lt;td&gt;No&lt;/td&gt;&lt;td&gt;payment status reason&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;xsolla&lt;/i&gt;: parameters &#39;user_id&#39;, &#39;foreinginvoice&#39;, &#39;invoice_id&#39; and &#39;status&#39; will be automatically added to the link&lt;/li&gt;&lt;li&gt;&lt;i&gt;adyen&lt;/i&gt;: https://docs.adyen.com/developers/checkout/web-sdk&lt;/li&gt;&lt;/ul&gt;
   */
  getPaymentReturnurl(queryParams) {
    const params = { ...queryParams };
    const url = "/platform/public/namespaces/{namespace}/payment/returnurl".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.get(url, { params });
    return Validate47.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, z389.unknown(), "z.unknown()");
  }
  /**
   * &lt;b&gt;[Not supported yet in AGS Shared Cloud]&lt;/b&gt;Get payment provider public config, at current only Strip provide public config.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: Public config&lt;/li&gt;&lt;/ul&gt;
   */
  getPaymentPublicconfig(queryParams) {
    const params = { ...queryParams };
    const url = "/platform/public/namespaces/{namespace}/payment/publicconfig".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.get(url, { params });
    return Validate47.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, z389.unknown(), "z.unknown()");
  }
  /**
   * @deprecated
   * &lt;b&gt;[Not supported yet in AGS Shared Cloud]&lt;/b&gt;Get payment provider customization, at current only Adyen provide customization. This api has been deprecated, pls use /public/namespaces/{namespace}/payment/publicconfig to get adyen config&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: customization&lt;/li&gt;&lt;/ul&gt;
   */
  getPaymentCustomization(queryParams) {
    const params = { ...queryParams };
    const url = "/platform/public/namespaces/{namespace}/payment/customization".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.get(url, { params });
    return Validate47.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, Customization, "Customization");
  }
  /**
   * &lt;b&gt;[Not supported yet in AGS Shared Cloud]&lt;/b&gt;Do payment(For now, this only support checkout.com).&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: Payment process result&lt;/li&gt;&lt;/ul&gt;
   */
  createPayPayment_ByPaymentOrderNo(paymentOrderNo, data, queryParams) {
    const params = { paymentProvider: "CHECKOUT", ...queryParams };
    const url = "/platform/public/namespaces/{namespace}/payment/orders/{paymentOrderNo}/pay".replace("{namespace}", this.namespace).replace("{paymentOrderNo}", paymentOrderNo);
    const resultPromise = this.axiosInstance.post(url, data, { params });
    return Validate47.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, PaymentProcessResult, "PaymentProcessResult");
  }
  /**
   * &lt;b&gt;[Not supported yet in AGS Shared Cloud]&lt;/b&gt;Get payment order info.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: Payment order details&lt;/li&gt;&lt;/ul&gt;
   */
  getInfoPayment_ByPaymentOrderNo(paymentOrderNo) {
    const params = {};
    const url = "/platform/public/namespaces/{namespace}/payment/orders/{paymentOrderNo}/info".replace("{namespace}", this.namespace).replace("{paymentOrderNo}", paymentOrderNo);
    const resultPromise = this.axiosInstance.get(url, { params });
    return Validate47.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, PaymentOrderDetails, "PaymentOrderDetails");
  }
  /**
   * &lt;b&gt;[Not supported yet in AGS Shared Cloud]&lt;/b&gt;Check payment order paid status.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: Payment order paid result&lt;/li&gt;&lt;/ul&gt;
   */
  getStatusPayment_ByPaymentOrderNo(paymentOrderNo) {
    const params = {};
    const url = "/platform/public/namespaces/{namespace}/payment/orders/{paymentOrderNo}/status".replace("{namespace}", this.namespace).replace("{paymentOrderNo}", paymentOrderNo);
    const resultPromise = this.axiosInstance.get(url, { params });
    return Validate47.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      PaymentOrderPaidResult,
      "PaymentOrderPaidResult"
    );
  }
};

// src/generated-public/endpoints/Reward$.ts
import { Validate as Validate48 } from "@accelbyte/sdk";
var Reward$ = class {
  // @ts-ignore
  // prettier-ignore
  constructor(axiosInstance, namespace, useSchemaValidation = true) {
    this.axiosInstance = axiosInstance;
    this.namespace = namespace;
    this.useSchemaValidation = useSchemaValidation;
  }
  /**
   * This API is used to get reward by reward code.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: reward instance&lt;/li&gt;&lt;/ul&gt;
   */
  getRewardsByCode(queryParams) {
    const params = { ...queryParams };
    const url = "/platform/public/namespaces/{namespace}/rewards/byCode".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.get(url, { params });
    return Validate48.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, RewardInfo, "RewardInfo");
  }
  /**
   * This API is used to get reward by reward Id.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: reward instance&lt;/li&gt;&lt;/ul&gt;
   */
  getReward_ByRewardId(rewardId) {
    const params = {};
    const url = "/platform/public/namespaces/{namespace}/rewards/{rewardId}".replace("{namespace}", this.namespace).replace("{rewardId}", rewardId);
    const resultPromise = this.axiosInstance.get(url, { params });
    return Validate48.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, RewardInfo, "RewardInfo");
  }
  /**
   * This API is used to query rewards by criteria.&lt;p&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: the list of rewards&lt;/li&gt;&lt;/ul&gt;
   */
  getRewardsByCriteria(queryParams) {
    const params = { limit: 20, sortBy: ["namespace:asc", "rewardCode:asc"], ...queryParams };
    const url = "/platform/public/namespaces/{namespace}/rewards/byCriteria".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.get(url, { params });
    return Validate48.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      RewardPagingSlicedResult,
      "RewardPagingSlicedResult"
    );
  }
};

// src/generated-public/endpoints/Section$.ts
import { Validate as Validate49 } from "@accelbyte/sdk";
var Section$ = class {
  // @ts-ignore
  // prettier-ignore
  constructor(axiosInstance, namespace, useSchemaValidation = true) {
    this.axiosInstance = axiosInstance;
    this.namespace = namespace;
    this.useSchemaValidation = useSchemaValidation;
  }
  /**
   * This API is used to list active section contents.&lt;p&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Optional permission&lt;/i&gt;: resource=&#34;PREVIEW&#34;, action=1(CREATE) (user with this permission can view draft store sections)&lt;/li&gt;&lt;li&gt;&lt;i&gt;Optional permission&lt;/i&gt;: resource=&#34;SANDBOX&#34;, action=1(CREATE) (user with this permission can view draft store sections)&lt;/li&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: active section contents&lt;/li&gt;&lt;/ul&gt;
   */
  getSections_ByUserId(userId, queryParams) {
    const params = { ...queryParams };
    const url = "/platform/public/namespaces/{namespace}/users/{userId}/sections".replace("{namespace}", this.namespace).replace("{userId}", userId);
    const resultPromise = this.axiosInstance.get(url, { params });
    return Validate49.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, SectionInfoArray, "SectionInfoArray");
  }
};

// src/generated-public/endpoints/Store$.ts
import { Validate as Validate50 } from "@accelbyte/sdk";
var Store$ = class {
  // @ts-ignore
  // prettier-ignore
  constructor(axiosInstance, namespace, useSchemaValidation = true) {
    this.axiosInstance = axiosInstance;
    this.namespace = namespace;
    this.useSchemaValidation = useSchemaValidation;
  }
  /**
   * This API is used to list all stores in a namespace.&lt;p&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Optional permission&lt;/i&gt;: resource=&#34;PREVIEW&#34;, action=1(CREATE) (user with this permission can view draft store)&lt;/li&gt;&lt;li&gt;&lt;i&gt;Optional permission&lt;/i&gt;: resource=&#34;SANDBOX&#34;, action=1(CREATE) (user with this permission can view draft store)&lt;/li&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: the list of stores&lt;/li&gt;&lt;/ul&gt;
   */
  getStores() {
    const params = {};
    const url = "/platform/public/namespaces/{namespace}/stores".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.get(url, { params });
    return Validate50.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, StoreInfoArray, "StoreInfoArray");
  }
};

// src/generated-public/endpoints/Subscription$.ts
import { Validate as Validate51 } from "@accelbyte/sdk";
import { z as z390 } from "zod";
var Subscription$ = class {
  // @ts-ignore
  // prettier-ignore
  constructor(axiosInstance, namespace, useSchemaValidation = true) {
    this.axiosInstance = axiosInstance;
    this.namespace = namespace;
    this.useSchemaValidation = useSchemaValidation;
  }
  /**
   * Query user subscriptions.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: paginated subscription&lt;/li&gt;&lt;/ul&gt;
   */
  getSubscriptions_ByUserId(userId, queryParams) {
    const params = { limit: 20, ...queryParams };
    const url = "/platform/public/namespaces/{namespace}/users/{userId}/subscriptions".replace("{namespace}", this.namespace).replace("{userId}", userId);
    const resultPromise = this.axiosInstance.get(url, { params });
    return Validate51.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      SubscriptionPagingSlicedResult,
      "SubscriptionPagingSlicedResult"
    );
  }
  /**
   * Subscribe a subscription. Support both real and virtual payment. Need go through payment flow using the paymentOrderNo if paymentFlowRequired true.&lt;br&gt;&lt;b&gt;ACTIVE USER subscription can&#39;t do subscribe again.&lt;/b&gt;&lt;br&gt;&lt;b&gt;The next billing date will be X(default 4) hours before the current period ends if correctly subscribed.&lt;/b&gt;&lt;br&gt;User with permission SANDBOX will create sandbox subscription that not real paid.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Optional permission(user with this permission will create sandbox subscription)&lt;/i&gt;: resource=&#34;SANDBOX&#34;, action=1 (CREATE)&lt;/li&gt;&lt;li&gt;It will be forbidden while the user is banned: ORDER_INITIATE or ORDER_AND_PAYMENT&lt;/li&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: created subscription&lt;/li&gt;&lt;/ul&gt;
   */
  createSubscription_ByUserId(userId, data) {
    const params = {};
    const url = "/platform/public/namespaces/{namespace}/users/{userId}/subscriptions".replace("{namespace}", this.namespace).replace("{userId}", userId);
    const resultPromise = this.axiosInstance.post(url, data, { params });
    return Validate51.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, z390.unknown(), "z.unknown()");
  }
  /**
   * Get user subscription.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: subscription&lt;/li&gt;&lt;/ul&gt;
   */
  getSubscription_ByUserId_BySubscriptionId(userId, subscriptionId) {
    const params = {};
    const url = "/platform/public/namespaces/{namespace}/users/{userId}/subscriptions/{subscriptionId}".replace("{namespace}", this.namespace).replace("{userId}", userId).replace("{subscriptionId}", subscriptionId);
    const resultPromise = this.axiosInstance.get(url, { params });
    return Validate51.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, SubscriptionInfo, "SubscriptionInfo");
  }
  /**
   * Check user subscription subscribable by itemId, ACTIVE USER subscription can&#39;t do subscribe again.&lt;p&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: subscribable info&lt;/li&gt;&lt;/ul&gt;
   */
  getSubscriptionsSubscribableByItemId_ByUserId(userId, queryParams) {
    const params = { ...queryParams };
    const url = "/platform/public/namespaces/{namespace}/users/{userId}/subscriptions/subscribable/byItemId".replace("{namespace}", this.namespace).replace("{userId}", userId);
    const resultPromise = this.axiosInstance.get(url, { params });
    return Validate51.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, Subscribable, "Subscribable");
  }
  /**
   * Cancel a subscription, only ACTIVE subscription can be cancelled. &lt;b&gt;Ensure successfully cancel, recommend at least 1 day before current period ends, otherwise it may be charging or charged.&lt;/b&gt;&lt;br&gt;Set immediate true, the subscription will be terminated immediately, otherwise till the end of current billing cycle.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: cancelled subscription&lt;/li&gt;&lt;/ul&gt;
   */
  updateCancel_ByUserId_BySubscriptionId(userId, subscriptionId, data) {
    const params = {};
    const url = "/platform/public/namespaces/{namespace}/users/{userId}/subscriptions/{subscriptionId}/cancel".replace("{namespace}", this.namespace).replace("{userId}", userId).replace("{subscriptionId}", subscriptionId);
    const resultPromise = this.axiosInstance.put(url, data, { params });
    return Validate51.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, SubscriptionInfo, "SubscriptionInfo");
  }
  /**
   * Get user subscription billing histories.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: paginated subscription history&lt;/li&gt;&lt;/ul&gt;
   */
  getHistory_ByUserId_BySubscriptionId(userId, subscriptionId, queryParams) {
    const params = { limit: 20, ...queryParams };
    const url = "/platform/public/namespaces/{namespace}/users/{userId}/subscriptions/{subscriptionId}/history".replace("{namespace}", this.namespace).replace("{userId}", userId).replace("{subscriptionId}", subscriptionId);
    const resultPromise = this.axiosInstance.get(url, { params });
    return Validate51.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      BillingHistoryPagingSlicedResult,
      "BillingHistoryPagingSlicedResult"
    );
  }
  /**
   * Request to change a subscription billing account, this will guide user to payment station. The actual change will happen at the 0 payment notification successfully handled.&lt;br&gt;Only ACTIVE USER subscription with real currency billing account can be changed.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: updated subscription&lt;/li&gt;&lt;/ul&gt;
   */
  updateBillingAccount_ByUserId_BySubscriptionId(userId, subscriptionId) {
    const params = {};
    const url = "/platform/public/namespaces/{namespace}/users/{userId}/subscriptions/{subscriptionId}/billingAccount".replace("{namespace}", this.namespace).replace("{userId}", userId).replace("{subscriptionId}", subscriptionId);
    const resultPromise = this.axiosInstance.put(url, null, { params });
    return Validate51.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, SubscriptionInfo, "SubscriptionInfo");
  }
};

// src/generated-public/endpoints/View$.ts
import { Validate as Validate52 } from "@accelbyte/sdk";
var View$ = class {
  // @ts-ignore
  // prettier-ignore
  constructor(axiosInstance, namespace, useSchemaValidation = true) {
    this.axiosInstance = axiosInstance;
    this.namespace = namespace;
    this.useSchemaValidation = useSchemaValidation;
  }
  /**
   * This API is used to get all views.&lt;p&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Optional permission&lt;/i&gt;: resource=&#34;PREVIEW&#34;, action=1(CREATE) (user with this permission can view draft store views)&lt;/li&gt;&lt;li&gt;&lt;i&gt;Optional permission&lt;/i&gt;: resource=&#34;SANDBOX&#34;, action=1(CREATE) (user with this permission can view draft store views)&lt;/li&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: all views&lt;/li&gt;&lt;/ul&gt;
   */
  getViews_ByUserId(userId, queryParams) {
    const params = { ...queryParams };
    const url = "/platform/public/namespaces/{namespace}/users/{userId}/views".replace("{namespace}", this.namespace).replace("{userId}", userId);
    const resultPromise = this.axiosInstance.get(url, { params });
    return Validate52.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, ViewInfoArray, "ViewInfoArray");
  }
};

// src/generated-public/endpoints/Wallet$.ts
import { Validate as Validate53 } from "@accelbyte/sdk";
var Wallet$ = class {
  // @ts-ignore
  // prettier-ignore
  constructor(axiosInstance, namespace, useSchemaValidation = true) {
    this.axiosInstance = axiosInstance;
    this.namespace = namespace;
    this.useSchemaValidation = useSchemaValidation;
  }
  /**
   * get my wallet by currency code and namespace.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: wallet info&lt;/li&gt;&lt;li&gt;&lt;i&gt;Path&#39;s namespace&lt;/i&gt; : &lt;ul&gt; &lt;li&gt;can be filled with &lt;b&gt;publisher namespace&lt;/b&gt; in order to get &lt;b&gt;publisher user wallet&lt;/b&gt;&lt;/li&gt; &lt;li&gt;can be filled with &lt;b&gt;game namespace&lt;/b&gt; in order to get &lt;b&gt;game user wallet&lt;/b&gt;&lt;/li&gt; &lt;/ul&gt;&lt;/li&gt;&lt;/ul&gt;
   */
  getUserMeWallet_ByCurrencyCode(currencyCode) {
    const params = {};
    const url = "/platform/public/namespaces/{namespace}/users/me/wallets/{currencyCode}".replace("{namespace}", this.namespace).replace("{currencyCode}", currencyCode);
    const resultPromise = this.axiosInstance.get(url, { params });
    return Validate53.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, PlatformWallet, "PlatformWallet");
  }
  /**
   * get a wallet by currency code.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: wallet info&lt;/li&gt;&lt;/ul&gt;
   */
  getWallet_ByUserId_ByCurrencyCode(userId, currencyCode) {
    const params = {};
    const url = "/platform/public/namespaces/{namespace}/users/{userId}/wallets/{currencyCode}".replace("{namespace}", this.namespace).replace("{userId}", userId).replace("{currencyCode}", currencyCode);
    const resultPromise = this.axiosInstance.get(url, { params });
    return Validate53.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, PlatformWallet, "PlatformWallet");
  }
  /**
   * List wallet transactions by currency code ordered by create time desc.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: currency transaction info&lt;/li&gt;&lt;/ul&gt;
   */
  getTransactions_ByUserId_ByCurrencyCode(userId, currencyCode, queryParams) {
    const params = { limit: 20, ...queryParams };
    const url = "/platform/public/namespaces/{namespace}/users/{userId}/wallets/{currencyCode}/transactions".replace("{namespace}", this.namespace).replace("{userId}", userId).replace("{currencyCode}", currencyCode);
    const resultPromise = this.axiosInstance.get(url, { params });
    return Validate53.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      WalletTransactionPagingSlicedResult,
      "WalletTransactionPagingSlicedResult"
    );
  }
};

// src/generated-public/EntitlementApi.ts
import { ApiUtils as ApiUtils40, Network as Network40 } from "@accelbyte/sdk";
function EntitlementApi(sdk, args) {
  const sdkAssembly = sdk.assembly();
  const namespace = args?.coreConfig?.namespace ?? sdkAssembly.coreConfig.namespace;
  const useSchemaValidation = args?.coreConfig?.useSchemaValidation ?? sdkAssembly.coreConfig.useSchemaValidation;
  let axiosInstance = sdkAssembly.axiosInstance;
  const requestConfigOverrides = args?.axiosConfig?.request;
  const baseURLOverride = args?.coreConfig?.baseURL;
  const interceptorsOverride = args?.axiosConfig?.interceptors ?? [];
  if (requestConfigOverrides || baseURLOverride || interceptorsOverride.length > 0) {
    const requestConfig = ApiUtils40.mergeAxiosConfigs(sdkAssembly.axiosInstance.defaults, {
      ...baseURLOverride ? { baseURL: baseURLOverride } : {},
      ...requestConfigOverrides
    });
    axiosInstance = Network40.create(requestConfig);
    for (const interceptor of interceptorsOverride) {
      if (interceptor.type === "request") {
        axiosInstance.interceptors.request.use(interceptor.onRequest, interceptor.onError);
      }
      if (interceptor.type === "response") {
        axiosInstance.interceptors.response.use(interceptor.onSuccess, interceptor.onError);
      }
    }
  }
  async function getEntitlements_ByUserId(userId, queryParams) {
    const $ = new Entitlement$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getEntitlements_ByUserId(userId, queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getEntitlementsByIds_ByUserId(userId, queryParams) {
    const $ = new Entitlement$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getEntitlementsByIds_ByUserId(userId, queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getEntitlementsBySku_ByUserId(userId, queryParams) {
    const $ = new Entitlement$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getEntitlementsBySku_ByUserId(userId, queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getEntitlementsByAppId_ByUserId(userId, queryParams) {
    const $ = new Entitlement$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getEntitlementsByAppId_ByUserId(userId, queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getEntitlementsHistory_ByUserId(userId, queryParams) {
    const $ = new Entitlement$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getEntitlementsHistory_ByUserId(userId, queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getUsersMeEntitlementsOwnershipAny(queryParams) {
    const $ = new Entitlement$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getUsersMeEntitlementsOwnershipAny(queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getEntitlementsByItemId_ByUserId(userId, queryParams) {
    const $ = new Entitlement$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getEntitlementsByItemId_ByUserId(userId, queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getUsersMeEntitlementsOwnershipToken(queryParams) {
    const $ = new Entitlement$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getUsersMeEntitlementsOwnershipToken(queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getEntitlementsByAppType_ByUserId(userId, queryParams) {
    const $ = new Entitlement$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getEntitlementsByAppType_ByUserId(userId, queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getUsersMeEntitlementsOwnershipBySku(queryParams) {
    const $ = new Entitlement$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getUsersMeEntitlementsOwnershipBySku(queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getUsersMeEntitlementsOwnershipByAppId(queryParams) {
    const $ = new Entitlement$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getUsersMeEntitlementsOwnershipByAppId(queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getUsersMeEntitlementsOwnershipByItemId(queryParams) {
    const $ = new Entitlement$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getUsersMeEntitlementsOwnershipByItemId(queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getEntitlementsOwnershipAny_ByUserId(userId, queryParams) {
    const $ = new Entitlement$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getEntitlementsOwnershipAny_ByUserId(userId, queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getEntitlement_ByUserId_ByEntitlementId(userId, entitlementId) {
    const $ = new Entitlement$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getEntitlement_ByUserId_ByEntitlementId(userId, entitlementId);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getEntitlementsOwnershipBySku_ByUserId(userId, queryParams) {
    const $ = new Entitlement$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getEntitlementsOwnershipBySku_ByUserId(userId, queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getEntitlementsOwnershipByAppId_ByUserId(userId, queryParams) {
    const $ = new Entitlement$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getEntitlementsOwnershipByAppId_ByUserId(userId, queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getEntitlementsOwnershipByItemId_ByUserId(userId, queryParams) {
    const $ = new Entitlement$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getEntitlementsOwnershipByItemId_ByUserId(userId, queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getEntitlementsOwnershipByItemIds_ByUserId(userId, queryParams) {
    const $ = new Entitlement$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getEntitlementsOwnershipByItemIds_ByUserId(userId, queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function updateSell_ByUserId_ByEntitlementId(userId, entitlementId, data) {
    const $ = new Entitlement$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.updateSell_ByUserId_ByEntitlementId(userId, entitlementId, data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function updateSplit_ByUserId_ByEntitlementId(userId, entitlementId, data) {
    const $ = new Entitlement$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.updateSplit_ByUserId_ByEntitlementId(userId, entitlementId, data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function updateTransfer_ByUserId_ByEntitlementId(userId, entitlementId, data) {
    const $ = new Entitlement$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.updateTransfer_ByUserId_ByEntitlementId(userId, entitlementId, data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function updateDecrement_ByUserId_ByEntitlementId(userId, entitlementId, data) {
    const $ = new Entitlement$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.updateDecrement_ByUserId_ByEntitlementId(userId, entitlementId, data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  return {
    /**
     * Query user entitlements for a specific user.&lt;p&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: entitlement list&lt;/li&gt;&lt;/ul&gt;
     */
    getEntitlements_ByUserId,
    /**
     * Get user entitlements by ids..&lt;p&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: entitlement list&lt;/li&gt;&lt;/ul&gt;
     */
    getEntitlementsByIds_ByUserId,
    /**
     * @deprecated
     * Get user entitlement by sku.
     */
    getEntitlementsBySku_ByUserId,
    /**
     * Get user app entitlement by appId.
     */
    getEntitlementsByAppId_ByUserId,
    /**
     * Get user entitlement history&lt;p&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: user entitlement history list&lt;/li&gt;&lt;/ul&gt;
     */
    getEntitlementsHistory_ByUserId,
    /**
     * Exists any my active entitlement of specified itemIds, skus and appIds
     */
    getUsersMeEntitlementsOwnershipAny,
    /**
     * @deprecated
     * Get user entitlement by itemId.
     */
    getEntitlementsByItemId_ByUserId,
    /**
     * Gets an entitlement ownership token of specified itemIds, skus and appIds&lt;p&gt;The decoded ownership token header like below:&lt;p&gt;&lt;pre&gt;&lt;code&gt;{ &#34;kid&#34;: &#34;9fd4cd5f991cebe3323605cd12d3b8bfdfc73fa4&#34;, &#34;typ&#34;: &#34;JWT&#34;, &#34;alg&#34;: &#34;RS256&#34; } &lt;/code&gt;&lt;/pre&gt;That you can get the jwks by api &lt;baseUrl&gt;/platform/jwks, if the configured private key is same as IAM, &lt;p&gt;you can also get jwks from IAM endpoint. &lt;p&gt;The decoded ownership token payload like below:&lt;p&gt;&lt;pre&gt;&lt;code&gt;{ &#34;namespace&#34;: &#34;accelbyte&#34;, &#34;entitlements&#34;: [ { &#34;itemId&#34;: &#34;4c1296291f604c199f7bb7f0ee02e5f8&#34;, &#34;appType&#34;: null, &#34;appId&#34;: null, &#34;namespace&#34;: &#34;accelbyte&#34;, &#34;itemNamespace&#34;: &#34;accelbyte&#34;, &#34;sku&#34;: &#34;prime-plus&#34; }, { &#34;itemId&#34;: &#34;e8f4974cf45c4e1f8d4f0c6990c518bd&#34;, &#34;appType&#34;: &#34;GAME&#34;, &#34;appId&#34;: &#34;omeganebula&#34;, &#34;namespace&#34;: &#34;accelbyte&#34;, &#34;itemNamespace&#34;: &#34;accelbyte&#34;, &#34;sku&#34;: &#34;APPG005ON&#34; } ], &#34;sub&#34;: &#34;66459eb6a4e44e6fb0040bd20c1079a5&#34;, &#34;exp&#34;: 1619624360, &#34;iat&#34;: 1619624060 } &lt;/code&gt;&lt;/pre&gt;&lt;b&gt;if there&#39;s no active entitlement for the specific params, the entitlements section will be omitted&lt;/b&gt;.
     */
    getUsersMeEntitlementsOwnershipToken,
    /**
     * Query app entitlements by appType.&lt;p&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: app entitlement pagination&lt;/li&gt;&lt;/ul&gt;
     */
    getEntitlementsByAppType_ByUserId,
    /**
     * Get my entitlement ownership by sku.&lt;p&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Path&#39;s namespace&lt;/i&gt; : &lt;ul&gt;&lt;li&gt;can be filled with &lt;b&gt;publisher namespace&lt;/b&gt; in order to get &lt;b&gt;publisher namespace entitlement ownership by sku&lt;/b&gt;&lt;/li&gt;&lt;li&gt;can be filled with &lt;b&gt;game namespace&lt;/b&gt; in order to get &lt;b&gt;game namespace entitlement ownership by sku&lt;/b&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;/ul&gt;
     */
    getUsersMeEntitlementsOwnershipBySku,
    /**
     * Get my app entitlement ownership by appId.&lt;p&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Path&#39;s namespace&lt;/i&gt; : &lt;ul&gt;&lt;li&gt;can be filled with &lt;b&gt;publisher namespace&lt;/b&gt; in order to get &lt;b&gt;publisher namespace app entitlement ownership&lt;/b&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;/ul&gt;
     */
    getUsersMeEntitlementsOwnershipByAppId,
    /**
     * Get my entitlement ownership by itemId.&lt;p&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Path&#39;s namespace&lt;/i&gt; : &lt;ul&gt;&lt;li&gt;can be filled with &lt;b&gt;publisher namespace&lt;/b&gt; in order to get &lt;b&gt;publisher namespace entitlement ownership by sku&lt;/b&gt;&lt;/li&gt;&lt;li&gt;can be filled with &lt;b&gt;game namespace&lt;/b&gt; in order to get &lt;b&gt;game namespace entitlement ownership by sku&lt;/b&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;/ul&gt;
     */
    getUsersMeEntitlementsOwnershipByItemId,
    /**
     * Exists any user active entitlement of specified itemIds, skus and appIds
     */
    getEntitlementsOwnershipAny_ByUserId,
    /**
     * Get user entitlement.&lt;p&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: entitlement&lt;/li&gt;&lt;/ul&gt;
     */
    getEntitlement_ByUserId_ByEntitlementId,
    /**
     * Get user entitlement ownership by sku.
     */
    getEntitlementsOwnershipBySku_ByUserId,
    /**
     * Get user app entitlement ownership by appId.
     */
    getEntitlementsOwnershipByAppId_ByUserId,
    /**
     * Get user entitlement ownership by itemId.
     */
    getEntitlementsOwnershipByItemId_ByUserId,
    /**
     * Get user entitlement ownership by itemIds.
     */
    getEntitlementsOwnershipByItemIds_ByUserId,
    /**
     * Sell user entitlement. If the entitlement is consumable, useCount is 0, the status will be CONSUMED. If the entitlement is durable, the status will be SOLD. Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: entitlement&lt;/li&gt;&lt;/ul&gt;
     */
    updateSell_ByUserId_ByEntitlementId,
    /**
     * Split a specified use count of entitlement and create a new entitlement with splitting use count.Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: entitlement&lt;/li&gt;&lt;/ul&gt;
     */
    updateSplit_ByUserId_ByEntitlementId,
    /**
     * Transfer a specified use count from entitlement A to B..Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: entitlement&lt;/li&gt;&lt;/ul&gt;
     */
    updateTransfer_ByUserId_ByEntitlementId,
    /**
     * Consume user entitlement. If the entitlement useCount is 0, the status will be CONSUMED. Client should pass item id in options if entitlement clazz is OPTIONBOX&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: consumed entitlement&lt;/li&gt;&lt;/ul&gt;
     */
    updateDecrement_ByUserId_ByEntitlementId
  };
}

// src/generated-public/FulfillmentApi.ts
import { ApiUtils as ApiUtils41, Network as Network41 } from "@accelbyte/sdk";
function FulfillmentApi(sdk, args) {
  const sdkAssembly = sdk.assembly();
  const namespace = args?.coreConfig?.namespace ?? sdkAssembly.coreConfig.namespace;
  const useSchemaValidation = args?.coreConfig?.useSchemaValidation ?? sdkAssembly.coreConfig.useSchemaValidation;
  let axiosInstance = sdkAssembly.axiosInstance;
  const requestConfigOverrides = args?.axiosConfig?.request;
  const baseURLOverride = args?.coreConfig?.baseURL;
  const interceptorsOverride = args?.axiosConfig?.interceptors ?? [];
  if (requestConfigOverrides || baseURLOverride || interceptorsOverride.length > 0) {
    const requestConfig = ApiUtils41.mergeAxiosConfigs(sdkAssembly.axiosInstance.defaults, {
      ...baseURLOverride ? { baseURL: baseURLOverride } : {},
      ...requestConfigOverrides
    });
    axiosInstance = Network41.create(requestConfig);
    for (const interceptor of interceptorsOverride) {
      if (interceptor.type === "request") {
        axiosInstance.interceptors.request.use(interceptor.onRequest, interceptor.onError);
      }
      if (interceptor.type === "response") {
        axiosInstance.interceptors.response.use(interceptor.onSuccess, interceptor.onError);
      }
    }
  }
  async function createFulfillmentCode_ByUserId(userId, data) {
    const $ = new Fulfillment$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.createFulfillmentCode_ByUserId(userId, data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  return {
    /**
     * Redeem campaign code, this api have rate limit, default: only allow request once per user in 2 seconds&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: fulfillment result&lt;/li&gt;&lt;/ul&gt;
     */
    createFulfillmentCode_ByUserId
  };
}

// src/generated-public/IapApi.ts
import { ApiUtils as ApiUtils42, Network as Network42 } from "@accelbyte/sdk";
function IapApi(sdk, args) {
  const sdkAssembly = sdk.assembly();
  const namespace = args?.coreConfig?.namespace ?? sdkAssembly.coreConfig.namespace;
  const useSchemaValidation = args?.coreConfig?.useSchemaValidation ?? sdkAssembly.coreConfig.useSchemaValidation;
  let axiosInstance = sdkAssembly.axiosInstance;
  const requestConfigOverrides = args?.axiosConfig?.request;
  const baseURLOverride = args?.coreConfig?.baseURL;
  const interceptorsOverride = args?.axiosConfig?.interceptors ?? [];
  if (requestConfigOverrides || baseURLOverride || interceptorsOverride.length > 0) {
    const requestConfig = ApiUtils42.mergeAxiosConfigs(sdkAssembly.axiosInstance.defaults, {
      ...baseURLOverride ? { baseURL: baseURLOverride } : {},
      ...requestConfigOverrides
    });
    axiosInstance = Network42.create(requestConfig);
    for (const interceptor of interceptorsOverride) {
      if (interceptor.type === "request") {
        axiosInstance.interceptors.request.use(interceptor.onRequest, interceptor.onError);
      }
      if (interceptor.type === "response") {
        axiosInstance.interceptors.response.use(interceptor.onSuccess, interceptor.onError);
      }
    }
  }
  async function getIapItemMapping(queryParams) {
    const $ = new Iap$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getIapItemMapping(queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getIapAppleConfigVersion() {
    const $ = new Iap$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getIapAppleConfigVersion();
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function updateUserMeIapTwitchSync(data) {
    const $ = new Iap$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.updateUserMeIapTwitchSync(data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function updateIapPsnSync_ByUserId(userId, data) {
    const $ = new Iap$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.updateIapPsnSync_ByUserId(userId, data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function updateIapXblSync_ByUserId(userId, data) {
    const $ = new Iap$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.updateIapXblSync_ByUserId(userId, data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function updateIapSteamSync_ByUserId(userId, data) {
    const $ = new Iap$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.updateIapSteamSync_ByUserId(userId, data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function updateIapOculuSync_ByUserId(userId) {
    const $ = new Iap$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.updateIapOculuSync_ByUserId(userId);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function updateIapTwitchSync_ByUserId(userId, data) {
    const $ = new Iap$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.updateIapTwitchSync_ByUserId(userId, data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function updateIapAppleReceipt_ByUserId(userId, data) {
    const $ = new Iap$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.updateIapAppleReceipt_ByUserId(userId, data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function updateIapEpicgameSync_ByUserId(userId, data) {
    const $ = new Iap$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.updateIapEpicgameSync_ByUserId(userId, data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function updateIapGoogleReceipt_ByUserId(userId, data) {
    const $ = new Iap$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.updateIapGoogleReceipt_ByUserId(userId, data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function updateIapAppleReceipt_ByUserId_v2(userId, data) {
    const $ = new Iap$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.updateIapAppleReceipt_ByUserId_v2(userId, data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function updateIapPsnSyncMultiServiceLabel_ByUserId(userId, data) {
    const $ = new Iap$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.updateIapPsnSyncMultiServiceLabel_ByUserId(userId, data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  return {
    /**
     * Get iap item mapping.
     */
    getIapItemMapping,
    /**
     * Get apple config version.
     */
    getIapAppleConfigVersion,
    /**
     * Sync my game twitch drops entitlements.
     */
    updateUserMeIapTwitchSync,
    /**
     * Synchronize with entitlements in PSN Store.Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: result of synchronization&lt;/li&gt;&lt;/ul&gt;
     */
    updateIapPsnSync_ByUserId,
    /**
     * Sync Xbox inventory&#39;s items.Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: &lt;/li&gt;&lt;/ul&gt;
     */
    updateIapXblSync_ByUserId,
    /**
     * Sync steam inventory&#39;s items.Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: &lt;/li&gt;&lt;/ul&gt;
     */
    updateIapSteamSync_ByUserId,
    /**
     * Sync Oculus entitlements.Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: &lt;/li&gt;&lt;/ul&gt;
     */
    updateIapOculuSync_ByUserId,
    /**
     * Sync twitch drops entitlements.Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: &lt;/li&gt;&lt;/ul&gt;
     */
    updateIapTwitchSync_ByUserId,
    /**
     * Verify apple iap receipt and fulfill item. don&#39;t support subscriptionOther detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: &lt;/li&gt;&lt;/ul&gt;
     */
    updateIapAppleReceipt_ByUserId,
    /**
     * Sync epic games inventory&#39;s items.Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: &lt;/li&gt;&lt;/ul&gt;
     */
    updateIapEpicgameSync_ByUserId,
    /**
     * Verify google iap receipt and fulfill item.Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: &lt;/li&gt;&lt;/ul&gt;
     */
    updateIapGoogleReceipt_ByUserId,
    /**
     * Verify apple iap transaction and fulfill item, support subscriptionOther detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: &lt;/li&gt;&lt;/ul&gt;
     */
    updateIapAppleReceipt_ByUserId_v2,
    /**
     * Synchronize with entitlements in PSN Store with multiple service labels.Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: result of synchronization&lt;/li&gt;&lt;/ul&gt;
     */
    updateIapPsnSyncMultiServiceLabel_ByUserId
  };
}

// src/generated-public/IapSubscriptionApi.ts
import { ApiUtils as ApiUtils43, Network as Network43 } from "@accelbyte/sdk";
function IapSubscriptionApi(sdk, args) {
  const sdkAssembly = sdk.assembly();
  const namespace = args?.coreConfig?.namespace ?? sdkAssembly.coreConfig.namespace;
  const useSchemaValidation = args?.coreConfig?.useSchemaValidation ?? sdkAssembly.coreConfig.useSchemaValidation;
  let axiosInstance = sdkAssembly.axiosInstance;
  const requestConfigOverrides = args?.axiosConfig?.request;
  const baseURLOverride = args?.coreConfig?.baseURL;
  const interceptorsOverride = args?.axiosConfig?.interceptors ?? [];
  if (requestConfigOverrides || baseURLOverride || interceptorsOverride.length > 0) {
    const requestConfig = ApiUtils43.mergeAxiosConfigs(sdkAssembly.axiosInstance.defaults, {
      ...baseURLOverride ? { baseURL: baseURLOverride } : {},
      ...requestConfigOverrides
    });
    axiosInstance = Network43.create(requestConfig);
    for (const interceptor of interceptorsOverride) {
      if (interceptor.type === "request") {
        axiosInstance.interceptors.request.use(interceptor.onRequest, interceptor.onError);
      }
      if (interceptor.type === "response") {
        axiosInstance.interceptors.response.use(interceptor.onSuccess, interceptor.onError);
      }
    }
  }
  async function getIapSubscriptionPlatform_ByUserId_ByPlatform(userId, platform, queryParams) {
    const $ = new IapSubscription$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getIapSubscriptionPlatform_ByUserId_ByPlatform(userId, platform, queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  return {
    /**
     * Query user subscription, default sort by updatedAtOther detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: &lt;/li&gt;&lt;/ul&gt;
     */
    getIapSubscriptionPlatform_ByUserId_ByPlatform
  };
}

// src/generated-public/ItemApi.ts
import { ApiUtils as ApiUtils44, Network as Network44 } from "@accelbyte/sdk";
function ItemApi(sdk, args) {
  const sdkAssembly = sdk.assembly();
  const namespace = args?.coreConfig?.namespace ?? sdkAssembly.coreConfig.namespace;
  const useSchemaValidation = args?.coreConfig?.useSchemaValidation ?? sdkAssembly.coreConfig.useSchemaValidation;
  let axiosInstance = sdkAssembly.axiosInstance;
  const requestConfigOverrides = args?.axiosConfig?.request;
  const baseURLOverride = args?.coreConfig?.baseURL;
  const interceptorsOverride = args?.axiosConfig?.interceptors ?? [];
  if (requestConfigOverrides || baseURLOverride || interceptorsOverride.length > 0) {
    const requestConfig = ApiUtils44.mergeAxiosConfigs(sdkAssembly.axiosInstance.defaults, {
      ...baseURLOverride ? { baseURL: baseURLOverride } : {},
      ...requestConfigOverrides
    });
    axiosInstance = Network44.create(requestConfig);
    for (const interceptor of interceptorsOverride) {
      if (interceptor.type === "request") {
        axiosInstance.interceptors.request.use(interceptor.onRequest, interceptor.onError);
      }
      if (interceptor.type === "response") {
        axiosInstance.interceptors.response.use(interceptor.onSuccess, interceptor.onError);
      }
    }
  }
  async function getItemsBySku(queryParams) {
    const $ = new Item$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getItemsBySku(queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getItemsSearch(queryParams) {
    const $ = new Item$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getItemsSearch(queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getItemsByAppId(queryParams) {
    const $ = new Item$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getItemsByAppId(queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getItemsByCriteria(queryParams) {
    const $ = new Item$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getItemsByCriteria(queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getItemsLocaleByIds(queryParams) {
    const $ = new Item$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getItemsLocaleByIds(queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getItemsEstimatedPrice(queryParams) {
    const $ = new Item$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getItemsEstimatedPrice(queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getLocale_ByItemId(itemId, queryParams) {
    const $ = new Item$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getLocale_ByItemId(itemId, queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getDynamic_ByItemId(itemId) {
    const $ = new Item$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getDynamic_ByItemId(itemId);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getAppLocale_ByItemId(itemId, queryParams) {
    const $ = new Item$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getAppLocale_ByItemId(itemId, queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function createItemPurchaseConditionValidate(data) {
    const $ = new Item$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.createItemPurchaseConditionValidate(data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  return {
    /**
     * This API is used to get the item by sku.&lt;p&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Optional permission&lt;/i&gt;: resource=&#34;PREVIEW&#34;, action=1(CREATE) (user with this permission can view draft store item)&lt;/li&gt;&lt;li&gt;&lt;i&gt;Optional permission&lt;/i&gt;: resource=&#34;SANDBOX&#34;, action=1(CREATE) (user with this permission can view draft store item)&lt;/li&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: the item with sku&lt;/li&gt;&lt;/ul&gt;
     */
    getItemsBySku,
    /**
     * This API is used to search items by keyword in title, description and long description, It&#39;s language constrained, also if item not exist in specific region, default region item will return.&lt;p&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Optional permission&lt;/i&gt;: resource=&#34;PREVIEW&#34;, action=1(CREATE) (user with this permission can view draft store item)&lt;/li&gt;&lt;li&gt;&lt;i&gt;Optional permission&lt;/i&gt;: resource=&#34;SANDBOX&#34;, action=1(CREATE) (user with this permission can view draft store item)&lt;/li&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: the list of items&lt;/li&gt;&lt;/ul&gt;
     */
    getItemsSearch,
    /**
     * This API is used to get item by appId.&lt;p&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Optional permission&lt;/i&gt;: resource=&#34;PREVIEW&#34;, action=1(CREATE) (user with this permission can view draft store item)&lt;/li&gt;&lt;li&gt;&lt;i&gt;Optional permission&lt;/i&gt;: resource=&#34;SANDBOX&#34;, action=1(CREATE) (user with this permission can view draft store item)&lt;/li&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: the item with that appId&lt;/li&gt;&lt;/ul&gt;
     */
    getItemsByAppId,
    /**
     * This API is used to query items by criteria within a store. If item not exist in specific region, default region item will return.&lt;p&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Optional permission&lt;/i&gt;: resource=&#34;PREVIEW&#34;, action=1(CREATE) (user with this permission can view draft store item)&lt;/li&gt;&lt;li&gt;&lt;i&gt;Optional permission&lt;/i&gt;: resource=&#34;SANDBOX&#34;, action=1(CREATE) (user with this permission can view draft store item)&lt;/li&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: the list of items&lt;/li&gt;&lt;/ul&gt;
     */
    getItemsByCriteria,
    /**
     * This API is used to bulk get locale items. If item not exist in specific region, default region item will return.&lt;p&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Optional permission&lt;/i&gt;: resource=&#34;PREVIEW&#34;, action=1(CREATE) (user with this permission can view draft store items)&lt;/li&gt;&lt;li&gt;&lt;i&gt;Optional permission&lt;/i&gt;: resource=&#34;SANDBOX&#34;, action=1(CREATE) (user with this permission can view draft store items)&lt;/li&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: the list of items info&lt;/li&gt;&lt;/ul&gt;
     */
    getItemsLocaleByIds,
    /**
     * This API is used to get estimated prices of item
     */
    getItemsEstimatedPrice,
    /**
     * This API is used to get an item in locale. If item not exist in specific region, default region item will return.&lt;p&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Optional permission&lt;/i&gt;: resource=&#34;PREVIEW&#34;, action=1(CREATE) (user with this permission can view draft store item)&lt;/li&gt;&lt;li&gt;&lt;i&gt;Optional permission&lt;/i&gt;: resource=&#34;SANDBOX&#34;, action=1(CREATE) (user with this permission can view draft store item)&lt;/li&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: item data&lt;/li&gt;&lt;/ul&gt;
     */
    getLocale_ByItemId,
    /**
     * Get item dynamic data for a published item.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: item dynamic data&lt;/li&gt;&lt;/ul&gt;
     */
    getDynamic_ByItemId,
    /**
     * This API is used to get an app in locale. If app not exist in specific region, default region app will return.&lt;p&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Optional permission&lt;/i&gt;: resource=&#34;PREVIEW&#34;, action=1(CREATE) (user with this permission can view draft store app)&lt;/li&gt;&lt;li&gt;&lt;i&gt;Optional permission&lt;/i&gt;: resource=&#34;SANDBOX&#34;, action=1(CREATE) (user with this permission can view draft store app)&lt;/li&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: app data&lt;/li&gt;&lt;/ul&gt;
     */
    getAppLocale_ByItemId,
    /**
     * This API is used to validate user item purchase condition
     */
    createItemPurchaseConditionValidate
  };
}

// src/generated-public/OrderApi.ts
import { ApiUtils as ApiUtils45, Network as Network45 } from "@accelbyte/sdk";
function OrderApi(sdk, args) {
  const sdkAssembly = sdk.assembly();
  const namespace = args?.coreConfig?.namespace ?? sdkAssembly.coreConfig.namespace;
  const useSchemaValidation = args?.coreConfig?.useSchemaValidation ?? sdkAssembly.coreConfig.useSchemaValidation;
  let axiosInstance = sdkAssembly.axiosInstance;
  const requestConfigOverrides = args?.axiosConfig?.request;
  const baseURLOverride = args?.coreConfig?.baseURL;
  const interceptorsOverride = args?.axiosConfig?.interceptors ?? [];
  if (requestConfigOverrides || baseURLOverride || interceptorsOverride.length > 0) {
    const requestConfig = ApiUtils45.mergeAxiosConfigs(sdkAssembly.axiosInstance.defaults, {
      ...baseURLOverride ? { baseURL: baseURLOverride } : {},
      ...requestConfigOverrides
    });
    axiosInstance = Network45.create(requestConfig);
    for (const interceptor of interceptorsOverride) {
      if (interceptor.type === "request") {
        axiosInstance.interceptors.request.use(interceptor.onRequest, interceptor.onError);
      }
      if (interceptor.type === "response") {
        axiosInstance.interceptors.response.use(interceptor.onSuccess, interceptor.onError);
      }
    }
  }
  async function getOrders_ByUserId(userId, queryParams) {
    const $ = new Order$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getOrders_ByUserId(userId, queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function createOrder_ByUserId(userId, data) {
    const $ = new Order$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.createOrder_ByUserId(userId, data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getOrder_ByUserId_ByOrderNo(userId, orderNo) {
    const $ = new Order$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getOrder_ByUserId_ByOrderNo(userId, orderNo);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function updateCancel_ByUserId_ByOrderNo(userId, orderNo) {
    const $ = new Order$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.updateCancel_ByUserId_ByOrderNo(userId, orderNo);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function createOrderDiscountPreview_ByUserId(userId, data) {
    const $ = new Order$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.createOrderDiscountPreview_ByUserId(userId, data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getHistory_ByUserId_ByOrderNo(userId, orderNo) {
    const $ = new Order$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getHistory_ByUserId_ByOrderNo(userId, orderNo);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getReceiptPdf_ByUserId_ByOrderNo(userId, orderNo) {
    const $ = new Order$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getReceiptPdf_ByUserId_ByOrderNo(userId, orderNo);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  return {
    /**
     * Query user orders.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: get order&lt;/li&gt;&lt;/ul&gt;
     */
    getOrders_ByUserId,
    /**
     * Create an order. The result contains the checkout link and payment token. User with permission SANDBOX will create sandbox order that not real paid for xsolla/alipay and not validate price for wxpay.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Optional permission(user with this permission will create sandbox order)&lt;/i&gt;: resource=&#34;SANDBOX&#34;, action=1 (CREATE)&lt;/li&gt;&lt;li&gt;It will be forbidden while the user is banned: ORDER_INITIATE or ORDER_AND_PAYMENT&lt;/li&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: created order&lt;/li&gt;&lt;/ul&gt;&lt;h2&gt;Restrictions for ext field&lt;/h2&gt; 1. Cannot use &lt;b&gt;&#34;.&#34;&lt;/b&gt; as the key name - &lt;pre&gt;{ &#34;data.2&#34;: &#34;value&#34; }&lt;/pre&gt; 2. Cannot use &lt;b&gt;&#34;$&#34;&lt;/b&gt; as the prefix in key names - &lt;pre&gt;{ &#34;$data&#34;: &#34;value&#34; }&lt;/pre&gt;
     */
    createOrder_ByUserId,
    /**
     * Get user order.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: get order&lt;/li&gt;&lt;/ul&gt;
     */
    getOrder_ByUserId_ByOrderNo,
    /**
     * Cancel user order.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;/li&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: cancelled order&lt;/li&gt;&lt;/ul&gt;
     */
    updateCancel_ByUserId_ByOrderNo,
    /**
     * Preview order price with discount code, this api is used to auto calc order price with discount code.Notes: this api don&#39;t do full order validation, only check discount code and calc final order price.Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: previewed order&lt;/li&gt;&lt;/ul&gt;
     */
    createOrderDiscountPreview_ByUserId,
    /**
     * Get user order histories.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: get order history&lt;/li&gt;&lt;/ul&gt;
     */
    getHistory_ByUserId_ByOrderNo,
    /**
     * Download user order receipt by orderNo.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: order receipt pdf&lt;/li&gt;&lt;/ul&gt;
     */
    getReceiptPdf_ByUserId_ByOrderNo
  };
}

// src/generated-public/PaymentAccountApi.ts
import { ApiUtils as ApiUtils46, Network as Network46 } from "@accelbyte/sdk";
function PaymentAccountApi(sdk, args) {
  const sdkAssembly = sdk.assembly();
  const namespace = args?.coreConfig?.namespace ?? sdkAssembly.coreConfig.namespace;
  const useSchemaValidation = args?.coreConfig?.useSchemaValidation ?? sdkAssembly.coreConfig.useSchemaValidation;
  let axiosInstance = sdkAssembly.axiosInstance;
  const requestConfigOverrides = args?.axiosConfig?.request;
  const baseURLOverride = args?.coreConfig?.baseURL;
  const interceptorsOverride = args?.axiosConfig?.interceptors ?? [];
  if (requestConfigOverrides || baseURLOverride || interceptorsOverride.length > 0) {
    const requestConfig = ApiUtils46.mergeAxiosConfigs(sdkAssembly.axiosInstance.defaults, {
      ...baseURLOverride ? { baseURL: baseURLOverride } : {},
      ...requestConfigOverrides
    });
    axiosInstance = Network46.create(requestConfig);
    for (const interceptor of interceptorsOverride) {
      if (interceptor.type === "request") {
        axiosInstance.interceptors.request.use(interceptor.onRequest, interceptor.onError);
      }
      if (interceptor.type === "response") {
        axiosInstance.interceptors.response.use(interceptor.onSuccess, interceptor.onError);
      }
    }
  }
  async function getPaymentAccounts_ByUserId(userId) {
    const $ = new PaymentAccount$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getPaymentAccounts_ByUserId(userId);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function deletePaymentAccount_ByUserId_ByType_ById(userId, type, id) {
    const $ = new PaymentAccount$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.deletePaymentAccount_ByUserId_ByType_ById(userId, type, id);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  return {
    /**
     * &lt;b&gt;[Not supported yet in AGS Shared Cloud]&lt;/b&gt;Get payment accounts.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: Payment account list&lt;/li&gt;&lt;/ul&gt;
     */
    getPaymentAccounts_ByUserId,
    /**
     * &lt;b&gt;[Not supported yet in AGS Shared Cloud]&lt;/b&gt;Delete payment account.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;:&lt;/li&gt;&lt;/ul&gt;
     */
    deletePaymentAccount_ByUserId_ByType_ById
  };
}

// src/generated-public/PaymentStationApi.ts
import { ApiUtils as ApiUtils47, Network as Network47 } from "@accelbyte/sdk";
function PaymentStationApi(sdk, args) {
  const sdkAssembly = sdk.assembly();
  const namespace = args?.coreConfig?.namespace ?? sdkAssembly.coreConfig.namespace;
  const useSchemaValidation = args?.coreConfig?.useSchemaValidation ?? sdkAssembly.coreConfig.useSchemaValidation;
  let axiosInstance = sdkAssembly.axiosInstance;
  const requestConfigOverrides = args?.axiosConfig?.request;
  const baseURLOverride = args?.coreConfig?.baseURL;
  const interceptorsOverride = args?.axiosConfig?.interceptors ?? [];
  if (requestConfigOverrides || baseURLOverride || interceptorsOverride.length > 0) {
    const requestConfig = ApiUtils47.mergeAxiosConfigs(sdkAssembly.axiosInstance.defaults, {
      ...baseURLOverride ? { baseURL: baseURLOverride } : {},
      ...requestConfigOverrides
    });
    axiosInstance = Network47.create(requestConfig);
    for (const interceptor of interceptorsOverride) {
      if (interceptor.type === "request") {
        axiosInstance.interceptors.request.use(interceptor.onRequest, interceptor.onError);
      }
      if (interceptor.type === "response") {
        axiosInstance.interceptors.response.use(interceptor.onSuccess, interceptor.onError);
      }
    }
  }
  async function getPaymentTax(queryParams) {
    const $ = new PaymentStation$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getPaymentTax(queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function createPaymentLink(data) {
    const $ = new PaymentStation$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.createPaymentLink(data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getPaymentQrcode(queryParams) {
    const $ = new PaymentStation$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getPaymentQrcode(queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getPaymentMethods(queryParams) {
    const $ = new PaymentStation$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getPaymentMethods(queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getPaymentReturnurl(queryParams) {
    const $ = new PaymentStation$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getPaymentReturnurl(queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getPaymentPublicconfig(queryParams) {
    const $ = new PaymentStation$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getPaymentPublicconfig(queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getPaymentCustomization(queryParams) {
    const $ = new PaymentStation$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getPaymentCustomization(queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function createPayPayment_ByPaymentOrderNo(paymentOrderNo, data, queryParams) {
    const $ = new PaymentStation$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.createPayPayment_ByPaymentOrderNo(paymentOrderNo, data, queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getInfoPayment_ByPaymentOrderNo(paymentOrderNo) {
    const $ = new PaymentStation$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getInfoPayment_ByPaymentOrderNo(paymentOrderNo);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getStatusPayment_ByPaymentOrderNo(paymentOrderNo) {
    const $ = new PaymentStation$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getStatusPayment_ByPaymentOrderNo(paymentOrderNo);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  return {
    /**
     * &lt;b&gt;[Not supported yet in AGS Shared Cloud]&lt;/b&gt;Check and get a payment order&#39;s should pay tax.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: tax result&lt;/li&gt;&lt;/ul&gt;
     */
    getPaymentTax,
    /**
     * &lt;b&gt;[Not supported yet in AGS Shared Cloud]&lt;/b&gt;Get payment url.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;For Neon Pay payment provider, the &#39;neonPayConfig&#39; field can be used to provide success and cancel URL. If &#39;neonPayConfig&#39; field is not present, the &#39;returnUrl&#39; will be used for both success and cancel URL.&lt;/li&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: Get payment link&lt;/li&gt;&lt;/ul&gt;
     */
    createPaymentLink,
    /**
     * &lt;b&gt;[Not supported yet in AGS Shared Cloud]&lt;/b&gt;Get qrcode.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: QRCode image stream&lt;/li&gt;&lt;/ul&gt;
     */
    getPaymentQrcode,
    /**
     * &lt;b&gt;[Not supported yet in AGS Shared Cloud]&lt;/b&gt;Get payment methods.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: Payment method list&lt;/li&gt;&lt;/ul&gt;
     */
    getPaymentMethods,
    /**
     * &lt;b&gt;[Not supported yet in AGS Shared Cloud]&lt;/b&gt;Normalize payment return url for payment provider&lt;br&gt;Payment response: &lt;table&gt;&lt;tr&gt;&lt;td&gt;Field&lt;/td&gt;&lt;td&gt;Type&lt;/td&gt;&lt;td&gt;Required&lt;/td&gt;&lt;td&gt;Description&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;orderNo&lt;/td&gt;&lt;td&gt;String&lt;/td&gt;&lt;td&gt;Yes&lt;/td&gt;&lt;td&gt;order no&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;paymentStatus&lt;/td&gt;&lt;td&gt;String&lt;/td&gt;&lt;td&gt;Yes&lt;/td&gt;&lt;td&gt;&lt;ul&gt;&lt;li&gt;DONE: The payment was successfully completed.&lt;/li&gt;&lt;li&gt;CANCELLED: The payment was cancelled by the shopper before completion, or the shopper returned to the merchant&#39;s site before completing the transaction.&lt;/li&gt;&lt;li&gt;PENDING: Inform the shopper that you&#39;ve received their order, and are waiting for the payment to be completed. When the shopper has completed the payment you will receive a successful AUTHORISATION.&lt;/li&gt;&lt;li&gt;RECEIVED: Inform the shopper that you&#39;ve received their order, and are waiting for the payment to clear.&lt;/li&gt;&lt;li&gt;UNKNOWN: An error occurred during the payment processing.&lt;/li&gt;&lt;li&gt;FAILED: Shopper paid failed because of various reasons.&lt;/li&gt;&lt;/ul&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;reason&lt;/td&gt;&lt;td&gt;String&lt;/td&gt;&lt;td&gt;No&lt;/td&gt;&lt;td&gt;payment status reason&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;xsolla&lt;/i&gt;: parameters &#39;user_id&#39;, &#39;foreinginvoice&#39;, &#39;invoice_id&#39; and &#39;status&#39; will be automatically added to the link&lt;/li&gt;&lt;li&gt;&lt;i&gt;adyen&lt;/i&gt;: https://docs.adyen.com/developers/checkout/web-sdk&lt;/li&gt;&lt;/ul&gt;
     */
    getPaymentReturnurl,
    /**
     * &lt;b&gt;[Not supported yet in AGS Shared Cloud]&lt;/b&gt;Get payment provider public config, at current only Strip provide public config.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: Public config&lt;/li&gt;&lt;/ul&gt;
     */
    getPaymentPublicconfig,
    /**
     * @deprecated
     * &lt;b&gt;[Not supported yet in AGS Shared Cloud]&lt;/b&gt;Get payment provider customization, at current only Adyen provide customization. This api has been deprecated, pls use /public/namespaces/{namespace}/payment/publicconfig to get adyen config&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: customization&lt;/li&gt;&lt;/ul&gt;
     */
    getPaymentCustomization,
    /**
     * &lt;b&gt;[Not supported yet in AGS Shared Cloud]&lt;/b&gt;Do payment(For now, this only support checkout.com).&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: Payment process result&lt;/li&gt;&lt;/ul&gt;
     */
    createPayPayment_ByPaymentOrderNo,
    /**
     * &lt;b&gt;[Not supported yet in AGS Shared Cloud]&lt;/b&gt;Get payment order info.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: Payment order details&lt;/li&gt;&lt;/ul&gt;
     */
    getInfoPayment_ByPaymentOrderNo,
    /**
     * &lt;b&gt;[Not supported yet in AGS Shared Cloud]&lt;/b&gt;Check payment order paid status.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: Payment order paid result&lt;/li&gt;&lt;/ul&gt;
     */
    getStatusPayment_ByPaymentOrderNo
  };
}

// src/generated-public/RewardApi.ts
import { ApiUtils as ApiUtils48, Network as Network48 } from "@accelbyte/sdk";
function RewardApi(sdk, args) {
  const sdkAssembly = sdk.assembly();
  const namespace = args?.coreConfig?.namespace ?? sdkAssembly.coreConfig.namespace;
  const useSchemaValidation = args?.coreConfig?.useSchemaValidation ?? sdkAssembly.coreConfig.useSchemaValidation;
  let axiosInstance = sdkAssembly.axiosInstance;
  const requestConfigOverrides = args?.axiosConfig?.request;
  const baseURLOverride = args?.coreConfig?.baseURL;
  const interceptorsOverride = args?.axiosConfig?.interceptors ?? [];
  if (requestConfigOverrides || baseURLOverride || interceptorsOverride.length > 0) {
    const requestConfig = ApiUtils48.mergeAxiosConfigs(sdkAssembly.axiosInstance.defaults, {
      ...baseURLOverride ? { baseURL: baseURLOverride } : {},
      ...requestConfigOverrides
    });
    axiosInstance = Network48.create(requestConfig);
    for (const interceptor of interceptorsOverride) {
      if (interceptor.type === "request") {
        axiosInstance.interceptors.request.use(interceptor.onRequest, interceptor.onError);
      }
      if (interceptor.type === "response") {
        axiosInstance.interceptors.response.use(interceptor.onSuccess, interceptor.onError);
      }
    }
  }
  async function getRewardsByCode(queryParams) {
    const $ = new Reward$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getRewardsByCode(queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getReward_ByRewardId(rewardId) {
    const $ = new Reward$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getReward_ByRewardId(rewardId);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getRewardsByCriteria(queryParams) {
    const $ = new Reward$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getRewardsByCriteria(queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  return {
    /**
     * This API is used to get reward by reward code.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: reward instance&lt;/li&gt;&lt;/ul&gt;
     */
    getRewardsByCode,
    /**
     * This API is used to get reward by reward Id.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: reward instance&lt;/li&gt;&lt;/ul&gt;
     */
    getReward_ByRewardId,
    /**
     * This API is used to query rewards by criteria.&lt;p&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: the list of rewards&lt;/li&gt;&lt;/ul&gt;
     */
    getRewardsByCriteria
  };
}

// src/generated-public/SectionApi.ts
import { ApiUtils as ApiUtils49, Network as Network49 } from "@accelbyte/sdk";
function SectionApi(sdk, args) {
  const sdkAssembly = sdk.assembly();
  const namespace = args?.coreConfig?.namespace ?? sdkAssembly.coreConfig.namespace;
  const useSchemaValidation = args?.coreConfig?.useSchemaValidation ?? sdkAssembly.coreConfig.useSchemaValidation;
  let axiosInstance = sdkAssembly.axiosInstance;
  const requestConfigOverrides = args?.axiosConfig?.request;
  const baseURLOverride = args?.coreConfig?.baseURL;
  const interceptorsOverride = args?.axiosConfig?.interceptors ?? [];
  if (requestConfigOverrides || baseURLOverride || interceptorsOverride.length > 0) {
    const requestConfig = ApiUtils49.mergeAxiosConfigs(sdkAssembly.axiosInstance.defaults, {
      ...baseURLOverride ? { baseURL: baseURLOverride } : {},
      ...requestConfigOverrides
    });
    axiosInstance = Network49.create(requestConfig);
    for (const interceptor of interceptorsOverride) {
      if (interceptor.type === "request") {
        axiosInstance.interceptors.request.use(interceptor.onRequest, interceptor.onError);
      }
      if (interceptor.type === "response") {
        axiosInstance.interceptors.response.use(interceptor.onSuccess, interceptor.onError);
      }
    }
  }
  async function getSections_ByUserId(userId, queryParams) {
    const $ = new Section$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getSections_ByUserId(userId, queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  return {
    /**
     * This API is used to list active section contents.&lt;p&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Optional permission&lt;/i&gt;: resource=&#34;PREVIEW&#34;, action=1(CREATE) (user with this permission can view draft store sections)&lt;/li&gt;&lt;li&gt;&lt;i&gt;Optional permission&lt;/i&gt;: resource=&#34;SANDBOX&#34;, action=1(CREATE) (user with this permission can view draft store sections)&lt;/li&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: active section contents&lt;/li&gt;&lt;/ul&gt;
     */
    getSections_ByUserId
  };
}

// src/generated-public/StoreApi.ts
import { ApiUtils as ApiUtils50, Network as Network50 } from "@accelbyte/sdk";
function StoreApi(sdk, args) {
  const sdkAssembly = sdk.assembly();
  const namespace = args?.coreConfig?.namespace ?? sdkAssembly.coreConfig.namespace;
  const useSchemaValidation = args?.coreConfig?.useSchemaValidation ?? sdkAssembly.coreConfig.useSchemaValidation;
  let axiosInstance = sdkAssembly.axiosInstance;
  const requestConfigOverrides = args?.axiosConfig?.request;
  const baseURLOverride = args?.coreConfig?.baseURL;
  const interceptorsOverride = args?.axiosConfig?.interceptors ?? [];
  if (requestConfigOverrides || baseURLOverride || interceptorsOverride.length > 0) {
    const requestConfig = ApiUtils50.mergeAxiosConfigs(sdkAssembly.axiosInstance.defaults, {
      ...baseURLOverride ? { baseURL: baseURLOverride } : {},
      ...requestConfigOverrides
    });
    axiosInstance = Network50.create(requestConfig);
    for (const interceptor of interceptorsOverride) {
      if (interceptor.type === "request") {
        axiosInstance.interceptors.request.use(interceptor.onRequest, interceptor.onError);
      }
      if (interceptor.type === "response") {
        axiosInstance.interceptors.response.use(interceptor.onSuccess, interceptor.onError);
      }
    }
  }
  async function getStores() {
    const $ = new Store$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getStores();
    if (resp.error) throw resp.error;
    return resp.response;
  }
  return {
    /**
     * This API is used to list all stores in a namespace.&lt;p&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Optional permission&lt;/i&gt;: resource=&#34;PREVIEW&#34;, action=1(CREATE) (user with this permission can view draft store)&lt;/li&gt;&lt;li&gt;&lt;i&gt;Optional permission&lt;/i&gt;: resource=&#34;SANDBOX&#34;, action=1(CREATE) (user with this permission can view draft store)&lt;/li&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: the list of stores&lt;/li&gt;&lt;/ul&gt;
     */
    getStores
  };
}

// src/generated-public/SubscriptionApi.ts
import { ApiUtils as ApiUtils51, Network as Network51 } from "@accelbyte/sdk";
function SubscriptionApi(sdk, args) {
  const sdkAssembly = sdk.assembly();
  const namespace = args?.coreConfig?.namespace ?? sdkAssembly.coreConfig.namespace;
  const useSchemaValidation = args?.coreConfig?.useSchemaValidation ?? sdkAssembly.coreConfig.useSchemaValidation;
  let axiosInstance = sdkAssembly.axiosInstance;
  const requestConfigOverrides = args?.axiosConfig?.request;
  const baseURLOverride = args?.coreConfig?.baseURL;
  const interceptorsOverride = args?.axiosConfig?.interceptors ?? [];
  if (requestConfigOverrides || baseURLOverride || interceptorsOverride.length > 0) {
    const requestConfig = ApiUtils51.mergeAxiosConfigs(sdkAssembly.axiosInstance.defaults, {
      ...baseURLOverride ? { baseURL: baseURLOverride } : {},
      ...requestConfigOverrides
    });
    axiosInstance = Network51.create(requestConfig);
    for (const interceptor of interceptorsOverride) {
      if (interceptor.type === "request") {
        axiosInstance.interceptors.request.use(interceptor.onRequest, interceptor.onError);
      }
      if (interceptor.type === "response") {
        axiosInstance.interceptors.response.use(interceptor.onSuccess, interceptor.onError);
      }
    }
  }
  async function getSubscriptions_ByUserId(userId, queryParams) {
    const $ = new Subscription$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getSubscriptions_ByUserId(userId, queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function createSubscription_ByUserId(userId, data) {
    const $ = new Subscription$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.createSubscription_ByUserId(userId, data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getSubscription_ByUserId_BySubscriptionId(userId, subscriptionId) {
    const $ = new Subscription$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getSubscription_ByUserId_BySubscriptionId(userId, subscriptionId);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getSubscriptionsSubscribableByItemId_ByUserId(userId, queryParams) {
    const $ = new Subscription$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getSubscriptionsSubscribableByItemId_ByUserId(userId, queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function updateCancel_ByUserId_BySubscriptionId(userId, subscriptionId, data) {
    const $ = new Subscription$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.updateCancel_ByUserId_BySubscriptionId(userId, subscriptionId, data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getHistory_ByUserId_BySubscriptionId(userId, subscriptionId, queryParams) {
    const $ = new Subscription$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getHistory_ByUserId_BySubscriptionId(userId, subscriptionId, queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function updateBillingAccount_ByUserId_BySubscriptionId(userId, subscriptionId) {
    const $ = new Subscription$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.updateBillingAccount_ByUserId_BySubscriptionId(userId, subscriptionId);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  return {
    /**
     * Query user subscriptions.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: paginated subscription&lt;/li&gt;&lt;/ul&gt;
     */
    getSubscriptions_ByUserId,
    /**
     * Subscribe a subscription. Support both real and virtual payment. Need go through payment flow using the paymentOrderNo if paymentFlowRequired true.&lt;br&gt;&lt;b&gt;ACTIVE USER subscription can&#39;t do subscribe again.&lt;/b&gt;&lt;br&gt;&lt;b&gt;The next billing date will be X(default 4) hours before the current period ends if correctly subscribed.&lt;/b&gt;&lt;br&gt;User with permission SANDBOX will create sandbox subscription that not real paid.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Optional permission(user with this permission will create sandbox subscription)&lt;/i&gt;: resource=&#34;SANDBOX&#34;, action=1 (CREATE)&lt;/li&gt;&lt;li&gt;It will be forbidden while the user is banned: ORDER_INITIATE or ORDER_AND_PAYMENT&lt;/li&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: created subscription&lt;/li&gt;&lt;/ul&gt;
     */
    createSubscription_ByUserId,
    /**
     * Get user subscription.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: subscription&lt;/li&gt;&lt;/ul&gt;
     */
    getSubscription_ByUserId_BySubscriptionId,
    /**
     * Check user subscription subscribable by itemId, ACTIVE USER subscription can&#39;t do subscribe again.&lt;p&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: subscribable info&lt;/li&gt;&lt;/ul&gt;
     */
    getSubscriptionsSubscribableByItemId_ByUserId,
    /**
     * Cancel a subscription, only ACTIVE subscription can be cancelled. &lt;b&gt;Ensure successfully cancel, recommend at least 1 day before current period ends, otherwise it may be charging or charged.&lt;/b&gt;&lt;br&gt;Set immediate true, the subscription will be terminated immediately, otherwise till the end of current billing cycle.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: cancelled subscription&lt;/li&gt;&lt;/ul&gt;
     */
    updateCancel_ByUserId_BySubscriptionId,
    /**
     * Get user subscription billing histories.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: paginated subscription history&lt;/li&gt;&lt;/ul&gt;
     */
    getHistory_ByUserId_BySubscriptionId,
    /**
     * Request to change a subscription billing account, this will guide user to payment station. The actual change will happen at the 0 payment notification successfully handled.&lt;br&gt;Only ACTIVE USER subscription with real currency billing account can be changed.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: updated subscription&lt;/li&gt;&lt;/ul&gt;
     */
    updateBillingAccount_ByUserId_BySubscriptionId
  };
}

// src/generated-public/ViewApi.ts
import { ApiUtils as ApiUtils52, Network as Network52 } from "@accelbyte/sdk";
function ViewApi(sdk, args) {
  const sdkAssembly = sdk.assembly();
  const namespace = args?.coreConfig?.namespace ?? sdkAssembly.coreConfig.namespace;
  const useSchemaValidation = args?.coreConfig?.useSchemaValidation ?? sdkAssembly.coreConfig.useSchemaValidation;
  let axiosInstance = sdkAssembly.axiosInstance;
  const requestConfigOverrides = args?.axiosConfig?.request;
  const baseURLOverride = args?.coreConfig?.baseURL;
  const interceptorsOverride = args?.axiosConfig?.interceptors ?? [];
  if (requestConfigOverrides || baseURLOverride || interceptorsOverride.length > 0) {
    const requestConfig = ApiUtils52.mergeAxiosConfigs(sdkAssembly.axiosInstance.defaults, {
      ...baseURLOverride ? { baseURL: baseURLOverride } : {},
      ...requestConfigOverrides
    });
    axiosInstance = Network52.create(requestConfig);
    for (const interceptor of interceptorsOverride) {
      if (interceptor.type === "request") {
        axiosInstance.interceptors.request.use(interceptor.onRequest, interceptor.onError);
      }
      if (interceptor.type === "response") {
        axiosInstance.interceptors.response.use(interceptor.onSuccess, interceptor.onError);
      }
    }
  }
  async function getViews_ByUserId(userId, queryParams) {
    const $ = new View$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getViews_ByUserId(userId, queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  return {
    /**
     * This API is used to get all views.&lt;p&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Optional permission&lt;/i&gt;: resource=&#34;PREVIEW&#34;, action=1(CREATE) (user with this permission can view draft store views)&lt;/li&gt;&lt;li&gt;&lt;i&gt;Optional permission&lt;/i&gt;: resource=&#34;SANDBOX&#34;, action=1(CREATE) (user with this permission can view draft store views)&lt;/li&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: all views&lt;/li&gt;&lt;/ul&gt;
     */
    getViews_ByUserId
  };
}

// src/generated-public/WalletApi.ts
import { ApiUtils as ApiUtils53, Network as Network53 } from "@accelbyte/sdk";
function WalletApi(sdk, args) {
  const sdkAssembly = sdk.assembly();
  const namespace = args?.coreConfig?.namespace ?? sdkAssembly.coreConfig.namespace;
  const useSchemaValidation = args?.coreConfig?.useSchemaValidation ?? sdkAssembly.coreConfig.useSchemaValidation;
  let axiosInstance = sdkAssembly.axiosInstance;
  const requestConfigOverrides = args?.axiosConfig?.request;
  const baseURLOverride = args?.coreConfig?.baseURL;
  const interceptorsOverride = args?.axiosConfig?.interceptors ?? [];
  if (requestConfigOverrides || baseURLOverride || interceptorsOverride.length > 0) {
    const requestConfig = ApiUtils53.mergeAxiosConfigs(sdkAssembly.axiosInstance.defaults, {
      ...baseURLOverride ? { baseURL: baseURLOverride } : {},
      ...requestConfigOverrides
    });
    axiosInstance = Network53.create(requestConfig);
    for (const interceptor of interceptorsOverride) {
      if (interceptor.type === "request") {
        axiosInstance.interceptors.request.use(interceptor.onRequest, interceptor.onError);
      }
      if (interceptor.type === "response") {
        axiosInstance.interceptors.response.use(interceptor.onSuccess, interceptor.onError);
      }
    }
  }
  async function getUserMeWallet_ByCurrencyCode(currencyCode) {
    const $ = new Wallet$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getUserMeWallet_ByCurrencyCode(currencyCode);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getWallet_ByUserId_ByCurrencyCode(userId, currencyCode) {
    const $ = new Wallet$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getWallet_ByUserId_ByCurrencyCode(userId, currencyCode);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getTransactions_ByUserId_ByCurrencyCode(userId, currencyCode, queryParams) {
    const $ = new Wallet$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getTransactions_ByUserId_ByCurrencyCode(userId, currencyCode, queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  return {
    /**
     * get my wallet by currency code and namespace.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: wallet info&lt;/li&gt;&lt;li&gt;&lt;i&gt;Path&#39;s namespace&lt;/i&gt; : &lt;ul&gt; &lt;li&gt;can be filled with &lt;b&gt;publisher namespace&lt;/b&gt; in order to get &lt;b&gt;publisher user wallet&lt;/b&gt;&lt;/li&gt; &lt;li&gt;can be filled with &lt;b&gt;game namespace&lt;/b&gt; in order to get &lt;b&gt;game user wallet&lt;/b&gt;&lt;/li&gt; &lt;/ul&gt;&lt;/li&gt;&lt;/ul&gt;
     */
    getUserMeWallet_ByCurrencyCode,
    /**
     * get a wallet by currency code.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: wallet info&lt;/li&gt;&lt;/ul&gt;
     */
    getWallet_ByUserId_ByCurrencyCode,
    /**
     * List wallet transactions by currency code ordered by create time desc.&lt;br&gt;Other detail info: &lt;ul&gt;&lt;li&gt;&lt;i&gt;Returns&lt;/i&gt;: currency transaction info&lt;/li&gt;&lt;/ul&gt;
     */
    getTransactions_ByUserId_ByCurrencyCode
  };
}

export {
  AchievementInfo,
  XblUserAchievements,
  AchievementPlatformAdmin$,
  AchievementPlatformAdminApi,
  AnonymizationAdmin$,
  AnonymizationAdminApi,
  BulkOperationResult,
  CampaignBatchNameInfo,
  CampaignBatchNameInfoArray,
  CampaignDynamicInfo,
  DiscountCategory,
  DiscountItem,
  DiscountConfig,
  RedeemableItem,
  CampaignInfo,
  Paging,
  CampaignPagingSlicedResult,
  CodeCreateResult,
  CampaignIfc,
  CodeInfo,
  CodeInfoPagingSlicedResult,
  RedeemHistoryInfo,
  RedeemHistoryPagingSlicedResult,
  RedeemResult,
  CampaignAdmin$,
  CampaignAdminApi,
  CatalogChangeInfo,
  CatalogChangePagingResult,
  CatalogChangeStatistics,
  StoreInfo,
  CatalogChangesAdmin$,
  CatalogChangesAdminApi,
  BasicCategoryInfo,
  BasicCategoryInfoArray,
  FullCategoryInfo,
  FullCategoryInfoArray,
  CategoryAdmin$,
  CategoryAdminApi,
  ClawbackInfo,
  IapClawbackPagingSlicedResult,
  ClawbackAdmin$,
  ClawbackAdminApi,
  CurrencyConfig,
  CurrencyInfo,
  CurrencyInfoArray,
  CurrencySummary,
  CurrencyAdmin$,
  CurrencyAdminApi,
  PlatformRewardCurrency,
  PlatformRewardItem,
  PlatformReward,
  DlcItem,
  DlcItemConfigInfo,
  PlatformDlcEntry,
  PlatformDlcConfigInfo,
  RewardMigrationResult,
  EntitlementOriginSyncResult,
  CreditRevocation,
  EntitlementRevocation,
  ItemRevocation,
  RevocationResult,
  RevokeItemSummary,
  RevokeResult,
  DlcRecord,
  UserDlc,
  UserDlcRecord,
  UserDlcRecordArray,
  DlcAdmin$,
  DlcAdminApi,
  InventoryConfig,
  BoxItem,
  LootBoxReward,
  LootBoxConfig,
  OptionBoxConfig,
  Recurring,
  RegionDataItem,
  SaleConfig,
  ItemSnapshot,
  AppEntitlementInfo,
  AppEntitlementPagingSlicedResult,
  EntitlementGrant,
  EntitlementGrantResult,
  BulkEntitlementGrantResult,
  EntitlementRevokeResult,
  BulkEntitlementRevokeResult,
  EntitlementConfigInfo,
  EntitlementLootBoxReward,
  EntitlementDecrementResult,
  EntitlementHistoryInfo,
  EntitlementHistoryInfoArray,
  EntitlementIfc,
  EntitlementInfo,
  EntitlementInfoArray,
  EntitlementOwnership,
  EntitlementOwnershipArray,
  EntitlementPagingSlicedResult,
  EntitlementPlatformConfigInfo,
  EntitlementPrechekResult,
  CreditSummary,
  EntitlementSoldResult,
  Ownership,
  StackableEntitlementInfo,
  StackableEntitlementInfoArray,
  TimedOwnership,
  EntitlementAdmin$,
  EntitlementSummary,
  ExtensionFulfillmentSummary,
  FulfillmentError,
  FulfillmentItem,
  FulfillmentHistoryInfo,
  FulfillmentHistoryPagingSlicedResult,
  FulfillmentItemArray,
  FulfillmentActionHistory,
  FulfillBundledItemResult,
  FulfillItemResult,
  FulfillmentStateInfo,
  FulfillmentInfo,
  FulfillmentPagingSlicedResult,
  SubscriptionSummary,
  FulfillmentResult,
  FulfillmentV2Result,
  RevokeFulfillmentV2Result,
  FulfillmentAdmin$,
  FulfillmentScriptInfo,
  FulfillmentScriptInfoArray,
  FulfillmentScriptAdmin$,
  AppleIapConfigInfo,
  EpicGamesIapConfigInfo,
  GoogleIapConfigInfo,
  ClientRequestParameter,
  ConsumeItem,
  RequestHistory,
  IapConsumeHistoryInfo,
  IapConsumeHistoryPagingSlicedResult,
  IapItemEntry,
  IapItemConfigInfo,
  IapOrderInfo,
  IapOrderPagingSlicedResult,
  OculusIapConfigInfo,
  PlayStationIapConfigInfo,
  SteamIapConfig,
  SteamIapConfigInfo,
  TestResult,
  TwitchIapConfigInfo,
  XblIapConfigInfo,
  IapAdmin$,
  NotificationPagingSlicedResult,
  IapNotificationAdmin$,
  ThirdPartySubscriptionOwnership,
  ThirdPartySubscriptionTransactionHistoryInfo,
  ThirdPartySubscriptionTransactionHistoryPagingSlicedResult,
  ThirdPartySubscriptionTransactionInfo,
  ThirdPartySubscriptionTransactionPagingSlicedResult,
  ThirdPartyUserSubscriptionInfo,
  ThirdPartyUserSubscriptionPagingSlicedResult,
  IapSubscriptionAdmin$,
  InvoiceCurrencySummary,
  InvoiceSummary,
  InvoiceAdmin$,
  AvailableComparison,
  AvailablePredicate,
  AvailablePredicateArray,
  BasicItem,
  BasicItemArray,
  SubItemAvailablePrice,
  AvailablePrice,
  EstimatedPriceInfo,
  AppLocalization,
  Requirement,
  Slide,
  FullAppInfo,
  Image,
  Localization,
  Predicate,
  ConditionGroup,
  PurchaseCondition,
  FullItemInfo,
  FullItemInfoArray,
  FullItemPagingResult,
  FullItemPagingSlicedResult,
  ItemAcquireResult,
  ItemDynamicDataInfo,
  ItemId,
  ItemIdArray,
  ItemInfo,
  ItemInfoArray,
  PredicateValidateResult,
  ConditionGroupValidateResult,
  ItemPurchaseConditionValidateResult,
  ItemPurchaseConditionValidateResultArray,
  ItemTypeConfigInfo,
  ItemTypeConfigInfoArray,
  BundledItemInfo,
  PopulatedItemInfo,
  ItemAdmin$,
  KeyGroupDynamicInfo,
  KeyGroupInfo,
  KeyGroupPagingSlicedResult,
  KeyInfo,
  KeyPagingSliceResult,
  KeyGroupAdmin$,
  OrderGrantInfo,
  OrderHistoryInfo,
  OrderHistoryInfoArray,
  DiscountCodeInfo,
  DiscountCodeDeductionDetail,
  DeductionDetail,
  OrderBundleItemInfo,
  OrderCreationOptions,
  OrderInfo,
  OrderPagingResult,
  OrderPagingSlicedResult,
  OrderStatistics,
  PurchasedItemCount,
  OrderAdmin$,
  PaymentData,
  Order,
  OrderSyncResult,
  OrderDedicatedAdmin$,
  NotificationProcessResult,
  PaymentNotificationInfo,
  PaymentNotificationPagingSlicedResult,
  PaymentOrderChargeStatus,
  AdditionalData,
  Transaction,
  PaymentOrderInfo,
  PaymentOrderPagingSlicedResult,
  PaymentAdmin$,
  PaymentCallbackConfigInfo,
  PaymentCallbackConfigAdmin$,
  PaymentDomainWhitelistConfigInfo,
  AdyenConfig,
  AliPayConfig,
  CheckoutConfig,
  NeonPayConfig,
  PayPalConfig,
  StripeConfig,
  WxPayConfigInfo,
  XsollaConfig,
  XsollaPaywallConfig,
  PaymentMerchantConfigInfo,
  PaymentProviderConfigInfo,
  PaymentProviderConfigPagingSlicedResult,
  PaymentTaxConfigInfo,
  PaymentConfigAdmin$,
  PaymentOrderCreateResult,
  PaymentOrderRefundResult,
  PaymentOrderNeonPayConfig,
  PaymentOrder,
  PaymentOrderSyncResult,
  PaymentDedicatedAdmin$,
  SimpleEntitlement,
  SimpleUserDlc,
  TimeLimitedBalance,
  SimpleWallet,
  PlatformAccountClosureHistoryInfo,
  PlatformAccountClosureHistoryInfoArray,
  PlatformAccountClosureAdmin$,
  PlatformOwnership,
  PlatformAdmin$,
  ConsumableEntitlementRevocationConfig,
  DurableEntitlementRevocationConfig,
  EntitlementRevocationConfig,
  WalletRevocationConfig,
  RevocationConfigInfo,
  RevocationError,
  RevokeCurrency,
  RevokeEntitlement,
  RevokeItem,
  RevokeEntry,
  RevocationHistoryInfo,
  RevocationHistoryPagingSlicedResult,
  RevocationAdmin$,
  ConditionMatchResult,
  RewardItem,
  RewardCondition,
  RewardInfo,
  RewardPagingSlicedResult,
  RewardAdmin$,
  FixedPeriodRotationConfig,
  ItemNaming,
  SectionItem,
  FullSectionInfo,
  SectionPagingSlicedResult,
  SectionAdmin$,
  TlsConfig,
  GrpcServerInfo,
  AppConfig,
  BaseTlsConfig,
  PublicCustomConfigInfo,
  LootBoxPluginConfigInfo,
  RevocationPluginConfigInfo,
  SectionPluginConfigInfo,
  ServicePluginConfigInfo,
  ServicePluginConfigAdmin$,
  SessionPlatformAdmin$,
  CatalogConfigInfo,
  CatalogDefinitionInfo,
  CatalogDefinitionInfoArray,
  ImportErrorDetails,
  ImportStoreAppInfo,
  ImportStoreCategoryInfo,
  ImportStoreItemInfo,
  ImportStoreSectionInfo,
  ImportStoreViewInfo,
  ImportStoreError,
  ImportStoreHistoryInfo,
  ImportStoreHistoryPagingResult,
  ImportStoreResult,
  StoreBackupInfo,
  StoreInfoArray,
  StoreAdmin$,
  BillingAccount,
  BillingHistoryInfo,
  BillingHistoryPagingSlicedResult,
  RecurringChargeResult,
  Subscribable,
  SubscriptionActivityInfo,
  SubscriptionActivityPagingSlicedResult,
  SubscriptionInfo,
  SubscriptionPagingSlicedResult,
  SubscriptionAdmin$,
  TicketAcquireResult,
  TicketBoothId,
  TicketDynamicInfo,
  TicketSaleIncrementResult,
  TicketAdmin$,
  CreditPayload,
  DebitPayload,
  FulFillItemPayload,
  RevokeEntitlementPayload,
  Operation,
  Action,
  TradeChainActionHistoryInfo,
  TradeActionPagingSlicedResult,
  TradeActionAdmin$,
  FullViewInfo,
  ListViewInfo,
  ListViewInfoArray,
  ViewAdmin$,
  CreditRequest,
  CreditResult,
  BulkCreditResult,
  DebitByCurrencyCodeRequest,
  DebitResult,
  BulkDebitResult,
  WalletInfo,
  CurrencyWallet,
  CurrencyWalletArray,
  DetailedWalletTransactionInfo,
  DetailedWalletTransactionPagingSlicedResult,
  PlatformWallet,
  PlatformWalletConfigInfo,
  WalletPagingSlicedResult,
  TransactionAmountDetails,
  WalletTransactionInfo,
  WalletTransactionPagingSlicedResult,
  WalletAdmin$,
  EntitlementAdminApi,
  FulfillmentAdminApi,
  FulfillmentScriptAdminApi,
  IapAdminApi,
  IapNotificationAdminApi,
  IapSubscriptionAdminApi,
  InvoiceAdminApi,
  ItemAdminApi,
  KeyGroupAdminApi,
  OrderAdminApi,
  OrderDedicatedAdminApi,
  PaymentAdminApi,
  PaymentCallbackConfigAdminApi,
  PaymentConfigAdminApi,
  PaymentDedicatedAdminApi,
  PlatformAccountClosureAdminApi,
  PlatformAdminApi,
  RevocationAdminApi,
  RewardAdminApi,
  SectionAdminApi,
  ServicePluginConfigAdminApi,
  SessionPlatformAdminApi,
  StoreAdminApi,
  SubscriptionAdminApi,
  TicketAdminApi,
  TradeActionAdminApi,
  ViewAdminApi,
  WalletAdminApi,
  AppInfo,
  AppleIapConfigVersionInfo,
  BinarySchema,
  CategoryInfo,
  CategoryInfoArray,
  Customization,
  DlcConfigRewardShortInfo,
  EntitlementSplitResult,
  EntitlementTransferResult,
  EpicGamesReconcileResult,
  EpicGamesReconcileResultArray,
  EstimatedPriceInfoArray,
  GoogleReceiptResolveResult,
  HierarchicalCategoryInfo,
  HierarchicalCategoryInfoArray,
  IapItemFlatEntry,
  IapItemMappingInfo,
  ItemPagingSlicedResult,
  OculusReconcileResult,
  OculusReconcileResultArray,
  OrderDiscountPreviewResponse,
  OwnershipToken,
  PaymentAccount,
  PaymentAccountArray,
  PaymentMethod,
  PaymentMethodArray,
  PaymentOrderDetails,
  PaymentOrderPaidResult,
  PaymentProcessResult,
  PaymentUrl,
  PlayStationReconcileResult,
  PlayStationReconcileResultArray,
  PublicEntitlementHistoryInfo,
  SectionInfo,
  SectionInfoArray,
  SimpleDlcRewardItem,
  SimpleUserDlcRewardContent,
  SimpleUserDlcRewardContentsResponse,
  TaxResult,
  TwitchSyncResult,
  TwitchSyncResultArray,
  UserEntitlementHistoryPagingSlicedResult,
  UserEntitlementHistoryPagingSlicedResultArray,
  ViewInfo,
  ViewInfoArray,
  XblReconcileResult,
  XblReconcileResultArray,
  Category$,
  CategoryApi,
  Currency$,
  CurrencyApi,
  Dlc$,
  DlcApi,
  Entitlement$,
  Fulfillment$,
  Iap$,
  IapSubscription$,
  Item$,
  Order$,
  PaymentAccount$,
  PaymentStation$,
  Reward$,
  Section$,
  Store$,
  Subscription$,
  View$,
  Wallet$,
  EntitlementApi,
  FulfillmentApi,
  IapApi,
  IapSubscriptionApi,
  ItemApi,
  OrderApi,
  PaymentAccountApi,
  PaymentStationApi,
  RewardApi,
  SectionApi,
  StoreApi,
  SubscriptionApi,
  ViewApi,
  WalletApi
};

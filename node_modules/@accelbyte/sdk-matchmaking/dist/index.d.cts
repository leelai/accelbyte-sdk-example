import { AccelByteSDK, SdkSetConfigParam, Response } from '@accelbyte/sdk';
import { AxiosResponse, AxiosInstance } from 'axios';
import { C as Configuration, B as BackFillCreateRequest, a as BackfillCreateResponse, b as BackfillProposalResponse, c as BackfillGetResponse, d as BackFillAcceptRequest, G as GameSession, e as BackFillRejectRequest, N as NamespaceConfigList, f as NamespaceConfig, P as PatchNamespaceConfigRequest, L as ListEnvironmentVariablesResponse, g as ListMatchFunctionsResponse, M as MatchFunctionRequest, h as MatchFunctionConfig, i as ListMatchPoolsResponse, j as MatchPool, k as MatchPoolConfig, T as TicketMetricResultRecord, l as ListMatchPoolTicketsResponse, m as PlayerMetricRecord, n as MatchTicketRequest, o as MatchTicketResponse, p as MatchTicketStatuses, q as MatchTicketStatus, r as ListRuleSetsResponse, R as RuleSetPayload } from './TicketMetricResultRecord-BQOOYbA1.cjs';
import { z } from 'zod';

/**
 * AUTO GENERATED
 */

declare function ConfigAdminApi(sdk: AccelByteSDK, args?: SdkSetConfigParam): {
    /**
     * Get Log Configuration.&lt;br&gt;
     */
    getConfigLog: () => Promise<AxiosResponse<Configuration>>;
    /**
     * Update Log Configuration.&lt;br&gt;
     */
    patchConfigLog: (data: Configuration) => Promise<AxiosResponse<Configuration>>;
};

/**
 * AUTO GENERATED
 */

declare class ConfigAdmin$ {
    private axiosInstance;
    private namespace;
    private useSchemaValidation;
    constructor(axiosInstance: AxiosInstance, namespace: string, useSchemaValidation?: boolean);
    /**
     * Get Log Configuration.&lt;br&gt;
     */
    getConfigLog(): Promise<Response<Configuration>>;
    /**
     * Update Log Configuration.&lt;br&gt;
     */
    patchConfigLog(data: Configuration): Promise<Response<Configuration>>;
}

declare const DsInformation: z.ZodObject<{
    MinPlayers: z.ZodNumber;
    RequestedAt: z.ZodString;
    RequestedRegions: z.ZodArray<z.ZodString, "many">;
    Server: z.ZodObject<{
        alternate_ips: z.ZodArray<z.ZodString, "many">;
        custom_attribute: z.ZodString;
        deployment: z.ZodString;
        game_version: z.ZodString;
        image_version: z.ZodString;
        ip: z.ZodString;
        is_override_game_version: z.ZodBoolean;
        last_update: z.ZodString;
        namespace: z.ZodString;
        pod_name: z.ZodString;
        port: z.ZodNumber;
        ports: z.ZodRecord<z.ZodString, z.ZodNumber>;
        protocol: z.ZodString;
        provider: z.ZodString;
        region: z.ZodString;
        session_id: z.ZodString;
        status: z.ZodString;
    }, "strip", z.ZodTypeAny, {
        namespace: string;
        status: string;
        deployment: string;
        alternate_ips: string[];
        custom_attribute: string;
        game_version: string;
        image_version: string;
        ip: string;
        is_override_game_version: boolean;
        last_update: string;
        pod_name: string;
        port: number;
        ports: Record<string, number>;
        protocol: string;
        provider: string;
        region: string;
        session_id: string;
    }, {
        namespace: string;
        status: string;
        deployment: string;
        alternate_ips: string[];
        custom_attribute: string;
        game_version: string;
        image_version: string;
        ip: string;
        is_override_game_version: boolean;
        last_update: string;
        pod_name: string;
        port: number;
        ports: Record<string, number>;
        protocol: string;
        provider: string;
        region: string;
        session_id: string;
    }>;
    Status: z.ZodString;
}, "strip", z.ZodTypeAny, {
    Server: {
        namespace: string;
        status: string;
        deployment: string;
        alternate_ips: string[];
        custom_attribute: string;
        game_version: string;
        image_version: string;
        ip: string;
        is_override_game_version: boolean;
        last_update: string;
        pod_name: string;
        port: number;
        ports: Record<string, number>;
        protocol: string;
        provider: string;
        region: string;
        session_id: string;
    };
    Status: string;
    MinPlayers: number;
    RequestedAt: string;
    RequestedRegions: string[];
}, {
    Server: {
        namespace: string;
        status: string;
        deployment: string;
        alternate_ips: string[];
        custom_attribute: string;
        game_version: string;
        image_version: string;
        ip: string;
        is_override_game_version: boolean;
        last_update: string;
        pod_name: string;
        port: number;
        ports: Record<string, number>;
        protocol: string;
        provider: string;
        region: string;
        session_id: string;
    };
    Status: string;
    MinPlayers: number;
    RequestedAt: string;
    RequestedRegions: string[];
}>;
interface DsInformation extends z.TypeOf<typeof DsInformation> {
}

declare const EnvironmentVariable: z.ZodObject<{
    actualValue: z.ZodOptional<z.ZodNullable<z.ZodString>>;
    defaultValue: z.ZodOptional<z.ZodNullable<z.ZodString>>;
    description: z.ZodOptional<z.ZodNullable<z.ZodString>>;
    name: z.ZodString;
}, "strip", z.ZodTypeAny, {
    name: string;
    actualValue?: string | null | undefined;
    defaultValue?: string | null | undefined;
    description?: string | null | undefined;
}, {
    name: string;
    actualValue?: string | null | undefined;
    defaultValue?: string | null | undefined;
    description?: string | null | undefined;
}>;
interface EnvironmentVariable extends z.TypeOf<typeof EnvironmentVariable> {
}

declare const Error: z.ZodObject<{
    ErrorCode: z.ZodNumber;
    ErrorMessage: z.ZodString;
}, "strip", z.ZodTypeAny, {
    ErrorCode: number;
    ErrorMessage: string;
}, {
    ErrorCode: number;
    ErrorMessage: string;
}>;
interface Error extends z.TypeOf<typeof Error> {
}

declare const Match: z.ZodObject<{
    backfill: z.ZodOptional<z.ZodNullable<z.ZodBoolean>>;
    clientVersion: z.ZodOptional<z.ZodNullable<z.ZodString>>;
    matchAttributes: z.ZodOptional<z.ZodNullable<z.ZodRecord<z.ZodString, z.ZodAny>>>;
    regionPreference: z.ZodOptional<z.ZodNullable<z.ZodArray<z.ZodString, "many">>>;
    serverName: z.ZodOptional<z.ZodNullable<z.ZodString>>;
    teams: z.ZodOptional<z.ZodNullable<z.ZodArray<z.ZodObject<{
        Parties: z.ZodOptional<z.ZodNullable<z.ZodArray<z.ZodObject<{
            partyID: z.ZodOptional<z.ZodNullable<z.ZodString>>;
            userIDs: z.ZodOptional<z.ZodNullable<z.ZodArray<z.ZodString, "many">>>;
        }, "strip", z.ZodTypeAny, {
            partyID?: string | null | undefined;
            userIDs?: string[] | null | undefined;
        }, {
            partyID?: string | null | undefined;
            userIDs?: string[] | null | undefined;
        }>, "many">>>;
        UserIDs: z.ZodOptional<z.ZodNullable<z.ZodArray<z.ZodString, "many">>>;
    }, "strip", z.ZodTypeAny, {
        Parties?: {
            partyID?: string | null | undefined;
            userIDs?: string[] | null | undefined;
        }[] | null | undefined;
        UserIDs?: string[] | null | undefined;
    }, {
        Parties?: {
            partyID?: string | null | undefined;
            userIDs?: string[] | null | undefined;
        }[] | null | undefined;
        UserIDs?: string[] | null | undefined;
    }>, "many">>>;
    tickets: z.ZodOptional<z.ZodNullable<z.ZodArray<z.ZodObject<{
        CreatedAt: z.ZodString;
        ExcludedSessions: z.ZodArray<z.ZodString, "many">;
        IsActive: z.ZodBoolean;
        IsPivot: z.ZodBoolean;
        IsSinglePlay: z.ZodBoolean;
        Latencies: z.ZodRecord<z.ZodString, z.ZodNumber>;
        MatchPool: z.ZodString;
        MatchedAt: z.ZodString;
        Namespace: z.ZodString;
        PartySessionID: z.ZodString;
        Players: z.ZodArray<z.ZodObject<{
            Attributes: z.ZodRecord<z.ZodString, z.ZodAny>;
            PartyID: z.ZodString;
            PlatformID: z.ZodString;
            PlayerID: z.ZodString;
        }, "strip", z.ZodTypeAny, {
            Attributes: Record<string, any>;
            PartyID: string;
            PlatformID: string;
            PlayerID: string;
        }, {
            Attributes: Record<string, any>;
            PartyID: string;
            PlatformID: string;
            PlayerID: string;
        }>, "many">;
        ProposedProposal: z.ZodObject<{
            BackfillID: z.ZodString;
            ProposalID: z.ZodString;
            Status: z.ZodString;
        }, "strip", z.ZodTypeAny, {
            BackfillID: string;
            ProposalID: string;
            Status: string;
        }, {
            BackfillID: string;
            ProposalID: string;
            Status: string;
        }>;
        TicketAttributes: z.ZodRecord<z.ZodString, z.ZodAny>;
        TicketID: z.ZodString;
        TicketInformation: z.ZodRecord<z.ZodString, z.ZodAny>;
    }, "strip", z.ZodTypeAny, {
        CreatedAt: string;
        ExcludedSessions: string[];
        IsActive: boolean;
        IsPivot: boolean;
        IsSinglePlay: boolean;
        Latencies: Record<string, number>;
        MatchPool: string;
        MatchedAt: string;
        Namespace: string;
        PartySessionID: string;
        Players: {
            Attributes: Record<string, any>;
            PartyID: string;
            PlatformID: string;
            PlayerID: string;
        }[];
        ProposedProposal: {
            BackfillID: string;
            ProposalID: string;
            Status: string;
        };
        TicketAttributes: Record<string, any>;
        TicketID: string;
        TicketInformation: Record<string, any>;
    }, {
        CreatedAt: string;
        ExcludedSessions: string[];
        IsActive: boolean;
        IsPivot: boolean;
        IsSinglePlay: boolean;
        Latencies: Record<string, number>;
        MatchPool: string;
        MatchedAt: string;
        Namespace: string;
        PartySessionID: string;
        Players: {
            Attributes: Record<string, any>;
            PartyID: string;
            PlatformID: string;
            PlayerID: string;
        }[];
        ProposedProposal: {
            BackfillID: string;
            ProposalID: string;
            Status: string;
        };
        TicketAttributes: Record<string, any>;
        TicketID: string;
        TicketInformation: Record<string, any>;
    }>, "many">>>;
}, "strip", z.ZodTypeAny, {
    clientVersion?: string | null | undefined;
    backfill?: boolean | null | undefined;
    matchAttributes?: Record<string, any> | null | undefined;
    regionPreference?: string[] | null | undefined;
    serverName?: string | null | undefined;
    teams?: {
        Parties?: {
            partyID?: string | null | undefined;
            userIDs?: string[] | null | undefined;
        }[] | null | undefined;
        UserIDs?: string[] | null | undefined;
    }[] | null | undefined;
    tickets?: {
        CreatedAt: string;
        ExcludedSessions: string[];
        IsActive: boolean;
        IsPivot: boolean;
        IsSinglePlay: boolean;
        Latencies: Record<string, number>;
        MatchPool: string;
        MatchedAt: string;
        Namespace: string;
        PartySessionID: string;
        Players: {
            Attributes: Record<string, any>;
            PartyID: string;
            PlatformID: string;
            PlayerID: string;
        }[];
        ProposedProposal: {
            BackfillID: string;
            ProposalID: string;
            Status: string;
        };
        TicketAttributes: Record<string, any>;
        TicketID: string;
        TicketInformation: Record<string, any>;
    }[] | null | undefined;
}, {
    clientVersion?: string | null | undefined;
    backfill?: boolean | null | undefined;
    matchAttributes?: Record<string, any> | null | undefined;
    regionPreference?: string[] | null | undefined;
    serverName?: string | null | undefined;
    teams?: {
        Parties?: {
            partyID?: string | null | undefined;
            userIDs?: string[] | null | undefined;
        }[] | null | undefined;
        UserIDs?: string[] | null | undefined;
    }[] | null | undefined;
    tickets?: {
        CreatedAt: string;
        ExcludedSessions: string[];
        IsActive: boolean;
        IsPivot: boolean;
        IsSinglePlay: boolean;
        Latencies: Record<string, number>;
        MatchPool: string;
        MatchedAt: string;
        Namespace: string;
        PartySessionID: string;
        Players: {
            Attributes: Record<string, any>;
            PartyID: string;
            PlatformID: string;
            PlayerID: string;
        }[];
        ProposedProposal: {
            BackfillID: string;
            ProposalID: string;
            Status: string;
        };
        TicketAttributes: Record<string, any>;
        TicketID: string;
        TicketInformation: Record<string, any>;
    }[] | null | undefined;
}>;
interface Match extends z.TypeOf<typeof Match> {
}

declare const MatchFunctionOverride: z.ZodObject<{
    backfill_matches: z.ZodOptional<z.ZodNullable<z.ZodString>>;
    enrichment: z.ZodOptional<z.ZodNullable<z.ZodArray<z.ZodString, "many">>>;
    make_matches: z.ZodOptional<z.ZodNullable<z.ZodString>>;
    stat_codes: z.ZodOptional<z.ZodNullable<z.ZodArray<z.ZodString, "many">>>;
    validation: z.ZodOptional<z.ZodNullable<z.ZodArray<z.ZodString, "many">>>;
}, "strip", z.ZodTypeAny, {
    validation?: string[] | null | undefined;
    backfill_matches?: string | null | undefined;
    enrichment?: string[] | null | undefined;
    make_matches?: string | null | undefined;
    stat_codes?: string[] | null | undefined;
}, {
    validation?: string[] | null | undefined;
    backfill_matches?: string | null | undefined;
    enrichment?: string[] | null | undefined;
    make_matches?: string | null | undefined;
    stat_codes?: string[] | null | undefined;
}>;
interface MatchFunctionOverride extends z.TypeOf<typeof MatchFunctionOverride> {
}

declare const MatchRuleSetNameData: z.ZodObject<{
    name: z.ZodString;
}, "strip", z.ZodTypeAny, {
    name: string;
}, {
    name: string;
}>;
interface MatchRuleSetNameData extends z.TypeOf<typeof MatchRuleSetNameData> {
}

declare const MatchTicketRecord: z.ZodObject<{
    CreatedAt: z.ZodString;
    IsActive: z.ZodBoolean;
    PartySessionID: z.ZodString;
    ProposedProposal: z.ZodObject<{
        BackfillID: z.ZodString;
        ProposalID: z.ZodString;
        Status: z.ZodString;
    }, "strip", z.ZodTypeAny, {
        BackfillID: string;
        ProposalID: string;
        Status: string;
    }, {
        BackfillID: string;
        ProposalID: string;
        Status: string;
    }>;
    SessionID: z.ZodString;
    Ticket: z.ZodObject<{
        CreatedAt: z.ZodString;
        ExcludedSessions: z.ZodArray<z.ZodString, "many">;
        IsActive: z.ZodBoolean;
        IsPivot: z.ZodBoolean;
        IsSinglePlay: z.ZodBoolean;
        Latencies: z.ZodRecord<z.ZodString, z.ZodNumber>;
        MatchPool: z.ZodString;
        MatchedAt: z.ZodString;
        Namespace: z.ZodString;
        PartySessionID: z.ZodString;
        Players: z.ZodArray<z.ZodObject<{
            Attributes: z.ZodRecord<z.ZodString, z.ZodAny>;
            PartyID: z.ZodString;
            PlatformID: z.ZodString;
            PlayerID: z.ZodString;
        }, "strip", z.ZodTypeAny, {
            Attributes: Record<string, any>;
            PartyID: string;
            PlatformID: string;
            PlayerID: string;
        }, {
            Attributes: Record<string, any>;
            PartyID: string;
            PlatformID: string;
            PlayerID: string;
        }>, "many">;
        ProposedProposal: z.ZodObject<{
            BackfillID: z.ZodString;
            ProposalID: z.ZodString;
            Status: z.ZodString;
        }, "strip", z.ZodTypeAny, {
            BackfillID: string;
            ProposalID: string;
            Status: string;
        }, {
            BackfillID: string;
            ProposalID: string;
            Status: string;
        }>;
        TicketAttributes: z.ZodRecord<z.ZodString, z.ZodAny>;
        TicketID: z.ZodString;
        TicketInformation: z.ZodRecord<z.ZodString, z.ZodAny>;
    }, "strip", z.ZodTypeAny, {
        CreatedAt: string;
        ExcludedSessions: string[];
        IsActive: boolean;
        IsPivot: boolean;
        IsSinglePlay: boolean;
        Latencies: Record<string, number>;
        MatchPool: string;
        MatchedAt: string;
        Namespace: string;
        PartySessionID: string;
        Players: {
            Attributes: Record<string, any>;
            PartyID: string;
            PlatformID: string;
            PlayerID: string;
        }[];
        ProposedProposal: {
            BackfillID: string;
            ProposalID: string;
            Status: string;
        };
        TicketAttributes: Record<string, any>;
        TicketID: string;
        TicketInformation: Record<string, any>;
    }, {
        CreatedAt: string;
        ExcludedSessions: string[];
        IsActive: boolean;
        IsPivot: boolean;
        IsSinglePlay: boolean;
        Latencies: Record<string, number>;
        MatchPool: string;
        MatchedAt: string;
        Namespace: string;
        PartySessionID: string;
        Players: {
            Attributes: Record<string, any>;
            PartyID: string;
            PlatformID: string;
            PlayerID: string;
        }[];
        ProposedProposal: {
            BackfillID: string;
            ProposalID: string;
            Status: string;
        };
        TicketAttributes: Record<string, any>;
        TicketID: string;
        TicketInformation: Record<string, any>;
    }>;
    TicketID: z.ZodString;
    UniqueTicketID: z.ZodString;
}, "strip", z.ZodTypeAny, {
    CreatedAt: string;
    IsActive: boolean;
    PartySessionID: string;
    ProposedProposal: {
        BackfillID: string;
        ProposalID: string;
        Status: string;
    };
    TicketID: string;
    SessionID: string;
    Ticket: {
        CreatedAt: string;
        ExcludedSessions: string[];
        IsActive: boolean;
        IsPivot: boolean;
        IsSinglePlay: boolean;
        Latencies: Record<string, number>;
        MatchPool: string;
        MatchedAt: string;
        Namespace: string;
        PartySessionID: string;
        Players: {
            Attributes: Record<string, any>;
            PartyID: string;
            PlatformID: string;
            PlayerID: string;
        }[];
        ProposedProposal: {
            BackfillID: string;
            ProposalID: string;
            Status: string;
        };
        TicketAttributes: Record<string, any>;
        TicketID: string;
        TicketInformation: Record<string, any>;
    };
    UniqueTicketID: string;
}, {
    CreatedAt: string;
    IsActive: boolean;
    PartySessionID: string;
    ProposedProposal: {
        BackfillID: string;
        ProposalID: string;
        Status: string;
    };
    TicketID: string;
    SessionID: string;
    Ticket: {
        CreatedAt: string;
        ExcludedSessions: string[];
        IsActive: boolean;
        IsPivot: boolean;
        IsSinglePlay: boolean;
        Latencies: Record<string, number>;
        MatchPool: string;
        MatchedAt: string;
        Namespace: string;
        PartySessionID: string;
        Players: {
            Attributes: Record<string, any>;
            PartyID: string;
            PlatformID: string;
            PlayerID: string;
        }[];
        ProposedProposal: {
            BackfillID: string;
            ProposalID: string;
            Status: string;
        };
        TicketAttributes: Record<string, any>;
        TicketID: string;
        TicketInformation: Record<string, any>;
    };
    UniqueTicketID: string;
}>;
interface MatchTicketRecord extends z.TypeOf<typeof MatchTicketRecord> {
}

declare const Pagination: z.ZodObject<{
    first: z.ZodString;
    last: z.ZodString;
    next: z.ZodString;
    previous: z.ZodString;
}, "strip", z.ZodTypeAny, {
    first: string;
    last: string;
    next: string;
    previous: string;
}, {
    first: string;
    last: string;
    next: string;
    previous: string;
}>;
interface Pagination extends z.TypeOf<typeof Pagination> {
}

declare const Party: z.ZodObject<{
    partyID: z.ZodOptional<z.ZodNullable<z.ZodString>>;
    userIDs: z.ZodOptional<z.ZodNullable<z.ZodArray<z.ZodString, "many">>>;
}, "strip", z.ZodTypeAny, {
    partyID?: string | null | undefined;
    userIDs?: string[] | null | undefined;
}, {
    partyID?: string | null | undefined;
    userIDs?: string[] | null | undefined;
}>;
interface Party extends z.TypeOf<typeof Party> {
}

declare const PlayerData: z.ZodObject<{
    Attributes: z.ZodRecord<z.ZodString, z.ZodAny>;
    PartyID: z.ZodString;
    PlatformID: z.ZodString;
    PlayerID: z.ZodString;
}, "strip", z.ZodTypeAny, {
    Attributes: Record<string, any>;
    PartyID: string;
    PlatformID: string;
    PlayerID: string;
}, {
    Attributes: Record<string, any>;
    PartyID: string;
    PlatformID: string;
    PlayerID: string;
}>;
interface PlayerData extends z.TypeOf<typeof PlayerData> {
}

declare const ProposedProposal: z.ZodObject<{
    BackfillID: z.ZodString;
    ProposalID: z.ZodString;
    Status: z.ZodString;
}, "strip", z.ZodTypeAny, {
    BackfillID: string;
    ProposalID: string;
    Status: string;
}, {
    BackfillID: string;
    ProposalID: string;
    Status: string;
}>;
interface ProposedProposal extends z.TypeOf<typeof ProposedProposal> {
}

declare const RuleSetPayloadData: z.ZodAny;
interface RuleSetPayloadData extends z.TypeOf<typeof RuleSetPayloadData> {
}

declare const Server: z.ZodObject<{
    alternate_ips: z.ZodArray<z.ZodString, "many">;
    custom_attribute: z.ZodString;
    deployment: z.ZodString;
    game_version: z.ZodString;
    image_version: z.ZodString;
    ip: z.ZodString;
    is_override_game_version: z.ZodBoolean;
    last_update: z.ZodString;
    namespace: z.ZodString;
    pod_name: z.ZodString;
    port: z.ZodNumber;
    ports: z.ZodRecord<z.ZodString, z.ZodNumber>;
    protocol: z.ZodString;
    provider: z.ZodString;
    region: z.ZodString;
    session_id: z.ZodString;
    status: z.ZodString;
}, "strip", z.ZodTypeAny, {
    namespace: string;
    status: string;
    deployment: string;
    alternate_ips: string[];
    custom_attribute: string;
    game_version: string;
    image_version: string;
    ip: string;
    is_override_game_version: boolean;
    last_update: string;
    pod_name: string;
    port: number;
    ports: Record<string, number>;
    protocol: string;
    provider: string;
    region: string;
    session_id: string;
}, {
    namespace: string;
    status: string;
    deployment: string;
    alternate_ips: string[];
    custom_attribute: string;
    game_version: string;
    image_version: string;
    ip: string;
    is_override_game_version: boolean;
    last_update: string;
    pod_name: string;
    port: number;
    ports: Record<string, number>;
    protocol: string;
    provider: string;
    region: string;
    session_id: string;
}>;
interface Server extends z.TypeOf<typeof Server> {
}

declare const Team: z.ZodObject<{
    Parties: z.ZodOptional<z.ZodNullable<z.ZodArray<z.ZodObject<{
        partyID: z.ZodOptional<z.ZodNullable<z.ZodString>>;
        userIDs: z.ZodOptional<z.ZodNullable<z.ZodArray<z.ZodString, "many">>>;
    }, "strip", z.ZodTypeAny, {
        partyID?: string | null | undefined;
        userIDs?: string[] | null | undefined;
    }, {
        partyID?: string | null | undefined;
        userIDs?: string[] | null | undefined;
    }>, "many">>>;
    UserIDs: z.ZodOptional<z.ZodNullable<z.ZodArray<z.ZodString, "many">>>;
}, "strip", z.ZodTypeAny, {
    Parties?: {
        partyID?: string | null | undefined;
        userIDs?: string[] | null | undefined;
    }[] | null | undefined;
    UserIDs?: string[] | null | undefined;
}, {
    Parties?: {
        partyID?: string | null | undefined;
        userIDs?: string[] | null | undefined;
    }[] | null | undefined;
    UserIDs?: string[] | null | undefined;
}>;
interface Team extends z.TypeOf<typeof Team> {
}

declare const Ticket: z.ZodObject<{
    CreatedAt: z.ZodString;
    ExcludedSessions: z.ZodArray<z.ZodString, "many">;
    IsActive: z.ZodBoolean;
    IsPivot: z.ZodBoolean;
    IsSinglePlay: z.ZodBoolean;
    Latencies: z.ZodRecord<z.ZodString, z.ZodNumber>;
    MatchPool: z.ZodString;
    MatchedAt: z.ZodString;
    Namespace: z.ZodString;
    PartySessionID: z.ZodString;
    Players: z.ZodArray<z.ZodObject<{
        Attributes: z.ZodRecord<z.ZodString, z.ZodAny>;
        PartyID: z.ZodString;
        PlatformID: z.ZodString;
        PlayerID: z.ZodString;
    }, "strip", z.ZodTypeAny, {
        Attributes: Record<string, any>;
        PartyID: string;
        PlatformID: string;
        PlayerID: string;
    }, {
        Attributes: Record<string, any>;
        PartyID: string;
        PlatformID: string;
        PlayerID: string;
    }>, "many">;
    ProposedProposal: z.ZodObject<{
        BackfillID: z.ZodString;
        ProposalID: z.ZodString;
        Status: z.ZodString;
    }, "strip", z.ZodTypeAny, {
        BackfillID: string;
        ProposalID: string;
        Status: string;
    }, {
        BackfillID: string;
        ProposalID: string;
        Status: string;
    }>;
    TicketAttributes: z.ZodRecord<z.ZodString, z.ZodAny>;
    TicketID: z.ZodString;
    TicketInformation: z.ZodRecord<z.ZodString, z.ZodAny>;
}, "strip", z.ZodTypeAny, {
    CreatedAt: string;
    ExcludedSessions: string[];
    IsActive: boolean;
    IsPivot: boolean;
    IsSinglePlay: boolean;
    Latencies: Record<string, number>;
    MatchPool: string;
    MatchedAt: string;
    Namespace: string;
    PartySessionID: string;
    Players: {
        Attributes: Record<string, any>;
        PartyID: string;
        PlatformID: string;
        PlayerID: string;
    }[];
    ProposedProposal: {
        BackfillID: string;
        ProposalID: string;
        Status: string;
    };
    TicketAttributes: Record<string, any>;
    TicketID: string;
    TicketInformation: Record<string, any>;
}, {
    CreatedAt: string;
    ExcludedSessions: string[];
    IsActive: boolean;
    IsPivot: boolean;
    IsSinglePlay: boolean;
    Latencies: Record<string, number>;
    MatchPool: string;
    MatchedAt: string;
    Namespace: string;
    PartySessionID: string;
    Players: {
        Attributes: Record<string, any>;
        PartyID: string;
        PlatformID: string;
        PlayerID: string;
    }[];
    ProposedProposal: {
        BackfillID: string;
        ProposalID: string;
        Status: string;
    };
    TicketAttributes: Record<string, any>;
    TicketID: string;
    TicketInformation: Record<string, any>;
}>;
interface Ticket extends z.TypeOf<typeof Ticket> {
}

declare const User: z.ZodObject<{
    ID: z.ZodString;
    PlatformID: z.ZodString;
    PlatformUserID: z.ZodString;
    PreviousStatus: z.ZodOptional<z.ZodNullable<z.ZodString>>;
    Status: z.ZodString;
    StatusV2: z.ZodString;
    UpdatedAt: z.ZodString;
}, "strip", z.ZodTypeAny, {
    PlatformID: string;
    Status: string;
    ID: string;
    PlatformUserID: string;
    StatusV2: string;
    UpdatedAt: string;
    PreviousStatus?: string | null | undefined;
}, {
    PlatformID: string;
    Status: string;
    ID: string;
    PlatformUserID: string;
    StatusV2: string;
    UpdatedAt: string;
    PreviousStatus?: string | null | undefined;
}>;
interface User extends z.TypeOf<typeof User> {
}

/**
 * AUTO GENERATED
 */

declare function BackfillApi(sdk: AccelByteSDK, args?: SdkSetConfigParam): {
    /**
     * Create backfill ticket.
     */
    createBackfill: (data: BackFillCreateRequest) => Promise<AxiosResponse<BackfillCreateResponse>>;
    /**
     * Get backfill proposal
     */
    getBackfillProposal: (queryParams: {
        sessionID: string | null;
    }) => Promise<AxiosResponse<BackfillProposalResponse>>;
    /**
     * Delete backfill ticket.
     */
    deleteBackfill_ByBackfillId: (backfillID: string) => Promise<AxiosResponse<unknown>>;
    /**
     * Get backfill ticket by ID
     */
    getBackfill_ByBackfillId: (backfillID: string) => Promise<AxiosResponse<BackfillGetResponse>>;
    /**
     *  Accept backfill proposal. Field partialAcceptTicketIDs can be used to accept specific tickets within a backfill proposal. If the ticketIDs are not mentioned in this field, those tickets will be rejected and reactivated for future proposals.
     */
    updateProposalAccept_ByBackfillId: (backfillID: string, data: BackFillAcceptRequest) => Promise<AxiosResponse<GameSession>>;
    /**
     * Reject backfill proposal
     */
    updateProposalReject_ByBackfillId: (backfillID: string, data: BackFillRejectRequest) => Promise<AxiosResponse<unknown>>;
};

/**
 * AUTO GENERATED
 */

declare function ConfigApi(sdk: AccelByteSDK, args?: SdkSetConfigParam): {
    /**
     * Get matchmaking config of all namespaces. Will only return namespace configs than have been updated.
     */
    getConfig: () => Promise<AxiosResponse<NamespaceConfigList>>;
    /**
     * Get matchmaking config of a namespaces.
     */
    getConfig_ByNamespace: () => Promise<AxiosResponse<NamespaceConfig>>;
    /**
     * Patch update matchmaking config of a namespaces. Partially update matchmaking config, will only update value that defined on the request.
     */
    patchConfig_ByNamespace: (data: PatchNamespaceConfigRequest) => Promise<AxiosResponse<NamespaceConfig>>;
};

/**
 * AUTO GENERATED
 */

declare class Backfill$ {
    private axiosInstance;
    private namespace;
    private useSchemaValidation;
    constructor(axiosInstance: AxiosInstance, namespace: string, useSchemaValidation?: boolean);
    /**
     * Create backfill ticket.
     */
    createBackfill(data: BackFillCreateRequest): Promise<Response<BackfillCreateResponse>>;
    /**
     * Get backfill proposal
     */
    getBackfillProposal(queryParams: {
        sessionID: string | null;
    }): Promise<Response<BackfillProposalResponse>>;
    /**
     * Delete backfill ticket.
     */
    deleteBackfill_ByBackfillId(backfillID: string): Promise<Response<unknown>>;
    /**
     * Get backfill ticket by ID
     */
    getBackfill_ByBackfillId(backfillID: string): Promise<Response<BackfillGetResponse>>;
    /**
     *  Accept backfill proposal. Field partialAcceptTicketIDs can be used to accept specific tickets within a backfill proposal. If the ticketIDs are not mentioned in this field, those tickets will be rejected and reactivated for future proposals.
     */
    updateProposalAccept_ByBackfillId(backfillID: string, data: BackFillAcceptRequest): Promise<Response<GameSession>>;
    /**
     * Reject backfill proposal
     */
    updateProposalReject_ByBackfillId(backfillID: string, data: BackFillRejectRequest): Promise<Response<unknown>>;
}

/**
 * AUTO GENERATED
 */

declare class Config$ {
    private axiosInstance;
    private namespace;
    private useSchemaValidation;
    constructor(axiosInstance: AxiosInstance, namespace: string, useSchemaValidation?: boolean);
    /**
     * Get matchmaking config of all namespaces. Will only return namespace configs than have been updated.
     */
    getConfig(): Promise<Response<NamespaceConfigList>>;
    /**
     * Get matchmaking config of a namespaces.
     */
    getConfig_ByNamespace(): Promise<Response<NamespaceConfig>>;
    /**
     * Patch update matchmaking config of a namespaces. Partially update matchmaking config, will only update value that defined on the request.
     */
    patchConfig_ByNamespace(data: PatchNamespaceConfigRequest): Promise<Response<NamespaceConfig>>;
}

/**
 * AUTO GENERATED
 */

declare class EnvironmentVariables$ {
    private axiosInstance;
    private namespace;
    private useSchemaValidation;
    constructor(axiosInstance: AxiosInstance, namespace: string, useSchemaValidation?: boolean);
    /**
     * List environment variables.
     */
    getEnvironmentVariables(): Promise<Response<ListEnvironmentVariablesResponse>>;
}

/**
 * AUTO GENERATED
 */

declare class MatchFunctions$ {
    private axiosInstance;
    private namespace;
    private useSchemaValidation;
    constructor(axiosInstance: AxiosInstance, namespace: string, useSchemaValidation?: boolean);
    /**
     * List existing match functions.
     */
    getMatchFunctions(queryParams?: {
        limit?: number;
        offset?: number;
    }): Promise<Response<ListMatchFunctionsResponse>>;
    /**
     * Creates a new matchmaking function.
     */
    createMatchFunction(data: MatchFunctionRequest): Promise<Response<unknown>>;
    /**
     * Deletes an existing match function.
     */
    deleteMatchFunction_ByName(name: string): Promise<Response<unknown>>;
    /**
     * Update existing matchmaking function.
     */
    updateMatchFunction_ByName(name: string, data: MatchFunctionRequest): Promise<Response<MatchFunctionConfig>>;
}

/**
 * AUTO GENERATED
 */

declare class MatchPools$ {
    private axiosInstance;
    private namespace;
    private useSchemaValidation;
    constructor(axiosInstance: AxiosInstance, namespace: string, useSchemaValidation?: boolean);
    /**
     * List matchmaking pools.
     */
    getMatchPools(queryParams?: {
        limit?: number;
        name?: string | null;
        offset?: number;
    }): Promise<Response<ListMatchPoolsResponse>>;
    /**
     * Creates a new matchmaking pool. A pool is isolated from other pools (i.e. tickets may be matched with other tickets in the same pool, but not with tickets in other pools). Each pool has its own matchmaking rules and/or logic. ticket_expiration_seconds and backfill_ticket_expiration_seconds will be set to 300 seconds (5 minutes) by default if not filled. Match Function holds information about the name of the match logic server that matchmaking can refers to. By default we provide (&#34;default&#34; and &#34;basic&#34;). Match Function will be used as reference value for Match Function Overrides if not set. In case Customer would like to use matchmaking service default match logic, then specify it in &#34;match_function_overrides&#34;. This sample configuration will let matchmaking service will use &#34;default&#34; match logic for make matches, while validation will hit both &#34;default&#34; and &#34;custom&#34; match logics. e.g. { &#34;match_function&#34;: &#34;custom&#34;, &#34;match_function_overrides&#34;: { &#34;validation&#34;: []{&#34;default&#34;,&#34;custom&#34;}, &#34;make_matches&#34;: &#34;default&#34;, } }
     */
    createMatchPool(data: MatchPool): Promise<Response<unknown>>;
    /**
     * Deletes an existing matchmaking pool.
     */
    deleteMatchPool_ByPool(pool: string): Promise<Response<unknown>>;
    /**
     * Get details for a specific match pool
     */
    getMatchPool_ByPool(pool: string): Promise<Response<MatchPool>>;
    /**
     * Updates an existing matchmaking pool. ticket_expiration_seconds and backfill_ticket_expiration_seconds will be set to 300 seconds (5 minutes) by default if not filled. Match Function holds information about the name of the match logic server that matchmaking can refers to. By default we provide (&#34;default&#34; and &#34;basic&#34;). Match Function will be used as reference value for Match Function Overrides if not set. In case Customer would like to use matchmaking service default match logic, then specify it in &#34;match_function_overrides&#34;. This sample configuration will let matchmaking service will use &#34;default&#34; match logic for make matches, while validation will hit both &#34;default&#34; and &#34;custom&#34; match logics. e.g. { &#34;match_function&#34;: &#34;custom&#34;, &#34;match_function_overrides&#34;: { &#34;validation&#34;: []{&#34;default&#34;,&#34;custom&#34;}, &#34;make_matches&#34;: &#34;default&#34;, } }
     */
    updateMatchPool_ByPool(pool: string, data: MatchPoolConfig): Promise<Response<MatchPool>>;
    /**
     * Get metric for a specific match pool Result: queueTime in seconds
     */
    getMetrics_ByPool(pool: string): Promise<Response<TicketMetricResultRecord>>;
    /**
     * Get tickets in queue for a specific match pool Result: number of tickets and list of ticket detail in a match pool.
     */
    getTickets_ByPool(pool: string, queryParams?: {
        limit?: number;
        offset?: number;
    }): Promise<Response<ListMatchPoolTicketsResponse>>;
    /**
     * Get player metric for a specific match pool
     */
    getMetricsPlayer_ByPool(pool: string): Promise<Response<PlayerMetricRecord>>;
    /**
     * Public get player metric for a specific match pool
     */
    getMetricsPlayer_ByPool_ByNS(pool: string): Promise<Response<PlayerMetricRecord>>;
}

/**
 * AUTO GENERATED
 */

declare class MatchTickets$ {
    private axiosInstance;
    private namespace;
    private useSchemaValidation;
    constructor(axiosInstance: AxiosInstance, namespace: string, useSchemaValidation?: boolean);
    /**
     * Creates a new request for matchmaking. Cross Platform: Allow player to play game with &#34;all&#34; registered platforms. 1. Cross Platform can be enabled through session service or create match ticket. a. via ticket: specify several cross_platform on create match ticket attributes. **[DEPRECATED]** client should not send from attribute &lt;code&gt;cross_platform&lt;/code&gt; will be populated from backend This value will override player attributes in session service. e.g. cross_platform:[xbox,psn,steam] b. via session service: set player/party cross_platform attributes. c. Enable match options ruleset with name cross_platform and type &#34;all&#34;. ``` { &#34;name&#34;: &#34;co-op&#34;, &#34;data&#34;: { &#34;alliance&#34;: { &#34;min_number&#34;: 1, &#34;max_number&#34;: 1, &#34;player_min_number&#34;: 1, &#34;player_max_number&#34;: 4 }, &#34;match_options&#34;: { &#34;options&#34;: [ {&#34;name&#34;: &#34;cross_platform&#34;, &#34;type&#34;: &#34;all&#34;} ] } } } ``` 2. Cross Platform can be disabled from the matchpool configuration &lt;code&gt;crossplay_disabled=true&lt;/code&gt; 3. When matchpool &lt;code&gt;crossplay_disabled=false&lt;/code&gt; * request attribute cross_platform is empty **[Recommended]**: * Matchmaking will consider Party leader &lt;code&gt;crossplayEnabled&lt;/code&gt; preference or Session attribute &lt;code&gt;crossplayEnabled&lt;/code&gt; preference. * When &lt;code&gt;crossplayEnabled=true&lt;/code&gt; &lt;code&gt;cross_platforms&lt;/code&gt; attributes will be populated from [active login methods](/iam/apidocs/#/Third%20Party%20Credential/RetrieveAllActiveThirdPartyLoginPlatformCredentialPublicV3) otherwise it will set to leader current platform * When &lt;code&gt;crossplayEnabled=false&lt;/code&gt; &lt;code&gt;cross_platforms&lt;/code&gt; attributes will be set to user&#39;s currentPlatform * request attribute cross_platform is not empty **[Not Recommended]**: * Cross Platform can be disabled with specify only ONE cross_platform. Current matchmaking use this behavior. e.g. cross_platform:[xbox] * Multiple cross_platform values is considered to be crossplay enabled 4. This behavior only works for Default Matchmaker. Custom matchmaker (custom gRPC matchmaker) need to consider this on its own implementation. ExcludedSessions: allow player to list out game sessions that they want to avoid matching, for example a match that they&#39;ve recently left or get kicked out from.
     */
    createMatchTicket(data: MatchTicketRequest): Promise<Response<MatchTicketResponse>>;
    /**
     * Get my match tickets.
     */
    getMatchTicketsMe(queryParams?: {
        limit?: number;
        matchPool?: string | null;
        offset?: number;
    }): Promise<Response<MatchTicketStatuses>>;
    /**
     * Deletes an existing matchmaking ticket.
     */
    deleteMatchTicket_ByTicketid(ticketid: string): Promise<Response<unknown>>;
    /**
     * Get details for a specific match ticket
     */
    getMatchTicket_ByTicketid(ticketid: string): Promise<Response<MatchTicketStatus>>;
}

/**
 * AUTO GENERATED
 */

declare class RuleSets$ {
    private axiosInstance;
    private namespace;
    private useSchemaValidation;
    constructor(axiosInstance: AxiosInstance, namespace: string, useSchemaValidation?: boolean);
    /**
     * List rule sets.
     */
    getRulesets(queryParams?: {
        limit?: number;
        name?: string | null;
        offset?: number;
    }): Promise<Response<ListRuleSetsResponse>>;
    /**
     * Creates a new rules set. A rule set has a name and contains arbitrary data which is meaningful to some particular match function(s) The name is used for a match pool to select the ruleset data that should be sent to the match function when matchmaking in that pool. To use custom rules set please set enable_custom_match_function=true. Default (false). When custom enable_custom_match_function=true, the ruleset will only validate if the rule is valid json.
     */
    createRuleset(data: RuleSetPayload): Promise<Response<unknown>>;
    /**
     * Deletes an existing rule set.
     */
    deleteRuleset_ByRuleset(ruleset: string): Promise<Response<unknown>>;
    /**
     * Get details for a specific rule set
     */
    getRuleset_ByRuleset(ruleset: string): Promise<Response<RuleSetPayload>>;
    /**
     * Updates an existing matchmaking rule set. To use custom rules set please set enable_custom_match_function=true. Default (false). When custom enable_custom_match_function=true, the ruleset will only validate if the rule is valid json.
     */
    updateRuleset_ByRuleset(ruleset: string, data: RuleSetPayload): Promise<Response<RuleSetPayload>>;
}

/**
 * AUTO GENERATED
 */

declare function EnvironmentVariablesApi(sdk: AccelByteSDK, args?: SdkSetConfigParam): {
    /**
     * List environment variables.
     */
    getEnvironmentVariables: () => Promise<AxiosResponse<ListEnvironmentVariablesResponse>>;
};

/**
 * AUTO GENERATED
 */

declare function MatchFunctionsApi(sdk: AccelByteSDK, args?: SdkSetConfigParam): {
    /**
     * List existing match functions.
     */
    getMatchFunctions: (queryParams?: {
        limit?: number;
        offset?: number;
    }) => Promise<AxiosResponse<ListMatchFunctionsResponse>>;
    /**
     * Creates a new matchmaking function.
     */
    createMatchFunction: (data: MatchFunctionRequest) => Promise<AxiosResponse<unknown>>;
    /**
     * Deletes an existing match function.
     */
    deleteMatchFunction_ByName: (name: string) => Promise<AxiosResponse<unknown>>;
    /**
     * Update existing matchmaking function.
     */
    updateMatchFunction_ByName: (name: string, data: MatchFunctionRequest) => Promise<AxiosResponse<MatchFunctionConfig>>;
};

/**
 * AUTO GENERATED
 */

declare function MatchPoolsApi(sdk: AccelByteSDK, args?: SdkSetConfigParam): {
    /**
     * List matchmaking pools.
     */
    getMatchPools: (queryParams?: {
        limit?: number;
        name?: string | null;
        offset?: number;
    }) => Promise<AxiosResponse<ListMatchPoolsResponse>>;
    /**
     * Creates a new matchmaking pool. A pool is isolated from other pools (i.e. tickets may be matched with other tickets in the same pool, but not with tickets in other pools). Each pool has its own matchmaking rules and/or logic. ticket_expiration_seconds and backfill_ticket_expiration_seconds will be set to 300 seconds (5 minutes) by default if not filled. Match Function holds information about the name of the match logic server that matchmaking can refers to. By default we provide (&#34;default&#34; and &#34;basic&#34;). Match Function will be used as reference value for Match Function Overrides if not set. In case Customer would like to use matchmaking service default match logic, then specify it in &#34;match_function_overrides&#34;. This sample configuration will let matchmaking service will use &#34;default&#34; match logic for make matches, while validation will hit both &#34;default&#34; and &#34;custom&#34; match logics. e.g. { &#34;match_function&#34;: &#34;custom&#34;, &#34;match_function_overrides&#34;: { &#34;validation&#34;: []{&#34;default&#34;,&#34;custom&#34;}, &#34;make_matches&#34;: &#34;default&#34;, } }
     */
    createMatchPool: (data: MatchPool) => Promise<AxiosResponse<unknown>>;
    /**
     * Deletes an existing matchmaking pool.
     */
    deleteMatchPool_ByPool: (pool: string) => Promise<AxiosResponse<unknown>>;
    /**
     * Get details for a specific match pool
     */
    getMatchPool_ByPool: (pool: string) => Promise<AxiosResponse<MatchPool>>;
    /**
     * Updates an existing matchmaking pool. ticket_expiration_seconds and backfill_ticket_expiration_seconds will be set to 300 seconds (5 minutes) by default if not filled. Match Function holds information about the name of the match logic server that matchmaking can refers to. By default we provide (&#34;default&#34; and &#34;basic&#34;). Match Function will be used as reference value for Match Function Overrides if not set. In case Customer would like to use matchmaking service default match logic, then specify it in &#34;match_function_overrides&#34;. This sample configuration will let matchmaking service will use &#34;default&#34; match logic for make matches, while validation will hit both &#34;default&#34; and &#34;custom&#34; match logics. e.g. { &#34;match_function&#34;: &#34;custom&#34;, &#34;match_function_overrides&#34;: { &#34;validation&#34;: []{&#34;default&#34;,&#34;custom&#34;}, &#34;make_matches&#34;: &#34;default&#34;, } }
     */
    updateMatchPool_ByPool: (pool: string, data: MatchPoolConfig) => Promise<AxiosResponse<MatchPool>>;
    /**
     * Get metric for a specific match pool Result: queueTime in seconds
     */
    getMetrics_ByPool: (pool: string) => Promise<AxiosResponse<TicketMetricResultRecord>>;
    /**
     * Get tickets in queue for a specific match pool Result: number of tickets and list of ticket detail in a match pool.
     */
    getTickets_ByPool: (pool: string, queryParams?: {
        limit?: number;
        offset?: number;
    }) => Promise<AxiosResponse<ListMatchPoolTicketsResponse>>;
    /**
     * Get player metric for a specific match pool
     */
    getMetricsPlayer_ByPool: (pool: string) => Promise<AxiosResponse<PlayerMetricRecord>>;
    /**
     * Public get player metric for a specific match pool
     */
    getMetricsPlayer_ByPool_ByNS: (pool: string) => Promise<AxiosResponse<PlayerMetricRecord>>;
};

/**
 * AUTO GENERATED
 */

declare function MatchTicketsApi(sdk: AccelByteSDK, args?: SdkSetConfigParam): {
    /**
     * Creates a new request for matchmaking. Cross Platform: Allow player to play game with &#34;all&#34; registered platforms. 1. Cross Platform can be enabled through session service or create match ticket. a. via ticket: specify several cross_platform on create match ticket attributes. **[DEPRECATED]** client should not send from attribute &lt;code&gt;cross_platform&lt;/code&gt; will be populated from backend This value will override player attributes in session service. e.g. cross_platform:[xbox,psn,steam] b. via session service: set player/party cross_platform attributes. c. Enable match options ruleset with name cross_platform and type &#34;all&#34;. ``` { &#34;name&#34;: &#34;co-op&#34;, &#34;data&#34;: { &#34;alliance&#34;: { &#34;min_number&#34;: 1, &#34;max_number&#34;: 1, &#34;player_min_number&#34;: 1, &#34;player_max_number&#34;: 4 }, &#34;match_options&#34;: { &#34;options&#34;: [ {&#34;name&#34;: &#34;cross_platform&#34;, &#34;type&#34;: &#34;all&#34;} ] } } } ``` 2. Cross Platform can be disabled from the matchpool configuration &lt;code&gt;crossplay_disabled=true&lt;/code&gt; 3. When matchpool &lt;code&gt;crossplay_disabled=false&lt;/code&gt; * request attribute cross_platform is empty **[Recommended]**: * Matchmaking will consider Party leader &lt;code&gt;crossplayEnabled&lt;/code&gt; preference or Session attribute &lt;code&gt;crossplayEnabled&lt;/code&gt; preference. * When &lt;code&gt;crossplayEnabled=true&lt;/code&gt; &lt;code&gt;cross_platforms&lt;/code&gt; attributes will be populated from [active login methods](/iam/apidocs/#/Third%20Party%20Credential/RetrieveAllActiveThirdPartyLoginPlatformCredentialPublicV3) otherwise it will set to leader current platform * When &lt;code&gt;crossplayEnabled=false&lt;/code&gt; &lt;code&gt;cross_platforms&lt;/code&gt; attributes will be set to user&#39;s currentPlatform * request attribute cross_platform is not empty **[Not Recommended]**: * Cross Platform can be disabled with specify only ONE cross_platform. Current matchmaking use this behavior. e.g. cross_platform:[xbox] * Multiple cross_platform values is considered to be crossplay enabled 4. This behavior only works for Default Matchmaker. Custom matchmaker (custom gRPC matchmaker) need to consider this on its own implementation. ExcludedSessions: allow player to list out game sessions that they want to avoid matching, for example a match that they&#39;ve recently left or get kicked out from.
     */
    createMatchTicket: (data: MatchTicketRequest) => Promise<AxiosResponse<MatchTicketResponse>>;
    /**
     * Get my match tickets.
     */
    getMatchTicketsMe: (queryParams?: {
        limit?: number;
        matchPool?: string | null;
        offset?: number;
    }) => Promise<AxiosResponse<MatchTicketStatuses>>;
    /**
     * Deletes an existing matchmaking ticket.
     */
    deleteMatchTicket_ByTicketid: (ticketid: string) => Promise<AxiosResponse<unknown>>;
    /**
     * Get details for a specific match ticket
     */
    getMatchTicket_ByTicketid: (ticketid: string) => Promise<AxiosResponse<MatchTicketStatus>>;
};

/**
 * AUTO GENERATED
 */

declare function RuleSetsApi(sdk: AccelByteSDK, args?: SdkSetConfigParam): {
    /**
     * List rule sets.
     */
    getRulesets: (queryParams?: {
        limit?: number;
        name?: string | null;
        offset?: number;
    }) => Promise<AxiosResponse<ListRuleSetsResponse>>;
    /**
     * Creates a new rules set. A rule set has a name and contains arbitrary data which is meaningful to some particular match function(s) The name is used for a match pool to select the ruleset data that should be sent to the match function when matchmaking in that pool. To use custom rules set please set enable_custom_match_function=true. Default (false). When custom enable_custom_match_function=true, the ruleset will only validate if the rule is valid json.
     */
    createRuleset: (data: RuleSetPayload) => Promise<AxiosResponse<unknown>>;
    /**
     * Deletes an existing rule set.
     */
    deleteRuleset_ByRuleset: (ruleset: string) => Promise<AxiosResponse<unknown>>;
    /**
     * Get details for a specific rule set
     */
    getRuleset_ByRuleset: (ruleset: string) => Promise<AxiosResponse<RuleSetPayload>>;
    /**
     * Updates an existing matchmaking rule set. To use custom rules set please set enable_custom_match_function=true. Default (false). When custom enable_custom_match_function=true, the ruleset will only validate if the rule is valid json.
     */
    updateRuleset_ByRuleset: (ruleset: string, data: RuleSetPayload) => Promise<AxiosResponse<RuleSetPayload>>;
};

/**
 * AUTO GENERATED
 */

declare const Matchmaking: {
    ConfigAdminApi: typeof ConfigAdminApi;
    ConfigApi: typeof ConfigApi;
    EnvironmentVariablesApi: typeof EnvironmentVariablesApi;
    BackfillApi: typeof BackfillApi;
    RuleSetsApi: typeof RuleSetsApi;
    MatchPoolsApi: typeof MatchPoolsApi;
    MatchTicketsApi: typeof MatchTicketsApi;
    MatchFunctionsApi: typeof MatchFunctionsApi;
    version: () => void;
};

export { BackFillAcceptRequest, BackFillCreateRequest, BackFillRejectRequest, Backfill$, BackfillApi, BackfillCreateResponse, BackfillGetResponse, BackfillProposalResponse, Config$, ConfigAdmin$, ConfigAdminApi, ConfigApi, Configuration, DsInformation, EnvironmentVariable, EnvironmentVariables$, EnvironmentVariablesApi, Error, GameSession, ListEnvironmentVariablesResponse, ListMatchFunctionsResponse, ListMatchPoolTicketsResponse, ListMatchPoolsResponse, ListRuleSetsResponse, Match, MatchFunctionConfig, MatchFunctionOverride, MatchFunctionRequest, MatchFunctions$, MatchFunctionsApi, MatchPool, MatchPoolConfig, MatchPools$, MatchPoolsApi, MatchRuleSetNameData, MatchTicketRecord, MatchTicketRequest, MatchTicketResponse, MatchTicketStatus, MatchTicketStatuses, MatchTickets$, MatchTicketsApi, Matchmaking, NamespaceConfig, NamespaceConfigList, Pagination, Party, PatchNamespaceConfigRequest, PlayerData, PlayerMetricRecord, ProposedProposal, RuleSetPayload, RuleSetPayloadData, RuleSets$, RuleSetsApi, Server, Team, Ticket, TicketMetricResultRecord, User };

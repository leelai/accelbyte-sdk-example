"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/all-query-imports.ts
var all_query_imports_exports = {};
__export(all_query_imports_exports, {
  Key_Backfill: () => Key_Backfill,
  Key_Config: () => Key_Config,
  Key_ConfigAdmin: () => Key_ConfigAdmin,
  Key_EnvironmentVariables: () => Key_EnvironmentVariables,
  Key_MatchFunctions: () => Key_MatchFunctions,
  Key_MatchPools: () => Key_MatchPools,
  Key_MatchTickets: () => Key_MatchTickets,
  Key_RuleSets: () => Key_RuleSets,
  useBackfillApi_CreateBackfillMutation: () => useBackfillApi_CreateBackfillMutation,
  useBackfillApi_DeleteBackfill_ByBackfillIdMutation: () => useBackfillApi_DeleteBackfill_ByBackfillIdMutation,
  useBackfillApi_GetBackfillProposal: () => useBackfillApi_GetBackfillProposal,
  useBackfillApi_GetBackfill_ByBackfillId: () => useBackfillApi_GetBackfill_ByBackfillId,
  useBackfillApi_UpdateProposalAccept_ByBackfillIdMutation: () => useBackfillApi_UpdateProposalAccept_ByBackfillIdMutation,
  useBackfillApi_UpdateProposalReject_ByBackfillIdMutation: () => useBackfillApi_UpdateProposalReject_ByBackfillIdMutation,
  useConfigAdminApi_GetConfigLog: () => useConfigAdminApi_GetConfigLog,
  useConfigAdminApi_PatchConfigLogMutation: () => useConfigAdminApi_PatchConfigLogMutation,
  useConfigApi_GetConfig: () => useConfigApi_GetConfig,
  useConfigApi_GetConfig_ByNamespace: () => useConfigApi_GetConfig_ByNamespace,
  useConfigApi_PatchConfig_ByNamespaceMutation: () => useConfigApi_PatchConfig_ByNamespaceMutation,
  useEnvironmentVariablesApi_GetEnvironmentVariables: () => useEnvironmentVariablesApi_GetEnvironmentVariables,
  useMatchFunctionsApi_CreateMatchFunctionMutation: () => useMatchFunctionsApi_CreateMatchFunctionMutation,
  useMatchFunctionsApi_DeleteMatchFunction_ByNameMutation: () => useMatchFunctionsApi_DeleteMatchFunction_ByNameMutation,
  useMatchFunctionsApi_GetMatchFunctions: () => useMatchFunctionsApi_GetMatchFunctions,
  useMatchFunctionsApi_UpdateMatchFunction_ByNameMutation: () => useMatchFunctionsApi_UpdateMatchFunction_ByNameMutation,
  useMatchPoolsApi_CreateMatchPoolMutation: () => useMatchPoolsApi_CreateMatchPoolMutation,
  useMatchPoolsApi_DeleteMatchPool_ByPoolMutation: () => useMatchPoolsApi_DeleteMatchPool_ByPoolMutation,
  useMatchPoolsApi_GetMatchPool_ByPool: () => useMatchPoolsApi_GetMatchPool_ByPool,
  useMatchPoolsApi_GetMatchPools: () => useMatchPoolsApi_GetMatchPools,
  useMatchPoolsApi_GetMetricsPlayer_ByPool: () => useMatchPoolsApi_GetMetricsPlayer_ByPool,
  useMatchPoolsApi_GetMetricsPlayer_ByPool_ByNS: () => useMatchPoolsApi_GetMetricsPlayer_ByPool_ByNS,
  useMatchPoolsApi_GetMetrics_ByPool: () => useMatchPoolsApi_GetMetrics_ByPool,
  useMatchPoolsApi_GetTickets_ByPool: () => useMatchPoolsApi_GetTickets_ByPool,
  useMatchPoolsApi_UpdateMatchPool_ByPoolMutation: () => useMatchPoolsApi_UpdateMatchPool_ByPoolMutation,
  useMatchTicketsApi_CreateMatchTicketMutation: () => useMatchTicketsApi_CreateMatchTicketMutation,
  useMatchTicketsApi_DeleteMatchTicket_ByTicketidMutation: () => useMatchTicketsApi_DeleteMatchTicket_ByTicketidMutation,
  useMatchTicketsApi_GetMatchTicket_ByTicketid: () => useMatchTicketsApi_GetMatchTicket_ByTicketid,
  useMatchTicketsApi_GetMatchTicketsMe: () => useMatchTicketsApi_GetMatchTicketsMe,
  useRuleSetsApi_CreateRulesetMutation: () => useRuleSetsApi_CreateRulesetMutation,
  useRuleSetsApi_DeleteRuleset_ByRulesetMutation: () => useRuleSetsApi_DeleteRuleset_ByRulesetMutation,
  useRuleSetsApi_GetRuleset_ByRuleset: () => useRuleSetsApi_GetRuleset_ByRuleset,
  useRuleSetsApi_GetRulesets: () => useRuleSetsApi_GetRulesets,
  useRuleSetsApi_UpdateRuleset_ByRulesetMutation: () => useRuleSetsApi_UpdateRuleset_ByRulesetMutation
});
module.exports = __toCommonJS(all_query_imports_exports);

// src/generated-admin/queries/ConfigAdmin.query.ts
var import_react_query = require("@tanstack/react-query");

// src/generated-admin/ConfigAdminApi.ts
var import_sdk2 = require("@accelbyte/sdk");

// src/generated-admin/endpoints/ConfigAdmin$.ts
var import_sdk = require("@accelbyte/sdk");

// src/generated-definitions/Configuration.ts
var import_zod = require("zod");
var Configuration = import_zod.z.object({
  clientVersion: import_zod.z.string(),
  deployment: import_zod.z.string(),
  inactiveTimeout: import_zod.z.number().int(),
  inviteTimeout: import_zod.z.number().int(),
  joinability: import_zod.z.string(),
  maxPlayers: import_zod.z.number().int(),
  minPlayers: import_zod.z.number().int(),
  name: import_zod.z.string(),
  requestedRegions: import_zod.z.array(import_zod.z.string()),
  type: import_zod.z.string()
});

// src/generated-admin/endpoints/ConfigAdmin$.ts
var ConfigAdmin$ = class {
  // @ts-ignore
  // prettier-ignore
  constructor(axiosInstance, namespace, useSchemaValidation = true) {
    this.axiosInstance = axiosInstance;
    this.namespace = namespace;
    this.useSchemaValidation = useSchemaValidation;
  }
  /**
   * Get Log Configuration.&lt;br&gt;
   */
  getConfigLog() {
    const params = {};
    const url = "/match2/v1/admin/config/log";
    const resultPromise = this.axiosInstance.get(url, { params });
    return import_sdk.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, Configuration, "Configuration");
  }
  /**
   * Update Log Configuration.&lt;br&gt;
   */
  patchConfigLog(data) {
    const params = {};
    const url = "/match2/v1/admin/config/log";
    const resultPromise = this.axiosInstance.patch(url, data, { params });
    return import_sdk.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, Configuration, "Configuration");
  }
};

// src/generated-admin/ConfigAdminApi.ts
function ConfigAdminApi(sdk, args) {
  const sdkAssembly = sdk.assembly();
  const namespace = args?.coreConfig?.namespace ?? sdkAssembly.coreConfig.namespace;
  const useSchemaValidation = args?.coreConfig?.useSchemaValidation ?? sdkAssembly.coreConfig.useSchemaValidation;
  let axiosInstance = sdkAssembly.axiosInstance;
  const requestConfigOverrides = args?.axiosConfig?.request;
  const baseURLOverride = args?.coreConfig?.baseURL;
  const interceptorsOverride = args?.axiosConfig?.interceptors ?? [];
  if (requestConfigOverrides || baseURLOverride || interceptorsOverride.length > 0) {
    const requestConfig = import_sdk2.ApiUtils.mergeAxiosConfigs(sdkAssembly.axiosInstance.defaults, {
      ...baseURLOverride ? { baseURL: baseURLOverride } : {},
      ...requestConfigOverrides
    });
    axiosInstance = import_sdk2.Network.create(requestConfig);
    for (const interceptor of interceptorsOverride) {
      if (interceptor.type === "request") {
        axiosInstance.interceptors.request.use(interceptor.onRequest, interceptor.onError);
      }
      if (interceptor.type === "response") {
        axiosInstance.interceptors.response.use(interceptor.onSuccess, interceptor.onError);
      }
    }
  }
  async function getConfigLog() {
    const $ = new ConfigAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getConfigLog();
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function patchConfigLog(data) {
    const $ = new ConfigAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.patchConfigLog(data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  return {
    /**
     * Get Log Configuration.&lt;br&gt;
     */
    getConfigLog,
    /**
     * Update Log Configuration.&lt;br&gt;
     */
    patchConfigLog
  };
}

// src/generated-admin/queries/ConfigAdmin.query.ts
var Key_ConfigAdmin = /* @__PURE__ */ ((Key_ConfigAdmin2) => {
  Key_ConfigAdmin2["ConfigLog"] = "Matchmaking.ConfigAdmin.ConfigLog";
  return Key_ConfigAdmin2;
})(Key_ConfigAdmin || {});
var useConfigAdminApi_GetConfigLog = (sdk, input, options, callback) => {
  const queryFn = (sdk2, input2) => async () => {
    const response = await ConfigAdminApi(sdk2, { coreConfig: input2.coreConfig, axiosConfig: input2.axiosConfig }).getConfigLog();
    callback && callback(response);
    return response.data;
  };
  return (0, import_react_query.useQuery)({
    queryKey: ["Matchmaking.ConfigAdmin.ConfigLog" /* ConfigLog */, input],
    queryFn: queryFn(sdk, input),
    ...options
  });
};
var useConfigAdminApi_PatchConfigLogMutation = (sdk, options, callback) => {
  const mutationFn = async (input) => {
    const response = await ConfigAdminApi(sdk, { coreConfig: input.coreConfig, axiosConfig: input.axiosConfig }).patchConfigLog(input.data);
    callback && callback(response.data);
    return response.data;
  };
  return (0, import_react_query.useMutation)({
    mutationKey: ["Matchmaking.ConfigAdmin.ConfigLog" /* ConfigLog */],
    mutationFn,
    ...options
  });
};

// src/generated-public/queries/Backfill.query.ts
var import_react_query2 = require("@tanstack/react-query");

// src/generated-public/BackfillApi.ts
var import_sdk4 = require("@accelbyte/sdk");

// src/generated-public/endpoints/Backfill$.ts
var import_sdk3 = require("@accelbyte/sdk");
var import_zod15 = require("zod");

// src/generated-definitions/BackfillCreateResponse.ts
var import_zod2 = require("zod");
var BackfillCreateResponse = import_zod2.z.object({ id: import_zod2.z.string() });

// src/generated-definitions/BackfillGetResponse.ts
var import_zod9 = require("zod");

// src/generated-definitions/Match.ts
var import_zod8 = require("zod");

// src/generated-definitions/Team.ts
var import_zod4 = require("zod");

// src/generated-definitions/Party.ts
var import_zod3 = require("zod");
var Party = import_zod3.z.object({ partyID: import_zod3.z.string().nullish(), userIDs: import_zod3.z.array(import_zod3.z.string()).nullish() });

// src/generated-definitions/Team.ts
var Team = import_zod4.z.object({ Parties: import_zod4.z.array(Party).nullish(), UserIDs: import_zod4.z.array(import_zod4.z.string()).nullish() });

// src/generated-definitions/Ticket.ts
var import_zod7 = require("zod");

// src/generated-definitions/PlayerData.ts
var import_zod5 = require("zod");
var PlayerData = import_zod5.z.object({ Attributes: import_zod5.z.record(import_zod5.z.any()), PartyID: import_zod5.z.string(), PlatformID: import_zod5.z.string(), PlayerID: import_zod5.z.string() });

// src/generated-definitions/ProposedProposal.ts
var import_zod6 = require("zod");
var ProposedProposal = import_zod6.z.object({ BackfillID: import_zod6.z.string(), ProposalID: import_zod6.z.string(), Status: import_zod6.z.string() });

// src/generated-definitions/Ticket.ts
var Ticket = import_zod7.z.object({
  CreatedAt: import_zod7.z.string(),
  ExcludedSessions: import_zod7.z.array(import_zod7.z.string()),
  IsActive: import_zod7.z.boolean(),
  IsPivot: import_zod7.z.boolean(),
  IsSinglePlay: import_zod7.z.boolean(),
  Latencies: import_zod7.z.record(import_zod7.z.number().int()),
  MatchPool: import_zod7.z.string(),
  MatchedAt: import_zod7.z.string(),
  Namespace: import_zod7.z.string(),
  PartySessionID: import_zod7.z.string(),
  Players: import_zod7.z.array(PlayerData),
  ProposedProposal,
  TicketAttributes: import_zod7.z.record(import_zod7.z.any()),
  TicketID: import_zod7.z.string(),
  TicketInformation: import_zod7.z.record(import_zod7.z.any())
});

// src/generated-definitions/Match.ts
var Match = import_zod8.z.object({
  backfill: import_zod8.z.boolean().nullish(),
  clientVersion: import_zod8.z.string().nullish(),
  matchAttributes: import_zod8.z.record(import_zod8.z.any()).nullish(),
  regionPreference: import_zod8.z.array(import_zod8.z.string()).nullish(),
  serverName: import_zod8.z.string().nullish(),
  teams: import_zod8.z.array(Team).nullish(),
  tickets: import_zod8.z.array(Ticket).nullish()
});

// src/generated-definitions/BackfillGetResponse.ts
var BackfillGetResponse = import_zod9.z.object({
  createdAt: import_zod9.z.string().nullish(),
  matchPool: import_zod9.z.string().nullish(),
  matchSessionID: import_zod9.z.string().nullish(),
  partialMatch: Match.nullish(),
  ticketID: import_zod9.z.string().nullish()
});

// src/generated-definitions/BackfillProposalResponse.ts
var import_zod10 = require("zod");
var BackfillProposalResponse = import_zod10.z.object({
  backfillTicketID: import_zod10.z.string().nullish(),
  createdAt: import_zod10.z.string().nullish(),
  matchPool: import_zod10.z.string().nullish(),
  matchSessionID: import_zod10.z.string().nullish(),
  proposalID: import_zod10.z.string().nullish(),
  proposedTeams: import_zod10.z.array(Team).nullish(),
  tickets: import_zod10.z.array(Ticket).nullish()
});

// src/generated-definitions/GameSession.ts
var import_zod14 = require("zod");

// src/generated-definitions/DsInformation.ts
var import_zod12 = require("zod");

// src/generated-definitions/Server.ts
var import_zod11 = require("zod");
var Server = import_zod11.z.object({
  alternate_ips: import_zod11.z.array(import_zod11.z.string()),
  custom_attribute: import_zod11.z.string(),
  deployment: import_zod11.z.string(),
  game_version: import_zod11.z.string(),
  image_version: import_zod11.z.string(),
  ip: import_zod11.z.string(),
  is_override_game_version: import_zod11.z.boolean(),
  last_update: import_zod11.z.string(),
  namespace: import_zod11.z.string(),
  pod_name: import_zod11.z.string(),
  port: import_zod11.z.number().int(),
  ports: import_zod11.z.record(import_zod11.z.number().int()),
  protocol: import_zod11.z.string(),
  provider: import_zod11.z.string(),
  region: import_zod11.z.string(),
  session_id: import_zod11.z.string(),
  status: import_zod11.z.string()
});

// src/generated-definitions/DsInformation.ts
var DsInformation = import_zod12.z.object({
  MinPlayers: import_zod12.z.number().int(),
  RequestedAt: import_zod12.z.string(),
  RequestedRegions: import_zod12.z.array(import_zod12.z.string()),
  Server,
  Status: import_zod12.z.string()
});

// src/generated-definitions/User.ts
var import_zod13 = require("zod");
var User = import_zod13.z.object({
  ID: import_zod13.z.string(),
  PlatformID: import_zod13.z.string(),
  PlatformUserID: import_zod13.z.string(),
  PreviousStatus: import_zod13.z.string().nullish(),
  Status: import_zod13.z.string(),
  StatusV2: import_zod13.z.string(),
  UpdatedAt: import_zod13.z.string()
});

// src/generated-definitions/GameSession.ts
var GameSession = import_zod14.z.object({
  DSInformation: DsInformation,
  GameMode: import_zod14.z.string(),
  IsFull: import_zod14.z.boolean(),
  JoinType: import_zod14.z.string(),
  Members: import_zod14.z.array(User),
  attributes: import_zod14.z.record(import_zod14.z.any()),
  backfillTicketID: import_zod14.z.string(),
  configuration: Configuration,
  createdAt: import_zod14.z.string(),
  id: import_zod14.z.string(),
  leaderID: import_zod14.z.string(),
  matchPool: import_zod14.z.string(),
  namespace: import_zod14.z.string(),
  teams: import_zod14.z.array(Team),
  updatedAt: import_zod14.z.string(),
  version: import_zod14.z.number().int()
});

// src/generated-public/endpoints/Backfill$.ts
var Backfill$ = class {
  // @ts-ignore
  // prettier-ignore
  constructor(axiosInstance, namespace, useSchemaValidation = true) {
    this.axiosInstance = axiosInstance;
    this.namespace = namespace;
    this.useSchemaValidation = useSchemaValidation;
  }
  /**
   * Create backfill ticket.
   */
  createBackfill(data) {
    const params = {};
    const url = "/match2/v1/namespaces/{namespace}/backfill".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.post(url, data, { params });
    return import_sdk3.Validate.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      BackfillCreateResponse,
      "BackfillCreateResponse"
    );
  }
  /**
   * Get backfill proposal
   */
  getBackfillProposal(queryParams) {
    const params = { ...queryParams };
    const url = "/match2/v1/namespaces/{namespace}/backfill/proposal".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.get(url, { params });
    return import_sdk3.Validate.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      BackfillProposalResponse,
      "BackfillProposalResponse"
    );
  }
  /**
   * Delete backfill ticket.
   */
  deleteBackfill_ByBackfillId(backfillID) {
    const params = {};
    const url = "/match2/v1/namespaces/{namespace}/backfill/{backfillID}".replace("{namespace}", this.namespace).replace("{backfillID}", backfillID);
    const resultPromise = this.axiosInstance.delete(url, { params });
    return import_sdk3.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, import_zod15.z.unknown(), "z.unknown()");
  }
  /**
   * Get backfill ticket by ID
   */
  getBackfill_ByBackfillId(backfillID) {
    const params = {};
    const url = "/match2/v1/namespaces/{namespace}/backfill/{backfillID}".replace("{namespace}", this.namespace).replace("{backfillID}", backfillID);
    const resultPromise = this.axiosInstance.get(url, { params });
    return import_sdk3.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, BackfillGetResponse, "BackfillGetResponse");
  }
  /**
   *  Accept backfill proposal. Field partialAcceptTicketIDs can be used to accept specific tickets within a backfill proposal. If the ticketIDs are not mentioned in this field, those tickets will be rejected and reactivated for future proposals.
   */
  updateProposalAccept_ByBackfillId(backfillID, data) {
    const params = {};
    const url = "/match2/v1/namespaces/{namespace}/backfill/{backfillID}/proposal/accept".replace("{namespace}", this.namespace).replace("{backfillID}", backfillID);
    const resultPromise = this.axiosInstance.put(url, data, { params });
    return import_sdk3.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, GameSession, "GameSession");
  }
  /**
   * Reject backfill proposal
   */
  updateProposalReject_ByBackfillId(backfillID, data) {
    const params = {};
    const url = "/match2/v1/namespaces/{namespace}/backfill/{backfillID}/proposal/reject".replace("{namespace}", this.namespace).replace("{backfillID}", backfillID);
    const resultPromise = this.axiosInstance.put(url, data, { params });
    return import_sdk3.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, import_zod15.z.unknown(), "z.unknown()");
  }
};

// src/generated-public/BackfillApi.ts
function BackfillApi(sdk, args) {
  const sdkAssembly = sdk.assembly();
  const namespace = args?.coreConfig?.namespace ?? sdkAssembly.coreConfig.namespace;
  const useSchemaValidation = args?.coreConfig?.useSchemaValidation ?? sdkAssembly.coreConfig.useSchemaValidation;
  let axiosInstance = sdkAssembly.axiosInstance;
  const requestConfigOverrides = args?.axiosConfig?.request;
  const baseURLOverride = args?.coreConfig?.baseURL;
  const interceptorsOverride = args?.axiosConfig?.interceptors ?? [];
  if (requestConfigOverrides || baseURLOverride || interceptorsOverride.length > 0) {
    const requestConfig = import_sdk4.ApiUtils.mergeAxiosConfigs(sdkAssembly.axiosInstance.defaults, {
      ...baseURLOverride ? { baseURL: baseURLOverride } : {},
      ...requestConfigOverrides
    });
    axiosInstance = import_sdk4.Network.create(requestConfig);
    for (const interceptor of interceptorsOverride) {
      if (interceptor.type === "request") {
        axiosInstance.interceptors.request.use(interceptor.onRequest, interceptor.onError);
      }
      if (interceptor.type === "response") {
        axiosInstance.interceptors.response.use(interceptor.onSuccess, interceptor.onError);
      }
    }
  }
  async function createBackfill(data) {
    const $ = new Backfill$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.createBackfill(data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getBackfillProposal(queryParams) {
    const $ = new Backfill$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getBackfillProposal(queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function deleteBackfill_ByBackfillId(backfillID) {
    const $ = new Backfill$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.deleteBackfill_ByBackfillId(backfillID);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getBackfill_ByBackfillId(backfillID) {
    const $ = new Backfill$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getBackfill_ByBackfillId(backfillID);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function updateProposalAccept_ByBackfillId(backfillID, data) {
    const $ = new Backfill$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.updateProposalAccept_ByBackfillId(backfillID, data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function updateProposalReject_ByBackfillId(backfillID, data) {
    const $ = new Backfill$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.updateProposalReject_ByBackfillId(backfillID, data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  return {
    /**
     * Create backfill ticket.
     */
    createBackfill,
    /**
     * Get backfill proposal
     */
    getBackfillProposal,
    /**
     * Delete backfill ticket.
     */
    deleteBackfill_ByBackfillId,
    /**
     * Get backfill ticket by ID
     */
    getBackfill_ByBackfillId,
    /**
     *  Accept backfill proposal. Field partialAcceptTicketIDs can be used to accept specific tickets within a backfill proposal. If the ticketIDs are not mentioned in this field, those tickets will be rejected and reactivated for future proposals.
     */
    updateProposalAccept_ByBackfillId,
    /**
     * Reject backfill proposal
     */
    updateProposalReject_ByBackfillId
  };
}

// src/generated-public/queries/Backfill.query.ts
var Key_Backfill = /* @__PURE__ */ ((Key_Backfill2) => {
  Key_Backfill2["Backfill"] = "Matchmaking.Backfill.Backfill";
  Key_Backfill2["BackfillProposal"] = "Matchmaking.Backfill.BackfillProposal";
  Key_Backfill2["Backfill_ByBackfillId"] = "Matchmaking.Backfill.Backfill_ByBackfillId";
  Key_Backfill2["ProposalAccept_ByBackfillId"] = "Matchmaking.Backfill.ProposalAccept_ByBackfillId";
  Key_Backfill2["ProposalReject_ByBackfillId"] = "Matchmaking.Backfill.ProposalReject_ByBackfillId";
  return Key_Backfill2;
})(Key_Backfill || {});
var useBackfillApi_CreateBackfillMutation = (sdk, options, callback) => {
  const mutationFn = async (input) => {
    const response = await BackfillApi(sdk, { coreConfig: input.coreConfig, axiosConfig: input.axiosConfig }).createBackfill(input.data);
    callback && callback(response.data);
    return response.data;
  };
  return (0, import_react_query2.useMutation)({
    mutationKey: ["Matchmaking.Backfill.Backfill" /* Backfill */],
    mutationFn,
    ...options
  });
};
var useBackfillApi_GetBackfillProposal = (sdk, input, options, callback) => {
  const queryFn = (sdk2, input2) => async () => {
    const response = await BackfillApi(sdk2, { coreConfig: input2.coreConfig, axiosConfig: input2.axiosConfig }).getBackfillProposal(
      input2.queryParams
    );
    callback && callback(response);
    return response.data;
  };
  return (0, import_react_query2.useQuery)({
    queryKey: ["Matchmaking.Backfill.BackfillProposal" /* BackfillProposal */, input],
    queryFn: queryFn(sdk, input),
    ...options
  });
};
var useBackfillApi_DeleteBackfill_ByBackfillIdMutation = (sdk, options, callback) => {
  const mutationFn = async (input) => {
    const response = await BackfillApi(sdk, { coreConfig: input.coreConfig, axiosConfig: input.axiosConfig }).deleteBackfill_ByBackfillId(
      input.backfillID
    );
    callback && callback(response.data);
    return response.data;
  };
  return (0, import_react_query2.useMutation)({
    mutationKey: ["Matchmaking.Backfill.Backfill_ByBackfillId" /* Backfill_ByBackfillId */],
    mutationFn,
    ...options
  });
};
var useBackfillApi_GetBackfill_ByBackfillId = (sdk, input, options, callback) => {
  const queryFn = (sdk2, input2) => async () => {
    const response = await BackfillApi(sdk2, { coreConfig: input2.coreConfig, axiosConfig: input2.axiosConfig }).getBackfill_ByBackfillId(
      input2.backfillID
    );
    callback && callback(response);
    return response.data;
  };
  return (0, import_react_query2.useQuery)({
    queryKey: ["Matchmaking.Backfill.Backfill_ByBackfillId" /* Backfill_ByBackfillId */, input],
    queryFn: queryFn(sdk, input),
    ...options
  });
};
var useBackfillApi_UpdateProposalAccept_ByBackfillIdMutation = (sdk, options, callback) => {
  const mutationFn = async (input) => {
    const response = await BackfillApi(sdk, {
      coreConfig: input.coreConfig,
      axiosConfig: input.axiosConfig
    }).updateProposalAccept_ByBackfillId(input.backfillID, input.data);
    callback && callback(response.data);
    return response.data;
  };
  return (0, import_react_query2.useMutation)({
    mutationKey: ["Matchmaking.Backfill.ProposalAccept_ByBackfillId" /* ProposalAccept_ByBackfillId */],
    mutationFn,
    ...options
  });
};
var useBackfillApi_UpdateProposalReject_ByBackfillIdMutation = (sdk, options, callback) => {
  const mutationFn = async (input) => {
    const response = await BackfillApi(sdk, {
      coreConfig: input.coreConfig,
      axiosConfig: input.axiosConfig
    }).updateProposalReject_ByBackfillId(input.backfillID, input.data);
    callback && callback(response.data);
    return response.data;
  };
  return (0, import_react_query2.useMutation)({
    mutationKey: ["Matchmaking.Backfill.ProposalReject_ByBackfillId" /* ProposalReject_ByBackfillId */],
    mutationFn,
    ...options
  });
};

// src/generated-public/queries/Config.query.ts
var import_react_query3 = require("@tanstack/react-query");

// src/generated-public/ConfigApi.ts
var import_sdk6 = require("@accelbyte/sdk");

// src/generated-public/endpoints/Config$.ts
var import_sdk5 = require("@accelbyte/sdk");

// src/generated-definitions/NamespaceConfig.ts
var import_zod16 = require("zod");
var NamespaceConfig = import_zod16.z.object({
  crossPlatformNoCurrentPlatform: import_zod16.z.boolean().nullish(),
  extraPlatforms: import_zod16.z.array(import_zod16.z.string()).nullish(),
  matchAnyCommon: import_zod16.z.boolean().nullish(),
  namespace: import_zod16.z.string(),
  platformGroup: import_zod16.z.record(import_zod16.z.array(import_zod16.z.string())).nullish()
});

// src/generated-definitions/NamespaceConfigList.ts
var import_zod17 = require("zod");
var NamespaceConfigList = import_zod17.z.object({ configs: import_zod17.z.array(NamespaceConfig) });

// src/generated-public/endpoints/Config$.ts
var Config$ = class {
  // @ts-ignore
  // prettier-ignore
  constructor(axiosInstance, namespace, useSchemaValidation = true) {
    this.axiosInstance = axiosInstance;
    this.namespace = namespace;
    this.useSchemaValidation = useSchemaValidation;
  }
  /**
   * Get matchmaking config of all namespaces. Will only return namespace configs than have been updated.
   */
  getConfig() {
    const params = {};
    const url = "/match2/v1/config";
    const resultPromise = this.axiosInstance.get(url, { params });
    return import_sdk5.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, NamespaceConfigList, "NamespaceConfigList");
  }
  /**
   * Get matchmaking config of a namespaces.
   */
  getConfig_ByNamespace() {
    const params = {};
    const url = "/match2/v1/config/namespaces/{namespace}".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.get(url, { params });
    return import_sdk5.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, NamespaceConfig, "NamespaceConfig");
  }
  /**
   * Patch update matchmaking config of a namespaces. Partially update matchmaking config, will only update value that defined on the request.
   */
  patchConfig_ByNamespace(data) {
    const params = {};
    const url = "/match2/v1/config/namespaces/{namespace}".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.patch(url, data, { params });
    return import_sdk5.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, NamespaceConfig, "NamespaceConfig");
  }
};

// src/generated-public/ConfigApi.ts
function ConfigApi(sdk, args) {
  const sdkAssembly = sdk.assembly();
  const namespace = args?.coreConfig?.namespace ?? sdkAssembly.coreConfig.namespace;
  const useSchemaValidation = args?.coreConfig?.useSchemaValidation ?? sdkAssembly.coreConfig.useSchemaValidation;
  let axiosInstance = sdkAssembly.axiosInstance;
  const requestConfigOverrides = args?.axiosConfig?.request;
  const baseURLOverride = args?.coreConfig?.baseURL;
  const interceptorsOverride = args?.axiosConfig?.interceptors ?? [];
  if (requestConfigOverrides || baseURLOverride || interceptorsOverride.length > 0) {
    const requestConfig = import_sdk6.ApiUtils.mergeAxiosConfigs(sdkAssembly.axiosInstance.defaults, {
      ...baseURLOverride ? { baseURL: baseURLOverride } : {},
      ...requestConfigOverrides
    });
    axiosInstance = import_sdk6.Network.create(requestConfig);
    for (const interceptor of interceptorsOverride) {
      if (interceptor.type === "request") {
        axiosInstance.interceptors.request.use(interceptor.onRequest, interceptor.onError);
      }
      if (interceptor.type === "response") {
        axiosInstance.interceptors.response.use(interceptor.onSuccess, interceptor.onError);
      }
    }
  }
  async function getConfig() {
    const $ = new Config$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getConfig();
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getConfig_ByNamespace() {
    const $ = new Config$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getConfig_ByNamespace();
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function patchConfig_ByNamespace(data) {
    const $ = new Config$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.patchConfig_ByNamespace(data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  return {
    /**
     * Get matchmaking config of all namespaces. Will only return namespace configs than have been updated.
     */
    getConfig,
    /**
     * Get matchmaking config of a namespaces.
     */
    getConfig_ByNamespace,
    /**
     * Patch update matchmaking config of a namespaces. Partially update matchmaking config, will only update value that defined on the request.
     */
    patchConfig_ByNamespace
  };
}

// src/generated-public/queries/Config.query.ts
var Key_Config = /* @__PURE__ */ ((Key_Config2) => {
  Key_Config2["Config"] = "Matchmaking.Config.Config";
  Key_Config2["Config_ByNamespace"] = "Matchmaking.Config.Config_ByNamespace";
  return Key_Config2;
})(Key_Config || {});
var useConfigApi_GetConfig = (sdk, input, options, callback) => {
  const queryFn = (sdk2, input2) => async () => {
    const response = await ConfigApi(sdk2, { coreConfig: input2.coreConfig, axiosConfig: input2.axiosConfig }).getConfig();
    callback && callback(response);
    return response.data;
  };
  return (0, import_react_query3.useQuery)({
    queryKey: ["Matchmaking.Config.Config" /* Config */, input],
    queryFn: queryFn(sdk, input),
    ...options
  });
};
var useConfigApi_GetConfig_ByNamespace = (sdk, input, options, callback) => {
  const queryFn = (sdk2, input2) => async () => {
    const response = await ConfigApi(sdk2, { coreConfig: input2.coreConfig, axiosConfig: input2.axiosConfig }).getConfig_ByNamespace();
    callback && callback(response);
    return response.data;
  };
  return (0, import_react_query3.useQuery)({
    queryKey: ["Matchmaking.Config.Config_ByNamespace" /* Config_ByNamespace */, input],
    queryFn: queryFn(sdk, input),
    ...options
  });
};
var useConfigApi_PatchConfig_ByNamespaceMutation = (sdk, options, callback) => {
  const mutationFn = async (input) => {
    const response = await ConfigApi(sdk, { coreConfig: input.coreConfig, axiosConfig: input.axiosConfig }).patchConfig_ByNamespace(
      input.data
    );
    callback && callback(response.data);
    return response.data;
  };
  return (0, import_react_query3.useMutation)({
    mutationKey: ["Matchmaking.Config.Config_ByNamespace" /* Config_ByNamespace */],
    mutationFn,
    ...options
  });
};

// src/generated-public/queries/EnvironmentVariables.query.ts
var import_react_query4 = require("@tanstack/react-query");

// src/generated-public/EnvironmentVariablesApi.ts
var import_sdk8 = require("@accelbyte/sdk");

// src/generated-public/endpoints/EnvironmentVariables$.ts
var import_sdk7 = require("@accelbyte/sdk");

// src/generated-definitions/ListEnvironmentVariablesResponse.ts
var import_zod19 = require("zod");

// src/generated-definitions/EnvironmentVariable.ts
var import_zod18 = require("zod");
var EnvironmentVariable = import_zod18.z.object({
  actualValue: import_zod18.z.string().nullish(),
  defaultValue: import_zod18.z.string().nullish(),
  description: import_zod18.z.string().nullish(),
  name: import_zod18.z.string()
});

// src/generated-definitions/ListEnvironmentVariablesResponse.ts
var ListEnvironmentVariablesResponse = import_zod19.z.object({ data: import_zod19.z.array(EnvironmentVariable) });

// src/generated-public/endpoints/EnvironmentVariables$.ts
var EnvironmentVariables$ = class {
  // @ts-ignore
  // prettier-ignore
  constructor(axiosInstance, namespace, useSchemaValidation = true) {
    this.axiosInstance = axiosInstance;
    this.namespace = namespace;
    this.useSchemaValidation = useSchemaValidation;
  }
  /**
   * List environment variables.
   */
  getEnvironmentVariables() {
    const params = {};
    const url = "/match2/v1/environment-variables";
    const resultPromise = this.axiosInstance.get(url, { params });
    return import_sdk7.Validate.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      ListEnvironmentVariablesResponse,
      "ListEnvironmentVariablesResponse"
    );
  }
};

// src/generated-public/EnvironmentVariablesApi.ts
function EnvironmentVariablesApi(sdk, args) {
  const sdkAssembly = sdk.assembly();
  const namespace = args?.coreConfig?.namespace ?? sdkAssembly.coreConfig.namespace;
  const useSchemaValidation = args?.coreConfig?.useSchemaValidation ?? sdkAssembly.coreConfig.useSchemaValidation;
  let axiosInstance = sdkAssembly.axiosInstance;
  const requestConfigOverrides = args?.axiosConfig?.request;
  const baseURLOverride = args?.coreConfig?.baseURL;
  const interceptorsOverride = args?.axiosConfig?.interceptors ?? [];
  if (requestConfigOverrides || baseURLOverride || interceptorsOverride.length > 0) {
    const requestConfig = import_sdk8.ApiUtils.mergeAxiosConfigs(sdkAssembly.axiosInstance.defaults, {
      ...baseURLOverride ? { baseURL: baseURLOverride } : {},
      ...requestConfigOverrides
    });
    axiosInstance = import_sdk8.Network.create(requestConfig);
    for (const interceptor of interceptorsOverride) {
      if (interceptor.type === "request") {
        axiosInstance.interceptors.request.use(interceptor.onRequest, interceptor.onError);
      }
      if (interceptor.type === "response") {
        axiosInstance.interceptors.response.use(interceptor.onSuccess, interceptor.onError);
      }
    }
  }
  async function getEnvironmentVariables() {
    const $ = new EnvironmentVariables$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getEnvironmentVariables();
    if (resp.error) throw resp.error;
    return resp.response;
  }
  return {
    /**
     * List environment variables.
     */
    getEnvironmentVariables
  };
}

// src/generated-public/queries/EnvironmentVariables.query.ts
var Key_EnvironmentVariables = /* @__PURE__ */ ((Key_EnvironmentVariables2) => {
  Key_EnvironmentVariables2["EnvironmentVariables"] = "Matchmaking.EnvironmentVariables.EnvironmentVariables";
  return Key_EnvironmentVariables2;
})(Key_EnvironmentVariables || {});
var useEnvironmentVariablesApi_GetEnvironmentVariables = (sdk, input, options, callback) => {
  const queryFn = (sdk2, input2) => async () => {
    const response = await EnvironmentVariablesApi(sdk2, {
      coreConfig: input2.coreConfig,
      axiosConfig: input2.axiosConfig
    }).getEnvironmentVariables();
    callback && callback(response);
    return response.data;
  };
  return (0, import_react_query4.useQuery)({
    queryKey: ["Matchmaking.EnvironmentVariables.EnvironmentVariables" /* EnvironmentVariables */, input],
    queryFn: queryFn(sdk, input),
    ...options
  });
};

// src/generated-public/queries/MatchFunctions.query.ts
var import_react_query5 = require("@tanstack/react-query");

// src/generated-public/MatchFunctionsApi.ts
var import_sdk10 = require("@accelbyte/sdk");

// src/generated-public/endpoints/MatchFunctions$.ts
var import_sdk9 = require("@accelbyte/sdk");
var import_zod23 = require("zod");

// src/generated-definitions/ListMatchFunctionsResponse.ts
var import_zod22 = require("zod");

// src/generated-definitions/MatchFunctionConfig.ts
var import_zod20 = require("zod");
var MatchFunctionConfig = import_zod20.z.object({ match_function: import_zod20.z.string(), serviceAppName: import_zod20.z.string().nullish(), url: import_zod20.z.string() });

// src/generated-definitions/Pagination.ts
var import_zod21 = require("zod");
var Pagination = import_zod21.z.object({ first: import_zod21.z.string(), last: import_zod21.z.string(), next: import_zod21.z.string(), previous: import_zod21.z.string() });

// src/generated-definitions/ListMatchFunctionsResponse.ts
var ListMatchFunctionsResponse = import_zod22.z.object({
  configs: import_zod22.z.array(MatchFunctionConfig).nullish(),
  functions: import_zod22.z.array(import_zod22.z.string()),
  pagination: Pagination
});

// src/generated-public/endpoints/MatchFunctions$.ts
var MatchFunctions$ = class {
  // @ts-ignore
  // prettier-ignore
  constructor(axiosInstance, namespace, useSchemaValidation = true) {
    this.axiosInstance = axiosInstance;
    this.namespace = namespace;
    this.useSchemaValidation = useSchemaValidation;
  }
  /**
   * List existing match functions.
   */
  getMatchFunctions(queryParams) {
    const params = { limit: 20, ...queryParams };
    const url = "/match2/v1/namespaces/{namespace}/match-functions".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.get(url, { params });
    return import_sdk9.Validate.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      ListMatchFunctionsResponse,
      "ListMatchFunctionsResponse"
    );
  }
  /**
   * Creates a new matchmaking function.
   */
  createMatchFunction(data) {
    const params = {};
    const url = "/match2/v1/namespaces/{namespace}/match-functions".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.post(url, data, { params });
    return import_sdk9.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, import_zod23.z.unknown(), "z.unknown()");
  }
  /**
   * Deletes an existing match function.
   */
  deleteMatchFunction_ByName(name) {
    const params = {};
    const url = "/match2/v1/namespaces/{namespace}/match-functions/{name}".replace("{namespace}", this.namespace).replace("{name}", name);
    const resultPromise = this.axiosInstance.delete(url, { params });
    return import_sdk9.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, import_zod23.z.unknown(), "z.unknown()");
  }
  /**
   * Update existing matchmaking function.
   */
  updateMatchFunction_ByName(name, data) {
    const params = {};
    const url = "/match2/v1/namespaces/{namespace}/match-functions/{name}".replace("{namespace}", this.namespace).replace("{name}", name);
    const resultPromise = this.axiosInstance.put(url, data, { params });
    return import_sdk9.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, MatchFunctionConfig, "MatchFunctionConfig");
  }
};

// src/generated-public/MatchFunctionsApi.ts
function MatchFunctionsApi(sdk, args) {
  const sdkAssembly = sdk.assembly();
  const namespace = args?.coreConfig?.namespace ?? sdkAssembly.coreConfig.namespace;
  const useSchemaValidation = args?.coreConfig?.useSchemaValidation ?? sdkAssembly.coreConfig.useSchemaValidation;
  let axiosInstance = sdkAssembly.axiosInstance;
  const requestConfigOverrides = args?.axiosConfig?.request;
  const baseURLOverride = args?.coreConfig?.baseURL;
  const interceptorsOverride = args?.axiosConfig?.interceptors ?? [];
  if (requestConfigOverrides || baseURLOverride || interceptorsOverride.length > 0) {
    const requestConfig = import_sdk10.ApiUtils.mergeAxiosConfigs(sdkAssembly.axiosInstance.defaults, {
      ...baseURLOverride ? { baseURL: baseURLOverride } : {},
      ...requestConfigOverrides
    });
    axiosInstance = import_sdk10.Network.create(requestConfig);
    for (const interceptor of interceptorsOverride) {
      if (interceptor.type === "request") {
        axiosInstance.interceptors.request.use(interceptor.onRequest, interceptor.onError);
      }
      if (interceptor.type === "response") {
        axiosInstance.interceptors.response.use(interceptor.onSuccess, interceptor.onError);
      }
    }
  }
  async function getMatchFunctions(queryParams) {
    const $ = new MatchFunctions$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getMatchFunctions(queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function createMatchFunction(data) {
    const $ = new MatchFunctions$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.createMatchFunction(data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function deleteMatchFunction_ByName(name) {
    const $ = new MatchFunctions$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.deleteMatchFunction_ByName(name);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function updateMatchFunction_ByName(name, data) {
    const $ = new MatchFunctions$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.updateMatchFunction_ByName(name, data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  return {
    /**
     * List existing match functions.
     */
    getMatchFunctions,
    /**
     * Creates a new matchmaking function.
     */
    createMatchFunction,
    /**
     * Deletes an existing match function.
     */
    deleteMatchFunction_ByName,
    /**
     * Update existing matchmaking function.
     */
    updateMatchFunction_ByName
  };
}

// src/generated-public/queries/MatchFunctions.query.ts
var Key_MatchFunctions = /* @__PURE__ */ ((Key_MatchFunctions2) => {
  Key_MatchFunctions2["MatchFunctions"] = "Matchmaking.MatchFunctions.MatchFunctions";
  Key_MatchFunctions2["MatchFunction"] = "Matchmaking.MatchFunctions.MatchFunction";
  Key_MatchFunctions2["MatchFunction_ByName"] = "Matchmaking.MatchFunctions.MatchFunction_ByName";
  return Key_MatchFunctions2;
})(Key_MatchFunctions || {});
var useMatchFunctionsApi_GetMatchFunctions = (sdk, input, options, callback) => {
  const queryFn = (sdk2, input2) => async () => {
    const response = await MatchFunctionsApi(sdk2, { coreConfig: input2.coreConfig, axiosConfig: input2.axiosConfig }).getMatchFunctions(
      input2.queryParams
    );
    callback && callback(response);
    return response.data;
  };
  return (0, import_react_query5.useQuery)({
    queryKey: ["Matchmaking.MatchFunctions.MatchFunctions" /* MatchFunctions */, input],
    queryFn: queryFn(sdk, input),
    ...options
  });
};
var useMatchFunctionsApi_CreateMatchFunctionMutation = (sdk, options, callback) => {
  const mutationFn = async (input) => {
    const response = await MatchFunctionsApi(sdk, { coreConfig: input.coreConfig, axiosConfig: input.axiosConfig }).createMatchFunction(
      input.data
    );
    callback && callback(response.data);
    return response.data;
  };
  return (0, import_react_query5.useMutation)({
    mutationKey: ["Matchmaking.MatchFunctions.MatchFunction" /* MatchFunction */],
    mutationFn,
    ...options
  });
};
var useMatchFunctionsApi_DeleteMatchFunction_ByNameMutation = (sdk, options, callback) => {
  const mutationFn = async (input) => {
    const response = await MatchFunctionsApi(sdk, {
      coreConfig: input.coreConfig,
      axiosConfig: input.axiosConfig
    }).deleteMatchFunction_ByName(input.name);
    callback && callback(response.data);
    return response.data;
  };
  return (0, import_react_query5.useMutation)({
    mutationKey: ["Matchmaking.MatchFunctions.MatchFunction_ByName" /* MatchFunction_ByName */],
    mutationFn,
    ...options
  });
};
var useMatchFunctionsApi_UpdateMatchFunction_ByNameMutation = (sdk, options, callback) => {
  const mutationFn = async (input) => {
    const response = await MatchFunctionsApi(sdk, {
      coreConfig: input.coreConfig,
      axiosConfig: input.axiosConfig
    }).updateMatchFunction_ByName(input.name, input.data);
    callback && callback(response.data);
    return response.data;
  };
  return (0, import_react_query5.useMutation)({
    mutationKey: ["Matchmaking.MatchFunctions.MatchFunction_ByName" /* MatchFunction_ByName */],
    mutationFn,
    ...options
  });
};

// src/generated-public/queries/MatchPools.query.ts
var import_react_query6 = require("@tanstack/react-query");

// src/generated-public/MatchPoolsApi.ts
var import_sdk12 = require("@accelbyte/sdk");

// src/generated-public/endpoints/MatchPools$.ts
var import_sdk11 = require("@accelbyte/sdk");
var import_zod31 = require("zod");

// src/generated-definitions/ListMatchPoolTicketsResponse.ts
var import_zod25 = require("zod");

// src/generated-definitions/MatchTicketRecord.ts
var import_zod24 = require("zod");
var MatchTicketRecord = import_zod24.z.object({
  CreatedAt: import_zod24.z.string(),
  IsActive: import_zod24.z.boolean(),
  PartySessionID: import_zod24.z.string(),
  ProposedProposal,
  SessionID: import_zod24.z.string(),
  Ticket,
  TicketID: import_zod24.z.string(),
  UniqueTicketID: import_zod24.z.string()
});

// src/generated-definitions/ListMatchPoolTicketsResponse.ts
var ListMatchPoolTicketsResponse = import_zod25.z.object({
  data: import_zod25.z.array(MatchTicketRecord),
  pagination: Pagination.nullish(),
  totalData: import_zod25.z.number().int()
});

// src/generated-definitions/ListMatchPoolsResponse.ts
var import_zod28 = require("zod");

// src/generated-definitions/MatchPool.ts
var import_zod27 = require("zod");

// src/generated-definitions/MatchFunctionOverride.ts
var import_zod26 = require("zod");
var MatchFunctionOverride = import_zod26.z.object({
  backfill_matches: import_zod26.z.string().nullish(),
  enrichment: import_zod26.z.array(import_zod26.z.string()).nullish(),
  make_matches: import_zod26.z.string().nullish(),
  stat_codes: import_zod26.z.array(import_zod26.z.string()).nullish(),
  validation: import_zod26.z.array(import_zod26.z.string()).nullish()
});

// src/generated-definitions/MatchPool.ts
var MatchPool = import_zod27.z.object({
  auto_accept_backfill_proposal: import_zod27.z.boolean(),
  backfill_proposal_expiration_seconds: import_zod27.z.number().int(),
  backfill_ticket_expiration_seconds: import_zod27.z.number().int(),
  best_latency_calculation_method: import_zod27.z.string().nullish(),
  crossplay_disabled: import_zod27.z.boolean().nullish(),
  match_function: import_zod27.z.string(),
  match_function_override: MatchFunctionOverride,
  name: import_zod27.z.string(),
  platform_group_enabled: import_zod27.z.boolean().nullish(),
  rule_set: import_zod27.z.string(),
  session_template: import_zod27.z.string(),
  ticket_expiration_seconds: import_zod27.z.number().int()
});

// src/generated-definitions/ListMatchPoolsResponse.ts
var ListMatchPoolsResponse = import_zod28.z.object({ data: import_zod28.z.array(MatchPool).nullish(), pagination: Pagination.nullish() });

// src/generated-definitions/PlayerMetricRecord.ts
var import_zod29 = require("zod");
var PlayerMetricRecord = import_zod29.z.object({ playerInQueue: import_zod29.z.number().int() });

// src/generated-definitions/TicketMetricResultRecord.ts
var import_zod30 = require("zod");
var TicketMetricResultRecord = import_zod30.z.object({ queueTime: import_zod30.z.number().int() });

// src/generated-public/endpoints/MatchPools$.ts
var MatchPools$ = class {
  // @ts-ignore
  // prettier-ignore
  constructor(axiosInstance, namespace, useSchemaValidation = true) {
    this.axiosInstance = axiosInstance;
    this.namespace = namespace;
    this.useSchemaValidation = useSchemaValidation;
  }
  /**
   * List matchmaking pools.
   */
  getMatchPools(queryParams) {
    const params = { limit: 20, ...queryParams };
    const url = "/match2/v1/namespaces/{namespace}/match-pools".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.get(url, { params });
    return import_sdk11.Validate.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      ListMatchPoolsResponse,
      "ListMatchPoolsResponse"
    );
  }
  /**
   * Creates a new matchmaking pool. A pool is isolated from other pools (i.e. tickets may be matched with other tickets in the same pool, but not with tickets in other pools). Each pool has its own matchmaking rules and/or logic. ticket_expiration_seconds and backfill_ticket_expiration_seconds will be set to 300 seconds (5 minutes) by default if not filled. Match Function holds information about the name of the match logic server that matchmaking can refers to. By default we provide (&#34;default&#34; and &#34;basic&#34;). Match Function will be used as reference value for Match Function Overrides if not set. In case Customer would like to use matchmaking service default match logic, then specify it in &#34;match_function_overrides&#34;. This sample configuration will let matchmaking service will use &#34;default&#34; match logic for make matches, while validation will hit both &#34;default&#34; and &#34;custom&#34; match logics. e.g. { &#34;match_function&#34;: &#34;custom&#34;, &#34;match_function_overrides&#34;: { &#34;validation&#34;: []{&#34;default&#34;,&#34;custom&#34;}, &#34;make_matches&#34;: &#34;default&#34;, } }
   */
  createMatchPool(data) {
    const params = {};
    const url = "/match2/v1/namespaces/{namespace}/match-pools".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.post(url, data, { params });
    return import_sdk11.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, import_zod31.z.unknown(), "z.unknown()");
  }
  /**
   * Deletes an existing matchmaking pool.
   */
  deleteMatchPool_ByPool(pool) {
    const params = {};
    const url = "/match2/v1/namespaces/{namespace}/match-pools/{pool}".replace("{namespace}", this.namespace).replace("{pool}", pool);
    const resultPromise = this.axiosInstance.delete(url, { params });
    return import_sdk11.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, import_zod31.z.unknown(), "z.unknown()");
  }
  /**
   * Get details for a specific match pool
   */
  getMatchPool_ByPool(pool) {
    const params = {};
    const url = "/match2/v1/namespaces/{namespace}/match-pools/{pool}".replace("{namespace}", this.namespace).replace("{pool}", pool);
    const resultPromise = this.axiosInstance.get(url, { params });
    return import_sdk11.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, MatchPool, "MatchPool");
  }
  /**
   * Updates an existing matchmaking pool. ticket_expiration_seconds and backfill_ticket_expiration_seconds will be set to 300 seconds (5 minutes) by default if not filled. Match Function holds information about the name of the match logic server that matchmaking can refers to. By default we provide (&#34;default&#34; and &#34;basic&#34;). Match Function will be used as reference value for Match Function Overrides if not set. In case Customer would like to use matchmaking service default match logic, then specify it in &#34;match_function_overrides&#34;. This sample configuration will let matchmaking service will use &#34;default&#34; match logic for make matches, while validation will hit both &#34;default&#34; and &#34;custom&#34; match logics. e.g. { &#34;match_function&#34;: &#34;custom&#34;, &#34;match_function_overrides&#34;: { &#34;validation&#34;: []{&#34;default&#34;,&#34;custom&#34;}, &#34;make_matches&#34;: &#34;default&#34;, } }
   */
  updateMatchPool_ByPool(pool, data) {
    const params = {};
    const url = "/match2/v1/namespaces/{namespace}/match-pools/{pool}".replace("{namespace}", this.namespace).replace("{pool}", pool);
    const resultPromise = this.axiosInstance.put(url, data, { params });
    return import_sdk11.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, MatchPool, "MatchPool");
  }
  /**
   * Get metric for a specific match pool Result: queueTime in seconds
   */
  getMetrics_ByPool(pool) {
    const params = {};
    const url = "/match2/v1/namespaces/{namespace}/match-pools/{pool}/metrics".replace("{namespace}", this.namespace).replace("{pool}", pool);
    const resultPromise = this.axiosInstance.get(url, { params });
    return import_sdk11.Validate.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      TicketMetricResultRecord,
      "TicketMetricResultRecord"
    );
  }
  /**
   * Get tickets in queue for a specific match pool Result: number of tickets and list of ticket detail in a match pool.
   */
  getTickets_ByPool(pool, queryParams) {
    const params = { limit: 20, ...queryParams };
    const url = "/match2/v1/namespaces/{namespace}/match-pools/{pool}/tickets".replace("{namespace}", this.namespace).replace("{pool}", pool);
    const resultPromise = this.axiosInstance.get(url, { params });
    return import_sdk11.Validate.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      ListMatchPoolTicketsResponse,
      "ListMatchPoolTicketsResponse"
    );
  }
  /**
   * Get player metric for a specific match pool
   */
  getMetricsPlayer_ByPool(pool) {
    const params = {};
    const url = "/match2/v1/namespaces/{namespace}/match-pools/{pool}/metrics/player".replace("{namespace}", this.namespace).replace("{pool}", pool);
    const resultPromise = this.axiosInstance.get(url, { params });
    return import_sdk11.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, PlayerMetricRecord, "PlayerMetricRecord");
  }
  /**
   * Public get player metric for a specific match pool
   */
  getMetricsPlayer_ByPool_ByNS(pool) {
    const params = {};
    const url = "/match2/v1/public/namespaces/{namespace}/match-pools/{pool}/metrics/player".replace("{namespace}", this.namespace).replace("{pool}", pool);
    const resultPromise = this.axiosInstance.get(url, { params });
    return import_sdk11.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, PlayerMetricRecord, "PlayerMetricRecord");
  }
};

// src/generated-public/MatchPoolsApi.ts
function MatchPoolsApi(sdk, args) {
  const sdkAssembly = sdk.assembly();
  const namespace = args?.coreConfig?.namespace ?? sdkAssembly.coreConfig.namespace;
  const useSchemaValidation = args?.coreConfig?.useSchemaValidation ?? sdkAssembly.coreConfig.useSchemaValidation;
  let axiosInstance = sdkAssembly.axiosInstance;
  const requestConfigOverrides = args?.axiosConfig?.request;
  const baseURLOverride = args?.coreConfig?.baseURL;
  const interceptorsOverride = args?.axiosConfig?.interceptors ?? [];
  if (requestConfigOverrides || baseURLOverride || interceptorsOverride.length > 0) {
    const requestConfig = import_sdk12.ApiUtils.mergeAxiosConfigs(sdkAssembly.axiosInstance.defaults, {
      ...baseURLOverride ? { baseURL: baseURLOverride } : {},
      ...requestConfigOverrides
    });
    axiosInstance = import_sdk12.Network.create(requestConfig);
    for (const interceptor of interceptorsOverride) {
      if (interceptor.type === "request") {
        axiosInstance.interceptors.request.use(interceptor.onRequest, interceptor.onError);
      }
      if (interceptor.type === "response") {
        axiosInstance.interceptors.response.use(interceptor.onSuccess, interceptor.onError);
      }
    }
  }
  async function getMatchPools(queryParams) {
    const $ = new MatchPools$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getMatchPools(queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function createMatchPool(data) {
    const $ = new MatchPools$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.createMatchPool(data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function deleteMatchPool_ByPool(pool) {
    const $ = new MatchPools$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.deleteMatchPool_ByPool(pool);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getMatchPool_ByPool(pool) {
    const $ = new MatchPools$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getMatchPool_ByPool(pool);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function updateMatchPool_ByPool(pool, data) {
    const $ = new MatchPools$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.updateMatchPool_ByPool(pool, data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getMetrics_ByPool(pool) {
    const $ = new MatchPools$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getMetrics_ByPool(pool);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getTickets_ByPool(pool, queryParams) {
    const $ = new MatchPools$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getTickets_ByPool(pool, queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getMetricsPlayer_ByPool(pool) {
    const $ = new MatchPools$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getMetricsPlayer_ByPool(pool);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getMetricsPlayer_ByPool_ByNS(pool) {
    const $ = new MatchPools$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getMetricsPlayer_ByPool_ByNS(pool);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  return {
    /**
     * List matchmaking pools.
     */
    getMatchPools,
    /**
     * Creates a new matchmaking pool. A pool is isolated from other pools (i.e. tickets may be matched with other tickets in the same pool, but not with tickets in other pools). Each pool has its own matchmaking rules and/or logic. ticket_expiration_seconds and backfill_ticket_expiration_seconds will be set to 300 seconds (5 minutes) by default if not filled. Match Function holds information about the name of the match logic server that matchmaking can refers to. By default we provide (&#34;default&#34; and &#34;basic&#34;). Match Function will be used as reference value for Match Function Overrides if not set. In case Customer would like to use matchmaking service default match logic, then specify it in &#34;match_function_overrides&#34;. This sample configuration will let matchmaking service will use &#34;default&#34; match logic for make matches, while validation will hit both &#34;default&#34; and &#34;custom&#34; match logics. e.g. { &#34;match_function&#34;: &#34;custom&#34;, &#34;match_function_overrides&#34;: { &#34;validation&#34;: []{&#34;default&#34;,&#34;custom&#34;}, &#34;make_matches&#34;: &#34;default&#34;, } }
     */
    createMatchPool,
    /**
     * Deletes an existing matchmaking pool.
     */
    deleteMatchPool_ByPool,
    /**
     * Get details for a specific match pool
     */
    getMatchPool_ByPool,
    /**
     * Updates an existing matchmaking pool. ticket_expiration_seconds and backfill_ticket_expiration_seconds will be set to 300 seconds (5 minutes) by default if not filled. Match Function holds information about the name of the match logic server that matchmaking can refers to. By default we provide (&#34;default&#34; and &#34;basic&#34;). Match Function will be used as reference value for Match Function Overrides if not set. In case Customer would like to use matchmaking service default match logic, then specify it in &#34;match_function_overrides&#34;. This sample configuration will let matchmaking service will use &#34;default&#34; match logic for make matches, while validation will hit both &#34;default&#34; and &#34;custom&#34; match logics. e.g. { &#34;match_function&#34;: &#34;custom&#34;, &#34;match_function_overrides&#34;: { &#34;validation&#34;: []{&#34;default&#34;,&#34;custom&#34;}, &#34;make_matches&#34;: &#34;default&#34;, } }
     */
    updateMatchPool_ByPool,
    /**
     * Get metric for a specific match pool Result: queueTime in seconds
     */
    getMetrics_ByPool,
    /**
     * Get tickets in queue for a specific match pool Result: number of tickets and list of ticket detail in a match pool.
     */
    getTickets_ByPool,
    /**
     * Get player metric for a specific match pool
     */
    getMetricsPlayer_ByPool,
    /**
     * Public get player metric for a specific match pool
     */
    getMetricsPlayer_ByPool_ByNS
  };
}

// src/generated-public/queries/MatchPools.query.ts
var Key_MatchPools = /* @__PURE__ */ ((Key_MatchPools2) => {
  Key_MatchPools2["MatchPools"] = "Matchmaking.MatchPools.MatchPools";
  Key_MatchPools2["MatchPool"] = "Matchmaking.MatchPools.MatchPool";
  Key_MatchPools2["MatchPool_ByPool"] = "Matchmaking.MatchPools.MatchPool_ByPool";
  Key_MatchPools2["Metrics_ByPool"] = "Matchmaking.MatchPools.Metrics_ByPool";
  Key_MatchPools2["Tickets_ByPool"] = "Matchmaking.MatchPools.Tickets_ByPool";
  Key_MatchPools2["MetricsPlayer_ByPool"] = "Matchmaking.MatchPools.MetricsPlayer_ByPool";
  Key_MatchPools2["MetricsPlayer_ByPool_ByNS"] = "Matchmaking.MatchPools.MetricsPlayer_ByPool_ByNS";
  return Key_MatchPools2;
})(Key_MatchPools || {});
var useMatchPoolsApi_GetMatchPools = (sdk, input, options, callback) => {
  const queryFn = (sdk2, input2) => async () => {
    const response = await MatchPoolsApi(sdk2, { coreConfig: input2.coreConfig, axiosConfig: input2.axiosConfig }).getMatchPools(
      input2.queryParams
    );
    callback && callback(response);
    return response.data;
  };
  return (0, import_react_query6.useQuery)({
    queryKey: ["Matchmaking.MatchPools.MatchPools" /* MatchPools */, input],
    queryFn: queryFn(sdk, input),
    ...options
  });
};
var useMatchPoolsApi_CreateMatchPoolMutation = (sdk, options, callback) => {
  const mutationFn = async (input) => {
    const response = await MatchPoolsApi(sdk, { coreConfig: input.coreConfig, axiosConfig: input.axiosConfig }).createMatchPool(input.data);
    callback && callback(response.data);
    return response.data;
  };
  return (0, import_react_query6.useMutation)({
    mutationKey: ["Matchmaking.MatchPools.MatchPool" /* MatchPool */],
    mutationFn,
    ...options
  });
};
var useMatchPoolsApi_DeleteMatchPool_ByPoolMutation = (sdk, options, callback) => {
  const mutationFn = async (input) => {
    const response = await MatchPoolsApi(sdk, { coreConfig: input.coreConfig, axiosConfig: input.axiosConfig }).deleteMatchPool_ByPool(
      input.pool
    );
    callback && callback(response.data);
    return response.data;
  };
  return (0, import_react_query6.useMutation)({
    mutationKey: ["Matchmaking.MatchPools.MatchPool_ByPool" /* MatchPool_ByPool */],
    mutationFn,
    ...options
  });
};
var useMatchPoolsApi_GetMatchPool_ByPool = (sdk, input, options, callback) => {
  const queryFn = (sdk2, input2) => async () => {
    const response = await MatchPoolsApi(sdk2, { coreConfig: input2.coreConfig, axiosConfig: input2.axiosConfig }).getMatchPool_ByPool(
      input2.pool
    );
    callback && callback(response);
    return response.data;
  };
  return (0, import_react_query6.useQuery)({
    queryKey: ["Matchmaking.MatchPools.MatchPool_ByPool" /* MatchPool_ByPool */, input],
    queryFn: queryFn(sdk, input),
    ...options
  });
};
var useMatchPoolsApi_UpdateMatchPool_ByPoolMutation = (sdk, options, callback) => {
  const mutationFn = async (input) => {
    const response = await MatchPoolsApi(sdk, { coreConfig: input.coreConfig, axiosConfig: input.axiosConfig }).updateMatchPool_ByPool(
      input.pool,
      input.data
    );
    callback && callback(response.data);
    return response.data;
  };
  return (0, import_react_query6.useMutation)({
    mutationKey: ["Matchmaking.MatchPools.MatchPool_ByPool" /* MatchPool_ByPool */],
    mutationFn,
    ...options
  });
};
var useMatchPoolsApi_GetMetrics_ByPool = (sdk, input, options, callback) => {
  const queryFn = (sdk2, input2) => async () => {
    const response = await MatchPoolsApi(sdk2, { coreConfig: input2.coreConfig, axiosConfig: input2.axiosConfig }).getMetrics_ByPool(
      input2.pool
    );
    callback && callback(response);
    return response.data;
  };
  return (0, import_react_query6.useQuery)({
    queryKey: ["Matchmaking.MatchPools.Metrics_ByPool" /* Metrics_ByPool */, input],
    queryFn: queryFn(sdk, input),
    ...options
  });
};
var useMatchPoolsApi_GetTickets_ByPool = (sdk, input, options, callback) => {
  const queryFn = (sdk2, input2) => async () => {
    const response = await MatchPoolsApi(sdk2, { coreConfig: input2.coreConfig, axiosConfig: input2.axiosConfig }).getTickets_ByPool(
      input2.pool,
      input2.queryParams
    );
    callback && callback(response);
    return response.data;
  };
  return (0, import_react_query6.useQuery)({
    queryKey: ["Matchmaking.MatchPools.Tickets_ByPool" /* Tickets_ByPool */, input],
    queryFn: queryFn(sdk, input),
    ...options
  });
};
var useMatchPoolsApi_GetMetricsPlayer_ByPool = (sdk, input, options, callback) => {
  const queryFn = (sdk2, input2) => async () => {
    const response = await MatchPoolsApi(sdk2, { coreConfig: input2.coreConfig, axiosConfig: input2.axiosConfig }).getMetricsPlayer_ByPool(
      input2.pool
    );
    callback && callback(response);
    return response.data;
  };
  return (0, import_react_query6.useQuery)({
    queryKey: ["Matchmaking.MatchPools.MetricsPlayer_ByPool" /* MetricsPlayer_ByPool */, input],
    queryFn: queryFn(sdk, input),
    ...options
  });
};
var useMatchPoolsApi_GetMetricsPlayer_ByPool_ByNS = (sdk, input, options, callback) => {
  const queryFn = (sdk2, input2) => async () => {
    const response = await MatchPoolsApi(sdk2, {
      coreConfig: input2.coreConfig,
      axiosConfig: input2.axiosConfig
    }).getMetricsPlayer_ByPool_ByNS(input2.pool);
    callback && callback(response);
    return response.data;
  };
  return (0, import_react_query6.useQuery)({
    queryKey: ["Matchmaking.MatchPools.MetricsPlayer_ByPool_ByNS" /* MetricsPlayer_ByPool_ByNS */, input],
    queryFn: queryFn(sdk, input),
    ...options
  });
};

// src/generated-public/queries/MatchTickets.query.ts
var import_react_query7 = require("@tanstack/react-query");

// src/generated-public/MatchTicketsApi.ts
var import_sdk14 = require("@accelbyte/sdk");

// src/generated-public/endpoints/MatchTickets$.ts
var import_sdk13 = require("@accelbyte/sdk");
var import_zod35 = require("zod");

// src/generated-definitions/MatchTicketResponse.ts
var import_zod32 = require("zod");
var MatchTicketResponse = import_zod32.z.object({ matchTicketID: import_zod32.z.string(), queueTime: import_zod32.z.number().int() });

// src/generated-definitions/MatchTicketStatus.ts
var import_zod33 = require("zod");
var MatchTicketStatus = import_zod33.z.object({
  isActive: import_zod33.z.boolean().nullish(),
  matchFound: import_zod33.z.boolean(),
  matchPool: import_zod33.z.string().nullish(),
  matchTicketID: import_zod33.z.string().nullish(),
  proposedProposal: ProposedProposal.nullish(),
  sessionID: import_zod33.z.string()
});

// src/generated-definitions/MatchTicketStatuses.ts
var import_zod34 = require("zod");
var MatchTicketStatuses = import_zod34.z.object({ data: import_zod34.z.array(MatchTicketStatus), pagination: Pagination.nullish() });

// src/generated-public/endpoints/MatchTickets$.ts
var MatchTickets$ = class {
  // @ts-ignore
  // prettier-ignore
  constructor(axiosInstance, namespace, useSchemaValidation = true) {
    this.axiosInstance = axiosInstance;
    this.namespace = namespace;
    this.useSchemaValidation = useSchemaValidation;
  }
  /**
   * Creates a new request for matchmaking. Cross Platform: Allow player to play game with &#34;all&#34; registered platforms. 1. Cross Platform can be enabled through session service or create match ticket. a. via ticket: specify several cross_platform on create match ticket attributes. **[DEPRECATED]** client should not send from attribute &lt;code&gt;cross_platform&lt;/code&gt; will be populated from backend This value will override player attributes in session service. e.g. cross_platform:[xbox,psn,steam] b. via session service: set player/party cross_platform attributes. c. Enable match options ruleset with name cross_platform and type &#34;all&#34;. ``` { &#34;name&#34;: &#34;co-op&#34;, &#34;data&#34;: { &#34;alliance&#34;: { &#34;min_number&#34;: 1, &#34;max_number&#34;: 1, &#34;player_min_number&#34;: 1, &#34;player_max_number&#34;: 4 }, &#34;match_options&#34;: { &#34;options&#34;: [ {&#34;name&#34;: &#34;cross_platform&#34;, &#34;type&#34;: &#34;all&#34;} ] } } } ``` 2. Cross Platform can be disabled from the matchpool configuration &lt;code&gt;crossplay_disabled=true&lt;/code&gt; 3. When matchpool &lt;code&gt;crossplay_disabled=false&lt;/code&gt; * request attribute cross_platform is empty **[Recommended]**: * Matchmaking will consider Party leader &lt;code&gt;crossplayEnabled&lt;/code&gt; preference or Session attribute &lt;code&gt;crossplayEnabled&lt;/code&gt; preference. * When &lt;code&gt;crossplayEnabled=true&lt;/code&gt; &lt;code&gt;cross_platforms&lt;/code&gt; attributes will be populated from [active login methods](/iam/apidocs/#/Third%20Party%20Credential/RetrieveAllActiveThirdPartyLoginPlatformCredentialPublicV3) otherwise it will set to leader current platform * When &lt;code&gt;crossplayEnabled=false&lt;/code&gt; &lt;code&gt;cross_platforms&lt;/code&gt; attributes will be set to user&#39;s currentPlatform * request attribute cross_platform is not empty **[Not Recommended]**: * Cross Platform can be disabled with specify only ONE cross_platform. Current matchmaking use this behavior. e.g. cross_platform:[xbox] * Multiple cross_platform values is considered to be crossplay enabled 4. This behavior only works for Default Matchmaker. Custom matchmaker (custom gRPC matchmaker) need to consider this on its own implementation. ExcludedSessions: allow player to list out game sessions that they want to avoid matching, for example a match that they&#39;ve recently left or get kicked out from.
   */
  createMatchTicket(data) {
    const params = {};
    const url = "/match2/v1/namespaces/{namespace}/match-tickets".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.post(url, data, { params });
    return import_sdk13.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, MatchTicketResponse, "MatchTicketResponse");
  }
  /**
   * Get my match tickets.
   */
  getMatchTicketsMe(queryParams) {
    const params = { ...queryParams };
    const url = "/match2/v1/namespaces/{namespace}/match-tickets/me".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.get(url, { params });
    return import_sdk13.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, MatchTicketStatuses, "MatchTicketStatuses");
  }
  /**
   * Deletes an existing matchmaking ticket.
   */
  deleteMatchTicket_ByTicketid(ticketid) {
    const params = {};
    const url = "/match2/v1/namespaces/{namespace}/match-tickets/{ticketid}".replace("{namespace}", this.namespace).replace("{ticketid}", ticketid);
    const resultPromise = this.axiosInstance.delete(url, { params });
    return import_sdk13.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, import_zod35.z.unknown(), "z.unknown()");
  }
  /**
   * Get details for a specific match ticket
   */
  getMatchTicket_ByTicketid(ticketid) {
    const params = {};
    const url = "/match2/v1/namespaces/{namespace}/match-tickets/{ticketid}".replace("{namespace}", this.namespace).replace("{ticketid}", ticketid);
    const resultPromise = this.axiosInstance.get(url, { params });
    return import_sdk13.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, MatchTicketStatus, "MatchTicketStatus");
  }
};

// src/generated-public/MatchTicketsApi.ts
function MatchTicketsApi(sdk, args) {
  const sdkAssembly = sdk.assembly();
  const namespace = args?.coreConfig?.namespace ?? sdkAssembly.coreConfig.namespace;
  const useSchemaValidation = args?.coreConfig?.useSchemaValidation ?? sdkAssembly.coreConfig.useSchemaValidation;
  let axiosInstance = sdkAssembly.axiosInstance;
  const requestConfigOverrides = args?.axiosConfig?.request;
  const baseURLOverride = args?.coreConfig?.baseURL;
  const interceptorsOverride = args?.axiosConfig?.interceptors ?? [];
  if (requestConfigOverrides || baseURLOverride || interceptorsOverride.length > 0) {
    const requestConfig = import_sdk14.ApiUtils.mergeAxiosConfigs(sdkAssembly.axiosInstance.defaults, {
      ...baseURLOverride ? { baseURL: baseURLOverride } : {},
      ...requestConfigOverrides
    });
    axiosInstance = import_sdk14.Network.create(requestConfig);
    for (const interceptor of interceptorsOverride) {
      if (interceptor.type === "request") {
        axiosInstance.interceptors.request.use(interceptor.onRequest, interceptor.onError);
      }
      if (interceptor.type === "response") {
        axiosInstance.interceptors.response.use(interceptor.onSuccess, interceptor.onError);
      }
    }
  }
  async function createMatchTicket(data) {
    const $ = new MatchTickets$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.createMatchTicket(data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getMatchTicketsMe(queryParams) {
    const $ = new MatchTickets$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getMatchTicketsMe(queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function deleteMatchTicket_ByTicketid(ticketid) {
    const $ = new MatchTickets$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.deleteMatchTicket_ByTicketid(ticketid);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getMatchTicket_ByTicketid(ticketid) {
    const $ = new MatchTickets$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getMatchTicket_ByTicketid(ticketid);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  return {
    /**
     * Creates a new request for matchmaking. Cross Platform: Allow player to play game with &#34;all&#34; registered platforms. 1. Cross Platform can be enabled through session service or create match ticket. a. via ticket: specify several cross_platform on create match ticket attributes. **[DEPRECATED]** client should not send from attribute &lt;code&gt;cross_platform&lt;/code&gt; will be populated from backend This value will override player attributes in session service. e.g. cross_platform:[xbox,psn,steam] b. via session service: set player/party cross_platform attributes. c. Enable match options ruleset with name cross_platform and type &#34;all&#34;. ``` { &#34;name&#34;: &#34;co-op&#34;, &#34;data&#34;: { &#34;alliance&#34;: { &#34;min_number&#34;: 1, &#34;max_number&#34;: 1, &#34;player_min_number&#34;: 1, &#34;player_max_number&#34;: 4 }, &#34;match_options&#34;: { &#34;options&#34;: [ {&#34;name&#34;: &#34;cross_platform&#34;, &#34;type&#34;: &#34;all&#34;} ] } } } ``` 2. Cross Platform can be disabled from the matchpool configuration &lt;code&gt;crossplay_disabled=true&lt;/code&gt; 3. When matchpool &lt;code&gt;crossplay_disabled=false&lt;/code&gt; * request attribute cross_platform is empty **[Recommended]**: * Matchmaking will consider Party leader &lt;code&gt;crossplayEnabled&lt;/code&gt; preference or Session attribute &lt;code&gt;crossplayEnabled&lt;/code&gt; preference. * When &lt;code&gt;crossplayEnabled=true&lt;/code&gt; &lt;code&gt;cross_platforms&lt;/code&gt; attributes will be populated from [active login methods](/iam/apidocs/#/Third%20Party%20Credential/RetrieveAllActiveThirdPartyLoginPlatformCredentialPublicV3) otherwise it will set to leader current platform * When &lt;code&gt;crossplayEnabled=false&lt;/code&gt; &lt;code&gt;cross_platforms&lt;/code&gt; attributes will be set to user&#39;s currentPlatform * request attribute cross_platform is not empty **[Not Recommended]**: * Cross Platform can be disabled with specify only ONE cross_platform. Current matchmaking use this behavior. e.g. cross_platform:[xbox] * Multiple cross_platform values is considered to be crossplay enabled 4. This behavior only works for Default Matchmaker. Custom matchmaker (custom gRPC matchmaker) need to consider this on its own implementation. ExcludedSessions: allow player to list out game sessions that they want to avoid matching, for example a match that they&#39;ve recently left or get kicked out from.
     */
    createMatchTicket,
    /**
     * Get my match tickets.
     */
    getMatchTicketsMe,
    /**
     * Deletes an existing matchmaking ticket.
     */
    deleteMatchTicket_ByTicketid,
    /**
     * Get details for a specific match ticket
     */
    getMatchTicket_ByTicketid
  };
}

// src/generated-public/queries/MatchTickets.query.ts
var Key_MatchTickets = /* @__PURE__ */ ((Key_MatchTickets2) => {
  Key_MatchTickets2["MatchTicket"] = "Matchmaking.MatchTickets.MatchTicket";
  Key_MatchTickets2["MatchTicketsMe"] = "Matchmaking.MatchTickets.MatchTicketsMe";
  Key_MatchTickets2["MatchTicket_ByTicketid"] = "Matchmaking.MatchTickets.MatchTicket_ByTicketid";
  return Key_MatchTickets2;
})(Key_MatchTickets || {});
var useMatchTicketsApi_CreateMatchTicketMutation = (sdk, options, callback) => {
  const mutationFn = async (input) => {
    const response = await MatchTicketsApi(sdk, { coreConfig: input.coreConfig, axiosConfig: input.axiosConfig }).createMatchTicket(
      input.data
    );
    callback && callback(response.data);
    return response.data;
  };
  return (0, import_react_query7.useMutation)({
    mutationKey: ["Matchmaking.MatchTickets.MatchTicket" /* MatchTicket */],
    mutationFn,
    ...options
  });
};
var useMatchTicketsApi_GetMatchTicketsMe = (sdk, input, options, callback) => {
  const queryFn = (sdk2, input2) => async () => {
    const response = await MatchTicketsApi(sdk2, { coreConfig: input2.coreConfig, axiosConfig: input2.axiosConfig }).getMatchTicketsMe(
      input2.queryParams
    );
    callback && callback(response);
    return response.data;
  };
  return (0, import_react_query7.useQuery)({
    queryKey: ["Matchmaking.MatchTickets.MatchTicketsMe" /* MatchTicketsMe */, input],
    queryFn: queryFn(sdk, input),
    ...options
  });
};
var useMatchTicketsApi_DeleteMatchTicket_ByTicketidMutation = (sdk, options, callback) => {
  const mutationFn = async (input) => {
    const response = await MatchTicketsApi(sdk, {
      coreConfig: input.coreConfig,
      axiosConfig: input.axiosConfig
    }).deleteMatchTicket_ByTicketid(input.ticketid);
    callback && callback(response.data);
    return response.data;
  };
  return (0, import_react_query7.useMutation)({
    mutationKey: ["Matchmaking.MatchTickets.MatchTicket_ByTicketid" /* MatchTicket_ByTicketid */],
    mutationFn,
    ...options
  });
};
var useMatchTicketsApi_GetMatchTicket_ByTicketid = (sdk, input, options, callback) => {
  const queryFn = (sdk2, input2) => async () => {
    const response = await MatchTicketsApi(sdk2, { coreConfig: input2.coreConfig, axiosConfig: input2.axiosConfig }).getMatchTicket_ByTicketid(
      input2.ticketid
    );
    callback && callback(response);
    return response.data;
  };
  return (0, import_react_query7.useQuery)({
    queryKey: ["Matchmaking.MatchTickets.MatchTicket_ByTicketid" /* MatchTicket_ByTicketid */, input],
    queryFn: queryFn(sdk, input),
    ...options
  });
};

// src/generated-public/queries/RuleSets.query.ts
var import_react_query8 = require("@tanstack/react-query");

// src/generated-public/RuleSetsApi.ts
var import_sdk16 = require("@accelbyte/sdk");

// src/generated-public/endpoints/RuleSets$.ts
var import_sdk15 = require("@accelbyte/sdk");
var import_zod40 = require("zod");

// src/generated-definitions/ListRuleSetsResponse.ts
var import_zod37 = require("zod");

// src/generated-definitions/MatchRuleSetNameData.ts
var import_zod36 = require("zod");
var MatchRuleSetNameData = import_zod36.z.object({ name: import_zod36.z.string() });

// src/generated-definitions/ListRuleSetsResponse.ts
var ListRuleSetsResponse = import_zod37.z.object({ data: import_zod37.z.array(MatchRuleSetNameData).nullish(), pagination: Pagination.nullish() });

// src/generated-definitions/RuleSetPayload.ts
var import_zod39 = require("zod");

// src/generated-definitions/RuleSetPayloadData.ts
var import_zod38 = require("zod");
var RuleSetPayloadData = import_zod38.z.any();

// src/generated-definitions/RuleSetPayload.ts
var RuleSetPayload = import_zod39.z.object({ data: RuleSetPayloadData, enable_custom_match_function: import_zod39.z.boolean(), name: import_zod39.z.string() });

// src/generated-public/endpoints/RuleSets$.ts
var RuleSets$ = class {
  // @ts-ignore
  // prettier-ignore
  constructor(axiosInstance, namespace, useSchemaValidation = true) {
    this.axiosInstance = axiosInstance;
    this.namespace = namespace;
    this.useSchemaValidation = useSchemaValidation;
  }
  /**
   * List rule sets.
   */
  getRulesets(queryParams) {
    const params = { limit: 20, ...queryParams };
    const url = "/match2/v1/namespaces/{namespace}/rulesets".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.get(url, { params });
    return import_sdk15.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, ListRuleSetsResponse, "ListRuleSetsResponse");
  }
  /**
   * Creates a new rules set. A rule set has a name and contains arbitrary data which is meaningful to some particular match function(s) The name is used for a match pool to select the ruleset data that should be sent to the match function when matchmaking in that pool. To use custom rules set please set enable_custom_match_function=true. Default (false). When custom enable_custom_match_function=true, the ruleset will only validate if the rule is valid json.
   */
  createRuleset(data) {
    const params = {};
    const url = "/match2/v1/namespaces/{namespace}/rulesets".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.post(url, data, { params });
    return import_sdk15.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, import_zod40.z.unknown(), "z.unknown()");
  }
  /**
   * Deletes an existing rule set.
   */
  deleteRuleset_ByRuleset(ruleset) {
    const params = {};
    const url = "/match2/v1/namespaces/{namespace}/rulesets/{ruleset}".replace("{namespace}", this.namespace).replace("{ruleset}", ruleset);
    const resultPromise = this.axiosInstance.delete(url, { params });
    return import_sdk15.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, import_zod40.z.unknown(), "z.unknown()");
  }
  /**
   * Get details for a specific rule set
   */
  getRuleset_ByRuleset(ruleset) {
    const params = {};
    const url = "/match2/v1/namespaces/{namespace}/rulesets/{ruleset}".replace("{namespace}", this.namespace).replace("{ruleset}", ruleset);
    const resultPromise = this.axiosInstance.get(url, { params });
    return import_sdk15.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, RuleSetPayload, "RuleSetPayload");
  }
  /**
   * Updates an existing matchmaking rule set. To use custom rules set please set enable_custom_match_function=true. Default (false). When custom enable_custom_match_function=true, the ruleset will only validate if the rule is valid json.
   */
  updateRuleset_ByRuleset(ruleset, data) {
    const params = {};
    const url = "/match2/v1/namespaces/{namespace}/rulesets/{ruleset}".replace("{namespace}", this.namespace).replace("{ruleset}", ruleset);
    const resultPromise = this.axiosInstance.put(url, data, { params });
    return import_sdk15.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, RuleSetPayload, "RuleSetPayload");
  }
};

// src/generated-public/RuleSetsApi.ts
function RuleSetsApi(sdk, args) {
  const sdkAssembly = sdk.assembly();
  const namespace = args?.coreConfig?.namespace ?? sdkAssembly.coreConfig.namespace;
  const useSchemaValidation = args?.coreConfig?.useSchemaValidation ?? sdkAssembly.coreConfig.useSchemaValidation;
  let axiosInstance = sdkAssembly.axiosInstance;
  const requestConfigOverrides = args?.axiosConfig?.request;
  const baseURLOverride = args?.coreConfig?.baseURL;
  const interceptorsOverride = args?.axiosConfig?.interceptors ?? [];
  if (requestConfigOverrides || baseURLOverride || interceptorsOverride.length > 0) {
    const requestConfig = import_sdk16.ApiUtils.mergeAxiosConfigs(sdkAssembly.axiosInstance.defaults, {
      ...baseURLOverride ? { baseURL: baseURLOverride } : {},
      ...requestConfigOverrides
    });
    axiosInstance = import_sdk16.Network.create(requestConfig);
    for (const interceptor of interceptorsOverride) {
      if (interceptor.type === "request") {
        axiosInstance.interceptors.request.use(interceptor.onRequest, interceptor.onError);
      }
      if (interceptor.type === "response") {
        axiosInstance.interceptors.response.use(interceptor.onSuccess, interceptor.onError);
      }
    }
  }
  async function getRulesets(queryParams) {
    const $ = new RuleSets$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getRulesets(queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function createRuleset(data) {
    const $ = new RuleSets$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.createRuleset(data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function deleteRuleset_ByRuleset(ruleset) {
    const $ = new RuleSets$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.deleteRuleset_ByRuleset(ruleset);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getRuleset_ByRuleset(ruleset) {
    const $ = new RuleSets$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getRuleset_ByRuleset(ruleset);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function updateRuleset_ByRuleset(ruleset, data) {
    const $ = new RuleSets$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.updateRuleset_ByRuleset(ruleset, data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  return {
    /**
     * List rule sets.
     */
    getRulesets,
    /**
     * Creates a new rules set. A rule set has a name and contains arbitrary data which is meaningful to some particular match function(s) The name is used for a match pool to select the ruleset data that should be sent to the match function when matchmaking in that pool. To use custom rules set please set enable_custom_match_function=true. Default (false). When custom enable_custom_match_function=true, the ruleset will only validate if the rule is valid json.
     */
    createRuleset,
    /**
     * Deletes an existing rule set.
     */
    deleteRuleset_ByRuleset,
    /**
     * Get details for a specific rule set
     */
    getRuleset_ByRuleset,
    /**
     * Updates an existing matchmaking rule set. To use custom rules set please set enable_custom_match_function=true. Default (false). When custom enable_custom_match_function=true, the ruleset will only validate if the rule is valid json.
     */
    updateRuleset_ByRuleset
  };
}

// src/generated-public/queries/RuleSets.query.ts
var Key_RuleSets = /* @__PURE__ */ ((Key_RuleSets2) => {
  Key_RuleSets2["Rulesets"] = "Matchmaking.RuleSets.Rulesets";
  Key_RuleSets2["Ruleset"] = "Matchmaking.RuleSets.Ruleset";
  Key_RuleSets2["Ruleset_ByRuleset"] = "Matchmaking.RuleSets.Ruleset_ByRuleset";
  return Key_RuleSets2;
})(Key_RuleSets || {});
var useRuleSetsApi_GetRulesets = (sdk, input, options, callback) => {
  const queryFn = (sdk2, input2) => async () => {
    const response = await RuleSetsApi(sdk2, { coreConfig: input2.coreConfig, axiosConfig: input2.axiosConfig }).getRulesets(input2.queryParams);
    callback && callback(response);
    return response.data;
  };
  return (0, import_react_query8.useQuery)({
    queryKey: ["Matchmaking.RuleSets.Rulesets" /* Rulesets */, input],
    queryFn: queryFn(sdk, input),
    ...options
  });
};
var useRuleSetsApi_CreateRulesetMutation = (sdk, options, callback) => {
  const mutationFn = async (input) => {
    const response = await RuleSetsApi(sdk, { coreConfig: input.coreConfig, axiosConfig: input.axiosConfig }).createRuleset(input.data);
    callback && callback(response.data);
    return response.data;
  };
  return (0, import_react_query8.useMutation)({
    mutationKey: ["Matchmaking.RuleSets.Ruleset" /* Ruleset */],
    mutationFn,
    ...options
  });
};
var useRuleSetsApi_DeleteRuleset_ByRulesetMutation = (sdk, options, callback) => {
  const mutationFn = async (input) => {
    const response = await RuleSetsApi(sdk, { coreConfig: input.coreConfig, axiosConfig: input.axiosConfig }).deleteRuleset_ByRuleset(
      input.ruleset
    );
    callback && callback(response.data);
    return response.data;
  };
  return (0, import_react_query8.useMutation)({
    mutationKey: ["Matchmaking.RuleSets.Ruleset_ByRuleset" /* Ruleset_ByRuleset */],
    mutationFn,
    ...options
  });
};
var useRuleSetsApi_GetRuleset_ByRuleset = (sdk, input, options, callback) => {
  const queryFn = (sdk2, input2) => async () => {
    const response = await RuleSetsApi(sdk2, { coreConfig: input2.coreConfig, axiosConfig: input2.axiosConfig }).getRuleset_ByRuleset(
      input2.ruleset
    );
    callback && callback(response);
    return response.data;
  };
  return (0, import_react_query8.useQuery)({
    queryKey: ["Matchmaking.RuleSets.Ruleset_ByRuleset" /* Ruleset_ByRuleset */, input],
    queryFn: queryFn(sdk, input),
    ...options
  });
};
var useRuleSetsApi_UpdateRuleset_ByRulesetMutation = (sdk, options, callback) => {
  const mutationFn = async (input) => {
    const response = await RuleSetsApi(sdk, { coreConfig: input.coreConfig, axiosConfig: input.axiosConfig }).updateRuleset_ByRuleset(
      input.ruleset,
      input.data
    );
    callback && callback(response.data);
    return response.data;
  };
  return (0, import_react_query8.useMutation)({
    mutationKey: ["Matchmaking.RuleSets.Ruleset_ByRuleset" /* Ruleset_ByRuleset */],
    mutationFn,
    ...options
  });
};
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  Key_Backfill,
  Key_Config,
  Key_ConfigAdmin,
  Key_EnvironmentVariables,
  Key_MatchFunctions,
  Key_MatchPools,
  Key_MatchTickets,
  Key_RuleSets,
  useBackfillApi_CreateBackfillMutation,
  useBackfillApi_DeleteBackfill_ByBackfillIdMutation,
  useBackfillApi_GetBackfillProposal,
  useBackfillApi_GetBackfill_ByBackfillId,
  useBackfillApi_UpdateProposalAccept_ByBackfillIdMutation,
  useBackfillApi_UpdateProposalReject_ByBackfillIdMutation,
  useConfigAdminApi_GetConfigLog,
  useConfigAdminApi_PatchConfigLogMutation,
  useConfigApi_GetConfig,
  useConfigApi_GetConfig_ByNamespace,
  useConfigApi_PatchConfig_ByNamespaceMutation,
  useEnvironmentVariablesApi_GetEnvironmentVariables,
  useMatchFunctionsApi_CreateMatchFunctionMutation,
  useMatchFunctionsApi_DeleteMatchFunction_ByNameMutation,
  useMatchFunctionsApi_GetMatchFunctions,
  useMatchFunctionsApi_UpdateMatchFunction_ByNameMutation,
  useMatchPoolsApi_CreateMatchPoolMutation,
  useMatchPoolsApi_DeleteMatchPool_ByPoolMutation,
  useMatchPoolsApi_GetMatchPool_ByPool,
  useMatchPoolsApi_GetMatchPools,
  useMatchPoolsApi_GetMetricsPlayer_ByPool,
  useMatchPoolsApi_GetMetricsPlayer_ByPool_ByNS,
  useMatchPoolsApi_GetMetrics_ByPool,
  useMatchPoolsApi_GetTickets_ByPool,
  useMatchPoolsApi_UpdateMatchPool_ByPoolMutation,
  useMatchTicketsApi_CreateMatchTicketMutation,
  useMatchTicketsApi_DeleteMatchTicket_ByTicketidMutation,
  useMatchTicketsApi_GetMatchTicket_ByTicketid,
  useMatchTicketsApi_GetMatchTicketsMe,
  useRuleSetsApi_CreateRulesetMutation,
  useRuleSetsApi_DeleteRuleset_ByRulesetMutation,
  useRuleSetsApi_GetRuleset_ByRuleset,
  useRuleSetsApi_GetRulesets,
  useRuleSetsApi_UpdateRuleset_ByRulesetMutation
});

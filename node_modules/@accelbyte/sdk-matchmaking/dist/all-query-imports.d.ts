import { AccelByteSDK, SdkSetConfigParam, ApiError } from '@accelbyte/sdk';
import { AxiosError, AxiosResponse } from 'axios';
import { UseQueryOptions, UseQueryResult, UseMutationOptions, UseMutationResult } from '@tanstack/react-query';
import { C as Configuration, a as BackfillCreateResponse, B as BackFillCreateRequest, b as BackfillProposalResponse, c as BackfillGetResponse, G as GameSession, d as BackFillAcceptRequest, e as BackFillRejectRequest, N as NamespaceConfigList, f as NamespaceConfig, P as PatchNamespaceConfigRequest, L as ListEnvironmentVariablesResponse, g as ListMatchFunctionsResponse, M as MatchFunctionRequest, h as MatchFunctionConfig, i as ListMatchPoolsResponse, j as MatchPool, k as MatchPoolConfig, T as TicketMetricResultRecord, l as ListMatchPoolTicketsResponse, m as PlayerMetricRecord, o as MatchTicketResponse, n as MatchTicketRequest, p as MatchTicketStatuses, q as MatchTicketStatus, r as ListRuleSetsResponse, R as RuleSetPayload } from './TicketMetricResultRecord-BQOOYbA1.js';
import 'zod';

/**
 * AUTO GENERATED
 */

declare enum Key_ConfigAdmin {
    ConfigLog = "Matchmaking.ConfigAdmin.ConfigLog"
}
/**
 * Get Log Configuration.&lt;br&gt;
 *
 * #### Default Query Options
 * The default options include:
 * ```
 * {
 *    queryKey: [Key_ConfigAdmin.ConfigLog, input]
 * }
 * ```
 */
declare const useConfigAdminApi_GetConfigLog: (sdk: AccelByteSDK, input: SdkSetConfigParam, options?: Omit<UseQueryOptions<Configuration, AxiosError<ApiError>>, "queryKey">, callback?: (data: AxiosResponse<Configuration>) => void) => UseQueryResult<Configuration, AxiosError<ApiError>>;
/**
 * Update Log Configuration.&lt;br&gt;
 *
 * #### Default Query Options
 * The default options include:
 * ```
 * {
 *    queryKey: [Key_ConfigAdmin.ConfigLog, input]
 * }
 * ```
 */
declare const useConfigAdminApi_PatchConfigLogMutation: (sdk: AccelByteSDK, options?: Omit<UseMutationOptions<Configuration, AxiosError<ApiError>, SdkSetConfigParam & {
    data: Configuration;
}>, "mutationKey">, callback?: (data: Configuration) => void) => UseMutationResult<Configuration, AxiosError<ApiError>, SdkSetConfigParam & {
    data: Configuration;
}>;

/**
 * AUTO GENERATED
 */

declare enum Key_Backfill {
    Backfill = "Matchmaking.Backfill.Backfill",
    BackfillProposal = "Matchmaking.Backfill.BackfillProposal",
    Backfill_ByBackfillId = "Matchmaking.Backfill.Backfill_ByBackfillId",
    ProposalAccept_ByBackfillId = "Matchmaking.Backfill.ProposalAccept_ByBackfillId",
    ProposalReject_ByBackfillId = "Matchmaking.Backfill.ProposalReject_ByBackfillId"
}
/**
 * Create backfill ticket.
 *
 * #### Default Query Options
 * The default options include:
 * ```
 * {
 *    queryKey: [Key_Backfill.Backfill, input]
 * }
 * ```
 */
declare const useBackfillApi_CreateBackfillMutation: (sdk: AccelByteSDK, options?: Omit<UseMutationOptions<BackfillCreateResponse, AxiosError<ApiError>, SdkSetConfigParam & {
    data: BackFillCreateRequest;
}>, "mutationKey">, callback?: (data: BackfillCreateResponse) => void) => UseMutationResult<BackfillCreateResponse, AxiosError<ApiError>, SdkSetConfigParam & {
    data: BackFillCreateRequest;
}>;
/**
 * Get backfill proposal
 *
 * #### Default Query Options
 * The default options include:
 * ```
 * {
 *    queryKey: [Key_Backfill.BackfillProposal, input]
 * }
 * ```
 */
declare const useBackfillApi_GetBackfillProposal: (sdk: AccelByteSDK, input: SdkSetConfigParam & {
    queryParams: {
        sessionID: string | null;
    };
}, options?: Omit<UseQueryOptions<BackfillProposalResponse, AxiosError<ApiError>>, "queryKey">, callback?: (data: AxiosResponse<BackfillProposalResponse>) => void) => UseQueryResult<BackfillProposalResponse, AxiosError<ApiError>>;
/**
 * Delete backfill ticket.
 *
 * #### Default Query Options
 * The default options include:
 * ```
 * {
 *    queryKey: [Key_Backfill.Backfill_ByBackfillId, input]
 * }
 * ```
 */
declare const useBackfillApi_DeleteBackfill_ByBackfillIdMutation: (sdk: AccelByteSDK, options?: Omit<UseMutationOptions<unknown, AxiosError<ApiError>, SdkSetConfigParam & {
    backfillID: string;
}>, "mutationKey">, callback?: (data: unknown) => void) => UseMutationResult<unknown, AxiosError<ApiError>, SdkSetConfigParam & {
    backfillID: string;
}>;
/**
 * Get backfill ticket by ID
 *
 * #### Default Query Options
 * The default options include:
 * ```
 * {
 *    queryKey: [Key_Backfill.Backfill_ByBackfillId, input]
 * }
 * ```
 */
declare const useBackfillApi_GetBackfill_ByBackfillId: (sdk: AccelByteSDK, input: SdkSetConfigParam & {
    backfillID: string;
}, options?: Omit<UseQueryOptions<BackfillGetResponse, AxiosError<ApiError>>, "queryKey">, callback?: (data: AxiosResponse<BackfillGetResponse>) => void) => UseQueryResult<BackfillGetResponse, AxiosError<ApiError>>;
/**
 *  Accept backfill proposal. Field partialAcceptTicketIDs can be used to accept specific tickets within a backfill proposal. If the ticketIDs are not mentioned in this field, those tickets will be rejected and reactivated for future proposals.
 *
 * #### Default Query Options
 * The default options include:
 * ```
 * {
 *    queryKey: [Key_Backfill.ProposalAccept_ByBackfillId, input]
 * }
 * ```
 */
declare const useBackfillApi_UpdateProposalAccept_ByBackfillIdMutation: (sdk: AccelByteSDK, options?: Omit<UseMutationOptions<GameSession, AxiosError<ApiError>, SdkSetConfigParam & {
    backfillID: string;
    data: BackFillAcceptRequest;
}>, "mutationKey">, callback?: (data: GameSession) => void) => UseMutationResult<GameSession, AxiosError<ApiError>, SdkSetConfigParam & {
    backfillID: string;
    data: BackFillAcceptRequest;
}>;
/**
 * Reject backfill proposal
 *
 * #### Default Query Options
 * The default options include:
 * ```
 * {
 *    queryKey: [Key_Backfill.ProposalReject_ByBackfillId, input]
 * }
 * ```
 */
declare const useBackfillApi_UpdateProposalReject_ByBackfillIdMutation: (sdk: AccelByteSDK, options?: Omit<UseMutationOptions<unknown, AxiosError<ApiError>, SdkSetConfigParam & {
    backfillID: string;
    data: BackFillRejectRequest;
}>, "mutationKey">, callback?: (data: unknown) => void) => UseMutationResult<unknown, AxiosError<ApiError>, SdkSetConfigParam & {
    backfillID: string;
    data: BackFillRejectRequest;
}>;

/**
 * AUTO GENERATED
 */

declare enum Key_Config {
    Config = "Matchmaking.Config.Config",
    Config_ByNamespace = "Matchmaking.Config.Config_ByNamespace"
}
/**
 * Get matchmaking config of all namespaces. Will only return namespace configs than have been updated.
 *
 * #### Default Query Options
 * The default options include:
 * ```
 * {
 *    queryKey: [Key_Config.Config, input]
 * }
 * ```
 */
declare const useConfigApi_GetConfig: (sdk: AccelByteSDK, input: SdkSetConfigParam, options?: Omit<UseQueryOptions<NamespaceConfigList, AxiosError<ApiError>>, "queryKey">, callback?: (data: AxiosResponse<NamespaceConfigList>) => void) => UseQueryResult<NamespaceConfigList, AxiosError<ApiError>>;
/**
 * Get matchmaking config of a namespaces.
 *
 * #### Default Query Options
 * The default options include:
 * ```
 * {
 *    queryKey: [Key_Config.Config_ByNamespace, input]
 * }
 * ```
 */
declare const useConfigApi_GetConfig_ByNamespace: (sdk: AccelByteSDK, input: SdkSetConfigParam, options?: Omit<UseQueryOptions<NamespaceConfig, AxiosError<ApiError>>, "queryKey">, callback?: (data: AxiosResponse<NamespaceConfig>) => void) => UseQueryResult<NamespaceConfig, AxiosError<ApiError>>;
/**
 * Patch update matchmaking config of a namespaces. Partially update matchmaking config, will only update value that defined on the request.
 *
 * #### Default Query Options
 * The default options include:
 * ```
 * {
 *    queryKey: [Key_Config.Config_ByNamespace, input]
 * }
 * ```
 */
declare const useConfigApi_PatchConfig_ByNamespaceMutation: (sdk: AccelByteSDK, options?: Omit<UseMutationOptions<NamespaceConfig, AxiosError<ApiError>, SdkSetConfigParam & {
    data: PatchNamespaceConfigRequest;
}>, "mutationKey">, callback?: (data: NamespaceConfig) => void) => UseMutationResult<NamespaceConfig, AxiosError<ApiError>, SdkSetConfigParam & {
    data: PatchNamespaceConfigRequest;
}>;

/**
 * AUTO GENERATED
 */

declare enum Key_EnvironmentVariables {
    EnvironmentVariables = "Matchmaking.EnvironmentVariables.EnvironmentVariables"
}
/**
 * List environment variables.
 *
 * #### Default Query Options
 * The default options include:
 * ```
 * {
 *    queryKey: [Key_EnvironmentVariables.EnvironmentVariables, input]
 * }
 * ```
 */
declare const useEnvironmentVariablesApi_GetEnvironmentVariables: (sdk: AccelByteSDK, input: SdkSetConfigParam, options?: Omit<UseQueryOptions<ListEnvironmentVariablesResponse, AxiosError<ApiError>>, "queryKey">, callback?: (data: AxiosResponse<ListEnvironmentVariablesResponse>) => void) => UseQueryResult<ListEnvironmentVariablesResponse, AxiosError<ApiError>>;

/**
 * AUTO GENERATED
 */

declare enum Key_MatchFunctions {
    MatchFunctions = "Matchmaking.MatchFunctions.MatchFunctions",
    MatchFunction = "Matchmaking.MatchFunctions.MatchFunction",
    MatchFunction_ByName = "Matchmaking.MatchFunctions.MatchFunction_ByName"
}
/**
 * List existing match functions.
 *
 * #### Default Query Options
 * The default options include:
 * ```
 * {
 *    queryKey: [Key_MatchFunctions.MatchFunctions, input]
 * }
 * ```
 */
declare const useMatchFunctionsApi_GetMatchFunctions: (sdk: AccelByteSDK, input: SdkSetConfigParam & {
    queryParams?: {
        limit?: number;
        offset?: number;
    };
}, options?: Omit<UseQueryOptions<ListMatchFunctionsResponse, AxiosError<ApiError>>, "queryKey">, callback?: (data: AxiosResponse<ListMatchFunctionsResponse>) => void) => UseQueryResult<ListMatchFunctionsResponse, AxiosError<ApiError>>;
/**
 * Creates a new matchmaking function.
 *
 * #### Default Query Options
 * The default options include:
 * ```
 * {
 *    queryKey: [Key_MatchFunctions.MatchFunction, input]
 * }
 * ```
 */
declare const useMatchFunctionsApi_CreateMatchFunctionMutation: (sdk: AccelByteSDK, options?: Omit<UseMutationOptions<unknown, AxiosError<ApiError>, SdkSetConfigParam & {
    data: MatchFunctionRequest;
}>, "mutationKey">, callback?: (data: unknown) => void) => UseMutationResult<unknown, AxiosError<ApiError>, SdkSetConfigParam & {
    data: MatchFunctionRequest;
}>;
/**
 * Deletes an existing match function.
 *
 * #### Default Query Options
 * The default options include:
 * ```
 * {
 *    queryKey: [Key_MatchFunctions.MatchFunction_ByName, input]
 * }
 * ```
 */
declare const useMatchFunctionsApi_DeleteMatchFunction_ByNameMutation: (sdk: AccelByteSDK, options?: Omit<UseMutationOptions<unknown, AxiosError<ApiError>, SdkSetConfigParam & {
    name: string;
}>, "mutationKey">, callback?: (data: unknown) => void) => UseMutationResult<unknown, AxiosError<ApiError>, SdkSetConfigParam & {
    name: string;
}>;
/**
 * Update existing matchmaking function.
 *
 * #### Default Query Options
 * The default options include:
 * ```
 * {
 *    queryKey: [Key_MatchFunctions.MatchFunction_ByName, input]
 * }
 * ```
 */
declare const useMatchFunctionsApi_UpdateMatchFunction_ByNameMutation: (sdk: AccelByteSDK, options?: Omit<UseMutationOptions<MatchFunctionConfig, AxiosError<ApiError>, SdkSetConfigParam & {
    name: string;
    data: MatchFunctionRequest;
}>, "mutationKey">, callback?: (data: MatchFunctionConfig) => void) => UseMutationResult<MatchFunctionConfig, AxiosError<ApiError>, SdkSetConfigParam & {
    name: string;
    data: MatchFunctionRequest;
}>;

/**
 * AUTO GENERATED
 */

declare enum Key_MatchPools {
    MatchPools = "Matchmaking.MatchPools.MatchPools",
    MatchPool = "Matchmaking.MatchPools.MatchPool",
    MatchPool_ByPool = "Matchmaking.MatchPools.MatchPool_ByPool",
    Metrics_ByPool = "Matchmaking.MatchPools.Metrics_ByPool",
    Tickets_ByPool = "Matchmaking.MatchPools.Tickets_ByPool",
    MetricsPlayer_ByPool = "Matchmaking.MatchPools.MetricsPlayer_ByPool",
    MetricsPlayer_ByPool_ByNS = "Matchmaking.MatchPools.MetricsPlayer_ByPool_ByNS"
}
/**
 * List matchmaking pools.
 *
 * #### Default Query Options
 * The default options include:
 * ```
 * {
 *    queryKey: [Key_MatchPools.MatchPools, input]
 * }
 * ```
 */
declare const useMatchPoolsApi_GetMatchPools: (sdk: AccelByteSDK, input: SdkSetConfigParam & {
    queryParams?: {
        limit?: number;
        name?: string | null;
        offset?: number;
    };
}, options?: Omit<UseQueryOptions<ListMatchPoolsResponse, AxiosError<ApiError>>, "queryKey">, callback?: (data: AxiosResponse<ListMatchPoolsResponse>) => void) => UseQueryResult<ListMatchPoolsResponse, AxiosError<ApiError>>;
/**
 * Creates a new matchmaking pool. A pool is isolated from other pools (i.e. tickets may be matched with other tickets in the same pool, but not with tickets in other pools). Each pool has its own matchmaking rules and/or logic. ticket_expiration_seconds and backfill_ticket_expiration_seconds will be set to 300 seconds (5 minutes) by default if not filled. Match Function holds information about the name of the match logic server that matchmaking can refers to. By default we provide (&#34;default&#34; and &#34;basic&#34;). Match Function will be used as reference value for Match Function Overrides if not set. In case Customer would like to use matchmaking service default match logic, then specify it in &#34;match_function_overrides&#34;. This sample configuration will let matchmaking service will use &#34;default&#34; match logic for make matches, while validation will hit both &#34;default&#34; and &#34;custom&#34; match logics. e.g. { &#34;match_function&#34;: &#34;custom&#34;, &#34;match_function_overrides&#34;: { &#34;validation&#34;: []{&#34;default&#34;,&#34;custom&#34;}, &#34;make_matches&#34;: &#34;default&#34;, } }
 *
 * #### Default Query Options
 * The default options include:
 * ```
 * {
 *    queryKey: [Key_MatchPools.MatchPool, input]
 * }
 * ```
 */
declare const useMatchPoolsApi_CreateMatchPoolMutation: (sdk: AccelByteSDK, options?: Omit<UseMutationOptions<unknown, AxiosError<ApiError>, SdkSetConfigParam & {
    data: MatchPool;
}>, "mutationKey">, callback?: (data: unknown) => void) => UseMutationResult<unknown, AxiosError<ApiError>, SdkSetConfigParam & {
    data: MatchPool;
}>;
/**
 * Deletes an existing matchmaking pool.
 *
 * #### Default Query Options
 * The default options include:
 * ```
 * {
 *    queryKey: [Key_MatchPools.MatchPool_ByPool, input]
 * }
 * ```
 */
declare const useMatchPoolsApi_DeleteMatchPool_ByPoolMutation: (sdk: AccelByteSDK, options?: Omit<UseMutationOptions<unknown, AxiosError<ApiError>, SdkSetConfigParam & {
    pool: string;
}>, "mutationKey">, callback?: (data: unknown) => void) => UseMutationResult<unknown, AxiosError<ApiError>, SdkSetConfigParam & {
    pool: string;
}>;
/**
 * Get details for a specific match pool
 *
 * #### Default Query Options
 * The default options include:
 * ```
 * {
 *    queryKey: [Key_MatchPools.MatchPool_ByPool, input]
 * }
 * ```
 */
declare const useMatchPoolsApi_GetMatchPool_ByPool: (sdk: AccelByteSDK, input: SdkSetConfigParam & {
    pool: string;
}, options?: Omit<UseQueryOptions<MatchPool, AxiosError<ApiError>>, "queryKey">, callback?: (data: AxiosResponse<MatchPool>) => void) => UseQueryResult<MatchPool, AxiosError<ApiError>>;
/**
 * Updates an existing matchmaking pool. ticket_expiration_seconds and backfill_ticket_expiration_seconds will be set to 300 seconds (5 minutes) by default if not filled. Match Function holds information about the name of the match logic server that matchmaking can refers to. By default we provide (&#34;default&#34; and &#34;basic&#34;). Match Function will be used as reference value for Match Function Overrides if not set. In case Customer would like to use matchmaking service default match logic, then specify it in &#34;match_function_overrides&#34;. This sample configuration will let matchmaking service will use &#34;default&#34; match logic for make matches, while validation will hit both &#34;default&#34; and &#34;custom&#34; match logics. e.g. { &#34;match_function&#34;: &#34;custom&#34;, &#34;match_function_overrides&#34;: { &#34;validation&#34;: []{&#34;default&#34;,&#34;custom&#34;}, &#34;make_matches&#34;: &#34;default&#34;, } }
 *
 * #### Default Query Options
 * The default options include:
 * ```
 * {
 *    queryKey: [Key_MatchPools.MatchPool_ByPool, input]
 * }
 * ```
 */
declare const useMatchPoolsApi_UpdateMatchPool_ByPoolMutation: (sdk: AccelByteSDK, options?: Omit<UseMutationOptions<MatchPool, AxiosError<ApiError>, SdkSetConfigParam & {
    pool: string;
    data: MatchPoolConfig;
}>, "mutationKey">, callback?: (data: MatchPool) => void) => UseMutationResult<MatchPool, AxiosError<ApiError>, SdkSetConfigParam & {
    pool: string;
    data: MatchPoolConfig;
}>;
/**
 * Get metric for a specific match pool Result: queueTime in seconds
 *
 * #### Default Query Options
 * The default options include:
 * ```
 * {
 *    queryKey: [Key_MatchPools.Metrics_ByPool, input]
 * }
 * ```
 */
declare const useMatchPoolsApi_GetMetrics_ByPool: (sdk: AccelByteSDK, input: SdkSetConfigParam & {
    pool: string;
}, options?: Omit<UseQueryOptions<TicketMetricResultRecord, AxiosError<ApiError>>, "queryKey">, callback?: (data: AxiosResponse<TicketMetricResultRecord>) => void) => UseQueryResult<TicketMetricResultRecord, AxiosError<ApiError>>;
/**
 * Get tickets in queue for a specific match pool Result: number of tickets and list of ticket detail in a match pool.
 *
 * #### Default Query Options
 * The default options include:
 * ```
 * {
 *    queryKey: [Key_MatchPools.Tickets_ByPool, input]
 * }
 * ```
 */
declare const useMatchPoolsApi_GetTickets_ByPool: (sdk: AccelByteSDK, input: SdkSetConfigParam & {
    pool: string;
    queryParams?: {
        limit?: number;
        offset?: number;
    };
}, options?: Omit<UseQueryOptions<ListMatchPoolTicketsResponse, AxiosError<ApiError>>, "queryKey">, callback?: (data: AxiosResponse<ListMatchPoolTicketsResponse>) => void) => UseQueryResult<ListMatchPoolTicketsResponse, AxiosError<ApiError>>;
/**
 * Get player metric for a specific match pool
 *
 * #### Default Query Options
 * The default options include:
 * ```
 * {
 *    queryKey: [Key_MatchPools.MetricsPlayer_ByPool, input]
 * }
 * ```
 */
declare const useMatchPoolsApi_GetMetricsPlayer_ByPool: (sdk: AccelByteSDK, input: SdkSetConfigParam & {
    pool: string;
}, options?: Omit<UseQueryOptions<PlayerMetricRecord, AxiosError<ApiError>>, "queryKey">, callback?: (data: AxiosResponse<PlayerMetricRecord>) => void) => UseQueryResult<PlayerMetricRecord, AxiosError<ApiError>>;
/**
 * Public get player metric for a specific match pool
 *
 * #### Default Query Options
 * The default options include:
 * ```
 * {
 *    queryKey: [Key_MatchPools.MetricsPlayer_ByPool_ByNS, input]
 * }
 * ```
 */
declare const useMatchPoolsApi_GetMetricsPlayer_ByPool_ByNS: (sdk: AccelByteSDK, input: SdkSetConfigParam & {
    pool: string;
}, options?: Omit<UseQueryOptions<PlayerMetricRecord, AxiosError<ApiError>>, "queryKey">, callback?: (data: AxiosResponse<PlayerMetricRecord>) => void) => UseQueryResult<PlayerMetricRecord, AxiosError<ApiError>>;

/**
 * AUTO GENERATED
 */

declare enum Key_MatchTickets {
    MatchTicket = "Matchmaking.MatchTickets.MatchTicket",
    MatchTicketsMe = "Matchmaking.MatchTickets.MatchTicketsMe",
    MatchTicket_ByTicketid = "Matchmaking.MatchTickets.MatchTicket_ByTicketid"
}
/**
 * Creates a new request for matchmaking. Cross Platform: Allow player to play game with &#34;all&#34; registered platforms. 1. Cross Platform can be enabled through session service or create match ticket. a. via ticket: specify several cross_platform on create match ticket attributes. **[DEPRECATED]** client should not send from attribute &lt;code&gt;cross_platform&lt;/code&gt; will be populated from backend This value will override player attributes in session service. e.g. cross_platform:[xbox,psn,steam] b. via session service: set player/party cross_platform attributes. c. Enable match options ruleset with name cross_platform and type &#34;all&#34;. ``` { &#34;name&#34;: &#34;co-op&#34;, &#34;data&#34;: { &#34;alliance&#34;: { &#34;min_number&#34;: 1, &#34;max_number&#34;: 1, &#34;player_min_number&#34;: 1, &#34;player_max_number&#34;: 4 }, &#34;match_options&#34;: { &#34;options&#34;: [ {&#34;name&#34;: &#34;cross_platform&#34;, &#34;type&#34;: &#34;all&#34;} ] } } } ``` 2. Cross Platform can be disabled from the matchpool configuration &lt;code&gt;crossplay_disabled=true&lt;/code&gt; 3. When matchpool &lt;code&gt;crossplay_disabled=false&lt;/code&gt; * request attribute cross_platform is empty **[Recommended]**: * Matchmaking will consider Party leader &lt;code&gt;crossplayEnabled&lt;/code&gt; preference or Session attribute &lt;code&gt;crossplayEnabled&lt;/code&gt; preference. * When &lt;code&gt;crossplayEnabled=true&lt;/code&gt; &lt;code&gt;cross_platforms&lt;/code&gt; attributes will be populated from [active login methods](/iam/apidocs/#/Third%20Party%20Credential/RetrieveAllActiveThirdPartyLoginPlatformCredentialPublicV3) otherwise it will set to leader current platform * When &lt;code&gt;crossplayEnabled=false&lt;/code&gt; &lt;code&gt;cross_platforms&lt;/code&gt; attributes will be set to user&#39;s currentPlatform * request attribute cross_platform is not empty **[Not Recommended]**: * Cross Platform can be disabled with specify only ONE cross_platform. Current matchmaking use this behavior. e.g. cross_platform:[xbox] * Multiple cross_platform values is considered to be crossplay enabled 4. This behavior only works for Default Matchmaker. Custom matchmaker (custom gRPC matchmaker) need to consider this on its own implementation. ExcludedSessions: allow player to list out game sessions that they want to avoid matching, for example a match that they&#39;ve recently left or get kicked out from.
 *
 * #### Default Query Options
 * The default options include:
 * ```
 * {
 *    queryKey: [Key_MatchTickets.MatchTicket, input]
 * }
 * ```
 */
declare const useMatchTicketsApi_CreateMatchTicketMutation: (sdk: AccelByteSDK, options?: Omit<UseMutationOptions<MatchTicketResponse, AxiosError<ApiError>, SdkSetConfigParam & {
    data: MatchTicketRequest;
}>, "mutationKey">, callback?: (data: MatchTicketResponse) => void) => UseMutationResult<MatchTicketResponse, AxiosError<ApiError>, SdkSetConfigParam & {
    data: MatchTicketRequest;
}>;
/**
 * Get my match tickets.
 *
 * #### Default Query Options
 * The default options include:
 * ```
 * {
 *    queryKey: [Key_MatchTickets.MatchTicketsMe, input]
 * }
 * ```
 */
declare const useMatchTicketsApi_GetMatchTicketsMe: (sdk: AccelByteSDK, input: SdkSetConfigParam & {
    queryParams?: {
        limit?: number;
        matchPool?: string | null;
        offset?: number;
    };
}, options?: Omit<UseQueryOptions<MatchTicketStatuses, AxiosError<ApiError>>, "queryKey">, callback?: (data: AxiosResponse<MatchTicketStatuses>) => void) => UseQueryResult<MatchTicketStatuses, AxiosError<ApiError>>;
/**
 * Deletes an existing matchmaking ticket.
 *
 * #### Default Query Options
 * The default options include:
 * ```
 * {
 *    queryKey: [Key_MatchTickets.MatchTicket_ByTicketid, input]
 * }
 * ```
 */
declare const useMatchTicketsApi_DeleteMatchTicket_ByTicketidMutation: (sdk: AccelByteSDK, options?: Omit<UseMutationOptions<unknown, AxiosError<ApiError>, SdkSetConfigParam & {
    ticketid: string;
}>, "mutationKey">, callback?: (data: unknown) => void) => UseMutationResult<unknown, AxiosError<ApiError>, SdkSetConfigParam & {
    ticketid: string;
}>;
/**
 * Get details for a specific match ticket
 *
 * #### Default Query Options
 * The default options include:
 * ```
 * {
 *    queryKey: [Key_MatchTickets.MatchTicket_ByTicketid, input]
 * }
 * ```
 */
declare const useMatchTicketsApi_GetMatchTicket_ByTicketid: (sdk: AccelByteSDK, input: SdkSetConfigParam & {
    ticketid: string;
}, options?: Omit<UseQueryOptions<MatchTicketStatus, AxiosError<ApiError>>, "queryKey">, callback?: (data: AxiosResponse<MatchTicketStatus>) => void) => UseQueryResult<MatchTicketStatus, AxiosError<ApiError>>;

/**
 * AUTO GENERATED
 */

declare enum Key_RuleSets {
    Rulesets = "Matchmaking.RuleSets.Rulesets",
    Ruleset = "Matchmaking.RuleSets.Ruleset",
    Ruleset_ByRuleset = "Matchmaking.RuleSets.Ruleset_ByRuleset"
}
/**
 * List rule sets.
 *
 * #### Default Query Options
 * The default options include:
 * ```
 * {
 *    queryKey: [Key_RuleSets.Rulesets, input]
 * }
 * ```
 */
declare const useRuleSetsApi_GetRulesets: (sdk: AccelByteSDK, input: SdkSetConfigParam & {
    queryParams?: {
        limit?: number;
        name?: string | null;
        offset?: number;
    };
}, options?: Omit<UseQueryOptions<ListRuleSetsResponse, AxiosError<ApiError>>, "queryKey">, callback?: (data: AxiosResponse<ListRuleSetsResponse>) => void) => UseQueryResult<ListRuleSetsResponse, AxiosError<ApiError>>;
/**
 * Creates a new rules set. A rule set has a name and contains arbitrary data which is meaningful to some particular match function(s) The name is used for a match pool to select the ruleset data that should be sent to the match function when matchmaking in that pool. To use custom rules set please set enable_custom_match_function=true. Default (false). When custom enable_custom_match_function=true, the ruleset will only validate if the rule is valid json.
 *
 * #### Default Query Options
 * The default options include:
 * ```
 * {
 *    queryKey: [Key_RuleSets.Ruleset, input]
 * }
 * ```
 */
declare const useRuleSetsApi_CreateRulesetMutation: (sdk: AccelByteSDK, options?: Omit<UseMutationOptions<unknown, AxiosError<ApiError>, SdkSetConfigParam & {
    data: RuleSetPayload;
}>, "mutationKey">, callback?: (data: unknown) => void) => UseMutationResult<unknown, AxiosError<ApiError>, SdkSetConfigParam & {
    data: RuleSetPayload;
}>;
/**
 * Deletes an existing rule set.
 *
 * #### Default Query Options
 * The default options include:
 * ```
 * {
 *    queryKey: [Key_RuleSets.Ruleset_ByRuleset, input]
 * }
 * ```
 */
declare const useRuleSetsApi_DeleteRuleset_ByRulesetMutation: (sdk: AccelByteSDK, options?: Omit<UseMutationOptions<unknown, AxiosError<ApiError>, SdkSetConfigParam & {
    ruleset: string;
}>, "mutationKey">, callback?: (data: unknown) => void) => UseMutationResult<unknown, AxiosError<ApiError>, SdkSetConfigParam & {
    ruleset: string;
}>;
/**
 * Get details for a specific rule set
 *
 * #### Default Query Options
 * The default options include:
 * ```
 * {
 *    queryKey: [Key_RuleSets.Ruleset_ByRuleset, input]
 * }
 * ```
 */
declare const useRuleSetsApi_GetRuleset_ByRuleset: (sdk: AccelByteSDK, input: SdkSetConfigParam & {
    ruleset: string;
}, options?: Omit<UseQueryOptions<RuleSetPayload, AxiosError<ApiError>>, "queryKey">, callback?: (data: AxiosResponse<RuleSetPayload>) => void) => UseQueryResult<RuleSetPayload, AxiosError<ApiError>>;
/**
 * Updates an existing matchmaking rule set. To use custom rules set please set enable_custom_match_function=true. Default (false). When custom enable_custom_match_function=true, the ruleset will only validate if the rule is valid json.
 *
 * #### Default Query Options
 * The default options include:
 * ```
 * {
 *    queryKey: [Key_RuleSets.Ruleset_ByRuleset, input]
 * }
 * ```
 */
declare const useRuleSetsApi_UpdateRuleset_ByRulesetMutation: (sdk: AccelByteSDK, options?: Omit<UseMutationOptions<RuleSetPayload, AxiosError<ApiError>, SdkSetConfigParam & {
    ruleset: string;
    data: RuleSetPayload;
}>, "mutationKey">, callback?: (data: RuleSetPayload) => void) => UseMutationResult<RuleSetPayload, AxiosError<ApiError>, SdkSetConfigParam & {
    ruleset: string;
    data: RuleSetPayload;
}>;

export { Key_Backfill, Key_Config, Key_ConfigAdmin, Key_EnvironmentVariables, Key_MatchFunctions, Key_MatchPools, Key_MatchTickets, Key_RuleSets, useBackfillApi_CreateBackfillMutation, useBackfillApi_DeleteBackfill_ByBackfillIdMutation, useBackfillApi_GetBackfillProposal, useBackfillApi_GetBackfill_ByBackfillId, useBackfillApi_UpdateProposalAccept_ByBackfillIdMutation, useBackfillApi_UpdateProposalReject_ByBackfillIdMutation, useConfigAdminApi_GetConfigLog, useConfigAdminApi_PatchConfigLogMutation, useConfigApi_GetConfig, useConfigApi_GetConfig_ByNamespace, useConfigApi_PatchConfig_ByNamespaceMutation, useEnvironmentVariablesApi_GetEnvironmentVariables, useMatchFunctionsApi_CreateMatchFunctionMutation, useMatchFunctionsApi_DeleteMatchFunction_ByNameMutation, useMatchFunctionsApi_GetMatchFunctions, useMatchFunctionsApi_UpdateMatchFunction_ByNameMutation, useMatchPoolsApi_CreateMatchPoolMutation, useMatchPoolsApi_DeleteMatchPool_ByPoolMutation, useMatchPoolsApi_GetMatchPool_ByPool, useMatchPoolsApi_GetMatchPools, useMatchPoolsApi_GetMetricsPlayer_ByPool, useMatchPoolsApi_GetMetricsPlayer_ByPool_ByNS, useMatchPoolsApi_GetMetrics_ByPool, useMatchPoolsApi_GetTickets_ByPool, useMatchPoolsApi_UpdateMatchPool_ByPoolMutation, useMatchTicketsApi_CreateMatchTicketMutation, useMatchTicketsApi_DeleteMatchTicket_ByTicketidMutation, useMatchTicketsApi_GetMatchTicket_ByTicketid, useMatchTicketsApi_GetMatchTicketsMe, useRuleSetsApi_CreateRulesetMutation, useRuleSetsApi_DeleteRuleset_ByRulesetMutation, useRuleSetsApi_GetRuleset_ByRuleset, useRuleSetsApi_GetRulesets, useRuleSetsApi_UpdateRuleset_ByRulesetMutation };

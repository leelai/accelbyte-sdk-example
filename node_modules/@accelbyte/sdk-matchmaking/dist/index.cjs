"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name2 in all)
    __defProp(target, name2, { get: all[name2], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/index.ts
var src_exports = {};
__export(src_exports, {
  BackFillAcceptRequest: () => BackFillAcceptRequest,
  BackFillCreateRequest: () => BackFillCreateRequest,
  BackFillRejectRequest: () => BackFillRejectRequest,
  Backfill$: () => Backfill$,
  BackfillApi: () => BackfillApi,
  BackfillCreateResponse: () => BackfillCreateResponse,
  BackfillGetResponse: () => BackfillGetResponse,
  BackfillProposalResponse: () => BackfillProposalResponse,
  Config$: () => Config$,
  ConfigAdmin$: () => ConfigAdmin$,
  ConfigAdminApi: () => ConfigAdminApi,
  ConfigApi: () => ConfigApi,
  Configuration: () => Configuration,
  DsInformation: () => DsInformation,
  EnvironmentVariable: () => EnvironmentVariable,
  EnvironmentVariables$: () => EnvironmentVariables$,
  EnvironmentVariablesApi: () => EnvironmentVariablesApi,
  Error: () => Error2,
  GameSession: () => GameSession,
  ListEnvironmentVariablesResponse: () => ListEnvironmentVariablesResponse,
  ListMatchFunctionsResponse: () => ListMatchFunctionsResponse,
  ListMatchPoolTicketsResponse: () => ListMatchPoolTicketsResponse,
  ListMatchPoolsResponse: () => ListMatchPoolsResponse,
  ListRuleSetsResponse: () => ListRuleSetsResponse,
  Match: () => Match,
  MatchFunctionConfig: () => MatchFunctionConfig,
  MatchFunctionOverride: () => MatchFunctionOverride,
  MatchFunctionRequest: () => MatchFunctionRequest,
  MatchFunctions$: () => MatchFunctions$,
  MatchFunctionsApi: () => MatchFunctionsApi,
  MatchPool: () => MatchPool,
  MatchPoolConfig: () => MatchPoolConfig,
  MatchPools$: () => MatchPools$,
  MatchPoolsApi: () => MatchPoolsApi,
  MatchRuleSetNameData: () => MatchRuleSetNameData,
  MatchTicketRecord: () => MatchTicketRecord,
  MatchTicketRequest: () => MatchTicketRequest,
  MatchTicketResponse: () => MatchTicketResponse,
  MatchTicketStatus: () => MatchTicketStatus,
  MatchTicketStatuses: () => MatchTicketStatuses,
  MatchTickets$: () => MatchTickets$,
  MatchTicketsApi: () => MatchTicketsApi,
  Matchmaking: () => Matchmaking,
  NamespaceConfig: () => NamespaceConfig,
  NamespaceConfigList: () => NamespaceConfigList,
  Pagination: () => Pagination,
  Party: () => Party,
  PatchNamespaceConfigRequest: () => PatchNamespaceConfigRequest,
  PlayerData: () => PlayerData,
  PlayerMetricRecord: () => PlayerMetricRecord,
  ProposedProposal: () => ProposedProposal,
  RuleSetPayload: () => RuleSetPayload,
  RuleSetPayloadData: () => RuleSetPayloadData,
  RuleSets$: () => RuleSets$,
  RuleSetsApi: () => RuleSetsApi,
  Server: () => Server,
  Team: () => Team,
  Ticket: () => Ticket,
  TicketMetricResultRecord: () => TicketMetricResultRecord,
  User: () => User
});
module.exports = __toCommonJS(src_exports);

// src/generated-admin/ConfigAdminApi.ts
var import_sdk2 = require("@accelbyte/sdk");

// src/generated-admin/endpoints/ConfigAdmin$.ts
var import_sdk = require("@accelbyte/sdk");

// src/generated-definitions/Configuration.ts
var import_zod = require("zod");
var Configuration = import_zod.z.object({
  clientVersion: import_zod.z.string(),
  deployment: import_zod.z.string(),
  inactiveTimeout: import_zod.z.number().int(),
  inviteTimeout: import_zod.z.number().int(),
  joinability: import_zod.z.string(),
  maxPlayers: import_zod.z.number().int(),
  minPlayers: import_zod.z.number().int(),
  name: import_zod.z.string(),
  requestedRegions: import_zod.z.array(import_zod.z.string()),
  type: import_zod.z.string()
});

// src/generated-admin/endpoints/ConfigAdmin$.ts
var ConfigAdmin$ = class {
  // @ts-ignore
  // prettier-ignore
  constructor(axiosInstance, namespace, useSchemaValidation = true) {
    this.axiosInstance = axiosInstance;
    this.namespace = namespace;
    this.useSchemaValidation = useSchemaValidation;
  }
  /**
   * Get Log Configuration.&lt;br&gt;
   */
  getConfigLog() {
    const params = {};
    const url = "/match2/v1/admin/config/log";
    const resultPromise = this.axiosInstance.get(url, { params });
    return import_sdk.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, Configuration, "Configuration");
  }
  /**
   * Update Log Configuration.&lt;br&gt;
   */
  patchConfigLog(data) {
    const params = {};
    const url = "/match2/v1/admin/config/log";
    const resultPromise = this.axiosInstance.patch(url, data, { params });
    return import_sdk.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, Configuration, "Configuration");
  }
};

// src/generated-admin/ConfigAdminApi.ts
function ConfigAdminApi(sdk, args) {
  const sdkAssembly = sdk.assembly();
  const namespace = args?.coreConfig?.namespace ?? sdkAssembly.coreConfig.namespace;
  const useSchemaValidation = args?.coreConfig?.useSchemaValidation ?? sdkAssembly.coreConfig.useSchemaValidation;
  let axiosInstance = sdkAssembly.axiosInstance;
  const requestConfigOverrides = args?.axiosConfig?.request;
  const baseURLOverride = args?.coreConfig?.baseURL;
  const interceptorsOverride = args?.axiosConfig?.interceptors ?? [];
  if (requestConfigOverrides || baseURLOverride || interceptorsOverride.length > 0) {
    const requestConfig = import_sdk2.ApiUtils.mergeAxiosConfigs(sdkAssembly.axiosInstance.defaults, {
      ...baseURLOverride ? { baseURL: baseURLOverride } : {},
      ...requestConfigOverrides
    });
    axiosInstance = import_sdk2.Network.create(requestConfig);
    for (const interceptor of interceptorsOverride) {
      if (interceptor.type === "request") {
        axiosInstance.interceptors.request.use(interceptor.onRequest, interceptor.onError);
      }
      if (interceptor.type === "response") {
        axiosInstance.interceptors.response.use(interceptor.onSuccess, interceptor.onError);
      }
    }
  }
  async function getConfigLog() {
    const $ = new ConfigAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getConfigLog();
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function patchConfigLog(data) {
    const $ = new ConfigAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.patchConfigLog(data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  return {
    /**
     * Get Log Configuration.&lt;br&gt;
     */
    getConfigLog,
    /**
     * Update Log Configuration.&lt;br&gt;
     */
    patchConfigLog
  };
}

// src/generated-definitions/BackFillAcceptRequest.ts
var import_zod2 = require("zod");
var BackFillAcceptRequest = import_zod2.z.object({
  partialAcceptTicketIDs: import_zod2.z.array(import_zod2.z.string()).nullish(),
  proposalId: import_zod2.z.string(),
  stop: import_zod2.z.boolean()
});

// src/generated-definitions/BackFillCreateRequest.ts
var import_zod3 = require("zod");
var BackFillCreateRequest = import_zod3.z.object({ matchPool: import_zod3.z.string(), sessionId: import_zod3.z.string() });

// src/generated-definitions/BackfillCreateResponse.ts
var import_zod4 = require("zod");
var BackfillCreateResponse = import_zod4.z.object({ id: import_zod4.z.string() });

// src/generated-definitions/BackfillGetResponse.ts
var import_zod11 = require("zod");

// src/generated-definitions/Match.ts
var import_zod10 = require("zod");

// src/generated-definitions/Team.ts
var import_zod6 = require("zod");

// src/generated-definitions/Party.ts
var import_zod5 = require("zod");
var Party = import_zod5.z.object({ partyID: import_zod5.z.string().nullish(), userIDs: import_zod5.z.array(import_zod5.z.string()).nullish() });

// src/generated-definitions/Team.ts
var Team = import_zod6.z.object({ Parties: import_zod6.z.array(Party).nullish(), UserIDs: import_zod6.z.array(import_zod6.z.string()).nullish() });

// src/generated-definitions/Ticket.ts
var import_zod9 = require("zod");

// src/generated-definitions/PlayerData.ts
var import_zod7 = require("zod");
var PlayerData = import_zod7.z.object({ Attributes: import_zod7.z.record(import_zod7.z.any()), PartyID: import_zod7.z.string(), PlatformID: import_zod7.z.string(), PlayerID: import_zod7.z.string() });

// src/generated-definitions/ProposedProposal.ts
var import_zod8 = require("zod");
var ProposedProposal = import_zod8.z.object({ BackfillID: import_zod8.z.string(), ProposalID: import_zod8.z.string(), Status: import_zod8.z.string() });

// src/generated-definitions/Ticket.ts
var Ticket = import_zod9.z.object({
  CreatedAt: import_zod9.z.string(),
  ExcludedSessions: import_zod9.z.array(import_zod9.z.string()),
  IsActive: import_zod9.z.boolean(),
  IsPivot: import_zod9.z.boolean(),
  IsSinglePlay: import_zod9.z.boolean(),
  Latencies: import_zod9.z.record(import_zod9.z.number().int()),
  MatchPool: import_zod9.z.string(),
  MatchedAt: import_zod9.z.string(),
  Namespace: import_zod9.z.string(),
  PartySessionID: import_zod9.z.string(),
  Players: import_zod9.z.array(PlayerData),
  ProposedProposal,
  TicketAttributes: import_zod9.z.record(import_zod9.z.any()),
  TicketID: import_zod9.z.string(),
  TicketInformation: import_zod9.z.record(import_zod9.z.any())
});

// src/generated-definitions/Match.ts
var Match = import_zod10.z.object({
  backfill: import_zod10.z.boolean().nullish(),
  clientVersion: import_zod10.z.string().nullish(),
  matchAttributes: import_zod10.z.record(import_zod10.z.any()).nullish(),
  regionPreference: import_zod10.z.array(import_zod10.z.string()).nullish(),
  serverName: import_zod10.z.string().nullish(),
  teams: import_zod10.z.array(Team).nullish(),
  tickets: import_zod10.z.array(Ticket).nullish()
});

// src/generated-definitions/BackfillGetResponse.ts
var BackfillGetResponse = import_zod11.z.object({
  createdAt: import_zod11.z.string().nullish(),
  matchPool: import_zod11.z.string().nullish(),
  matchSessionID: import_zod11.z.string().nullish(),
  partialMatch: Match.nullish(),
  ticketID: import_zod11.z.string().nullish()
});

// src/generated-definitions/BackfillProposalResponse.ts
var import_zod12 = require("zod");
var BackfillProposalResponse = import_zod12.z.object({
  backfillTicketID: import_zod12.z.string().nullish(),
  createdAt: import_zod12.z.string().nullish(),
  matchPool: import_zod12.z.string().nullish(),
  matchSessionID: import_zod12.z.string().nullish(),
  proposalID: import_zod12.z.string().nullish(),
  proposedTeams: import_zod12.z.array(Team).nullish(),
  tickets: import_zod12.z.array(Ticket).nullish()
});

// src/generated-definitions/BackFillRejectRequest.ts
var import_zod13 = require("zod");
var BackFillRejectRequest = import_zod13.z.object({ proposalId: import_zod13.z.string(), stop: import_zod13.z.boolean() });

// src/generated-definitions/DsInformation.ts
var import_zod15 = require("zod");

// src/generated-definitions/Server.ts
var import_zod14 = require("zod");
var Server = import_zod14.z.object({
  alternate_ips: import_zod14.z.array(import_zod14.z.string()),
  custom_attribute: import_zod14.z.string(),
  deployment: import_zod14.z.string(),
  game_version: import_zod14.z.string(),
  image_version: import_zod14.z.string(),
  ip: import_zod14.z.string(),
  is_override_game_version: import_zod14.z.boolean(),
  last_update: import_zod14.z.string(),
  namespace: import_zod14.z.string(),
  pod_name: import_zod14.z.string(),
  port: import_zod14.z.number().int(),
  ports: import_zod14.z.record(import_zod14.z.number().int()),
  protocol: import_zod14.z.string(),
  provider: import_zod14.z.string(),
  region: import_zod14.z.string(),
  session_id: import_zod14.z.string(),
  status: import_zod14.z.string()
});

// src/generated-definitions/DsInformation.ts
var DsInformation = import_zod15.z.object({
  MinPlayers: import_zod15.z.number().int(),
  RequestedAt: import_zod15.z.string(),
  RequestedRegions: import_zod15.z.array(import_zod15.z.string()),
  Server,
  Status: import_zod15.z.string()
});

// src/generated-definitions/EnvironmentVariable.ts
var import_zod16 = require("zod");
var EnvironmentVariable = import_zod16.z.object({
  actualValue: import_zod16.z.string().nullish(),
  defaultValue: import_zod16.z.string().nullish(),
  description: import_zod16.z.string().nullish(),
  name: import_zod16.z.string()
});

// src/generated-definitions/Error.ts
var import_zod17 = require("zod");
var Error2 = import_zod17.z.object({ ErrorCode: import_zod17.z.number().int(), ErrorMessage: import_zod17.z.string() });

// src/generated-definitions/GameSession.ts
var import_zod19 = require("zod");

// src/generated-definitions/User.ts
var import_zod18 = require("zod");
var User = import_zod18.z.object({
  ID: import_zod18.z.string(),
  PlatformID: import_zod18.z.string(),
  PlatformUserID: import_zod18.z.string(),
  PreviousStatus: import_zod18.z.string().nullish(),
  Status: import_zod18.z.string(),
  StatusV2: import_zod18.z.string(),
  UpdatedAt: import_zod18.z.string()
});

// src/generated-definitions/GameSession.ts
var GameSession = import_zod19.z.object({
  DSInformation: DsInformation,
  GameMode: import_zod19.z.string(),
  IsFull: import_zod19.z.boolean(),
  JoinType: import_zod19.z.string(),
  Members: import_zod19.z.array(User),
  attributes: import_zod19.z.record(import_zod19.z.any()),
  backfillTicketID: import_zod19.z.string(),
  configuration: Configuration,
  createdAt: import_zod19.z.string(),
  id: import_zod19.z.string(),
  leaderID: import_zod19.z.string(),
  matchPool: import_zod19.z.string(),
  namespace: import_zod19.z.string(),
  teams: import_zod19.z.array(Team),
  updatedAt: import_zod19.z.string(),
  version: import_zod19.z.number().int()
});

// src/generated-definitions/ListEnvironmentVariablesResponse.ts
var import_zod20 = require("zod");
var ListEnvironmentVariablesResponse = import_zod20.z.object({ data: import_zod20.z.array(EnvironmentVariable) });

// src/generated-definitions/ListMatchFunctionsResponse.ts
var import_zod23 = require("zod");

// src/generated-definitions/MatchFunctionConfig.ts
var import_zod21 = require("zod");
var MatchFunctionConfig = import_zod21.z.object({ match_function: import_zod21.z.string(), serviceAppName: import_zod21.z.string().nullish(), url: import_zod21.z.string() });

// src/generated-definitions/Pagination.ts
var import_zod22 = require("zod");
var Pagination = import_zod22.z.object({ first: import_zod22.z.string(), last: import_zod22.z.string(), next: import_zod22.z.string(), previous: import_zod22.z.string() });

// src/generated-definitions/ListMatchFunctionsResponse.ts
var ListMatchFunctionsResponse = import_zod23.z.object({
  configs: import_zod23.z.array(MatchFunctionConfig).nullish(),
  functions: import_zod23.z.array(import_zod23.z.string()),
  pagination: Pagination
});

// src/generated-definitions/ListMatchPoolsResponse.ts
var import_zod26 = require("zod");

// src/generated-definitions/MatchPool.ts
var import_zod25 = require("zod");

// src/generated-definitions/MatchFunctionOverride.ts
var import_zod24 = require("zod");
var MatchFunctionOverride = import_zod24.z.object({
  backfill_matches: import_zod24.z.string().nullish(),
  enrichment: import_zod24.z.array(import_zod24.z.string()).nullish(),
  make_matches: import_zod24.z.string().nullish(),
  stat_codes: import_zod24.z.array(import_zod24.z.string()).nullish(),
  validation: import_zod24.z.array(import_zod24.z.string()).nullish()
});

// src/generated-definitions/MatchPool.ts
var MatchPool = import_zod25.z.object({
  auto_accept_backfill_proposal: import_zod25.z.boolean(),
  backfill_proposal_expiration_seconds: import_zod25.z.number().int(),
  backfill_ticket_expiration_seconds: import_zod25.z.number().int(),
  best_latency_calculation_method: import_zod25.z.string().nullish(),
  crossplay_disabled: import_zod25.z.boolean().nullish(),
  match_function: import_zod25.z.string(),
  match_function_override: MatchFunctionOverride,
  name: import_zod25.z.string(),
  platform_group_enabled: import_zod25.z.boolean().nullish(),
  rule_set: import_zod25.z.string(),
  session_template: import_zod25.z.string(),
  ticket_expiration_seconds: import_zod25.z.number().int()
});

// src/generated-definitions/ListMatchPoolsResponse.ts
var ListMatchPoolsResponse = import_zod26.z.object({ data: import_zod26.z.array(MatchPool).nullish(), pagination: Pagination.nullish() });

// src/generated-definitions/ListMatchPoolTicketsResponse.ts
var import_zod28 = require("zod");

// src/generated-definitions/MatchTicketRecord.ts
var import_zod27 = require("zod");
var MatchTicketRecord = import_zod27.z.object({
  CreatedAt: import_zod27.z.string(),
  IsActive: import_zod27.z.boolean(),
  PartySessionID: import_zod27.z.string(),
  ProposedProposal,
  SessionID: import_zod27.z.string(),
  Ticket,
  TicketID: import_zod27.z.string(),
  UniqueTicketID: import_zod27.z.string()
});

// src/generated-definitions/ListMatchPoolTicketsResponse.ts
var ListMatchPoolTicketsResponse = import_zod28.z.object({
  data: import_zod28.z.array(MatchTicketRecord),
  pagination: Pagination.nullish(),
  totalData: import_zod28.z.number().int()
});

// src/generated-definitions/ListRuleSetsResponse.ts
var import_zod30 = require("zod");

// src/generated-definitions/MatchRuleSetNameData.ts
var import_zod29 = require("zod");
var MatchRuleSetNameData = import_zod29.z.object({ name: import_zod29.z.string() });

// src/generated-definitions/ListRuleSetsResponse.ts
var ListRuleSetsResponse = import_zod30.z.object({ data: import_zod30.z.array(MatchRuleSetNameData).nullish(), pagination: Pagination.nullish() });

// src/generated-definitions/MatchFunctionRequest.ts
var import_zod31 = require("zod");
var MatchFunctionRequest = import_zod31.z.object({ match_function: import_zod31.z.string(), serviceAppName: import_zod31.z.string().nullish(), url: import_zod31.z.string() });

// src/generated-definitions/MatchPoolConfig.ts
var import_zod32 = require("zod");
var MatchPoolConfig = import_zod32.z.object({
  auto_accept_backfill_proposal: import_zod32.z.boolean(),
  backfill_proposal_expiration_seconds: import_zod32.z.number().int(),
  backfill_ticket_expiration_seconds: import_zod32.z.number().int(),
  best_latency_calculation_method: import_zod32.z.string().nullish(),
  crossplay_disabled: import_zod32.z.boolean().nullish(),
  match_function: import_zod32.z.string(),
  match_function_override: MatchFunctionOverride,
  platform_group_enabled: import_zod32.z.boolean().nullish(),
  rule_set: import_zod32.z.string(),
  session_template: import_zod32.z.string(),
  ticket_expiration_seconds: import_zod32.z.number().int()
});

// src/generated-definitions/MatchTicketRequest.ts
var import_zod33 = require("zod");
var MatchTicketRequest = import_zod33.z.object({
  attributes: import_zod33.z.record(import_zod33.z.any()),
  excludedSessions: import_zod33.z.array(import_zod33.z.string()).nullish(),
  latencies: import_zod33.z.record(import_zod33.z.number().int()),
  matchPool: import_zod33.z.string(),
  sessionID: import_zod33.z.string().nullish(),
  storage: import_zod33.z.record(import_zod33.z.any()).nullish()
});

// src/generated-definitions/MatchTicketResponse.ts
var import_zod34 = require("zod");
var MatchTicketResponse = import_zod34.z.object({ matchTicketID: import_zod34.z.string(), queueTime: import_zod34.z.number().int() });

// src/generated-definitions/MatchTicketStatus.ts
var import_zod35 = require("zod");
var MatchTicketStatus = import_zod35.z.object({
  isActive: import_zod35.z.boolean().nullish(),
  matchFound: import_zod35.z.boolean(),
  matchPool: import_zod35.z.string().nullish(),
  matchTicketID: import_zod35.z.string().nullish(),
  proposedProposal: ProposedProposal.nullish(),
  sessionID: import_zod35.z.string()
});

// src/generated-definitions/MatchTicketStatuses.ts
var import_zod36 = require("zod");
var MatchTicketStatuses = import_zod36.z.object({ data: import_zod36.z.array(MatchTicketStatus), pagination: Pagination.nullish() });

// src/generated-definitions/NamespaceConfig.ts
var import_zod37 = require("zod");
var NamespaceConfig = import_zod37.z.object({
  crossPlatformNoCurrentPlatform: import_zod37.z.boolean().nullish(),
  extraPlatforms: import_zod37.z.array(import_zod37.z.string()).nullish(),
  matchAnyCommon: import_zod37.z.boolean().nullish(),
  namespace: import_zod37.z.string(),
  platformGroup: import_zod37.z.record(import_zod37.z.array(import_zod37.z.string())).nullish()
});

// src/generated-definitions/NamespaceConfigList.ts
var import_zod38 = require("zod");
var NamespaceConfigList = import_zod38.z.object({ configs: import_zod38.z.array(NamespaceConfig) });

// src/generated-definitions/PatchNamespaceConfigRequest.ts
var import_zod39 = require("zod");
var PatchNamespaceConfigRequest = import_zod39.z.object({
  crossPlatformNoCurrentPlatform: import_zod39.z.boolean().nullish(),
  extraPlatforms: import_zod39.z.array(import_zod39.z.string()).nullish(),
  matchAnyCommon: import_zod39.z.boolean().nullish(),
  platformGroup: import_zod39.z.record(import_zod39.z.array(import_zod39.z.string())).nullish()
});

// src/generated-definitions/PlayerMetricRecord.ts
var import_zod40 = require("zod");
var PlayerMetricRecord = import_zod40.z.object({ playerInQueue: import_zod40.z.number().int() });

// src/generated-definitions/RuleSetPayload.ts
var import_zod42 = require("zod");

// src/generated-definitions/RuleSetPayloadData.ts
var import_zod41 = require("zod");
var RuleSetPayloadData = import_zod41.z.any();

// src/generated-definitions/RuleSetPayload.ts
var RuleSetPayload = import_zod42.z.object({ data: RuleSetPayloadData, enable_custom_match_function: import_zod42.z.boolean(), name: import_zod42.z.string() });

// src/generated-definitions/TicketMetricResultRecord.ts
var import_zod43 = require("zod");
var TicketMetricResultRecord = import_zod43.z.object({ queueTime: import_zod43.z.number().int() });

// src/generated-public/BackfillApi.ts
var import_sdk4 = require("@accelbyte/sdk");

// src/generated-public/endpoints/Backfill$.ts
var import_sdk3 = require("@accelbyte/sdk");
var import_zod44 = require("zod");
var Backfill$ = class {
  // @ts-ignore
  // prettier-ignore
  constructor(axiosInstance, namespace, useSchemaValidation = true) {
    this.axiosInstance = axiosInstance;
    this.namespace = namespace;
    this.useSchemaValidation = useSchemaValidation;
  }
  /**
   * Create backfill ticket.
   */
  createBackfill(data) {
    const params = {};
    const url = "/match2/v1/namespaces/{namespace}/backfill".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.post(url, data, { params });
    return import_sdk3.Validate.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      BackfillCreateResponse,
      "BackfillCreateResponse"
    );
  }
  /**
   * Get backfill proposal
   */
  getBackfillProposal(queryParams) {
    const params = { ...queryParams };
    const url = "/match2/v1/namespaces/{namespace}/backfill/proposal".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.get(url, { params });
    return import_sdk3.Validate.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      BackfillProposalResponse,
      "BackfillProposalResponse"
    );
  }
  /**
   * Delete backfill ticket.
   */
  deleteBackfill_ByBackfillId(backfillID) {
    const params = {};
    const url = "/match2/v1/namespaces/{namespace}/backfill/{backfillID}".replace("{namespace}", this.namespace).replace("{backfillID}", backfillID);
    const resultPromise = this.axiosInstance.delete(url, { params });
    return import_sdk3.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, import_zod44.z.unknown(), "z.unknown()");
  }
  /**
   * Get backfill ticket by ID
   */
  getBackfill_ByBackfillId(backfillID) {
    const params = {};
    const url = "/match2/v1/namespaces/{namespace}/backfill/{backfillID}".replace("{namespace}", this.namespace).replace("{backfillID}", backfillID);
    const resultPromise = this.axiosInstance.get(url, { params });
    return import_sdk3.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, BackfillGetResponse, "BackfillGetResponse");
  }
  /**
   *  Accept backfill proposal. Field partialAcceptTicketIDs can be used to accept specific tickets within a backfill proposal. If the ticketIDs are not mentioned in this field, those tickets will be rejected and reactivated for future proposals.
   */
  updateProposalAccept_ByBackfillId(backfillID, data) {
    const params = {};
    const url = "/match2/v1/namespaces/{namespace}/backfill/{backfillID}/proposal/accept".replace("{namespace}", this.namespace).replace("{backfillID}", backfillID);
    const resultPromise = this.axiosInstance.put(url, data, { params });
    return import_sdk3.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, GameSession, "GameSession");
  }
  /**
   * Reject backfill proposal
   */
  updateProposalReject_ByBackfillId(backfillID, data) {
    const params = {};
    const url = "/match2/v1/namespaces/{namespace}/backfill/{backfillID}/proposal/reject".replace("{namespace}", this.namespace).replace("{backfillID}", backfillID);
    const resultPromise = this.axiosInstance.put(url, data, { params });
    return import_sdk3.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, import_zod44.z.unknown(), "z.unknown()");
  }
};

// src/generated-public/BackfillApi.ts
function BackfillApi(sdk, args) {
  const sdkAssembly = sdk.assembly();
  const namespace = args?.coreConfig?.namespace ?? sdkAssembly.coreConfig.namespace;
  const useSchemaValidation = args?.coreConfig?.useSchemaValidation ?? sdkAssembly.coreConfig.useSchemaValidation;
  let axiosInstance = sdkAssembly.axiosInstance;
  const requestConfigOverrides = args?.axiosConfig?.request;
  const baseURLOverride = args?.coreConfig?.baseURL;
  const interceptorsOverride = args?.axiosConfig?.interceptors ?? [];
  if (requestConfigOverrides || baseURLOverride || interceptorsOverride.length > 0) {
    const requestConfig = import_sdk4.ApiUtils.mergeAxiosConfigs(sdkAssembly.axiosInstance.defaults, {
      ...baseURLOverride ? { baseURL: baseURLOverride } : {},
      ...requestConfigOverrides
    });
    axiosInstance = import_sdk4.Network.create(requestConfig);
    for (const interceptor of interceptorsOverride) {
      if (interceptor.type === "request") {
        axiosInstance.interceptors.request.use(interceptor.onRequest, interceptor.onError);
      }
      if (interceptor.type === "response") {
        axiosInstance.interceptors.response.use(interceptor.onSuccess, interceptor.onError);
      }
    }
  }
  async function createBackfill(data) {
    const $ = new Backfill$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.createBackfill(data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getBackfillProposal(queryParams) {
    const $ = new Backfill$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getBackfillProposal(queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function deleteBackfill_ByBackfillId(backfillID) {
    const $ = new Backfill$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.deleteBackfill_ByBackfillId(backfillID);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getBackfill_ByBackfillId(backfillID) {
    const $ = new Backfill$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getBackfill_ByBackfillId(backfillID);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function updateProposalAccept_ByBackfillId(backfillID, data) {
    const $ = new Backfill$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.updateProposalAccept_ByBackfillId(backfillID, data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function updateProposalReject_ByBackfillId(backfillID, data) {
    const $ = new Backfill$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.updateProposalReject_ByBackfillId(backfillID, data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  return {
    /**
     * Create backfill ticket.
     */
    createBackfill,
    /**
     * Get backfill proposal
     */
    getBackfillProposal,
    /**
     * Delete backfill ticket.
     */
    deleteBackfill_ByBackfillId,
    /**
     * Get backfill ticket by ID
     */
    getBackfill_ByBackfillId,
    /**
     *  Accept backfill proposal. Field partialAcceptTicketIDs can be used to accept specific tickets within a backfill proposal. If the ticketIDs are not mentioned in this field, those tickets will be rejected and reactivated for future proposals.
     */
    updateProposalAccept_ByBackfillId,
    /**
     * Reject backfill proposal
     */
    updateProposalReject_ByBackfillId
  };
}

// src/generated-public/ConfigApi.ts
var import_sdk6 = require("@accelbyte/sdk");

// src/generated-public/endpoints/Config$.ts
var import_sdk5 = require("@accelbyte/sdk");
var Config$ = class {
  // @ts-ignore
  // prettier-ignore
  constructor(axiosInstance, namespace, useSchemaValidation = true) {
    this.axiosInstance = axiosInstance;
    this.namespace = namespace;
    this.useSchemaValidation = useSchemaValidation;
  }
  /**
   * Get matchmaking config of all namespaces. Will only return namespace configs than have been updated.
   */
  getConfig() {
    const params = {};
    const url = "/match2/v1/config";
    const resultPromise = this.axiosInstance.get(url, { params });
    return import_sdk5.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, NamespaceConfigList, "NamespaceConfigList");
  }
  /**
   * Get matchmaking config of a namespaces.
   */
  getConfig_ByNamespace() {
    const params = {};
    const url = "/match2/v1/config/namespaces/{namespace}".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.get(url, { params });
    return import_sdk5.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, NamespaceConfig, "NamespaceConfig");
  }
  /**
   * Patch update matchmaking config of a namespaces. Partially update matchmaking config, will only update value that defined on the request.
   */
  patchConfig_ByNamespace(data) {
    const params = {};
    const url = "/match2/v1/config/namespaces/{namespace}".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.patch(url, data, { params });
    return import_sdk5.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, NamespaceConfig, "NamespaceConfig");
  }
};

// src/generated-public/ConfigApi.ts
function ConfigApi(sdk, args) {
  const sdkAssembly = sdk.assembly();
  const namespace = args?.coreConfig?.namespace ?? sdkAssembly.coreConfig.namespace;
  const useSchemaValidation = args?.coreConfig?.useSchemaValidation ?? sdkAssembly.coreConfig.useSchemaValidation;
  let axiosInstance = sdkAssembly.axiosInstance;
  const requestConfigOverrides = args?.axiosConfig?.request;
  const baseURLOverride = args?.coreConfig?.baseURL;
  const interceptorsOverride = args?.axiosConfig?.interceptors ?? [];
  if (requestConfigOverrides || baseURLOverride || interceptorsOverride.length > 0) {
    const requestConfig = import_sdk6.ApiUtils.mergeAxiosConfigs(sdkAssembly.axiosInstance.defaults, {
      ...baseURLOverride ? { baseURL: baseURLOverride } : {},
      ...requestConfigOverrides
    });
    axiosInstance = import_sdk6.Network.create(requestConfig);
    for (const interceptor of interceptorsOverride) {
      if (interceptor.type === "request") {
        axiosInstance.interceptors.request.use(interceptor.onRequest, interceptor.onError);
      }
      if (interceptor.type === "response") {
        axiosInstance.interceptors.response.use(interceptor.onSuccess, interceptor.onError);
      }
    }
  }
  async function getConfig() {
    const $ = new Config$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getConfig();
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getConfig_ByNamespace() {
    const $ = new Config$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getConfig_ByNamespace();
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function patchConfig_ByNamespace(data) {
    const $ = new Config$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.patchConfig_ByNamespace(data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  return {
    /**
     * Get matchmaking config of all namespaces. Will only return namespace configs than have been updated.
     */
    getConfig,
    /**
     * Get matchmaking config of a namespaces.
     */
    getConfig_ByNamespace,
    /**
     * Patch update matchmaking config of a namespaces. Partially update matchmaking config, will only update value that defined on the request.
     */
    patchConfig_ByNamespace
  };
}

// src/generated-public/endpoints/EnvironmentVariables$.ts
var import_sdk7 = require("@accelbyte/sdk");
var EnvironmentVariables$ = class {
  // @ts-ignore
  // prettier-ignore
  constructor(axiosInstance, namespace, useSchemaValidation = true) {
    this.axiosInstance = axiosInstance;
    this.namespace = namespace;
    this.useSchemaValidation = useSchemaValidation;
  }
  /**
   * List environment variables.
   */
  getEnvironmentVariables() {
    const params = {};
    const url = "/match2/v1/environment-variables";
    const resultPromise = this.axiosInstance.get(url, { params });
    return import_sdk7.Validate.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      ListEnvironmentVariablesResponse,
      "ListEnvironmentVariablesResponse"
    );
  }
};

// src/generated-public/endpoints/MatchFunctions$.ts
var import_sdk8 = require("@accelbyte/sdk");
var import_zod45 = require("zod");
var MatchFunctions$ = class {
  // @ts-ignore
  // prettier-ignore
  constructor(axiosInstance, namespace, useSchemaValidation = true) {
    this.axiosInstance = axiosInstance;
    this.namespace = namespace;
    this.useSchemaValidation = useSchemaValidation;
  }
  /**
   * List existing match functions.
   */
  getMatchFunctions(queryParams) {
    const params = { limit: 20, ...queryParams };
    const url = "/match2/v1/namespaces/{namespace}/match-functions".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.get(url, { params });
    return import_sdk8.Validate.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      ListMatchFunctionsResponse,
      "ListMatchFunctionsResponse"
    );
  }
  /**
   * Creates a new matchmaking function.
   */
  createMatchFunction(data) {
    const params = {};
    const url = "/match2/v1/namespaces/{namespace}/match-functions".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.post(url, data, { params });
    return import_sdk8.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, import_zod45.z.unknown(), "z.unknown()");
  }
  /**
   * Deletes an existing match function.
   */
  deleteMatchFunction_ByName(name2) {
    const params = {};
    const url = "/match2/v1/namespaces/{namespace}/match-functions/{name}".replace("{namespace}", this.namespace).replace("{name}", name2);
    const resultPromise = this.axiosInstance.delete(url, { params });
    return import_sdk8.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, import_zod45.z.unknown(), "z.unknown()");
  }
  /**
   * Update existing matchmaking function.
   */
  updateMatchFunction_ByName(name2, data) {
    const params = {};
    const url = "/match2/v1/namespaces/{namespace}/match-functions/{name}".replace("{namespace}", this.namespace).replace("{name}", name2);
    const resultPromise = this.axiosInstance.put(url, data, { params });
    return import_sdk8.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, MatchFunctionConfig, "MatchFunctionConfig");
  }
};

// src/generated-public/endpoints/MatchPools$.ts
var import_sdk9 = require("@accelbyte/sdk");
var import_zod46 = require("zod");
var MatchPools$ = class {
  // @ts-ignore
  // prettier-ignore
  constructor(axiosInstance, namespace, useSchemaValidation = true) {
    this.axiosInstance = axiosInstance;
    this.namespace = namespace;
    this.useSchemaValidation = useSchemaValidation;
  }
  /**
   * List matchmaking pools.
   */
  getMatchPools(queryParams) {
    const params = { limit: 20, ...queryParams };
    const url = "/match2/v1/namespaces/{namespace}/match-pools".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.get(url, { params });
    return import_sdk9.Validate.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      ListMatchPoolsResponse,
      "ListMatchPoolsResponse"
    );
  }
  /**
   * Creates a new matchmaking pool. A pool is isolated from other pools (i.e. tickets may be matched with other tickets in the same pool, but not with tickets in other pools). Each pool has its own matchmaking rules and/or logic. ticket_expiration_seconds and backfill_ticket_expiration_seconds will be set to 300 seconds (5 minutes) by default if not filled. Match Function holds information about the name of the match logic server that matchmaking can refers to. By default we provide (&#34;default&#34; and &#34;basic&#34;). Match Function will be used as reference value for Match Function Overrides if not set. In case Customer would like to use matchmaking service default match logic, then specify it in &#34;match_function_overrides&#34;. This sample configuration will let matchmaking service will use &#34;default&#34; match logic for make matches, while validation will hit both &#34;default&#34; and &#34;custom&#34; match logics. e.g. { &#34;match_function&#34;: &#34;custom&#34;, &#34;match_function_overrides&#34;: { &#34;validation&#34;: []{&#34;default&#34;,&#34;custom&#34;}, &#34;make_matches&#34;: &#34;default&#34;, } }
   */
  createMatchPool(data) {
    const params = {};
    const url = "/match2/v1/namespaces/{namespace}/match-pools".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.post(url, data, { params });
    return import_sdk9.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, import_zod46.z.unknown(), "z.unknown()");
  }
  /**
   * Deletes an existing matchmaking pool.
   */
  deleteMatchPool_ByPool(pool) {
    const params = {};
    const url = "/match2/v1/namespaces/{namespace}/match-pools/{pool}".replace("{namespace}", this.namespace).replace("{pool}", pool);
    const resultPromise = this.axiosInstance.delete(url, { params });
    return import_sdk9.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, import_zod46.z.unknown(), "z.unknown()");
  }
  /**
   * Get details for a specific match pool
   */
  getMatchPool_ByPool(pool) {
    const params = {};
    const url = "/match2/v1/namespaces/{namespace}/match-pools/{pool}".replace("{namespace}", this.namespace).replace("{pool}", pool);
    const resultPromise = this.axiosInstance.get(url, { params });
    return import_sdk9.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, MatchPool, "MatchPool");
  }
  /**
   * Updates an existing matchmaking pool. ticket_expiration_seconds and backfill_ticket_expiration_seconds will be set to 300 seconds (5 minutes) by default if not filled. Match Function holds information about the name of the match logic server that matchmaking can refers to. By default we provide (&#34;default&#34; and &#34;basic&#34;). Match Function will be used as reference value for Match Function Overrides if not set. In case Customer would like to use matchmaking service default match logic, then specify it in &#34;match_function_overrides&#34;. This sample configuration will let matchmaking service will use &#34;default&#34; match logic for make matches, while validation will hit both &#34;default&#34; and &#34;custom&#34; match logics. e.g. { &#34;match_function&#34;: &#34;custom&#34;, &#34;match_function_overrides&#34;: { &#34;validation&#34;: []{&#34;default&#34;,&#34;custom&#34;}, &#34;make_matches&#34;: &#34;default&#34;, } }
   */
  updateMatchPool_ByPool(pool, data) {
    const params = {};
    const url = "/match2/v1/namespaces/{namespace}/match-pools/{pool}".replace("{namespace}", this.namespace).replace("{pool}", pool);
    const resultPromise = this.axiosInstance.put(url, data, { params });
    return import_sdk9.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, MatchPool, "MatchPool");
  }
  /**
   * Get metric for a specific match pool Result: queueTime in seconds
   */
  getMetrics_ByPool(pool) {
    const params = {};
    const url = "/match2/v1/namespaces/{namespace}/match-pools/{pool}/metrics".replace("{namespace}", this.namespace).replace("{pool}", pool);
    const resultPromise = this.axiosInstance.get(url, { params });
    return import_sdk9.Validate.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      TicketMetricResultRecord,
      "TicketMetricResultRecord"
    );
  }
  /**
   * Get tickets in queue for a specific match pool Result: number of tickets and list of ticket detail in a match pool.
   */
  getTickets_ByPool(pool, queryParams) {
    const params = { limit: 20, ...queryParams };
    const url = "/match2/v1/namespaces/{namespace}/match-pools/{pool}/tickets".replace("{namespace}", this.namespace).replace("{pool}", pool);
    const resultPromise = this.axiosInstance.get(url, { params });
    return import_sdk9.Validate.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      ListMatchPoolTicketsResponse,
      "ListMatchPoolTicketsResponse"
    );
  }
  /**
   * Get player metric for a specific match pool
   */
  getMetricsPlayer_ByPool(pool) {
    const params = {};
    const url = "/match2/v1/namespaces/{namespace}/match-pools/{pool}/metrics/player".replace("{namespace}", this.namespace).replace("{pool}", pool);
    const resultPromise = this.axiosInstance.get(url, { params });
    return import_sdk9.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, PlayerMetricRecord, "PlayerMetricRecord");
  }
  /**
   * Public get player metric for a specific match pool
   */
  getMetricsPlayer_ByPool_ByNS(pool) {
    const params = {};
    const url = "/match2/v1/public/namespaces/{namespace}/match-pools/{pool}/metrics/player".replace("{namespace}", this.namespace).replace("{pool}", pool);
    const resultPromise = this.axiosInstance.get(url, { params });
    return import_sdk9.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, PlayerMetricRecord, "PlayerMetricRecord");
  }
};

// src/generated-public/endpoints/MatchTickets$.ts
var import_sdk10 = require("@accelbyte/sdk");
var import_zod47 = require("zod");
var MatchTickets$ = class {
  // @ts-ignore
  // prettier-ignore
  constructor(axiosInstance, namespace, useSchemaValidation = true) {
    this.axiosInstance = axiosInstance;
    this.namespace = namespace;
    this.useSchemaValidation = useSchemaValidation;
  }
  /**
   * Creates a new request for matchmaking. Cross Platform: Allow player to play game with &#34;all&#34; registered platforms. 1. Cross Platform can be enabled through session service or create match ticket. a. via ticket: specify several cross_platform on create match ticket attributes. **[DEPRECATED]** client should not send from attribute &lt;code&gt;cross_platform&lt;/code&gt; will be populated from backend This value will override player attributes in session service. e.g. cross_platform:[xbox,psn,steam] b. via session service: set player/party cross_platform attributes. c. Enable match options ruleset with name cross_platform and type &#34;all&#34;. ``` { &#34;name&#34;: &#34;co-op&#34;, &#34;data&#34;: { &#34;alliance&#34;: { &#34;min_number&#34;: 1, &#34;max_number&#34;: 1, &#34;player_min_number&#34;: 1, &#34;player_max_number&#34;: 4 }, &#34;match_options&#34;: { &#34;options&#34;: [ {&#34;name&#34;: &#34;cross_platform&#34;, &#34;type&#34;: &#34;all&#34;} ] } } } ``` 2. Cross Platform can be disabled from the matchpool configuration &lt;code&gt;crossplay_disabled=true&lt;/code&gt; 3. When matchpool &lt;code&gt;crossplay_disabled=false&lt;/code&gt; * request attribute cross_platform is empty **[Recommended]**: * Matchmaking will consider Party leader &lt;code&gt;crossplayEnabled&lt;/code&gt; preference or Session attribute &lt;code&gt;crossplayEnabled&lt;/code&gt; preference. * When &lt;code&gt;crossplayEnabled=true&lt;/code&gt; &lt;code&gt;cross_platforms&lt;/code&gt; attributes will be populated from [active login methods](/iam/apidocs/#/Third%20Party%20Credential/RetrieveAllActiveThirdPartyLoginPlatformCredentialPublicV3) otherwise it will set to leader current platform * When &lt;code&gt;crossplayEnabled=false&lt;/code&gt; &lt;code&gt;cross_platforms&lt;/code&gt; attributes will be set to user&#39;s currentPlatform * request attribute cross_platform is not empty **[Not Recommended]**: * Cross Platform can be disabled with specify only ONE cross_platform. Current matchmaking use this behavior. e.g. cross_platform:[xbox] * Multiple cross_platform values is considered to be crossplay enabled 4. This behavior only works for Default Matchmaker. Custom matchmaker (custom gRPC matchmaker) need to consider this on its own implementation. ExcludedSessions: allow player to list out game sessions that they want to avoid matching, for example a match that they&#39;ve recently left or get kicked out from.
   */
  createMatchTicket(data) {
    const params = {};
    const url = "/match2/v1/namespaces/{namespace}/match-tickets".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.post(url, data, { params });
    return import_sdk10.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, MatchTicketResponse, "MatchTicketResponse");
  }
  /**
   * Get my match tickets.
   */
  getMatchTicketsMe(queryParams) {
    const params = { ...queryParams };
    const url = "/match2/v1/namespaces/{namespace}/match-tickets/me".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.get(url, { params });
    return import_sdk10.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, MatchTicketStatuses, "MatchTicketStatuses");
  }
  /**
   * Deletes an existing matchmaking ticket.
   */
  deleteMatchTicket_ByTicketid(ticketid) {
    const params = {};
    const url = "/match2/v1/namespaces/{namespace}/match-tickets/{ticketid}".replace("{namespace}", this.namespace).replace("{ticketid}", ticketid);
    const resultPromise = this.axiosInstance.delete(url, { params });
    return import_sdk10.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, import_zod47.z.unknown(), "z.unknown()");
  }
  /**
   * Get details for a specific match ticket
   */
  getMatchTicket_ByTicketid(ticketid) {
    const params = {};
    const url = "/match2/v1/namespaces/{namespace}/match-tickets/{ticketid}".replace("{namespace}", this.namespace).replace("{ticketid}", ticketid);
    const resultPromise = this.axiosInstance.get(url, { params });
    return import_sdk10.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, MatchTicketStatus, "MatchTicketStatus");
  }
};

// src/generated-public/endpoints/RuleSets$.ts
var import_sdk11 = require("@accelbyte/sdk");
var import_zod48 = require("zod");
var RuleSets$ = class {
  // @ts-ignore
  // prettier-ignore
  constructor(axiosInstance, namespace, useSchemaValidation = true) {
    this.axiosInstance = axiosInstance;
    this.namespace = namespace;
    this.useSchemaValidation = useSchemaValidation;
  }
  /**
   * List rule sets.
   */
  getRulesets(queryParams) {
    const params = { limit: 20, ...queryParams };
    const url = "/match2/v1/namespaces/{namespace}/rulesets".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.get(url, { params });
    return import_sdk11.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, ListRuleSetsResponse, "ListRuleSetsResponse");
  }
  /**
   * Creates a new rules set. A rule set has a name and contains arbitrary data which is meaningful to some particular match function(s) The name is used for a match pool to select the ruleset data that should be sent to the match function when matchmaking in that pool. To use custom rules set please set enable_custom_match_function=true. Default (false). When custom enable_custom_match_function=true, the ruleset will only validate if the rule is valid json.
   */
  createRuleset(data) {
    const params = {};
    const url = "/match2/v1/namespaces/{namespace}/rulesets".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.post(url, data, { params });
    return import_sdk11.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, import_zod48.z.unknown(), "z.unknown()");
  }
  /**
   * Deletes an existing rule set.
   */
  deleteRuleset_ByRuleset(ruleset) {
    const params = {};
    const url = "/match2/v1/namespaces/{namespace}/rulesets/{ruleset}".replace("{namespace}", this.namespace).replace("{ruleset}", ruleset);
    const resultPromise = this.axiosInstance.delete(url, { params });
    return import_sdk11.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, import_zod48.z.unknown(), "z.unknown()");
  }
  /**
   * Get details for a specific rule set
   */
  getRuleset_ByRuleset(ruleset) {
    const params = {};
    const url = "/match2/v1/namespaces/{namespace}/rulesets/{ruleset}".replace("{namespace}", this.namespace).replace("{ruleset}", ruleset);
    const resultPromise = this.axiosInstance.get(url, { params });
    return import_sdk11.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, RuleSetPayload, "RuleSetPayload");
  }
  /**
   * Updates an existing matchmaking rule set. To use custom rules set please set enable_custom_match_function=true. Default (false). When custom enable_custom_match_function=true, the ruleset will only validate if the rule is valid json.
   */
  updateRuleset_ByRuleset(ruleset, data) {
    const params = {};
    const url = "/match2/v1/namespaces/{namespace}/rulesets/{ruleset}".replace("{namespace}", this.namespace).replace("{ruleset}", ruleset);
    const resultPromise = this.axiosInstance.put(url, data, { params });
    return import_sdk11.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, RuleSetPayload, "RuleSetPayload");
  }
};

// src/generated-public/EnvironmentVariablesApi.ts
var import_sdk12 = require("@accelbyte/sdk");
function EnvironmentVariablesApi(sdk, args) {
  const sdkAssembly = sdk.assembly();
  const namespace = args?.coreConfig?.namespace ?? sdkAssembly.coreConfig.namespace;
  const useSchemaValidation = args?.coreConfig?.useSchemaValidation ?? sdkAssembly.coreConfig.useSchemaValidation;
  let axiosInstance = sdkAssembly.axiosInstance;
  const requestConfigOverrides = args?.axiosConfig?.request;
  const baseURLOverride = args?.coreConfig?.baseURL;
  const interceptorsOverride = args?.axiosConfig?.interceptors ?? [];
  if (requestConfigOverrides || baseURLOverride || interceptorsOverride.length > 0) {
    const requestConfig = import_sdk12.ApiUtils.mergeAxiosConfigs(sdkAssembly.axiosInstance.defaults, {
      ...baseURLOverride ? { baseURL: baseURLOverride } : {},
      ...requestConfigOverrides
    });
    axiosInstance = import_sdk12.Network.create(requestConfig);
    for (const interceptor of interceptorsOverride) {
      if (interceptor.type === "request") {
        axiosInstance.interceptors.request.use(interceptor.onRequest, interceptor.onError);
      }
      if (interceptor.type === "response") {
        axiosInstance.interceptors.response.use(interceptor.onSuccess, interceptor.onError);
      }
    }
  }
  async function getEnvironmentVariables() {
    const $ = new EnvironmentVariables$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getEnvironmentVariables();
    if (resp.error) throw resp.error;
    return resp.response;
  }
  return {
    /**
     * List environment variables.
     */
    getEnvironmentVariables
  };
}

// src/generated-public/MatchFunctionsApi.ts
var import_sdk13 = require("@accelbyte/sdk");
function MatchFunctionsApi(sdk, args) {
  const sdkAssembly = sdk.assembly();
  const namespace = args?.coreConfig?.namespace ?? sdkAssembly.coreConfig.namespace;
  const useSchemaValidation = args?.coreConfig?.useSchemaValidation ?? sdkAssembly.coreConfig.useSchemaValidation;
  let axiosInstance = sdkAssembly.axiosInstance;
  const requestConfigOverrides = args?.axiosConfig?.request;
  const baseURLOverride = args?.coreConfig?.baseURL;
  const interceptorsOverride = args?.axiosConfig?.interceptors ?? [];
  if (requestConfigOverrides || baseURLOverride || interceptorsOverride.length > 0) {
    const requestConfig = import_sdk13.ApiUtils.mergeAxiosConfigs(sdkAssembly.axiosInstance.defaults, {
      ...baseURLOverride ? { baseURL: baseURLOverride } : {},
      ...requestConfigOverrides
    });
    axiosInstance = import_sdk13.Network.create(requestConfig);
    for (const interceptor of interceptorsOverride) {
      if (interceptor.type === "request") {
        axiosInstance.interceptors.request.use(interceptor.onRequest, interceptor.onError);
      }
      if (interceptor.type === "response") {
        axiosInstance.interceptors.response.use(interceptor.onSuccess, interceptor.onError);
      }
    }
  }
  async function getMatchFunctions(queryParams) {
    const $ = new MatchFunctions$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getMatchFunctions(queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function createMatchFunction(data) {
    const $ = new MatchFunctions$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.createMatchFunction(data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function deleteMatchFunction_ByName(name2) {
    const $ = new MatchFunctions$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.deleteMatchFunction_ByName(name2);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function updateMatchFunction_ByName(name2, data) {
    const $ = new MatchFunctions$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.updateMatchFunction_ByName(name2, data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  return {
    /**
     * List existing match functions.
     */
    getMatchFunctions,
    /**
     * Creates a new matchmaking function.
     */
    createMatchFunction,
    /**
     * Deletes an existing match function.
     */
    deleteMatchFunction_ByName,
    /**
     * Update existing matchmaking function.
     */
    updateMatchFunction_ByName
  };
}

// src/generated-public/MatchPoolsApi.ts
var import_sdk14 = require("@accelbyte/sdk");
function MatchPoolsApi(sdk, args) {
  const sdkAssembly = sdk.assembly();
  const namespace = args?.coreConfig?.namespace ?? sdkAssembly.coreConfig.namespace;
  const useSchemaValidation = args?.coreConfig?.useSchemaValidation ?? sdkAssembly.coreConfig.useSchemaValidation;
  let axiosInstance = sdkAssembly.axiosInstance;
  const requestConfigOverrides = args?.axiosConfig?.request;
  const baseURLOverride = args?.coreConfig?.baseURL;
  const interceptorsOverride = args?.axiosConfig?.interceptors ?? [];
  if (requestConfigOverrides || baseURLOverride || interceptorsOverride.length > 0) {
    const requestConfig = import_sdk14.ApiUtils.mergeAxiosConfigs(sdkAssembly.axiosInstance.defaults, {
      ...baseURLOverride ? { baseURL: baseURLOverride } : {},
      ...requestConfigOverrides
    });
    axiosInstance = import_sdk14.Network.create(requestConfig);
    for (const interceptor of interceptorsOverride) {
      if (interceptor.type === "request") {
        axiosInstance.interceptors.request.use(interceptor.onRequest, interceptor.onError);
      }
      if (interceptor.type === "response") {
        axiosInstance.interceptors.response.use(interceptor.onSuccess, interceptor.onError);
      }
    }
  }
  async function getMatchPools(queryParams) {
    const $ = new MatchPools$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getMatchPools(queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function createMatchPool(data) {
    const $ = new MatchPools$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.createMatchPool(data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function deleteMatchPool_ByPool(pool) {
    const $ = new MatchPools$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.deleteMatchPool_ByPool(pool);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getMatchPool_ByPool(pool) {
    const $ = new MatchPools$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getMatchPool_ByPool(pool);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function updateMatchPool_ByPool(pool, data) {
    const $ = new MatchPools$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.updateMatchPool_ByPool(pool, data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getMetrics_ByPool(pool) {
    const $ = new MatchPools$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getMetrics_ByPool(pool);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getTickets_ByPool(pool, queryParams) {
    const $ = new MatchPools$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getTickets_ByPool(pool, queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getMetricsPlayer_ByPool(pool) {
    const $ = new MatchPools$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getMetricsPlayer_ByPool(pool);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getMetricsPlayer_ByPool_ByNS(pool) {
    const $ = new MatchPools$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getMetricsPlayer_ByPool_ByNS(pool);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  return {
    /**
     * List matchmaking pools.
     */
    getMatchPools,
    /**
     * Creates a new matchmaking pool. A pool is isolated from other pools (i.e. tickets may be matched with other tickets in the same pool, but not with tickets in other pools). Each pool has its own matchmaking rules and/or logic. ticket_expiration_seconds and backfill_ticket_expiration_seconds will be set to 300 seconds (5 minutes) by default if not filled. Match Function holds information about the name of the match logic server that matchmaking can refers to. By default we provide (&#34;default&#34; and &#34;basic&#34;). Match Function will be used as reference value for Match Function Overrides if not set. In case Customer would like to use matchmaking service default match logic, then specify it in &#34;match_function_overrides&#34;. This sample configuration will let matchmaking service will use &#34;default&#34; match logic for make matches, while validation will hit both &#34;default&#34; and &#34;custom&#34; match logics. e.g. { &#34;match_function&#34;: &#34;custom&#34;, &#34;match_function_overrides&#34;: { &#34;validation&#34;: []{&#34;default&#34;,&#34;custom&#34;}, &#34;make_matches&#34;: &#34;default&#34;, } }
     */
    createMatchPool,
    /**
     * Deletes an existing matchmaking pool.
     */
    deleteMatchPool_ByPool,
    /**
     * Get details for a specific match pool
     */
    getMatchPool_ByPool,
    /**
     * Updates an existing matchmaking pool. ticket_expiration_seconds and backfill_ticket_expiration_seconds will be set to 300 seconds (5 minutes) by default if not filled. Match Function holds information about the name of the match logic server that matchmaking can refers to. By default we provide (&#34;default&#34; and &#34;basic&#34;). Match Function will be used as reference value for Match Function Overrides if not set. In case Customer would like to use matchmaking service default match logic, then specify it in &#34;match_function_overrides&#34;. This sample configuration will let matchmaking service will use &#34;default&#34; match logic for make matches, while validation will hit both &#34;default&#34; and &#34;custom&#34; match logics. e.g. { &#34;match_function&#34;: &#34;custom&#34;, &#34;match_function_overrides&#34;: { &#34;validation&#34;: []{&#34;default&#34;,&#34;custom&#34;}, &#34;make_matches&#34;: &#34;default&#34;, } }
     */
    updateMatchPool_ByPool,
    /**
     * Get metric for a specific match pool Result: queueTime in seconds
     */
    getMetrics_ByPool,
    /**
     * Get tickets in queue for a specific match pool Result: number of tickets and list of ticket detail in a match pool.
     */
    getTickets_ByPool,
    /**
     * Get player metric for a specific match pool
     */
    getMetricsPlayer_ByPool,
    /**
     * Public get player metric for a specific match pool
     */
    getMetricsPlayer_ByPool_ByNS
  };
}

// src/generated-public/MatchTicketsApi.ts
var import_sdk15 = require("@accelbyte/sdk");
function MatchTicketsApi(sdk, args) {
  const sdkAssembly = sdk.assembly();
  const namespace = args?.coreConfig?.namespace ?? sdkAssembly.coreConfig.namespace;
  const useSchemaValidation = args?.coreConfig?.useSchemaValidation ?? sdkAssembly.coreConfig.useSchemaValidation;
  let axiosInstance = sdkAssembly.axiosInstance;
  const requestConfigOverrides = args?.axiosConfig?.request;
  const baseURLOverride = args?.coreConfig?.baseURL;
  const interceptorsOverride = args?.axiosConfig?.interceptors ?? [];
  if (requestConfigOverrides || baseURLOverride || interceptorsOverride.length > 0) {
    const requestConfig = import_sdk15.ApiUtils.mergeAxiosConfigs(sdkAssembly.axiosInstance.defaults, {
      ...baseURLOverride ? { baseURL: baseURLOverride } : {},
      ...requestConfigOverrides
    });
    axiosInstance = import_sdk15.Network.create(requestConfig);
    for (const interceptor of interceptorsOverride) {
      if (interceptor.type === "request") {
        axiosInstance.interceptors.request.use(interceptor.onRequest, interceptor.onError);
      }
      if (interceptor.type === "response") {
        axiosInstance.interceptors.response.use(interceptor.onSuccess, interceptor.onError);
      }
    }
  }
  async function createMatchTicket(data) {
    const $ = new MatchTickets$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.createMatchTicket(data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getMatchTicketsMe(queryParams) {
    const $ = new MatchTickets$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getMatchTicketsMe(queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function deleteMatchTicket_ByTicketid(ticketid) {
    const $ = new MatchTickets$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.deleteMatchTicket_ByTicketid(ticketid);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getMatchTicket_ByTicketid(ticketid) {
    const $ = new MatchTickets$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getMatchTicket_ByTicketid(ticketid);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  return {
    /**
     * Creates a new request for matchmaking. Cross Platform: Allow player to play game with &#34;all&#34; registered platforms. 1. Cross Platform can be enabled through session service or create match ticket. a. via ticket: specify several cross_platform on create match ticket attributes. **[DEPRECATED]** client should not send from attribute &lt;code&gt;cross_platform&lt;/code&gt; will be populated from backend This value will override player attributes in session service. e.g. cross_platform:[xbox,psn,steam] b. via session service: set player/party cross_platform attributes. c. Enable match options ruleset with name cross_platform and type &#34;all&#34;. ``` { &#34;name&#34;: &#34;co-op&#34;, &#34;data&#34;: { &#34;alliance&#34;: { &#34;min_number&#34;: 1, &#34;max_number&#34;: 1, &#34;player_min_number&#34;: 1, &#34;player_max_number&#34;: 4 }, &#34;match_options&#34;: { &#34;options&#34;: [ {&#34;name&#34;: &#34;cross_platform&#34;, &#34;type&#34;: &#34;all&#34;} ] } } } ``` 2. Cross Platform can be disabled from the matchpool configuration &lt;code&gt;crossplay_disabled=true&lt;/code&gt; 3. When matchpool &lt;code&gt;crossplay_disabled=false&lt;/code&gt; * request attribute cross_platform is empty **[Recommended]**: * Matchmaking will consider Party leader &lt;code&gt;crossplayEnabled&lt;/code&gt; preference or Session attribute &lt;code&gt;crossplayEnabled&lt;/code&gt; preference. * When &lt;code&gt;crossplayEnabled=true&lt;/code&gt; &lt;code&gt;cross_platforms&lt;/code&gt; attributes will be populated from [active login methods](/iam/apidocs/#/Third%20Party%20Credential/RetrieveAllActiveThirdPartyLoginPlatformCredentialPublicV3) otherwise it will set to leader current platform * When &lt;code&gt;crossplayEnabled=false&lt;/code&gt; &lt;code&gt;cross_platforms&lt;/code&gt; attributes will be set to user&#39;s currentPlatform * request attribute cross_platform is not empty **[Not Recommended]**: * Cross Platform can be disabled with specify only ONE cross_platform. Current matchmaking use this behavior. e.g. cross_platform:[xbox] * Multiple cross_platform values is considered to be crossplay enabled 4. This behavior only works for Default Matchmaker. Custom matchmaker (custom gRPC matchmaker) need to consider this on its own implementation. ExcludedSessions: allow player to list out game sessions that they want to avoid matching, for example a match that they&#39;ve recently left or get kicked out from.
     */
    createMatchTicket,
    /**
     * Get my match tickets.
     */
    getMatchTicketsMe,
    /**
     * Deletes an existing matchmaking ticket.
     */
    deleteMatchTicket_ByTicketid,
    /**
     * Get details for a specific match ticket
     */
    getMatchTicket_ByTicketid
  };
}

// src/generated-public/RuleSetsApi.ts
var import_sdk16 = require("@accelbyte/sdk");
function RuleSetsApi(sdk, args) {
  const sdkAssembly = sdk.assembly();
  const namespace = args?.coreConfig?.namespace ?? sdkAssembly.coreConfig.namespace;
  const useSchemaValidation = args?.coreConfig?.useSchemaValidation ?? sdkAssembly.coreConfig.useSchemaValidation;
  let axiosInstance = sdkAssembly.axiosInstance;
  const requestConfigOverrides = args?.axiosConfig?.request;
  const baseURLOverride = args?.coreConfig?.baseURL;
  const interceptorsOverride = args?.axiosConfig?.interceptors ?? [];
  if (requestConfigOverrides || baseURLOverride || interceptorsOverride.length > 0) {
    const requestConfig = import_sdk16.ApiUtils.mergeAxiosConfigs(sdkAssembly.axiosInstance.defaults, {
      ...baseURLOverride ? { baseURL: baseURLOverride } : {},
      ...requestConfigOverrides
    });
    axiosInstance = import_sdk16.Network.create(requestConfig);
    for (const interceptor of interceptorsOverride) {
      if (interceptor.type === "request") {
        axiosInstance.interceptors.request.use(interceptor.onRequest, interceptor.onError);
      }
      if (interceptor.type === "response") {
        axiosInstance.interceptors.response.use(interceptor.onSuccess, interceptor.onError);
      }
    }
  }
  async function getRulesets(queryParams) {
    const $ = new RuleSets$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getRulesets(queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function createRuleset(data) {
    const $ = new RuleSets$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.createRuleset(data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function deleteRuleset_ByRuleset(ruleset) {
    const $ = new RuleSets$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.deleteRuleset_ByRuleset(ruleset);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getRuleset_ByRuleset(ruleset) {
    const $ = new RuleSets$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getRuleset_ByRuleset(ruleset);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function updateRuleset_ByRuleset(ruleset, data) {
    const $ = new RuleSets$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.updateRuleset_ByRuleset(ruleset, data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  return {
    /**
     * List rule sets.
     */
    getRulesets,
    /**
     * Creates a new rules set. A rule set has a name and contains arbitrary data which is meaningful to some particular match function(s) The name is used for a match pool to select the ruleset data that should be sent to the match function when matchmaking in that pool. To use custom rules set please set enable_custom_match_function=true. Default (false). When custom enable_custom_match_function=true, the ruleset will only validate if the rule is valid json.
     */
    createRuleset,
    /**
     * Deletes an existing rule set.
     */
    deleteRuleset_ByRuleset,
    /**
     * Get details for a specific rule set
     */
    getRuleset_ByRuleset,
    /**
     * Updates an existing matchmaking rule set. To use custom rules set please set enable_custom_match_function=true. Default (false). When custom enable_custom_match_function=true, the ruleset will only validate if the rule is valid json.
     */
    updateRuleset_ByRuleset
  };
}

// package.json
var name = "@accelbyte/sdk-matchmaking";
var version = "5.0.4";
var author = "AccelByte Inc";

// src/Matchmaking.ts
console.log(`${name}@${version}`);
var apis = {
  ConfigAdminApi,
  ConfigApi,
  EnvironmentVariablesApi,
  BackfillApi,
  RuleSetsApi,
  MatchPoolsApi,
  MatchTicketsApi,
  MatchFunctionsApi,
  version: () => console.log({
    version,
    name,
    author
  })
};
var Matchmaking = apis;
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  BackFillAcceptRequest,
  BackFillCreateRequest,
  BackFillRejectRequest,
  Backfill$,
  BackfillApi,
  BackfillCreateResponse,
  BackfillGetResponse,
  BackfillProposalResponse,
  Config$,
  ConfigAdmin$,
  ConfigAdminApi,
  ConfigApi,
  Configuration,
  DsInformation,
  EnvironmentVariable,
  EnvironmentVariables$,
  EnvironmentVariablesApi,
  Error,
  GameSession,
  ListEnvironmentVariablesResponse,
  ListMatchFunctionsResponse,
  ListMatchPoolTicketsResponse,
  ListMatchPoolsResponse,
  ListRuleSetsResponse,
  Match,
  MatchFunctionConfig,
  MatchFunctionOverride,
  MatchFunctionRequest,
  MatchFunctions$,
  MatchFunctionsApi,
  MatchPool,
  MatchPoolConfig,
  MatchPools$,
  MatchPoolsApi,
  MatchRuleSetNameData,
  MatchTicketRecord,
  MatchTicketRequest,
  MatchTicketResponse,
  MatchTicketStatus,
  MatchTicketStatuses,
  MatchTickets$,
  MatchTicketsApi,
  Matchmaking,
  NamespaceConfig,
  NamespaceConfigList,
  Pagination,
  Party,
  PatchNamespaceConfigRequest,
  PlayerData,
  PlayerMetricRecord,
  ProposedProposal,
  RuleSetPayload,
  RuleSetPayloadData,
  RuleSets$,
  RuleSetsApi,
  Server,
  Team,
  Ticket,
  TicketMetricResultRecord,
  User
});

// src/generated-definitions/Configuration.ts
import { z } from "zod";
var Configuration = z.object({
  clientVersion: z.string(),
  deployment: z.string(),
  inactiveTimeout: z.number().int(),
  inviteTimeout: z.number().int(),
  joinability: z.string(),
  maxPlayers: z.number().int(),
  minPlayers: z.number().int(),
  name: z.string(),
  requestedRegions: z.array(z.string()),
  type: z.string()
});

// src/generated-admin/endpoints/ConfigAdmin$.ts
import { Validate } from "@accelbyte/sdk";
var ConfigAdmin$ = class {
  // @ts-ignore
  // prettier-ignore
  constructor(axiosInstance, namespace, useSchemaValidation = true) {
    this.axiosInstance = axiosInstance;
    this.namespace = namespace;
    this.useSchemaValidation = useSchemaValidation;
  }
  /**
   * Get Log Configuration.&lt;br&gt;
   */
  getConfigLog() {
    const params = {};
    const url = "/match2/v1/admin/config/log";
    const resultPromise = this.axiosInstance.get(url, { params });
    return Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, Configuration, "Configuration");
  }
  /**
   * Update Log Configuration.&lt;br&gt;
   */
  patchConfigLog(data) {
    const params = {};
    const url = "/match2/v1/admin/config/log";
    const resultPromise = this.axiosInstance.patch(url, data, { params });
    return Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, Configuration, "Configuration");
  }
};

// src/generated-admin/ConfigAdminApi.ts
import { ApiUtils, Network } from "@accelbyte/sdk";
function ConfigAdminApi(sdk, args) {
  const sdkAssembly = sdk.assembly();
  const namespace = args?.coreConfig?.namespace ?? sdkAssembly.coreConfig.namespace;
  const useSchemaValidation = args?.coreConfig?.useSchemaValidation ?? sdkAssembly.coreConfig.useSchemaValidation;
  let axiosInstance = sdkAssembly.axiosInstance;
  const requestConfigOverrides = args?.axiosConfig?.request;
  const baseURLOverride = args?.coreConfig?.baseURL;
  const interceptorsOverride = args?.axiosConfig?.interceptors ?? [];
  if (requestConfigOverrides || baseURLOverride || interceptorsOverride.length > 0) {
    const requestConfig = ApiUtils.mergeAxiosConfigs(sdkAssembly.axiosInstance.defaults, {
      ...baseURLOverride ? { baseURL: baseURLOverride } : {},
      ...requestConfigOverrides
    });
    axiosInstance = Network.create(requestConfig);
    for (const interceptor of interceptorsOverride) {
      if (interceptor.type === "request") {
        axiosInstance.interceptors.request.use(interceptor.onRequest, interceptor.onError);
      }
      if (interceptor.type === "response") {
        axiosInstance.interceptors.response.use(interceptor.onSuccess, interceptor.onError);
      }
    }
  }
  async function getConfigLog() {
    const $ = new ConfigAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getConfigLog();
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function patchConfigLog(data) {
    const $ = new ConfigAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.patchConfigLog(data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  return {
    /**
     * Get Log Configuration.&lt;br&gt;
     */
    getConfigLog,
    /**
     * Update Log Configuration.&lt;br&gt;
     */
    patchConfigLog
  };
}

// src/generated-definitions/BackfillCreateResponse.ts
import { z as z2 } from "zod";
var BackfillCreateResponse = z2.object({ id: z2.string() });

// src/generated-definitions/Party.ts
import { z as z3 } from "zod";
var Party = z3.object({ partyID: z3.string().nullish(), userIDs: z3.array(z3.string()).nullish() });

// src/generated-definitions/Team.ts
import { z as z4 } from "zod";
var Team = z4.object({ Parties: z4.array(Party).nullish(), UserIDs: z4.array(z4.string()).nullish() });

// src/generated-definitions/PlayerData.ts
import { z as z5 } from "zod";
var PlayerData = z5.object({ Attributes: z5.record(z5.any()), PartyID: z5.string(), PlatformID: z5.string(), PlayerID: z5.string() });

// src/generated-definitions/ProposedProposal.ts
import { z as z6 } from "zod";
var ProposedProposal = z6.object({ BackfillID: z6.string(), ProposalID: z6.string(), Status: z6.string() });

// src/generated-definitions/Ticket.ts
import { z as z7 } from "zod";
var Ticket = z7.object({
  CreatedAt: z7.string(),
  ExcludedSessions: z7.array(z7.string()),
  IsActive: z7.boolean(),
  IsPivot: z7.boolean(),
  IsSinglePlay: z7.boolean(),
  Latencies: z7.record(z7.number().int()),
  MatchPool: z7.string(),
  MatchedAt: z7.string(),
  Namespace: z7.string(),
  PartySessionID: z7.string(),
  Players: z7.array(PlayerData),
  ProposedProposal,
  TicketAttributes: z7.record(z7.any()),
  TicketID: z7.string(),
  TicketInformation: z7.record(z7.any())
});

// src/generated-definitions/Match.ts
import { z as z8 } from "zod";
var Match = z8.object({
  backfill: z8.boolean().nullish(),
  clientVersion: z8.string().nullish(),
  matchAttributes: z8.record(z8.any()).nullish(),
  regionPreference: z8.array(z8.string()).nullish(),
  serverName: z8.string().nullish(),
  teams: z8.array(Team).nullish(),
  tickets: z8.array(Ticket).nullish()
});

// src/generated-definitions/BackfillGetResponse.ts
import { z as z9 } from "zod";
var BackfillGetResponse = z9.object({
  createdAt: z9.string().nullish(),
  matchPool: z9.string().nullish(),
  matchSessionID: z9.string().nullish(),
  partialMatch: Match.nullish(),
  ticketID: z9.string().nullish()
});

// src/generated-definitions/BackfillProposalResponse.ts
import { z as z10 } from "zod";
var BackfillProposalResponse = z10.object({
  backfillTicketID: z10.string().nullish(),
  createdAt: z10.string().nullish(),
  matchPool: z10.string().nullish(),
  matchSessionID: z10.string().nullish(),
  proposalID: z10.string().nullish(),
  proposedTeams: z10.array(Team).nullish(),
  tickets: z10.array(Ticket).nullish()
});

// src/generated-definitions/Server.ts
import { z as z11 } from "zod";
var Server = z11.object({
  alternate_ips: z11.array(z11.string()),
  custom_attribute: z11.string(),
  deployment: z11.string(),
  game_version: z11.string(),
  image_version: z11.string(),
  ip: z11.string(),
  is_override_game_version: z11.boolean(),
  last_update: z11.string(),
  namespace: z11.string(),
  pod_name: z11.string(),
  port: z11.number().int(),
  ports: z11.record(z11.number().int()),
  protocol: z11.string(),
  provider: z11.string(),
  region: z11.string(),
  session_id: z11.string(),
  status: z11.string()
});

// src/generated-definitions/DsInformation.ts
import { z as z12 } from "zod";
var DsInformation = z12.object({
  MinPlayers: z12.number().int(),
  RequestedAt: z12.string(),
  RequestedRegions: z12.array(z12.string()),
  Server,
  Status: z12.string()
});

// src/generated-definitions/EnvironmentVariable.ts
import { z as z13 } from "zod";
var EnvironmentVariable = z13.object({
  actualValue: z13.string().nullish(),
  defaultValue: z13.string().nullish(),
  description: z13.string().nullish(),
  name: z13.string()
});

// src/generated-definitions/User.ts
import { z as z14 } from "zod";
var User = z14.object({
  ID: z14.string(),
  PlatformID: z14.string(),
  PlatformUserID: z14.string(),
  PreviousStatus: z14.string().nullish(),
  Status: z14.string(),
  StatusV2: z14.string(),
  UpdatedAt: z14.string()
});

// src/generated-definitions/GameSession.ts
import { z as z15 } from "zod";
var GameSession = z15.object({
  DSInformation: DsInformation,
  GameMode: z15.string(),
  IsFull: z15.boolean(),
  JoinType: z15.string(),
  Members: z15.array(User),
  attributes: z15.record(z15.any()),
  backfillTicketID: z15.string(),
  configuration: Configuration,
  createdAt: z15.string(),
  id: z15.string(),
  leaderID: z15.string(),
  matchPool: z15.string(),
  namespace: z15.string(),
  teams: z15.array(Team),
  updatedAt: z15.string(),
  version: z15.number().int()
});

// src/generated-definitions/ListEnvironmentVariablesResponse.ts
import { z as z16 } from "zod";
var ListEnvironmentVariablesResponse = z16.object({ data: z16.array(EnvironmentVariable) });

// src/generated-definitions/MatchFunctionConfig.ts
import { z as z17 } from "zod";
var MatchFunctionConfig = z17.object({ match_function: z17.string(), serviceAppName: z17.string().nullish(), url: z17.string() });

// src/generated-definitions/Pagination.ts
import { z as z18 } from "zod";
var Pagination = z18.object({ first: z18.string(), last: z18.string(), next: z18.string(), previous: z18.string() });

// src/generated-definitions/ListMatchFunctionsResponse.ts
import { z as z19 } from "zod";
var ListMatchFunctionsResponse = z19.object({
  configs: z19.array(MatchFunctionConfig).nullish(),
  functions: z19.array(z19.string()),
  pagination: Pagination
});

// src/generated-definitions/MatchFunctionOverride.ts
import { z as z20 } from "zod";
var MatchFunctionOverride = z20.object({
  backfill_matches: z20.string().nullish(),
  enrichment: z20.array(z20.string()).nullish(),
  make_matches: z20.string().nullish(),
  stat_codes: z20.array(z20.string()).nullish(),
  validation: z20.array(z20.string()).nullish()
});

// src/generated-definitions/MatchPool.ts
import { z as z21 } from "zod";
var MatchPool = z21.object({
  auto_accept_backfill_proposal: z21.boolean(),
  backfill_proposal_expiration_seconds: z21.number().int(),
  backfill_ticket_expiration_seconds: z21.number().int(),
  best_latency_calculation_method: z21.string().nullish(),
  crossplay_disabled: z21.boolean().nullish(),
  match_function: z21.string(),
  match_function_override: MatchFunctionOverride,
  name: z21.string(),
  platform_group_enabled: z21.boolean().nullish(),
  rule_set: z21.string(),
  session_template: z21.string(),
  ticket_expiration_seconds: z21.number().int()
});

// src/generated-definitions/ListMatchPoolsResponse.ts
import { z as z22 } from "zod";
var ListMatchPoolsResponse = z22.object({ data: z22.array(MatchPool).nullish(), pagination: Pagination.nullish() });

// src/generated-definitions/MatchTicketRecord.ts
import { z as z23 } from "zod";
var MatchTicketRecord = z23.object({
  CreatedAt: z23.string(),
  IsActive: z23.boolean(),
  PartySessionID: z23.string(),
  ProposedProposal,
  SessionID: z23.string(),
  Ticket,
  TicketID: z23.string(),
  UniqueTicketID: z23.string()
});

// src/generated-definitions/ListMatchPoolTicketsResponse.ts
import { z as z24 } from "zod";
var ListMatchPoolTicketsResponse = z24.object({
  data: z24.array(MatchTicketRecord),
  pagination: Pagination.nullish(),
  totalData: z24.number().int()
});

// src/generated-definitions/MatchRuleSetNameData.ts
import { z as z25 } from "zod";
var MatchRuleSetNameData = z25.object({ name: z25.string() });

// src/generated-definitions/ListRuleSetsResponse.ts
import { z as z26 } from "zod";
var ListRuleSetsResponse = z26.object({ data: z26.array(MatchRuleSetNameData).nullish(), pagination: Pagination.nullish() });

// src/generated-definitions/MatchTicketResponse.ts
import { z as z27 } from "zod";
var MatchTicketResponse = z27.object({ matchTicketID: z27.string(), queueTime: z27.number().int() });

// src/generated-definitions/MatchTicketStatus.ts
import { z as z28 } from "zod";
var MatchTicketStatus = z28.object({
  isActive: z28.boolean().nullish(),
  matchFound: z28.boolean(),
  matchPool: z28.string().nullish(),
  matchTicketID: z28.string().nullish(),
  proposedProposal: ProposedProposal.nullish(),
  sessionID: z28.string()
});

// src/generated-definitions/MatchTicketStatuses.ts
import { z as z29 } from "zod";
var MatchTicketStatuses = z29.object({ data: z29.array(MatchTicketStatus), pagination: Pagination.nullish() });

// src/generated-definitions/NamespaceConfig.ts
import { z as z30 } from "zod";
var NamespaceConfig = z30.object({
  crossPlatformNoCurrentPlatform: z30.boolean().nullish(),
  extraPlatforms: z30.array(z30.string()).nullish(),
  matchAnyCommon: z30.boolean().nullish(),
  namespace: z30.string(),
  platformGroup: z30.record(z30.array(z30.string())).nullish()
});

// src/generated-definitions/NamespaceConfigList.ts
import { z as z31 } from "zod";
var NamespaceConfigList = z31.object({ configs: z31.array(NamespaceConfig) });

// src/generated-definitions/PlayerMetricRecord.ts
import { z as z32 } from "zod";
var PlayerMetricRecord = z32.object({ playerInQueue: z32.number().int() });

// src/generated-definitions/RuleSetPayloadData.ts
import { z as z33 } from "zod";
var RuleSetPayloadData = z33.any();

// src/generated-definitions/RuleSetPayload.ts
import { z as z34 } from "zod";
var RuleSetPayload = z34.object({ data: RuleSetPayloadData, enable_custom_match_function: z34.boolean(), name: z34.string() });

// src/generated-definitions/TicketMetricResultRecord.ts
import { z as z35 } from "zod";
var TicketMetricResultRecord = z35.object({ queueTime: z35.number().int() });

// src/generated-public/endpoints/Backfill$.ts
import { Validate as Validate2 } from "@accelbyte/sdk";
import { z as z36 } from "zod";
var Backfill$ = class {
  // @ts-ignore
  // prettier-ignore
  constructor(axiosInstance, namespace, useSchemaValidation = true) {
    this.axiosInstance = axiosInstance;
    this.namespace = namespace;
    this.useSchemaValidation = useSchemaValidation;
  }
  /**
   * Create backfill ticket.
   */
  createBackfill(data) {
    const params = {};
    const url = "/match2/v1/namespaces/{namespace}/backfill".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.post(url, data, { params });
    return Validate2.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      BackfillCreateResponse,
      "BackfillCreateResponse"
    );
  }
  /**
   * Get backfill proposal
   */
  getBackfillProposal(queryParams) {
    const params = { ...queryParams };
    const url = "/match2/v1/namespaces/{namespace}/backfill/proposal".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.get(url, { params });
    return Validate2.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      BackfillProposalResponse,
      "BackfillProposalResponse"
    );
  }
  /**
   * Delete backfill ticket.
   */
  deleteBackfill_ByBackfillId(backfillID) {
    const params = {};
    const url = "/match2/v1/namespaces/{namespace}/backfill/{backfillID}".replace("{namespace}", this.namespace).replace("{backfillID}", backfillID);
    const resultPromise = this.axiosInstance.delete(url, { params });
    return Validate2.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, z36.unknown(), "z.unknown()");
  }
  /**
   * Get backfill ticket by ID
   */
  getBackfill_ByBackfillId(backfillID) {
    const params = {};
    const url = "/match2/v1/namespaces/{namespace}/backfill/{backfillID}".replace("{namespace}", this.namespace).replace("{backfillID}", backfillID);
    const resultPromise = this.axiosInstance.get(url, { params });
    return Validate2.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, BackfillGetResponse, "BackfillGetResponse");
  }
  /**
   *  Accept backfill proposal. Field partialAcceptTicketIDs can be used to accept specific tickets within a backfill proposal. If the ticketIDs are not mentioned in this field, those tickets will be rejected and reactivated for future proposals.
   */
  updateProposalAccept_ByBackfillId(backfillID, data) {
    const params = {};
    const url = "/match2/v1/namespaces/{namespace}/backfill/{backfillID}/proposal/accept".replace("{namespace}", this.namespace).replace("{backfillID}", backfillID);
    const resultPromise = this.axiosInstance.put(url, data, { params });
    return Validate2.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, GameSession, "GameSession");
  }
  /**
   * Reject backfill proposal
   */
  updateProposalReject_ByBackfillId(backfillID, data) {
    const params = {};
    const url = "/match2/v1/namespaces/{namespace}/backfill/{backfillID}/proposal/reject".replace("{namespace}", this.namespace).replace("{backfillID}", backfillID);
    const resultPromise = this.axiosInstance.put(url, data, { params });
    return Validate2.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, z36.unknown(), "z.unknown()");
  }
};

// src/generated-public/BackfillApi.ts
import { ApiUtils as ApiUtils2, Network as Network2 } from "@accelbyte/sdk";
function BackfillApi(sdk, args) {
  const sdkAssembly = sdk.assembly();
  const namespace = args?.coreConfig?.namespace ?? sdkAssembly.coreConfig.namespace;
  const useSchemaValidation = args?.coreConfig?.useSchemaValidation ?? sdkAssembly.coreConfig.useSchemaValidation;
  let axiosInstance = sdkAssembly.axiosInstance;
  const requestConfigOverrides = args?.axiosConfig?.request;
  const baseURLOverride = args?.coreConfig?.baseURL;
  const interceptorsOverride = args?.axiosConfig?.interceptors ?? [];
  if (requestConfigOverrides || baseURLOverride || interceptorsOverride.length > 0) {
    const requestConfig = ApiUtils2.mergeAxiosConfigs(sdkAssembly.axiosInstance.defaults, {
      ...baseURLOverride ? { baseURL: baseURLOverride } : {},
      ...requestConfigOverrides
    });
    axiosInstance = Network2.create(requestConfig);
    for (const interceptor of interceptorsOverride) {
      if (interceptor.type === "request") {
        axiosInstance.interceptors.request.use(interceptor.onRequest, interceptor.onError);
      }
      if (interceptor.type === "response") {
        axiosInstance.interceptors.response.use(interceptor.onSuccess, interceptor.onError);
      }
    }
  }
  async function createBackfill(data) {
    const $ = new Backfill$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.createBackfill(data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getBackfillProposal(queryParams) {
    const $ = new Backfill$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getBackfillProposal(queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function deleteBackfill_ByBackfillId(backfillID) {
    const $ = new Backfill$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.deleteBackfill_ByBackfillId(backfillID);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getBackfill_ByBackfillId(backfillID) {
    const $ = new Backfill$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getBackfill_ByBackfillId(backfillID);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function updateProposalAccept_ByBackfillId(backfillID, data) {
    const $ = new Backfill$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.updateProposalAccept_ByBackfillId(backfillID, data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function updateProposalReject_ByBackfillId(backfillID, data) {
    const $ = new Backfill$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.updateProposalReject_ByBackfillId(backfillID, data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  return {
    /**
     * Create backfill ticket.
     */
    createBackfill,
    /**
     * Get backfill proposal
     */
    getBackfillProposal,
    /**
     * Delete backfill ticket.
     */
    deleteBackfill_ByBackfillId,
    /**
     * Get backfill ticket by ID
     */
    getBackfill_ByBackfillId,
    /**
     *  Accept backfill proposal. Field partialAcceptTicketIDs can be used to accept specific tickets within a backfill proposal. If the ticketIDs are not mentioned in this field, those tickets will be rejected and reactivated for future proposals.
     */
    updateProposalAccept_ByBackfillId,
    /**
     * Reject backfill proposal
     */
    updateProposalReject_ByBackfillId
  };
}

// src/generated-public/endpoints/Config$.ts
import { Validate as Validate3 } from "@accelbyte/sdk";
var Config$ = class {
  // @ts-ignore
  // prettier-ignore
  constructor(axiosInstance, namespace, useSchemaValidation = true) {
    this.axiosInstance = axiosInstance;
    this.namespace = namespace;
    this.useSchemaValidation = useSchemaValidation;
  }
  /**
   * Get matchmaking config of all namespaces. Will only return namespace configs than have been updated.
   */
  getConfig() {
    const params = {};
    const url = "/match2/v1/config";
    const resultPromise = this.axiosInstance.get(url, { params });
    return Validate3.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, NamespaceConfigList, "NamespaceConfigList");
  }
  /**
   * Get matchmaking config of a namespaces.
   */
  getConfig_ByNamespace() {
    const params = {};
    const url = "/match2/v1/config/namespaces/{namespace}".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.get(url, { params });
    return Validate3.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, NamespaceConfig, "NamespaceConfig");
  }
  /**
   * Patch update matchmaking config of a namespaces. Partially update matchmaking config, will only update value that defined on the request.
   */
  patchConfig_ByNamespace(data) {
    const params = {};
    const url = "/match2/v1/config/namespaces/{namespace}".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.patch(url, data, { params });
    return Validate3.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, NamespaceConfig, "NamespaceConfig");
  }
};

// src/generated-public/ConfigApi.ts
import { ApiUtils as ApiUtils3, Network as Network3 } from "@accelbyte/sdk";
function ConfigApi(sdk, args) {
  const sdkAssembly = sdk.assembly();
  const namespace = args?.coreConfig?.namespace ?? sdkAssembly.coreConfig.namespace;
  const useSchemaValidation = args?.coreConfig?.useSchemaValidation ?? sdkAssembly.coreConfig.useSchemaValidation;
  let axiosInstance = sdkAssembly.axiosInstance;
  const requestConfigOverrides = args?.axiosConfig?.request;
  const baseURLOverride = args?.coreConfig?.baseURL;
  const interceptorsOverride = args?.axiosConfig?.interceptors ?? [];
  if (requestConfigOverrides || baseURLOverride || interceptorsOverride.length > 0) {
    const requestConfig = ApiUtils3.mergeAxiosConfigs(sdkAssembly.axiosInstance.defaults, {
      ...baseURLOverride ? { baseURL: baseURLOverride } : {},
      ...requestConfigOverrides
    });
    axiosInstance = Network3.create(requestConfig);
    for (const interceptor of interceptorsOverride) {
      if (interceptor.type === "request") {
        axiosInstance.interceptors.request.use(interceptor.onRequest, interceptor.onError);
      }
      if (interceptor.type === "response") {
        axiosInstance.interceptors.response.use(interceptor.onSuccess, interceptor.onError);
      }
    }
  }
  async function getConfig() {
    const $ = new Config$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getConfig();
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getConfig_ByNamespace() {
    const $ = new Config$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getConfig_ByNamespace();
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function patchConfig_ByNamespace(data) {
    const $ = new Config$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.patchConfig_ByNamespace(data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  return {
    /**
     * Get matchmaking config of all namespaces. Will only return namespace configs than have been updated.
     */
    getConfig,
    /**
     * Get matchmaking config of a namespaces.
     */
    getConfig_ByNamespace,
    /**
     * Patch update matchmaking config of a namespaces. Partially update matchmaking config, will only update value that defined on the request.
     */
    patchConfig_ByNamespace
  };
}

// src/generated-public/endpoints/EnvironmentVariables$.ts
import { Validate as Validate4 } from "@accelbyte/sdk";
var EnvironmentVariables$ = class {
  // @ts-ignore
  // prettier-ignore
  constructor(axiosInstance, namespace, useSchemaValidation = true) {
    this.axiosInstance = axiosInstance;
    this.namespace = namespace;
    this.useSchemaValidation = useSchemaValidation;
  }
  /**
   * List environment variables.
   */
  getEnvironmentVariables() {
    const params = {};
    const url = "/match2/v1/environment-variables";
    const resultPromise = this.axiosInstance.get(url, { params });
    return Validate4.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      ListEnvironmentVariablesResponse,
      "ListEnvironmentVariablesResponse"
    );
  }
};

// src/generated-public/endpoints/MatchFunctions$.ts
import { Validate as Validate5 } from "@accelbyte/sdk";
import { z as z37 } from "zod";
var MatchFunctions$ = class {
  // @ts-ignore
  // prettier-ignore
  constructor(axiosInstance, namespace, useSchemaValidation = true) {
    this.axiosInstance = axiosInstance;
    this.namespace = namespace;
    this.useSchemaValidation = useSchemaValidation;
  }
  /**
   * List existing match functions.
   */
  getMatchFunctions(queryParams) {
    const params = { limit: 20, ...queryParams };
    const url = "/match2/v1/namespaces/{namespace}/match-functions".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.get(url, { params });
    return Validate5.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      ListMatchFunctionsResponse,
      "ListMatchFunctionsResponse"
    );
  }
  /**
   * Creates a new matchmaking function.
   */
  createMatchFunction(data) {
    const params = {};
    const url = "/match2/v1/namespaces/{namespace}/match-functions".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.post(url, data, { params });
    return Validate5.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, z37.unknown(), "z.unknown()");
  }
  /**
   * Deletes an existing match function.
   */
  deleteMatchFunction_ByName(name) {
    const params = {};
    const url = "/match2/v1/namespaces/{namespace}/match-functions/{name}".replace("{namespace}", this.namespace).replace("{name}", name);
    const resultPromise = this.axiosInstance.delete(url, { params });
    return Validate5.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, z37.unknown(), "z.unknown()");
  }
  /**
   * Update existing matchmaking function.
   */
  updateMatchFunction_ByName(name, data) {
    const params = {};
    const url = "/match2/v1/namespaces/{namespace}/match-functions/{name}".replace("{namespace}", this.namespace).replace("{name}", name);
    const resultPromise = this.axiosInstance.put(url, data, { params });
    return Validate5.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, MatchFunctionConfig, "MatchFunctionConfig");
  }
};

// src/generated-public/endpoints/MatchPools$.ts
import { Validate as Validate6 } from "@accelbyte/sdk";
import { z as z38 } from "zod";
var MatchPools$ = class {
  // @ts-ignore
  // prettier-ignore
  constructor(axiosInstance, namespace, useSchemaValidation = true) {
    this.axiosInstance = axiosInstance;
    this.namespace = namespace;
    this.useSchemaValidation = useSchemaValidation;
  }
  /**
   * List matchmaking pools.
   */
  getMatchPools(queryParams) {
    const params = { limit: 20, ...queryParams };
    const url = "/match2/v1/namespaces/{namespace}/match-pools".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.get(url, { params });
    return Validate6.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      ListMatchPoolsResponse,
      "ListMatchPoolsResponse"
    );
  }
  /**
   * Creates a new matchmaking pool. A pool is isolated from other pools (i.e. tickets may be matched with other tickets in the same pool, but not with tickets in other pools). Each pool has its own matchmaking rules and/or logic. ticket_expiration_seconds and backfill_ticket_expiration_seconds will be set to 300 seconds (5 minutes) by default if not filled. Match Function holds information about the name of the match logic server that matchmaking can refers to. By default we provide (&#34;default&#34; and &#34;basic&#34;). Match Function will be used as reference value for Match Function Overrides if not set. In case Customer would like to use matchmaking service default match logic, then specify it in &#34;match_function_overrides&#34;. This sample configuration will let matchmaking service will use &#34;default&#34; match logic for make matches, while validation will hit both &#34;default&#34; and &#34;custom&#34; match logics. e.g. { &#34;match_function&#34;: &#34;custom&#34;, &#34;match_function_overrides&#34;: { &#34;validation&#34;: []{&#34;default&#34;,&#34;custom&#34;}, &#34;make_matches&#34;: &#34;default&#34;, } }
   */
  createMatchPool(data) {
    const params = {};
    const url = "/match2/v1/namespaces/{namespace}/match-pools".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.post(url, data, { params });
    return Validate6.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, z38.unknown(), "z.unknown()");
  }
  /**
   * Deletes an existing matchmaking pool.
   */
  deleteMatchPool_ByPool(pool) {
    const params = {};
    const url = "/match2/v1/namespaces/{namespace}/match-pools/{pool}".replace("{namespace}", this.namespace).replace("{pool}", pool);
    const resultPromise = this.axiosInstance.delete(url, { params });
    return Validate6.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, z38.unknown(), "z.unknown()");
  }
  /**
   * Get details for a specific match pool
   */
  getMatchPool_ByPool(pool) {
    const params = {};
    const url = "/match2/v1/namespaces/{namespace}/match-pools/{pool}".replace("{namespace}", this.namespace).replace("{pool}", pool);
    const resultPromise = this.axiosInstance.get(url, { params });
    return Validate6.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, MatchPool, "MatchPool");
  }
  /**
   * Updates an existing matchmaking pool. ticket_expiration_seconds and backfill_ticket_expiration_seconds will be set to 300 seconds (5 minutes) by default if not filled. Match Function holds information about the name of the match logic server that matchmaking can refers to. By default we provide (&#34;default&#34; and &#34;basic&#34;). Match Function will be used as reference value for Match Function Overrides if not set. In case Customer would like to use matchmaking service default match logic, then specify it in &#34;match_function_overrides&#34;. This sample configuration will let matchmaking service will use &#34;default&#34; match logic for make matches, while validation will hit both &#34;default&#34; and &#34;custom&#34; match logics. e.g. { &#34;match_function&#34;: &#34;custom&#34;, &#34;match_function_overrides&#34;: { &#34;validation&#34;: []{&#34;default&#34;,&#34;custom&#34;}, &#34;make_matches&#34;: &#34;default&#34;, } }
   */
  updateMatchPool_ByPool(pool, data) {
    const params = {};
    const url = "/match2/v1/namespaces/{namespace}/match-pools/{pool}".replace("{namespace}", this.namespace).replace("{pool}", pool);
    const resultPromise = this.axiosInstance.put(url, data, { params });
    return Validate6.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, MatchPool, "MatchPool");
  }
  /**
   * Get metric for a specific match pool Result: queueTime in seconds
   */
  getMetrics_ByPool(pool) {
    const params = {};
    const url = "/match2/v1/namespaces/{namespace}/match-pools/{pool}/metrics".replace("{namespace}", this.namespace).replace("{pool}", pool);
    const resultPromise = this.axiosInstance.get(url, { params });
    return Validate6.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      TicketMetricResultRecord,
      "TicketMetricResultRecord"
    );
  }
  /**
   * Get tickets in queue for a specific match pool Result: number of tickets and list of ticket detail in a match pool.
   */
  getTickets_ByPool(pool, queryParams) {
    const params = { limit: 20, ...queryParams };
    const url = "/match2/v1/namespaces/{namespace}/match-pools/{pool}/tickets".replace("{namespace}", this.namespace).replace("{pool}", pool);
    const resultPromise = this.axiosInstance.get(url, { params });
    return Validate6.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      ListMatchPoolTicketsResponse,
      "ListMatchPoolTicketsResponse"
    );
  }
  /**
   * Get player metric for a specific match pool
   */
  getMetricsPlayer_ByPool(pool) {
    const params = {};
    const url = "/match2/v1/namespaces/{namespace}/match-pools/{pool}/metrics/player".replace("{namespace}", this.namespace).replace("{pool}", pool);
    const resultPromise = this.axiosInstance.get(url, { params });
    return Validate6.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, PlayerMetricRecord, "PlayerMetricRecord");
  }
  /**
   * Public get player metric for a specific match pool
   */
  getMetricsPlayer_ByPool_ByNS(pool) {
    const params = {};
    const url = "/match2/v1/public/namespaces/{namespace}/match-pools/{pool}/metrics/player".replace("{namespace}", this.namespace).replace("{pool}", pool);
    const resultPromise = this.axiosInstance.get(url, { params });
    return Validate6.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, PlayerMetricRecord, "PlayerMetricRecord");
  }
};

// src/generated-public/endpoints/MatchTickets$.ts
import { Validate as Validate7 } from "@accelbyte/sdk";
import { z as z39 } from "zod";
var MatchTickets$ = class {
  // @ts-ignore
  // prettier-ignore
  constructor(axiosInstance, namespace, useSchemaValidation = true) {
    this.axiosInstance = axiosInstance;
    this.namespace = namespace;
    this.useSchemaValidation = useSchemaValidation;
  }
  /**
   * Creates a new request for matchmaking. Cross Platform: Allow player to play game with &#34;all&#34; registered platforms. 1. Cross Platform can be enabled through session service or create match ticket. a. via ticket: specify several cross_platform on create match ticket attributes. **[DEPRECATED]** client should not send from attribute &lt;code&gt;cross_platform&lt;/code&gt; will be populated from backend This value will override player attributes in session service. e.g. cross_platform:[xbox,psn,steam] b. via session service: set player/party cross_platform attributes. c. Enable match options ruleset with name cross_platform and type &#34;all&#34;. ``` { &#34;name&#34;: &#34;co-op&#34;, &#34;data&#34;: { &#34;alliance&#34;: { &#34;min_number&#34;: 1, &#34;max_number&#34;: 1, &#34;player_min_number&#34;: 1, &#34;player_max_number&#34;: 4 }, &#34;match_options&#34;: { &#34;options&#34;: [ {&#34;name&#34;: &#34;cross_platform&#34;, &#34;type&#34;: &#34;all&#34;} ] } } } ``` 2. Cross Platform can be disabled from the matchpool configuration &lt;code&gt;crossplay_disabled=true&lt;/code&gt; 3. When matchpool &lt;code&gt;crossplay_disabled=false&lt;/code&gt; * request attribute cross_platform is empty **[Recommended]**: * Matchmaking will consider Party leader &lt;code&gt;crossplayEnabled&lt;/code&gt; preference or Session attribute &lt;code&gt;crossplayEnabled&lt;/code&gt; preference. * When &lt;code&gt;crossplayEnabled=true&lt;/code&gt; &lt;code&gt;cross_platforms&lt;/code&gt; attributes will be populated from [active login methods](/iam/apidocs/#/Third%20Party%20Credential/RetrieveAllActiveThirdPartyLoginPlatformCredentialPublicV3) otherwise it will set to leader current platform * When &lt;code&gt;crossplayEnabled=false&lt;/code&gt; &lt;code&gt;cross_platforms&lt;/code&gt; attributes will be set to user&#39;s currentPlatform * request attribute cross_platform is not empty **[Not Recommended]**: * Cross Platform can be disabled with specify only ONE cross_platform. Current matchmaking use this behavior. e.g. cross_platform:[xbox] * Multiple cross_platform values is considered to be crossplay enabled 4. This behavior only works for Default Matchmaker. Custom matchmaker (custom gRPC matchmaker) need to consider this on its own implementation. ExcludedSessions: allow player to list out game sessions that they want to avoid matching, for example a match that they&#39;ve recently left or get kicked out from.
   */
  createMatchTicket(data) {
    const params = {};
    const url = "/match2/v1/namespaces/{namespace}/match-tickets".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.post(url, data, { params });
    return Validate7.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, MatchTicketResponse, "MatchTicketResponse");
  }
  /**
   * Get my match tickets.
   */
  getMatchTicketsMe(queryParams) {
    const params = { ...queryParams };
    const url = "/match2/v1/namespaces/{namespace}/match-tickets/me".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.get(url, { params });
    return Validate7.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, MatchTicketStatuses, "MatchTicketStatuses");
  }
  /**
   * Deletes an existing matchmaking ticket.
   */
  deleteMatchTicket_ByTicketid(ticketid) {
    const params = {};
    const url = "/match2/v1/namespaces/{namespace}/match-tickets/{ticketid}".replace("{namespace}", this.namespace).replace("{ticketid}", ticketid);
    const resultPromise = this.axiosInstance.delete(url, { params });
    return Validate7.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, z39.unknown(), "z.unknown()");
  }
  /**
   * Get details for a specific match ticket
   */
  getMatchTicket_ByTicketid(ticketid) {
    const params = {};
    const url = "/match2/v1/namespaces/{namespace}/match-tickets/{ticketid}".replace("{namespace}", this.namespace).replace("{ticketid}", ticketid);
    const resultPromise = this.axiosInstance.get(url, { params });
    return Validate7.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, MatchTicketStatus, "MatchTicketStatus");
  }
};

// src/generated-public/endpoints/RuleSets$.ts
import { Validate as Validate8 } from "@accelbyte/sdk";
import { z as z40 } from "zod";
var RuleSets$ = class {
  // @ts-ignore
  // prettier-ignore
  constructor(axiosInstance, namespace, useSchemaValidation = true) {
    this.axiosInstance = axiosInstance;
    this.namespace = namespace;
    this.useSchemaValidation = useSchemaValidation;
  }
  /**
   * List rule sets.
   */
  getRulesets(queryParams) {
    const params = { limit: 20, ...queryParams };
    const url = "/match2/v1/namespaces/{namespace}/rulesets".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.get(url, { params });
    return Validate8.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, ListRuleSetsResponse, "ListRuleSetsResponse");
  }
  /**
   * Creates a new rules set. A rule set has a name and contains arbitrary data which is meaningful to some particular match function(s) The name is used for a match pool to select the ruleset data that should be sent to the match function when matchmaking in that pool. To use custom rules set please set enable_custom_match_function=true. Default (false). When custom enable_custom_match_function=true, the ruleset will only validate if the rule is valid json.
   */
  createRuleset(data) {
    const params = {};
    const url = "/match2/v1/namespaces/{namespace}/rulesets".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.post(url, data, { params });
    return Validate8.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, z40.unknown(), "z.unknown()");
  }
  /**
   * Deletes an existing rule set.
   */
  deleteRuleset_ByRuleset(ruleset) {
    const params = {};
    const url = "/match2/v1/namespaces/{namespace}/rulesets/{ruleset}".replace("{namespace}", this.namespace).replace("{ruleset}", ruleset);
    const resultPromise = this.axiosInstance.delete(url, { params });
    return Validate8.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, z40.unknown(), "z.unknown()");
  }
  /**
   * Get details for a specific rule set
   */
  getRuleset_ByRuleset(ruleset) {
    const params = {};
    const url = "/match2/v1/namespaces/{namespace}/rulesets/{ruleset}".replace("{namespace}", this.namespace).replace("{ruleset}", ruleset);
    const resultPromise = this.axiosInstance.get(url, { params });
    return Validate8.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, RuleSetPayload, "RuleSetPayload");
  }
  /**
   * Updates an existing matchmaking rule set. To use custom rules set please set enable_custom_match_function=true. Default (false). When custom enable_custom_match_function=true, the ruleset will only validate if the rule is valid json.
   */
  updateRuleset_ByRuleset(ruleset, data) {
    const params = {};
    const url = "/match2/v1/namespaces/{namespace}/rulesets/{ruleset}".replace("{namespace}", this.namespace).replace("{ruleset}", ruleset);
    const resultPromise = this.axiosInstance.put(url, data, { params });
    return Validate8.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, RuleSetPayload, "RuleSetPayload");
  }
};

// src/generated-public/EnvironmentVariablesApi.ts
import { ApiUtils as ApiUtils4, Network as Network4 } from "@accelbyte/sdk";
function EnvironmentVariablesApi(sdk, args) {
  const sdkAssembly = sdk.assembly();
  const namespace = args?.coreConfig?.namespace ?? sdkAssembly.coreConfig.namespace;
  const useSchemaValidation = args?.coreConfig?.useSchemaValidation ?? sdkAssembly.coreConfig.useSchemaValidation;
  let axiosInstance = sdkAssembly.axiosInstance;
  const requestConfigOverrides = args?.axiosConfig?.request;
  const baseURLOverride = args?.coreConfig?.baseURL;
  const interceptorsOverride = args?.axiosConfig?.interceptors ?? [];
  if (requestConfigOverrides || baseURLOverride || interceptorsOverride.length > 0) {
    const requestConfig = ApiUtils4.mergeAxiosConfigs(sdkAssembly.axiosInstance.defaults, {
      ...baseURLOverride ? { baseURL: baseURLOverride } : {},
      ...requestConfigOverrides
    });
    axiosInstance = Network4.create(requestConfig);
    for (const interceptor of interceptorsOverride) {
      if (interceptor.type === "request") {
        axiosInstance.interceptors.request.use(interceptor.onRequest, interceptor.onError);
      }
      if (interceptor.type === "response") {
        axiosInstance.interceptors.response.use(interceptor.onSuccess, interceptor.onError);
      }
    }
  }
  async function getEnvironmentVariables() {
    const $ = new EnvironmentVariables$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getEnvironmentVariables();
    if (resp.error) throw resp.error;
    return resp.response;
  }
  return {
    /**
     * List environment variables.
     */
    getEnvironmentVariables
  };
}

// src/generated-public/MatchFunctionsApi.ts
import { ApiUtils as ApiUtils5, Network as Network5 } from "@accelbyte/sdk";
function MatchFunctionsApi(sdk, args) {
  const sdkAssembly = sdk.assembly();
  const namespace = args?.coreConfig?.namespace ?? sdkAssembly.coreConfig.namespace;
  const useSchemaValidation = args?.coreConfig?.useSchemaValidation ?? sdkAssembly.coreConfig.useSchemaValidation;
  let axiosInstance = sdkAssembly.axiosInstance;
  const requestConfigOverrides = args?.axiosConfig?.request;
  const baseURLOverride = args?.coreConfig?.baseURL;
  const interceptorsOverride = args?.axiosConfig?.interceptors ?? [];
  if (requestConfigOverrides || baseURLOverride || interceptorsOverride.length > 0) {
    const requestConfig = ApiUtils5.mergeAxiosConfigs(sdkAssembly.axiosInstance.defaults, {
      ...baseURLOverride ? { baseURL: baseURLOverride } : {},
      ...requestConfigOverrides
    });
    axiosInstance = Network5.create(requestConfig);
    for (const interceptor of interceptorsOverride) {
      if (interceptor.type === "request") {
        axiosInstance.interceptors.request.use(interceptor.onRequest, interceptor.onError);
      }
      if (interceptor.type === "response") {
        axiosInstance.interceptors.response.use(interceptor.onSuccess, interceptor.onError);
      }
    }
  }
  async function getMatchFunctions(queryParams) {
    const $ = new MatchFunctions$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getMatchFunctions(queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function createMatchFunction(data) {
    const $ = new MatchFunctions$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.createMatchFunction(data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function deleteMatchFunction_ByName(name) {
    const $ = new MatchFunctions$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.deleteMatchFunction_ByName(name);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function updateMatchFunction_ByName(name, data) {
    const $ = new MatchFunctions$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.updateMatchFunction_ByName(name, data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  return {
    /**
     * List existing match functions.
     */
    getMatchFunctions,
    /**
     * Creates a new matchmaking function.
     */
    createMatchFunction,
    /**
     * Deletes an existing match function.
     */
    deleteMatchFunction_ByName,
    /**
     * Update existing matchmaking function.
     */
    updateMatchFunction_ByName
  };
}

// src/generated-public/MatchPoolsApi.ts
import { ApiUtils as ApiUtils6, Network as Network6 } from "@accelbyte/sdk";
function MatchPoolsApi(sdk, args) {
  const sdkAssembly = sdk.assembly();
  const namespace = args?.coreConfig?.namespace ?? sdkAssembly.coreConfig.namespace;
  const useSchemaValidation = args?.coreConfig?.useSchemaValidation ?? sdkAssembly.coreConfig.useSchemaValidation;
  let axiosInstance = sdkAssembly.axiosInstance;
  const requestConfigOverrides = args?.axiosConfig?.request;
  const baseURLOverride = args?.coreConfig?.baseURL;
  const interceptorsOverride = args?.axiosConfig?.interceptors ?? [];
  if (requestConfigOverrides || baseURLOverride || interceptorsOverride.length > 0) {
    const requestConfig = ApiUtils6.mergeAxiosConfigs(sdkAssembly.axiosInstance.defaults, {
      ...baseURLOverride ? { baseURL: baseURLOverride } : {},
      ...requestConfigOverrides
    });
    axiosInstance = Network6.create(requestConfig);
    for (const interceptor of interceptorsOverride) {
      if (interceptor.type === "request") {
        axiosInstance.interceptors.request.use(interceptor.onRequest, interceptor.onError);
      }
      if (interceptor.type === "response") {
        axiosInstance.interceptors.response.use(interceptor.onSuccess, interceptor.onError);
      }
    }
  }
  async function getMatchPools(queryParams) {
    const $ = new MatchPools$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getMatchPools(queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function createMatchPool(data) {
    const $ = new MatchPools$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.createMatchPool(data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function deleteMatchPool_ByPool(pool) {
    const $ = new MatchPools$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.deleteMatchPool_ByPool(pool);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getMatchPool_ByPool(pool) {
    const $ = new MatchPools$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getMatchPool_ByPool(pool);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function updateMatchPool_ByPool(pool, data) {
    const $ = new MatchPools$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.updateMatchPool_ByPool(pool, data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getMetrics_ByPool(pool) {
    const $ = new MatchPools$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getMetrics_ByPool(pool);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getTickets_ByPool(pool, queryParams) {
    const $ = new MatchPools$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getTickets_ByPool(pool, queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getMetricsPlayer_ByPool(pool) {
    const $ = new MatchPools$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getMetricsPlayer_ByPool(pool);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getMetricsPlayer_ByPool_ByNS(pool) {
    const $ = new MatchPools$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getMetricsPlayer_ByPool_ByNS(pool);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  return {
    /**
     * List matchmaking pools.
     */
    getMatchPools,
    /**
     * Creates a new matchmaking pool. A pool is isolated from other pools (i.e. tickets may be matched with other tickets in the same pool, but not with tickets in other pools). Each pool has its own matchmaking rules and/or logic. ticket_expiration_seconds and backfill_ticket_expiration_seconds will be set to 300 seconds (5 minutes) by default if not filled. Match Function holds information about the name of the match logic server that matchmaking can refers to. By default we provide (&#34;default&#34; and &#34;basic&#34;). Match Function will be used as reference value for Match Function Overrides if not set. In case Customer would like to use matchmaking service default match logic, then specify it in &#34;match_function_overrides&#34;. This sample configuration will let matchmaking service will use &#34;default&#34; match logic for make matches, while validation will hit both &#34;default&#34; and &#34;custom&#34; match logics. e.g. { &#34;match_function&#34;: &#34;custom&#34;, &#34;match_function_overrides&#34;: { &#34;validation&#34;: []{&#34;default&#34;,&#34;custom&#34;}, &#34;make_matches&#34;: &#34;default&#34;, } }
     */
    createMatchPool,
    /**
     * Deletes an existing matchmaking pool.
     */
    deleteMatchPool_ByPool,
    /**
     * Get details for a specific match pool
     */
    getMatchPool_ByPool,
    /**
     * Updates an existing matchmaking pool. ticket_expiration_seconds and backfill_ticket_expiration_seconds will be set to 300 seconds (5 minutes) by default if not filled. Match Function holds information about the name of the match logic server that matchmaking can refers to. By default we provide (&#34;default&#34; and &#34;basic&#34;). Match Function will be used as reference value for Match Function Overrides if not set. In case Customer would like to use matchmaking service default match logic, then specify it in &#34;match_function_overrides&#34;. This sample configuration will let matchmaking service will use &#34;default&#34; match logic for make matches, while validation will hit both &#34;default&#34; and &#34;custom&#34; match logics. e.g. { &#34;match_function&#34;: &#34;custom&#34;, &#34;match_function_overrides&#34;: { &#34;validation&#34;: []{&#34;default&#34;,&#34;custom&#34;}, &#34;make_matches&#34;: &#34;default&#34;, } }
     */
    updateMatchPool_ByPool,
    /**
     * Get metric for a specific match pool Result: queueTime in seconds
     */
    getMetrics_ByPool,
    /**
     * Get tickets in queue for a specific match pool Result: number of tickets and list of ticket detail in a match pool.
     */
    getTickets_ByPool,
    /**
     * Get player metric for a specific match pool
     */
    getMetricsPlayer_ByPool,
    /**
     * Public get player metric for a specific match pool
     */
    getMetricsPlayer_ByPool_ByNS
  };
}

// src/generated-public/MatchTicketsApi.ts
import { ApiUtils as ApiUtils7, Network as Network7 } from "@accelbyte/sdk";
function MatchTicketsApi(sdk, args) {
  const sdkAssembly = sdk.assembly();
  const namespace = args?.coreConfig?.namespace ?? sdkAssembly.coreConfig.namespace;
  const useSchemaValidation = args?.coreConfig?.useSchemaValidation ?? sdkAssembly.coreConfig.useSchemaValidation;
  let axiosInstance = sdkAssembly.axiosInstance;
  const requestConfigOverrides = args?.axiosConfig?.request;
  const baseURLOverride = args?.coreConfig?.baseURL;
  const interceptorsOverride = args?.axiosConfig?.interceptors ?? [];
  if (requestConfigOverrides || baseURLOverride || interceptorsOverride.length > 0) {
    const requestConfig = ApiUtils7.mergeAxiosConfigs(sdkAssembly.axiosInstance.defaults, {
      ...baseURLOverride ? { baseURL: baseURLOverride } : {},
      ...requestConfigOverrides
    });
    axiosInstance = Network7.create(requestConfig);
    for (const interceptor of interceptorsOverride) {
      if (interceptor.type === "request") {
        axiosInstance.interceptors.request.use(interceptor.onRequest, interceptor.onError);
      }
      if (interceptor.type === "response") {
        axiosInstance.interceptors.response.use(interceptor.onSuccess, interceptor.onError);
      }
    }
  }
  async function createMatchTicket(data) {
    const $ = new MatchTickets$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.createMatchTicket(data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getMatchTicketsMe(queryParams) {
    const $ = new MatchTickets$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getMatchTicketsMe(queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function deleteMatchTicket_ByTicketid(ticketid) {
    const $ = new MatchTickets$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.deleteMatchTicket_ByTicketid(ticketid);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getMatchTicket_ByTicketid(ticketid) {
    const $ = new MatchTickets$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getMatchTicket_ByTicketid(ticketid);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  return {
    /**
     * Creates a new request for matchmaking. Cross Platform: Allow player to play game with &#34;all&#34; registered platforms. 1. Cross Platform can be enabled through session service or create match ticket. a. via ticket: specify several cross_platform on create match ticket attributes. **[DEPRECATED]** client should not send from attribute &lt;code&gt;cross_platform&lt;/code&gt; will be populated from backend This value will override player attributes in session service. e.g. cross_platform:[xbox,psn,steam] b. via session service: set player/party cross_platform attributes. c. Enable match options ruleset with name cross_platform and type &#34;all&#34;. ``` { &#34;name&#34;: &#34;co-op&#34;, &#34;data&#34;: { &#34;alliance&#34;: { &#34;min_number&#34;: 1, &#34;max_number&#34;: 1, &#34;player_min_number&#34;: 1, &#34;player_max_number&#34;: 4 }, &#34;match_options&#34;: { &#34;options&#34;: [ {&#34;name&#34;: &#34;cross_platform&#34;, &#34;type&#34;: &#34;all&#34;} ] } } } ``` 2. Cross Platform can be disabled from the matchpool configuration &lt;code&gt;crossplay_disabled=true&lt;/code&gt; 3. When matchpool &lt;code&gt;crossplay_disabled=false&lt;/code&gt; * request attribute cross_platform is empty **[Recommended]**: * Matchmaking will consider Party leader &lt;code&gt;crossplayEnabled&lt;/code&gt; preference or Session attribute &lt;code&gt;crossplayEnabled&lt;/code&gt; preference. * When &lt;code&gt;crossplayEnabled=true&lt;/code&gt; &lt;code&gt;cross_platforms&lt;/code&gt; attributes will be populated from [active login methods](/iam/apidocs/#/Third%20Party%20Credential/RetrieveAllActiveThirdPartyLoginPlatformCredentialPublicV3) otherwise it will set to leader current platform * When &lt;code&gt;crossplayEnabled=false&lt;/code&gt; &lt;code&gt;cross_platforms&lt;/code&gt; attributes will be set to user&#39;s currentPlatform * request attribute cross_platform is not empty **[Not Recommended]**: * Cross Platform can be disabled with specify only ONE cross_platform. Current matchmaking use this behavior. e.g. cross_platform:[xbox] * Multiple cross_platform values is considered to be crossplay enabled 4. This behavior only works for Default Matchmaker. Custom matchmaker (custom gRPC matchmaker) need to consider this on its own implementation. ExcludedSessions: allow player to list out game sessions that they want to avoid matching, for example a match that they&#39;ve recently left or get kicked out from.
     */
    createMatchTicket,
    /**
     * Get my match tickets.
     */
    getMatchTicketsMe,
    /**
     * Deletes an existing matchmaking ticket.
     */
    deleteMatchTicket_ByTicketid,
    /**
     * Get details for a specific match ticket
     */
    getMatchTicket_ByTicketid
  };
}

// src/generated-public/RuleSetsApi.ts
import { ApiUtils as ApiUtils8, Network as Network8 } from "@accelbyte/sdk";
function RuleSetsApi(sdk, args) {
  const sdkAssembly = sdk.assembly();
  const namespace = args?.coreConfig?.namespace ?? sdkAssembly.coreConfig.namespace;
  const useSchemaValidation = args?.coreConfig?.useSchemaValidation ?? sdkAssembly.coreConfig.useSchemaValidation;
  let axiosInstance = sdkAssembly.axiosInstance;
  const requestConfigOverrides = args?.axiosConfig?.request;
  const baseURLOverride = args?.coreConfig?.baseURL;
  const interceptorsOverride = args?.axiosConfig?.interceptors ?? [];
  if (requestConfigOverrides || baseURLOverride || interceptorsOverride.length > 0) {
    const requestConfig = ApiUtils8.mergeAxiosConfigs(sdkAssembly.axiosInstance.defaults, {
      ...baseURLOverride ? { baseURL: baseURLOverride } : {},
      ...requestConfigOverrides
    });
    axiosInstance = Network8.create(requestConfig);
    for (const interceptor of interceptorsOverride) {
      if (interceptor.type === "request") {
        axiosInstance.interceptors.request.use(interceptor.onRequest, interceptor.onError);
      }
      if (interceptor.type === "response") {
        axiosInstance.interceptors.response.use(interceptor.onSuccess, interceptor.onError);
      }
    }
  }
  async function getRulesets(queryParams) {
    const $ = new RuleSets$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getRulesets(queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function createRuleset(data) {
    const $ = new RuleSets$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.createRuleset(data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function deleteRuleset_ByRuleset(ruleset) {
    const $ = new RuleSets$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.deleteRuleset_ByRuleset(ruleset);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getRuleset_ByRuleset(ruleset) {
    const $ = new RuleSets$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getRuleset_ByRuleset(ruleset);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function updateRuleset_ByRuleset(ruleset, data) {
    const $ = new RuleSets$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.updateRuleset_ByRuleset(ruleset, data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  return {
    /**
     * List rule sets.
     */
    getRulesets,
    /**
     * Creates a new rules set. A rule set has a name and contains arbitrary data which is meaningful to some particular match function(s) The name is used for a match pool to select the ruleset data that should be sent to the match function when matchmaking in that pool. To use custom rules set please set enable_custom_match_function=true. Default (false). When custom enable_custom_match_function=true, the ruleset will only validate if the rule is valid json.
     */
    createRuleset,
    /**
     * Deletes an existing rule set.
     */
    deleteRuleset_ByRuleset,
    /**
     * Get details for a specific rule set
     */
    getRuleset_ByRuleset,
    /**
     * Updates an existing matchmaking rule set. To use custom rules set please set enable_custom_match_function=true. Default (false). When custom enable_custom_match_function=true, the ruleset will only validate if the rule is valid json.
     */
    updateRuleset_ByRuleset
  };
}

export {
  Configuration,
  ConfigAdmin$,
  ConfigAdminApi,
  BackfillCreateResponse,
  Party,
  Team,
  PlayerData,
  ProposedProposal,
  Ticket,
  Match,
  BackfillGetResponse,
  BackfillProposalResponse,
  Server,
  DsInformation,
  EnvironmentVariable,
  User,
  GameSession,
  ListEnvironmentVariablesResponse,
  MatchFunctionConfig,
  Pagination,
  ListMatchFunctionsResponse,
  MatchFunctionOverride,
  MatchPool,
  ListMatchPoolsResponse,
  MatchTicketRecord,
  ListMatchPoolTicketsResponse,
  MatchRuleSetNameData,
  ListRuleSetsResponse,
  MatchTicketResponse,
  MatchTicketStatus,
  MatchTicketStatuses,
  NamespaceConfig,
  NamespaceConfigList,
  PlayerMetricRecord,
  RuleSetPayloadData,
  RuleSetPayload,
  TicketMetricResultRecord,
  Backfill$,
  BackfillApi,
  Config$,
  ConfigApi,
  EnvironmentVariables$,
  MatchFunctions$,
  MatchPools$,
  MatchTickets$,
  RuleSets$,
  EnvironmentVariablesApi,
  MatchFunctionsApi,
  MatchPoolsApi,
  MatchTicketsApi,
  RuleSetsApi
};

import { z } from 'zod';
import { CommonValidationErrorType } from './constant/errorType';
import { ValidateLengthErrorType, validateLength } from './validateLength';
import { validateRegex } from './validateRegex';
import { REGEX_ALPHA_NUMERIC_CHARACTER_REPEAT, REGEX_SPECIAL_CHARACTERS, REGEX_SPECIAL_CHARACTER_REPEAT, REGEX_ALL_SPECIAL_CHARACTERS } from './constant/regex';

const ValidatePasswordErrorType = z.enum([...ValidateLengthErrorType.options, CommonValidationErrorType.enum.invalidFormat]);
const DEFAULT_REGEX = "^(?:(?=.*[A-Z])(?=.*[a-z])(?=.*[0-9])|(?=.*[A-Z])(?=.*[a-z])(?=.*[_\\W])|(?=.*[A-Z])(?=.*[0-9])(?=.*[_\\W])|(?=.*[a-z])(?=.*[0-9])(?=.*[_\\W]))(?!.*([A-Za-z0-9])\\1{2,})(?!.*([_\\W])\\2{2,})([A-Za-z0-9_\\W])[^\\s]*$";
const validatePassword = (value, {
  regex = DEFAULT_REGEX,
  minLength = 8,
  maxLength = 64,
  maxRepeatingAlphaNum = 2,
  maxRepeatingSpecialCharacter = 2,
  minCharType = 3,
  letterCase = "mixed",
  allowSpace = false,
  allowLetter = true,
  allowDigit = true,
  allowAllSpecialCharacters = true,
  isCustomRegex = false,
  allowUnicode = false,
  specialCharacters = []
} = {}) => {
  if (isCustomRegex) {
    return validateRegex(value, regex, {
      allowUnicode: allowUnicode || isCustomRegex
    });
  } else {
    if (maxRepeatingAlphaNum > 0) {
      const regex2 = new RegExp(REGEX_ALPHA_NUMERIC_CHARACTER_REPEAT(maxRepeatingAlphaNum), "g");
      if (regex2.test(value)) return ValidatePasswordErrorType.enum.invalidFormat;
    }
    if (!allowAllSpecialCharacters && specialCharacters.length === 0) {
      const regex2 = new RegExp(REGEX_ALL_SPECIAL_CHARACTERS, "g");
      if (regex2.test(value)) return ValidatePasswordErrorType.enum.invalidFormat;
    }
    if (specialCharacters.length > 0) {
      const regex2 = new RegExp(REGEX_SPECIAL_CHARACTERS(specialCharacters), "g");
      if (regex2.test(value)) return ValidatePasswordErrorType.enum.invalidFormat;
    }
    let charTypeCount = 0;
    if (allowLetter && /[a-z]/.test(value)) charTypeCount++;
    if (allowLetter && /[A-Z]/.test(value)) charTypeCount++;
    if (allowDigit && /\d/.test(value)) charTypeCount++;
    if (allowAllSpecialCharacters && /[^\w\s]/.test(value)) charTypeCount++;
    if (!allowAllSpecialCharacters && specialCharacters.length > 0) {
      const regex2 = new RegExp(REGEX_SPECIAL_CHARACTER_REPEAT(specialCharacters, maxRepeatingSpecialCharacter), "g");
      if (regex2.test(value)) charTypeCount++;
    }
    if (charTypeCount < minCharType) {
      return ValidatePasswordErrorType.enum.invalidFormat;
    }
    if (!allowSpace) {
      const isSpaceFound = /\s/.test(value);
      if (isSpaceFound) return ValidatePasswordErrorType.enum.invalidFormat;
    }
    if (letterCase === "lowercase" && value.toLowerCase() !== value) {
      return ValidatePasswordErrorType.enum.invalidFormat;
    }
    if (letterCase === "uppercase" && value.toUpperCase() !== value) {
      return ValidatePasswordErrorType.enum.invalidFormat;
    }
  }
  return validateLength(value, {
    max: maxLength,
    min: minLength
  });
};

export { ValidatePasswordErrorType, validatePassword };
//# sourceMappingURL=validatePassword.js.map
//# sourceMappingURL=validatePassword.js.map
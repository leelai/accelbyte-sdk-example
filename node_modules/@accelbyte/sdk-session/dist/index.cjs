"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name2 in all)
    __defProp(target, name2, { get: all[name2], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/index.ts
var src_exports = {};
__export(src_exports, {
  AppendTeamGameSessionRequest: () => AppendTeamGameSessionRequest,
  CertificateAdmin$: () => CertificateAdmin$,
  CertificateAdminApi: () => CertificateAdminApi,
  ConfigAdmin$: () => ConfigAdmin$,
  ConfigAdminApi: () => ConfigAdminApi,
  ConfigAlertRequestCreate: () => ConfigAlertRequestCreate,
  ConfigAlertResponse: () => ConfigAlertResponse,
  Configuration: () => Configuration,
  ConfigurationTemplateAdmin$: () => ConfigurationTemplateAdmin$,
  ConfigurationTemplateAdminApi: () => ConfigurationTemplateAdminApi,
  ConfigurationTemplateResponse: () => ConfigurationTemplateResponse,
  ConfigurationTemplatesResponse: () => ConfigurationTemplatesResponse,
  CreateConfigurationTemplateRequest: () => CreateConfigurationTemplateRequest,
  CreateGameSessionRequest: () => CreateGameSessionRequest,
  CreatePartyRequest: () => CreatePartyRequest,
  DefaultDsmcConfig: () => DefaultDsmcConfig,
  DeleteBulkGameSessionRequest: () => DeleteBulkGameSessionRequest,
  DeleteBulkGameSessionsApiResponse: () => DeleteBulkGameSessionsApiResponse,
  DsInformationResponse: () => DsInformationResponse,
  DsmConfigRecord: () => DsmConfigRecord,
  DsmcDefaultConfigurationAdmin$: () => DsmcDefaultConfigurationAdmin$,
  DsmcDefaultConfigurationAdminApi: () => DsmcDefaultConfigurationAdminApi,
  EnvironmentVariableAdmin$: () => EnvironmentVariableAdmin$,
  EnvironmentVariableAdminApi: () => EnvironmentVariableAdminApi,
  EnvironmentVariableListResponse: () => EnvironmentVariableListResponse,
  EnvironmentVariableResponse: () => EnvironmentVariableResponse,
  Error: () => Error2,
  ExtendConfiguration: () => ExtendConfiguration,
  GameServer: () => GameServer,
  GameSession$: () => GameSession$,
  GameSessionAdmin$: () => GameSessionAdmin$,
  GameSessionAdminApi: () => GameSessionAdminApi,
  GameSessionApi: () => GameSessionApi,
  GameSessionQueryResponse: () => GameSessionQueryResponse,
  GameSessionResponse: () => GameSessionResponse,
  GlobalConfigurationAdmin$: () => GlobalConfigurationAdmin$,
  GlobalConfigurationAdminApi: () => GlobalConfigurationAdminApi,
  GlobalConfigurationResponse: () => GlobalConfigurationResponse,
  JoinByCodeRequest: () => JoinByCodeRequest,
  KickResponse: () => KickResponse,
  MaxActiveAdmin$: () => MaxActiveAdmin$,
  MaxActiveAdminApi: () => MaxActiveAdminApi,
  MemberActiveSession: () => MemberActiveSession,
  NativeSession: () => NativeSession,
  NativeSessionAdmin$: () => NativeSessionAdmin$,
  NativeSessionAdminApi: () => NativeSessionAdminApi,
  NativeSessionMember: () => NativeSessionMember,
  NativeSessionPagingResponse: () => NativeSessionPagingResponse,
  NativeSessionSetting: () => NativeSessionSetting,
  Pagination: () => Pagination,
  Party$: () => Party$,
  PartyAdmin$: () => PartyAdmin$,
  PartyAdminApi: () => PartyAdminApi,
  PartyApi: () => PartyApi,
  PartyMembers: () => PartyMembers,
  PartyQueryResponse: () => PartyQueryResponse,
  PartySessionResponse: () => PartySessionResponse,
  PlatformCredentialAdmin$: () => PlatformCredentialAdmin$,
  PlatformCredentialAdminApi: () => PlatformCredentialAdminApi,
  PlatformCredentials: () => PlatformCredentials,
  Player$: () => Player$,
  PlayerAdmin$: () => PlayerAdmin$,
  PlayerAdminApi: () => PlayerAdminApi,
  PlayerApi: () => PlayerApi,
  PlayerAttributesRequestBody: () => PlayerAttributesRequestBody,
  PlayerAttributesResponseBody: () => PlayerAttributesResponseBody,
  PlayerAttributesResponseBodyArray: () => PlayerAttributesResponseBodyArray,
  PlayerPlatform: () => PlayerPlatform,
  PlayersCurrentPlatformRequest: () => PlayersCurrentPlatformRequest,
  PlayersCurrentPlatformResponse: () => PlayersCurrentPlatformResponse,
  PortConfigurationAms: () => PortConfigurationAms,
  PromoteLeaderRequest: () => PromoteLeaderRequest,
  PsnAppServerCredentials: () => PsnAppServerCredentials,
  PublicConfiguration: () => PublicConfiguration,
  PutGlobalConfigurationRequest: () => PutGlobalConfigurationRequest,
  PutPlatformCredentialsRequest: () => PutPlatformCredentialsRequest,
  RecentPlayer$: () => RecentPlayer$,
  RecentPlayerAdmin$: () => RecentPlayerAdmin$,
  RecentPlayerAdminApi: () => RecentPlayerAdminApi,
  RecentPlayerApi: () => RecentPlayerApi,
  RecentPlayerQueryResponse: () => RecentPlayerQueryResponse,
  RequestMember: () => RequestMember,
  RequestReconcileMaxActiveSession: () => RequestReconcileMaxActiveSession,
  ResponseDeleteBulkGameSessions: () => ResponseDeleteBulkGameSessions,
  ServerSecret: () => ServerSecret,
  Session: () => Session,
  SessionInviteRequest: () => SessionInviteRequest,
  SessionInviteResponse: () => SessionInviteResponse,
  SessionStorage$: () => SessionStorage$,
  SessionStorageAdmin$: () => SessionStorageAdmin$,
  SessionStorageAdminApi: () => SessionStorageAdminApi,
  SessionStorageApi: () => SessionStorageApi,
  SessionStorageRequest: () => SessionStorageRequest,
  SetDsReadyRequest: () => SetDsReadyRequest,
  Team: () => Team,
  UpdateConfigurationTemplateRequest: () => UpdateConfigurationTemplateRequest,
  UpdateGameSessionBackfillRequest: () => UpdateGameSessionBackfillRequest,
  UpdateGameSessionMemberStatusResponse: () => UpdateGameSessionMemberStatusResponse,
  UpdateGameSessionRequest: () => UpdateGameSessionRequest,
  UpdatePartyRequest: () => UpdatePartyRequest,
  UserInfoResponse: () => UserInfoResponse,
  UserPlatformInfo: () => UserPlatformInfo,
  UserResponse: () => UserResponse
});
module.exports = __toCommonJS(src_exports);

// src/generated-admin/CertificateAdminApi.ts
var import_sdk2 = require("@accelbyte/sdk");

// src/generated-admin/endpoints/CertificateAdmin$.ts
var import_sdk = require("@accelbyte/sdk");

// src/generated-definitions/PlatformCredentials.ts
var import_zod2 = require("zod");

// src/generated-definitions/PsnAppServerCredentials.ts
var import_zod = require("zod");
var PsnAppServerCredentials = import_zod.z.object({ clientId: import_zod.z.string(), clientSecret: import_zod.z.string(), scope: import_zod.z.string() });

// src/generated-definitions/PlatformCredentials.ts
var PlatformCredentials = import_zod2.z.object({ psn: PsnAppServerCredentials, updatedAt: import_zod2.z.string() });

// src/generated-admin/endpoints/CertificateAdmin$.ts
var CertificateAdmin$ = class {
  // @ts-ignore
  // prettier-ignore
  constructor(axiosInstance, namespace, useSchemaValidation = true) {
    this.axiosInstance = axiosInstance;
    this.namespace = namespace;
    this.useSchemaValidation = useSchemaValidation;
  }
  /**
   * Upload certificates for xbox. Certificate must be in the valid form of PFX format.
   */
  updateCertificatePfxPlatformXbl(data) {
    const params = {};
    const url = "/session/v1/admin/namespaces/{namespace}/certificates/pfx/platforms/xbl".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.put(url, data, { params });
    return import_sdk.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, PlatformCredentials, "PlatformCredentials");
  }
};

// src/generated-admin/CertificateAdminApi.ts
function CertificateAdminApi(sdk, args) {
  const sdkAssembly = sdk.assembly();
  const namespace = args?.coreConfig?.namespace ?? sdkAssembly.coreConfig.namespace;
  const useSchemaValidation = args?.coreConfig?.useSchemaValidation ?? sdkAssembly.coreConfig.useSchemaValidation;
  let axiosInstance = sdkAssembly.axiosInstance;
  const requestConfigOverrides = args?.axiosConfig?.request;
  const baseURLOverride = args?.coreConfig?.baseURL;
  const interceptorsOverride = args?.axiosConfig?.interceptors ?? [];
  if (requestConfigOverrides || baseURLOverride || interceptorsOverride.length > 0) {
    const requestConfig = import_sdk2.ApiUtils.mergeAxiosConfigs(sdkAssembly.axiosInstance.defaults, {
      ...baseURLOverride ? { baseURL: baseURLOverride } : {},
      ...requestConfigOverrides
    });
    axiosInstance = import_sdk2.Network.create(requestConfig);
    for (const interceptor of interceptorsOverride) {
      if (interceptor.type === "request") {
        axiosInstance.interceptors.request.use(interceptor.onRequest, interceptor.onError);
      }
      if (interceptor.type === "response") {
        axiosInstance.interceptors.response.use(interceptor.onSuccess, interceptor.onError);
      }
    }
  }
  async function updateCertificatePfxPlatformXbl(data) {
    const $ = new CertificateAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.updateCertificatePfxPlatformXbl(data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  return {
    /**
     * Upload certificates for xbox. Certificate must be in the valid form of PFX format.
     */
    updateCertificatePfxPlatformXbl
  };
}

// src/generated-admin/ConfigAdminApi.ts
var import_sdk4 = require("@accelbyte/sdk");

// src/generated-admin/endpoints/ConfigAdmin$.ts
var import_sdk3 = require("@accelbyte/sdk");

// src/generated-definitions/Configuration.ts
var import_zod3 = require("zod");
var Configuration = import_zod3.z.object({ logLevel: import_zod3.z.enum(["debug", "error", "fatal", "info", "panic", "trace", "warning"]).nullish() });

// src/generated-admin/endpoints/ConfigAdmin$.ts
var ConfigAdmin$ = class {
  // @ts-ignore
  // prettier-ignore
  constructor(axiosInstance, namespace, useSchemaValidation = true) {
    this.axiosInstance = axiosInstance;
    this.namespace = namespace;
    this.useSchemaValidation = useSchemaValidation;
  }
  /**
   * Get Log Configuration.&lt;br&gt;
   */
  getConfigLog() {
    const params = {};
    const url = "/session/v1/admin/config/log";
    const resultPromise = this.axiosInstance.get(url, { params });
    return import_sdk3.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, Configuration, "Configuration");
  }
  /**
   * Update Log Configuration.&lt;br&gt;
   */
  patchConfigLog(data) {
    const params = {};
    const url = "/session/v1/admin/config/log";
    const resultPromise = this.axiosInstance.patch(url, data, { params });
    return import_sdk3.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, Configuration, "Configuration");
  }
};

// src/generated-admin/ConfigAdminApi.ts
function ConfigAdminApi(sdk, args) {
  const sdkAssembly = sdk.assembly();
  const namespace = args?.coreConfig?.namespace ?? sdkAssembly.coreConfig.namespace;
  const useSchemaValidation = args?.coreConfig?.useSchemaValidation ?? sdkAssembly.coreConfig.useSchemaValidation;
  let axiosInstance = sdkAssembly.axiosInstance;
  const requestConfigOverrides = args?.axiosConfig?.request;
  const baseURLOverride = args?.coreConfig?.baseURL;
  const interceptorsOverride = args?.axiosConfig?.interceptors ?? [];
  if (requestConfigOverrides || baseURLOverride || interceptorsOverride.length > 0) {
    const requestConfig = import_sdk4.ApiUtils.mergeAxiosConfigs(sdkAssembly.axiosInstance.defaults, {
      ...baseURLOverride ? { baseURL: baseURLOverride } : {},
      ...requestConfigOverrides
    });
    axiosInstance = import_sdk4.Network.create(requestConfig);
    for (const interceptor of interceptorsOverride) {
      if (interceptor.type === "request") {
        axiosInstance.interceptors.request.use(interceptor.onRequest, interceptor.onError);
      }
      if (interceptor.type === "response") {
        axiosInstance.interceptors.response.use(interceptor.onSuccess, interceptor.onError);
      }
    }
  }
  async function getConfigLog() {
    const $ = new ConfigAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getConfigLog();
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function patchConfigLog(data) {
    const $ = new ConfigAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.patchConfigLog(data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  return {
    /**
     * Get Log Configuration.&lt;br&gt;
     */
    getConfigLog,
    /**
     * Update Log Configuration.&lt;br&gt;
     */
    patchConfigLog
  };
}

// src/generated-admin/ConfigurationTemplateAdminApi.ts
var import_sdk6 = require("@accelbyte/sdk");

// src/generated-admin/endpoints/ConfigurationTemplateAdmin$.ts
var import_sdk5 = require("@accelbyte/sdk");
var import_zod11 = require("zod");

// src/generated-definitions/ConfigAlertResponse.ts
var import_zod4 = require("zod");
var ConfigAlertResponse = import_zod4.z.object({
  createdAt: import_zod4.z.string(),
  durationDays: import_zod4.z.number().int(),
  namespace: import_zod4.z.string(),
  updatedAt: import_zod4.z.string()
});

// src/generated-definitions/ConfigurationTemplateResponse.ts
var import_zod7 = require("zod");

// src/generated-definitions/ExtendConfiguration.ts
var import_zod5 = require("zod");
var ExtendConfiguration = import_zod5.z.object({
  appName: import_zod5.z.string().nullish(),
  customURL: import_zod5.z.string().nullish(),
  functionFlag: import_zod5.z.number().int().nullish()
});

// src/generated-definitions/NativeSessionSetting.ts
var import_zod6 = require("zod");
var NativeSessionSetting = import_zod6.z.object({
  PSNServiceLabel: import_zod6.z.number().int(),
  PSNSupportedPlatforms: import_zod6.z.array(import_zod6.z.string()).nullish(),
  SessionTitle: import_zod6.z.string(),
  ShouldSync: import_zod6.z.boolean().nullish(),
  XboxAllowCrossPlatform: import_zod6.z.boolean(),
  XboxSandboxID: import_zod6.z.string(),
  XboxServiceConfigID: import_zod6.z.string(),
  XboxSessionTemplateName: import_zod6.z.string(),
  XboxTitleID: import_zod6.z.string(),
  localizedSessionName: import_zod6.z.record(import_zod6.z.any()).nullish()
});

// src/generated-definitions/ConfigurationTemplateResponse.ts
var ConfigurationTemplateResponse = import_zod7.z.object({
  PSNBaseUrl: import_zod7.z.string().nullish(),
  appName: import_zod7.z.string().nullish(),
  attributes: import_zod7.z.record(import_zod7.z.any()).nullish(),
  autoJoin: import_zod7.z.boolean().nullish(),
  autoLeaveSession: import_zod7.z.boolean().nullish(),
  clientVersion: import_zod7.z.string(),
  createdAt: import_zod7.z.string(),
  customURLGRPC: import_zod7.z.string().nullish(),
  deployment: import_zod7.z.string(),
  disableCodeGeneration: import_zod7.z.boolean().nullish(),
  disableResendInvite: import_zod7.z.boolean().nullish(),
  dsManualSetReady: import_zod7.z.boolean().nullish(),
  dsSource: import_zod7.z.string().nullish(),
  enableSecret: import_zod7.z.boolean().nullish(),
  fallbackClaimKeys: import_zod7.z.array(import_zod7.z.string()).nullish(),
  grpcSessionConfig: ExtendConfiguration.nullish(),
  immutableStorage: import_zod7.z.boolean().nullish(),
  inactiveTimeout: import_zod7.z.number().int(),
  inviteTimeout: import_zod7.z.number().int(),
  joinability: import_zod7.z.string(),
  last: import_zod7.z.string(),
  leaderElectionGracePeriod: import_zod7.z.number().int().nullish(),
  manualRejoin: import_zod7.z.boolean().nullish(),
  maxActiveSessions: import_zod7.z.number().int().nullish(),
  maxPlayers: import_zod7.z.number().int(),
  minPlayers: import_zod7.z.number().int(),
  name: import_zod7.z.string(),
  namespace: import_zod7.z.string(),
  nativeSessionSetting: NativeSessionSetting.nullish(),
  persistent: import_zod7.z.boolean(),
  preferredClaimKeys: import_zod7.z.array(import_zod7.z.string()).nullish(),
  requestedRegions: import_zod7.z.array(import_zod7.z.string()).nullish(),
  textChat: import_zod7.z.boolean(),
  tieTeamsSessionLifetime: import_zod7.z.boolean().nullish(),
  type: import_zod7.z.string(),
  updatedAt: import_zod7.z.string()
});

// src/generated-definitions/ConfigurationTemplatesResponse.ts
var import_zod9 = require("zod");

// src/generated-definitions/Pagination.ts
var import_zod8 = require("zod");
var Pagination = import_zod8.z.object({ first: import_zod8.z.string(), last: import_zod8.z.string(), next: import_zod8.z.string(), previous: import_zod8.z.string() });

// src/generated-definitions/ConfigurationTemplatesResponse.ts
var ConfigurationTemplatesResponse = import_zod9.z.object({ data: import_zod9.z.array(ConfigurationTemplateResponse), paging: Pagination });

// src/generated-definitions/DsmConfigRecord.ts
var import_zod10 = require("zod");
var DsmConfigRecord = import_zod10.z.object({
  claim_timeout: import_zod10.z.number().int(),
  createdAt: import_zod10.z.string(),
  creation_timeout: import_zod10.z.number().int(),
  namespace: import_zod10.z.string(),
  updatedAt: import_zod10.z.string()
});

// src/generated-admin/endpoints/ConfigurationTemplateAdmin$.ts
var ConfigurationTemplateAdmin$ = class {
  // @ts-ignore
  // prettier-ignore
  constructor(axiosInstance, namespace, useSchemaValidation = true) {
    this.axiosInstance = axiosInstance;
    this.namespace = namespace;
    this.useSchemaValidation = useSchemaValidation;
  }
  /**
   * Get a dsmc configuration.
   */
  getDsconfigs() {
    const params = {};
    const url = "/session/v1/admin/namespaces/{namespace}/dsconfigs".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.get(url, { params });
    return import_sdk5.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, DsmConfigRecord, "DsmConfigRecord");
  }
  /**
   * Create template configuration to be applied across party and session. Session configuration mandatory : - name - joinability. supported values: - OPEN: user can join or rejoin the session without an invite - CLOSED: once a CLOSED session is created or a session joinability is updated to CLOSED, any change to session members is not allowed and remaining invites will all be canceled. - INVITE_ONLY: to join the session, user whether needs to be invited, or have the code (for join by code). when a user is KICKED/LEFT/REJECTED from this session, they will need to be re-invited to join. - FRIENDS_OF_MEMBERS: only if a user is friend with at least one of the session members, they can join via code. - FRIENDS_OF_LEADER: only if a user is friend with the session leader, they can join via code. - FRIENDS_OF_FRIENDS: only friends of the leader OR friends of friends of the leader can join via code. - autoJoin: when enabled, players will automatically join the initial game session creation. Game session will not send any invite and players dont need to act upon it. default: false (disabled) - Type (example value : P2P, DS, NONE) if type empty, type will be assign to NONE - MinPlayers (must greater or equal 0) - MaxPlayers (must greater than 0) - InviteTimeout (must greater or equal 0) if InviteTimeout equal 0 will be use default DefaultTimeoutSecond (60s) - InactiveTimeout (must greater or equal 0) if InactiveTimeout equal 0 will be use default DefaultTimeoutSecond (60s) - Persistent will only applies to session with type DS (example value true or false, default: false) - If Persistent True the session always active even DS removing or terminate and Session will be request DS again until DS Ready or Busy. - To Stop Session Not request again to DS or want Delete Session can Delete Session using endpoint DELETE /session/v1/public/namespaces/{namespace}/gamesessions/{sessionId} - If Persistent False the session will be inactive if all member left and DS terminate or removing - nativeSessionSetting: - XboxSessionTemplateName: the XBox session template name that correspondent to the AB session template, and is needed to define XBox session&#39;s joinRestriction and maxMembersCount when doing the session sync. - XboxServiceConfigID: the XBox service configuration ID. - PSNServiceLabel: the PSN service label. - SessionTitle: the session title. In PSN, this will be used to define name of the session thats displayed on PlayStation system UI. - ShouldSync: to define whether the service needs to do session sync with native platform(s). Default: false (disabled). - PSNSupportedPlatforms: the PSN supported platforms. In PSN, if ShouldSync true and PSNSupportedPlatforms is empty, then PS5 will be set as default value. - PSNBaseUrl this is for base URL PSN if not set will be default value https://s2s.sp-int.playstation.net. In a single namespace only 1 PSN Env that can be used. Multiple session template should refers to the same PSN Env as we have in IAM Service. - https://s2s.sp-int.playstation.net (DEV, need IP Whitelist) - https://s2s.prod-qa.playstation.net (QA Environment/PSN Certification) - https://s2s.np.playstation.net (Production) - localizedSessionName : for localized name and default language example payload : &#34;localizedSessionName&#34;:{ &#34;defaultLanguage&#34; : &#34;en-US&#34; &#34;localizedText&#34; :{ &#34;en-US&#34; : &#34;title&#34; } } - if the game client wants to enable push context to PSN, game client will need to store PSN_PUSH_CONTEXT_ID on the player attributes, otherwise Session service will try to populate from the session attributes or auto generate with random UUID if empty. - TieTeamsSessionLifetime (optional, default: false): If it is set to true, the lifetime of any partyId session inside teams attribute will be tied to the game session. Only applies when the teams partyId is game session. - DisableCodeGeneration (optional, default: false): If it is set to true, code will not be generated for party session automatically. - DSManualSetReady (optional, default: false): The DS need to call specific end point to flag the DS for game session is ready to accept client connection. - EnableSecret (optional, default: false): if configuration template is created with TypeDS and EnableSecret is True, A secret will be created - LeaderElectionGracePeriod this is on second (optional, default:0) this is only use for party session, if value &gt; 0 if leader disconnect will be wait until value reach and leader will be change after reach - ManualRejoin (optional, default: false): indicates if game client will handle manual rejoin upon websocket reconnection when enabled. - DisableResendInvite (optional, default: false): by default, the service will be sending invites until the user reacts to it. enabling this flag will prohibit the service to send reminder invites&#39;. - appName (optional, default: empty string). Extend application name that uploaded to AccelByte extends deployment. The application is for custom/external DS management. - customURLGRPC (optional: default: empty string). Url for grpc server that server custom/external DS management. This value will be ignore when appName is filled. Value formatted as host:port. Example: yourdomain.com:9989 - grpcSessionConfig (optional, default: empty object). Setting for grpc session extends. Session service will calls the grpc when any activity for the game sessions. - appName (required when customURL is empty) The extends app name that created and uploaded to AccelByte extends deployment. - customURL (required when appName is empty) The url for grpc server. Format is host:port. Example: mycustomdomain.com:9889. This will be ignore when appName is filled. - functionFlag (optional, default: -1) Flag to enable which function to calls when any event on the game sessions. The value is bitwise integer. - 0x1 is for created event. Event is sync, anything return from create event will be overide the final game session. - 0x2 is for updated event. Event is async. Called when any update on the game session. - 0x4 is for deleted event. Event is async. Callen when game session got deleted. Example: - value 3: enable for created and updated - value 7: enable for created, updated, and deleted, etc
   */
  createConfiguration(data) {
    const params = {};
    const url = "/session/v1/admin/namespaces/{namespace}/configuration".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.post(url, data, { params });
    return import_sdk5.Validate.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      ConfigurationTemplateResponse,
      "ConfigurationTemplateResponse"
    );
  }
  /**
   * Get all template configurations in specified namespace.
   */
  getConfigurations(queryParams) {
    const params = { limit: 20, ...queryParams };
    const url = "/session/v1/admin/namespaces/{namespace}/configurations".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.get(url, { params });
    return import_sdk5.Validate.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      ConfigurationTemplatesResponse,
      "ConfigurationTemplatesResponse"
    );
  }
  /**
   * sync dsmc configuration.
   */
  getDsconfigsSync() {
    const params = {};
    const url = "/session/v1/admin/namespaces/{namespace}/dsconfigs/sync".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.get(url, { params });
    return import_sdk5.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, DsmConfigRecord, "DsmConfigRecord");
  }
  /**
   * Delete configuration alert.
   */
  deleteAlertsConfiguration() {
    const params = {};
    const url = "/session/v1/admin/namespaces/{namespace}/alerts-configuration".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.delete(url, { params });
    return import_sdk5.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, import_zod11.z.unknown(), "z.unknown()");
  }
  /**
   * Get a configuration alert.
   */
  getAlertsConfiguration() {
    const params = {};
    const url = "/session/v1/admin/namespaces/{namespace}/alerts-configuration".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.get(url, { params });
    return import_sdk5.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, ConfigAlertResponse, "ConfigAlertResponse");
  }
  /**
   * Create configuration alert configuration alert mandatory : - namespace - durationDays must be greater than 0
   */
  updateAlertsConfiguration(data) {
    const params = {};
    const url = "/session/v1/admin/namespaces/{namespace}/alerts-configuration".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.post(url, data, { params });
    return import_sdk5.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, ConfigAlertResponse, "ConfigAlertResponse");
  }
  /**
   * Update configuration alert configuration alert mandatory : - namespace - durationDays must be greater than 0
   */
  updateAlertsConfiguration_ByNS(data) {
    const params = {};
    const url = "/session/v1/admin/namespaces/{namespace}/alerts-configuration".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.put(url, data, { params });
    return import_sdk5.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, ConfigAlertResponse, "ConfigAlertResponse");
  }
  /**
   * Delete a template configuration.
   */
  deleteConfiguration_ByName(name2) {
    const params = {};
    const url = "/session/v1/admin/namespaces/{namespace}/configurations/{name}".replace("{namespace}", this.namespace).replace("{name}", name2);
    const resultPromise = this.axiosInstance.delete(url, { params });
    return import_sdk5.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, import_zod11.z.unknown(), "z.unknown()");
  }
  /**
   * Get a template configuration.
   */
  getConfiguration_ByName(name2) {
    const params = {};
    const url = "/session/v1/admin/namespaces/{namespace}/configurations/{name}".replace("{namespace}", this.namespace).replace("{name}", name2);
    const resultPromise = this.axiosInstance.get(url, { params });
    return import_sdk5.Validate.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      ConfigurationTemplateResponse,
      "ConfigurationTemplateResponse"
    );
  }
  /**
   * Modify template configuration Session configuration mandatory : - name - joinability. supported values: - OPEN: user can join or rejoin the session without an invite - CLOSED: once a CLOSED session is created or a session joinability is updated to CLOSED, any change to session members is not allowed and remaining invites will all be canceled. - INVITE_ONLY: to join the session, user whether needs to be invited, or have the code (for join by code). when a user is KICKED/LEFT/REJECTED from this session, they will need to be re-invited to join. - FRIENDS_OF_MEMBERS: only if a user is friend with at least one of the session members, they can join via code. - FRIENDS_OF_LEADER: only if a user is friend with the session leader, they can join via code. - FRIENDS_OF_FRIENDS: only friends of the leader OR friends of friends of the leader can join via code. - autoJoin: when enabled, players will automatically join the initial game session creation. Game session will not send any invite and players dont need to act upon it. default: false (disabled) - Type (example value : P2P, DS, NONE) if type empty, type will be assign to NONE - MinPlayers (must greater or equal 0) - MaxPlayers (must greater than 0) - InviteTimeout (must greater or equal 0) if InviteTimeout equal 0 will be use default DefaultTimeoutSecond (60s) - InactiveTimeout (must greater or equal 0) if InactiveTimeout equal 0 will be use default DefaultTimeoutSecond (60s) - Persistent Flag only can use with type DS (example value true or false) - If Persistent True the session always active even DS removing or terminate and Session will be request DS again until DS Ready or Busy. - To Stop Session Not request again to DS or want Delete Session can Delete Session using endpoint DELETE /session/v1/public/namespaces/{namespace}/gamesessions/{sessionId} - If Persistent False the session will be inactive if all member left and DS terminate or removing - nativeSessionSetting: - XboxSessionTemplateName: the XBox session template name that correspondent to the AB session template, and is needed to define XBox session&#39;s joinRestriction and maxMembersCount when doing the session sync. - XboxServiceConfigID: the XBox service configuration ID. - PSNServiceLabel: the PSN service label. - SessionTitle: the session title. In PSN, this will be used to define name of the session thats displayed on PlayStation system UI. - ShouldSync: to define whether the service needs to do session sync with native platform(s). Default: false (disabled). - PSNSupportedPlatforms: the PSN supported platforms. In PSN, if ShouldSync true and PSNSupportedPlatforms is empty, then PS5 will be set as default value. - PSNBaseUrl this is for base URL PSN if not set will be default value https://s2s.sp-int.playstation.net. In a single namespace only 1 PSN Env that can be used. Multiple session template should refers to the same PSN Env as we have in IAM Service. - https://s2s.sp-int.playstation.net (DEV, need IP Whitelist) - https://s2s.prod-qa.playstation.net (QA Environment/PSN Certification) - https://s2s.np.playstation.net (Production) - localizedSessionName : for localized name and default language example payload : &#34;localizedSessionName&#34;:{ &#34;defaultLanguage&#34; : &#34;en-US&#34; &#34;localizedText&#34; :{ &#34;en-US&#34; : &#34;title&#34; } } - if the game client wants to enable push context to PSN, game client will need to store PSN_PUSH_CONTEXT_ID on the player attributes, otherwise Session service will try to populate from the session attributes or auto generate with random UUID if empty. - TieTeamsSessionLifetime: If it is set to true, the lifetime of any partyId session inside teams attribute will be tied to the game session. Only applies when the teams partyId is game session. - DisableCodeGeneration (optional, default: false): If it is set to true, code will not be generated for party session automatically. - DSManualSetReady (optional, default: false): The DS need to call specific end point to flag the DS for game session is ready to accept client connection. - EnableSecret (optional, default: false): if configuration template is created with TypeDS and EnableSecret is True, A secret will be created. - ManualRejoin (optional, default: false): indicates if game client will handle manual rejoin upon websocket reconnection when enabled. - DisableResendInvite (optional, default: false): by default, the service will be sending invites until the user reacts to it. enabling this flag will prohibit the service to send reminder invites&#39;. - appName (optional, default: empty string). Extend application name that uploaded to AccelByte extends deployment. The application is for custom/external DS management. - customURLGRPC (optional: default: empty string). Url for grpc server that server custom/external DS management. This value will be ignore when appName is filled. Value formatted as host:port. Example: yourdomain.com:9989 - grpcSessionConfig (optional, default: empty object). Setting for grpc session extends. Session service will calls the grpc when any activity for the game sessions. - appName (required when customURL is empty) The extends app name that created and uploaded to AccelByte extends deployment. - customURL (required when appName is empty) The url for grpc server. Format is host:port. Example: mycustomdomain.com:9889. This will be ignore when appName is filled. - functionFlag (optional, default: -1) Flag to enable which function to calls when any event on the game sessions. The value is bitwise integer. - 0x1 is for created event. Event is sync, anything return from create event will be overide the final game session. - 0x2 is for updated event. Event is async. Called when any update on the game session. - 0x4 is for deleted event. Event is async. Callen when game session got deleted. Example: - value 3: enable for created and updated - value 7: enable for created, updated, and deleted, etc
   */
  updateConfiguration_ByName(name2, data) {
    const params = {};
    const url = "/session/v1/admin/namespaces/{namespace}/configurations/{name}".replace("{namespace}", this.namespace).replace("{name}", name2);
    const resultPromise = this.axiosInstance.put(url, data, { params });
    return import_sdk5.Validate.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      ConfigurationTemplateResponse,
      "ConfigurationTemplateResponse"
    );
  }
};

// src/generated-admin/ConfigurationTemplateAdminApi.ts
function ConfigurationTemplateAdminApi(sdk, args) {
  const sdkAssembly = sdk.assembly();
  const namespace = args?.coreConfig?.namespace ?? sdkAssembly.coreConfig.namespace;
  const useSchemaValidation = args?.coreConfig?.useSchemaValidation ?? sdkAssembly.coreConfig.useSchemaValidation;
  let axiosInstance = sdkAssembly.axiosInstance;
  const requestConfigOverrides = args?.axiosConfig?.request;
  const baseURLOverride = args?.coreConfig?.baseURL;
  const interceptorsOverride = args?.axiosConfig?.interceptors ?? [];
  if (requestConfigOverrides || baseURLOverride || interceptorsOverride.length > 0) {
    const requestConfig = import_sdk6.ApiUtils.mergeAxiosConfigs(sdkAssembly.axiosInstance.defaults, {
      ...baseURLOverride ? { baseURL: baseURLOverride } : {},
      ...requestConfigOverrides
    });
    axiosInstance = import_sdk6.Network.create(requestConfig);
    for (const interceptor of interceptorsOverride) {
      if (interceptor.type === "request") {
        axiosInstance.interceptors.request.use(interceptor.onRequest, interceptor.onError);
      }
      if (interceptor.type === "response") {
        axiosInstance.interceptors.response.use(interceptor.onSuccess, interceptor.onError);
      }
    }
  }
  async function getDsconfigs() {
    const $ = new ConfigurationTemplateAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getDsconfigs();
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function createConfiguration(data) {
    const $ = new ConfigurationTemplateAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.createConfiguration(data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getConfigurations(queryParams) {
    const $ = new ConfigurationTemplateAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getConfigurations(queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getDsconfigsSync() {
    const $ = new ConfigurationTemplateAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getDsconfigsSync();
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function deleteAlertsConfiguration() {
    const $ = new ConfigurationTemplateAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.deleteAlertsConfiguration();
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getAlertsConfiguration() {
    const $ = new ConfigurationTemplateAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getAlertsConfiguration();
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function updateAlertsConfiguration(data) {
    const $ = new ConfigurationTemplateAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.updateAlertsConfiguration(data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function updateAlertsConfiguration_ByNS(data) {
    const $ = new ConfigurationTemplateAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.updateAlertsConfiguration_ByNS(data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function deleteConfiguration_ByName(name2) {
    const $ = new ConfigurationTemplateAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.deleteConfiguration_ByName(name2);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getConfiguration_ByName(name2) {
    const $ = new ConfigurationTemplateAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getConfiguration_ByName(name2);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function updateConfiguration_ByName(name2, data) {
    const $ = new ConfigurationTemplateAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.updateConfiguration_ByName(name2, data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  return {
    /**
     * Get a dsmc configuration.
     */
    getDsconfigs,
    /**
     * Create template configuration to be applied across party and session. Session configuration mandatory : - name - joinability. supported values: - OPEN: user can join or rejoin the session without an invite - CLOSED: once a CLOSED session is created or a session joinability is updated to CLOSED, any change to session members is not allowed and remaining invites will all be canceled. - INVITE_ONLY: to join the session, user whether needs to be invited, or have the code (for join by code). when a user is KICKED/LEFT/REJECTED from this session, they will need to be re-invited to join. - FRIENDS_OF_MEMBERS: only if a user is friend with at least one of the session members, they can join via code. - FRIENDS_OF_LEADER: only if a user is friend with the session leader, they can join via code. - FRIENDS_OF_FRIENDS: only friends of the leader OR friends of friends of the leader can join via code. - autoJoin: when enabled, players will automatically join the initial game session creation. Game session will not send any invite and players dont need to act upon it. default: false (disabled) - Type (example value : P2P, DS, NONE) if type empty, type will be assign to NONE - MinPlayers (must greater or equal 0) - MaxPlayers (must greater than 0) - InviteTimeout (must greater or equal 0) if InviteTimeout equal 0 will be use default DefaultTimeoutSecond (60s) - InactiveTimeout (must greater or equal 0) if InactiveTimeout equal 0 will be use default DefaultTimeoutSecond (60s) - Persistent will only applies to session with type DS (example value true or false, default: false) - If Persistent True the session always active even DS removing or terminate and Session will be request DS again until DS Ready or Busy. - To Stop Session Not request again to DS or want Delete Session can Delete Session using endpoint DELETE /session/v1/public/namespaces/{namespace}/gamesessions/{sessionId} - If Persistent False the session will be inactive if all member left and DS terminate or removing - nativeSessionSetting: - XboxSessionTemplateName: the XBox session template name that correspondent to the AB session template, and is needed to define XBox session&#39;s joinRestriction and maxMembersCount when doing the session sync. - XboxServiceConfigID: the XBox service configuration ID. - PSNServiceLabel: the PSN service label. - SessionTitle: the session title. In PSN, this will be used to define name of the session thats displayed on PlayStation system UI. - ShouldSync: to define whether the service needs to do session sync with native platform(s). Default: false (disabled). - PSNSupportedPlatforms: the PSN supported platforms. In PSN, if ShouldSync true and PSNSupportedPlatforms is empty, then PS5 will be set as default value. - PSNBaseUrl this is for base URL PSN if not set will be default value https://s2s.sp-int.playstation.net. In a single namespace only 1 PSN Env that can be used. Multiple session template should refers to the same PSN Env as we have in IAM Service. - https://s2s.sp-int.playstation.net (DEV, need IP Whitelist) - https://s2s.prod-qa.playstation.net (QA Environment/PSN Certification) - https://s2s.np.playstation.net (Production) - localizedSessionName : for localized name and default language example payload : &#34;localizedSessionName&#34;:{ &#34;defaultLanguage&#34; : &#34;en-US&#34; &#34;localizedText&#34; :{ &#34;en-US&#34; : &#34;title&#34; } } - if the game client wants to enable push context to PSN, game client will need to store PSN_PUSH_CONTEXT_ID on the player attributes, otherwise Session service will try to populate from the session attributes or auto generate with random UUID if empty. - TieTeamsSessionLifetime (optional, default: false): If it is set to true, the lifetime of any partyId session inside teams attribute will be tied to the game session. Only applies when the teams partyId is game session. - DisableCodeGeneration (optional, default: false): If it is set to true, code will not be generated for party session automatically. - DSManualSetReady (optional, default: false): The DS need to call specific end point to flag the DS for game session is ready to accept client connection. - EnableSecret (optional, default: false): if configuration template is created with TypeDS and EnableSecret is True, A secret will be created - LeaderElectionGracePeriod this is on second (optional, default:0) this is only use for party session, if value &gt; 0 if leader disconnect will be wait until value reach and leader will be change after reach - ManualRejoin (optional, default: false): indicates if game client will handle manual rejoin upon websocket reconnection when enabled. - DisableResendInvite (optional, default: false): by default, the service will be sending invites until the user reacts to it. enabling this flag will prohibit the service to send reminder invites&#39;. - appName (optional, default: empty string). Extend application name that uploaded to AccelByte extends deployment. The application is for custom/external DS management. - customURLGRPC (optional: default: empty string). Url for grpc server that server custom/external DS management. This value will be ignore when appName is filled. Value formatted as host:port. Example: yourdomain.com:9989 - grpcSessionConfig (optional, default: empty object). Setting for grpc session extends. Session service will calls the grpc when any activity for the game sessions. - appName (required when customURL is empty) The extends app name that created and uploaded to AccelByte extends deployment. - customURL (required when appName is empty) The url for grpc server. Format is host:port. Example: mycustomdomain.com:9889. This will be ignore when appName is filled. - functionFlag (optional, default: -1) Flag to enable which function to calls when any event on the game sessions. The value is bitwise integer. - 0x1 is for created event. Event is sync, anything return from create event will be overide the final game session. - 0x2 is for updated event. Event is async. Called when any update on the game session. - 0x4 is for deleted event. Event is async. Callen when game session got deleted. Example: - value 3: enable for created and updated - value 7: enable for created, updated, and deleted, etc
     */
    createConfiguration,
    /**
     * Get all template configurations in specified namespace.
     */
    getConfigurations,
    /**
     * sync dsmc configuration.
     */
    getDsconfigsSync,
    /**
     * Delete configuration alert.
     */
    deleteAlertsConfiguration,
    /**
     * Get a configuration alert.
     */
    getAlertsConfiguration,
    /**
     * Create configuration alert configuration alert mandatory : - namespace - durationDays must be greater than 0
     */
    updateAlertsConfiguration,
    /**
     * Update configuration alert configuration alert mandatory : - namespace - durationDays must be greater than 0
     */
    updateAlertsConfiguration_ByNS,
    /**
     * Delete a template configuration.
     */
    deleteConfiguration_ByName,
    /**
     * Get a template configuration.
     */
    getConfiguration_ByName,
    /**
     * Modify template configuration Session configuration mandatory : - name - joinability. supported values: - OPEN: user can join or rejoin the session without an invite - CLOSED: once a CLOSED session is created or a session joinability is updated to CLOSED, any change to session members is not allowed and remaining invites will all be canceled. - INVITE_ONLY: to join the session, user whether needs to be invited, or have the code (for join by code). when a user is KICKED/LEFT/REJECTED from this session, they will need to be re-invited to join. - FRIENDS_OF_MEMBERS: only if a user is friend with at least one of the session members, they can join via code. - FRIENDS_OF_LEADER: only if a user is friend with the session leader, they can join via code. - FRIENDS_OF_FRIENDS: only friends of the leader OR friends of friends of the leader can join via code. - autoJoin: when enabled, players will automatically join the initial game session creation. Game session will not send any invite and players dont need to act upon it. default: false (disabled) - Type (example value : P2P, DS, NONE) if type empty, type will be assign to NONE - MinPlayers (must greater or equal 0) - MaxPlayers (must greater than 0) - InviteTimeout (must greater or equal 0) if InviteTimeout equal 0 will be use default DefaultTimeoutSecond (60s) - InactiveTimeout (must greater or equal 0) if InactiveTimeout equal 0 will be use default DefaultTimeoutSecond (60s) - Persistent Flag only can use with type DS (example value true or false) - If Persistent True the session always active even DS removing or terminate and Session will be request DS again until DS Ready or Busy. - To Stop Session Not request again to DS or want Delete Session can Delete Session using endpoint DELETE /session/v1/public/namespaces/{namespace}/gamesessions/{sessionId} - If Persistent False the session will be inactive if all member left and DS terminate or removing - nativeSessionSetting: - XboxSessionTemplateName: the XBox session template name that correspondent to the AB session template, and is needed to define XBox session&#39;s joinRestriction and maxMembersCount when doing the session sync. - XboxServiceConfigID: the XBox service configuration ID. - PSNServiceLabel: the PSN service label. - SessionTitle: the session title. In PSN, this will be used to define name of the session thats displayed on PlayStation system UI. - ShouldSync: to define whether the service needs to do session sync with native platform(s). Default: false (disabled). - PSNSupportedPlatforms: the PSN supported platforms. In PSN, if ShouldSync true and PSNSupportedPlatforms is empty, then PS5 will be set as default value. - PSNBaseUrl this is for base URL PSN if not set will be default value https://s2s.sp-int.playstation.net. In a single namespace only 1 PSN Env that can be used. Multiple session template should refers to the same PSN Env as we have in IAM Service. - https://s2s.sp-int.playstation.net (DEV, need IP Whitelist) - https://s2s.prod-qa.playstation.net (QA Environment/PSN Certification) - https://s2s.np.playstation.net (Production) - localizedSessionName : for localized name and default language example payload : &#34;localizedSessionName&#34;:{ &#34;defaultLanguage&#34; : &#34;en-US&#34; &#34;localizedText&#34; :{ &#34;en-US&#34; : &#34;title&#34; } } - if the game client wants to enable push context to PSN, game client will need to store PSN_PUSH_CONTEXT_ID on the player attributes, otherwise Session service will try to populate from the session attributes or auto generate with random UUID if empty. - TieTeamsSessionLifetime: If it is set to true, the lifetime of any partyId session inside teams attribute will be tied to the game session. Only applies when the teams partyId is game session. - DisableCodeGeneration (optional, default: false): If it is set to true, code will not be generated for party session automatically. - DSManualSetReady (optional, default: false): The DS need to call specific end point to flag the DS for game session is ready to accept client connection. - EnableSecret (optional, default: false): if configuration template is created with TypeDS and EnableSecret is True, A secret will be created. - ManualRejoin (optional, default: false): indicates if game client will handle manual rejoin upon websocket reconnection when enabled. - DisableResendInvite (optional, default: false): by default, the service will be sending invites until the user reacts to it. enabling this flag will prohibit the service to send reminder invites&#39;. - appName (optional, default: empty string). Extend application name that uploaded to AccelByte extends deployment. The application is for custom/external DS management. - customURLGRPC (optional: default: empty string). Url for grpc server that server custom/external DS management. This value will be ignore when appName is filled. Value formatted as host:port. Example: yourdomain.com:9989 - grpcSessionConfig (optional, default: empty object). Setting for grpc session extends. Session service will calls the grpc when any activity for the game sessions. - appName (required when customURL is empty) The extends app name that created and uploaded to AccelByte extends deployment. - customURL (required when appName is empty) The url for grpc server. Format is host:port. Example: mycustomdomain.com:9889. This will be ignore when appName is filled. - functionFlag (optional, default: -1) Flag to enable which function to calls when any event on the game sessions. The value is bitwise integer. - 0x1 is for created event. Event is sync, anything return from create event will be overide the final game session. - 0x2 is for updated event. Event is async. Called when any update on the game session. - 0x4 is for deleted event. Event is async. Callen when game session got deleted. Example: - value 3: enable for created and updated - value 7: enable for created, updated, and deleted, etc
     */
    updateConfiguration_ByName
  };
}

// src/generated-admin/DsmcDefaultConfigurationAdminApi.ts
var import_sdk8 = require("@accelbyte/sdk");

// src/generated-admin/endpoints/DsmcDefaultConfigurationAdmin$.ts
var import_sdk7 = require("@accelbyte/sdk");

// src/generated-definitions/DefaultDsmcConfig.ts
var import_zod12 = require("zod");
var DefaultDsmcConfig = import_zod12.z.object({ claim_timeout: import_zod12.z.number().int(), creation_timeout: import_zod12.z.number().int() });

// src/generated-admin/endpoints/DsmcDefaultConfigurationAdmin$.ts
var DsmcDefaultConfigurationAdmin$ = class {
  // @ts-ignore
  // prettier-ignore
  constructor(axiosInstance, namespace, useSchemaValidation = true) {
    this.axiosInstance = axiosInstance;
    this.namespace = namespace;
    this.useSchemaValidation = useSchemaValidation;
  }
  /**
   * Get dsmc default configuration.
   */
  getDsconfigsDefault() {
    const params = {};
    const url = "/session/v1/admin/dsconfigs/default";
    const resultPromise = this.axiosInstance.get(url, { params });
    return import_sdk7.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, DefaultDsmcConfig, "DefaultDsmcConfig");
  }
};

// src/generated-admin/DsmcDefaultConfigurationAdminApi.ts
function DsmcDefaultConfigurationAdminApi(sdk, args) {
  const sdkAssembly = sdk.assembly();
  const namespace = args?.coreConfig?.namespace ?? sdkAssembly.coreConfig.namespace;
  const useSchemaValidation = args?.coreConfig?.useSchemaValidation ?? sdkAssembly.coreConfig.useSchemaValidation;
  let axiosInstance = sdkAssembly.axiosInstance;
  const requestConfigOverrides = args?.axiosConfig?.request;
  const baseURLOverride = args?.coreConfig?.baseURL;
  const interceptorsOverride = args?.axiosConfig?.interceptors ?? [];
  if (requestConfigOverrides || baseURLOverride || interceptorsOverride.length > 0) {
    const requestConfig = import_sdk8.ApiUtils.mergeAxiosConfigs(sdkAssembly.axiosInstance.defaults, {
      ...baseURLOverride ? { baseURL: baseURLOverride } : {},
      ...requestConfigOverrides
    });
    axiosInstance = import_sdk8.Network.create(requestConfig);
    for (const interceptor of interceptorsOverride) {
      if (interceptor.type === "request") {
        axiosInstance.interceptors.request.use(interceptor.onRequest, interceptor.onError);
      }
      if (interceptor.type === "response") {
        axiosInstance.interceptors.response.use(interceptor.onSuccess, interceptor.onError);
      }
    }
  }
  async function getDsconfigsDefault() {
    const $ = new DsmcDefaultConfigurationAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getDsconfigsDefault();
    if (resp.error) throw resp.error;
    return resp.response;
  }
  return {
    /**
     * Get dsmc default configuration.
     */
    getDsconfigsDefault
  };
}

// src/generated-admin/endpoints/EnvironmentVariableAdmin$.ts
var import_sdk9 = require("@accelbyte/sdk");

// src/generated-definitions/EnvironmentVariableListResponse.ts
var import_zod14 = require("zod");

// src/generated-definitions/EnvironmentVariableResponse.ts
var import_zod13 = require("zod");
var EnvironmentVariableResponse = import_zod13.z.object({
  actualValue: import_zod13.z.string().nullish(),
  defaultValue: import_zod13.z.string().nullish(),
  description: import_zod13.z.string().nullish(),
  name: import_zod13.z.string()
});

// src/generated-definitions/EnvironmentVariableListResponse.ts
var EnvironmentVariableListResponse = import_zod14.z.object({ data: import_zod14.z.array(EnvironmentVariableResponse) });

// src/generated-admin/endpoints/EnvironmentVariableAdmin$.ts
var EnvironmentVariableAdmin$ = class {
  // @ts-ignore
  // prettier-ignore
  constructor(axiosInstance, namespace, useSchemaValidation = true) {
    this.axiosInstance = axiosInstance;
    this.namespace = namespace;
    this.useSchemaValidation = useSchemaValidation;
  }
  /**
   * List of environment variables.
   */
  getEnvironmentVariables() {
    const params = {};
    const url = "/session/v1/admin/environment-variables";
    const resultPromise = this.axiosInstance.get(url, { params });
    return import_sdk9.Validate.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      EnvironmentVariableListResponse,
      "EnvironmentVariableListResponse"
    );
  }
};

// src/generated-admin/endpoints/GameSessionAdmin$.ts
var import_sdk10 = require("@accelbyte/sdk");
var import_zod27 = require("zod");

// src/generated-definitions/DeleteBulkGameSessionsApiResponse.ts
var import_zod16 = require("zod");

// src/generated-definitions/ResponseDeleteBulkGameSessions.ts
var import_zod15 = require("zod");
var ResponseDeleteBulkGameSessions = import_zod15.z.object({ error: import_zod15.z.string(), id: import_zod15.z.string() });

// src/generated-definitions/DeleteBulkGameSessionsApiResponse.ts
var DeleteBulkGameSessionsApiResponse = import_zod16.z.object({
  failed: import_zod16.z.array(ResponseDeleteBulkGameSessions).nullish(),
  success: import_zod16.z.array(import_zod16.z.string()).nullish()
});

// src/generated-definitions/GameSessionQueryResponse.ts
var import_zod25 = require("zod");

// src/generated-definitions/GameSessionResponse.ts
var import_zod24 = require("zod");

// src/generated-definitions/DsInformationResponse.ts
var import_zod19 = require("zod");

// src/generated-definitions/GameServer.ts
var import_zod18 = require("zod");

// src/generated-definitions/PortConfigurationAms.ts
var import_zod17 = require("zod");
var PortConfigurationAms = import_zod17.z.object({ name: import_zod17.z.string(), protocol: import_zod17.z.string() });

// src/generated-definitions/GameServer.ts
var GameServer = import_zod18.z.object({
  alternate_ips: import_zod18.z.array(import_zod18.z.string()).nullish(),
  ams_protocol: import_zod18.z.array(PortConfigurationAms).nullish(),
  custom_attribute: import_zod18.z.string(),
  deployment: import_zod18.z.string().nullish(),
  extend_region: import_zod18.z.string().nullish(),
  game_version: import_zod18.z.string().nullish(),
  image_version: import_zod18.z.string().nullish(),
  ip: import_zod18.z.string().nullish(),
  is_override_game_version: import_zod18.z.boolean(),
  last_update: import_zod18.z.string(),
  namespace: import_zod18.z.string(),
  pod_name: import_zod18.z.string().nullish(),
  port: import_zod18.z.number().int().nullish(),
  ports: import_zod18.z.record(import_zod18.z.number().int()).nullish(),
  protocol: import_zod18.z.string().nullish(),
  provider: import_zod18.z.string().nullish(),
  region: import_zod18.z.string(),
  session_id: import_zod18.z.string(),
  source: import_zod18.z.string(),
  status: import_zod18.z.string()
});

// src/generated-definitions/DsInformationResponse.ts
var DsInformationResponse = import_zod19.z.object({
  CreatedAt: import_zod19.z.string(),
  RequestedAt: import_zod19.z.string(),
  Server: GameServer.nullish(),
  Status: import_zod19.z.string().nullish(),
  StatusV2: import_zod19.z.string().nullish()
});

// src/generated-definitions/PublicConfiguration.ts
var import_zod20 = require("zod");
var PublicConfiguration = import_zod20.z.object({
  PSNBaseURL: import_zod20.z.string().nullish(),
  appName: import_zod20.z.string().nullish(),
  attributes: import_zod20.z.record(import_zod20.z.any()).nullish(),
  autoJoin: import_zod20.z.boolean(),
  clientVersion: import_zod20.z.string(),
  customURLGRPC: import_zod20.z.string().nullish(),
  deployment: import_zod20.z.string(),
  disableCodeGeneration: import_zod20.z.boolean().nullish(),
  disableResendInvite: import_zod20.z.boolean().nullish(),
  dsManualSetReady: import_zod20.z.boolean().nullish(),
  dsSource: import_zod20.z.string().nullish(),
  enableSecret: import_zod20.z.boolean().nullish(),
  fallbackClaimKeys: import_zod20.z.array(import_zod20.z.string()).nullish(),
  grpcSessionConfig: ExtendConfiguration.nullish(),
  immutableStorage: import_zod20.z.boolean().nullish(),
  inactiveTimeout: import_zod20.z.number().int(),
  inviteTimeout: import_zod20.z.number().int(),
  joinability: import_zod20.z.string(),
  leaderElectionGracePeriod: import_zod20.z.number().int().nullish(),
  manualRejoin: import_zod20.z.boolean().nullish(),
  maxActiveSession: import_zod20.z.number().int().nullish(),
  maxPlayers: import_zod20.z.number().int(),
  minPlayers: import_zod20.z.number().int(),
  name: import_zod20.z.string(),
  nativeSessionSetting: NativeSessionSetting.nullish(),
  persistent: import_zod20.z.boolean(),
  preferredClaimKeys: import_zod20.z.array(import_zod20.z.string()).nullish(),
  requestedRegions: import_zod20.z.array(import_zod20.z.string()).nullish(),
  textChat: import_zod20.z.boolean(),
  tieTeamsSessionLifetime: import_zod20.z.boolean().nullish(),
  type: import_zod20.z.string()
});

// src/generated-definitions/Team.ts
var import_zod22 = require("zod");

// src/generated-definitions/PartyMembers.ts
var import_zod21 = require("zod");
var PartyMembers = import_zod21.z.object({ partyID: import_zod21.z.string().nullish(), userIDs: import_zod21.z.array(import_zod21.z.string()).nullish() });

// src/generated-definitions/Team.ts
var Team = import_zod22.z.object({ parties: import_zod22.z.array(PartyMembers).nullish(), userIDs: import_zod22.z.array(import_zod22.z.string()).nullish() });

// src/generated-definitions/UserResponse.ts
var import_zod23 = require("zod");
var UserResponse = import_zod23.z.object({
  id: import_zod23.z.string(),
  platformID: import_zod23.z.string(),
  platformUserID: import_zod23.z.string(),
  previousStatus: import_zod23.z.string().nullish(),
  status: import_zod23.z.string(),
  statusV2: import_zod23.z.string(),
  updatedAt: import_zod23.z.string()
});

// src/generated-definitions/GameSessionResponse.ts
var GameSessionResponse = import_zod24.z.object({
  DSInformation: DsInformationResponse,
  attributes: import_zod24.z.record(import_zod24.z.any()).nullish(),
  backfillTicketID: import_zod24.z.string(),
  code: import_zod24.z.string().nullish(),
  configuration: PublicConfiguration,
  createdAt: import_zod24.z.string(),
  createdBy: import_zod24.z.string(),
  expiredAt: import_zod24.z.string().nullish(),
  id: import_zod24.z.string(),
  isActive: import_zod24.z.boolean(),
  isFull: import_zod24.z.boolean(),
  leaderID: import_zod24.z.string(),
  matchPool: import_zod24.z.string(),
  members: import_zod24.z.array(UserResponse),
  namespace: import_zod24.z.string(),
  storage: import_zod24.z.record(import_zod24.z.any()).nullish(),
  teams: import_zod24.z.array(Team).nullish(),
  ticketIDs: import_zod24.z.array(import_zod24.z.string()).nullish(),
  updatedAt: import_zod24.z.string(),
  version: import_zod24.z.number().int()
});

// src/generated-definitions/GameSessionQueryResponse.ts
var GameSessionQueryResponse = import_zod25.z.object({ data: import_zod25.z.array(GameSessionResponse), paging: Pagination });

// src/generated-definitions/UpdateGameSessionMemberStatusResponse.ts
var import_zod26 = require("zod");
var UpdateGameSessionMemberStatusResponse = import_zod26.z.object({ status: import_zod26.z.string(), statusV2: import_zod26.z.string() });

// src/generated-admin/endpoints/GameSessionAdmin$.ts
var GameSessionAdmin$ = class {
  // @ts-ignore
  // prettier-ignore
  constructor(axiosInstance, namespace, useSchemaValidation = true) {
    this.axiosInstance = axiosInstance;
    this.namespace = namespace;
    this.useSchemaValidation = useSchemaValidation;
  }
  /**
   * Get all game sessions.
   */
  getGamesessions(queryParams) {
    const params = { limit: 20, ...queryParams };
    const url = "/session/v1/admin/namespaces/{namespace}/gamesessions".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.get(url, { params });
    return import_sdk10.Validate.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      GameSessionQueryResponse,
      "GameSessionQueryResponse"
    );
  }
  /**
   * Query game sessions by admin. By default, API will return a list of available game sessions (joinability: open). Session service has several DSInformation status to track DS request to DS providers: - NEED_TO_REQUEST: number of active players hasn&#39;t reached session&#39;s minPlayers therefore DS has not yet requested. - REQUESTED: DS is being requested to DSMC. - PREPARING: DS needs to call manual set ready for the game session - AVAILABLE: DS is ready to use. The DSMC status for this DS is either READY/BUSY. - FAILED_TO_REQUEST: DSMC fails to spin up a DS for session. - DS_ERROR: DS provider fails to spin up the DS or the DS itself becomes unreachable - DS_CANCELLED: when DSMC is preparing the DS, DSMC will give a temporary DS. In this phase, if you delete the game session, the DS request will be canceled. - ENDED: when a game session (match) has finished and DS has done its job, it will terminate itself. - UNKNOWN: if any unknown DS status is detected. DSInformation has 2 fields for DS status: &#34;status&#34; and &#34;statusV2&#34;. The &#34;status&#34; is there for backward-compatibility, therefore we encourage to just rely on &#34;statusV2&#34; for the more updated statuses. DS Source can be DSMC, AMS or custom. In DSMC, a DS request will be put in queue if they dont have available buffers, and DSMC will let the service knows when they finished spinning it up. While AMS doesn&#39;t have a concept of queue. Therefore some &#34;DSInformation.statusV2&#34; only applicable for DSMC. query parameter \&#34;availability\&#34; to filter sessions&#39; availability: all: return all sessions regardless it&#39;s full full: only return active sessions default behavior (unset or else): return only available sessions (not full)
   */
  fetchGamesession() {
    const params = {};
    const url = "/session/v1/admin/namespaces/{namespace}/gamesessions".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.post(url, null, { params });
    return import_sdk10.Validate.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      GameSessionQueryResponse,
      "GameSessionQueryResponse"
    );
  }
  /**
   * Delete bulk game sessions.
   */
  deleteGamesessionBulk(data) {
    const params = {};
    const url = "/session/v1/admin/namespaces/{namespace}/gamesessions/bulk".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.delete(url, { data, params });
    return import_sdk10.Validate.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      DeleteBulkGameSessionsApiResponse,
      "DeleteBulkGameSessionsApiResponse"
    );
  }
  /**
   * When the session template has ds_manual_set_ready as true. Then the DS need to calls this end point in order to notify game client if the DS is ready to accept any game client connection.
   */
  updateD_BySessionId(sessionId, data) {
    const params = {};
    const url = "/session/v1/admin/namespaces/{namespace}/gamesessions/{sessionId}/ds".replace("{namespace}", this.namespace).replace("{sessionId}", sessionId);
    const resultPromise = this.axiosInstance.put(url, data, { params });
    return import_sdk10.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, import_zod27.z.unknown(), "z.unknown()");
  }
  /**
   * Kick member from a game session.
   */
  deleteKick_BySessionId_ByMemberId(sessionId, memberId) {
    const params = {};
    const url = "/session/v1/admin/namespaces/{namespace}/gamesessions/{sessionId}/members/{memberId}/kick".replace("{namespace}", this.namespace).replace("{sessionId}", sessionId).replace("{memberId}", memberId);
    const resultPromise = this.axiosInstance.delete(url, { params });
    return import_sdk10.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, import_zod27.z.unknown(), "z.unknown()");
  }
  /**
   * Update a game session member status.
   */
  updateStatu_BySessionId_ByMemberId_ByStatusType(sessionId, memberId, statusType) {
    const params = {};
    const url = "/session/v1/admin/namespaces/{namespace}/gamesessions/{sessionId}/members/{memberId}/status/{statusType}".replace("{namespace}", this.namespace).replace("{sessionId}", sessionId).replace("{memberId}", memberId).replace("{statusType}", statusType);
    const resultPromise = this.axiosInstance.put(url, null, { params });
    return import_sdk10.Validate.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      UpdateGameSessionMemberStatusResponse,
      "UpdateGameSessionMemberStatusResponse"
    );
  }
};

// src/generated-admin/endpoints/GlobalConfigurationAdmin$.ts
var import_sdk11 = require("@accelbyte/sdk");
var import_zod29 = require("zod");

// src/generated-definitions/GlobalConfigurationResponse.ts
var import_zod28 = require("zod");
var GlobalConfigurationResponse = import_zod28.z.object({
  metricExcludedNamespaces: import_zod28.z.array(import_zod28.z.string()).nullish(),
  regionRetryMapping: import_zod28.z.record(import_zod28.z.array(import_zod28.z.string())),
  regionURLMapping: import_zod28.z.array(import_zod28.z.string()),
  testGameMode: import_zod28.z.string(),
  testRegionURLMapping: import_zod28.z.array(import_zod28.z.string()),
  testTargetUserIDs: import_zod28.z.array(import_zod28.z.string()),
  updatedAt: import_zod28.z.string()
});

// src/generated-admin/endpoints/GlobalConfigurationAdmin$.ts
var GlobalConfigurationAdmin$ = class {
  // @ts-ignore
  // prettier-ignore
  constructor(axiosInstance, namespace, useSchemaValidation = true) {
    this.axiosInstance = axiosInstance;
    this.namespace = namespace;
    this.useSchemaValidation = useSchemaValidation;
  }
  /**
   * Delete of global configuration data.
   */
  deleteGlobalConfiguration() {
    const params = {};
    const url = "/session/v1/admin/global-configurations";
    const resultPromise = this.axiosInstance.delete(url, { params });
    return import_sdk11.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, import_zod29.z.unknown(), "z.unknown()");
  }
  /**
   * Record of global configuration data.
   */
  getGlobalConfigurations() {
    const params = {};
    const url = "/session/v1/admin/global-configurations";
    const resultPromise = this.axiosInstance.get(url, { params });
    return import_sdk11.Validate.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      GlobalConfigurationResponse,
      "GlobalConfigurationResponse"
    );
  }
  /**
   * Upsert global configuration data.
   */
  updateGlobalConfiguration(data) {
    const params = {};
    const url = "/session/v1/admin/global-configurations";
    const resultPromise = this.axiosInstance.put(url, data, { params });
    return import_sdk11.Validate.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      GlobalConfigurationResponse,
      "GlobalConfigurationResponse"
    );
  }
};

// src/generated-admin/endpoints/MaxActiveAdmin$.ts
var import_sdk12 = require("@accelbyte/sdk");
var import_zod31 = require("zod");

// src/generated-definitions/MemberActiveSession.ts
var import_zod30 = require("zod");
var MemberActiveSession = import_zod30.z.object({
  CreatedAt: import_zod30.z.string(),
  ID: import_zod30.z.string(),
  MemberID: import_zod30.z.string(),
  Namespace: import_zod30.z.string(),
  SessionIDs: import_zod30.z.array(import_zod30.z.string()),
  SessionTemplate: import_zod30.z.string(),
  Total: import_zod30.z.number().int(),
  UpdatedAt: import_zod30.z.string()
});

// src/generated-admin/endpoints/MaxActiveAdmin$.ts
var MaxActiveAdmin$ = class {
  // @ts-ignore
  // prettier-ignore
  constructor(axiosInstance, namespace, useSchemaValidation = true) {
    this.axiosInstance = axiosInstance;
    this.namespace = namespace;
    this.useSchemaValidation = useSchemaValidation;
  }
  /**
   *  Reconcile Max Active Session.
   */
  updateReconcile_ByName(name2, data) {
    const params = {};
    const url = "/session/v1/admin/namespaces/{namespace}/configurations/{name}/reconcile".replace("{namespace}", this.namespace).replace("{name}", name2);
    const resultPromise = this.axiosInstance.post(url, data, { params });
    return import_sdk12.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, import_zod31.z.unknown(), "z.unknown()");
  }
  /**
   *  Get Member Active Session.
   */
  getMemberactivesession_ByName_ByUserId(name2, userId) {
    const params = {};
    const url = "/session/v1/admin/namespaces/{namespace}/configurations/{name}/memberactivesession/{userId}".replace("{namespace}", this.namespace).replace("{name}", name2).replace("{userId}", userId);
    const resultPromise = this.axiosInstance.get(url, { params });
    return import_sdk12.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, MemberActiveSession, "MemberActiveSession");
  }
};

// src/generated-admin/endpoints/NativeSessionAdmin$.ts
var import_sdk13 = require("@accelbyte/sdk");

// src/generated-definitions/NativeSessionPagingResponse.ts
var import_zod34 = require("zod");

// src/generated-definitions/NativeSession.ts
var import_zod33 = require("zod");

// src/generated-definitions/NativeSessionMember.ts
var import_zod32 = require("zod");
var NativeSessionMember = import_zod32.z.object({ platformID: import_zod32.z.string(), platformUserID: import_zod32.z.string(), userID: import_zod32.z.string() });

// src/generated-definitions/NativeSession.ts
var NativeSession = import_zod33.z.object({
  CreatedAt: import_zod33.z.string(),
  DeletedAt: import_zod33.z.string(),
  PushContextID: import_zod33.z.string(),
  id: import_zod33.z.string(),
  members: import_zod33.z.array(NativeSessionMember),
  namespace: import_zod33.z.string(),
  nativeSessionPlatforms: import_zod33.z.record(import_zod33.z.string()),
  persistent: import_zod33.z.boolean()
});

// src/generated-definitions/NativeSessionPagingResponse.ts
var NativeSessionPagingResponse = import_zod34.z.object({ data: import_zod34.z.array(NativeSession), paging: Pagination });

// src/generated-admin/endpoints/NativeSessionAdmin$.ts
var NativeSessionAdmin$ = class {
  // @ts-ignore
  // prettier-ignore
  constructor(axiosInstance, namespace, useSchemaValidation = true) {
    this.axiosInstance = axiosInstance;
    this.namespace = namespace;
    this.useSchemaValidation = useSchemaValidation;
  }
  /**
   * List of native sessions.
   */
  getNativeSessions(queryParams) {
    const params = { limit: 20, ...queryParams };
    const url = "/session/v1/admin/namespaces/{namespace}/native-sessions".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.get(url, { params });
    return import_sdk13.Validate.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      NativeSessionPagingResponse,
      "NativeSessionPagingResponse"
    );
  }
};

// src/generated-admin/endpoints/PartyAdmin$.ts
var import_sdk14 = require("@accelbyte/sdk");
var import_zod37 = require("zod");

// src/generated-definitions/PartyQueryResponse.ts
var import_zod36 = require("zod");

// src/generated-definitions/PartySessionResponse.ts
var import_zod35 = require("zod");
var PartySessionResponse = import_zod35.z.object({
  attributes: import_zod35.z.record(import_zod35.z.any()).nullish(),
  code: import_zod35.z.string().nullish(),
  configuration: PublicConfiguration,
  createdAt: import_zod35.z.string(),
  createdBy: import_zod35.z.string(),
  expiredAt: import_zod35.z.string().nullish(),
  id: import_zod35.z.string(),
  isActive: import_zod35.z.boolean(),
  isFull: import_zod35.z.boolean(),
  leaderID: import_zod35.z.string(),
  members: import_zod35.z.array(UserResponse),
  namespace: import_zod35.z.string(),
  storage: import_zod35.z.record(import_zod35.z.any()).nullish(),
  updatedAt: import_zod35.z.string(),
  version: import_zod35.z.number().int()
});

// src/generated-definitions/PartyQueryResponse.ts
var PartyQueryResponse = import_zod36.z.object({ data: import_zod36.z.array(PartySessionResponse), paging: Pagination });

// src/generated-admin/endpoints/PartyAdmin$.ts
var PartyAdmin$ = class {
  // @ts-ignore
  // prettier-ignore
  constructor(axiosInstance, namespace, useSchemaValidation = true) {
    this.axiosInstance = axiosInstance;
    this.namespace = namespace;
    this.useSchemaValidation = useSchemaValidation;
  }
  /**
   * Query parties.
   */
  getParties(queryParams) {
    const params = { limit: 20, ...queryParams };
    const url = "/session/v1/admin/namespaces/{namespace}/parties".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.get(url, { params });
    return import_sdk14.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, PartyQueryResponse, "PartyQueryResponse");
  }
  /**
   * Trigger user&#39;s active party session to native platform.
   */
  createNativeSync_ByUserId(userId) {
    const params = {};
    const url = "/session/v1/admin/namespaces/{namespace}/users/{userId}/native-sync".replace("{namespace}", this.namespace).replace("{userId}", userId);
    const resultPromise = this.axiosInstance.post(url, null, { params });
    return import_sdk14.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, import_zod37.z.unknown(), "z.unknown()");
  }
};

// src/generated-admin/endpoints/PlatformCredentialAdmin$.ts
var import_sdk15 = require("@accelbyte/sdk");
var import_zod38 = require("zod");
var PlatformCredentialAdmin$ = class {
  // @ts-ignore
  // prettier-ignore
  constructor(axiosInstance, namespace, useSchemaValidation = true) {
    this.axiosInstance = axiosInstance;
    this.namespace = namespace;
    this.useSchemaValidation = useSchemaValidation;
  }
  /**
   * Delete platform credentials used for Native Session sync.
   */
  deletePlatformCredential() {
    const params = {};
    const url = "/session/v1/admin/namespaces/{namespace}/platform-credentials".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.delete(url, { params });
    return import_sdk15.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, import_zod38.z.unknown(), "z.unknown()");
  }
  /**
   * Get platform credentials used for Native Session sync. PSN: - clientID: Auth Server (Client Credential) ClientID - clientSecret: Auth Server (Client Credential) Secret. For security, only the first few characters are shown. - scope: should be psn:s2s.service (For Sync non PSN member to PSN Session)
   */
  getPlatformCredentials() {
    const params = {};
    const url = "/session/v1/admin/namespaces/{namespace}/platform-credentials".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.get(url, { params });
    return import_sdk15.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, PlatformCredentials, "PlatformCredentials");
  }
  /**
   * Update platform credentials for Native Session sync. Currently supports PSN platform. Send an empty body to clear data. PSN: - clientID: Auth Server (Client Credential) ClientID - clientSecret: Auth Server (Client Credential) Secret - scope: psn:s2s.service (For Sync non PSN member to PSN Session)
   */
  updatePlatformCredential(data) {
    const params = {};
    const url = "/session/v1/admin/namespaces/{namespace}/platform-credentials".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.put(url, data, { params });
    return import_sdk15.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, PlatformCredentials, "PlatformCredentials");
  }
};

// src/generated-admin/endpoints/PlayerAdmin$.ts
var import_sdk16 = require("@accelbyte/sdk");

// src/generated-definitions/PlayerAttributesResponseBody.ts
var import_zod40 = require("zod");

// src/generated-definitions/UserPlatformInfo.ts
var import_zod39 = require("zod");
var UserPlatformInfo = import_zod39.z.object({ name: import_zod39.z.string(), userID: import_zod39.z.string() });

// src/generated-definitions/PlayerAttributesResponseBody.ts
var PlayerAttributesResponseBody = import_zod40.z.object({
  crossplayEnabled: import_zod40.z.boolean(),
  currentPlatform: import_zod40.z.string(),
  data: import_zod40.z.record(import_zod40.z.any()),
  platforms: import_zod40.z.array(UserPlatformInfo),
  roles: import_zod40.z.array(import_zod40.z.string()),
  userID: import_zod40.z.string()
});

// src/generated-definitions/PlayerAttributesResponseBodyArray.ts
var import_zod41 = require("zod");
var PlayerAttributesResponseBodyArray = import_zod41.z.array(PlayerAttributesResponseBody);

// src/generated-admin/endpoints/PlayerAdmin$.ts
var PlayerAdmin$ = class {
  // @ts-ignore
  // prettier-ignore
  constructor(axiosInstance, namespace, useSchemaValidation = true) {
    this.axiosInstance = axiosInstance;
    this.namespace = namespace;
    this.useSchemaValidation = useSchemaValidation;
  }
  /**
   * Admin get attributes of players. Field descriptions: - userID : user who owns the attributes. - crossplayEnabled : set to true if the player wants to enable crossplay to their session (default: false). - platforms : list of the player&#39;s 3rd party platform account information. - name : platform name. supported platforms: STEAM, XBOX, PSN - userID : platform userID - data : other data that the player wants to store. - PSN_PUSH_CONTEXT_ID: if provided, session will refer to this when performing session sync with PSN, otherwise will populate from session attributes, otherwise will populate from session attributes - currentPlatform : latest user game platform. - roles : user role for matchmaking role base support.
   */
  getUsersAttributes(queryParams) {
    const params = { ...queryParams };
    const url = "/session/v1/admin/namespaces/{namespace}/users/attributes".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.get(url, { params });
    return import_sdk16.Validate.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      PlayerAttributesResponseBodyArray,
      "PlayerAttributesResponseBodyArray"
    );
  }
  /**
   * Admin get attributes of a player. Field descriptions: - userID : user who owns the attributes. - crossplayEnabled : set to true if the player wants to enable crossplay to their session (default: false). - platforms : list of the player&#39;s 3rd party platform account information. - name : platform name. supported platforms: STEAM, XBOX, PSN - userID : platform userID - data : other data that the player wants to store. - PSN_PUSH_CONTEXT_ID: if provided, session will refer to this when performing session sync with PSN, otherwise will populate from session attributes - currentPlatform : latest user game platform. - roles : user role for matchmaking role base support.
   */
  getAttributes_ByUserId(userId) {
    const params = {};
    const url = "/session/v1/admin/namespaces/{namespace}/users/{userId}/attributes".replace("{namespace}", this.namespace).replace("{userId}", userId);
    const resultPromise = this.axiosInstance.get(url, { params });
    return import_sdk16.Validate.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      PlayerAttributesResponseBody,
      "PlayerAttributesResponseBody"
    );
  }
};

// src/generated-admin/endpoints/RecentPlayerAdmin$.ts
var import_sdk17 = require("@accelbyte/sdk");

// src/generated-definitions/RecentPlayerQueryResponse.ts
var import_zod43 = require("zod");

// src/generated-definitions/UserInfoResponse.ts
var import_zod42 = require("zod");
var UserInfoResponse = import_zod42.z.object({
  lastPlayedTime: import_zod42.z.string().nullish(),
  matchPool: import_zod42.z.string().nullish(),
  namespace: import_zod42.z.string().nullish(),
  platformName: import_zod42.z.string().nullish(),
  sessionTemplate: import_zod42.z.string().nullish(),
  userID: import_zod42.z.string().nullish()
});

// src/generated-definitions/RecentPlayerQueryResponse.ts
var RecentPlayerQueryResponse = import_zod43.z.object({ data: import_zod43.z.array(UserInfoResponse) });

// src/generated-admin/endpoints/RecentPlayerAdmin$.ts
var RecentPlayerAdmin$ = class {
  // @ts-ignore
  // prettier-ignore
  constructor(axiosInstance, namespace, useSchemaValidation = true) {
    this.axiosInstance = axiosInstance;
    this.namespace = namespace;
    this.useSchemaValidation = useSchemaValidation;
  }
  /**
   * Query recent player with given user id. If user id parameter is empty: 1. Using User Token : It will get the user id from the token 2. Using client token : it will throw an error Please ensure environment variable &#34;RECENT_PLAYER_ENABLED&#34; is set to &#34;TRUE&#34; to use this feature.
   */
  getRecentPlayer(queryParams) {
    const params = { limit: 20, ...queryParams };
    const url = "/session/v1/admin/namespaces/{namespace}/recent-player".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.get(url, { params });
    return import_sdk17.Validate.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      RecentPlayerQueryResponse,
      "RecentPlayerQueryResponse"
    );
  }
  /**
   * Query recent player who were on the same team with given user id. If user id parameter is empty: 1. Using User Token : It will get the user id from the token 2. Using client token : it will throw an error Please ensure environment variable &#34;RECENT_TEAM_PLAYER_ENABLED&#34; is set to &#34;TRUE&#34; to use this feature.
   */
  getRecentTeamPlayer(queryParams) {
    const params = { limit: 20, ...queryParams };
    const url = "/session/v1/admin/namespaces/{namespace}/recent-team-player".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.get(url, { params });
    return import_sdk17.Validate.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      RecentPlayerQueryResponse,
      "RecentPlayerQueryResponse"
    );
  }
};

// src/generated-admin/endpoints/SessionStorageAdmin$.ts
var import_sdk18 = require("@accelbyte/sdk");
var import_zod44 = require("zod");
var SessionStorageAdmin$ = class {
  // @ts-ignore
  // prettier-ignore
  constructor(axiosInstance, namespace, useSchemaValidation = true) {
    this.axiosInstance = axiosInstance;
    this.namespace = namespace;
    this.useSchemaValidation = useSchemaValidation;
  }
  /**
   *  Delete Session Storage By sessionID Session Storage feature only available for Gamesession
   */
  deleteStorage_BySessionId(sessionId) {
    const params = {};
    const url = "/session/v1/admin/namespaces/{namespace}/sessions/{sessionId}/storage".replace("{namespace}", this.namespace).replace("{sessionId}", sessionId);
    const resultPromise = this.axiosInstance.delete(url, { params });
    return import_sdk18.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, import_zod44.z.unknown(), "z.unknown()");
  }
  /**
   *  Read Session Storage by sessionID Session Storage feature only available for Gamesession
   */
  getStorage_BySessionId(sessionId) {
    const params = {};
    const url = "/session/v1/admin/namespaces/{namespace}/sessions/{sessionId}/storage".replace("{namespace}", this.namespace).replace("{sessionId}", sessionId);
    const resultPromise = this.axiosInstance.get(url, { params });
    return import_sdk18.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, import_zod44.z.unknown(), "z.unknown()");
  }
  /**
   *  Read Session Storage by sessionID and userID Session Storage feature only available for Gamesession
   */
  getStorageUser_BySessionId_ByUserId(sessionId, userId) {
    const params = {};
    const url = "/session/v1/admin/namespaces/{namespace}/sessions/{sessionId}/storage/users/{userId}".replace("{namespace}", this.namespace).replace("{sessionId}", sessionId).replace("{userId}", userId);
    const resultPromise = this.axiosInstance.get(url, { params });
    return import_sdk18.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, import_zod44.z.unknown(), "z.unknown()");
  }
};

// src/generated-admin/EnvironmentVariableAdminApi.ts
var import_sdk19 = require("@accelbyte/sdk");
function EnvironmentVariableAdminApi(sdk, args) {
  const sdkAssembly = sdk.assembly();
  const namespace = args?.coreConfig?.namespace ?? sdkAssembly.coreConfig.namespace;
  const useSchemaValidation = args?.coreConfig?.useSchemaValidation ?? sdkAssembly.coreConfig.useSchemaValidation;
  let axiosInstance = sdkAssembly.axiosInstance;
  const requestConfigOverrides = args?.axiosConfig?.request;
  const baseURLOverride = args?.coreConfig?.baseURL;
  const interceptorsOverride = args?.axiosConfig?.interceptors ?? [];
  if (requestConfigOverrides || baseURLOverride || interceptorsOverride.length > 0) {
    const requestConfig = import_sdk19.ApiUtils.mergeAxiosConfigs(sdkAssembly.axiosInstance.defaults, {
      ...baseURLOverride ? { baseURL: baseURLOverride } : {},
      ...requestConfigOverrides
    });
    axiosInstance = import_sdk19.Network.create(requestConfig);
    for (const interceptor of interceptorsOverride) {
      if (interceptor.type === "request") {
        axiosInstance.interceptors.request.use(interceptor.onRequest, interceptor.onError);
      }
      if (interceptor.type === "response") {
        axiosInstance.interceptors.response.use(interceptor.onSuccess, interceptor.onError);
      }
    }
  }
  async function getEnvironmentVariables() {
    const $ = new EnvironmentVariableAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getEnvironmentVariables();
    if (resp.error) throw resp.error;
    return resp.response;
  }
  return {
    /**
     * List of environment variables.
     */
    getEnvironmentVariables
  };
}

// src/generated-admin/GameSessionAdminApi.ts
var import_sdk20 = require("@accelbyte/sdk");
function GameSessionAdminApi(sdk, args) {
  const sdkAssembly = sdk.assembly();
  const namespace = args?.coreConfig?.namespace ?? sdkAssembly.coreConfig.namespace;
  const useSchemaValidation = args?.coreConfig?.useSchemaValidation ?? sdkAssembly.coreConfig.useSchemaValidation;
  let axiosInstance = sdkAssembly.axiosInstance;
  const requestConfigOverrides = args?.axiosConfig?.request;
  const baseURLOverride = args?.coreConfig?.baseURL;
  const interceptorsOverride = args?.axiosConfig?.interceptors ?? [];
  if (requestConfigOverrides || baseURLOverride || interceptorsOverride.length > 0) {
    const requestConfig = import_sdk20.ApiUtils.mergeAxiosConfigs(sdkAssembly.axiosInstance.defaults, {
      ...baseURLOverride ? { baseURL: baseURLOverride } : {},
      ...requestConfigOverrides
    });
    axiosInstance = import_sdk20.Network.create(requestConfig);
    for (const interceptor of interceptorsOverride) {
      if (interceptor.type === "request") {
        axiosInstance.interceptors.request.use(interceptor.onRequest, interceptor.onError);
      }
      if (interceptor.type === "response") {
        axiosInstance.interceptors.response.use(interceptor.onSuccess, interceptor.onError);
      }
    }
  }
  async function getGamesessions(queryParams) {
    const $ = new GameSessionAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getGamesessions(queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function fetchGamesession() {
    const $ = new GameSessionAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.fetchGamesession();
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function deleteGamesessionBulk(data) {
    const $ = new GameSessionAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.deleteGamesessionBulk(data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function updateD_BySessionId(sessionId, data) {
    const $ = new GameSessionAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.updateD_BySessionId(sessionId, data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function deleteKick_BySessionId_ByMemberId(sessionId, memberId) {
    const $ = new GameSessionAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.deleteKick_BySessionId_ByMemberId(sessionId, memberId);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function updateStatu_BySessionId_ByMemberId_ByStatusType(sessionId, memberId, statusType) {
    const $ = new GameSessionAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.updateStatu_BySessionId_ByMemberId_ByStatusType(sessionId, memberId, statusType);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  return {
    /**
     * Get all game sessions.
     */
    getGamesessions,
    /**
     * Query game sessions by admin. By default, API will return a list of available game sessions (joinability: open). Session service has several DSInformation status to track DS request to DS providers: - NEED_TO_REQUEST: number of active players hasn&#39;t reached session&#39;s minPlayers therefore DS has not yet requested. - REQUESTED: DS is being requested to DSMC. - PREPARING: DS needs to call manual set ready for the game session - AVAILABLE: DS is ready to use. The DSMC status for this DS is either READY/BUSY. - FAILED_TO_REQUEST: DSMC fails to spin up a DS for session. - DS_ERROR: DS provider fails to spin up the DS or the DS itself becomes unreachable - DS_CANCELLED: when DSMC is preparing the DS, DSMC will give a temporary DS. In this phase, if you delete the game session, the DS request will be canceled. - ENDED: when a game session (match) has finished and DS has done its job, it will terminate itself. - UNKNOWN: if any unknown DS status is detected. DSInformation has 2 fields for DS status: &#34;status&#34; and &#34;statusV2&#34;. The &#34;status&#34; is there for backward-compatibility, therefore we encourage to just rely on &#34;statusV2&#34; for the more updated statuses. DS Source can be DSMC, AMS or custom. In DSMC, a DS request will be put in queue if they dont have available buffers, and DSMC will let the service knows when they finished spinning it up. While AMS doesn&#39;t have a concept of queue. Therefore some &#34;DSInformation.statusV2&#34; only applicable for DSMC. query parameter \&#34;availability\&#34; to filter sessions&#39; availability: all: return all sessions regardless it&#39;s full full: only return active sessions default behavior (unset or else): return only available sessions (not full)
     */
    fetchGamesession,
    /**
     * Delete bulk game sessions.
     */
    deleteGamesessionBulk,
    /**
     * When the session template has ds_manual_set_ready as true. Then the DS need to calls this end point in order to notify game client if the DS is ready to accept any game client connection.
     */
    updateD_BySessionId,
    /**
     * Kick member from a game session.
     */
    deleteKick_BySessionId_ByMemberId,
    /**
     * Update a game session member status.
     */
    updateStatu_BySessionId_ByMemberId_ByStatusType
  };
}

// src/generated-admin/GlobalConfigurationAdminApi.ts
var import_sdk21 = require("@accelbyte/sdk");
function GlobalConfigurationAdminApi(sdk, args) {
  const sdkAssembly = sdk.assembly();
  const namespace = args?.coreConfig?.namespace ?? sdkAssembly.coreConfig.namespace;
  const useSchemaValidation = args?.coreConfig?.useSchemaValidation ?? sdkAssembly.coreConfig.useSchemaValidation;
  let axiosInstance = sdkAssembly.axiosInstance;
  const requestConfigOverrides = args?.axiosConfig?.request;
  const baseURLOverride = args?.coreConfig?.baseURL;
  const interceptorsOverride = args?.axiosConfig?.interceptors ?? [];
  if (requestConfigOverrides || baseURLOverride || interceptorsOverride.length > 0) {
    const requestConfig = import_sdk21.ApiUtils.mergeAxiosConfigs(sdkAssembly.axiosInstance.defaults, {
      ...baseURLOverride ? { baseURL: baseURLOverride } : {},
      ...requestConfigOverrides
    });
    axiosInstance = import_sdk21.Network.create(requestConfig);
    for (const interceptor of interceptorsOverride) {
      if (interceptor.type === "request") {
        axiosInstance.interceptors.request.use(interceptor.onRequest, interceptor.onError);
      }
      if (interceptor.type === "response") {
        axiosInstance.interceptors.response.use(interceptor.onSuccess, interceptor.onError);
      }
    }
  }
  async function deleteGlobalConfiguration() {
    const $ = new GlobalConfigurationAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.deleteGlobalConfiguration();
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getGlobalConfigurations() {
    const $ = new GlobalConfigurationAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getGlobalConfigurations();
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function updateGlobalConfiguration(data) {
    const $ = new GlobalConfigurationAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.updateGlobalConfiguration(data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  return {
    /**
     * Delete of global configuration data.
     */
    deleteGlobalConfiguration,
    /**
     * Record of global configuration data.
     */
    getGlobalConfigurations,
    /**
     * Upsert global configuration data.
     */
    updateGlobalConfiguration
  };
}

// src/generated-admin/MaxActiveAdminApi.ts
var import_sdk22 = require("@accelbyte/sdk");
function MaxActiveAdminApi(sdk, args) {
  const sdkAssembly = sdk.assembly();
  const namespace = args?.coreConfig?.namespace ?? sdkAssembly.coreConfig.namespace;
  const useSchemaValidation = args?.coreConfig?.useSchemaValidation ?? sdkAssembly.coreConfig.useSchemaValidation;
  let axiosInstance = sdkAssembly.axiosInstance;
  const requestConfigOverrides = args?.axiosConfig?.request;
  const baseURLOverride = args?.coreConfig?.baseURL;
  const interceptorsOverride = args?.axiosConfig?.interceptors ?? [];
  if (requestConfigOverrides || baseURLOverride || interceptorsOverride.length > 0) {
    const requestConfig = import_sdk22.ApiUtils.mergeAxiosConfigs(sdkAssembly.axiosInstance.defaults, {
      ...baseURLOverride ? { baseURL: baseURLOverride } : {},
      ...requestConfigOverrides
    });
    axiosInstance = import_sdk22.Network.create(requestConfig);
    for (const interceptor of interceptorsOverride) {
      if (interceptor.type === "request") {
        axiosInstance.interceptors.request.use(interceptor.onRequest, interceptor.onError);
      }
      if (interceptor.type === "response") {
        axiosInstance.interceptors.response.use(interceptor.onSuccess, interceptor.onError);
      }
    }
  }
  async function updateReconcile_ByName(name2, data) {
    const $ = new MaxActiveAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.updateReconcile_ByName(name2, data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getMemberactivesession_ByName_ByUserId(name2, userId) {
    const $ = new MaxActiveAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getMemberactivesession_ByName_ByUserId(name2, userId);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  return {
    /**
     *  Reconcile Max Active Session.
     */
    updateReconcile_ByName,
    /**
     *  Get Member Active Session.
     */
    getMemberactivesession_ByName_ByUserId
  };
}

// src/generated-admin/NativeSessionAdminApi.ts
var import_sdk23 = require("@accelbyte/sdk");
function NativeSessionAdminApi(sdk, args) {
  const sdkAssembly = sdk.assembly();
  const namespace = args?.coreConfig?.namespace ?? sdkAssembly.coreConfig.namespace;
  const useSchemaValidation = args?.coreConfig?.useSchemaValidation ?? sdkAssembly.coreConfig.useSchemaValidation;
  let axiosInstance = sdkAssembly.axiosInstance;
  const requestConfigOverrides = args?.axiosConfig?.request;
  const baseURLOverride = args?.coreConfig?.baseURL;
  const interceptorsOverride = args?.axiosConfig?.interceptors ?? [];
  if (requestConfigOverrides || baseURLOverride || interceptorsOverride.length > 0) {
    const requestConfig = import_sdk23.ApiUtils.mergeAxiosConfigs(sdkAssembly.axiosInstance.defaults, {
      ...baseURLOverride ? { baseURL: baseURLOverride } : {},
      ...requestConfigOverrides
    });
    axiosInstance = import_sdk23.Network.create(requestConfig);
    for (const interceptor of interceptorsOverride) {
      if (interceptor.type === "request") {
        axiosInstance.interceptors.request.use(interceptor.onRequest, interceptor.onError);
      }
      if (interceptor.type === "response") {
        axiosInstance.interceptors.response.use(interceptor.onSuccess, interceptor.onError);
      }
    }
  }
  async function getNativeSessions(queryParams) {
    const $ = new NativeSessionAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getNativeSessions(queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  return {
    /**
     * List of native sessions.
     */
    getNativeSessions
  };
}

// src/generated-admin/PartyAdminApi.ts
var import_sdk24 = require("@accelbyte/sdk");
function PartyAdminApi(sdk, args) {
  const sdkAssembly = sdk.assembly();
  const namespace = args?.coreConfig?.namespace ?? sdkAssembly.coreConfig.namespace;
  const useSchemaValidation = args?.coreConfig?.useSchemaValidation ?? sdkAssembly.coreConfig.useSchemaValidation;
  let axiosInstance = sdkAssembly.axiosInstance;
  const requestConfigOverrides = args?.axiosConfig?.request;
  const baseURLOverride = args?.coreConfig?.baseURL;
  const interceptorsOverride = args?.axiosConfig?.interceptors ?? [];
  if (requestConfigOverrides || baseURLOverride || interceptorsOverride.length > 0) {
    const requestConfig = import_sdk24.ApiUtils.mergeAxiosConfigs(sdkAssembly.axiosInstance.defaults, {
      ...baseURLOverride ? { baseURL: baseURLOverride } : {},
      ...requestConfigOverrides
    });
    axiosInstance = import_sdk24.Network.create(requestConfig);
    for (const interceptor of interceptorsOverride) {
      if (interceptor.type === "request") {
        axiosInstance.interceptors.request.use(interceptor.onRequest, interceptor.onError);
      }
      if (interceptor.type === "response") {
        axiosInstance.interceptors.response.use(interceptor.onSuccess, interceptor.onError);
      }
    }
  }
  async function getParties(queryParams) {
    const $ = new PartyAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getParties(queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function createNativeSync_ByUserId(userId) {
    const $ = new PartyAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.createNativeSync_ByUserId(userId);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  return {
    /**
     * Query parties.
     */
    getParties,
    /**
     * Trigger user&#39;s active party session to native platform.
     */
    createNativeSync_ByUserId
  };
}

// src/generated-admin/PlatformCredentialAdminApi.ts
var import_sdk25 = require("@accelbyte/sdk");
function PlatformCredentialAdminApi(sdk, args) {
  const sdkAssembly = sdk.assembly();
  const namespace = args?.coreConfig?.namespace ?? sdkAssembly.coreConfig.namespace;
  const useSchemaValidation = args?.coreConfig?.useSchemaValidation ?? sdkAssembly.coreConfig.useSchemaValidation;
  let axiosInstance = sdkAssembly.axiosInstance;
  const requestConfigOverrides = args?.axiosConfig?.request;
  const baseURLOverride = args?.coreConfig?.baseURL;
  const interceptorsOverride = args?.axiosConfig?.interceptors ?? [];
  if (requestConfigOverrides || baseURLOverride || interceptorsOverride.length > 0) {
    const requestConfig = import_sdk25.ApiUtils.mergeAxiosConfigs(sdkAssembly.axiosInstance.defaults, {
      ...baseURLOverride ? { baseURL: baseURLOverride } : {},
      ...requestConfigOverrides
    });
    axiosInstance = import_sdk25.Network.create(requestConfig);
    for (const interceptor of interceptorsOverride) {
      if (interceptor.type === "request") {
        axiosInstance.interceptors.request.use(interceptor.onRequest, interceptor.onError);
      }
      if (interceptor.type === "response") {
        axiosInstance.interceptors.response.use(interceptor.onSuccess, interceptor.onError);
      }
    }
  }
  async function deletePlatformCredential() {
    const $ = new PlatformCredentialAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.deletePlatformCredential();
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getPlatformCredentials() {
    const $ = new PlatformCredentialAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getPlatformCredentials();
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function updatePlatformCredential(data) {
    const $ = new PlatformCredentialAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.updatePlatformCredential(data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  return {
    /**
     * Delete platform credentials used for Native Session sync.
     */
    deletePlatformCredential,
    /**
     * Get platform credentials used for Native Session sync. PSN: - clientID: Auth Server (Client Credential) ClientID - clientSecret: Auth Server (Client Credential) Secret. For security, only the first few characters are shown. - scope: should be psn:s2s.service (For Sync non PSN member to PSN Session)
     */
    getPlatformCredentials,
    /**
     * Update platform credentials for Native Session sync. Currently supports PSN platform. Send an empty body to clear data. PSN: - clientID: Auth Server (Client Credential) ClientID - clientSecret: Auth Server (Client Credential) Secret - scope: psn:s2s.service (For Sync non PSN member to PSN Session)
     */
    updatePlatformCredential
  };
}

// src/generated-admin/PlayerAdminApi.ts
var import_sdk26 = require("@accelbyte/sdk");
function PlayerAdminApi(sdk, args) {
  const sdkAssembly = sdk.assembly();
  const namespace = args?.coreConfig?.namespace ?? sdkAssembly.coreConfig.namespace;
  const useSchemaValidation = args?.coreConfig?.useSchemaValidation ?? sdkAssembly.coreConfig.useSchemaValidation;
  let axiosInstance = sdkAssembly.axiosInstance;
  const requestConfigOverrides = args?.axiosConfig?.request;
  const baseURLOverride = args?.coreConfig?.baseURL;
  const interceptorsOverride = args?.axiosConfig?.interceptors ?? [];
  if (requestConfigOverrides || baseURLOverride || interceptorsOverride.length > 0) {
    const requestConfig = import_sdk26.ApiUtils.mergeAxiosConfigs(sdkAssembly.axiosInstance.defaults, {
      ...baseURLOverride ? { baseURL: baseURLOverride } : {},
      ...requestConfigOverrides
    });
    axiosInstance = import_sdk26.Network.create(requestConfig);
    for (const interceptor of interceptorsOverride) {
      if (interceptor.type === "request") {
        axiosInstance.interceptors.request.use(interceptor.onRequest, interceptor.onError);
      }
      if (interceptor.type === "response") {
        axiosInstance.interceptors.response.use(interceptor.onSuccess, interceptor.onError);
      }
    }
  }
  async function getUsersAttributes(queryParams) {
    const $ = new PlayerAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getUsersAttributes(queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getAttributes_ByUserId(userId) {
    const $ = new PlayerAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getAttributes_ByUserId(userId);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  return {
    /**
     * Admin get attributes of players. Field descriptions: - userID : user who owns the attributes. - crossplayEnabled : set to true if the player wants to enable crossplay to their session (default: false). - platforms : list of the player&#39;s 3rd party platform account information. - name : platform name. supported platforms: STEAM, XBOX, PSN - userID : platform userID - data : other data that the player wants to store. - PSN_PUSH_CONTEXT_ID: if provided, session will refer to this when performing session sync with PSN, otherwise will populate from session attributes, otherwise will populate from session attributes - currentPlatform : latest user game platform. - roles : user role for matchmaking role base support.
     */
    getUsersAttributes,
    /**
     * Admin get attributes of a player. Field descriptions: - userID : user who owns the attributes. - crossplayEnabled : set to true if the player wants to enable crossplay to their session (default: false). - platforms : list of the player&#39;s 3rd party platform account information. - name : platform name. supported platforms: STEAM, XBOX, PSN - userID : platform userID - data : other data that the player wants to store. - PSN_PUSH_CONTEXT_ID: if provided, session will refer to this when performing session sync with PSN, otherwise will populate from session attributes - currentPlatform : latest user game platform. - roles : user role for matchmaking role base support.
     */
    getAttributes_ByUserId
  };
}

// src/generated-admin/RecentPlayerAdminApi.ts
var import_sdk27 = require("@accelbyte/sdk");
function RecentPlayerAdminApi(sdk, args) {
  const sdkAssembly = sdk.assembly();
  const namespace = args?.coreConfig?.namespace ?? sdkAssembly.coreConfig.namespace;
  const useSchemaValidation = args?.coreConfig?.useSchemaValidation ?? sdkAssembly.coreConfig.useSchemaValidation;
  let axiosInstance = sdkAssembly.axiosInstance;
  const requestConfigOverrides = args?.axiosConfig?.request;
  const baseURLOverride = args?.coreConfig?.baseURL;
  const interceptorsOverride = args?.axiosConfig?.interceptors ?? [];
  if (requestConfigOverrides || baseURLOverride || interceptorsOverride.length > 0) {
    const requestConfig = import_sdk27.ApiUtils.mergeAxiosConfigs(sdkAssembly.axiosInstance.defaults, {
      ...baseURLOverride ? { baseURL: baseURLOverride } : {},
      ...requestConfigOverrides
    });
    axiosInstance = import_sdk27.Network.create(requestConfig);
    for (const interceptor of interceptorsOverride) {
      if (interceptor.type === "request") {
        axiosInstance.interceptors.request.use(interceptor.onRequest, interceptor.onError);
      }
      if (interceptor.type === "response") {
        axiosInstance.interceptors.response.use(interceptor.onSuccess, interceptor.onError);
      }
    }
  }
  async function getRecentPlayer(queryParams) {
    const $ = new RecentPlayerAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getRecentPlayer(queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getRecentTeamPlayer(queryParams) {
    const $ = new RecentPlayerAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getRecentTeamPlayer(queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  return {
    /**
     * Query recent player with given user id. If user id parameter is empty: 1. Using User Token : It will get the user id from the token 2. Using client token : it will throw an error Please ensure environment variable &#34;RECENT_PLAYER_ENABLED&#34; is set to &#34;TRUE&#34; to use this feature.
     */
    getRecentPlayer,
    /**
     * Query recent player who were on the same team with given user id. If user id parameter is empty: 1. Using User Token : It will get the user id from the token 2. Using client token : it will throw an error Please ensure environment variable &#34;RECENT_TEAM_PLAYER_ENABLED&#34; is set to &#34;TRUE&#34; to use this feature.
     */
    getRecentTeamPlayer
  };
}

// src/generated-admin/SessionStorageAdminApi.ts
var import_sdk28 = require("@accelbyte/sdk");
function SessionStorageAdminApi(sdk, args) {
  const sdkAssembly = sdk.assembly();
  const namespace = args?.coreConfig?.namespace ?? sdkAssembly.coreConfig.namespace;
  const useSchemaValidation = args?.coreConfig?.useSchemaValidation ?? sdkAssembly.coreConfig.useSchemaValidation;
  let axiosInstance = sdkAssembly.axiosInstance;
  const requestConfigOverrides = args?.axiosConfig?.request;
  const baseURLOverride = args?.coreConfig?.baseURL;
  const interceptorsOverride = args?.axiosConfig?.interceptors ?? [];
  if (requestConfigOverrides || baseURLOverride || interceptorsOverride.length > 0) {
    const requestConfig = import_sdk28.ApiUtils.mergeAxiosConfigs(sdkAssembly.axiosInstance.defaults, {
      ...baseURLOverride ? { baseURL: baseURLOverride } : {},
      ...requestConfigOverrides
    });
    axiosInstance = import_sdk28.Network.create(requestConfig);
    for (const interceptor of interceptorsOverride) {
      if (interceptor.type === "request") {
        axiosInstance.interceptors.request.use(interceptor.onRequest, interceptor.onError);
      }
      if (interceptor.type === "response") {
        axiosInstance.interceptors.response.use(interceptor.onSuccess, interceptor.onError);
      }
    }
  }
  async function deleteStorage_BySessionId(sessionId) {
    const $ = new SessionStorageAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.deleteStorage_BySessionId(sessionId);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getStorage_BySessionId(sessionId) {
    const $ = new SessionStorageAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getStorage_BySessionId(sessionId);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getStorageUser_BySessionId_ByUserId(sessionId, userId) {
    const $ = new SessionStorageAdmin$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getStorageUser_BySessionId_ByUserId(sessionId, userId);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  return {
    /**
     *  Delete Session Storage By sessionID Session Storage feature only available for Gamesession
     */
    deleteStorage_BySessionId,
    /**
     *  Read Session Storage by sessionID Session Storage feature only available for Gamesession
     */
    getStorage_BySessionId,
    /**
     *  Read Session Storage by sessionID and userID Session Storage feature only available for Gamesession
     */
    getStorageUser_BySessionId_ByUserId
  };
}

// src/generated-definitions/AppendTeamGameSessionRequest.ts
var import_zod45 = require("zod");
var AppendTeamGameSessionRequest = import_zod45.z.object({
  additionalMembers: import_zod45.z.array(PartyMembers),
  proposedTeams: import_zod45.z.array(Team),
  version: import_zod45.z.number().int()
});

// src/generated-definitions/ConfigAlertRequestCreate.ts
var import_zod46 = require("zod");
var ConfigAlertRequestCreate = import_zod46.z.object({ durationDays: import_zod46.z.number().int() });

// src/generated-definitions/CreateConfigurationTemplateRequest.ts
var import_zod47 = require("zod");
var CreateConfigurationTemplateRequest = import_zod47.z.object({
  NativeSessionSetting: NativeSessionSetting.nullish(),
  PSNBaseUrl: import_zod47.z.string().nullish(),
  appName: import_zod47.z.string().nullish(),
  attributes: import_zod47.z.record(import_zod47.z.any()).nullish(),
  autoJoin: import_zod47.z.boolean().nullish(),
  autoLeaveSession: import_zod47.z.boolean().nullish(),
  clientVersion: import_zod47.z.string(),
  customURLGRPC: import_zod47.z.string().nullish(),
  deployment: import_zod47.z.string(),
  disableCodeGeneration: import_zod47.z.boolean().nullish(),
  disableResendInvite: import_zod47.z.boolean().nullish(),
  dsManualSetReady: import_zod47.z.boolean().nullish(),
  dsSource: import_zod47.z.string().nullish(),
  enableSecret: import_zod47.z.boolean().nullish(),
  fallbackClaimKeys: import_zod47.z.array(import_zod47.z.string()).nullish(),
  grpcSessionConfig: ExtendConfiguration.nullish(),
  immutableStorage: import_zod47.z.boolean().nullish(),
  inactiveTimeout: import_zod47.z.number().int(),
  inviteTimeout: import_zod47.z.number().int(),
  joinability: import_zod47.z.string(),
  leaderElectionGracePeriod: import_zod47.z.number().int().nullish(),
  manualRejoin: import_zod47.z.boolean().nullish(),
  maxActiveSessions: import_zod47.z.number().int().nullish(),
  maxPlayers: import_zod47.z.number().int(),
  minPlayers: import_zod47.z.number().int(),
  name: import_zod47.z.string(),
  persistent: import_zod47.z.boolean(),
  preferredClaimKeys: import_zod47.z.array(import_zod47.z.string()).nullish(),
  requestedRegions: import_zod47.z.array(import_zod47.z.string()),
  textChat: import_zod47.z.boolean(),
  tieTeamsSessionLifetime: import_zod47.z.boolean().nullish(),
  type: import_zod47.z.string()
});

// src/generated-definitions/CreateGameSessionRequest.ts
var import_zod49 = require("zod");

// src/generated-definitions/SessionStorageRequest.ts
var import_zod48 = require("zod");
var SessionStorageRequest = import_zod48.z.object({ leader: import_zod48.z.record(import_zod48.z.any()) });

// src/generated-definitions/CreateGameSessionRequest.ts
var CreateGameSessionRequest = import_zod49.z.object({
  appName: import_zod49.z.string().nullish(),
  attributes: import_zod49.z.record(import_zod49.z.any()),
  autoJoin: import_zod49.z.boolean().nullish(),
  backfillTicketID: import_zod49.z.string(),
  clientVersion: import_zod49.z.string(),
  configurationName: import_zod49.z.string(),
  customURLGRPC: import_zod49.z.string().nullish(),
  deployment: import_zod49.z.string(),
  dsSource: import_zod49.z.string().nullish(),
  fallbackClaimKeys: import_zod49.z.array(import_zod49.z.string()).nullish(),
  inactiveTimeout: import_zod49.z.number().int(),
  inviteTimeout: import_zod49.z.number().int(),
  joinability: import_zod49.z.string(),
  matchPool: import_zod49.z.string(),
  maxPlayers: import_zod49.z.number().int(),
  minPlayers: import_zod49.z.number().int(),
  preferredClaimKeys: import_zod49.z.array(import_zod49.z.string()).nullish(),
  requestedRegions: import_zod49.z.array(import_zod49.z.string()),
  serverName: import_zod49.z.string(),
  storage: SessionStorageRequest.nullish(),
  teams: import_zod49.z.array(Team),
  textChat: import_zod49.z.boolean(),
  ticketIDs: import_zod49.z.array(import_zod49.z.string()),
  tieTeamsSessionLifetime: import_zod49.z.boolean().nullish(),
  type: import_zod49.z.string()
});

// src/generated-definitions/CreatePartyRequest.ts
var import_zod51 = require("zod");

// src/generated-definitions/RequestMember.ts
var import_zod50 = require("zod");
var RequestMember = import_zod50.z.object({ ID: import_zod50.z.string(), PlatformID: import_zod50.z.string(), PlatformUserID: import_zod50.z.string() });

// src/generated-definitions/CreatePartyRequest.ts
var CreatePartyRequest = import_zod51.z.object({
  attributes: import_zod51.z.record(import_zod51.z.any()),
  configurationName: import_zod51.z.string(),
  inactiveTimeout: import_zod51.z.number().int(),
  inviteTimeout: import_zod51.z.number().int(),
  joinability: import_zod51.z.string(),
  maxPlayers: import_zod51.z.number().int(),
  members: import_zod51.z.array(RequestMember),
  minPlayers: import_zod51.z.number().int(),
  textChat: import_zod51.z.boolean(),
  type: import_zod51.z.string()
});

// src/generated-definitions/DeleteBulkGameSessionRequest.ts
var import_zod52 = require("zod");
var DeleteBulkGameSessionRequest = import_zod52.z.object({ ids: import_zod52.z.array(import_zod52.z.string()) });

// src/generated-definitions/Error.ts
var import_zod53 = require("zod");
var Error2 = import_zod53.z.object({
  attributes: import_zod53.z.record(import_zod53.z.string()),
  errorCode: import_zod53.z.number().int(),
  errorMessage: import_zod53.z.string(),
  message: import_zod53.z.string(),
  name: import_zod53.z.string()
});

// src/generated-definitions/JoinByCodeRequest.ts
var import_zod54 = require("zod");
var JoinByCodeRequest = import_zod54.z.object({ code: import_zod54.z.string() });

// src/generated-definitions/KickResponse.ts
var import_zod55 = require("zod");
var KickResponse = import_zod55.z.object({ leaderID: import_zod55.z.string(), members: import_zod55.z.array(UserResponse), partyID: import_zod55.z.string() });

// src/generated-definitions/PlayerAttributesRequestBody.ts
var import_zod56 = require("zod");
var PlayerAttributesRequestBody = import_zod56.z.object({
  crossplayEnabled: import_zod56.z.boolean(),
  currentPlatform: import_zod56.z.string(),
  data: import_zod56.z.record(import_zod56.z.any()),
  platforms: import_zod56.z.array(UserPlatformInfo),
  roles: import_zod56.z.array(import_zod56.z.string()).nullish(),
  simultaneousPlatform: import_zod56.z.string()
});

// src/generated-definitions/PlayerPlatform.ts
var import_zod57 = require("zod");
var PlayerPlatform = import_zod57.z.object({ crossplayEnabled: import_zod57.z.boolean().nullish(), currentPlatform: import_zod57.z.string(), userID: import_zod57.z.string() });

// src/generated-definitions/PlayersCurrentPlatformRequest.ts
var import_zod58 = require("zod");
var PlayersCurrentPlatformRequest = import_zod58.z.object({ userIDs: import_zod58.z.array(import_zod58.z.string()) });

// src/generated-definitions/PlayersCurrentPlatformResponse.ts
var import_zod59 = require("zod");
var PlayersCurrentPlatformResponse = import_zod59.z.object({ data: import_zod59.z.array(PlayerPlatform) });

// src/generated-definitions/PromoteLeaderRequest.ts
var import_zod60 = require("zod");
var PromoteLeaderRequest = import_zod60.z.object({ leaderID: import_zod60.z.string() });

// src/generated-definitions/PutGlobalConfigurationRequest.ts
var import_zod61 = require("zod");
var PutGlobalConfigurationRequest = import_zod61.z.object({
  metricExcludedNamespaces: import_zod61.z.array(import_zod61.z.string()),
  regionRetryMapping: import_zod61.z.record(import_zod61.z.array(import_zod61.z.string())),
  regionURLMapping: import_zod61.z.array(import_zod61.z.string()),
  testGameMode: import_zod61.z.string(),
  testRegionURLMapping: import_zod61.z.array(import_zod61.z.string()),
  testTargetUserIDs: import_zod61.z.array(import_zod61.z.string())
});

// src/generated-definitions/PutPlatformCredentialsRequest.ts
var import_zod62 = require("zod");
var PutPlatformCredentialsRequest = import_zod62.z.object({ psn: PsnAppServerCredentials });

// src/generated-definitions/RequestReconcileMaxActiveSession.ts
var import_zod63 = require("zod");
var RequestReconcileMaxActiveSession = import_zod63.z.object({ userID: import_zod63.z.string() });

// src/generated-definitions/ServerSecret.ts
var import_zod64 = require("zod");
var ServerSecret = import_zod64.z.object({ secret: import_zod64.z.string() });

// src/generated-definitions/SessionInviteRequest.ts
var import_zod65 = require("zod");
var SessionInviteRequest = import_zod65.z.object({ platformID: import_zod65.z.string(), userID: import_zod65.z.string() });

// src/generated-definitions/SessionInviteResponse.ts
var import_zod66 = require("zod");
var SessionInviteResponse = import_zod66.z.object({ platformUserID: import_zod66.z.string() });

// src/generated-definitions/SetDsReadyRequest.ts
var import_zod67 = require("zod");
var SetDsReadyRequest = import_zod67.z.object({ ready: import_zod67.z.boolean() });

// src/generated-definitions/UpdateConfigurationTemplateRequest.ts
var import_zod68 = require("zod");
var UpdateConfigurationTemplateRequest = import_zod68.z.object({
  NativeSessionSetting: NativeSessionSetting.nullish(),
  PSNBaseUrl: import_zod68.z.string().nullish(),
  appName: import_zod68.z.string().nullish(),
  attributes: import_zod68.z.record(import_zod68.z.any()).nullish(),
  autoJoin: import_zod68.z.boolean().nullish(),
  autoLeaveSession: import_zod68.z.boolean().nullish(),
  clientVersion: import_zod68.z.string(),
  customURLGRPC: import_zod68.z.string().nullish(),
  deployment: import_zod68.z.string(),
  disableCodeGeneration: import_zod68.z.boolean().nullish(),
  disableResendInvite: import_zod68.z.boolean().nullish(),
  dsManualSetReady: import_zod68.z.boolean().nullish(),
  dsSource: import_zod68.z.string().nullish(),
  enableSecret: import_zod68.z.boolean().nullish(),
  fallbackClaimKeys: import_zod68.z.array(import_zod68.z.string()).nullish(),
  grpcSessionConfig: ExtendConfiguration.nullish(),
  immutableStorage: import_zod68.z.boolean().nullish(),
  inactiveTimeout: import_zod68.z.number().int(),
  inviteTimeout: import_zod68.z.number().int(),
  joinability: import_zod68.z.string(),
  leaderElectionGracePeriod: import_zod68.z.number().int().nullish(),
  manualRejoin: import_zod68.z.boolean().nullish(),
  maxActiveSessions: import_zod68.z.number().int().nullish(),
  maxPlayers: import_zod68.z.number().int(),
  minPlayers: import_zod68.z.number().int(),
  name: import_zod68.z.string(),
  persistent: import_zod68.z.boolean(),
  preferredClaimKeys: import_zod68.z.array(import_zod68.z.string()).nullish(),
  requestedRegions: import_zod68.z.array(import_zod68.z.string()),
  textChat: import_zod68.z.boolean(),
  tieTeamsSessionLifetime: import_zod68.z.boolean().nullish(),
  type: import_zod68.z.string()
});

// src/generated-definitions/UpdateGameSessionBackfillRequest.ts
var import_zod69 = require("zod");
var UpdateGameSessionBackfillRequest = import_zod69.z.object({ backfillTicketID: import_zod69.z.string() });

// src/generated-definitions/UpdateGameSessionRequest.ts
var import_zod70 = require("zod");
var UpdateGameSessionRequest = import_zod70.z.object({
  attributes: import_zod70.z.record(import_zod70.z.any()),
  backfillTicketID: import_zod70.z.string(),
  clientVersion: import_zod70.z.string(),
  deployment: import_zod70.z.string(),
  fallbackClaimKeys: import_zod70.z.array(import_zod70.z.string()).nullish(),
  inactiveTimeout: import_zod70.z.number().int(),
  inviteTimeout: import_zod70.z.number().int(),
  joinability: import_zod70.z.string(),
  matchPool: import_zod70.z.string(),
  maxPlayers: import_zod70.z.number().int(),
  minPlayers: import_zod70.z.number().int(),
  preferredClaimKeys: import_zod70.z.array(import_zod70.z.string()).nullish(),
  requestedRegions: import_zod70.z.array(import_zod70.z.string()),
  teams: import_zod70.z.array(Team),
  ticketIDs: import_zod70.z.array(import_zod70.z.string()),
  tieTeamsSessionLifetime: import_zod70.z.boolean().nullish(),
  type: import_zod70.z.string(),
  version: import_zod70.z.number().int()
});

// src/generated-definitions/UpdatePartyRequest.ts
var import_zod71 = require("zod");
var UpdatePartyRequest = import_zod71.z.object({
  attributes: import_zod71.z.record(import_zod71.z.any()),
  inactiveTimeout: import_zod71.z.number().int(),
  inviteTimeout: import_zod71.z.number().int(),
  joinability: import_zod71.z.string(),
  maxPlayers: import_zod71.z.number().int(),
  minPlayers: import_zod71.z.number().int(),
  type: import_zod71.z.string(),
  version: import_zod71.z.number().int()
});

// src/generated-public/endpoints/GameSession$.ts
var import_sdk29 = require("@accelbyte/sdk");
var import_zod72 = require("zod");
var GameSession$ = class {
  // @ts-ignore
  // prettier-ignore
  constructor(axiosInstance, namespace, useSchemaValidation = true) {
    this.axiosInstance = axiosInstance;
    this.namespace = namespace;
    this.useSchemaValidation = useSchemaValidation;
  }
  /**
   * Create a game session. Session configuration &#34;name&#34; is mandatory, this API will refer following values from the session template if they&#39;re not provided in the request: - type - joinability - autoJoin. If enabled (set to true), players provided in the request will automatically joined the initial game session creation. Game session will not send any invite and players dont need to act upon it. - minPlayers - maxPlayers - inviteTimeout - inactiveTimeout - attributes - dsSource - tieTeamsSessionLifetime - matchPool - clientVersion - deployment - serverName - textChat - autoJoin - requestedRegions - dsSource - preferredClaimKeys - fallbackClaimKeys - customURLGRPC When the tieTeamsSessionLifetime is true, the lifetime of any partyId inside teams attribute will be tied to the game session. Only applies when the teams partyId is a game session. Session has 2 fields for user status: &#34;status&#34; and &#34;statusV2&#34;. The &#34;status&#34; is there for backward-compatibility, therefore we encourage to just rely on &#34;statusV2&#34; for the more updated statuses. User statuses: 1. INVITED: by default, to join a session (except session with OPEN joinability or if session configuration has &#34;autoJoin&#34; sets to True) a user will receive an invite. The invitee will have the chance to respond within &#34;inviteTimeout&#34; which you can configure through session configuration. 2. TIMEOUT: when a user is invited to a session, they will receive an invite. Unless &#34;disableResendInvite&#34; sets to True in the session configuration, the user will also receive invite reminder every 30s until they respond to the invite. 3. REJECTED: when a user rejects an invite. To rejoin an INVITE_ONLY session, they will need to be re-invited and accept the invite. 4. JOINED: there are few ways of a user to join a session, by invite, direct join (depends on session joinability) or join by code. upon invite, once a user accepts an invite, their status will be changed to JOINED. 5. LEFT: user can leave a session. in case of party, a user can only be in 1 party at a time. therefore when they decide to create or join another party, they will be automatically removed from their initial party and their status will be changed to LEFT. 6. KICKED: only party leader can kick a member. 7. DISCONNECTED: if user still have reserved seat in the session and they disconnect lobby websocket, their status in the session will be changed to DISCONNECTED and field &#34;members.previousStatus&#34; of that user will contains the initial status before they disconnect lobby websocket. the user will be given chance to reconnect within &#34;inactiveTimeout&#34; which you can configure through session configuration. 8. CONNECTED: when a user reconnect their lobby websocket, their status will change from DISCONNECTED to CONNECTED, only if they previously JOINED session. if they were on INVITED state before the disconnect happened, the user&#39;s status will return back to INVITED after they reconnect. 9. DROPPED: when &#34;inactiveTimeout&#34; is due and user never re-establish their websocket connection, we will drop them from the session. 10. TERMINATED: only applies to game session. If a game session (match) is ended, DS will end/delete the session and we will mark all remaining users&#39; status to be TERMINATED. 11. CANCELLED: when a session joinability changes to CLOSED, any remaining invites will be canceled. User is considered as active if they&#39;re present in the session, which their status either CONNECTED or JOINED. User has a reserved seat in the session if their status either INVITED, JOINED, CONNECTED, DISCONNECTED. When user&#39;s&#39; status change to other than these mentioned statuses, we will release the seat for other players to occupy. Managing the relation between session and lobby websocket connection: - Session relies on lobby to consider player&#39;s connection health to our backend. therefore a disruption to lobby websocket will be reflected in the user&#39;s status in all of their session(s). - If user still have a reserved seat in the session and they disconnect lobby websocket, their status in session(s) will be changed to DISCONNECTED and field &#34;members.previousStatus&#34; of that user will contains the initial status before they disconnect lobby websocket. This &#34;members.previousStatus&#34; used to track user&#39;s previous status before they disconnect websocket, since we still reserve a seat for them, therefore this field will be empty again after they websocket. - If the disconnected user is the leader of the session they&#39;re disconnected from, we will wait until &#34;leaderElectionGracePeriod&#34; is due, to promote the next oldest member as the new leader of the session. You can configure &#34;leaderElectionGracePeriod&#34; through session configuration. - The user will be given chance to reconnect within &#34;inactiveTimeout&#34; which you can configure through session configuration. If until &#34;inactiveTimeout&#34; is due and the user doesn&#39;t reconnect their websocket, they will be removed from session and their status will change to DROPPED. If the dropped user was the leader of the session, we will promote the next oldest member as leader. - By default, we will update user&#39;s status to what it was before disconnect, when the user reconnects lobby websocket, unless &#34;manualRejoin&#34; sets to True in the session configuration. When &#34;manualRejoin&#34; is enabled, after lobby websocket reconnect, the game client will need to manually invoke join session again to rejoin the session. - If the user was on INVITED state before the disconnect happened, the user&#39;s status will return back to INVITED after they reconnect. When the session type is a DS, a DS creation request will be sent if number of active players reaches session&#39;s minPlayers. Session service has several DSInformation status to track DS request to DS providers: - NEED_TO_REQUEST: number of active players hasn&#39;t reached session&#39;s minPlayers therefore DS has not yet requested. - REQUESTED: DS is being requested to DSMC. - PREPARING: DS needs to call manual set ready for the game session - AVAILABLE: DS is ready to use. The DSMC status for this DS is either READY/BUSY. - FAILED_TO_REQUEST: DSMC fails to spin up a DS for session. - DS_ERROR: DS provider fails to spin up the DS or the DS itself becomes unreachable - DS_CANCELLED: when DSMC is preparing the DS, DSMC will give a temporary DS. In this phase, if you delete the game session, the DS request will be canceled. - ENDED: when a game session (match) has finished and DS has done its job, it will terminate itself. - UNKNOWN: if any unknown DS status is detected. DSInformation has 2 fields for DS status: &#34;status&#34; and &#34;statusV2&#34;. The &#34;status&#34; is there for backward-compatibility, therefore we encourage to just rely on &#34;statusV2&#34; for the more updated statuses. DS Source can be DSMC, AMS or custom. In DSMC, a DS request will be put in queue if they dont have available buffers, and DSMC will let the service knows when they finished spinning it up. While AMS doesn&#39;t have a concept of queue. Therefore some &#34;DSInformation.statusV2&#34; only applicable for DSMC. By default, DS requests are sent to DSMC, but if dsSource is set to &#34;AMS&#34;: - A DS will be requested from AMS instead of DSMC. - The server will be chosen based on a set of claim keys, in order of preference, to match with fleets. - The claim key list is built build from the preferredClaimKeys, fallbackClaimKeys, and clientVersion as follows: [preferredClaimKeys.., clientVersion, fallbackClaimKeys...] for session override can follow guideline in here https://docs.accelbyte.io/gaming-services/services/extend/override-ags-feature/getting-started-with-session-customization/
   */
  createGamesession(data) {
    const params = {};
    const url = "/session/v1/public/namespaces/{namespace}/gamesession".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.post(url, data, { params });
    return import_sdk29.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, GameSessionResponse, "GameSessionResponse");
  }
  /**
   * Query game sessions. By default, API will return a list of available game sessions (joinability: open). Session service has several DSInformation status to track DS request to DS providers: - NEED_TO_REQUEST: number of active players hasn&#39;t reached session&#39;s minPlayers therefore DS has not yet requested. - REQUESTED: DS is being requested to DSMC. - PREPARING: DS needs to call manual set ready for the game session - AVAILABLE: DS is ready to use. The DSMC status for this DS is either READY/BUSY. - FAILED_TO_REQUEST: DSMC fails to spin up a DS for session. - DS_ERROR: DS provider fails to spin up the DS or the DS itself becomes unreachable - DS_CANCELLED: when DSMC is preparing the DS, DSMC will give a temporary DS. In this phase, if you delete the game session, the DS request will be canceled. - ENDED: when a game session (match) has finished and DS has done its job, it will terminate itself. - UNKNOWN: if any unknown DS status is detected. DSInformation has 2 fields for DS status: &#34;status&#34; and &#34;statusV2&#34;. The &#34;status&#34; is there for backward-compatibility, therefore we encourage to just rely on &#34;statusV2&#34; for the more updated statuses. DS Source can be DSMC, AMS or custom. In DSMC, a DS request will be put in queue if they dont have available buffers, and DSMC will let the service knows when they finished spinning it up. While AMS doesn&#39;t have a concept of queue. Therefore some &#34;DSInformation.statusV2&#34; only applicable for DSMC. query parameter \&#34;availability\&#34; to filter sessions&#39; availability: all: return all sessions regardless it&#39;s full full: only return active sessions default behavior (unset or else): return only available sessions (not full)
   */
  createGamesession_ByNS() {
    const params = {};
    const url = "/session/v1/public/namespaces/{namespace}/gamesessions".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.post(url, null, { params });
    return import_sdk29.Validate.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      GameSessionQueryResponse,
      "GameSessionQueryResponse"
    );
  }
  /**
   * Query user&#39;s game sessions. By default, API will return a list of user&#39;s active game sessions (INVITED,JOINED,CONNECTED). Session service has several DSInformation status to track DS request to DS providers: - NEED_TO_REQUEST: number of active players hasn&#39;t reached session&#39;s minPlayers therefore DS has not yet requested. - REQUESTED: DS is being requested to DSMC. - PREPARING: DS needs to call manual set ready for the game session - AVAILABLE: DS is ready to use. The DSMC status for this DS is either READY/BUSY. - FAILED_TO_REQUEST: DSMC fails to spin up a DS for session. - DS_ERROR: DS provider fails to spin up the DS or the DS itself becomes unreachable - DS_CANCELLED: when DSMC is preparing the DS, DSMC will give a temporary DS. In this phase, if you delete the game session, the DS request will be canceled. - ENDED: when a game session (match) has finished and DS has done its job, it will terminate itself. - UNKNOWN: if any unknown DS status is detected. DSInformation has 2 fields for DS status: &#34;status&#34; and &#34;statusV2&#34;. The &#34;status&#34; is there for backward-compatibility, therefore we encourage to just rely on &#34;statusV2&#34; for the more updated statuses. DS Source can be DSMC, AMS or custom. In DSMC, a DS request will be put in queue if they dont have available buffers, and DSMC will let the service knows when they finished spinning it up. While AMS doesn&#39;t have a concept of queue. Therefore some &#34;DSInformation.statusV2&#34; only applicable for DSMC.
   */
  getUsersMeGamesessions(queryParams) {
    const params = { ...queryParams };
    const url = "/session/v1/public/namespaces/{namespace}/users/me/gamesessions".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.get(url, { params });
    return import_sdk29.Validate.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      GameSessionQueryResponse,
      "GameSessionQueryResponse"
    );
  }
  /**
   * Join a session by code. The user can join a session as long as the code is valid
   */
  createGamesessionJoinCode(data) {
    const params = {};
    const url = "/session/v1/public/namespaces/{namespace}/gamesessions/join/code".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.post(url, data, { params });
    return import_sdk29.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, GameSessionResponse, "GameSessionResponse");
  }
  /**
   * Delete a game session.
   */
  deleteGamesession_BySessionId(sessionId) {
    const params = {};
    const url = "/session/v1/public/namespaces/{namespace}/gamesessions/{sessionId}".replace("{namespace}", this.namespace).replace("{sessionId}", sessionId);
    const resultPromise = this.axiosInstance.delete(url, { params });
    return import_sdk29.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, import_zod72.z.unknown(), "z.unknown()");
  }
  /**
   * Get game session detail. Session will only be accessible from active players in the session, and client with the permission, except the joinability is set to OPEN. Session service has several DSInformation status to track DS request to DS providers: - NEED_TO_REQUEST: number of active players hasn&#39;t reached session&#39;s minPlayers therefore DS has not yet requested. - REQUESTED: DS is being requested to DSMC. - PREPARING: DS needs to call manual set ready for the game session - AVAILABLE: DS is ready to use. The DSMC status for this DS is either READY/BUSY. - FAILED_TO_REQUEST: DSMC fails to spin up a DS for session. - DS_ERROR: DS provider fails to spin up the DS or the DS itself becomes unreachable - DS_CANCELLED: when DSMC is preparing the DS, DSMC will give a temporary DS. In this phase, if you delete the game session, the DS request will be canceled. - ENDED: when a game session (match) has finished and DS has done its job, it will terminate itself. - UNKNOWN: if any unknown DS status is detected. DSInformation has 2 fields for DS status: &#34;status&#34; and &#34;statusV2&#34;. The &#34;status&#34; is there for backward-compatibility, therefore we encourage to just rely on &#34;statusV2&#34; for the more updated statuses. DS Source can be DSMC, AMS or custom. In DSMC, a DS request will be put in queue if they dont have available buffers, and DSMC will let the service knows when they finished spinning it up. While AMS doesn&#39;t have a concept of queue. Therefore some &#34;DSInformation.statusV2&#34; only applicable for DSMC.
   */
  getGamesession_BySessionId(sessionId) {
    const params = {};
    const url = "/session/v1/public/namespaces/{namespace}/gamesessions/{sessionId}".replace("{namespace}", this.namespace).replace("{sessionId}", sessionId);
    const resultPromise = this.axiosInstance.get(url, { params });
    return import_sdk29.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, GameSessionResponse, "GameSessionResponse");
  }
  /**
   * Update specified fields from game session data.
   */
  patchGamesession_BySessionId(sessionId, data) {
    const params = {};
    const url = "/session/v1/public/namespaces/{namespace}/gamesessions/{sessionId}".replace("{namespace}", this.namespace).replace("{sessionId}", sessionId);
    const resultPromise = this.axiosInstance.patch(url, data, { params });
    return import_sdk29.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, GameSessionResponse, "GameSessionResponse");
  }
  /**
   * Updates a game session, this endpoint will override stored gamesession data. To update only specified fields, please use following endpoint: method : PATCH API : /session/v1/public/namespaces/{namespace}/gamesessions/{sessionId} To update DS attributes (clientVersion, deployment, requestedRegions) it will only be applied only as long as no DS has been requested, otherwise ignored.
   */
  updateGamesession_BySessionId(sessionId, data) {
    const params = {};
    const url = "/session/v1/public/namespaces/{namespace}/gamesessions/{sessionId}".replace("{namespace}", this.namespace).replace("{sessionId}", sessionId);
    const resultPromise = this.axiosInstance.put(url, data, { params });
    return import_sdk29.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, GameSessionResponse, "GameSessionResponse");
  }
  /**
   * Revoke code of the game session. Only leader can revoke a code.
   */
  deleteCode_BySessionId(sessionId) {
    const params = {};
    const url = "/session/v1/public/namespaces/{namespace}/gamesessions/{sessionId}/code".replace("{namespace}", this.namespace).replace("{sessionId}", sessionId);
    const resultPromise = this.axiosInstance.delete(url, { params });
    return import_sdk29.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, import_zod72.z.unknown(), "z.unknown()");
  }
  /**
   * Generate a new code for the game session. Only leader can generate a code.
   */
  updateCode_BySessionId(sessionId) {
    const params = {};
    const url = "/session/v1/public/namespaces/{namespace}/gamesessions/{sessionId}/code".replace("{namespace}", this.namespace).replace("{sessionId}", sessionId);
    const resultPromise = this.axiosInstance.post(url, null, { params });
    return import_sdk29.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, GameSessionResponse, "GameSessionResponse");
  }
  /**
   * Join a game session.
   */
  createJoin_BySessionId(sessionId) {
    const params = {};
    const url = "/session/v1/public/namespaces/{namespace}/gamesessions/{sessionId}/join".replace("{namespace}", this.namespace).replace("{sessionId}", sessionId);
    const resultPromise = this.axiosInstance.post(url, null, { params });
    return import_sdk29.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, GameSessionResponse, "GameSessionResponse");
  }
  /**
   * Leave a game session.
   */
  deleteLeave_BySessionId(sessionId) {
    const params = {};
    const url = "/session/v1/public/namespaces/{namespace}/gamesessions/{sessionId}/leave".replace("{namespace}", this.namespace).replace("{sessionId}", sessionId);
    const resultPromise = this.axiosInstance.delete(url, { params });
    return import_sdk29.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, import_zod72.z.unknown(), "z.unknown()");
  }
  /**
   * Append new member or team to session
   */
  updateTeam_BySessionId(sessionId, data) {
    const params = {};
    const url = "/session/v1/public/namespaces/{namespace}/gamesessions/{sessionId}/teams".replace("{namespace}", this.namespace).replace("{sessionId}", sessionId);
    const resultPromise = this.axiosInstance.post(url, data, { params });
    return import_sdk29.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, GameSessionResponse, "GameSessionResponse");
  }
  /**
   * Get game session detail by podname. Session service has several DSInformation status to track DS request to DS providers: - NEED_TO_REQUEST: number of active players hasn&#39;t reached session&#39;s minPlayers therefore DS has not yet requested. - REQUESTED: DS is being requested to DSMC. - PREPARING: DS needs to call manual set ready for the game session - AVAILABLE: DS is ready to use. The DSMC status for this DS is either READY/BUSY. - FAILED_TO_REQUEST: DSMC fails to spin up a DS for session. - DS_ERROR: DS provider fails to spin up the DS or the DS itself becomes unreachable - DS_CANCELLED: when DSMC is preparing the DS, DSMC will give a temporary DS. In this phase, if you delete the game session, the DS request will be canceled. - ENDED: when a game session (match) has finished and DS has done its job, it will terminate itself. - UNKNOWN: if any unknown DS status is detected. DSInformation has 2 fields for DS status: &#34;status&#34; and &#34;statusV2&#34;. The &#34;status&#34; is there for backward-compatibility, therefore we encourage to just rely on &#34;statusV2&#34; for the more updated statuses. DS Source can be DSMC, AMS or custom. In DSMC, a DS request will be put in queue if they dont have available buffers, and DSMC will let the service knows when they finished spinning it up. While AMS doesn&#39;t have a concept of queue. Therefore some &#34;DSInformation.statusV2&#34; only applicable for DSMC.
   */
  getGamesessionServer_ByPodName(podName) {
    const params = {};
    const url = "/session/v1/public/namespaces/{namespace}/gamesessions/servers/{podName}".replace("{namespace}", this.namespace).replace("{podName}", podName);
    const resultPromise = this.axiosInstance.get(url, { params });
    return import_sdk29.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, GameSessionResponse, "GameSessionResponse");
  }
  /**
   * Invite a user to a game session. platformID represents the native platform of the invitee. API will return the corresponding native platform&#39;s userID. supported platforms: - STEAM - XBOX - PSN
   */
  createInvite_BySessionId(sessionId, data) {
    const params = {};
    const url = "/session/v1/public/namespaces/{namespace}/gamesessions/{sessionId}/invite".replace("{namespace}", this.namespace).replace("{sessionId}", sessionId);
    const resultPromise = this.axiosInstance.post(url, data, { params });
    return import_sdk29.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, import_zod72.z.unknown(), "z.unknown()");
  }
  /**
   * Promote game session member to become the new game session leader. This API requires the NAMESPACE:{namespace}:SESSION:GAME [UPDATE] permission. This API can be operated by: - User (game session member) who is the current leader of the game session - Game Client - Dedicated Server (DS) This API will promote game session leader candidate with the following criteria: - Leader candidate is a member of the game session - Leader candidate has a &#34;CONNECTED&#34; or &#34;JOINED&#34; status - If the leader candidate is the current leader, then no promotion process is carried out
   */
  updateLeader_BySessionId(sessionId, data) {
    const params = {};
    const url = "/session/v1/public/namespaces/{namespace}/gamesessions/{sessionId}/leader".replace("{namespace}", this.namespace).replace("{sessionId}", sessionId);
    const resultPromise = this.axiosInstance.post(url, data, { params });
    return import_sdk29.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, GameSessionResponse, "GameSessionResponse");
  }
  /**
   * Reject a game session invitation.
   */
  deleteReject_BySessionId(sessionId) {
    const params = {};
    const url = "/session/v1/public/namespaces/{namespace}/gamesessions/{sessionId}/reject".replace("{namespace}", this.namespace).replace("{sessionId}", sessionId);
    const resultPromise = this.axiosInstance.delete(url, { params });
    return import_sdk29.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, import_zod72.z.unknown(), "z.unknown()");
  }
  /**
   *  Used by game Client to Get Secret constraints - EnableSecret = true - Type = &#34;DS&#34; - secret value will only be produced if enableSecret is true and type is DS if enableSecret = false - empty secret will be returned as 200 OK Expected caller of this API - Game Client to get server secret In the Response you will get following: - 200 OK { &#34;secret&#34;: &lt;string&gt; } If there is error: - 400 Invalid path parameters - 401 unauthorized - 404 StatusNotFound - 500 Internal server error
   */
  getSecret_BySessionId(sessionId) {
    const params = {};
    const url = "/session/v1/public/namespaces/{namespace}/gamesessions/{sessionId}/secret".replace("{namespace}", this.namespace).replace("{sessionId}", sessionId);
    const resultPromise = this.axiosInstance.get(url, { params });
    return import_sdk29.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, ServerSecret, "ServerSecret");
  }
  /**
   * Update game session backfill ticket id. Will override game session backfill ticket based on given request parameter
   */
  updateBackfill_BySessionId(sessionId, data) {
    const params = {};
    const url = "/session/v1/public/namespaces/{namespace}/gamesessions/{sessionId}/backfill".replace("{namespace}", this.namespace).replace("{sessionId}", sessionId);
    const resultPromise = this.axiosInstance.put(url, data, { params });
    return import_sdk29.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, GameSessionResponse, "GameSessionResponse");
  }
  /**
   * cancel a game session invitation.
   */
  deleteCancel_BySessionId_ByUserId(sessionId, userId) {
    const params = {};
    const url = "/session/v1/public/namespaces/{namespace}/gamesessions/{sessionId}/users/{userId}/cancel".replace("{namespace}", this.namespace).replace("{sessionId}", sessionId).replace("{userId}", userId);
    const resultPromise = this.axiosInstance.delete(url, { params });
    return import_sdk29.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, import_zod72.z.unknown(), "z.unknown()");
  }
  /**
   * Kick member from a game session, only leader can kick member.
   */
  deleteKick_BySessionId_ByMemberId(sessionId, memberId) {
    const params = {};
    const url = "/session/v1/public/namespaces/{namespace}/gamesessions/{sessionId}/members/{memberId}/kick".replace("{namespace}", this.namespace).replace("{sessionId}", sessionId).replace("{memberId}", memberId);
    const resultPromise = this.axiosInstance.delete(url, { params });
    return import_sdk29.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, import_zod72.z.unknown(), "z.unknown()");
  }
};

// src/generated-public/endpoints/Party$.ts
var import_sdk30 = require("@accelbyte/sdk");
var import_zod73 = require("zod");
var Party$ = class {
  // @ts-ignore
  // prettier-ignore
  constructor(axiosInstance, namespace, useSchemaValidation = true) {
    this.axiosInstance = axiosInstance;
    this.namespace = namespace;
    this.useSchemaValidation = useSchemaValidation;
  }
  /**
   * A join code will be autogenerated if the party is joinable. A user can be in 1 party at a time, therefore the requester will be removed from their previous party (if any) and automatically added/joined into this newly created party as a leader. Session configuration name is optional. Default configuration name if empty: { &#34;name&#34;: &#34;default&#34;, &#34;type&#34;: &#34;NONE&#34;, &#34;joinability&#34;: &#34;OPEN&#34;, &#34;minPlayers&#34;: 1, &#34;maxPlayers&#34;: 8, &#34;inviteTimeout&#34;: 60, &#34;inactiveTimeout&#34;: 60, &#34;textChat&#34;: false } When session configuration &#34;name&#34; is provided, we will refer to the template if these fields are empty: - textChat - minPlayers - maxPlayers - inviteTimeout - inactiveTimeout - type - joinability - configurationName - attributes Supported platforms: 1. STEAM 2. PSN 3. XBOX Reserved attributes key: 1. preference: used to store preference of the leader and it is non-replaceable to keep the initial behavior of the session regardless the leader changes. 2. NATIVESESSIONTITLE: used for session sync, to define name of session displayed on PlayStation system UI. Session has 2 fields for user status: &#34;status&#34; and &#34;statusV2&#34;. The &#34;status&#34; is there for backward-compatibility, therefore we encourage to just rely on &#34;statusV2&#34; for the more updated statuses. User statuses: 1. INVITED: by default, to join a session (except session with OPEN joinability or if session configuration has &#34;autoJoin&#34; sets to True) a user will receive an invite. The invitee will have the chance to respond within &#34;inviteTimeout&#34; which you can configure through session configuration. 2. TIMEOUT: when a user is invited to a session, they will receive an invite. Unless &#34;disableResendInvite&#34; sets to True in the session configuration, the user will also receive invite reminder every 30s until they respond to the invite. 3. REJECTED: when a user rejects an invite. To rejoin an INVITE_ONLY session, they will need to be re-invited and accept the invite. 4. JOINED: there are few ways of a user to join a session, by invite, direct join (depends on session joinability) or join by code. upon invite, once a user accepts an invite, their status will be changed to JOINED. 5. LEFT: user can leave a session. in case of party, a user can only be in 1 party at a time. therefore when they decide to create or join another party, they will be automatically removed from their initial party and their status will be changed to LEFT. 6. KICKED: only party leader can kick a member. 7. DISCONNECTED: if user still have reserved seat in the session and they disconnect lobby websocket, their status in the session will be changed to DISCONNECTED and field &#34;members.previousStatus&#34; of that user will contains the initial status before they disconnect lobby websocket. the user will be given chance to reconnect within &#34;inactiveTimeout&#34; which you can configure through session configuration. 8. CONNECTED: when a user reconnect their lobby websocket, their status will change from DISCONNECTED to CONNECTED, only if they previously JOINED session. if they were on INVITED state before the disconnect happened, the user&#39;s status will return back to INVITED after they reconnect. 9. DROPPED: when &#34;inactiveTimeout&#34; is due and user never re-establish their websocket connection, we will drop them from the session. 10. TERMINATED: only applies to game session. If a game session (match) is ended, DS will end/delete the session and we will mark all remaining users&#39; status to be TERMINATED. 11. CANCELLED: when a session joinability changes to CLOSED, any remaining invites will be canceled. User is considered as active if they&#39;re present in the session, which their status either CONNECTED or JOINED. User has a reserved seat in the session if their status either INVITED, JOINED, CONNECTED, DISCONNECTED. When user&#39;s&#39; status change to other than these mentioned statuses, we will release the seat for other players to occupy. Managing the relation between session and lobby websocket connection: - Session relies on lobby to consider player&#39;s connection health to our backend. therefore a disruption to lobby websocket will be reflected in the user&#39;s status in all of their session(s). - If user still have a reserved seat in the session and they disconnect lobby websocket, their status in session(s) will be changed to DISCONNECTED and field &#34;members.previousStatus&#34; of that user will contains the initial status before they disconnect lobby websocket. This &#34;members.previousStatus&#34; used to track user&#39;s previous status before they disconnect websocket, since we still reserve a seat for them, therefore this field will be empty again after they websocket. - If the disconnected user is the leader of the session they&#39;re disconnected from, we will wait until &#34;leaderElectionGracePeriod&#34; is due, to promote the next oldest member as the new leader of the session. You can configure &#34;leaderElectionGracePeriod&#34; through session configuration. - The user will be given chance to reconnect within &#34;inactiveTimeout&#34; which you can configure through session configuration. If until &#34;inactiveTimeout&#34; is due and the user doesn&#39;t reconnect their websocket, they will be removed from session and their status will change to DROPPED. If the dropped user was the leader of the session, we will promote the next oldest member as leader. - By default, we will update user&#39;s status to what it was before disconnect, when the user reconnects lobby websocket, unless &#34;manualRejoin&#34; sets to True in the session configuration. When &#34;manualRejoin&#34; is enabled, after lobby websocket reconnect, the game client will need to manually invoke join session again to rejoin the session. - If the user was on INVITED state before the disconnect happened, the user&#39;s status will return back to INVITED after they reconnect.
   */
  createParty(data) {
    const params = {};
    const url = "/session/v1/public/namespaces/{namespace}/party".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.post(url, data, { params });
    return import_sdk30.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, PartySessionResponse, "PartySessionResponse");
  }
  /**
   * Query user&#39;s parties. By default, API will return a list of user&#39;s active parties.
   */
  getUsersMeParties(queryParams) {
    const params = { ...queryParams };
    const url = "/session/v1/public/namespaces/{namespace}/users/me/parties".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.get(url, { params });
    return import_sdk30.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, PartyQueryResponse, "PartyQueryResponse");
  }
  /**
   * Get party details.
   */
  getParty_ByPartyId(partyId) {
    const params = {};
    const url = "/session/v1/public/namespaces/{namespace}/parties/{partyId}".replace("{namespace}", this.namespace).replace("{partyId}", partyId);
    const resultPromise = this.axiosInstance.get(url, { params });
    return import_sdk30.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, PartySessionResponse, "PartySessionResponse");
  }
  /**
   * Update specified fields from party data. Note: Join type can only be updated by the party&#39;s leader. Reserved attributes key: 1. preference: used to store preference of the leader and it is non-replaceable to keep the initial behavior of the session regardless the leader changes. 2. NATIVESESSIONTITLE: used for session sync, to define name of session displayed on PlayStation system UI.
   */
  patchParty_ByPartyId(partyId, data) {
    const params = {};
    const url = "/session/v1/public/namespaces/{namespace}/parties/{partyId}".replace("{namespace}", this.namespace).replace("{partyId}", partyId);
    const resultPromise = this.axiosInstance.patch(url, data, { params });
    return import_sdk30.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, PartySessionResponse, "PartySessionResponse");
  }
  /**
   * Updates party blob, this endpoint will override stored party data. Join type can only be updated by the party&#39;s leader. To update only specified fields, please use following endpoint: method : PATCH API : /session/v1/public/namespaces/{namespace}/gamesessions/{sessionId} Reserved attributes key: 1. preference: used to store preference of the leader and it is non-replaceable to keep the initial behavior of the session regardless the leader changes. 2. NATIVESESSIONTITLE: used for session sync, to define name of session displayed on PlayStation system UI.
   */
  updateParty_ByPartyId(partyId, data) {
    const params = {};
    const url = "/session/v1/public/namespaces/{namespace}/parties/{partyId}".replace("{namespace}", this.namespace).replace("{partyId}", partyId);
    const resultPromise = this.axiosInstance.put(url, data, { params });
    return import_sdk30.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, PartySessionResponse, "PartySessionResponse");
  }
  /**
   * Revoke code of the party. Only leader can revoke a code.
   */
  deleteCode_ByPartyId(partyId) {
    const params = {};
    const url = "/session/v1/public/namespaces/{namespace}/parties/{partyId}/code".replace("{namespace}", this.namespace).replace("{partyId}", partyId);
    const resultPromise = this.axiosInstance.delete(url, { params });
    return import_sdk30.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, import_zod73.z.unknown(), "z.unknown()");
  }
  /**
   * Generate a new code for the party. Only leader can generate a code.
   */
  updateCode_ByPartyId(partyId) {
    const params = {};
    const url = "/session/v1/public/namespaces/{namespace}/parties/{partyId}/code".replace("{namespace}", this.namespace).replace("{partyId}", partyId);
    const resultPromise = this.axiosInstance.post(url, null, { params });
    return import_sdk30.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, PartySessionResponse, "PartySessionResponse");
  }
  /**
   * Invite a user to a party. platformID represents the native platform of the invitee. API will return the corresponding native platform&#39;s userID. supported platforms: - STEAM - XBOX - PSN
   */
  createInvite_ByPartyId(partyId, data) {
    const params = {};
    const url = "/session/v1/public/namespaces/{namespace}/parties/{partyId}/invite".replace("{namespace}", this.namespace).replace("{partyId}", partyId);
    const resultPromise = this.axiosInstance.post(url, data, { params });
    return import_sdk30.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, SessionInviteResponse, "SessionInviteResponse");
  }
  /**
   * Promotes a party member to be a party leader. Only leader can promote a new leader.
   */
  updateLeader_ByPartyId(partyId, data) {
    const params = {};
    const url = "/session/v1/public/namespaces/{namespace}/parties/{partyId}/leader".replace("{namespace}", this.namespace).replace("{partyId}", partyId);
    const resultPromise = this.axiosInstance.post(url, data, { params });
    return import_sdk30.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, PartySessionResponse, "PartySessionResponse");
  }
  /**
   * Join a party by code. The user can join a party as long as the code is valid
   */
  createPartyUserMeJoinCode(data) {
    const params = {};
    const url = "/session/v1/public/namespaces/{namespace}/parties/users/me/join/code".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.post(url, data, { params });
    return import_sdk30.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, PartySessionResponse, "PartySessionResponse");
  }
  /**
   * Join a party. The user can either join a party they have been invited to, or any party with an &#34;open&#34; joinable setting.
   */
  createUserMeJoin_ByPartyId(partyId) {
    const params = {};
    const url = "/session/v1/public/namespaces/{namespace}/parties/{partyId}/users/me/join".replace("{namespace}", this.namespace).replace("{partyId}", partyId);
    const resultPromise = this.axiosInstance.post(url, null, { params });
    return import_sdk30.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, PartySessionResponse, "PartySessionResponse");
  }
  /**
   * Leave a party
   */
  deleteUserMeLeave_ByPartyId(partyId) {
    const params = {};
    const url = "/session/v1/public/namespaces/{namespace}/parties/{partyId}/users/me/leave".replace("{namespace}", this.namespace).replace("{partyId}", partyId);
    const resultPromise = this.axiosInstance.delete(url, { params });
    return import_sdk30.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, import_zod73.z.unknown(), "z.unknown()");
  }
  /**
   * Reject a party invitation.
   */
  deleteUserMeReject_ByPartyId(partyId) {
    const params = {};
    const url = "/session/v1/public/namespaces/{namespace}/parties/{partyId}/users/me/reject".replace("{namespace}", this.namespace).replace("{partyId}", partyId);
    const resultPromise = this.axiosInstance.delete(url, { params });
    return import_sdk30.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, import_zod73.z.unknown(), "z.unknown()");
  }
  /**
   * Kick a player from a party. Requires invoker to be the party leader.
   */
  deleteKick_ByPartyId_ByUserId(partyId, userId) {
    const params = {};
    const url = "/session/v1/public/namespaces/{namespace}/parties/{partyId}/users/{userId}/kick".replace("{namespace}", this.namespace).replace("{partyId}", partyId).replace("{userId}", userId);
    const resultPromise = this.axiosInstance.delete(url, { params });
    return import_sdk30.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, KickResponse, "KickResponse");
  }
  /**
   * Cancel a party invitation.
   */
  deleteCancel_ByPartyId_ByUserId(partyId, userId) {
    const params = {};
    const url = "/session/v1/public/namespaces/{namespace}/parties/{partyId}/users/{userId}/cancel".replace("{namespace}", this.namespace).replace("{partyId}", partyId).replace("{userId}", userId);
    const resultPromise = this.axiosInstance.delete(url, { params });
    return import_sdk30.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, import_zod73.z.unknown(), "z.unknown()");
  }
};

// src/generated-public/endpoints/Player$.ts
var import_sdk31 = require("@accelbyte/sdk");
var import_zod74 = require("zod");
var Player$ = class {
  // @ts-ignore
  // prettier-ignore
  constructor(axiosInstance, namespace, useSchemaValidation = true) {
    this.axiosInstance = axiosInstance;
    this.namespace = namespace;
    this.useSchemaValidation = useSchemaValidation;
  }
  /**
   * Get bulk players current platform.
   */
  fetchUserBulkPlatform(data) {
    const params = {};
    const url = "/session/v1/public/namespaces/{namespace}/users/bulk/platform".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.post(url, data, { params });
    return import_sdk31.Validate.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      PlayersCurrentPlatformResponse,
      "PlayersCurrentPlatformResponse"
    );
  }
  /**
   * Reset player attributes.
   */
  deleteUserMeAttribute() {
    const params = {};
    const url = "/session/v1/public/namespaces/{namespace}/users/me/attributes".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.delete(url, { params });
    return import_sdk31.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, import_zod74.z.unknown(), "z.unknown()");
  }
  /**
   * Get player attributes. Field descriptions: - userID : user who owns the attributes. - crossplayEnabled : set to true if the player wants to enable crossplay to their session (default: false). - platforms : list of the player&#39;s 3rd party platform account information. - name : platform name. supported platforms: STEAM, XBOX, PSN - userID : platform userID - data : other data that the player wants to store. - PSN_PUSH_CONTEXT_ID: if provided, session will refer to this when performing session sync with PSN, otherwise will populate from session attributes - currentPlatform : latest user game platform. - roles : user role for matchmaking role base support.
   */
  getUsersMeAttributes() {
    const params = {};
    const url = "/session/v1/public/namespaces/{namespace}/users/me/attributes".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.get(url, { params });
    return import_sdk31.Validate.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      PlayerAttributesResponseBody,
      "PlayerAttributesResponseBody"
    );
  }
  /**
   * This API behaves to upsert player&#39;s attributes. Field descriptions: - userID : user who owns the attributes. - crossplayEnabled : set to true if the player wants to enable crossplay to their session (default: false). - platforms : list of the player&#39;s 3rd party platform account information. - name : platform name. supported platforms: STEAM, XBOX, PSN - userID : platform userID - data : other data that the player wants to store. - PSN_PUSH_CONTEXT_ID: if provided, session will refer to this when performing session sync with PSN, otherwise will populate from session attributes - currentPlatform : latest user game platform. - roles : user role for matchmaking role base support.
   */
  createUserMeAttribute(data) {
    const params = {};
    const url = "/session/v1/public/namespaces/{namespace}/users/me/attributes".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.post(url, data, { params });
    return import_sdk31.Validate.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      PlayerAttributesResponseBody,
      "PlayerAttributesResponseBody"
    );
  }
};

// src/generated-public/endpoints/RecentPlayer$.ts
var import_sdk32 = require("@accelbyte/sdk");
var RecentPlayer$ = class {
  // @ts-ignore
  // prettier-ignore
  constructor(axiosInstance, namespace, useSchemaValidation = true) {
    this.axiosInstance = axiosInstance;
    this.namespace = namespace;
    this.useSchemaValidation = useSchemaValidation;
  }
  /**
   * Query user&#39;s recent player. Please ensure environment variable &#34;RECENT_PLAYER_ENABLED&#34; is set to &#34;TRUE&#34; to use this feature.
   */
  getRecentPlayer(queryParams) {
    const params = { limit: 20, ...queryParams };
    const url = "/session/v1/public/namespaces/{namespace}/recent-player".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.get(url, { params });
    return import_sdk32.Validate.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      RecentPlayerQueryResponse,
      "RecentPlayerQueryResponse"
    );
  }
  /**
   * Query user&#39;s recent player who were on the same team. Please ensure environment variable &#34;RECENT_TEAM_PLAYER_ENABLED&#34; is set to &#34;TRUE&#34; to use this feature.
   */
  getRecentTeamPlayer(queryParams) {
    const params = { limit: 20, ...queryParams };
    const url = "/session/v1/public/namespaces/{namespace}/recent-team-player".replace("{namespace}", this.namespace);
    const resultPromise = this.axiosInstance.get(url, { params });
    return import_sdk32.Validate.validateOrReturnResponse(
      this.useSchemaValidation,
      () => resultPromise,
      RecentPlayerQueryResponse,
      "RecentPlayerQueryResponse"
    );
  }
};

// src/generated-public/endpoints/SessionStorage$.ts
var import_sdk33 = require("@accelbyte/sdk");
var import_zod75 = require("zod");
var SessionStorage$ = class {
  // @ts-ignore
  // prettier-ignore
  constructor(axiosInstance, namespace, useSchemaValidation = true) {
    this.axiosInstance = axiosInstance;
    this.namespace = namespace;
    this.useSchemaValidation = useSchemaValidation;
  }
  /**
   *  Update Insert Session Storage Leader. only Leader can update or insert user session storage data Leader. can store generic json example json can store : { &#34;leader&#34;: { &#34;leader&#34;: 1 }, &#34;data&#34;: 123 } game Admin can update or insert session storage Session Storage feature only available for Gamesession
   */
  patchStorageLeader_BySessionId(sessionId) {
    const params = {};
    const url = "/session/v1/public/namespaces/{namespace}/sessions/{sessionId}/storage/leader".replace("{namespace}", this.namespace).replace("{sessionId}", sessionId);
    const resultPromise = this.axiosInstance.patch(url, null, { params });
    return import_sdk33.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, import_zod75.z.unknown(), "z.unknown()");
  }
  /**
   *  Update Insert Session Storage User. user can only update or insert user session storage data itself. can store generic json example json can store : { &#34;storage&#34;: { &#34;storage&#34;: 1 }, &#34;data&#34;: 123 } game Admin can update or insert session storage Session Storage feature only available for Gamesession
   */
  patchStorageUser_BySessionId_ByUserId(sessionId, userId) {
    const params = {};
    const url = "/session/v1/public/namespaces/{namespace}/sessions/{sessionId}/storage/users/{userId}".replace("{namespace}", this.namespace).replace("{sessionId}", sessionId).replace("{userId}", userId);
    const resultPromise = this.axiosInstance.patch(url, null, { params });
    return import_sdk33.Validate.validateOrReturnResponse(this.useSchemaValidation, () => resultPromise, import_zod75.z.unknown(), "z.unknown()");
  }
};

// src/generated-public/GameSessionApi.ts
var import_sdk34 = require("@accelbyte/sdk");
function GameSessionApi(sdk, args) {
  const sdkAssembly = sdk.assembly();
  const namespace = args?.coreConfig?.namespace ?? sdkAssembly.coreConfig.namespace;
  const useSchemaValidation = args?.coreConfig?.useSchemaValidation ?? sdkAssembly.coreConfig.useSchemaValidation;
  let axiosInstance = sdkAssembly.axiosInstance;
  const requestConfigOverrides = args?.axiosConfig?.request;
  const baseURLOverride = args?.coreConfig?.baseURL;
  const interceptorsOverride = args?.axiosConfig?.interceptors ?? [];
  if (requestConfigOverrides || baseURLOverride || interceptorsOverride.length > 0) {
    const requestConfig = import_sdk34.ApiUtils.mergeAxiosConfigs(sdkAssembly.axiosInstance.defaults, {
      ...baseURLOverride ? { baseURL: baseURLOverride } : {},
      ...requestConfigOverrides
    });
    axiosInstance = import_sdk34.Network.create(requestConfig);
    for (const interceptor of interceptorsOverride) {
      if (interceptor.type === "request") {
        axiosInstance.interceptors.request.use(interceptor.onRequest, interceptor.onError);
      }
      if (interceptor.type === "response") {
        axiosInstance.interceptors.response.use(interceptor.onSuccess, interceptor.onError);
      }
    }
  }
  async function createGamesession(data) {
    const $ = new GameSession$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.createGamesession(data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function createGamesession_ByNS() {
    const $ = new GameSession$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.createGamesession_ByNS();
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getUsersMeGamesessions(queryParams) {
    const $ = new GameSession$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getUsersMeGamesessions(queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function createGamesessionJoinCode(data) {
    const $ = new GameSession$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.createGamesessionJoinCode(data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function deleteGamesession_BySessionId(sessionId) {
    const $ = new GameSession$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.deleteGamesession_BySessionId(sessionId);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getGamesession_BySessionId(sessionId) {
    const $ = new GameSession$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getGamesession_BySessionId(sessionId);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function patchGamesession_BySessionId(sessionId, data) {
    const $ = new GameSession$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.patchGamesession_BySessionId(sessionId, data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function updateGamesession_BySessionId(sessionId, data) {
    const $ = new GameSession$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.updateGamesession_BySessionId(sessionId, data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function deleteCode_BySessionId(sessionId) {
    const $ = new GameSession$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.deleteCode_BySessionId(sessionId);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function updateCode_BySessionId(sessionId) {
    const $ = new GameSession$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.updateCode_BySessionId(sessionId);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function createJoin_BySessionId(sessionId) {
    const $ = new GameSession$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.createJoin_BySessionId(sessionId);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function deleteLeave_BySessionId(sessionId) {
    const $ = new GameSession$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.deleteLeave_BySessionId(sessionId);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function updateTeam_BySessionId(sessionId, data) {
    const $ = new GameSession$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.updateTeam_BySessionId(sessionId, data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getGamesessionServer_ByPodName(podName) {
    const $ = new GameSession$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getGamesessionServer_ByPodName(podName);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function createInvite_BySessionId(sessionId, data) {
    const $ = new GameSession$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.createInvite_BySessionId(sessionId, data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function updateLeader_BySessionId(sessionId, data) {
    const $ = new GameSession$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.updateLeader_BySessionId(sessionId, data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function deleteReject_BySessionId(sessionId) {
    const $ = new GameSession$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.deleteReject_BySessionId(sessionId);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getSecret_BySessionId(sessionId) {
    const $ = new GameSession$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getSecret_BySessionId(sessionId);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function updateBackfill_BySessionId(sessionId, data) {
    const $ = new GameSession$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.updateBackfill_BySessionId(sessionId, data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function deleteCancel_BySessionId_ByUserId(sessionId, userId) {
    const $ = new GameSession$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.deleteCancel_BySessionId_ByUserId(sessionId, userId);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function deleteKick_BySessionId_ByMemberId(sessionId, memberId) {
    const $ = new GameSession$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.deleteKick_BySessionId_ByMemberId(sessionId, memberId);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  return {
    /**
     * Create a game session. Session configuration &#34;name&#34; is mandatory, this API will refer following values from the session template if they&#39;re not provided in the request: - type - joinability - autoJoin. If enabled (set to true), players provided in the request will automatically joined the initial game session creation. Game session will not send any invite and players dont need to act upon it. - minPlayers - maxPlayers - inviteTimeout - inactiveTimeout - attributes - dsSource - tieTeamsSessionLifetime - matchPool - clientVersion - deployment - serverName - textChat - autoJoin - requestedRegions - dsSource - preferredClaimKeys - fallbackClaimKeys - customURLGRPC When the tieTeamsSessionLifetime is true, the lifetime of any partyId inside teams attribute will be tied to the game session. Only applies when the teams partyId is a game session. Session has 2 fields for user status: &#34;status&#34; and &#34;statusV2&#34;. The &#34;status&#34; is there for backward-compatibility, therefore we encourage to just rely on &#34;statusV2&#34; for the more updated statuses. User statuses: 1. INVITED: by default, to join a session (except session with OPEN joinability or if session configuration has &#34;autoJoin&#34; sets to True) a user will receive an invite. The invitee will have the chance to respond within &#34;inviteTimeout&#34; which you can configure through session configuration. 2. TIMEOUT: when a user is invited to a session, they will receive an invite. Unless &#34;disableResendInvite&#34; sets to True in the session configuration, the user will also receive invite reminder every 30s until they respond to the invite. 3. REJECTED: when a user rejects an invite. To rejoin an INVITE_ONLY session, they will need to be re-invited and accept the invite. 4. JOINED: there are few ways of a user to join a session, by invite, direct join (depends on session joinability) or join by code. upon invite, once a user accepts an invite, their status will be changed to JOINED. 5. LEFT: user can leave a session. in case of party, a user can only be in 1 party at a time. therefore when they decide to create or join another party, they will be automatically removed from their initial party and their status will be changed to LEFT. 6. KICKED: only party leader can kick a member. 7. DISCONNECTED: if user still have reserved seat in the session and they disconnect lobby websocket, their status in the session will be changed to DISCONNECTED and field &#34;members.previousStatus&#34; of that user will contains the initial status before they disconnect lobby websocket. the user will be given chance to reconnect within &#34;inactiveTimeout&#34; which you can configure through session configuration. 8. CONNECTED: when a user reconnect their lobby websocket, their status will change from DISCONNECTED to CONNECTED, only if they previously JOINED session. if they were on INVITED state before the disconnect happened, the user&#39;s status will return back to INVITED after they reconnect. 9. DROPPED: when &#34;inactiveTimeout&#34; is due and user never re-establish their websocket connection, we will drop them from the session. 10. TERMINATED: only applies to game session. If a game session (match) is ended, DS will end/delete the session and we will mark all remaining users&#39; status to be TERMINATED. 11. CANCELLED: when a session joinability changes to CLOSED, any remaining invites will be canceled. User is considered as active if they&#39;re present in the session, which their status either CONNECTED or JOINED. User has a reserved seat in the session if their status either INVITED, JOINED, CONNECTED, DISCONNECTED. When user&#39;s&#39; status change to other than these mentioned statuses, we will release the seat for other players to occupy. Managing the relation between session and lobby websocket connection: - Session relies on lobby to consider player&#39;s connection health to our backend. therefore a disruption to lobby websocket will be reflected in the user&#39;s status in all of their session(s). - If user still have a reserved seat in the session and they disconnect lobby websocket, their status in session(s) will be changed to DISCONNECTED and field &#34;members.previousStatus&#34; of that user will contains the initial status before they disconnect lobby websocket. This &#34;members.previousStatus&#34; used to track user&#39;s previous status before they disconnect websocket, since we still reserve a seat for them, therefore this field will be empty again after they websocket. - If the disconnected user is the leader of the session they&#39;re disconnected from, we will wait until &#34;leaderElectionGracePeriod&#34; is due, to promote the next oldest member as the new leader of the session. You can configure &#34;leaderElectionGracePeriod&#34; through session configuration. - The user will be given chance to reconnect within &#34;inactiveTimeout&#34; which you can configure through session configuration. If until &#34;inactiveTimeout&#34; is due and the user doesn&#39;t reconnect their websocket, they will be removed from session and their status will change to DROPPED. If the dropped user was the leader of the session, we will promote the next oldest member as leader. - By default, we will update user&#39;s status to what it was before disconnect, when the user reconnects lobby websocket, unless &#34;manualRejoin&#34; sets to True in the session configuration. When &#34;manualRejoin&#34; is enabled, after lobby websocket reconnect, the game client will need to manually invoke join session again to rejoin the session. - If the user was on INVITED state before the disconnect happened, the user&#39;s status will return back to INVITED after they reconnect. When the session type is a DS, a DS creation request will be sent if number of active players reaches session&#39;s minPlayers. Session service has several DSInformation status to track DS request to DS providers: - NEED_TO_REQUEST: number of active players hasn&#39;t reached session&#39;s minPlayers therefore DS has not yet requested. - REQUESTED: DS is being requested to DSMC. - PREPARING: DS needs to call manual set ready for the game session - AVAILABLE: DS is ready to use. The DSMC status for this DS is either READY/BUSY. - FAILED_TO_REQUEST: DSMC fails to spin up a DS for session. - DS_ERROR: DS provider fails to spin up the DS or the DS itself becomes unreachable - DS_CANCELLED: when DSMC is preparing the DS, DSMC will give a temporary DS. In this phase, if you delete the game session, the DS request will be canceled. - ENDED: when a game session (match) has finished and DS has done its job, it will terminate itself. - UNKNOWN: if any unknown DS status is detected. DSInformation has 2 fields for DS status: &#34;status&#34; and &#34;statusV2&#34;. The &#34;status&#34; is there for backward-compatibility, therefore we encourage to just rely on &#34;statusV2&#34; for the more updated statuses. DS Source can be DSMC, AMS or custom. In DSMC, a DS request will be put in queue if they dont have available buffers, and DSMC will let the service knows when they finished spinning it up. While AMS doesn&#39;t have a concept of queue. Therefore some &#34;DSInformation.statusV2&#34; only applicable for DSMC. By default, DS requests are sent to DSMC, but if dsSource is set to &#34;AMS&#34;: - A DS will be requested from AMS instead of DSMC. - The server will be chosen based on a set of claim keys, in order of preference, to match with fleets. - The claim key list is built build from the preferredClaimKeys, fallbackClaimKeys, and clientVersion as follows: [preferredClaimKeys.., clientVersion, fallbackClaimKeys...] for session override can follow guideline in here https://docs.accelbyte.io/gaming-services/services/extend/override-ags-feature/getting-started-with-session-customization/
     */
    createGamesession,
    /**
     * Query game sessions. By default, API will return a list of available game sessions (joinability: open). Session service has several DSInformation status to track DS request to DS providers: - NEED_TO_REQUEST: number of active players hasn&#39;t reached session&#39;s minPlayers therefore DS has not yet requested. - REQUESTED: DS is being requested to DSMC. - PREPARING: DS needs to call manual set ready for the game session - AVAILABLE: DS is ready to use. The DSMC status for this DS is either READY/BUSY. - FAILED_TO_REQUEST: DSMC fails to spin up a DS for session. - DS_ERROR: DS provider fails to spin up the DS or the DS itself becomes unreachable - DS_CANCELLED: when DSMC is preparing the DS, DSMC will give a temporary DS. In this phase, if you delete the game session, the DS request will be canceled. - ENDED: when a game session (match) has finished and DS has done its job, it will terminate itself. - UNKNOWN: if any unknown DS status is detected. DSInformation has 2 fields for DS status: &#34;status&#34; and &#34;statusV2&#34;. The &#34;status&#34; is there for backward-compatibility, therefore we encourage to just rely on &#34;statusV2&#34; for the more updated statuses. DS Source can be DSMC, AMS or custom. In DSMC, a DS request will be put in queue if they dont have available buffers, and DSMC will let the service knows when they finished spinning it up. While AMS doesn&#39;t have a concept of queue. Therefore some &#34;DSInformation.statusV2&#34; only applicable for DSMC. query parameter \&#34;availability\&#34; to filter sessions&#39; availability: all: return all sessions regardless it&#39;s full full: only return active sessions default behavior (unset or else): return only available sessions (not full)
     */
    createGamesession_ByNS,
    /**
     * Query user&#39;s game sessions. By default, API will return a list of user&#39;s active game sessions (INVITED,JOINED,CONNECTED). Session service has several DSInformation status to track DS request to DS providers: - NEED_TO_REQUEST: number of active players hasn&#39;t reached session&#39;s minPlayers therefore DS has not yet requested. - REQUESTED: DS is being requested to DSMC. - PREPARING: DS needs to call manual set ready for the game session - AVAILABLE: DS is ready to use. The DSMC status for this DS is either READY/BUSY. - FAILED_TO_REQUEST: DSMC fails to spin up a DS for session. - DS_ERROR: DS provider fails to spin up the DS or the DS itself becomes unreachable - DS_CANCELLED: when DSMC is preparing the DS, DSMC will give a temporary DS. In this phase, if you delete the game session, the DS request will be canceled. - ENDED: when a game session (match) has finished and DS has done its job, it will terminate itself. - UNKNOWN: if any unknown DS status is detected. DSInformation has 2 fields for DS status: &#34;status&#34; and &#34;statusV2&#34;. The &#34;status&#34; is there for backward-compatibility, therefore we encourage to just rely on &#34;statusV2&#34; for the more updated statuses. DS Source can be DSMC, AMS or custom. In DSMC, a DS request will be put in queue if they dont have available buffers, and DSMC will let the service knows when they finished spinning it up. While AMS doesn&#39;t have a concept of queue. Therefore some &#34;DSInformation.statusV2&#34; only applicable for DSMC.
     */
    getUsersMeGamesessions,
    /**
     * Join a session by code. The user can join a session as long as the code is valid
     */
    createGamesessionJoinCode,
    /**
     * Delete a game session.
     */
    deleteGamesession_BySessionId,
    /**
     * Get game session detail. Session will only be accessible from active players in the session, and client with the permission, except the joinability is set to OPEN. Session service has several DSInformation status to track DS request to DS providers: - NEED_TO_REQUEST: number of active players hasn&#39;t reached session&#39;s minPlayers therefore DS has not yet requested. - REQUESTED: DS is being requested to DSMC. - PREPARING: DS needs to call manual set ready for the game session - AVAILABLE: DS is ready to use. The DSMC status for this DS is either READY/BUSY. - FAILED_TO_REQUEST: DSMC fails to spin up a DS for session. - DS_ERROR: DS provider fails to spin up the DS or the DS itself becomes unreachable - DS_CANCELLED: when DSMC is preparing the DS, DSMC will give a temporary DS. In this phase, if you delete the game session, the DS request will be canceled. - ENDED: when a game session (match) has finished and DS has done its job, it will terminate itself. - UNKNOWN: if any unknown DS status is detected. DSInformation has 2 fields for DS status: &#34;status&#34; and &#34;statusV2&#34;. The &#34;status&#34; is there for backward-compatibility, therefore we encourage to just rely on &#34;statusV2&#34; for the more updated statuses. DS Source can be DSMC, AMS or custom. In DSMC, a DS request will be put in queue if they dont have available buffers, and DSMC will let the service knows when they finished spinning it up. While AMS doesn&#39;t have a concept of queue. Therefore some &#34;DSInformation.statusV2&#34; only applicable for DSMC.
     */
    getGamesession_BySessionId,
    /**
     * Update specified fields from game session data.
     */
    patchGamesession_BySessionId,
    /**
     * Updates a game session, this endpoint will override stored gamesession data. To update only specified fields, please use following endpoint: method : PATCH API : /session/v1/public/namespaces/{namespace}/gamesessions/{sessionId} To update DS attributes (clientVersion, deployment, requestedRegions) it will only be applied only as long as no DS has been requested, otherwise ignored.
     */
    updateGamesession_BySessionId,
    /**
     * Revoke code of the game session. Only leader can revoke a code.
     */
    deleteCode_BySessionId,
    /**
     * Generate a new code for the game session. Only leader can generate a code.
     */
    updateCode_BySessionId,
    /**
     * Join a game session.
     */
    createJoin_BySessionId,
    /**
     * Leave a game session.
     */
    deleteLeave_BySessionId,
    /**
     * Append new member or team to session
     */
    updateTeam_BySessionId,
    /**
     * Get game session detail by podname. Session service has several DSInformation status to track DS request to DS providers: - NEED_TO_REQUEST: number of active players hasn&#39;t reached session&#39;s minPlayers therefore DS has not yet requested. - REQUESTED: DS is being requested to DSMC. - PREPARING: DS needs to call manual set ready for the game session - AVAILABLE: DS is ready to use. The DSMC status for this DS is either READY/BUSY. - FAILED_TO_REQUEST: DSMC fails to spin up a DS for session. - DS_ERROR: DS provider fails to spin up the DS or the DS itself becomes unreachable - DS_CANCELLED: when DSMC is preparing the DS, DSMC will give a temporary DS. In this phase, if you delete the game session, the DS request will be canceled. - ENDED: when a game session (match) has finished and DS has done its job, it will terminate itself. - UNKNOWN: if any unknown DS status is detected. DSInformation has 2 fields for DS status: &#34;status&#34; and &#34;statusV2&#34;. The &#34;status&#34; is there for backward-compatibility, therefore we encourage to just rely on &#34;statusV2&#34; for the more updated statuses. DS Source can be DSMC, AMS or custom. In DSMC, a DS request will be put in queue if they dont have available buffers, and DSMC will let the service knows when they finished spinning it up. While AMS doesn&#39;t have a concept of queue. Therefore some &#34;DSInformation.statusV2&#34; only applicable for DSMC.
     */
    getGamesessionServer_ByPodName,
    /**
     * Invite a user to a game session. platformID represents the native platform of the invitee. API will return the corresponding native platform&#39;s userID. supported platforms: - STEAM - XBOX - PSN
     */
    createInvite_BySessionId,
    /**
     * Promote game session member to become the new game session leader. This API requires the NAMESPACE:{namespace}:SESSION:GAME [UPDATE] permission. This API can be operated by: - User (game session member) who is the current leader of the game session - Game Client - Dedicated Server (DS) This API will promote game session leader candidate with the following criteria: - Leader candidate is a member of the game session - Leader candidate has a &#34;CONNECTED&#34; or &#34;JOINED&#34; status - If the leader candidate is the current leader, then no promotion process is carried out
     */
    updateLeader_BySessionId,
    /**
     * Reject a game session invitation.
     */
    deleteReject_BySessionId,
    /**
     *  Used by game Client to Get Secret constraints - EnableSecret = true - Type = &#34;DS&#34; - secret value will only be produced if enableSecret is true and type is DS if enableSecret = false - empty secret will be returned as 200 OK Expected caller of this API - Game Client to get server secret In the Response you will get following: - 200 OK { &#34;secret&#34;: &lt;string&gt; } If there is error: - 400 Invalid path parameters - 401 unauthorized - 404 StatusNotFound - 500 Internal server error
     */
    getSecret_BySessionId,
    /**
     * Update game session backfill ticket id. Will override game session backfill ticket based on given request parameter
     */
    updateBackfill_BySessionId,
    /**
     * cancel a game session invitation.
     */
    deleteCancel_BySessionId_ByUserId,
    /**
     * Kick member from a game session, only leader can kick member.
     */
    deleteKick_BySessionId_ByMemberId
  };
}

// src/generated-public/PartyApi.ts
var import_sdk35 = require("@accelbyte/sdk");
function PartyApi(sdk, args) {
  const sdkAssembly = sdk.assembly();
  const namespace = args?.coreConfig?.namespace ?? sdkAssembly.coreConfig.namespace;
  const useSchemaValidation = args?.coreConfig?.useSchemaValidation ?? sdkAssembly.coreConfig.useSchemaValidation;
  let axiosInstance = sdkAssembly.axiosInstance;
  const requestConfigOverrides = args?.axiosConfig?.request;
  const baseURLOverride = args?.coreConfig?.baseURL;
  const interceptorsOverride = args?.axiosConfig?.interceptors ?? [];
  if (requestConfigOverrides || baseURLOverride || interceptorsOverride.length > 0) {
    const requestConfig = import_sdk35.ApiUtils.mergeAxiosConfigs(sdkAssembly.axiosInstance.defaults, {
      ...baseURLOverride ? { baseURL: baseURLOverride } : {},
      ...requestConfigOverrides
    });
    axiosInstance = import_sdk35.Network.create(requestConfig);
    for (const interceptor of interceptorsOverride) {
      if (interceptor.type === "request") {
        axiosInstance.interceptors.request.use(interceptor.onRequest, interceptor.onError);
      }
      if (interceptor.type === "response") {
        axiosInstance.interceptors.response.use(interceptor.onSuccess, interceptor.onError);
      }
    }
  }
  async function createParty(data) {
    const $ = new Party$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.createParty(data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getUsersMeParties(queryParams) {
    const $ = new Party$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getUsersMeParties(queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getParty_ByPartyId(partyId) {
    const $ = new Party$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getParty_ByPartyId(partyId);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function patchParty_ByPartyId(partyId, data) {
    const $ = new Party$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.patchParty_ByPartyId(partyId, data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function updateParty_ByPartyId(partyId, data) {
    const $ = new Party$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.updateParty_ByPartyId(partyId, data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function deleteCode_ByPartyId(partyId) {
    const $ = new Party$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.deleteCode_ByPartyId(partyId);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function updateCode_ByPartyId(partyId) {
    const $ = new Party$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.updateCode_ByPartyId(partyId);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function createInvite_ByPartyId(partyId, data) {
    const $ = new Party$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.createInvite_ByPartyId(partyId, data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function updateLeader_ByPartyId(partyId, data) {
    const $ = new Party$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.updateLeader_ByPartyId(partyId, data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function createPartyUserMeJoinCode(data) {
    const $ = new Party$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.createPartyUserMeJoinCode(data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function createUserMeJoin_ByPartyId(partyId) {
    const $ = new Party$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.createUserMeJoin_ByPartyId(partyId);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function deleteUserMeLeave_ByPartyId(partyId) {
    const $ = new Party$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.deleteUserMeLeave_ByPartyId(partyId);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function deleteUserMeReject_ByPartyId(partyId) {
    const $ = new Party$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.deleteUserMeReject_ByPartyId(partyId);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function deleteKick_ByPartyId_ByUserId(partyId, userId) {
    const $ = new Party$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.deleteKick_ByPartyId_ByUserId(partyId, userId);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function deleteCancel_ByPartyId_ByUserId(partyId, userId) {
    const $ = new Party$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.deleteCancel_ByPartyId_ByUserId(partyId, userId);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  return {
    /**
     * A join code will be autogenerated if the party is joinable. A user can be in 1 party at a time, therefore the requester will be removed from their previous party (if any) and automatically added/joined into this newly created party as a leader. Session configuration name is optional. Default configuration name if empty: { &#34;name&#34;: &#34;default&#34;, &#34;type&#34;: &#34;NONE&#34;, &#34;joinability&#34;: &#34;OPEN&#34;, &#34;minPlayers&#34;: 1, &#34;maxPlayers&#34;: 8, &#34;inviteTimeout&#34;: 60, &#34;inactiveTimeout&#34;: 60, &#34;textChat&#34;: false } When session configuration &#34;name&#34; is provided, we will refer to the template if these fields are empty: - textChat - minPlayers - maxPlayers - inviteTimeout - inactiveTimeout - type - joinability - configurationName - attributes Supported platforms: 1. STEAM 2. PSN 3. XBOX Reserved attributes key: 1. preference: used to store preference of the leader and it is non-replaceable to keep the initial behavior of the session regardless the leader changes. 2. NATIVESESSIONTITLE: used for session sync, to define name of session displayed on PlayStation system UI. Session has 2 fields for user status: &#34;status&#34; and &#34;statusV2&#34;. The &#34;status&#34; is there for backward-compatibility, therefore we encourage to just rely on &#34;statusV2&#34; for the more updated statuses. User statuses: 1. INVITED: by default, to join a session (except session with OPEN joinability or if session configuration has &#34;autoJoin&#34; sets to True) a user will receive an invite. The invitee will have the chance to respond within &#34;inviteTimeout&#34; which you can configure through session configuration. 2. TIMEOUT: when a user is invited to a session, they will receive an invite. Unless &#34;disableResendInvite&#34; sets to True in the session configuration, the user will also receive invite reminder every 30s until they respond to the invite. 3. REJECTED: when a user rejects an invite. To rejoin an INVITE_ONLY session, they will need to be re-invited and accept the invite. 4. JOINED: there are few ways of a user to join a session, by invite, direct join (depends on session joinability) or join by code. upon invite, once a user accepts an invite, their status will be changed to JOINED. 5. LEFT: user can leave a session. in case of party, a user can only be in 1 party at a time. therefore when they decide to create or join another party, they will be automatically removed from their initial party and their status will be changed to LEFT. 6. KICKED: only party leader can kick a member. 7. DISCONNECTED: if user still have reserved seat in the session and they disconnect lobby websocket, their status in the session will be changed to DISCONNECTED and field &#34;members.previousStatus&#34; of that user will contains the initial status before they disconnect lobby websocket. the user will be given chance to reconnect within &#34;inactiveTimeout&#34; which you can configure through session configuration. 8. CONNECTED: when a user reconnect their lobby websocket, their status will change from DISCONNECTED to CONNECTED, only if they previously JOINED session. if they were on INVITED state before the disconnect happened, the user&#39;s status will return back to INVITED after they reconnect. 9. DROPPED: when &#34;inactiveTimeout&#34; is due and user never re-establish their websocket connection, we will drop them from the session. 10. TERMINATED: only applies to game session. If a game session (match) is ended, DS will end/delete the session and we will mark all remaining users&#39; status to be TERMINATED. 11. CANCELLED: when a session joinability changes to CLOSED, any remaining invites will be canceled. User is considered as active if they&#39;re present in the session, which their status either CONNECTED or JOINED. User has a reserved seat in the session if their status either INVITED, JOINED, CONNECTED, DISCONNECTED. When user&#39;s&#39; status change to other than these mentioned statuses, we will release the seat for other players to occupy. Managing the relation between session and lobby websocket connection: - Session relies on lobby to consider player&#39;s connection health to our backend. therefore a disruption to lobby websocket will be reflected in the user&#39;s status in all of their session(s). - If user still have a reserved seat in the session and they disconnect lobby websocket, their status in session(s) will be changed to DISCONNECTED and field &#34;members.previousStatus&#34; of that user will contains the initial status before they disconnect lobby websocket. This &#34;members.previousStatus&#34; used to track user&#39;s previous status before they disconnect websocket, since we still reserve a seat for them, therefore this field will be empty again after they websocket. - If the disconnected user is the leader of the session they&#39;re disconnected from, we will wait until &#34;leaderElectionGracePeriod&#34; is due, to promote the next oldest member as the new leader of the session. You can configure &#34;leaderElectionGracePeriod&#34; through session configuration. - The user will be given chance to reconnect within &#34;inactiveTimeout&#34; which you can configure through session configuration. If until &#34;inactiveTimeout&#34; is due and the user doesn&#39;t reconnect their websocket, they will be removed from session and their status will change to DROPPED. If the dropped user was the leader of the session, we will promote the next oldest member as leader. - By default, we will update user&#39;s status to what it was before disconnect, when the user reconnects lobby websocket, unless &#34;manualRejoin&#34; sets to True in the session configuration. When &#34;manualRejoin&#34; is enabled, after lobby websocket reconnect, the game client will need to manually invoke join session again to rejoin the session. - If the user was on INVITED state before the disconnect happened, the user&#39;s status will return back to INVITED after they reconnect.
     */
    createParty,
    /**
     * Query user&#39;s parties. By default, API will return a list of user&#39;s active parties.
     */
    getUsersMeParties,
    /**
     * Get party details.
     */
    getParty_ByPartyId,
    /**
     * Update specified fields from party data. Note: Join type can only be updated by the party&#39;s leader. Reserved attributes key: 1. preference: used to store preference of the leader and it is non-replaceable to keep the initial behavior of the session regardless the leader changes. 2. NATIVESESSIONTITLE: used for session sync, to define name of session displayed on PlayStation system UI.
     */
    patchParty_ByPartyId,
    /**
     * Updates party blob, this endpoint will override stored party data. Join type can only be updated by the party&#39;s leader. To update only specified fields, please use following endpoint: method : PATCH API : /session/v1/public/namespaces/{namespace}/gamesessions/{sessionId} Reserved attributes key: 1. preference: used to store preference of the leader and it is non-replaceable to keep the initial behavior of the session regardless the leader changes. 2. NATIVESESSIONTITLE: used for session sync, to define name of session displayed on PlayStation system UI.
     */
    updateParty_ByPartyId,
    /**
     * Revoke code of the party. Only leader can revoke a code.
     */
    deleteCode_ByPartyId,
    /**
     * Generate a new code for the party. Only leader can generate a code.
     */
    updateCode_ByPartyId,
    /**
     * Invite a user to a party. platformID represents the native platform of the invitee. API will return the corresponding native platform&#39;s userID. supported platforms: - STEAM - XBOX - PSN
     */
    createInvite_ByPartyId,
    /**
     * Promotes a party member to be a party leader. Only leader can promote a new leader.
     */
    updateLeader_ByPartyId,
    /**
     * Join a party by code. The user can join a party as long as the code is valid
     */
    createPartyUserMeJoinCode,
    /**
     * Join a party. The user can either join a party they have been invited to, or any party with an &#34;open&#34; joinable setting.
     */
    createUserMeJoin_ByPartyId,
    /**
     * Leave a party
     */
    deleteUserMeLeave_ByPartyId,
    /**
     * Reject a party invitation.
     */
    deleteUserMeReject_ByPartyId,
    /**
     * Kick a player from a party. Requires invoker to be the party leader.
     */
    deleteKick_ByPartyId_ByUserId,
    /**
     * Cancel a party invitation.
     */
    deleteCancel_ByPartyId_ByUserId
  };
}

// src/generated-public/PlayerApi.ts
var import_sdk36 = require("@accelbyte/sdk");
function PlayerApi(sdk, args) {
  const sdkAssembly = sdk.assembly();
  const namespace = args?.coreConfig?.namespace ?? sdkAssembly.coreConfig.namespace;
  const useSchemaValidation = args?.coreConfig?.useSchemaValidation ?? sdkAssembly.coreConfig.useSchemaValidation;
  let axiosInstance = sdkAssembly.axiosInstance;
  const requestConfigOverrides = args?.axiosConfig?.request;
  const baseURLOverride = args?.coreConfig?.baseURL;
  const interceptorsOverride = args?.axiosConfig?.interceptors ?? [];
  if (requestConfigOverrides || baseURLOverride || interceptorsOverride.length > 0) {
    const requestConfig = import_sdk36.ApiUtils.mergeAxiosConfigs(sdkAssembly.axiosInstance.defaults, {
      ...baseURLOverride ? { baseURL: baseURLOverride } : {},
      ...requestConfigOverrides
    });
    axiosInstance = import_sdk36.Network.create(requestConfig);
    for (const interceptor of interceptorsOverride) {
      if (interceptor.type === "request") {
        axiosInstance.interceptors.request.use(interceptor.onRequest, interceptor.onError);
      }
      if (interceptor.type === "response") {
        axiosInstance.interceptors.response.use(interceptor.onSuccess, interceptor.onError);
      }
    }
  }
  async function fetchUserBulkPlatform(data) {
    const $ = new Player$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.fetchUserBulkPlatform(data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function deleteUserMeAttribute() {
    const $ = new Player$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.deleteUserMeAttribute();
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getUsersMeAttributes() {
    const $ = new Player$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getUsersMeAttributes();
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function createUserMeAttribute(data) {
    const $ = new Player$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.createUserMeAttribute(data);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  return {
    /**
     * Get bulk players current platform.
     */
    fetchUserBulkPlatform,
    /**
     * Reset player attributes.
     */
    deleteUserMeAttribute,
    /**
     * Get player attributes. Field descriptions: - userID : user who owns the attributes. - crossplayEnabled : set to true if the player wants to enable crossplay to their session (default: false). - platforms : list of the player&#39;s 3rd party platform account information. - name : platform name. supported platforms: STEAM, XBOX, PSN - userID : platform userID - data : other data that the player wants to store. - PSN_PUSH_CONTEXT_ID: if provided, session will refer to this when performing session sync with PSN, otherwise will populate from session attributes - currentPlatform : latest user game platform. - roles : user role for matchmaking role base support.
     */
    getUsersMeAttributes,
    /**
     * This API behaves to upsert player&#39;s attributes. Field descriptions: - userID : user who owns the attributes. - crossplayEnabled : set to true if the player wants to enable crossplay to their session (default: false). - platforms : list of the player&#39;s 3rd party platform account information. - name : platform name. supported platforms: STEAM, XBOX, PSN - userID : platform userID - data : other data that the player wants to store. - PSN_PUSH_CONTEXT_ID: if provided, session will refer to this when performing session sync with PSN, otherwise will populate from session attributes - currentPlatform : latest user game platform. - roles : user role for matchmaking role base support.
     */
    createUserMeAttribute
  };
}

// src/generated-public/RecentPlayerApi.ts
var import_sdk37 = require("@accelbyte/sdk");
function RecentPlayerApi(sdk, args) {
  const sdkAssembly = sdk.assembly();
  const namespace = args?.coreConfig?.namespace ?? sdkAssembly.coreConfig.namespace;
  const useSchemaValidation = args?.coreConfig?.useSchemaValidation ?? sdkAssembly.coreConfig.useSchemaValidation;
  let axiosInstance = sdkAssembly.axiosInstance;
  const requestConfigOverrides = args?.axiosConfig?.request;
  const baseURLOverride = args?.coreConfig?.baseURL;
  const interceptorsOverride = args?.axiosConfig?.interceptors ?? [];
  if (requestConfigOverrides || baseURLOverride || interceptorsOverride.length > 0) {
    const requestConfig = import_sdk37.ApiUtils.mergeAxiosConfigs(sdkAssembly.axiosInstance.defaults, {
      ...baseURLOverride ? { baseURL: baseURLOverride } : {},
      ...requestConfigOverrides
    });
    axiosInstance = import_sdk37.Network.create(requestConfig);
    for (const interceptor of interceptorsOverride) {
      if (interceptor.type === "request") {
        axiosInstance.interceptors.request.use(interceptor.onRequest, interceptor.onError);
      }
      if (interceptor.type === "response") {
        axiosInstance.interceptors.response.use(interceptor.onSuccess, interceptor.onError);
      }
    }
  }
  async function getRecentPlayer(queryParams) {
    const $ = new RecentPlayer$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getRecentPlayer(queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function getRecentTeamPlayer(queryParams) {
    const $ = new RecentPlayer$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.getRecentTeamPlayer(queryParams);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  return {
    /**
     * Query user&#39;s recent player. Please ensure environment variable &#34;RECENT_PLAYER_ENABLED&#34; is set to &#34;TRUE&#34; to use this feature.
     */
    getRecentPlayer,
    /**
     * Query user&#39;s recent player who were on the same team. Please ensure environment variable &#34;RECENT_TEAM_PLAYER_ENABLED&#34; is set to &#34;TRUE&#34; to use this feature.
     */
    getRecentTeamPlayer
  };
}

// src/generated-public/SessionStorageApi.ts
var import_sdk38 = require("@accelbyte/sdk");
function SessionStorageApi(sdk, args) {
  const sdkAssembly = sdk.assembly();
  const namespace = args?.coreConfig?.namespace ?? sdkAssembly.coreConfig.namespace;
  const useSchemaValidation = args?.coreConfig?.useSchemaValidation ?? sdkAssembly.coreConfig.useSchemaValidation;
  let axiosInstance = sdkAssembly.axiosInstance;
  const requestConfigOverrides = args?.axiosConfig?.request;
  const baseURLOverride = args?.coreConfig?.baseURL;
  const interceptorsOverride = args?.axiosConfig?.interceptors ?? [];
  if (requestConfigOverrides || baseURLOverride || interceptorsOverride.length > 0) {
    const requestConfig = import_sdk38.ApiUtils.mergeAxiosConfigs(sdkAssembly.axiosInstance.defaults, {
      ...baseURLOverride ? { baseURL: baseURLOverride } : {},
      ...requestConfigOverrides
    });
    axiosInstance = import_sdk38.Network.create(requestConfig);
    for (const interceptor of interceptorsOverride) {
      if (interceptor.type === "request") {
        axiosInstance.interceptors.request.use(interceptor.onRequest, interceptor.onError);
      }
      if (interceptor.type === "response") {
        axiosInstance.interceptors.response.use(interceptor.onSuccess, interceptor.onError);
      }
    }
  }
  async function patchStorageLeader_BySessionId(sessionId) {
    const $ = new SessionStorage$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.patchStorageLeader_BySessionId(sessionId);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  async function patchStorageUser_BySessionId_ByUserId(sessionId, userId) {
    const $ = new SessionStorage$(axiosInstance, namespace, useSchemaValidation);
    const resp = await $.patchStorageUser_BySessionId_ByUserId(sessionId, userId);
    if (resp.error) throw resp.error;
    return resp.response;
  }
  return {
    /**
     *  Update Insert Session Storage Leader. only Leader can update or insert user session storage data Leader. can store generic json example json can store : { &#34;leader&#34;: { &#34;leader&#34;: 1 }, &#34;data&#34;: 123 } game Admin can update or insert session storage Session Storage feature only available for Gamesession
     */
    patchStorageLeader_BySessionId,
    /**
     *  Update Insert Session Storage User. user can only update or insert user session storage data itself. can store generic json example json can store : { &#34;storage&#34;: { &#34;storage&#34;: 1 }, &#34;data&#34;: 123 } game Admin can update or insert session storage Session Storage feature only available for Gamesession
     */
    patchStorageUser_BySessionId_ByUserId
  };
}

// package.json
var name = "@accelbyte/sdk-session";
var version = "5.0.4";
var author = "AccelByte Inc";

// src/Session.ts
console.log(`${name}@${version}`);
var apis = {
  ConfigAdminApi,
  DsmcDefaultConfigurationAdminApi,
  EnvironmentVariableAdminApi,
  GlobalConfigurationAdminApi,
  PartyAdminApi,
  ConfigurationTemplateAdminApi,
  GameSessionAdminApi,
  RecentPlayerAdminApi,
  NativeSessionAdminApi,
  PlayerAdminApi,
  PlatformCredentialAdminApi,
  SessionStorageAdminApi,
  CertificateAdminApi,
  MaxActiveAdminApi,
  PartyApi,
  GameSessionApi,
  RecentPlayerApi,
  PlayerApi,
  SessionStorageApi,
  version: () => console.log({
    version,
    name,
    author
  })
};
var Session = apis;
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  AppendTeamGameSessionRequest,
  CertificateAdmin$,
  CertificateAdminApi,
  ConfigAdmin$,
  ConfigAdminApi,
  ConfigAlertRequestCreate,
  ConfigAlertResponse,
  Configuration,
  ConfigurationTemplateAdmin$,
  ConfigurationTemplateAdminApi,
  ConfigurationTemplateResponse,
  ConfigurationTemplatesResponse,
  CreateConfigurationTemplateRequest,
  CreateGameSessionRequest,
  CreatePartyRequest,
  DefaultDsmcConfig,
  DeleteBulkGameSessionRequest,
  DeleteBulkGameSessionsApiResponse,
  DsInformationResponse,
  DsmConfigRecord,
  DsmcDefaultConfigurationAdmin$,
  DsmcDefaultConfigurationAdminApi,
  EnvironmentVariableAdmin$,
  EnvironmentVariableAdminApi,
  EnvironmentVariableListResponse,
  EnvironmentVariableResponse,
  Error,
  ExtendConfiguration,
  GameServer,
  GameSession$,
  GameSessionAdmin$,
  GameSessionAdminApi,
  GameSessionApi,
  GameSessionQueryResponse,
  GameSessionResponse,
  GlobalConfigurationAdmin$,
  GlobalConfigurationAdminApi,
  GlobalConfigurationResponse,
  JoinByCodeRequest,
  KickResponse,
  MaxActiveAdmin$,
  MaxActiveAdminApi,
  MemberActiveSession,
  NativeSession,
  NativeSessionAdmin$,
  NativeSessionAdminApi,
  NativeSessionMember,
  NativeSessionPagingResponse,
  NativeSessionSetting,
  Pagination,
  Party$,
  PartyAdmin$,
  PartyAdminApi,
  PartyApi,
  PartyMembers,
  PartyQueryResponse,
  PartySessionResponse,
  PlatformCredentialAdmin$,
  PlatformCredentialAdminApi,
  PlatformCredentials,
  Player$,
  PlayerAdmin$,
  PlayerAdminApi,
  PlayerApi,
  PlayerAttributesRequestBody,
  PlayerAttributesResponseBody,
  PlayerAttributesResponseBodyArray,
  PlayerPlatform,
  PlayersCurrentPlatformRequest,
  PlayersCurrentPlatformResponse,
  PortConfigurationAms,
  PromoteLeaderRequest,
  PsnAppServerCredentials,
  PublicConfiguration,
  PutGlobalConfigurationRequest,
  PutPlatformCredentialsRequest,
  RecentPlayer$,
  RecentPlayerAdmin$,
  RecentPlayerAdminApi,
  RecentPlayerApi,
  RecentPlayerQueryResponse,
  RequestMember,
  RequestReconcileMaxActiveSession,
  ResponseDeleteBulkGameSessions,
  ServerSecret,
  Session,
  SessionInviteRequest,
  SessionInviteResponse,
  SessionStorage$,
  SessionStorageAdmin$,
  SessionStorageAdminApi,
  SessionStorageApi,
  SessionStorageRequest,
  SetDsReadyRequest,
  Team,
  UpdateConfigurationTemplateRequest,
  UpdateGameSessionBackfillRequest,
  UpdateGameSessionMemberStatusResponse,
  UpdateGameSessionRequest,
  UpdatePartyRequest,
  UserInfoResponse,
  UserPlatformInfo,
  UserResponse
});

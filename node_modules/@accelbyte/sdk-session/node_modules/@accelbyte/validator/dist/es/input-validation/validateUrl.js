import isEmpty from 'validator/lib/isEmpty.js';
import { z } from 'zod';
import { CommonValidationErrorType } from './constant/errorType';
import { ValidateLengthErrorType, validateLength } from './validateLength';

const ValidateUrlErrorType = z.enum([...ValidateLengthErrorType.options, CommonValidationErrorType.enum.invalidFormat]);
const DEFAULT_MAX_URL_LENGTH = 2e3;
const INVALID_PROTOCOL_REGEX = /(javascript|vbscript):/;
const INVALID_PUNCTUATION_REGEX = /[{}|`~,]/;
const validateUrl = (value, { isRequired = true, allowCustomProtocol = false } = {}) => {
  if (isEmpty(value)) {
    if (!isRequired) {
      return null;
    }
    return ValidateUrlErrorType.enum.empty;
  }
  const validateLengthResult = validateLength(value, { max: DEFAULT_MAX_URL_LENGTH });
  if (validateLengthResult) return validateLengthResult;
  try {
    const url = new URL(value);
    if (isContainingInvalidPunctuations(url)) {
      throw new Error("URL should not contain invalid punctuations");
    }
    if (!allowCustomProtocol && INVALID_PROTOCOL_REGEX.test(url.protocol)) {
      throw new Error("URL should not use an invalid protocol");
    }
    return null;
  } catch (err) {
    return ValidateUrlErrorType.enum.invalidFormat;
  }
};
const isContainingInvalidPunctuations = (url) => {
  const scheme = `${url.protocol}//`;
  let schemeEndIndex = url.href.indexOf(`${url.protocol}//`);
  if (schemeEndIndex === -1) {
    schemeEndIndex = url.protocol.length;
  } else {
    schemeEndIndex = scheme.length;
  }
  const mainUrlBody = url.href.slice(schemeEndIndex);
  return INVALID_PUNCTUATION_REGEX.test(mainUrlBody);
};

export { ValidateUrlErrorType, validateUrl };
//# sourceMappingURL=validateUrl.js.map
//# sourceMappingURL=validateUrl.js.map
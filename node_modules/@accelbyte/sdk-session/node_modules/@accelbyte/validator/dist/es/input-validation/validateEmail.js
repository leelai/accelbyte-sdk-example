import isEmpty from 'validator/lib/isEmpty.js';
import matches from 'validator/lib/matches.js';
import { z } from 'zod';
import { CommonValidationErrorType } from './constant/errorType';
import { MAX_EMAIL_LENGTH } from './constant/numbers';
import { ValidateLengthErrorType, validateLength } from './validateLength';
import { validateForbiddenWords } from './validateForbiddenWords';

const ValidateEmailErrorType = z.enum([
  ...ValidateLengthErrorType.options,
  CommonValidationErrorType.enum.invalidFormat,
  CommonValidationErrorType.enum.containsForbiddenWords
]);
const validateEmail = (value, { blockedWord = [], isRequired = true, customRegex, maxLength, minLength } = {}) => {
  const REGEX = "^[a-zA-Z0-9_+&*-]+(?:\\.[a-zA-Z0-9_+&*-]+)*@(?:[a-zA-Z0-9-]+\\.)+[a-zA-Z]{2,15}$";
  if (isRequired && isEmpty(value)) return ValidateEmailErrorType.enum.empty;
  if (blockedWord.length > 0) {
    if (validateForbiddenWords(value, blockedWord)) return ValidateEmailErrorType.enum.containsForbiddenWords;
  }
  if (!matches(value, customRegex || REGEX)) return ValidateEmailErrorType.enum.invalidFormat;
  return validateLength(value, { max: maxLength || MAX_EMAIL_LENGTH, min: minLength });
};

export { ValidateEmailErrorType, validateEmail };
//# sourceMappingURL=validateEmail.js.map
//# sourceMappingURL=validateEmail.js.map